        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/OperationSupport.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcda
        -:    0:Runs:116164
        -:    1://===- OperationSupport.cpp -----------------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains out-of-line implementations of the support types that
        -:   10:// Operation and related classes build on top of.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/OperationSupport.h"
        -:   15:#include "mlir/IR/BuiltinAttributes.h"
        -:   16:#include "mlir/IR/BuiltinTypes.h"
        -:   17:#include "mlir/IR/OpDefinition.h"
        -:   18:#include "llvm/ADT/BitVector.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23://===----------------------------------------------------------------------===//
        -:   24:// NamedAttrList
        -:   25://===----------------------------------------------------------------------===//
        -:   26:
function _ZN4mlir13NamedAttrListC2EN4llvm8ArrayRefINS_14NamedAttributeEEE called 66226 returned 100% blocks executed 100%
    66226:   27:NamedAttrList::NamedAttrList(ArrayRef<NamedAttribute> attributes) {
call    0 returned 100%
260988097:   28:  assign(attributes.begin(), attributes.end());
call    0 returned 100%
call    1 returned 100%
    66226:   29:}
        -:   30:
function _ZN4mlir13NamedAttrListC2ENS_14DictionaryAttrE called 260921876 returned 100% blocks executed 86%
260921876:   31:NamedAttrList::NamedAttrList(DictionaryAttr attributes)
260921876:   32:    : NamedAttrList(attributes ? attributes.getValue()
call    0 returned 100%
521843747:   33:                               : ArrayRef<NamedAttribute>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
260921859:   34:  dictionarySorted.setPointerAndInt(attributes, true);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
260921859:   35:}
        -:   36:
function _ZN4mlir13NamedAttrListC2EPKNS_14NamedAttributeES3_ called 0 returned 0% blocks executed 0%
 2504546*:   37:NamedAttrList::NamedAttrList(const_iterator inStart, const_iterator inEnd) {
call    0 returned 100%
call    1 never executed
 5009092*:   38:  assign(inStart, inEnd);
    #####:   39:}
        -:   40:
function _ZNK4mlir13NamedAttrList8getAttrsEv called 1736551 returned 100% blocks executed 100%
  1736551:   41:ArrayRef<NamedAttribute> NamedAttrList::getAttrs() const { return attrs; }
        -:   42:
function _ZNK4mlir13NamedAttrList13findDuplicateEv called 206951871 returned 100% blocks executed 100%
206951871:   43:Optional<NamedAttribute> NamedAttrList::findDuplicate() const {
206951871:   44:  Optional<NamedAttribute> duplicate =
call    0 returned 100%
206951871:   45:      DictionaryAttr::findDuplicate(attrs, isSorted());
call    0 returned 100%
        -:   46:  // DictionaryAttr::findDuplicate will sort the list, so reset the sorted
        -:   47:  // state.
206951871:   48:  if (!isSorted())
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
  4946122:   49:    dictionarySorted.setPointerAndInt(nullptr, true);
206951871:   50:  return duplicate;
        -:   51:}
        -:   52:
function _ZNK4mlir13NamedAttrList13getDictionaryEPNS_11MLIRContextE called 524870956 returned 100% blocks executed 100%
524870956:   53:DictionaryAttr NamedAttrList::getDictionary(MLIRContext *context) const {
524870956:   54:  if (!isSorted()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
   980428:   55:    DictionaryAttr::sortInPlace(attrs);
call    0 returned 100%
   980428:   56:    dictionarySorted.setPointerAndInt(nullptr, true);
        -:   57:  }
524870956:   58:  if (!dictionarySorted.getPointer())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
268505316:   59:    dictionarySorted.setPointer(DictionaryAttr::getWithSorted(context, attrs));
call    0 returned 100%
call    1 returned 100%
524870966:   60:  return dictionarySorted.getPointer().cast<DictionaryAttr>();
call    0 returned 100%
        -:   61:}
        -:   62:
        -:   63:/// Add an attribute with the specified name.
function _ZN4mlir13NamedAttrList6appendEN4llvm9StringRefENS_9AttributeE called 30042803 returned 100% blocks executed 100%
 30042803:   64:void NamedAttrList::append(StringRef name, Attribute attr) {
 30042803:   65:  append(StringAttr::get(attr.getContext(), name), attr);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 30042803:   66:}
        -:   67:
        -:   68:/// Replaces the attributes with new list of attributes.
function _ZN4mlir13NamedAttrList6assignEPKNS_14NamedAttributeES3_ called 2113286 returned 100% blocks executed 100%
265605929*:   69:void NamedAttrList::assign(const_iterator inStart, const_iterator inEnd) {
265605929*:   70:  DictionaryAttr::sort(ArrayRef<NamedAttribute>{inStart, inEnd}, attrs);
call    0 returned 100%
call    1 never executed
call    2 returned 100%
call    3 never executed
call    4 returned 100%
call    5 returned 100%
263426405*:   71:  dictionarySorted.setPointerAndInt(nullptr, true);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  2113286:   72:}
        -:   73:
function _ZN4mlir13NamedAttrList9push_backENS_14NamedAttributeE called 116475758 returned 100% blocks executed 100%
116475758:   74:void NamedAttrList::push_back(NamedAttribute newAttribute) {
116475758:   75:  if (isSorted())
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
135333068:   76:    dictionarySorted.setInt(attrs.empty() || attrs.back() < newAttribute);
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 80% (fallthrough)
branch  5 taken 20%
116475758:   77:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
116475772:   78:  attrs.push_back(newAttribute);
call    0 returned 100%
116475773:   79:}
        -:   80:
        -:   81:/// Return the specified attribute if present, null otherwise.
function _ZNK4mlir13NamedAttrList3getEN4llvm9StringRefE called 7044463 returned 100% blocks executed 100%
  7044463:   82:Attribute NamedAttrList::get(StringRef name) const {
  7044463:   83:  auto it = findAttr(*this, name);
call    0 returned 100%
  7044463:   84:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:   85:}
function _ZNK4mlir13NamedAttrList3getENS_10StringAttrE called 23085896 returned 100% blocks executed 100%
 23085896:   86:Attribute NamedAttrList::get(StringAttr name) const {
 23085896:   87:  auto it = findAttr(*this, name);
call    0 returned 100%
 23085896:   88:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -:   89:}
        -:   90:
        -:   91:/// Return the specified named attribute if present, None otherwise.
function _ZNK4mlir13NamedAttrList8getNamedEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   92:Optional<NamedAttribute> NamedAttrList::getNamed(StringRef name) const {
    #####:   93:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   94:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:   95:}
function _ZNK4mlir13NamedAttrList8getNamedENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:   96:Optional<NamedAttribute> NamedAttrList::getNamed(StringAttr name) const {
    #####:   97:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   98:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:   99:}
        -:  100:
        -:  101:/// If the an attribute exists with the specified name, change it to the new
        -:  102:/// value.  Otherwise, add a new attribute with the specified name/value.
function _ZN4mlir13NamedAttrList3setENS_10StringAttrENS_9AttributeE called 6019122 returned 100% blocks executed 89%
  6019122:  103:Attribute NamedAttrList::set(StringAttr name, Attribute value) {
 6019122*:  104:  assert(value && "attributes may never be null");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  105:
        -:  106:  // Look for an existing attribute with the given name, and set its value
        -:  107:  // in-place. Return the previous value of the attribute, if there was one.
  6019122:  108:  auto it = findAttr(*this, name);
call    0 returned 100%
  6019120:  109:  if (it.second) {
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
        -:  110:    // Update the existing attribute by swapping out the old value for the new
        -:  111:    // value. Return the old value.
  2025162:  112:    Attribute oldValue = it.first->getValue();
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  2025162:  113:    if (it.first->getValue() != value) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  2013992:  114:      it.first->setValue(value);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:
        -:  116:      // If the attributes have changed, the dictionary is invalidated.
  2013992:  117:      dictionarySorted.setPointer(nullptr);
call    0 returned 100%
        -:  118:    }
  2025162:  119:    return oldValue;
        -:  120:  }
        -:  121:  // Perform a string lookup to insert the new attribute into its sorted
        -:  122:  // position.
  3993958:  123:  if (isSorted())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  3993958:  124:    it = findAttr(*this, name.strref());
call    0 returned 100%
call    1 returned 100%
  3993960:  125:  attrs.insert(it.first, {name, value});
call    0 returned 100%
call    1 returned 100%
        -:  126:  // Invalidate the dictionary. Return null as there was no previous value.
  3993960:  127:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
  3993960:  128:  return Attribute();
        -:  129:}
        -:  130:
function _ZN4mlir13NamedAttrList3setEN4llvm9StringRefENS_9AttributeE called 3878961 returned 100% blocks executed 86%
  3878961:  131:Attribute NamedAttrList::set(StringRef name, Attribute value) {
 3878961*:  132:  assert(value && "attributes may never be null");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  3878961:  133:  return set(mlir::StringAttr::get(value.getContext(), name), value);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  134:}
        -:  135:
        -:  136:Attribute
function _ZN4mlir13NamedAttrList9eraseImplEPNS_14NamedAttributeE called 66227 returned 100% blocks executed 100%
    66227:  137:NamedAttrList::eraseImpl(SmallVectorImpl<NamedAttribute>::iterator it) {
        -:  138:  // Erasing does not affect the sorted property.
    66227:  139:  Attribute attr = it->getValue();
call    0 returned 100%
    66227:  140:  attrs.erase(it);
call    0 returned 100%
    66227:  141:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
    66227:  142:  return attr;
        -:  143:}
        -:  144:
function _ZN4mlir13NamedAttrList5eraseENS_10StringAttrE called 795009 returned 100% blocks executed 100%
   795009:  145:Attribute NamedAttrList::erase(StringAttr name) {
   795009:  146:  auto it = findAttr(*this, name);
call    0 returned 100%
   795008:  147:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  148:}
        -:  149:
function _ZN4mlir13NamedAttrList5eraseEN4llvm9StringRefE called 66226 returned 100% blocks executed 80%
    66226:  150:Attribute NamedAttrList::erase(StringRef name) {
    66226:  151:  auto it = findAttr(*this, name);
call    0 returned 100%
   66226*:  152:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  153:}
        -:  154:
        -:  155:NamedAttrList &
function _ZN4mlir13NamedAttrListaSERKN4llvm15SmallVectorImplINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  156:NamedAttrList::operator=(const SmallVectorImpl<NamedAttribute> &rhs) {
    #####:  157:  assign(rhs.begin(), rhs.end());
call    0 never executed
    #####:  158:  return *this;
        -:  159:}
        -:  160:
function _ZNK4mlir13NamedAttrListcvN4llvm8ArrayRefINS_14NamedAttributeEEEEv called 0 returned 0% blocks executed 0%
    #####:  161:NamedAttrList::operator ArrayRef<NamedAttribute>() const { return attrs; }
        -:  162:
        -:  163://===----------------------------------------------------------------------===//
        -:  164:// OperationState
        -:  165://===----------------------------------------------------------------------===//
        -:  166:
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefE called 1311367 returned 100% blocks executed 100%
  1311367:  167:OperationState::OperationState(Location location, StringRef name)
  1311367:  168:    : location(location), name(name, location->getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  169:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameE called 246349244 returned 100% blocks executed 100%
246349244:  170:OperationState::OperationState(Location location, OperationName name)
246349244:  171:    : location(location), name(name) {}
call    0 returned 100%
        -:  172:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameENS_10ValueRangeENS_9TypeRangeEN4llvm8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS5_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 2504546 returned 100% blocks executed 78%
  2504546:  173:OperationState::OperationState(Location location, OperationName name,
        -:  174:                               ValueRange operands, TypeRange types,
        -:  175:                               ArrayRef<NamedAttribute> attributes,
        -:  176:                               BlockRange successors,
  2504546:  177:                               MutableArrayRef<std::unique_ptr<Region>> regions)
        -:  178:    : location(location), name(name),
        -:  179:      operands(operands.begin(), operands.end()),
        -:  180:      types(types.begin(), types.end()),
        -:  181:      attributes(attributes.begin(), attributes.end()),
  2504546:  182:      successors(successors.begin(), successors.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 2504546*:  183:  for (std::unique_ptr<Region> &r : regions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  184:    this->regions.push_back(std::move(r));
call    0 never executed
  2504546:  185:}
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefENS_10ValueRangeENS_9TypeRangeENS2_8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS2_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 2504546 returned 100% blocks executed 100%
  2504546:  186:OperationState::OperationState(Location location, StringRef name,
        -:  187:                               ValueRange operands, TypeRange types,
        -:  188:                               ArrayRef<NamedAttribute> attributes,
        -:  189:                               BlockRange successors,
  2504546:  190:                               MutableArrayRef<std::unique_ptr<Region>> regions)
call    0 returned 100%
        -:  191:    : OperationState(location, OperationName(name, location.getContext()),
  2504546:  192:                     operands, types, attributes, successors, regions) {}
call    0 returned 100%
call    1 returned 100%
        -:  193:
function _ZN4mlir14OperationState11addOperandsENS_10ValueRangeE called 38922413 returned 100% blocks executed 100%
 38922413:  194:void OperationState::addOperands(ValueRange newOperands) {
 38922413:  195:  operands.append(newOperands.begin(), newOperands.end());
call    0 returned 100%
 38922413:  196:}
        -:  197:
function _ZN4mlir14OperationState13addSuccessorsENS_10BlockRangeE called 4 returned 100% blocks executed 100%
        4:  198:void OperationState::addSuccessors(BlockRange newSuccessors) {
        4:  199:  successors.append(newSuccessors.begin(), newSuccessors.end());
call    0 returned 100%
        4:  200:}
        -:  201:
function _ZN4mlir14OperationState9addRegionEv called 6779550 returned 100% blocks executed 100%
  6779550:  202:Region *OperationState::addRegion() {
  6779550:  203:  regions.emplace_back(new Region);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  6779550:  204:  return regions.back().get();
call    0 returned 100%
        -:  205:}
        -:  206:
function _ZN4mlir14OperationState9addRegionEOSt10unique_ptrINS_6RegionESt14default_deleteIS2_EE called 3595093 returned 100% blocks executed 100%
  5048673:  207:void OperationState::addRegion(std::unique_ptr<Region> &&region) {
  5048673:  208:  regions.push_back(std::move(region));
call    0 returned 100%
call    1 returned 100%
  3595093:  209:}
        -:  210:
function _ZN4mlir14OperationState10addRegionsEN4llvm15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteIS4_EEEE called 607637 returned 100% blocks executed 100%
   607637:  211:void OperationState::addRegions(
        -:  212:    MutableArrayRef<std::unique_ptr<Region>> regions) {
  2061217:  213:  for (std::unique_ptr<Region> &region : regions)
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
  1453580:  214:    addRegion(std::move(region));
call    0 returned 100%
   607637:  215:}
        -:  216:
        -:  217://===----------------------------------------------------------------------===//
        -:  218:// OperandStorage
        -:  219://===----------------------------------------------------------------------===//
        -:  220:
function _ZN4mlir6detail14OperandStorageC2EPNS_9OperationEPNS_9OpOperandENS_10ValueRangeE called 232175448 returned 100% blocks executed 100%
232175448:  221:detail::OperandStorage::OperandStorage(Operation *owner,
        -:  222:                                       OpOperand *trailingOperands,
232175448:  223:                                       ValueRange values)
232175448:  224:    : isStorageDynamic(false), operandStorage(trailingOperands) {
232175448:  225:  numOperands = capacity = values.size();
847422055:  226:  for (unsigned i = 0; i < numOperands; ++i)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
1162376852:  227:    new (&operandStorage[i]) OpOperand(owner, values[i]);
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
232175448:  228:}
        -:  229:
function _ZN4mlir6detail14OperandStorageD2Ev called 231540371 returned 100% blocks executed 100%
463080742:  230:detail::OperandStorage::~OperandStorage() {
864181049:  231:  for (auto &operand : getOperands())
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
710252822:  232:    operand.~OpOperand();
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  233:
        -:  234:  // If the storage is dynamic, deallocate it.
231540371:  235:  if (isStorageDynamic)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
  6558234:  236:    free(operandStorage);
231540371:  237:}
        -:  238:
        -:  239:/// Replace the operands contained in the storage with the ones provided in
        -:  240:/// 'values'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationENS_10ValueRangeE called 7190879 returned 100% blocks executed 92%
  7190879:  241:void detail::OperandStorage::setOperands(Operation *owner, ValueRange values) {
  7190879:  242:  MutableArrayRef<OpOperand> storageOperands = resize(owner, values.size());
call    0 returned 100%
 26421439:  243:  for (unsigned i = 0, e = values.size(); i != e; ++i)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
 38461120:  244:    storageOperands[i].set(values[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
  7190879:  245:}
        -:  246:
        -:  247:/// Replace the operands beginning at 'start' and ending at 'start' + 'length'
        -:  248:/// with the ones provided in 'operands'. 'operands' may be smaller or larger
        -:  249:/// than the range pointed to by 'start'+'length'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationEjjNS_10ValueRangeE called 3861 returned 100% blocks executed 79%
     3861:  250:void detail::OperandStorage::setOperands(Operation *owner, unsigned start,
        -:  251:                                         unsigned length, ValueRange operands) {
        -:  252:  // If the new size is the same, we can update inplace.
     3861:  253:  unsigned newSize = operands.size();
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
     3861:  254:  if (newSize == length) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
     2371:  255:    MutableArrayRef<OpOperand> storageOperands = getOperands();
     3322:  256:    for (unsigned i = 0, e = length; i != e; ++i)
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
     1902:  257:      storageOperands[start + i].set(operands[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  258:    return;
        -:  259:  }
        -:  260:  // If the new size is greater, remove the extra operands and set the rest
        -:  261:  // inplace.
     1490:  262:  if (newSize < length) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
     1195:  263:    eraseOperands(start + operands.size(), length - newSize);
call    0 returned 100%
     1195:  264:    setOperands(owner, start, newSize, operands);
     1195:  265:    return;
call    0 returned 100%
        -:  266:  }
        -:  267:  // Otherwise, the new size is greater so we need to grow the storage.
      295:  268:  auto storageOperands = resize(owner, size() + (newSize - length));
call    0 returned 100%
        -:  269:
        -:  270:  // Shift operands to the right to make space for the new operands.
      295:  271:  unsigned rotateSize = storageOperands.size() - (start + length);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      295:  272:  auto rbegin = storageOperands.rbegin();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      590:  273:  std::rotate(rbegin, std::next(rbegin, newSize - length), rbegin + rotateSize);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  274:
        -:  275:  // Update the operands inplace.
      590:  276:  for (unsigned i = 0, e = operands.size(); i != e; ++i)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      590:  277:    storageOperands[start + i].set(operands[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  278:}
        -:  279:
        -:  280:/// Erase an operand held by the storage.
function _ZN4mlir6detail14OperandStorage13eraseOperandsEjj called 1331 returned 100% blocks executed 45%
     1331:  281:void detail::OperandStorage::eraseOperands(unsigned start, unsigned length) {
     1331:  282:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    1331*:  283:  assert((start + length) <= operands.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     1331:  284:  numOperands -= length;
        -:  285:
        -:  286:  // Shift all operands down if the operand to remove is not at the end.
     1331:  287:  if (start != numOperands) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  288:    auto *indexIt = std::next(operands.begin(), start);
branch  0 never executed
branch  1 never executed
    #####:  289:    std::rotate(indexIt, std::next(indexIt, length), operands.end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  290:  }
     2662:  291:  for (unsigned i = 0; i != length; ++i)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     2662:  292:    operands[numOperands + i].~OpOperand();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1331:  293:}
        -:  294:
function _ZN4mlir6detail14OperandStorage13eraseOperandsERKN4llvm9BitVectorE called 0 returned 0% blocks executed 0%
    #####:  295:void detail::OperandStorage::eraseOperands(const BitVector &eraseIndices) {
    #####:  296:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 never executed
branch  1 never executed
    #####:  297:  assert(eraseIndices.size() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  298:
        -:  299:  // Check that at least one operand is erased.
    #####:  300:  int firstErasedIndice = eraseIndices.find_first();
call    0 never executed
    #####:  301:  if (firstErasedIndice == -1)
branch  0 never executed
branch  1 never executed
    #####:  302:    return;
        -:  303:
        -:  304:  // Shift all of the removed operands to the end, and destroy them.
    #####:  305:  numOperands = firstErasedIndice;
    #####:  306:  for (unsigned i = firstErasedIndice + 1, e = operands.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  307:    if (!eraseIndices.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  308:      operands[numOperands++] = std::move(operands[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  309:  for (OpOperand &operand : operands.drop_front(numOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  310:    operand.~OpOperand();
branch  0 never executed
branch  1 never executed
        -:  311:}
        -:  312:
        -:  313:/// Resize the storage to the given size. Returns the array containing the new
        -:  314:/// operands.
function _ZN4mlir6detail14OperandStorage6resizeEPNS_9OperationEj called 7191174 returned 100% blocks executed 87%
  7191174:  315:MutableArrayRef<OpOperand> detail::OperandStorage::resize(Operation *owner,
        -:  316:                                                          unsigned newSize) {
        -:  317:  // If the number of operands is less than or equal to the current amount, we
        -:  318:  // can just update in place.
  7191174:  319:  MutableArrayRef<OpOperand> origOperands = getOperands();
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
  7191174:  320:  if (newSize <= numOperands) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        -:  321:    // If the number of new size is less than the current, remove any extra
        -:  322:    // operands.
   991734:  323:    for (unsigned i = newSize; i != numOperands; ++i)
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
   718438:  324:      origOperands[i].~OpOperand();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   632515:  325:    numOperands = newSize;
   632515:  326:    return origOperands.take_front(newSize);
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
        -:  327:  }
        -:  328:
        -:  329:  // If the new size is within the original inline capacity, grow inplace.
  6558659:  330:  if (newSize <= capacity) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      776:  331:    OpOperand *opBegin = origOperands.data();
      776:  332:    for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
      407:  333:      new (&opBegin[numOperands]) OpOperand(owner);
      369:  334:    return MutableArrayRef<OpOperand>(opBegin, newSize);
        -:  335:  }
        -:  336:
        -:  337:  // Otherwise, we need to allocate a new storage.
  6558290:  338:  unsigned newCapacity =
  6558290:  339:      std::max(unsigned(llvm::NextPowerOf2(capacity + 2)), newSize);
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
  6558290:  340:  OpOperand *newOperandStorage =
  6558290:  341:      reinterpret_cast<OpOperand *>(malloc(sizeof(OpOperand) * newCapacity));
        -:  342:
        -:  343:  // Move the current operands to the new storage.
  6558290:  344:  MutableArrayRef<OpOperand> newOperands(newOperandStorage, newSize);
  6558290:  345:  std::uninitialized_move(origOperands.begin(), origOperands.end(),
        -:  346:                          newOperands.begin());
        -:  347:
        -:  348:  // Destroy the original operands.
  6559505:  349:  for (auto &operand : origOperands)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     1215:  350:    operand.~OpOperand();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  351:
        -:  352:  // Initialize any new operands.
 25785995:  353:  for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
 19227705:  354:    new (&newOperands[numOperands]) OpOperand(owner);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  355:
        -:  356:  // If the current storage is dynamic, free it.
  6558290:  357:  if (isStorageDynamic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  358:    free(operandStorage);
        -:  359:
        -:  360:  // Update the storage representation to use the new dynamic storage.
  6558290:  361:  operandStorage = newOperandStorage;
  6558290:  362:  capacity = newCapacity;
  6558290:  363:  isStorageDynamic = true;
  6558290:  364:  return newOperands;
        -:  365:}
        -:  366:
        -:  367://===----------------------------------------------------------------------===//
        -:  368:// Operation Value-Iterators
        -:  369://===----------------------------------------------------------------------===//
        -:  370:
        -:  371://===----------------------------------------------------------------------===//
        -:  372:// OperandRange
        -:  373:
function _ZNK4mlir12OperandRange20getBeginOperandIndexEv called 280 returned 100% blocks executed 75%
      280:  374:unsigned OperandRange::getBeginOperandIndex() const {
     280*:  375:  assert(!empty() && "range must not be empty");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      280:  376:  return base->getOperandNumber();
call    0 returned 100%
        -:  377:}
        -:  378:
function _ZNK4mlir12OperandRange5splitENS_6detail18DenseArrayAttrImplIiEE called 0 returned 0% blocks executed 0%
    #####:  379:OperandRangeRange OperandRange::split(DenseI32ArrayAttr segmentSizes) const {
    #####:  380:  return OperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  381:}
        -:  382:
        -:  383://===----------------------------------------------------------------------===//
        -:  384:// OperandRangeRange
        -:  385:
function _ZN4mlir17OperandRangeRangeC2ENS_12OperandRangeENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  386:OperandRangeRange::OperandRangeRange(OperandRange operands,
    #####:  387:                                     Attribute operandSegments)
call    0 never executed
        -:  388:    : OperandRangeRange(OwnerT(operands.getBase(), operandSegments), 0,
    #####:  389:                        operandSegments.cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
        -:  390:
function _ZNK4mlir17OperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  391:OperandRange OperandRangeRange::join() const {
    #####:  392:  const OwnerT &owner = getBase();
call    0 never executed
    #####:  393:  ArrayRef<int32_t> sizeData = owner.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  394:  return OperandRange(owner.first,
    #####:  395:                      std::accumulate(sizeData.begin(), sizeData.end(), 0));
        -:  396:}
        -:  397:
function _ZN4mlir17OperandRangeRange11dereferenceERKSt4pairIPNS_9OpOperandENS_9AttributeEEl called 0 returned 0% blocks executed 0%
    #####:  398:OperandRange OperandRangeRange::dereference(const OwnerT &object,
        -:  399:                                            ptrdiff_t index) {
    #####:  400:  ArrayRef<int32_t> sizeData = object.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  401:  uint32_t startIndex =
    #####:  402:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  403:  return OperandRange(object.first + startIndex, *(sizeData.begin() + index));
        -:  404:}
        -:  405:
        -:  406://===----------------------------------------------------------------------===//
        -:  407:// MutableOperandRange
        -:  408:
        -:  409:/// Construct a new mutable range from the given operand, operand start index,
        -:  410:/// and range length.
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationEjjN4llvm8ArrayRefISt4pairIjNS_14NamedAttributeEEEE called 769017861 returned 100% blocks executed 75%
769017861:  411:MutableOperandRange::MutableOperandRange(
        -:  412:    Operation *owner, unsigned start, unsigned length,
769017861:  413:    ArrayRef<OperandSegment> operandSegments)
        -:  414:    : owner(owner), start(start), length(length),
769017861:  415:      operandSegments(operandSegments.begin(), operandSegments.end()) {
call    0 returned 100%
1538035718*:  416:  assert((start + length) <= owner->getNumOperands() && "invalid range");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
769017859:  417:}
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationE called 721749131 returned 100% blocks executed 83%
721749131:  418:MutableOperandRange::MutableOperandRange(Operation *owner)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
1443498262:  419:    : MutableOperandRange(owner, /*start=*/0, owner->getNumOperands()) {}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  420:
        -:  421:/// Slice this range into a sub range, with the additional operand segment.
        -:  422:MutableOperandRange
function _ZNK4mlir19MutableOperandRange5sliceEjjN4llvm8OptionalISt4pairIjNS_14NamedAttributeEEEE called 1622 returned 100% blocks executed 67%
     1622:  423:MutableOperandRange::slice(unsigned subStart, unsigned subLen,
        -:  424:                           Optional<OperandSegment> segment) const {
    1622*:  425:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     1622:  426:  MutableOperandRange subSlice(owner, start + subStart, subLen,
     1622:  427:                               operandSegments);
call    0 returned 100%
     1622:  428:  if (segment)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  429:    subSlice.operandSegments.push_back(*segment);
call    0 never executed
     1622:  430:  return subSlice;
        -:  431:}
        -:  432:
        -:  433:/// Append the given values to the range.
function _ZN4mlir19MutableOperandRange6appendENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  434:void MutableOperandRange::append(ValueRange values) {
    #####:  435:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  436:    return;
    #####:  437:  owner->insertOperands(start + length, values);
call    0 never executed
    #####:  438:  updateLength(length + values.size());
call    0 never executed
        -:  439:}
        -:  440:
        -:  441:/// Assign this range to the given values.
function _ZN4mlir19MutableOperandRange6assignENS_10ValueRangeE called 2371 returned 100% blocks executed 100%
     2371:  442:void MutableOperandRange::assign(ValueRange values) {
     2371:  443:  owner->setOperands(start, length, values);
call    0 returned 100%
     2371:  444:  if (length != values.size())
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1195:  445:    updateLength(/*newLength=*/values.size());
call    0 returned 100%
     2371:  446:}
        -:  447:
        -:  448:/// Assign the range to the given value.
function _ZN4mlir19MutableOperandRange6assignENS_5ValueE called 217394 returned 100% blocks executed 100%
   217394:  449:void MutableOperandRange::assign(Value value) {
   217394:  450:  if (length == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   217099:  451:    owner->setOperand(start, value);
call    0 returned 100%
        -:  452:  } else {
      295:  453:    owner->setOperands(start, length, value);
call    0 returned 100%
call    1 returned 100%
      295:  454:    updateLength(/*newLength=*/1);
call    0 returned 100%
        -:  455:  }
   217394:  456:}
        -:  457:
        -:  458:/// Erase the operands within the given sub-range.
function _ZN4mlir19MutableOperandRange5eraseEjj called 136 returned 100% blocks executed 83%
      136:  459:void MutableOperandRange::erase(unsigned subStart, unsigned subLen) {
     136*:  460:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      136:  461:  if (length == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  462:    return;
      136:  463:  owner->eraseOperands(start + subStart, subLen);
call    0 returned 100%
      136:  464:  updateLength(length - subLen);
call    0 returned 100%
        -:  465:}
        -:  466:
        -:  467:/// Clear this range and erase all of the operands.
function _ZN4mlir19MutableOperandRange5clearEv called 0 returned 0% blocks executed 0%
    #####:  468:void MutableOperandRange::clear() {
    #####:  469:  if (length != 0) {
branch  0 never executed
branch  1 never executed
    #####:  470:    owner->eraseOperands(start, length);
call    0 never executed
    #####:  471:    updateLength(/*newLength=*/0);
call    0 never executed
        -:  472:  }
    #####:  473:}
        -:  474:
        -:  475:/// Allow implicit conversion to an OperandRange.
function _ZNK4mlir19MutableOperandRangecvNS_12OperandRangeEEv called 768784510 returned 100% blocks executed 100%
768784510:  476:MutableOperandRange::operator OperandRange() const {
768784510:  477:  return owner->getOperands().slice(start, length);
call    0 returned 100%
call    1 returned 100%
        -:  478:}
        -:  479:
        -:  480:MutableOperandRangeRange
function _ZNK4mlir19MutableOperandRange5splitENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  481:MutableOperandRange::split(NamedAttribute segmentSizes) const {
    #####:  482:  return MutableOperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  483:}
        -:  484:
        -:  485:/// Update the length of this range to the one provided.
function _ZN4mlir19MutableOperandRange12updateLengthEj called 1626 returned 100% blocks executed 82%
     1626:  486:void MutableOperandRange::updateLength(unsigned newLength) {
     1626:  487:  int32_t diff = int32_t(newLength) - int32_t(length);
     1626:  488:  length = newLength;
        -:  489:
        -:  490:  // Update any of the provided segment attributes.
     1969:  491:  for (OperandSegment &segment : operandSegments) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
      343:  492:    auto attr = segment.second.getValue().cast<DenseI32ArrayAttr>();
call    0 returned 100%
      686:  493:    SmallVector<int32_t, 8> segments(attr.asArrayRef());
call    0 returned 100%
call    1 returned 100%
      343:  494:    segments[segment.first] += diff;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      343:  495:    segment.second.setValue(
call    0 returned 100%
      343:  496:        DenseI32ArrayAttr::get(attr.getContext(), segments));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      343:  497:    owner->setAttr(segment.second.getName(), segment.second.getValue());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  498:  }
     1626:  499:}
        -:  500:
        -:  501://===----------------------------------------------------------------------===//
        -:  502:// MutableOperandRangeRange
        -:  503:
function _ZN4mlir24MutableOperandRangeRangeC2ERKNS_19MutableOperandRangeENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  504:MutableOperandRangeRange::MutableOperandRangeRange(
    #####:  505:    const MutableOperandRange &operands, NamedAttribute operandSegmentAttr)
        -:  506:    : MutableOperandRangeRange(
    #####:  507:          OwnerT(operands, operandSegmentAttr), 0,
call    0 never executed
    #####:  508:          operandSegmentAttr.getValue().cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  509:
function _ZNK4mlir24MutableOperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  510:MutableOperandRange MutableOperandRangeRange::join() const {
    #####:  511:  return getBase().first;
branch  0 never executed
branch  1 never executed
        -:  512:}
        -:  513:
function _ZNK4mlir24MutableOperandRangeRangecvNS_17OperandRangeRangeEEv called 0 returned 0% blocks executed 0%
    #####:  514:MutableOperandRangeRange::operator OperandRangeRange() const {
    #####:  515:  return OperandRangeRange(getBase().first, getBase().second.getValue());
call    0 never executed
call    1 never executed
        -:  516:}
        -:  517:
function _ZN4mlir24MutableOperandRangeRange11dereferenceERKSt4pairINS_19MutableOperandRangeENS_14NamedAttributeEEl called 0 returned 0% blocks executed 0%
    #####:  518:MutableOperandRange MutableOperandRangeRange::dereference(const OwnerT &object,
        -:  519:                                                          ptrdiff_t index) {
    #####:  520:  ArrayRef<int32_t> sizeData =
    #####:  521:      object.second.getValue().cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  522:  uint32_t startIndex =
    #####:  523:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  524:  return object.first.slice(
    #####:  525:      startIndex, *(sizeData.begin() + index),
call    0 never executed
    #####:  526:      MutableOperandRange::OperandSegment(index, object.second));
call    0 never executed
        -:  527:}
        -:  528:
        -:  529://===----------------------------------------------------------------------===//
        -:  530:// ResultRange
        -:  531:
function _ZN4mlir11ResultRangeC2ENS_8OpResultE called 50537 returned 100% blocks executed 100%
    50537:  532:ResultRange::ResultRange(OpResult result)
    50537:  533:    : ResultRange(static_cast<detail::OpResultImpl *>(Value(result).getImpl()),
    50537:  534:                  1) {}
        -:  535:
function _ZNK4mlir11ResultRange7getUsesEv called 15584 returned 100% blocks executed 100%
    15584:  536:ResultRange::use_range ResultRange::getUses() const {
    31168:  537:  return {use_begin(), use_end()};
        -:  538:}
function _ZNK4mlir11ResultRange9use_beginEv called 849135 returned 100% blocks executed 100%
  864719*:  539:ResultRange::use_iterator ResultRange::use_begin() const {
 1729438*:  540:  return use_iterator(*this);
        -:  541:}
function _ZNK4mlir11ResultRange7use_endEv called 849135 returned 100% blocks executed 100%
  864719*:  542:ResultRange::use_iterator ResultRange::use_end() const {
  864719*:  543:  return use_iterator(*this, /*end=*/true);
        -:  544:}
function _ZN4mlir11ResultRange8getUsersEv called 0 returned 0% blocks executed 0%
    #####:  545:ResultRange::user_range ResultRange::getUsers() {
    #####:  546:  return {user_begin(), user_end()};
call    0 never executed
        -:  547:}
function _ZN4mlir11ResultRange10user_beginEv called 0 returned 0% blocks executed 0%
    #####:  548:ResultRange::user_iterator ResultRange::user_begin() {
    #####:  549:  return user_iterator(use_begin());
        -:  550:}
function _ZN4mlir11ResultRange8user_endEv called 0 returned 0% blocks executed 0%
    #####:  551:ResultRange::user_iterator ResultRange::user_end() {
    #####:  552:  return user_iterator(use_end());
        -:  553:}
        -:  554:
function _ZN4mlir11ResultRange11UseIteratorC2ES0_b called 0 returned 0% blocks executed 0%
 1729438*:  555:ResultRange::UseIterator::UseIterator(ResultRange results, bool end)
  864719*:  556:    : it(end ? results.end() : results.begin()), endIt(results.end()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 100% (fallthrough)
branch  7 taken 1%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
        -:  557:  // Only initialize current use if there are results/can be uses.
  864719*:  558:  if (it != endIt)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
  864535*:  559:    skipOverResultsWithNoUsers();
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
    #####:  560:}
        -:  561:
function _ZN4mlir11ResultRange11UseIteratorppEv called 2883781 returned 100% blocks executed 100%
  2883781:  562:ResultRange::UseIterator &ResultRange::UseIterator::operator++() {
        -:  563:  // We increment over uses, if we reach the last use then move to next
        -:  564:  // result.
  2883781:  565:  if (use != (*it).use_end())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2883781:  566:    ++use;
  2883781:  567:  if (use == (*it).use_end()) {
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
   226356:  568:    ++it;
call    0 returned 100%
   226356:  569:    skipOverResultsWithNoUsers();
call    0 returned 100%
        -:  570:  }
  2883781:  571:  return *this;
        -:  572:}
        -:  573:
function _ZN4mlir11ResultRange11UseIterator26skipOverResultsWithNoUsersEv called 1090891 returned 100% blocks executed 100%
  1090891:  574:void ResultRange::UseIterator::skipOverResultsWithNoUsers() {
   864616:  575:  while (it != endIt && (*it).use_empty())
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
  1112888:  576:    ++it;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  577:
        -:  578:  // If we are at the last result, then set use to first use of
        -:  579:  // first result (sentinel value used for end).
  1090891:  580:  if (it == endIt)
branch  0 taken 100%
branch  1 taken 0%
   248272:  581:    use = {};
        -:  582:  else
   842619:  583:    use = (*it).use_begin();
call    0 returned 100%
  1090891:  584:}
        -:  585:
function _ZN4mlir11ResultRange18replaceAllUsesWithEPNS_9OperationE called 1255308 returned 100% blocks executed 100%
  1255308:  586:void ResultRange::replaceAllUsesWith(Operation *op) {
  2509638:  587:  replaceAllUsesWith(op->getResults());
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
  1255308:  588:}
        -:  589:
        -:  590://===----------------------------------------------------------------------===//
        -:  591:// ValueRange
        -:  592:
function _ZN4mlir10ValueRangeC2EN4llvm8ArrayRefINS_5ValueEEE called 597536570 returned 100% blocks executed 100%
597540359:  593:ValueRange::ValueRange(ArrayRef<Value> values)
597540359:  594:    : ValueRange(values.data(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
function _ZN4mlir10ValueRangeC2ENS_12OperandRangeE called 5052387714 returned 100% blocks executed 100%
5053150200:  595:ValueRange::ValueRange(OperandRange values)
5053150200:  596:    : ValueRange(values.begin().getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
function _ZN4mlir10ValueRangeC2ENS_11ResultRangeE called 551400613 returned 100% blocks executed 100%
552058497:  597:ValueRange::ValueRange(ResultRange values)
552058497:  598:    : ValueRange(values.getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
call    5 returned 100%
        -:  599:
        -:  600:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange11offset_baseERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 681135 returned 100% blocks executed 69%
   681135:  601:ValueRange::OwnerT ValueRange::offset_base(const OwnerT &owner,
        -:  602:                                           ptrdiff_t index) {
   681135:  603:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
   667076:  604:    return {value + index};
call    0 returned 100%
    14059:  605:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    14059:  606:    return {operand + index};
call    0 returned 100%
    #####:  607:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  608:}
        -:  609:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange20dereference_iteratorERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 4005471812 returned 100% blocks executed 100%
4005471812:  610:Value ValueRange::dereference_iterator(const OwnerT &owner, ptrdiff_t index) {
4005471812:  611:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 returned 100%
branch  1 taken 18% (fallthrough)
branch  2 taken 82%
713647433:  612:    return value[index];
3291824456:  613:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
3290748428:  614:    return operand[index].get();
  1076128:  615:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 returned 100%
call    1 returned 100%
        -:  616:}
        -:  617:
        -:  618://===----------------------------------------------------------------------===//
        -:  619:// Operation Equivalency
        -:  620://===----------------------------------------------------------------------===//
        -:  621:
function _ZN4mlir20OperationEquivalence11computeHashEPNS_9OperationEN4llvm12function_refIFNS3_9hash_codeENS_5ValueEEEES8_NS0_5FlagsE called 567796 returned 100% blocks executed 97%
   567796:  622:llvm::hash_code OperationEquivalence::computeHash(
        -:  623:    Operation *op, function_ref<llvm::hash_code(Value)> hashOperands,
        -:  624:    function_ref<llvm::hash_code(Value)> hashResults, Flags flags) {
        -:  625:  // Hash operations based upon their:
        -:  626:  //   - Operation Name
        -:  627:  //   - Attributes
        -:  628:  //   - Result Types
   567796:  629:  llvm::hash_code hash = llvm::hash_combine(
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   567796:  630:      op->getName(), op->getAttrDictionary(), op->getResultTypes());
call    0 returned 100%
        -:  631:
        -:  632:  //   - Operands
   567796:  633:  ValueRange operands = op->getOperands();
call    0 returned 100%
call    1 returned 100%
   567796:  634:  SmallVector<Value> operandStorage;
call    0 returned 100%
   567796:  635:  if (op->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
     3687:  636:    operandStorage.append(operands.begin(), operands.end());
call    0 returned 100%
     3687:  637:    llvm::sort(operandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  638:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  639:    });
     3687:  640:    operands = operandStorage;
call    0 returned 100%
        -:  641:  }
  3207484:  642:  for (Value operand : operands)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
  1319844:  643:    hash = llvm::hash_combine(hash, hashOperands(operand));
call    0 returned 100%
call    1 returned 100%
        -:  644:
        -:  645:  //   - Operands
  1702860:  646:  for (Value result : op->getResults())
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
   567532:  647:    hash = llvm::hash_combine(hash, hashResults(result));
call    0 returned 100%
call    1 returned 100%
   567796:  648:  return hash;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  649:}
        -:  650:
        -:  651:static bool
function _ZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsE called 0 returned 0% blocks executed 0%
    #####:  652:isRegionEquivalentTo(Region *lhs, Region *rhs,
        -:  653:                     function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  654:                     function_ref<LogicalResult(Value, Value)> mapResults,
        -:  655:                     OperationEquivalence::Flags flags) {
    #####:  656:  DenseMap<Block *, Block *> blocksMap;
call    0 never executed
function _ZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ called 0 returned 0% blocks executed 0%
    #####:  657:  auto blocksEquivalent = [&](Block &lBlock, Block &rBlock) {
        -:  658:    // Check block arguments.
    #####:  659:    if (lBlock.getNumArguments() != rBlock.getNumArguments())
branch  0 never executed
branch  1 never executed
        -:  660:      return false;
        -:  661:
        -:  662:    // Map the two blocks.
    #####:  663:    auto insertion = blocksMap.insert({&lBlock, &rBlock});
call    0 never executed
    #####:  664:    if (insertion.first->getSecond() != &rBlock)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  665:      return false;
        -:  666:
    #####:  667:    for (auto argPair :
    #####:  668:         llvm::zip(lBlock.getArguments(), rBlock.getArguments())) {
branch  0 never executed
branch  1 never executed
    #####:  669:      Value curArg = std::get<0>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  670:      Value otherArg = std::get<1>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  671:      if (curArg.getType() != otherArg.getType())
branch  0 never executed
branch  1 never executed
    #####:  672:        return false;
    #####:  673:      if (!(flags & OperationEquivalence::IgnoreLocations) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  674:          curArg.getLoc() != otherArg.getLoc())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  675:        return false;
        -:  676:      // Check if this value was already mapped to another value.
    #####:  677:      if (failed(mapOperands(curArg, otherArg)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  678:        return false;
        -:  679:    }
        -:  680:
function _ZZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ENKUlRNS_9OperationESE_E_clESE_SE_ called 0 returned 0% blocks executed 0%
    #####:  681:    auto opsEquivalent = [&](Operation &lOp, Operation &rOp) {
        -:  682:      // Check for op equality (recursively).
    #####:  683:      if (!OperationEquivalence::isEquivalentTo(&lOp, &rOp, mapOperands,
branch  0 never executed
branch  1 never executed
    #####:  684:                                                mapResults, flags))
call    0 never executed
        -:  685:        return false;
        -:  686:      // Check successor mapping.
    #####:  687:      for (auto successorsPair :
call    0 never executed
    #####:  688:           llvm::zip(lOp.getSuccessors(), rOp.getSuccessors())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  689:        Block *curSuccessor = std::get<0>(successorsPair);
call    0 never executed
    #####:  690:        Block *otherSuccessor = std::get<1>(successorsPair);
call    0 never executed
    #####:  691:        auto insertion = blocksMap.insert({curSuccessor, otherSuccessor});
call    0 never executed
    #####:  692:        if (insertion.first->getSecond() != otherSuccessor)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  693:          return false;
        -:  694:      }
    #####:  695:      return true;
    #####:  696:    };
    #####:  697:    return llvm::all_of_zip(lBlock, rBlock, opsEquivalent);
call    0 never executed
    #####:  698:  };
    #####:  699:  return llvm::all_of_zip(*lhs, *rhs, blocksEquivalent);
call    0 never executed
call    1 never executed
        -:  700:}
        -:  701:
function _ZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsE called 600158 returned 100% blocks executed 83%
   600158:  702:bool OperationEquivalence::isEquivalentTo(
        -:  703:    Operation *lhs, Operation *rhs,
        -:  704:    function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  705:    function_ref<LogicalResult(Value, Value)> mapResults, Flags flags) {
   600158:  706:  if (lhs == rhs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  707:    return true;
        -:  708:
        -:  709:  // Compare the operation properties.
   600158:  710:  if (lhs->getName() != rhs->getName() ||
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
branch  2 taken 69% (fallthrough)
branch  3 taken 31%
   142392:  711:      lhs->getAttrDictionary() != rhs->getAttrDictionary() ||
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
    97587:  712:      lhs->getNumRegions() != rhs->getNumRegions() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    97587:  713:      lhs->getNumSuccessors() != rhs->getNumSuccessors() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   791670:  714:      lhs->getNumOperands() != rhs->getNumOperands() ||
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
    97345:  715:      lhs->getNumResults() != rhs->getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  716:    return false;
   97345*:  717:  if (!(flags & IgnoreLocations) && lhs->getLoc() != rhs->getLoc())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  718:    return false;
        -:  719:
    97345:  720:  ValueRange lhsOperands = lhs->getOperands(), rhsOperands = rhs->getOperands();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   194690:  721:  SmallVector<Value> lhsOperandStorage, rhsOperandStorage;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    97345:  722:  if (lhs->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       51:  723:    lhsOperandStorage.append(lhsOperands.begin(), lhsOperands.end());
call    0 returned 100%
       51:  724:    llvm::sort(lhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  725:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  726:    });
       51:  727:    lhsOperands = lhsOperandStorage;
call    0 returned 100%
        -:  728:
       51:  729:    rhsOperandStorage.append(rhsOperands.begin(), rhsOperands.end());
call    0 returned 100%
       51:  730:    llvm::sort(rhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  731:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  732:    });
       51:  733:    rhsOperands = rhsOperandStorage;
call    0 returned 100%
        -:  734:  }
    97345:  735:  auto checkValueRangeMapping =
function _ZZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsEENKUlNS_10ValueRangeESA_S8_E1_clESA_SA_S8_.isra.0 called 142389 returned 100% blocks executed 100%
   142389:  736:      [](ValueRange lhs, ValueRange rhs,
        -:  737:         function_ref<LogicalResult(Value, Value)> mapValues) {
   212071:  738:        for (auto operandPair : llvm::zip(lhs, rhs)) {
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
   133697:  739:          Value curArg = std::get<0>(operandPair);
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
   133697:  740:          Value otherArg = std::get<1>(operandPair);
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
   133697:  741:          if (curArg.getType() != otherArg.getType())
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
    64015:  742:            return false;
    86762:  743:          if (failed(mapValues(curArg, otherArg)))
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
        -:  744:            return false;
        -:  745:        }
    78374:  746:        return true;
        -:  747:      };
        -:  748:  // Check mapping of operands and results.
    97345:  749:  if (!checkValueRangeMapping(lhsOperands, rhsOperands, mapOperands))
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
        -:  750:    return false;
   135132:  751:  if (!checkValueRangeMapping(lhs->getResults(), rhs->getResults(), mapResults))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 74% (fallthrough)
branch  8 taken 26%
        -:  752:    return false;
   40644*:  753:  for (auto regionPair : llvm::zip(lhs->getRegions(), rhs->getRegions()))
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  754:    if (!isRegionEquivalentTo(&std::get<0>(regionPair),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:                              &std::get<1>(regionPair), mapOperands, mapResults,
call    0 never executed
        -:  756:                              flags))
    #####:  757:      return false;
    33330:  758:  return true;
        -:  759:}
