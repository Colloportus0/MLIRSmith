        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/Diagnostics.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Diagnostics.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Diagnostics.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- Diagnostics.cpp - MLIR Diagnostics ---------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/Diagnostics.h"
        -:   10:#include "mlir/IR/Attributes.h"
        -:   11:#include "mlir/IR/Location.h"
        -:   12:#include "mlir/IR/MLIRContext.h"
        -:   13:#include "mlir/IR/Operation.h"
        -:   14:#include "mlir/IR/Types.h"
        -:   15:#include "llvm/ADT/MapVector.h"
        -:   16:#include "llvm/ADT/SmallString.h"
        -:   17:#include "llvm/ADT/StringMap.h"
        -:   18:#include "llvm/ADT/TypeSwitch.h"
        -:   19:#include "llvm/Support/Mutex.h"
        -:   20:#include "llvm/Support/PrettyStackTrace.h"
        -:   21:#include "llvm/Support/Regex.h"
        -:   22:#include "llvm/Support/Signals.h"
        -:   23:#include "llvm/Support/SourceMgr.h"
        -:   24:#include "llvm/Support/raw_ostream.h"
        -:   25:
        -:   26:using namespace mlir;
        -:   27:using namespace mlir::detail;
        -:   28:
        -:   29://===----------------------------------------------------------------------===//
        -:   30:// DiagnosticArgument
        -:   31://===----------------------------------------------------------------------===//
        -:   32:
        -:   33:/// Construct from an Attribute.
function _ZN4mlir18DiagnosticArgumentC2ENS_9AttributeE called 462 returned 100% blocks executed 100%
     462*:   34:DiagnosticArgument::DiagnosticArgument(Attribute attr)
        -:   35:    : kind(DiagnosticArgumentKind::Attribute),
     462*:   36:      opaqueVal(reinterpret_cast<intptr_t>(attr.getAsOpaquePointer())) {}
        -:   37:
        -:   38:/// Construct from a Type.
function _ZN4mlir18DiagnosticArgumentC2ENS_4TypeE called 7169 returned 100% blocks executed 100%
     7169:   39:DiagnosticArgument::DiagnosticArgument(Type val)
        -:   40:    : kind(DiagnosticArgumentKind::Type),
     7169:   41:      opaqueVal(reinterpret_cast<intptr_t>(val.getAsOpaquePointer())) {}
        -:   42:
        -:   43:/// Returns this argument as an Attribute.
function _ZNK4mlir18DiagnosticArgument14getAsAttributeEv called 0 returned 0% blocks executed 0%
     462*:   44:Attribute DiagnosticArgument::getAsAttribute() const {
    #####:   45:  assert(getKind() == DiagnosticArgumentKind::Attribute);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
     462*:   46:  return Attribute::getFromOpaquePointer(
     462*:   47:      reinterpret_cast<const void *>(opaqueVal));
call    0 returned 100%
        -:   48:}
        -:   49:
        -:   50:/// Returns this argument as a Type.
function _ZNK4mlir18DiagnosticArgument9getAsTypeEv called 0 returned 0% blocks executed 0%
     312*:   51:Type DiagnosticArgument::getAsType() const {
    #####:   52:  assert(getKind() == DiagnosticArgumentKind::Type);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
     312*:   53:  return Type::getFromOpaquePointer(reinterpret_cast<const void *>(opaqueVal));
call    0 returned 100%
        -:   54:}
        -:   55:
        -:   56:/// Outputs this argument to a stream.
function _ZNK4mlir18DiagnosticArgument5printERN4llvm11raw_ostreamE called 27022565 returned 100% blocks executed 65%
 27022565:   57:void DiagnosticArgument::print(raw_ostream &os) const {
 27022565:   58:  switch (kind) {
branch  0 taken 1%
branch  1 taken 0%
branch  2 taken 1%
branch  3 taken 98%
branch  4 taken 1%
branch  5 taken 2%
branch  6 taken 0%
      462:   59:  case DiagnosticArgumentKind::Attribute:
      462:   60:    os << getAsAttribute();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
      462:   61:    break;
    #####:   62:  case DiagnosticArgumentKind::Double:
    #####:   63:    os << getAsDouble();
branch  0 never executed
branch  1 never executed
    #####:   64:    break;
call    0 never executed
      433:   65:  case DiagnosticArgumentKind::Integer:
      433:   66:    os << getAsInteger();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      433:   67:    break;
call    0 returned 100%
 26552954:   68:  case DiagnosticArgumentKind::String:
 26552954:   69:    os << getAsString();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 26552954:   70:    break;
call    0 returned 100%
      312:   71:  case DiagnosticArgumentKind::Type:
      624:   72:    os << '\'' << getAsType() << '\'';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        -:   73:    break;
   468404:   74:  case DiagnosticArgumentKind::Unsigned:
   468404:   75:    os << getAsUnsigned();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   468404:   76:    break;
call    0 returned 100%
        -:   77:  }
 27022565:   78:}
        -:   79:
        -:   80://===----------------------------------------------------------------------===//
        -:   81:// Diagnostic
        -:   82://===----------------------------------------------------------------------===//
        -:   83:
        -:   84:/// Convert a Twine to a StringRef. Memory used for generating the StringRef is
        -:   85:/// stored in 'strings'.
function _ZL13twineToStrRefRKN4llvm5TwineERSt6vectorISt10unique_ptrIA_cSt14default_deleteIS5_EESaIS8_EE called 10289609 returned 100% blocks executed 75%
 10289609:   86:static StringRef twineToStrRef(const Twine &val,
        -:   87:                               std::vector<std::unique_ptr<char[]>> &strings) {
        -:   88:  // Allocate memory to hold this string.
 10289609:   89:  SmallString<64> data;
call    0 returned 100%
 10289609:   90:  auto strRef = val.toStringRef(data);
call    0 returned 100%
 10289582:   91:  if (strRef.empty())
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
  2924448:   92:    return strRef;
        -:   93:
  7365134:   94:  strings.push_back(std::unique_ptr<char[]>(new char[strRef.size()]));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  7365184:   95:  memcpy(&strings.back()[0], strRef.data(), strRef.size());
        -:   96:  // Return a reference to the new string.
  7365184:   97:  return StringRef(&strings.back()[0], strRef.size());
        -:   98:}
        -:   99:
        -:  100:/// Stream in a Twine argument.
function _ZN4mlir10DiagnosticlsEc called 431 returned 100% blocks executed 100%
   216109:  101:Diagnostic &Diagnostic::operator<<(char val) { return *this << Twine(val); }
call    0 returned 100%
function _ZN4mlir10DiagnosticlsERKN4llvm5TwineE called 3149810 returned 100% blocks executed 100%
  3149810:  102:Diagnostic &Diagnostic::operator<<(const Twine &val) {
  3149810:  103:  arguments.push_back(DiagnosticArgument(twineToStrRef(val, strings)));
call    0 returned 100%
call    1 returned 100%
  3149825:  104:  return *this;
        -:  105:}
function _ZN4mlir10DiagnosticlsEON4llvm5TwineE called 7139851 returned 100% blocks executed 100%
  7139851:  106:Diagnostic &Diagnostic::operator<<(Twine &&val) {
  7139851:  107:  arguments.push_back(DiagnosticArgument(twineToStrRef(val, strings)));
call    0 returned 100%
call    1 returned 100%
  7139923:  108:  return *this;
        -:  109:}
        -:  110:
function _ZN4mlir10DiagnosticlsENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:  111:Diagnostic &Diagnostic::operator<<(StringAttr val) {
    #####:  112:  arguments.push_back(DiagnosticArgument(val));
call    0 never executed
    #####:  113:  return *this;
        -:  114:}
        -:  115:
        -:  116:/// Stream in an OperationName.
function _ZN4mlir10DiagnosticlsENS_13OperationNameE called 4547052 returned 100% blocks executed 100%
  4547052:  117:Diagnostic &Diagnostic::operator<<(OperationName val) {
        -:  118:  // An OperationName is stored in the context, so we don't need to worry about
        -:  119:  // the lifetime of its data.
  4547052:  120:  arguments.push_back(DiagnosticArgument(val.getStringRef()));
call    0 returned 100%
call    1 returned 100%
  4547066:  121:  return *this;
        -:  122:}
        -:  123:
        -:  124:/// Adjusts operation printing flags used in diagnostics for the given severity
        -:  125:/// level.
function _ZL19adjustPrintingFlagsN4mlir15OpPrintingFlagsENS_18DiagnosticSeverityE called 6290002 returned 100% blocks executed 80%
  6290002:  126:static OpPrintingFlags adjustPrintingFlags(OpPrintingFlags flags,
        -:  127:                                           DiagnosticSeverity severity) {
  6290002:  128:  flags.useLocalScope();
call    0 returned 100%
  6290002:  129:  flags.elideLargeElementsAttrs();
call    0 returned 100%
  6290001:  130:  if (severity == DiagnosticSeverity::Error)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  131:    flags.printGenericOpForm();
call    0 never executed
  6290001:  132:  return flags;
        -:  133:}
        -:  134:
        -:  135:/// Stream in an Operation.
function _ZN4mlir10DiagnosticlsERNS_9OperationE called 3189599 returned 100% blocks executed 100%
  3189599:  136:Diagnostic &Diagnostic::operator<<(Operation &op) {
  3189599:  137:  return appendOp(op, OpPrintingFlags());
call    0 returned 100%
call    1 returned 100%
        -:  138:}
        -:  139:
function _ZN4mlir10Diagnostic8appendOpERNS_9OperationERKNS_15OpPrintingFlagsE called 6289998 returned 100% blocks executed 100%
  6289998:  140:Diagnostic &Diagnostic::appendOp(Operation &op, const OpPrintingFlags &flags) {
  6289998:  141:  std::string str;
call    0 returned 100%
 12579993:  142:  llvm::raw_string_ostream os(str);
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
  6290003:  143:  op.print(os, adjustPrintingFlags(flags, severity));
call    0 returned 100%
call    1 returned 100%
        -:  144:  // Print on a new line for better readability if the op will be printed on
        -:  145:  // multiple lines.
  6289968:  146:  if (str.find('\n') != std::string::npos)
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
   215678:  147:    *this << '\n';
call    0 returned 100%
  6289984:  148:  return *this << os.str();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  149:}
        -:  150:
        -:  151:/// Stream in a Value.
function _ZN4mlir10DiagnosticlsENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  152:Diagnostic &Diagnostic::operator<<(Value val) {
    #####:  153:  std::string str;
call    0 never executed
    #####:  154:  llvm::raw_string_ostream os(str);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  155:  val.print(os, adjustPrintingFlags(OpPrintingFlags(), severity));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  156:  return *this << os.str();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  157:}
        -:  158:
        -:  159:/// Outputs this diagnostic to a stream.
function _ZNK4mlir10Diagnostic5printERN4llvm11raw_ostreamE called 2914839 returned 100% blocks executed 100%
 9567696*:  160:void Diagnostic::print(raw_ostream &os) const {
36590261*:  161:  for (auto &arg : getArguments())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 70% (fallthrough)
branch  5 taken 30%
branch  6 taken 80% (fallthrough)
branch  7 taken 20%
27022565*:  162:    arg.print(os);
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
  2914839:  163:}
        -:  164:
        -:  165:/// Convert the diagnostic to a string.
function _ZNK4mlir10Diagnostic3strB5cxx11Ev called 6652857 returned 100% blocks executed 100%
  6652857:  166:std::string Diagnostic::str() const {
  6652857:  167:  std::string str;
call    0 returned 100%
 13305714:  168:  llvm::raw_string_ostream os(str);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  6652857:  169:  print(os);
  6652857:  170:  return os.str();
call    0 returned 100%
call    1 returned 100%
        -:  171:}
        -:  172:
        -:  173:/// Attaches a note to this diagnostic. A new location may be optionally
        -:  174:/// provided, if not, then the location defaults to the one specified for this
        -:  175:/// diagnostic. Notes may not be attached to other notes.
function _ZN4mlir10Diagnostic10attachNoteEN4llvm8OptionalINS_8LocationEEE called 6291372 returned 100% blocks executed 73%
  6291372:  176:Diagnostic &Diagnostic::attachNote(Optional<Location> noteLoc) {
        -:  177:  // We don't allow attaching notes to notes.
 6291372*:  178:  assert(severity != DiagnosticSeverity::Note &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  179:         "cannot attach a note to a note");
        -:  180:
        -:  181:  // If a location wasn't provided then reuse our location.
  6291372:  182:  if (!noteLoc)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      794:  183:    noteLoc = loc;
        -:  184:
        -:  185:  /// Append and return a new note.
  6291388:  186:  notes.push_back(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  6291372:  187:      std::make_unique<Diagnostic>(*noteLoc, DiagnosticSeverity::Note));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
  6291388:  188:  return *notes.back();
        -:  189:}
        -:  190:
        -:  191:/// Allow a diagnostic to be converted to 'failure'.
function _ZNK4mlir10DiagnosticcvNS_13LogicalResultEEv called 522 returned 100% blocks executed 100%
      522:  192:Diagnostic::operator LogicalResult() const { return failure(); }
        -:  193:
        -:  194://===----------------------------------------------------------------------===//
        -:  195:// InFlightDiagnostic
        -:  196://===----------------------------------------------------------------------===//
        -:  197:
        -:  198:/// Allow an inflight diagnostic to be converted to 'failure', otherwise
        -:  199:/// 'success' if this is an empty diagnostic.
function _ZNK4mlir18InFlightDiagnosticcvNS_13LogicalResultEEv called 79575 returned 100% blocks executed 100%
    79575:  200:InFlightDiagnostic::operator LogicalResult() const {
    79575:  201:  return failure(isActive());
        -:  202:}
        -:  203:
        -:  204:/// Reports the diagnostic to the engine.
function _ZN4mlir18InFlightDiagnostic6reportEv called 6319963 returned 100% blocks executed 89%
  6319963:  205:void InFlightDiagnostic::report() {
        -:  206:  // If this diagnostic is still inflight and it hasn't been abandoned, then
        -:  207:  // report it.
  6319963:  208:  if (isInFlight()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  6319963:  209:    owner->emit(std::move(*impl));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  6319980:  210:    owner = nullptr;
        -:  211:  }
  6319980:  212:  impl.reset();
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  6319980:  213:}
        -:  214:
        -:  215:/// Abandons this diagnostic.
function _ZN4mlir18InFlightDiagnostic7abandonEv called 3200423 returned 100% blocks executed 100%
  3200423:  216:void InFlightDiagnostic::abandon() { owner = nullptr; }
        -:  217:
        -:  218://===----------------------------------------------------------------------===//
        -:  219:// DiagnosticEngineImpl
        -:  220://===----------------------------------------------------------------------===//
        -:  221:
        -:  222:namespace mlir {
        -:  223:namespace detail {
        -:  224:struct DiagnosticEngineImpl {
        -:  225:  /// Emit a diagnostic using the registered issue handle if present, or with
        -:  226:  /// the default behavior if not.
        -:  227:  void emit(Diagnostic &&diag);
        -:  228:
        -:  229:  /// A mutex to ensure that diagnostics emission is thread-safe.
        -:  230:  llvm::sys::SmartMutex<true> mutex;
        -:  231:
        -:  232:  /// These are the handlers used to report diagnostics.
        -:  233:  llvm::SmallMapVector<DiagnosticEngine::HandlerID, DiagnosticEngine::HandlerTy,
        -:  234:                       2>
        -:  235:      handlers;
        -:  236:
        -:  237:  /// This is a unique identifier counter for diagnostic handlers in the
        -:  238:  /// context. This id starts at 1 to allow for 0 to be used as a sentinel.
        -:  239:  DiagnosticEngine::HandlerID uniqueHandlerId = 1;
        -:  240:};
        -:  241:} // namespace detail
        -:  242:} // namespace mlir
        -:  243:
        -:  244:/// Emit a diagnostic using the registered issue handle if present, or with
        -:  245:/// the default behavior if not.
function _ZN4mlir6detail20DiagnosticEngineImpl4emitEONS_10DiagnosticE called 6323182 returned 100% blocks executed 32%
  6323182:  246:void DiagnosticEngineImpl::emit(Diagnostic &&diag) {
  6323182:  247:  llvm::sys::SmartScopedLock<true> lock(mutex);
call    0 returned 100%
        -:  248:
        -:  249:  // Try to process the given diagnostic on one of the registered handlers.
        -:  250:  // Handlers are walked in reverse order, so that the most recent handler is
        -:  251:  // processed first.
  6323204:  252:  for (auto &handlerIt : llvm::reverse(handlers))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
  6323204:  253:    if (succeeded(handlerIt.second(diag)))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
  6323203:  254:      return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  255:
        -:  256:  // Otherwise, if this is an error we emit it to stderr.
    #####:  257:  if (diag.getSeverity() != DiagnosticSeverity::Error)
branch  0 never executed
branch  1 never executed
        -:  258:    return;
        -:  259:
    #####:  260:  auto &os = llvm::errs();
call    0 never executed
    #####:  261:  if (!diag.getLocation().isa<UnknownLoc>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  262:    os << diag.getLocation() << ": ";
call    0 never executed
call    1 never executed
    #####:  263:  os << "error: ";
call    0 never executed
        -:  264:
        -:  265:  // The default behavior for errors is to emit them to stderr.
    #####:  266:  os << diag << '\n';
branch  0 never executed
branch  1 never executed
    #####:  267:  os.flush();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  268:}
        -:  269:
        -:  270://===----------------------------------------------------------------------===//
        -:  271:// DiagnosticEngine
        -:  272://===----------------------------------------------------------------------===//
        -:  273:
function _ZN4mlir16DiagnosticEngineC2Ev called 189144 returned 100% blocks executed 100%
   189144:  274:DiagnosticEngine::DiagnosticEngine() : impl(new DiagnosticEngineImpl()) {}
call    0 returned 100%
call    1 returned 100%
        -:  275:DiagnosticEngine::~DiagnosticEngine() = default;
        -:  276:
        -:  277:/// Register a new handler for diagnostics to the engine. This function returns
        -:  278:/// a unique identifier for the registered handler, which can be used to
        -:  279:/// unregister this handler at a later time.
function _ZN4mlir16DiagnosticEngine15registerHandlerEN4llvm15unique_functionIFNS_13LogicalResultERNS_10DiagnosticEEEE called 8032279 returned 100% blocks executed 100%
  8032279:  280:auto DiagnosticEngine::registerHandler(HandlerTy handler) -> HandlerID {
  8032279:  281:  llvm::sys::SmartScopedLock<true> lock(impl->mutex);
call    0 returned 100%
  8032279:  282:  auto uniqueID = impl->uniqueHandlerId++;
call    0 returned 100%
  8032279:  283:  impl->handlers.insert({uniqueID, std::move(handler)});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  8032279:  284:  return uniqueID;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  285:}
        -:  286:
        -:  287:/// Erase the registered diagnostic handler with the given identifier.
function _ZN4mlir16DiagnosticEngine12eraseHandlerEm called 8032022 returned 100% blocks executed 100%
  8032022:  288:void DiagnosticEngine::eraseHandler(HandlerID handlerID) {
  8032022:  289:  llvm::sys::SmartScopedLock<true> lock(impl->mutex);
call    0 returned 100%
  8032022:  290:  impl->handlers.erase(handlerID);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  8032022:  291:}
        -:  292:
        -:  293:/// Emit a diagnostic using the registered issue handler if present, or with
        -:  294:/// the default behavior if not.
function _ZN4mlir16DiagnosticEngine4emitEONS_10DiagnosticE called 6323186 returned 100% blocks executed 75%
  6323186:  295:void DiagnosticEngine::emit(Diagnostic &&diag) {
 6323186*:  296:  assert(diag.getSeverity() != DiagnosticSeverity::Note &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  297:         "notes should not be emitted directly");
  6323186:  298:  impl->emit(std::move(diag));
call    0 returned 100%
  6323202:  299:}
        -:  300:
        -:  301:/// Helper function used to emit a diagnostic with an optionally empty twine
        -:  302:/// message. If the message is empty, then it is not inserted into the
        -:  303:/// diagnostic.
        -:  304:static InFlightDiagnostic
function _ZL8emitDiagN4mlir8LocationENS_18DiagnosticSeverityERKN4llvm5TwineE called 6319967 returned 100% blocks executed 100%
  6319967:  305:emitDiag(Location location, DiagnosticSeverity severity, const Twine &message) {
  6319967:  306:  MLIRContext *ctx = location->getContext();
call    0 returned 100%
  6319966:  307:  auto &diagEngine = ctx->getDiagEngine();
call    0 returned 100%
  6319962:  308:  auto diag = diagEngine.emit(location, severity);
call    0 returned 100%
  6319962:  309:  if (!message.isTriviallyEmpty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   160803:  310:    diag << message;
call    0 returned 100%
        -:  311:
        -:  312:  // Add the stack trace as a note if necessary.
  6319963:  313:  if (ctx->shouldPrintStackTraceOnDiagnostic()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      726:  314:    std::string bt;
call    0 returned 100%
      363:  315:    {
      363:  316:      llvm::raw_string_ostream stream(bt);
call    0 returned 100%
      363:  317:      llvm::sys::PrintStackTrace(stream);
call    0 returned 100%
call    1 returned 100%
        -:  318:    }
      363:  319:    if (!bt.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      363:  320:      diag.attachNote() << "diagnostic emitted with trace:\n" << bt;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  321:  }
        -:  322:
  6319965:  323:  return diag;
        -:  324:}
        -:  325:
        -:  326:/// Emit an error message using this location.
function _ZN4mlir9emitErrorENS_8LocationE called 4467 returned 100% blocks executed 100%
     4467:  327:InFlightDiagnostic mlir::emitError(Location loc) { return emitError(loc, {}); }
call    0 returned 100%
function _ZN4mlir9emitErrorENS_8LocationERKN4llvm5TwineE called 3105499 returned 100% blocks executed 100%
  3109966:  328:InFlightDiagnostic mlir::emitError(Location loc, const Twine &message) {
  3109966:  329:  return emitDiag(loc, DiagnosticSeverity::Error, message);
call    0 returned 100%
call    1 returned 100%
        -:  330:}
        -:  331:
        -:  332:/// Emit a warning message using this location.
function _ZN4mlir11emitWarningENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  333:InFlightDiagnostic mlir::emitWarning(Location loc) {
    #####:  334:  return emitWarning(loc, {});
call    0 never executed
        -:  335:}
function _ZN4mlir11emitWarningENS_8LocationERKN4llvm5TwineE called 0 returned 0% blocks executed 0%
    #####:  336:InFlightDiagnostic mlir::emitWarning(Location loc, const Twine &message) {
    #####:  337:  return emitDiag(loc, DiagnosticSeverity::Warning, message);
call    0 never executed
call    1 never executed
        -:  338:}
        -:  339:
        -:  340:/// Emit a remark message using this location.
function _ZN4mlir10emitRemarkENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  341:InFlightDiagnostic mlir::emitRemark(Location loc) {
    #####:  342:  return emitRemark(loc, {});
call    0 never executed
        -:  343:}
function _ZN4mlir10emitRemarkENS_8LocationERKN4llvm5TwineE called 3210008 returned 100% blocks executed 100%
 3210008*:  344:InFlightDiagnostic mlir::emitRemark(Location loc, const Twine &message) {
 3210008*:  345:  return emitDiag(loc, DiagnosticSeverity::Remark, message);
call    0 returned 100%
call    1 never executed
        -:  346:}
        -:  347:
        -:  348://===----------------------------------------------------------------------===//
        -:  349:// ScopedDiagnosticHandler
        -:  350://===----------------------------------------------------------------------===//
        -:  351:
function _ZN4mlir23ScopedDiagnosticHandlerD2Ev called 8023550 returned 100% blocks executed 100%
 16047100:  352:ScopedDiagnosticHandler::~ScopedDiagnosticHandler() {
  8023550:  353:  if (handlerID)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  8023550:  354:    ctx->getDiagEngine().eraseHandler(handlerID);
call    0 returned 100%
call    1 returned 100%
  8023550:  355:}
        -:  356:
        -:  357://===----------------------------------------------------------------------===//
        -:  358:// SourceMgrDiagnosticHandler
        -:  359://===----------------------------------------------------------------------===//
        -:  360:namespace mlir {
        -:  361:namespace detail {
  4555875:  362:struct SourceMgrDiagnosticHandlerImpl {
        -:  363:  /// Return the SrcManager buffer id for the specified file, or zero if none
        -:  364:  /// can be found.
function _ZN4mlir6detail30SourceMgrDiagnosticHandlerImpl27getSourceMgrBufferIDForFileERN4llvm9SourceMgrENS2_9StringRefE called 3253763 returned 100% blocks executed 100%
  3253763:  365:  unsigned getSourceMgrBufferIDForFile(llvm::SourceMgr &mgr,
        -:  366:                                       StringRef filename) {
        -:  367:    // Check for an existing mapping to the buffer id for this file.
  3253763:  368:    auto bufferIt = filenameToBufId.find(filename);
call    0 returned 100%
  3253763:  369:    if (bufferIt != filenameToBufId.end())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  3236576:  370:      return bufferIt->second;
        -:  371:
        -:  372:    // Look for a buffer in the manager that has this filename.
    17235:  373:    for (unsigned i = 1, e = mgr.getNumBuffers() + 1; i != e; ++i) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    17187:  374:      auto *buf = mgr.getMemoryBuffer(i);
call    0 returned 100%
    17235:  375:      if (buf->getBufferIdentifier() == filename)
call    0 returned 100%
    17139:  376:        return filenameToBufId[filename] = i;
call    0 returned 100%
        -:  377:    }
        -:  378:
        -:  379:    // Otherwise, try to load the source file.
       48:  380:    std::string ignored;
call    0 returned 100%
       48:  381:    unsigned id = mgr.AddIncludeFile(std::string(filename), SMLoc(), ignored);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       48:  382:    filenameToBufId[filename] = id;
call    0 returned 100%
       48:  383:    return id;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  384:  }
        -:  385:
        -:  386:  /// Mapping between file name and buffer ID's.
        -:  387:  llvm::StringMap<unsigned> filenameToBufId;
        -:  388:};
        -:  389:} // namespace detail
        -:  390:} // namespace mlir
        -:  391:
        -:  392:/// Return a processable CallSiteLoc from the given location.
function _ZL14getCallSiteLocN4mlir8LocationE called 3318680 returned 100% blocks executed 39%
  3318680:  393:static Optional<CallSiteLoc> getCallSiteLoc(Location loc) {
  6637360:  394:  if (auto nameLoc = dyn_cast<NameLoc>(loc))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  395:    return getCallSiteLoc(cast<NameLoc>(loc).getChildLoc());
call    0 never executed
call    1 never executed
call    2 never executed
  6637360:  396:  if (auto callLoc = dyn_cast<CallSiteLoc>(loc))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  397:    return callLoc;
  6637360:  398:  if (auto fusedLoc = dyn_cast<FusedLoc>(loc)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  399:    for (auto subLoc : cast<FusedLoc>(loc).getLocations()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  400:      if (auto callLoc = getCallSiteLoc(subLoc)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  401:        return callLoc;
        -:  402:      }
        -:  403:    }
    #####:  404:    return llvm::None;
        -:  405:  }
  3318680:  406:  return llvm::None;
        -:  407:}
        -:  408:
        -:  409:/// Given a diagnostic kind, returns the LLVM DiagKind.
  6652857:  410:static llvm::SourceMgr::DiagKind getDiagKind(DiagnosticSeverity kind) {
  6486734:  411:  switch (kind) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  412:  case DiagnosticSeverity::Note:
        -:  413:    return llvm::SourceMgr::DK_Note;
        -:  414:  case DiagnosticSeverity::Warning:
        -:  415:    return llvm::SourceMgr::DK_Warning;
        -:  416:  case DiagnosticSeverity::Error:
        -:  417:    return llvm::SourceMgr::DK_Error;
        -:  418:  case DiagnosticSeverity::Remark:
        -:  419:    return llvm::SourceMgr::DK_Remark;
        -:  420:  }
    #####:  421:  llvm_unreachable("Unknown DiagnosticSeverity");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  422:}
        -:  423:
function _ZN4mlir26SourceMgrDiagnosticHandlerC2ERN4llvm9SourceMgrEPNS_11MLIRContextERNS1_11raw_ostreamEONS1_15unique_functionIFbNS_8LocationEEEE called 4555875 returned 100% blocks executed 100%
  4555875:  424:SourceMgrDiagnosticHandler::SourceMgrDiagnosticHandler(
        -:  425:    llvm::SourceMgr &mgr, MLIRContext *ctx, raw_ostream &os,
  4555875:  426:    ShouldShowLocFn &&shouldShowLocFn)
        -:  427:    : ScopedDiagnosticHandler(ctx), mgr(mgr), os(os),
  4555875:  428:      shouldShowLocFn(std::move(shouldShowLocFn)),
call    0 returned 100%
  4555875:  429:      impl(new SourceMgrDiagnosticHandlerImpl()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  7874555:  430:  setHandler([this](Diagnostic &diag) { emitDiagnostic(diag); });
call    0 returned 100%
call    1 returned 100%
  4555875:  431:}
        -:  432:
function _ZN4mlir26SourceMgrDiagnosticHandlerC2ERN4llvm9SourceMgrEPNS_11MLIRContextEONS1_15unique_functionIFbNS_8LocationEEEE called 4555382 returned 100% blocks executed 100%
  4555382:  433:SourceMgrDiagnosticHandler::SourceMgrDiagnosticHandler(
  4555382:  434:    llvm::SourceMgr &mgr, MLIRContext *ctx, ShouldShowLocFn &&shouldShowLocFn)
call    0 returned 100%
  4555382:  435:    : SourceMgrDiagnosticHandler(mgr, ctx, llvm::errs(),
  4555382:  436:                                 std::move(shouldShowLocFn)) {}
call    0 returned 100%
call    1 returned 100%
        -:  437:
        -:  438:SourceMgrDiagnosticHandler::~SourceMgrDiagnosticHandler() = default;
        -:  439:
function _ZN4mlir26SourceMgrDiagnosticHandler14emitDiagnosticENS_8LocationEN4llvm5TwineENS_18DiagnosticSeverityEb called 6652857 returned 100% blocks executed 94%
  6652857:  440:void SourceMgrDiagnosticHandler::emitDiagnostic(Location loc, Twine message,
        -:  441:                                                DiagnosticSeverity kind,
        -:  442:                                                bool displaySourceLine) {
        -:  443:  // Extract a file location from this loc.
  6652857:  444:  auto fileLoc = loc->findInstanceOf<FileLineColLoc>();
call    0 returned 100%
        -:  445:
        -:  446:  // If one doesn't exist, then print the raw message without a source location.
  6652857:  447:  if (!fileLoc) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
   332246:  448:    std::string str;
call    0 returned 100%
   332246:  449:    llvm::raw_string_ostream strOS(str);
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
   166123:  450:    if (!loc.isa<UnknownLoc>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        2:  451:      strOS << loc << ": ";
call    0 returned 100%
call    1 returned 100%
   166123:  452:    strOS << message;
call    0 returned 100%
   166123:  453:    return mgr.PrintMessage(os, SMLoc(), getDiagKind(kind), strOS.str());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
        -:  454:  }
        -:  455:
        -:  456:  // Otherwise if we are displaying the source line, try to convert the file
        -:  457:  // location to an SMLoc.
  6486734:  458:  if (displaySourceLine) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
  3253765:  459:    auto smloc = convertLocToSMLoc(fileLoc);
call    0 returned 100%
  3253765:  460:    if (smloc.isValid())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  3253762:  461:      return mgr.PrintMessage(os, smloc, getDiagKind(kind), message);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  462:  }
        -:  463:
        -:  464:  // If the conversion was unsuccessful, create a diagnostic with the file
        -:  465:  // information. We manually combine the line and column to avoid asserts in
        -:  466:  // the constructor of SMDiagnostic that takes a location.
  6465944:  467:  std::string locStr;
call    0 returned 100%
  6465944:  468:  llvm::raw_string_ostream locOS(locStr);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  3232972:  469:  locOS << fileLoc.getFilename().getValue() << ":" << fileLoc.getLine() << ":"
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
  3232972:  470:        << fileLoc.getColumn();
call    0 returned 100%
call    1 returned 100%
  6465944:  471:  llvm::SMDiagnostic diag(locOS.str(), getDiagKind(kind), message.str());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100%
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
  3232972:  472:  diag.print(nullptr, os);
call    0 returned 100%
        -:  473:}
        -:  474:
        -:  475:/// Emit the given diagnostic with the held source manager.
function _ZN4mlir26SourceMgrDiagnosticHandler14emitDiagnosticERNS_10DiagnosticE called 3318680 returned 100% blocks executed 55%
  3318680:  476:void SourceMgrDiagnosticHandler::emitDiagnostic(Diagnostic &diag) {
  3318680:  477:  SmallVector<std::pair<Location, StringRef>> locationStack;
call    0 returned 100%
function _ZZN4mlir26SourceMgrDiagnosticHandler14emitDiagnosticERNS_10DiagnosticEENKUlNS_8LocationEN4llvm9StringRefEE_clES3_S5_.isra.0 called 3318680 returned 100% blocks executed 100%
  3318680:  478:  auto addLocToStack = [&](Location loc, StringRef locContext) {
  3318680:  479:    if (Optional<Location> showableLoc = findLocToShow(loc))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  3318680:  480:      locationStack.emplace_back(*showableLoc, locContext);
call    0 returned 100%
  6637360:  481:  };
        -:  482:
        -:  483:  // Add locations to display for this diagnostic.
  3318680:  484:  Location loc = diag.getLocation();
call    0 returned 100%
  3318680:  485:  addLocToStack(loc, /*locContext=*/{});
call    0 returned 100%
        -:  486:
        -:  487:  // If the diagnostic location was a call site location, add the call stack as
        -:  488:  // well.
  3318680:  489:  if (auto callLoc = getCallSiteLoc(loc)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  490:    // Print the call stack while valid, or until the limit is reached.
    #####:  491:    loc = callLoc->getCaller();
call    0 never executed
    #####:  492:    for (unsigned curDepth = 0; curDepth < callStackLimit; ++curDepth) {
branch  0 never executed
branch  1 never executed
    #####:  493:      addLocToStack(loc, "called from");
call    0 never executed
    #####:  494:      if ((callLoc = getCallSiteLoc(loc)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  495:        loc = callLoc->getCaller();
call    0 never executed
        -:  496:      else
        -:  497:        break;
        -:  498:    }
        -:  499:  }
        -:  500:
        -:  501:  // If the location stack is empty, use the initial location.
  3318680:  502:  if (locationStack.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  503:    emitDiagnostic(diag.getLocation(), diag.str(), diag.getSeverity());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  504:
        -:  505:    // Otherwise, use the location stack.
        -:  506:  } else {
  3318680:  507:    emitDiagnostic(locationStack.front().first, diag.str(), diag.getSeverity());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 3318680*:  508:    for (auto &it : llvm::drop_begin(locationStack))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  509:      emitDiagnostic(it.first, it.second, DiagnosticSeverity::Note);
call    0 never executed
call    1 never executed
        -:  510:  }
        -:  511:
        -:  512:  // Emit each of the notes. Only display the source code if the location is
        -:  513:  // different from the previous location.
  6631329:  514:  for (auto &note : diag.getNotes()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
  3312649:  515:    emitDiagnostic(note.getLocation(), note.str(), note.getSeverity(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  3312649:  516:                   /*displaySourceLine=*/loc != note.getLocation());
call    0 returned 100%
  3312649:  517:    loc = note.getLocation();
        -:  518:  }
  3318680:  519:}
        -:  520:
        -:  521:/// Get a memory buffer for the given file, or nullptr if one is not found.
        -:  522:const llvm::MemoryBuffer *
function _ZN4mlir26SourceMgrDiagnosticHandler16getBufferForFileEN4llvm9StringRefE called 1 returned 100% blocks executed 100%
        1:  523:SourceMgrDiagnosticHandler::getBufferForFile(StringRef filename) {
        1:  524:  if (unsigned id = impl->getSourceMgrBufferIDForFile(mgr, filename))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        1:  525:    return mgr.getMemoryBuffer(id);
call    0 returned 100%
        -:  526:  return nullptr;
        -:  527:}
        -:  528:
function _ZN4mlir26SourceMgrDiagnosticHandler13findLocToShowENS_8LocationE called 3318680 returned 100% blocks executed 20%
  3318680:  529:Optional<Location> SourceMgrDiagnosticHandler::findLocToShow(Location loc) {
  3318680:  530:  if (!shouldShowLocFn)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  3318680:  531:    return loc;
    #####:  532:  if (!shouldShowLocFn(loc))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  533:    return llvm::None;
        -:  534:
        -:  535:  // Recurse into the child locations of some of location types.
    #####:  536:  return TypeSwitch<LocationAttr, Optional<Location>>(loc)
call    0 never executed
    #####:  537:      .Case([&](CallSiteLoc callLoc) -> Optional<Location> {
        -:  538:        // We recurse into the callee of a call site, as the caller will be
        -:  539:        // emitted in a different note on the main diagnostic.
    #####:  540:        return findLocToShow(callLoc.getCallee());
call    0 never executed
call    1 never executed
    #####:  541:      })
call    0 never executed
    #####:  542:      .Case([&](FileLineColLoc) -> Optional<Location> { return loc; })
branch  0 never executed
branch  1 never executed
call    2 never executed
function _ZZN4mlir26SourceMgrDiagnosticHandler13findLocToShowENS_8LocationEENKUlNS_8FusedLocEE1_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  543:      .Case([&](FusedLoc fusedLoc) -> Optional<Location> {
        -:  544:        // Fused location is unique in that we try to find a sub-location to
        -:  545:        // show, rather than the top-level location itself.
    #####:  546:        for (Location childLoc : fusedLoc.getLocations())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  547:          if (Optional<Location> showableLoc = findLocToShow(childLoc))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  548:            return showableLoc;
    #####:  549:        return llvm::None;
    #####:  550:      })
call    0 never executed
    #####:  551:      .Case([&](NameLoc nameLoc) -> Optional<Location> {
    #####:  552:        return findLocToShow(nameLoc.getChildLoc());
call    0 never executed
call    1 never executed
    #####:  553:      })
call    0 never executed
function _ZZN4mlir26SourceMgrDiagnosticHandler13findLocToShowENS_8LocationEENKUlNS_9OpaqueLocEE3_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  554:      .Case([&](OpaqueLoc opaqueLoc) -> Optional<Location> {
        -:  555:        // OpaqueLoc always falls back to a different source location.
    #####:  556:        return findLocToShow(opaqueLoc.getFallbackLocation());
call    0 never executed
call    1 never executed
    #####:  557:      })
call    0 never executed
        -:  558:      .Case([](UnknownLoc) -> Optional<Location> {
        -:  559:        // Prefer not to show unknown locations.
        -:  560:        return llvm::None;
    #####:  561:      });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  562:}
        -:  563:
        -:  564:/// Get a memory buffer for the given file, or the main file of the source
        -:  565:/// manager if one doesn't exist. This always returns non-null.
function _ZN4mlir26SourceMgrDiagnosticHandler17convertLocToSMLocENS_14FileLineColLocE called 3253765 returned 100% blocks executed 93%
  3253765:  566:SMLoc SourceMgrDiagnosticHandler::convertLocToSMLoc(FileLineColLoc loc) {
        -:  567:  // The column and line may be zero to represent unknown column and/or unknown
        -:  568:  /// line/column information.
  3253765:  569:  if (loc.getLine() == 0 || loc.getColumn() == 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
        3:  570:    return SMLoc();
        -:  571:
  3253762:  572:  unsigned bufferId = impl->getSourceMgrBufferIDForFile(mgr, loc.getFilename());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  3253762:  573:  if (!bufferId)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  574:    return SMLoc();
  3253762:  575:  return mgr.FindLocForLineAndColumn(bufferId, loc.getLine(), loc.getColumn());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  576:}
        -:  577:
        -:  578://===----------------------------------------------------------------------===//
        -:  579:// SourceMgrDiagnosticVerifierHandler
        -:  580://===----------------------------------------------------------------------===//
        -:  581:
        -:  582:namespace mlir {
        -:  583:namespace detail {
        -:  584:/// This class represents an expected output diagnostic.
    #####:  585:struct ExpectedDiag {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  586:  ExpectedDiag(DiagnosticSeverity kind, unsigned lineNo, SMLoc fileLoc,
        -:  587:               StringRef substring)
    #####:  588:      : kind(kind), lineNo(lineNo), fileLoc(fileLoc), substring(substring) {}
        -:  589:
        -:  590:  /// Emit an error at the location referenced by this diagnostic.
function _ZN4mlir6detail12ExpectedDiag9emitErrorERN4llvm11raw_ostreamERNS2_9SourceMgrERKNS2_5TwineE called 0 returned 0% blocks executed 0%
    #####:  591:  LogicalResult emitError(raw_ostream &os, llvm::SourceMgr &mgr,
        -:  592:                          const Twine &msg) {
    #####:  593:    SMRange range(fileLoc, SMLoc::getFromPointer(fileLoc.getPointer() +
call    0 never executed
    #####:  594:                                                 substring.size()));
call    0 never executed
    #####:  595:    mgr.PrintMessage(os, fileLoc, llvm::SourceMgr::DK_Error, msg, range);
call    0 never executed
    #####:  596:    return failure();
        -:  597:  }
        -:  598:
        -:  599:  /// Returns true if this diagnostic matches the given string.
function _ZNK4mlir6detail12ExpectedDiag5matchEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  600:  bool match(StringRef str) const {
        -:  601:    // If this isn't a regex diagnostic, we simply check if the string was
        -:  602:    // contained.
    #####:  603:    if (substringRegex)
branch  0 never executed
branch  1 never executed
    #####:  604:      return substringRegex->match(str);
call    0 never executed
    #####:  605:    return str.contains(substring);
call    0 never executed
        -:  606:  }
        -:  607:
        -:  608:  /// Compute the regex matcher for this diagnostic, using the provided stream
        -:  609:  /// and manager to emit diagnostics as necessary.
function _ZN4mlir6detail12ExpectedDiag12computeRegexERN4llvm11raw_ostreamERNS2_9SourceMgrE called 0 returned 0% blocks executed 0%
    #####:  610:  LogicalResult computeRegex(raw_ostream &os, llvm::SourceMgr &mgr) {
    #####:  611:    std::string regexStr;
call    0 never executed
    #####:  612:    llvm::raw_string_ostream regexOS(regexStr);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  613:    StringRef strToProcess = substring;
    #####:  614:    while (!strToProcess.empty()) {
branch  0 never executed
branch  1 never executed
        -:  615:      // Find the next regex block.
    #####:  616:      size_t regexIt = strToProcess.find("{{");
call    0 never executed
    #####:  617:      if (regexIt == StringRef::npos) {
branch  0 never executed
branch  1 never executed
    #####:  618:        regexOS << llvm::Regex::escape(strToProcess);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  619:        break;
        -:  620:      }
    #####:  621:      regexOS << llvm::Regex::escape(strToProcess.take_front(regexIt));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  622:      strToProcess = strToProcess.drop_front(regexIt + 2);
call    0 never executed
        -:  623:
        -:  624:      // Find the end of the regex block.
    #####:  625:      size_t regexEndIt = strToProcess.find("}}");
call    0 never executed
    #####:  626:      if (regexEndIt == StringRef::npos)
branch  0 never executed
branch  1 never executed
    #####:  627:        return emitError(os, mgr, "found start of regex with no end '}}'");
call    0 never executed
call    1 never executed
    #####:  628:      StringRef regexStr = strToProcess.take_front(regexEndIt);
branch  0 never executed
branch  1 never executed
        -:  629:
        -:  630:      // Validate that the regex is actually valid.
    #####:  631:      std::string regexError;
call    0 never executed
    #####:  632:      if (!llvm::Regex(regexStr).isValid(regexError))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  633:        return emitError(os, mgr, "invalid regex: " + regexError);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  634:
    #####:  635:      regexOS << '(' << regexStr << ')';
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  636:      strToProcess = strToProcess.drop_front(regexEndIt + 2);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  637:    }
    #####:  638:    substringRegex = llvm::Regex(regexOS.str());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  639:    return success();
call    0 never executed
        -:  640:  }
        -:  641:
        -:  642:  /// The severity of the diagnosic expected.
        -:  643:  DiagnosticSeverity kind;
        -:  644:  /// The line number the expected diagnostic should be on.
        -:  645:  unsigned lineNo;
        -:  646:  /// The location of the expected diagnostic within the input file.
        -:  647:  SMLoc fileLoc;
        -:  648:  /// A flag indicating if the expected diagnostic has been matched yet.
        -:  649:  bool matched = false;
        -:  650:  /// The substring that is expected to be within the diagnostic.
        -:  651:  StringRef substring;
        -:  652:  /// An optional regex matcher, if the expected diagnostic sub-string was a
        -:  653:  /// regex string.
        -:  654:  Optional<llvm::Regex> substringRegex;
        -:  655:};
        -:  656:
        -:  657:struct SourceMgrDiagnosticVerifierHandlerImpl {
      986:  658:  SourceMgrDiagnosticVerifierHandlerImpl() : status(success()) {}
        -:  659:
        -:  660:  /// Returns the expected diagnostics for the given source file.
        -:  661:  Optional<MutableArrayRef<ExpectedDiag>> getExpectedDiags(StringRef bufName);
        -:  662:
        -:  663:  /// Computes the expected diagnostics for the given source buffer.
        -:  664:  MutableArrayRef<ExpectedDiag>
        -:  665:  computeExpectedDiags(raw_ostream &os, llvm::SourceMgr &mgr,
        -:  666:                       const llvm::MemoryBuffer *buf);
        -:  667:
        -:  668:  /// The current status of the verifier.
        -:  669:  LogicalResult status;
        -:  670:
        -:  671:  /// A list of expected diagnostics for each buffer of the source manager.
        -:  672:  llvm::StringMap<SmallVector<ExpectedDiag, 2>> expectedDiagsPerFile;
        -:  673:
        -:  674:  /// Regex to match the expected diagnostics format.
        -:  675:  llvm::Regex expected =
        -:  676:      llvm::Regex("expected-(error|note|remark|warning)(-re)? "
        -:  677:                  "*(@([+-][0-9]+|above|below))? *{{(.*)}}$");
        -:  678:};
        -:  679:} // namespace detail
        -:  680:} // namespace mlir
        -:  681:
        -:  682:/// Given a diagnostic kind, return a human readable string for it.
function _ZL14getDiagKindStrN4mlir18DiagnosticSeverityE called 21528 returned 100% blocks executed 71%
    21528:  683:static StringRef getDiagKindStr(DiagnosticSeverity kind) {
    21528:  684:  switch (kind) {
branch  0 taken 1%
branch  1 taken 0%
branch  2 taken 5%
branch  3 taken 95%
branch  4 taken 0%
       35:  685:  case DiagnosticSeverity::Note:
       35:  686:    return "note";
    #####:  687:  case DiagnosticSeverity::Warning:
    #####:  688:    return "warning";
      980:  689:  case DiagnosticSeverity::Error:
      980:  690:    return "error";
    20513:  691:  case DiagnosticSeverity::Remark:
    20513:  692:    return "remark";
        -:  693:  }
    #####:  694:  llvm_unreachable("Unknown DiagnosticSeverity");
call    0 never executed
        -:  695:}
        -:  696:
        -:  697:Optional<MutableArrayRef<ExpectedDiag>>
function _ZN4mlir6detail38SourceMgrDiagnosticVerifierHandlerImpl16getExpectedDiagsEN4llvm9StringRefE called 17930 returned 100% blocks executed 100%
    17930:  698:SourceMgrDiagnosticVerifierHandlerImpl::getExpectedDiags(StringRef bufName) {
    17930:  699:  auto expectedDiags = expectedDiagsPerFile.find(bufName);
call    0 returned 100%
    17930:  700:  if (expectedDiags != expectedDiagsPerFile.end())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    17929:  701:    return MutableArrayRef<ExpectedDiag>(expectedDiags->second);
        1:  702:  return llvm::None;
        -:  703:}
        -:  704:
        -:  705:MutableArrayRef<ExpectedDiag>
function _ZN4mlir6detail38SourceMgrDiagnosticVerifierHandlerImpl20computeExpectedDiagsERN4llvm11raw_ostreamERNS2_9SourceMgrEPKNS2_12MemoryBufferE called 494 returned 100% blocks executed 24%
      494:  706:SourceMgrDiagnosticVerifierHandlerImpl::computeExpectedDiags(
        -:  707:    raw_ostream &os, llvm::SourceMgr &mgr, const llvm::MemoryBuffer *buf) {
        -:  708:  // If the buffer is invalid, return an empty list.
      494:  709:  if (!buf)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  710:    return llvm::None;
      494:  711:  auto &expectedDiags = expectedDiagsPerFile[buf->getBufferIdentifier()];
call    0 returned 100%
call    1 returned 100%
        -:  712:
        -:  713:  // The number of the last line that did not correlate to a designator.
      494:  714:  unsigned lastNonDesignatorLine = 0;
        -:  715:
        -:  716:  // The indices of designators that apply to the next non designator line.
      494:  717:  SmallVector<unsigned, 1> designatorsForNextLine;
call    0 returned 100%
        -:  718:
        -:  719:  // Scan the file for expected-* designators.
      494:  720:  SmallVector<StringRef, 100> lines;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      494:  721:  buf->getBuffer().split(lines, '\n');
call    0 returned 100%
  1096022:  722:  for (unsigned lineNo = 0, e = lines.size(); lineNo < e; ++lineNo) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
 1095528*:  723:    SmallVector<StringRef, 4> matches;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1095528:  724:    if (!expected.match(lines[lineNo].rtrim(), &matches)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  725:      // Check for designators that apply to this line.
  1095528:  726:      if (!designatorsForNextLine.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  727:        for (unsigned diagIndex : designatorsForNextLine)
branch  0 never executed
branch  1 never executed
    #####:  728:          expectedDiags[diagIndex].lineNo = lineNo + 1;
branch  0 never executed
branch  1 never executed
    #####:  729:        designatorsForNextLine.clear();
        -:  730:      }
  1095528:  731:      lastNonDesignatorLine = lineNo;
  2191056:  732:      continue;
        -:  733:    }
        -:  734:
        -:  735:    // Point to the start of expected-*.
    #####:  736:    SMLoc expectedStart = SMLoc::getFromPointer(matches[0].data());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  737:
    #####:  738:    DiagnosticSeverity kind;
    #####:  739:    if (matches[1] == "error")
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  740:      kind = DiagnosticSeverity::Error;
    #####:  741:    else if (matches[1] == "warning")
branch  0 never executed
branch  1 never executed
        -:  742:      kind = DiagnosticSeverity::Warning;
    #####:  743:    else if (matches[1] == "remark")
branch  0 never executed
branch  1 never executed
        -:  744:      kind = DiagnosticSeverity::Remark;
        -:  745:    else {
    #####:  746:      assert(matches[1] == "note");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  747:      kind = DiagnosticSeverity::Note;
        -:  748:    }
    #####:  749:    ExpectedDiag record(kind, lineNo + 1, expectedStart, matches[5]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  750:
        -:  751:    // Check to see if this is a regex match, i.e. it includes the `-re`.
    #####:  752:    if (!matches[2].empty() && failed(record.computeRegex(os, mgr))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  753:      status = failure();
branch  0 never executed
branch  1 never executed
 1095528*:  754:      continue;
branch  0 never executed
branch  1 never executed
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  755:    }
        -:  756:
    #####:  757:    StringRef offsetMatch = matches[3];
branch  0 never executed
branch  1 never executed
    #####:  758:    if (!offsetMatch.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  759:      offsetMatch = offsetMatch.drop_front(1);
call    0 never executed
        -:  760:
        -:  761:      // Get the integer value without the @ and +/- prefix.
    #####:  762:      if (offsetMatch[0] == '+' || offsetMatch[0] == '-') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  763:        int offset;
    #####:  764:        offsetMatch.drop_front().getAsInteger(0, offset);
call    0 never executed
call    1 never executed
        -:  765:
    #####:  766:        if (offsetMatch.front() == '+')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:          record.lineNo += offset;
        -:  768:        else
    #####:  769:          record.lineNo -= offset;
    #####:  770:      } else if (offsetMatch.consume_front("above")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  771:        // If the designator applies 'above' we add it to the last non
        -:  772:        // designator line.
    #####:  773:        record.lineNo = lastNonDesignatorLine + 1;
        -:  774:      } else {
        -:  775:        // Otherwise, this is a 'below' designator and applies to the next
        -:  776:        // non-designator line.
    #####:  777:        assert(offsetMatch.consume_front("below"));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  778:        designatorsForNextLine.push_back(expectedDiags.size());
call    0 never executed
        -:  779:
        -:  780:        // Set the line number to the last in the case that this designator ends
        -:  781:        // up dangling.
    #####:  782:        record.lineNo = e;
        -:  783:      }
        -:  784:    }
    #####:  785:    expectedDiags.emplace_back(std::move(record));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  786:  }
      494:  787:  return expectedDiags;
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:  788:}
        -:  789:
function _ZN4mlir34SourceMgrDiagnosticVerifierHandlerC2ERN4llvm9SourceMgrEPNS_11MLIRContextERNS1_11raw_ostreamE called 493 returned 100% blocks executed 100%
      493:  790:SourceMgrDiagnosticVerifierHandler::SourceMgrDiagnosticVerifierHandler(
      493:  791:    llvm::SourceMgr &srcMgr, MLIRContext *ctx, raw_ostream &out)
        -:  792:    : SourceMgrDiagnosticHandler(srcMgr, ctx, out),
      493:  793:      impl(new SourceMgrDiagnosticVerifierHandlerImpl()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  794:  // Compute the expected diagnostics for each of the current files in the
        -:  795:  // source manager.
      986:  796:  for (unsigned i = 0, e = mgr.getNumBuffers(); i != e; ++i)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      493:  797:    (void)impl->computeExpectedDiags(out, mgr, mgr.getMemoryBuffer(i + 1));
call    0 returned 100%
call    1 returned 100%
        -:  798:
        -:  799:  // Register a handler to verify the diagnostics.
function _ZZN4mlir34SourceMgrDiagnosticVerifierHandlerC4ERN4llvm9SourceMgrEPNS_11MLIRContextERNS1_11raw_ostreamEENKUlRNS_10DiagnosticEE_clES9_.isra.0 called 21493 returned 100% blocks executed 100%
    21986:  800:  setHandler([&](Diagnostic &diag) {
call    0 returned 100%
        -:  801:    // Process the main diagnostics.
    21493:  802:    process(diag);
call    0 returned 100%
        -:  803:
        -:  804:    // Process each of the notes.
    21528:  805:    for (auto &note : diag.getNotes())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       35:  806:      process(note);
call    0 returned 100%
    21493:  807:  });
      493:  808:}
        -:  809:
function _ZN4mlir34SourceMgrDiagnosticVerifierHandlerC2ERN4llvm9SourceMgrEPNS_11MLIRContextE called 493 returned 100% blocks executed 100%
      493:  810:SourceMgrDiagnosticVerifierHandler::SourceMgrDiagnosticVerifierHandler(
      493:  811:    llvm::SourceMgr &srcMgr, MLIRContext *ctx)
      493:  812:    : SourceMgrDiagnosticVerifierHandler(srcMgr, ctx, llvm::errs()) {}
call    0 returned 100%
call    1 returned 100%
        -:  813:
function _ZN4mlir34SourceMgrDiagnosticVerifierHandlerD2Ev called 491 returned 100% blocks executed 100%
      982:  814:SourceMgrDiagnosticVerifierHandler::~SourceMgrDiagnosticVerifierHandler() {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  815:  // Ensure that all expected diagnostics were handled.
      491:  816:  (void)verify();
call    0 returned 100%
      491:  817:}
        -:  818:
        -:  819:/// Returns the status of the verifier and verifies that all expected
        -:  820:/// diagnostics were emitted. This return success if all diagnostics were
        -:  821:/// verified correctly, failure otherwise.
function _ZN4mlir34SourceMgrDiagnosticVerifierHandler6verifyEv called 982 returned 100% blocks executed 55%
      982:  822:LogicalResult SourceMgrDiagnosticVerifierHandler::verify() {
        -:  823:  // Verify that all expected errors were seen.
     2948:  824:  for (auto &expectedDiagsPair : impl->expectedDiagsPerFile) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
     492*:  825:    for (auto &err : expectedDiagsPair.second) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  826:      if (err.matched)
branch  0 never executed
branch  1 never executed
    #####:  827:        continue;
    #####:  828:      impl->status =
        -:  829:          err.emitError(os, mgr,
    #####:  830:                        "expected " + getDiagKindStr(err.kind) + " \"" +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  831:                            err.substring + "\" was not produced");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  832:    }
        -:  833:  }
      982:  834:  impl->expectedDiagsPerFile.clear();
call    0 returned 100%
      982:  835:  return impl->status;
        -:  836:}
        -:  837:
        -:  838:/// Process a single diagnostic.
function _ZN4mlir34SourceMgrDiagnosticVerifierHandler7processERNS_10DiagnosticE called 21528 returned 100% blocks executed 100%
    21528:  839:void SourceMgrDiagnosticVerifierHandler::process(Diagnostic &diag) {
    21528:  840:  auto kind = diag.getSeverity();
call    0 returned 100%
        -:  841:
        -:  842:  // Process a FileLineColLoc.
    21528:  843:  if (auto fileLoc = diag.getLocation()->findInstanceOf<FileLineColLoc>())
call    0 returned 100%
branch  1 taken 83% (fallthrough)
branch  2 taken 17%
    35860:  844:    return process(fileLoc, diag.str(), kind);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  845:
     7196:  846:  emitDiagnostic(diag.getLocation(),
call    0 returned 100%
call    1 returned 100%
    10794:  847:                 "unexpected " + getDiagKindStr(kind) + ": " + diag.str(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
        -:  848:                 DiagnosticSeverity::Error);
     3598:  849:  impl->status = failure();
        -:  850:}
        -:  851:
        -:  852:/// Process a FileLineColLoc diagnostic.
function _ZN4mlir34SourceMgrDiagnosticVerifierHandler7processENS_14FileLineColLocEN4llvm9StringRefENS_18DiagnosticSeverityE called 17930 returned 100% blocks executed 57%
    17930:  853:void SourceMgrDiagnosticVerifierHandler::process(FileLineColLoc loc,
        -:  854:                                                 StringRef msg,
        -:  855:                                                 DiagnosticSeverity kind) {
        -:  856:  // Get the expected diagnostics for this file.
    17930:  857:  auto diags = impl->getExpectedDiags(loc.getFilename());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    17930:  858:  if (!diags) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  859:    diags = impl->computeExpectedDiags(os, mgr,
        1:  860:                                       getBufferForFile(loc.getFilename()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  861:  }
        -:  862:
        -:  863:  // Search for a matching expected diagnostic.
        -:  864:  // If we find something that is close then emit a more specific error.
    17930:  865:  ExpectedDiag *nearMiss = nullptr;
        -:  866:
        -:  867:  // If this was an expected error, remember that we saw it and return.
    17930:  868:  unsigned line = loc.getLine();
call    0 returned 100%
   17930*:  869:  for (auto &e : *diags) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  870:    if (line == e.lineNo && e.match(msg)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  871:      if (e.kind == kind) {
branch  0 never executed
branch  1 never executed
    #####:  872:        e.matched = true;
    #####:  873:        return;
        -:  874:      }
        -:  875:
        -:  876:      // If this only differs based on the diagnostic kind, then consider it
        -:  877:      // to be a near miss.
        -:  878:      nearMiss = &e;
        -:  879:    }
        -:  880:  }
        -:  881:
        -:  882:  // Otherwise, emit an error for the near miss.
    17930:  883:  if (nearMiss)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  884:    mgr.PrintMessage(os, nearMiss->fileLoc, llvm::SourceMgr::DK_Error,
call    0 never executed
    #####:  885:                     "'" + getDiagKindStr(kind) +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  886:                         "' diagnostic emitted when expecting a '" +
call    0 never executed
call    1 never executed
    #####:  887:                         getDiagKindStr(nearMiss->kind) + "'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  888:  else
    17930:  889:    emitDiagnostic(loc, "unexpected " + getDiagKindStr(kind) + ": " + msg,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 returned 100%
        -:  890:                   DiagnosticSeverity::Error);
    17930:  891:  impl->status = failure();
        -:  892:}
        -:  893:
        -:  894://===----------------------------------------------------------------------===//
        -:  895:// ParallelDiagnosticHandler
        -:  896://===----------------------------------------------------------------------===//
        -:  897:
        -:  898:namespace mlir {
        -:  899:namespace detail {
        -:  900:struct ParallelDiagnosticHandlerImpl : public llvm::PrettyStackTraceEntry {
   17459*:  901:  struct ThreadDiagnostic {
call    0 never executed
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 returned 100%
call   14 never executed
call   15 never executed
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 returned 100%
call   26 returned 100%
call   27 returned 100%
call   28 returned 100%
call   29 returned 100%
call   30 returned 100%
call   31 returned 100%
call   32 returned 100%
call   33 returned 100%
call   34 never executed
call   35 returned 100%
call   36 returned 100%
        -:  902:    ThreadDiagnostic(size_t id, Diagnostic diag)
        -:  903:        : id(id), diag(std::move(diag)) {}
    2132*:  904:    bool operator<(const ThreadDiagnostic &rhs) const { return id < rhs.id; }
branch  0 never executed
branch  1 never executed
branch  2 taken 45%
branch  3 taken 55%
branch  4 taken 32% (fallthrough)
branch  5 taken 68%
branch  6 taken 24%
branch  7 taken 76%
branch  8 taken 20% (fallthrough)
branch  9 taken 80%
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 taken 21% (fallthrough)
branch 21 taken 79%
        -:  905:
        -:  906:    /// The id for this diagnostic, this is used for ordering.
        -:  907:    /// Note: This id corresponds to the ordered position of the current element
        -:  908:    ///       being processed by a given thread.
        -:  909:    size_t id;
        -:  910:
        -:  911:    /// The diagnostic.
        -:  912:    Diagnostic diag;
        -:  913:  };
        -:  914:
function _ZN4mlir6detail29ParallelDiagnosticHandlerImplC2EPNS_11MLIRContextE called 7979 returned 100% blocks executed 100%
     7979:  915:  ParallelDiagnosticHandlerImpl(MLIRContext *ctx) : context(ctx) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function _ZZN4mlir6detail29ParallelDiagnosticHandlerImplC4EPNS_11MLIRContextEENKUlRNS_10DiagnosticEE_clES5_ called 3223 returned 100% blocks executed 91%
     7979:  916:    handlerID = ctx->getDiagEngine().registerHandler([this](Diagnostic &diag) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     3223:  917:      uint64_t tid = llvm::get_threadid();
call    0 returned 100%
     3223:  918:      llvm::sys::SmartScopedLock<true> lock(mutex);
call    0 returned 100%
        -:  919:
        -:  920:      // If this thread is not tracked, then return failure to let another
        -:  921:      // handler process this diagnostic.
    3223*:  922:      if (!threadToOrderID.count(tid))
call    0 returned 100%
    #####:  923:        return failure();
        -:  924:
        -:  925:      // Append a new diagnostic.
     3223:  926:      diagnostics.emplace_back(threadToOrderID[tid], std::move(diag));
call    0 returned 100%
call    1 returned 100%
     3223:  927:      return success();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  928:    });
     7979:  929:  }
        -:  930:
    15958:  931:  ~ParallelDiagnosticHandlerImpl() override {
        -:  932:    // Erase this handler from the context.
     7979:  933:    context->getDiagEngine().eraseHandler(handlerID);
        -:  934:
        -:  935:    // Early exit if there are no diagnostics, this is the common case.
     7979:  936:    if (diagnostics.empty())
     5689:  937:      return;
        -:  938:
        -:  939:    // Emit the diagnostics back to the context.
     5513:  940:    emitDiagnostics([&](Diagnostic &diag) {
     3223:  941:      return context->getDiagEngine().emit(std::move(diag));
call    0 returned 100%
call    1 returned 100%
        -:  942:    });
    15958:  943:  }
------------------
_ZN4mlir6detail29ParallelDiagnosticHandlerImplD0Ev:
function _ZN4mlir6detail29ParallelDiagnosticHandlerImplD0Ev called 7979 returned 100% blocks executed 100%
     7979:  931:  ~ParallelDiagnosticHandlerImpl() override {
        -:  932:    // Erase this handler from the context.
        -:  933:    context->getDiagEngine().eraseHandler(handlerID);
        -:  934:
        -:  935:    // Early exit if there are no diagnostics, this is the common case.
        -:  936:    if (diagnostics.empty())
        -:  937:      return;
        -:  938:
        -:  939:    // Emit the diagnostics back to the context.
        -:  940:    emitDiagnostics([&](Diagnostic &diag) {
        -:  941:      return context->getDiagEngine().emit(std::move(diag));
        -:  942:    });
     7979:  943:  }
call    0 returned 100%
call    1 returned 100%
------------------
_ZN4mlir6detail29ParallelDiagnosticHandlerImplD2Ev:
function _ZN4mlir6detail29ParallelDiagnosticHandlerImplD2Ev called 7979 returned 100% blocks executed 100%
     7979:  931:  ~ParallelDiagnosticHandlerImpl() override {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  932:    // Erase this handler from the context.
     7979:  933:    context->getDiagEngine().eraseHandler(handlerID);
call    0 returned 100%
call    1 returned 100%
        -:  934:
        -:  935:    // Early exit if there are no diagnostics, this is the common case.
     7979:  936:    if (diagnostics.empty())
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
     5689:  937:      return;
call    0 returned 100%
        -:  938:
        -:  939:    // Emit the diagnostics back to the context.
     2290:  940:    emitDiagnostics([&](Diagnostic &diag) {
call    0 returned 100%
call    1 returned 100%
        -:  941:      return context->getDiagEngine().emit(std::move(diag));
        -:  942:    });
     7979:  943:  }
------------------
        -:  944:
        -:  945:  /// Utility method to emit any held diagnostics.
function _ZNK4mlir6detail29ParallelDiagnosticHandlerImpl15emitDiagnosticsEN4llvm12function_refIFvRNS_10DiagnosticEEEE called 2290 returned 100% blocks executed 100%
     2290:  946:  void emitDiagnostics(llvm::function_ref<void(Diagnostic &)> emitFn) const {
        -:  947:    // Stable sort all of the diagnostics that were emitted. This creates a
        -:  948:    // deterministic ordering for the diagnostics based upon which order id they
        -:  949:    // were emitted for.
     2290:  950:    std::stable_sort(diagnostics.begin(), diagnostics.end());
call    0 returned 100%
        -:  951:
        -:  952:    // Emit each diagnostic to the context again.
     5513:  953:    for (ThreadDiagnostic &diag : diagnostics)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
call    2 returned 100%
     3223:  954:      emitFn(diag.diag);
call    0 returned 100%
     2290:  955:  }
        -:  956:
        -:  957:  /// Set the order id for the current thread.
function _ZN4mlir6detail29ParallelDiagnosticHandlerImpl19setOrderIDForThreadEm called 72291 returned 101% blocks executed 100%
    72291:  958:  void setOrderIDForThread(size_t orderID) {
    72291:  959:    uint64_t tid = llvm::get_threadid();
call    0 returned 100%
    72350:  960:    llvm::sys::SmartScopedLock<true> lock(mutex);
call    0 returned 101%
    72734:  961:    threadToOrderID[tid] = orderID;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    72676:  962:  }
        -:  963:
        -:  964:  /// Remove the order id for the current thread.
function _ZN4mlir6detail29ParallelDiagnosticHandlerImpl21eraseOrderIDForThreadEv called 67831 returned 107% blocks executed 100%
    67831:  965:  void eraseOrderIDForThread() {
    67831:  966:    uint64_t tid = llvm::get_threadid();
call    0 returned 105%
    71468:  967:    llvm::sys::SmartScopedLock<true> lock(mutex);
call    0 returned 102%
    72734:  968:    threadToOrderID.erase(tid);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    72654:  969:  }
        -:  970:
        -:  971:  /// Dump the current diagnostics that were inflight.
function _ZNK4mlir6detail29ParallelDiagnosticHandlerImpl5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  972:  void print(raw_ostream &os) const override {
        -:  973:    // Early exit if there are no diagnostics, this is the common case.
    #####:  974:    if (diagnostics.empty())
branch  0 never executed
branch  1 never executed
        -:  975:      return;
        -:  976:
    #####:  977:    os << "In-Flight Diagnostics:\n";
call    0 never executed
function _ZZNK4mlir6detail29ParallelDiagnosticHandlerImpl5printERN4llvm11raw_ostreamEENKUlRKNS_10DiagnosticEE_clES7_ called 0 returned 0% blocks executed 0%
    #####:  978:    emitDiagnostics([&](const Diagnostic &diag) {
call    0 never executed
    #####:  979:      os.indent(4);
call    0 never executed
        -:  980:
        -:  981:      // Print each diagnostic with the format:
        -:  982:      //   "<location>: <kind>: <msg>"
    #####:  983:      if (!diag.getLocation().isa<UnknownLoc>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  984:        os << diag.getLocation() << ": ";
call    0 never executed
call    1 never executed
    #####:  985:      switch (diag.getSeverity()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  986:      case DiagnosticSeverity::Error:
    #####:  987:        os << "error: ";
    #####:  988:        break;
call    0 never executed
    #####:  989:      case DiagnosticSeverity::Warning:
    #####:  990:        os << "warning: ";
    #####:  991:        break;
call    0 never executed
    #####:  992:      case DiagnosticSeverity::Note:
    #####:  993:        os << "note: ";
    #####:  994:        break;
call    0 never executed
    #####:  995:      case DiagnosticSeverity::Remark:
    #####:  996:        os << "remark: ";
    #####:  997:        break;
call    0 never executed
        -:  998:      }
    #####:  999:      os << diag << '\n';
branch  0 never executed
branch  1 never executed
    #####: 1000:    });
        -: 1001:  }
        -: 1002:
        -: 1003:  /// A smart mutex to lock access to the internal state.
        -: 1004:  llvm::sys::SmartMutex<true> mutex;
        -: 1005:
        -: 1006:  /// A mapping between the thread id and the current order id.
        -: 1007:  DenseMap<uint64_t, size_t> threadToOrderID;
        -: 1008:
        -: 1009:  /// An unordered list of diagnostics that were emitted.
        -: 1010:  mutable std::vector<ThreadDiagnostic> diagnostics;
        -: 1011:
        -: 1012:  /// The unique id for the parallel handler.
        -: 1013:  DiagnosticEngine::HandlerID handlerID = 0;
        -: 1014:
        -: 1015:  /// The context to emit the diagnostics to.
        -: 1016:  MLIRContext *context;
        -: 1017:};
        -: 1018:} // namespace detail
        -: 1019:} // namespace mlir
        -: 1020:
function _ZN4mlir25ParallelDiagnosticHandlerC2EPNS_11MLIRContextE called 7979 returned 100% blocks executed 100%
     7979: 1021:ParallelDiagnosticHandler::ParallelDiagnosticHandler(MLIRContext *ctx)
     7979: 1022:    : impl(new ParallelDiagnosticHandlerImpl(ctx)) {}
call    0 returned 100%
call    1 returned 100%
        -: 1023:ParallelDiagnosticHandler::~ParallelDiagnosticHandler() = default;
        -: 1024:
        -: 1025:/// Set the order id for the current thread.
function _ZN4mlir25ParallelDiagnosticHandler19setOrderIDForThreadEm called 72363 returned 100% blocks executed 100%
    72363: 1026:void ParallelDiagnosticHandler::setOrderIDForThread(size_t orderID) {
    72363: 1027:  impl->setOrderIDForThread(orderID);
call    0 returned 100%
    72641: 1028:}
        -: 1029:
        -: 1030:/// Remove the order id for the current thread. This removes the thread from
        -: 1031:/// diagnostics tracking.
function _ZN4mlir25ParallelDiagnosticHandler21eraseOrderIDForThreadEv called 67871 returned 107% blocks executed 100%
    67871: 1032:void ParallelDiagnosticHandler::eraseOrderIDForThread() {
    67871: 1033:  impl->eraseOrderIDForThread();
call    0 returned 107%
    72617: 1034:}
