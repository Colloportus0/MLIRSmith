        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/AffineExpr.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineExpr.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineExpr.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- AffineExpr.cpp - MLIR Affine Expr Classes --------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include <utility>
        -:   10:
        -:   11:#include "AffineExprDetail.h"
        -:   12:#include "mlir/IR/AffineExpr.h"
        -:   13:#include "mlir/IR/AffineExprVisitor.h"
        -:   14:#include "mlir/IR/AffineMap.h"
        -:   15:#include "mlir/IR/IntegerSet.h"
        -:   16:#include "mlir/Support/MathExtras.h"
        -:   17:#include "mlir/Support/TypeID.h"
        -:   18:#include "llvm/ADT/STLExtras.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:using namespace mlir::detail;
        -:   23:
function _ZNK4mlir10AffineExpr10getContextEv called 1072574609 returned 100% blocks executed 100%
2389430391*:   24:MLIRContext *AffineExpr::getContext() const { return expr->context; }
        -:   25:
function _ZNK4mlir10AffineExpr7getKindEv called 32423816367 returned 100% blocks executed 100%
18501438315*:   26:AffineExprKind AffineExpr::getKind() const { return expr->kind; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 taken 1%
branch 26 taken 1%
branch 27 taken 1%
branch 28 taken 1%
branch 29 taken 1%
branch 30 taken 60%
branch 31 taken 39%
branch 32 taken 1%
branch 33 taken 0%
branch 34 taken 0% (fallthrough)
branch 35 taken 100%
branch 36 taken 0% (fallthrough)
branch 37 taken 100%
branch 38 taken 0% (fallthrough)
branch 39 taken 100%
branch 40 taken 0% (fallthrough)
branch 41 taken 100%
branch 42 taken 0% (fallthrough)
branch 43 taken 100%
branch 44 taken 0% (fallthrough)
branch 45 taken 100%
branch 46 taken 0% (fallthrough)
branch 47 taken 100%
branch 48 taken 0% (fallthrough)
branch 49 taken 100%
branch 50 taken 1% (fallthrough)
branch 51 taken 100%
branch 52 taken 0% (fallthrough)
branch 53 taken 100%
branch 54 taken 1% (fallthrough)
branch 55 taken 100%
branch 56 taken 0% (fallthrough)
branch 57 taken 100%
branch 58 taken 0% (fallthrough)
branch 59 taken 100%
branch 60 never executed
branch 61 never executed
branch 62 taken 100% (fallthrough)
branch 63 taken 0%
branch 64 taken 0% (fallthrough)
branch 65 taken 100%
branch 66 never executed
branch 67 never executed
branch 68 taken 0% (fallthrough)
branch 69 taken 100%
branch 70 never executed
branch 71 never executed
call   72 never executed
branch 73 never executed
branch 74 never executed
branch 75 taken 100% (fallthrough)
branch 76 taken 0%
branch 77 taken 0% (fallthrough)
branch 78 taken 100%
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 taken 96% (fallthrough)
branch 84 taken 4%
branch 85 taken 0% (fallthrough)
branch 86 taken 100%
branch 87 taken 61% (fallthrough)
branch 88 taken 39%
branch 89 taken 0% (fallthrough)
branch 90 taken 100%
branch 91 taken 94% (fallthrough)
branch 92 taken 6%
branch 93 taken 1% (fallthrough)
branch 94 taken 100%
branch 95 taken 57% (fallthrough)
branch 96 taken 43%
branch 97 taken 0% (fallthrough)
branch 98 taken 100%
branch 99 taken 93% (fallthrough)
branch 100 taken 7%
branch 101 taken 0% (fallthrough)
branch 102 taken 100%
branch 103 taken 55% (fallthrough)
branch 104 taken 45%
branch 105 taken 0% (fallthrough)
branch 106 taken 100%
branch 107 taken 81% (fallthrough)
branch 108 taken 19%
branch 109 taken 1% (fallthrough)
branch 110 taken 100%
branch 111 taken 100% (fallthrough)
branch 112 taken 0%
branch 113 taken 98% (fallthrough)
branch 114 taken 2%
branch 115 taken 1% (fallthrough)
branch 116 taken 100%
branch 117 taken 100% (fallthrough)
branch 118 taken 0%
branch 119 taken 38% (fallthrough)
branch 120 taken 62%
branch 121 taken 37% (fallthrough)
branch 122 taken 63%
branch 123 taken 73% (fallthrough)
branch 124 taken 27%
branch 125 taken 36% (fallthrough)
branch 126 taken 64%
branch 127 taken 93% (fallthrough)
branch 128 taken 7%
branch 129 taken 64% (fallthrough)
branch 130 taken 36%
branch 131 taken 1% (fallthrough)
branch 132 taken 100%
branch 133 taken 39% (fallthrough)
branch 134 taken 61%
branch 135 taken 1% (fallthrough)
branch 136 taken 100%
branch 137 taken 100% (fallthrough)
branch 138 taken 1%
branch 139 taken 99% (fallthrough)
branch 140 taken 1%
branch 141 taken 1% (fallthrough)
branch 142 taken 100%
branch 143 taken 100% (fallthrough)
branch 144 taken 0%
branch 145 taken 1% (fallthrough)
branch 146 taken 99%
branch 147 taken 0% (fallthrough)
branch 148 taken 100%
branch 149 taken 0% (fallthrough)
branch 150 taken 100%
branch 151 taken 0% (fallthrough)
branch 152 taken 100%
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 taken 0% (fallthrough)
branch 164 taken 100%
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 taken 50% (fallthrough)
branch 178 taken 50%
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 taken 0% (fallthrough)
branch 186 taken 100%
branch 187 taken 0% (fallthrough)
branch 188 taken 100%
branch 189 taken 0% (fallthrough)
branch 190 taken 100%
branch 191 taken 0% (fallthrough)
branch 192 taken 100%
branch 193 taken 0% (fallthrough)
branch 194 taken 100%
branch 195 taken 100% (fallthrough)
branch 196 taken 0%
branch 197 taken 100% (fallthrough)
branch 198 taken 1%
branch 199 taken 0% (fallthrough)
branch 200 taken 100%
branch 201 taken 1% (fallthrough)
branch 202 taken 100%
branch 203 taken 0% (fallthrough)
branch 204 taken 100%
call   205 returned 100%
branch 206 taken 0% (fallthrough)
branch 207 taken 100%
branch 208 taken 0% (fallthrough)
branch 209 taken 100%
branch 210 taken 0% (fallthrough)
branch 211 taken 100%
        -:   27:
        -:   28:/// Walk all of the AffineExprs in this subgraph in postorder.
function _ZNK4mlir10AffineExpr4walkESt8functionIFvS0_EE called 12494039173 returned 100% blocks executed 83%
12494039173:   29:void AffineExpr::walk(std::function<void(AffineExpr)> callback) const {
37482112695:   30:  struct AffineExprWalker : public AffineExprVisitor<AffineExprWalker> {
        -:   31:    std::function<void(AffineExpr)> callback;
        -:   32:
12494039173:   33:    AffineExprWalker(std::function<void(AffineExpr)> callback)
12494039173:   34:        : callback(std::move(callback)) {}
call    0 returned 100%
        -:   35:
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker23visitAffineBinaryOpExprENS_18AffineBinaryOpExprE called 15350423 returned 100% blocks executed 75%
 15350423:   36:    void visitAffineBinaryOpExpr(AffineBinaryOpExpr expr) { callback(expr); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker17visitConstantExprENS_18AffineConstantExprE called 7575538597 returned 100% blocks executed 75%
7575538597:   37:    void visitConstantExpr(AffineConstantExpr expr) { callback(expr); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker12visitDimExprENS_13AffineDimExprE called 4933067589 returned 100% blocks executed 75%
4933067589:   38:    void visitDimExpr(AffineDimExpr expr) { callback(expr); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
function _ZZNK4mlir10AffineExpr4walkESt8functionIFvS0_EEEN16AffineExprWalker15visitSymbolExprENS_16AffineSymbolExprE called 788875 returned 100% blocks executed 75%
   788875:   39:    void visitSymbolExpr(AffineSymbolExpr expr) { callback(expr); }
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   40:  };
        -:   41:
24988075768:   42:  AffineExprWalker(std::move(callback)).walkPostOrder(*this);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
12494036595:   43:}
        -:   44:
        -:   45:// Dispatch affine expression construction based on kind.
function _ZN4mlir21getAffineBinaryOpExprENS_14AffineExprKindENS_10AffineExprES1_ called 1375630 returned 100% blocks executed 92%
  1464217:   46:AffineExpr mlir::getAffineBinaryOpExpr(AffineExprKind kind, AffineExpr lhs,
        -:   47:                                       AffineExpr rhs) {
  1375630:   48:  if (kind == AffineExprKind::Add)
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
   527102:   49:    return lhs + rhs;
call    0 returned 100%
   848528:   50:  if (kind == AffineExprKind::Mul)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
   403474:   51:    return lhs * rhs;
call    0 returned 100%
   445054:   52:  if (kind == AffineExprKind::FloorDiv)
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
   133620:   53:    return lhs.floorDiv(rhs);
call    0 returned 100%
   311434:   54:  if (kind == AffineExprKind::CeilDiv)
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
   182221:   55:    return lhs.ceilDiv(rhs);
call    0 returned 100%
   129213:   56:  if (kind == AffineExprKind::Mod)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   129213:   57:    return lhs % rhs;
call    0 returned 100%
        -:   58:
    #####:   59:  llvm_unreachable("unknown binary operation on affine expressions");
call    0 never executed
        -:   60:}
        -:   61:
        -:   62:/// This method substitutes any uses of dimensions and symbols (e.g.
        -:   63:/// dim#0 with dimReplacements[0]) and returns the modified expression tree.
        -:   64:AffineExpr
function _ZNK4mlir10AffineExpr21replaceDimsAndSymbolsEN4llvm8ArrayRefIS0_EES3_ called 6143565657 returned 100% blocks executed 86%
6143565657:   65:AffineExpr::replaceDimsAndSymbols(ArrayRef<AffineExpr> dimReplacements,
        -:   66:                                  ArrayRef<AffineExpr> symReplacements) const {
6143565657:   67:  switch (getKind()) {
branch  0 taken 45%
branch  1 taken 55%
branch  2 taken 1%
branch  3 taken 1%
branch  4 taken 0%
2788539812:   68:  case AffineExprKind::Constant:
2788539812:   69:    return *this;
3353013408:   70:  case AffineExprKind::DimId: {
3353013408:   71:    unsigned dimId = cast<AffineDimExpr>().getPosition();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
3353013408:   72:    if (dimId >= dimReplacements.size())
1463070237:   73:      return *this;
1889943171:   74:    return dimReplacements[dimId];
        -:   75:  }
   613742:   76:  case AffineExprKind::SymbolId: {
   613742:   77:    unsigned symId = cast<AffineSymbolExpr>().getPosition();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   613742:   78:    if (symId >= symReplacements.size())
    11137:   79:      return *this;
   602605:   80:    return symReplacements[symId];
        -:   81:  }
  1398695:   82:  case AffineExprKind::Add:
  1398695:   83:  case AffineExprKind::Mul:
  1398695:   84:  case AffineExprKind::FloorDiv:
  1398695:   85:  case AffineExprKind::CeilDiv:
  1398695:   86:  case AffineExprKind::Mod:
  1398695:   87:    auto binOp = cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1398695:   88:    auto lhs = binOp.getLHS(), rhs = binOp.getRHS();
  1398695:   89:    auto newLHS = lhs.replaceDimsAndSymbols(dimReplacements, symReplacements);
  1398694:   90:    auto newRHS = rhs.replaceDimsAndSymbols(dimReplacements, symReplacements);
call    0 returned 100%
  1398694:   91:    if (newLHS == lhs && newRHS == rhs)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
    28850:   92:      return *this;
  1369844:   93:    return getAffineBinaryOpExpr(getKind(), newLHS, newRHS);
call    0 returned 100%
        -:   94:  }
    #####:   95:  llvm_unreachable("Unknown AffineExpr");
        -:   96:}
        -:   97:
function _ZNK4mlir10AffineExpr11replaceDimsEN4llvm8ArrayRefIS0_EE called 0 returned 0% blocks executed 0%
    #####:   98:AffineExpr AffineExpr::replaceDims(ArrayRef<AffineExpr> dimReplacements) const {
    #####:   99:  return replaceDimsAndSymbols(dimReplacements, {});
call    0 never executed
        -:  100:}
        -:  101:
        -:  102:AffineExpr
function _ZNK4mlir10AffineExpr14replaceSymbolsEN4llvm8ArrayRefIS0_EE called 0 returned 0% blocks executed 0%
    #####:  103:AffineExpr::replaceSymbols(ArrayRef<AffineExpr> symReplacements) const {
    #####:  104:  return replaceDimsAndSymbols({}, symReplacements);
call    0 never executed
        -:  105:}
        -:  106:
        -:  107:/// Replace dims[offset ... numDims)
        -:  108:/// by dims[offset + shift ... shift + numDims).
function _ZNK4mlir10AffineExpr9shiftDimsEjjj called 17369 returned 100% blocks executed 79%
    17369:  109:AffineExpr AffineExpr::shiftDims(unsigned numDims, unsigned shift,
        -:  110:                                 unsigned offset) const {
    17369:  111:  SmallVector<AffineExpr, 4> dims;
   17369*:  112:  for (unsigned idx = 0; idx < offset; ++idx)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  113:    dims.push_back(getAffineDimExpr(idx, getContext()));
call    0 never executed
    27582:  114:  for (unsigned idx = offset; idx < numDims; ++idx)
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
    10213:  115:    dims.push_back(getAffineDimExpr(idx + shift, getContext()));
call    0 returned 100%
    17369:  116:  return replaceDimsAndSymbols(dims, {});
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        -:  117:}
        -:  118:
        -:  119:/// Replace symbols[offset ... numSymbols)
        -:  120:/// by symbols[offset + shift ... shift + numSymbols).
function _ZNK4mlir10AffineExpr12shiftSymbolsEjjj called 1454526944 returned 100% blocks executed 79%
1454526944:  121:AffineExpr AffineExpr::shiftSymbols(unsigned numSymbols, unsigned shift,
        -:  122:                                    unsigned offset) const {
1454526944:  123:  SmallVector<AffineExpr, 4> symbols;
1454526947:  124:  for (unsigned idx = 0; idx < offset; ++idx)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  125:    symbols.push_back(getAffineSymbolExpr(idx, getContext()));
1454527826:  126:  for (unsigned idx = offset; idx < numSymbols; ++idx)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     1762:  127:    symbols.push_back(getAffineSymbolExpr(idx + shift, getContext()));
1454526945:  128:  return replaceDimsAndSymbols({}, symbols);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  129:}
        -:  130:
        -:  131:/// Sparse replace method. Return the modified expression tree.
        -:  132:AffineExpr
function _ZNK4mlir10AffineExpr7replaceERKN4llvm8DenseMapIS0_S0_NS1_12DenseMapInfoIS0_vEENS1_6detail12DenseMapPairIS0_S0_EEEE called 17767 returned 100% blocks executed 100%
    17767:  133:AffineExpr::replace(const DenseMap<AffineExpr, AffineExpr> &map) const {
    17767:  134:  auto it = map.find(*this);
call    0 returned 100%
    17767:  135:  if (it != map.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 19% (fallthrough)
branch  3 taken 81%
     3460:  136:    return it->second;
call    0 returned 100%
    14307:  137:  switch (getKind()) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
    10132:  138:  default:
    10132:  139:    return *this;
     4175:  140:  case AffineExprKind::Add:
     4175:  141:  case AffineExprKind::Mul:
     4175:  142:  case AffineExprKind::FloorDiv:
     4175:  143:  case AffineExprKind::CeilDiv:
     4175:  144:  case AffineExprKind::Mod:
     4175:  145:    auto binOp = cast<AffineBinaryOpExpr>();
call    0 returned 100%
     4175:  146:    auto lhs = binOp.getLHS(), rhs = binOp.getRHS();
     4175:  147:    auto newLHS = lhs.replace(map);
     4175:  148:    auto newRHS = rhs.replace(map);
call    0 returned 100%
     4175:  149:    if (newLHS == lhs && newRHS == rhs)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
     3725:  150:      return *this;
      450:  151:    return getAffineBinaryOpExpr(getKind(), newLHS, newRHS);
call    0 returned 100%
        -:  152:  }
        -:  153:  llvm_unreachable("Unknown AffineExpr");
        -:  154:}
        -:  155:
        -:  156:/// Sparse replace method. Return the modified expression tree.
function _ZNK4mlir10AffineExpr7replaceES0_S0_ called 9417 returned 100% blocks executed 100%
     9417:  157:AffineExpr AffineExpr::replace(AffineExpr expr, AffineExpr replacement) const {
     9417:  158:  DenseMap<AffineExpr, AffineExpr> map;
call    0 returned 100%
     9417:  159:  map.insert(std::make_pair(expr, replacement));
call    0 returned 100%
     9417:  160:  return replace(map);
call    0 returned 100%
call    1 returned 100%
        -:  161:}
        -:  162:/// Returns true if this expression is made out of only symbols and
        -:  163:/// constants (no dimensional identifiers).
function _ZNK4mlir10AffineExpr20isSymbolicOrConstantEv called 883735292 returned 100% blocks executed 75%
883735292:  164:bool AffineExpr::isSymbolicOrConstant() const {
883735292:  165:  switch (getKind()) {
branch  0 taken 41%
branch  1 taken 13%
branch  2 taken 0%
branch  3 taken 47%
        -:  166:  case AffineExprKind::Constant:
        -:  167:    return true;
358929547:  168:  case AffineExprKind::DimId:
358929547:  169:    return false;
        -:  170:  case AffineExprKind::SymbolId:
        -:  171:    return true;
        -:  172:
112071687:  173:  case AffineExprKind::Add:
112071687:  174:  case AffineExprKind::Mul:
112071687:  175:  case AffineExprKind::FloorDiv:
112071687:  176:  case AffineExprKind::CeilDiv:
112071687:  177:  case AffineExprKind::Mod: {
112071687:  178:    auto expr = this->cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
112603247:  179:    return expr.getLHS().isSymbolicOrConstant() &&
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
112071687:  180:           expr.getRHS().isSymbolicOrConstant();
        -:  181:  }
        -:  182:  }
    #####:  183:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  184:}
        -:  185:
        -:  186:/// Returns true if this is a pure affine expression, i.e., multiplication,
        -:  187:/// floordiv, ceildiv, and mod is only allowed w.r.t constants.
function _ZNK4mlir10AffineExpr12isPureAffineEv called 986313115 returned 100% blocks executed 86%
986313115:  188:bool AffineExpr::isPureAffine() const {
986313115:  189:  switch (getKind()) {
branch  0 taken 14%
branch  1 taken 13%
branch  2 taken 1%
branch  3 taken 0%
branch  4 taken 73%
        -:  190:  case AffineExprKind::SymbolId:
        -:  191:  case AffineExprKind::DimId:
        -:  192:  case AffineExprKind::Constant:
        -:  193:    return true;
133677360:  194:  case AffineExprKind::Add: {
133677360:  195:    auto op = cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
267355251:  196:    return op.getLHS().isPureAffine() && op.getRHS().isPureAffine();
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        -:  197:  }
        -:  198:
128321470:  199:  case AffineExprKind::Mul: {
        -:  200:    // TODO: Canonicalize the constants in binary operators to the RHS when
        -:  201:    // possible, allowing this to merge into the next case.
128321470:  202:    auto op = cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
384964394:  203:    return op.getLHS().isPureAffine() && op.getRHS().isPureAffine() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
128321462:  204:           (op.getLHS().template isa<AffineConstantExpr>() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
128321462:  205:            op.getRHS().template isa<AffineConstantExpr>());
        -:  206:  }
    55156:  207:  case AffineExprKind::FloorDiv:
    55156:  208:  case AffineExprKind::CeilDiv:
    55156:  209:  case AffineExprKind::Mod: {
    55156:  210:    auto op = cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    55176:  211:    return op.getLHS().isPureAffine() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
    55156:  212:           op.getRHS().template isa<AffineConstantExpr>();
        -:  213:  }
        -:  214:  }
    #####:  215:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  216:}
        -:  217:
        -:  218:// Returns the greatest known integral divisor of this affine expression.
function _ZNK4mlir10AffineExpr22getLargestKnownDivisorEv called 4639329 returned 100% blocks executed 80%
  4639329:  219:int64_t AffineExpr::getLargestKnownDivisor() const {
  4639329:  220:  AffineBinaryOpExpr binExpr(nullptr);
  4639329:  221:  switch (getKind()) {
branch  0 taken 22%
branch  1 taken 10%
branch  2 taken 11%
branch  3 taken 0%
branch  4 taken 57%
        -:  222:  case AffineExprKind::CeilDiv:
        -:  223:    [[fallthrough]];
        -:  224:  case AffineExprKind::DimId:
        -:  225:  case AffineExprKind::FloorDiv:
        -:  226:  case AffineExprKind::SymbolId:
        -:  227:    return 1;
  1033513:  228:  case AffineExprKind::Constant:
  1033513:  229:    return std::abs(this->cast<AffineConstantExpr>().getValue());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   446831:  230:  case AffineExprKind::Mul: {
   446831:  231:    binExpr = this->cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1340493:  232:    return binExpr.getLHS().getLargestKnownDivisor() *
   446831:  233:           binExpr.getRHS().getLargestKnownDivisor();
        -:  234:  }
   507678:  235:  case AffineExprKind::Add:
   507678:  236:    [[fallthrough]];
   507678:  237:  case AffineExprKind::Mod: {
   507678:  238:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   507678:  239:    return std::gcd((uint64_t)binExpr.getLHS().getLargestKnownDivisor(),
   507678:  240:                    (uint64_t)binExpr.getRHS().getLargestKnownDivisor());
        -:  241:  }
        -:  242:  }
    #####:  243:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  244:}
        -:  245:
function _ZNK4mlir10AffineExpr12isMultipleOfEl called 0 returned 0% blocks executed 0%
    #####:  246:bool AffineExpr::isMultipleOf(int64_t factor) const {
    #####:  247:  AffineBinaryOpExpr binExpr(nullptr);
    #####:  248:  uint64_t l, u;
    #####:  249:  switch (getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  250:  case AffineExprKind::SymbolId:
    #####:  251:    [[fallthrough]];
    #####:  252:  case AffineExprKind::DimId:
    #####:  253:    return factor * factor == 1;
    #####:  254:  case AffineExprKind::Constant:
    #####:  255:    return cast<AffineConstantExpr>().getValue() % factor == 0;
branch  0 never executed
branch  1 never executed
    #####:  256:  case AffineExprKind::Mul: {
    #####:  257:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
        -:  258:    // It's probably not worth optimizing this further (to not traverse the
        -:  259:    // whole sub-tree under - it that would require a version of isMultipleOf
        -:  260:    // that on a 'false' return also returns the largest known divisor).
    #####:  261:    return (l = binExpr.getLHS().getLargestKnownDivisor()) % factor == 0 ||
    #####:  262:           (u = binExpr.getRHS().getLargestKnownDivisor()) % factor == 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  263:           (l * u) % factor == 0;
branch  0 never executed
branch  1 never executed
        -:  264:  }
    #####:  265:  case AffineExprKind::Add:
    #####:  266:  case AffineExprKind::FloorDiv:
    #####:  267:  case AffineExprKind::CeilDiv:
    #####:  268:  case AffineExprKind::Mod: {
    #####:  269:    binExpr = cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  270:    return std::gcd((uint64_t)binExpr.getLHS().getLargestKnownDivisor(),
    #####:  271:                    (uint64_t)binExpr.getRHS().getLargestKnownDivisor()) %
    #####:  272:               factor ==
    #####:  273:           0;
        -:  274:  }
        -:  275:  }
    #####:  276:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  277:}
        -:  278:
function _ZNK4mlir10AffineExpr15isFunctionOfDimEj called 517731027 returned 100% blocks executed 92%
517731027:  279:bool AffineExpr::isFunctionOfDim(unsigned position) const {
517731027:  280:  if (getKind() == AffineExprKind::DimId) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
517712857:  281:    return *this == mlir::getAffineDimExpr(position, getContext());
        -:  282:  }
    18171:  283:  if (auto expr = this->dyn_cast<AffineBinaryOpExpr>()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    17994:  284:    return expr.getLHS().isFunctionOfDim(position) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     8997:  285:           expr.getRHS().isFunctionOfDim(position);
        -:  286:  }
        -:  287:  return false;
        -:  288:}
        -:  289:
function _ZNK4mlir10AffineExpr18isFunctionOfSymbolEj called 0 returned 0% blocks executed 0%
    #####:  290:bool AffineExpr::isFunctionOfSymbol(unsigned position) const {
    #####:  291:  if (getKind() == AffineExprKind::SymbolId) {
branch  0 never executed
branch  1 never executed
    #####:  292:    return *this == mlir::getAffineSymbolExpr(position, getContext());
        -:  293:  }
    #####:  294:  if (auto expr = this->dyn_cast<AffineBinaryOpExpr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  295:    return expr.getLHS().isFunctionOfSymbol(position) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  296:           expr.getRHS().isFunctionOfSymbol(position);
        -:  297:  }
        -:  298:  return false;
        -:  299:}
        -:  300:
function _ZN4mlir18AffineBinaryOpExprC2EPNS_6detail17AffineExprStorageE called 241340762 returned 100% blocks executed 100%
858173342*:  301:AffineBinaryOpExpr::AffineBinaryOpExpr(AffineExpr::ImplType *ptr)
858380890*:  302:    : AffineExpr(ptr) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 39% (fallthrough)
branch 13 taken 61%
branch 14 taken 43% (fallthrough)
branch 15 taken 57%
branch 16 taken 45% (fallthrough)
branch 17 taken 55%
branch 18 taken 2% (fallthrough)
branch 19 taken 98%
branch 20 taken 64% (fallthrough)
branch 21 taken 36%
branch 22 taken 64% (fallthrough)
branch 23 taken 36%
branch 24 taken 61% (fallthrough)
branch 25 taken 39%
branch 26 taken 1% (fallthrough)
branch 27 taken 100%
branch 28 taken 0% (fallthrough)
branch 29 taken 100%
branch 30 taken 1% (fallthrough)
branch 31 taken 99%
call   32 returned 100%
call   33 returned 100%
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 taken 50% (fallthrough)
branch 46 taken 50%
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
call   52 never executed
call   53 never executed
branch 54 taken 22%
branch 55 taken 10%
branch 56 taken 11%
branch 57 taken 0%
branch 58 taken 57%
call   59 returned 100%
call   60 returned 100%
call   61 returned 100%
call   62 returned 100%
call   63 returned 100%
call   64 returned 100%
call   65 returned 100%
call   66 returned 100%
function _ZNK4mlir18AffineBinaryOpExpr6getLHSEv called 187472752 returned 100% blocks executed 100%
854042180*:  303:AffineExpr AffineBinaryOpExpr::getLHS() const {
518761068*:  304:  return static_cast<ImplType *>(expr)->lhs;
call    0 never executed
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
call   13 returned 100%
        -:  305:}
function _ZNK4mlir18AffineBinaryOpExpr6getRHSEv called 185808672 returned 100% blocks executed 100%
813670088*:  306:AffineExpr AffineBinaryOpExpr::getRHS() const {
408623664*:  307:  return static_cast<ImplType *>(expr)->rhs;
call    0 never executed
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 1%
branch 12 taken 1% (fallthrough)
branch 13 taken 100%
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
        -:  308:}
        -:  309:
function _ZN4mlir13AffineDimExprC2EPNS_6detail17AffineExprStorageE called 16744362363 returned 100% blocks executed 100%
8286081109*:  310:AffineDimExpr::AffineDimExpr(AffineExpr::ImplType *ptr) : AffineExpr(ptr) {}
call    0 never executed
call    1 returned 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 44% (fallthrough)
branch  6 taken 56%
function _ZNK4mlir13AffineDimExpr11getPositionEv called 9884473548 returned 100% blocks executed 100%
13443821021*:  311:unsigned AffineDimExpr::getPosition() const {
3456180431*:  312:  return static_cast<ImplType *>(expr)->position;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 44% (fallthrough)
branch  3 taken 56%
        -:  313:}
        -:  314:
        -:  315:/// Returns true if the expression is divisible by the given symbol with
        -:  316:/// position `symbolPos`. The argument `opKind` specifies here what kind of
        -:  317:/// division or mod operation called this division. It helps in implementing the
        -:  318:/// commutative property of the floordiv and ceildiv operations. If the argument
        -:  319:///`exprKind` is floordiv and `expr` is also a binary expression of a floordiv
        -:  320:/// operation, then the commutative property can be used otherwise, the floordiv
        -:  321:/// operation is not divisible. The same argument holds for ceildiv operation.
function _ZL19isDivisibleBySymbolN4mlir10AffineExprEjNS_14AffineExprKindE called 10 returned 100% blocks executed 14%
       10:  322:static bool isDivisibleBySymbol(AffineExpr expr, unsigned symbolPos,
        -:  323:                                AffineExprKind opKind) {
        -:  324:  // The argument `opKind` can either be Modulo, Floordiv or Ceildiv only.
      10*:  325:  assert((opKind == AffineExprKind::Mod || opKind == AffineExprKind::FloorDiv ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  326:          opKind == AffineExprKind::CeilDiv) &&
        -:  327:         "unexpected opKind");
       10:  328:  switch (expr.getKind()) {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
       10:  329:  case AffineExprKind::Constant:
       10:  330:    return expr.cast<AffineConstantExpr>().getValue() == 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  331:  case AffineExprKind::DimId:
        -:  332:    return false;
    #####:  333:  case AffineExprKind::SymbolId:
    #####:  334:    return (expr.cast<AffineSymbolExpr>().getPosition() == symbolPos);
branch  0 never executed
branch  1 never executed
        -:  335:  // Checks divisibility by the given symbol for both operands.
    #####:  336:  case AffineExprKind::Add: {
    #####:  337:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  338:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  339:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
        -:  340:  }
        -:  341:  // Checks divisibility by the given symbol for both operands. Consider the
        -:  342:  // expression `(((s1*s0) floordiv w) mod ((s1 * s2) floordiv p)) floordiv s1`,
        -:  343:  // this is a division by s1 and both the operands of modulo are divisible by
        -:  344:  // s1 but it is not divisible by s1 always. The third argument is
        -:  345:  // `AffineExprKind::Mod` for this reason.
    #####:  346:  case AffineExprKind::Mod: {
    #####:  347:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  348:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos,
call    0 never executed
    #####:  349:                               AffineExprKind::Mod) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  350:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos,
call    0 never executed
        -:  351:                               AffineExprKind::Mod);
        -:  352:  }
        -:  353:  // Checks if any of the operand divisible by the given symbol.
    #####:  354:  case AffineExprKind::Mul: {
    #####:  355:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  356:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  357:           isDivisibleBySymbol(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
        -:  358:  }
        -:  359:  // Floordiv and ceildiv are divisible by the given symbol when the first
        -:  360:  // operand is divisible, and the affine expression kind of the argument expr
        -:  361:  // is same as the argument `opKind`. This can be inferred from commutative
        -:  362:  // property of floordiv and ceildiv operations and are as follow:
        -:  363:  // (exp1 floordiv exp2) floordiv exp3 = (exp1 floordiv exp3) floordiv exp2
        -:  364:  // (exp1 ceildiv exp2) ceildiv exp3 = (exp1 ceildiv exp3) ceildiv expr2
        -:  365:  // It will fail if operations are not same. For example:
        -:  366:  // (exps1 ceildiv exp2) floordiv exp3 can not be simplified.
    #####:  367:  case AffineExprKind::FloorDiv:
    #####:  368:  case AffineExprKind::CeilDiv: {
    #####:  369:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  370:    if (opKind != expr.getKind())
branch  0 never executed
branch  1 never executed
        -:  371:      return false;
    #####:  372:    return isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, expr.getKind());
call    0 never executed
        -:  373:  }
        -:  374:  }
    #####:  375:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  376:}
        -:  377:
        -:  378:/// Divides the given expression by the given symbol at position `symbolPos`. It
        -:  379:/// considers the divisibility condition is checked before calling itself. A
        -:  380:/// null expression is returned whenever the divisibility condition fails.
function _ZL14symbolicDivideN4mlir10AffineExprEjNS_14AffineExprKindE called 0 returned 0% blocks executed 0%
    #####:  381:static AffineExpr symbolicDivide(AffineExpr expr, unsigned symbolPos,
        -:  382:                                 AffineExprKind opKind) {
        -:  383:  // THe argument `opKind` can either be Modulo, Floordiv or Ceildiv only.
    #####:  384:  assert((opKind == AffineExprKind::Mod || opKind == AffineExprKind::FloorDiv ||
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  385:          opKind == AffineExprKind::CeilDiv) &&
        -:  386:         "unexpected opKind");
    #####:  387:  switch (expr.getKind()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  388:  case AffineExprKind::Constant:
    #####:  389:    if (expr.cast<AffineConstantExpr>().getValue() != 0)
branch  0 never executed
branch  1 never executed
    #####:  390:      return nullptr;
    #####:  391:    return getAffineConstantExpr(0, expr.getContext());
call    0 never executed
    #####:  392:  case AffineExprKind::DimId:
    #####:  393:    return nullptr;
    #####:  394:  case AffineExprKind::SymbolId:
    #####:  395:    return getAffineConstantExpr(1, expr.getContext());
call    0 never executed
        -:  396:  // Dividing both operands by the given symbol.
    #####:  397:  case AffineExprKind::Add: {
    #####:  398:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  399:    return getAffineBinaryOpExpr(
        -:  400:        expr.getKind(), symbolicDivide(binaryExpr.getLHS(), symbolPos, opKind),
    #####:  401:        symbolicDivide(binaryExpr.getRHS(), symbolPos, opKind));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  402:  }
        -:  403:  // Dividing both operands by the given symbol.
    #####:  404:  case AffineExprKind::Mod: {
    #####:  405:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  406:    return getAffineBinaryOpExpr(
        -:  407:        expr.getKind(),
        -:  408:        symbolicDivide(binaryExpr.getLHS(), symbolPos, expr.getKind()),
    #####:  409:        symbolicDivide(binaryExpr.getRHS(), symbolPos, expr.getKind()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  410:  }
        -:  411:  // Dividing any of the operand by the given symbol.
    #####:  412:  case AffineExprKind::Mul: {
    #####:  413:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  414:    if (!isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, opKind))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  415:      return binaryExpr.getLHS() *
    #####:  416:             symbolicDivide(binaryExpr.getRHS(), symbolPos, opKind);
call    0 never executed
call    1 never executed
    #####:  417:    return symbolicDivide(binaryExpr.getLHS(), symbolPos, opKind) *
    #####:  418:           binaryExpr.getRHS();
call    0 never executed
call    1 never executed
        -:  419:  }
        -:  420:  // Dividing first operand only by the given symbol.
    #####:  421:  case AffineExprKind::FloorDiv:
    #####:  422:  case AffineExprKind::CeilDiv: {
    #####:  423:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 never executed
branch  1 never executed
    #####:  424:    return getAffineBinaryOpExpr(
        -:  425:        expr.getKind(),
        -:  426:        symbolicDivide(binaryExpr.getLHS(), symbolPos, expr.getKind()),
    #####:  427:        binaryExpr.getRHS());
call    0 never executed
call    1 never executed
        -:  428:  }
        -:  429:  }
    #####:  430:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  431:}
        -:  432:
        -:  433:/// Simplify a semi-affine expression by handling modulo, floordiv, or ceildiv
        -:  434:/// operations when the second operand simplifies to a symbol and the first
        -:  435:/// operand is divisible by that symbol. It can be applied to any semi-affine
        -:  436:/// expression. Returned expression can either be a semi-affine or pure affine
        -:  437:/// expression.
function _ZL18simplifySemiAffineN4mlir10AffineExprE called 2056 returned 100% blocks executed 68%
     2056:  438:static AffineExpr simplifySemiAffine(AffineExpr expr) {
     2056:  439:  switch (expr.getKind()) {
branch  0 taken 59%
branch  1 taken 41%
branch  2 taken 1%
branch  3 taken 0%
     1210:  440:  case AffineExprKind::Constant:
     1210:  441:  case AffineExprKind::DimId:
     1210:  442:  case AffineExprKind::SymbolId:
     1210:  443:    return expr;
      836:  444:  case AffineExprKind::Add:
      836:  445:  case AffineExprKind::Mul: {
      836:  446:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      836:  447:    return getAffineBinaryOpExpr(expr.getKind(),
        -:  448:                                 simplifySemiAffine(binaryExpr.getLHS()),
      836:  449:                                 simplifySemiAffine(binaryExpr.getRHS()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  450:  }
        -:  451:  // Check if the simplification of the second operand is a symbol, and the
        -:  452:  // first operand is divisible by it. If the operation is a modulo, a constant
        -:  453:  // zero expression is returned. In the case of floordiv and ceildiv, the
        -:  454:  // symbol from the simplification of the second operand divides the first
        -:  455:  // operand. Otherwise, simplification is not possible.
       10:  456:  case AffineExprKind::FloorDiv:
       10:  457:  case AffineExprKind::CeilDiv:
       10:  458:  case AffineExprKind::Mod: {
       10:  459:    AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       10:  460:    AffineExpr sLHS = simplifySemiAffine(binaryExpr.getLHS());
call    0 returned 100%
       10:  461:    AffineExpr sRHS = simplifySemiAffine(binaryExpr.getRHS());
call    0 returned 100%
       10:  462:    AffineSymbolExpr symbolExpr =
       10:  463:        simplifySemiAffine(binaryExpr.getRHS()).dyn_cast<AffineSymbolExpr>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       10:  464:    if (!symbolExpr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  465:      return getAffineBinaryOpExpr(expr.getKind(), sLHS, sRHS);
call    0 never executed
       10:  466:    unsigned symbolPos = symbolExpr.getPosition();
       10:  467:    if (!isDivisibleBySymbol(binaryExpr.getLHS(), symbolPos, expr.getKind()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  468:      return getAffineBinaryOpExpr(expr.getKind(), sLHS, sRHS);
call    0 returned 100%
    #####:  469:    if (expr.getKind() == AffineExprKind::Mod)
branch  0 never executed
branch  1 never executed
    #####:  470:      return getAffineConstantExpr(0, expr.getContext());
call    0 never executed
    #####:  471:    return symbolicDivide(sLHS, symbolPos, expr.getKind());
call    0 never executed
        -:  472:  }
        -:  473:  }
    #####:  474:  llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:  475:}
        -:  476:
function _ZL20getAffineDimOrSymbolN4mlir14AffineExprKindEjPNS_11MLIRContextE called 3211721180 returned 100% blocks executed 100%
3211721180:  477:static AffineExpr getAffineDimOrSymbol(AffineExprKind kind, unsigned position,
        -:  478:                                       MLIRContext *context) {
3212482930:  479:  auto assignCtx = [context](AffineDimExprStorage *storage) {
   761750:  480:    storage->context = context;
3211721180:  481:  };
        -:  482:
3211721180:  483:  StorageUniquer &uniquer = context->getAffineUniquer();
call    0 returned 100%
6423442410:  484:  return uniquer.get<AffineDimExprStorage>(
3211721095:  485:      assignCtx, static_cast<unsigned>(kind), position);
call    0 returned 100%
        -:  486:}
        -:  487:
function _ZN4mlir16getAffineDimExprEjPNS_11MLIRContextE called 2573186685 returned 100% blocks executed 100%
3194080976*:  488:AffineExpr mlir::getAffineDimExpr(unsigned position, MLIRContext *context) {
3194080932*:  489:  return getAffineDimOrSymbol(AffineExprKind::DimId, position, context);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
        -:  490:}
        -:  491:
function _ZN4mlir16AffineSymbolExprC2EPNS_6detail17AffineExprStorageE called 11991990215 returned 100% blocks executed 100%
11993392851*:  492:AffineSymbolExpr::AffineSymbolExpr(AffineExpr::ImplType *ptr)
 1402646*:  493:    : AffineExpr(ptr) {}
call    0 never executed
call    1 returned 100%
branch  2 never executed
branch  3 never executed
call    4 returned 100%
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
branch 11 taken 2% (fallthrough)
branch 12 taken 98%
function _ZNK4mlir16AffineSymbolExpr11getPositionEv called 791343 returned 100% blocks executed 100%
 1424086*:  494:unsigned AffineSymbolExpr::getPosition() const {
  623238*:  495:  return static_cast<ImplType *>(expr)->position;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
        -:  496:}
        -:  497:
function _ZN4mlir19getAffineSymbolExprEjPNS_11MLIRContextE called 17631725 returned 100% blocks executed 100%
17640482*:  498:AffineExpr mlir::getAffineSymbolExpr(unsigned position, MLIRContext *context) {
17632606*:  499:  return getAffineDimOrSymbol(AffineExprKind::SymbolId, position, context);
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 returned 100%
     881*:  500:  ;
call    0 never executed
call    1 returned 100%
        -:  501:}
        -:  502:
function _ZN4mlir18AffineConstantExprC2EPNS_6detail17AffineExprStorageE called 2328360460 returned 100% blocks executed 100%
10637984160*:  503:AffineConstantExpr::AffineConstantExpr(AffineExpr::ImplType *ptr)
8410792105*:  504:    : AffineExpr(ptr) {}
call    0 never executed
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 1% (fallthrough)
branch  9 taken 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 1%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
branch 18 taken 100% (fallthrough)
branch 19 taken 0%
branch 20 taken 1% (fallthrough)
branch 21 taken 100%
branch 22 taken 19% (fallthrough)
branch 23 taken 81%
branch 24 taken 100% (fallthrough)
branch 25 taken 1%
branch 26 taken 0% (fallthrough)
branch 27 taken 100%
branch 28 taken 37% (fallthrough)
branch 29 taken 63%
branch 30 taken 62% (fallthrough)
branch 31 taken 38%
branch 32 taken 7% (fallthrough)
branch 33 taken 93%
branch 34 taken 100% (fallthrough)
branch 35 taken 1%
branch 36 taken 100% (fallthrough)
branch 37 taken 1%
branch 38 taken 1% (fallthrough)
branch 39 taken 100%
branch 40 taken 100% (fallthrough)
branch 41 taken 1%
branch 42 never executed
branch 43 never executed
function _ZNK4mlir18AffineConstantExpr8getValueEv called 2139462070 returned 100% blocks executed 100%
3028278551*:  505:int64_t AffineConstantExpr::getValue() const {
 1033523*:  506:  return static_cast<ImplType *>(expr)->constant;
branch  0 never executed
branch  1 never executed
        -:  507:}
        -:  508:
function _ZNK4mlir10AffineExpreqEl called 7812 returned 100% blocks executed 100%
  1645919:  509:bool AffineExpr::operator==(int64_t v) const {
  1645919:  510:  return *this == getAffineConstantExpr(v, getContext());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  511:}
        -:  512:
function _ZN4mlir21getAffineConstantExprElPNS_11MLIRContextE called 3594840758 returned 100% blocks executed 100%
3594840758:  513:AffineExpr mlir::getAffineConstantExpr(int64_t constant, MLIRContext *context) {
3598360485:  514:  auto assignCtx = [context](AffineConstantExprStorage *storage) {
  3519727:  515:    storage->context = context;
3594840758:  516:  };
        -:  517:
3594840758:  518:  StorageUniquer &uniquer = context->getAffineUniquer();
call    0 returned 100%
3594840679:  519:  return uniquer.get<AffineConstantExprStorage>(assignCtx, constant);
call    0 returned 100%
        -:  520:}
        -:  521:
        -:  522:/// Simplify add expression. Return nullptr if it can't be simplified.
function _ZL11simplifyAddN4mlir10AffineExprES0_ called 404017414 returned 100% blocks executed 95%
404017414:  523:static AffineExpr simplifyAdd(AffineExpr lhs, AffineExpr rhs) {
404017414:  524:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
404017414:  525:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
        -:  526:  // Fold if both LHS, RHS are a constant.
404017414:  527:  if (lhsConst && rhsConst)
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
branch  2 taken 76% (fallthrough)
branch  3 taken 24%
190253918:  528:    return getAffineConstantExpr(lhsConst.getValue() + rhsConst.getValue(),
190253918:  529:                                 lhs.getContext());
call    0 returned 100%
        -:  530:
        -:  531:  // Canonicalize so that only the RHS is a constant. (4 + d0 becomes d0 + 4).
        -:  532:  // If only one of them is a symbolic expressions, make it the RHS.
368872853:  533:  if (lhs.isa<AffineConstantExpr>() ||
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
155386174:  534:      (lhs.isSymbolicOrConstant() && !rhs.isSymbolicOrConstant())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
 58655277:  535:    return rhs + lhs;
call    0 returned 100%
        -:  536:  }
        -:  537:
        -:  538:  // At this point, if there was a constant, it would be on the right.
        -:  539:
        -:  540:  // Addition with a zero is a noop, return the other input.
155108219:  541:  if (rhsConst) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
 63433659:  542:    if (rhsConst.getValue() == 0)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
 59860627:  543:      return lhs;
        -:  544:  }
        -:  545:  // Fold successive additions like (d0 + 2) + 3 into d0 + 5.
 95247592:  546:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
 95247592:  547:  if (lBin && rhsConst && lBin.getKind() == AffineExprKind::Add) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
branch  4 taken 40% (fallthrough)
branch  5 taken 60%
  1511538:  548:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>())
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
    56084:  549:      return lBin.getLHS() + (lrhs.getValue() + rhsConst.getValue());
call    0 returned 100%
        -:  550:  }
        -:  551:
        -:  552:  // Detect "c1 * expr + c_2 * expr" as "(c1 + c2) * expr".
        -:  553:  // c1 is rRhsConst, c2 is rLhsConst; firstExpr, secondExpr are their
        -:  554:  // respective multiplicands.
 95191508:  555:  Optional<int64_t> rLhsConst, rRhsConst;
 95191508:  556:  AffineExpr firstExpr, secondExpr;
 95191508:  557:  AffineConstantExpr rLhsConstExpr;
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
 95191508:  558:  auto lBinOpExpr = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
125716034:  559:  if (lBinOpExpr && lBinOpExpr.getKind() == AffineExprKind::Mul &&
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
 30524612:  560:      (rLhsConstExpr = lBinOpExpr.getRHS().dyn_cast<AffineConstantExpr>())) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
 30524440:  561:    rLhsConst = rLhsConstExpr.getValue();
 30524440:  562:    firstExpr = lBinOpExpr.getLHS();
        -:  563:  } else {
 95191508:  564:    rLhsConst = 1;
        -:  565:    firstExpr = lhs;
        -:  566:  }
        -:  567:
 95191508:  568:  auto rBinOpExpr = rhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
 95191508:  569:  AffineConstantExpr rRhsConstExpr;
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
152607115:  570:  if (rBinOpExpr && rBinOpExpr.getKind() == AffineExprKind::Mul &&
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
 57416734:  571:      (rRhsConstExpr = rBinOpExpr.getRHS().dyn_cast<AffineConstantExpr>())) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
 57414480:  572:    rRhsConst = rRhsConstExpr.getValue();
 57414480:  573:    secondExpr = rBinOpExpr.getLHS();
        -:  574:  } else {
 95191508:  575:    rRhsConst = 1;
        -:  576:    secondExpr = rhs;
        -:  577:  }
        -:  578:
 95191508:  579:  if (rLhsConst && rRhsConst && firstExpr == secondExpr)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    88587:  580:    return getAffineBinaryOpExpr(
        -:  581:        AffineExprKind::Mul, firstExpr,
    88587:  582:        getAffineConstantExpr(*rLhsConst + *rRhsConst, lhs.getContext()));
call    0 returned 100%
call    1 returned 100%
        -:  583:
        -:  584:  // When doing successive additions, bring constant to the right: turn (d0 + 2)
        -:  585:  // + d1 into (d0 + d1) + 2.
 95102921:  586:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 taken 64%
branch  1 taken 36%
branch  2 taken 48% (fallthrough)
branch  3 taken 52%
 57808700:  587:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
    14140:  588:      return lBin.getLHS() + rhs + lrhs;
call    0 returned 100%
call    1 returned 100%
        -:  589:    }
        -:  590:  }
        -:  591:
        -:  592:  // Detect and transform "expr - q * (expr floordiv q)" to "expr mod q", where
        -:  593:  // q may be a constant or symbolic expression. This leads to a much more
        -:  594:  // efficient form when 'c' is a power of two, and in general a more compact
        -:  595:  // and readable form.
        -:  596:
        -:  597:  // Process '(expr floordiv c) * (-c)'.
 95088781:  598:  if (!rBinOpExpr)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
 37361688:  599:    return nullptr;
        -:  600:
 57727093:  601:  auto lrhs = rBinOpExpr.getLHS();
 57727093:  602:  auto rrhs = rBinOpExpr.getRHS();
        -:  603:
 57727093:  604:  AffineExpr llrhs, rlrhs;
        -:  605:
        -:  606:  // Check if lrhsBinOpExpr is of the form (expr floordiv q) * q, where q is a
        -:  607:  // symbolic expression.
 57727093:  608:  auto lrhsBinOpExpr = lrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  609:  // Check rrhsConstOpExpr = -1.
 57727093:  610:  auto rrhsConstOpExpr = rrhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
 57727093:  611:  if (rrhsConstOpExpr && rrhsConstOpExpr.getValue() == -1 && lrhsBinOpExpr &&
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
branch  4 taken 40% (fallthrough)
branch  5 taken 60%
   507246:  612:      lrhsBinOpExpr.getKind() == AffineExprKind::Mul) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  613:    // Check llrhs = expr floordiv q.
       10:  614:    llrhs = lrhsBinOpExpr.getLHS();
        -:  615:    // Check rlrhs = q.
       10:  616:    rlrhs = lrhsBinOpExpr.getRHS();
       10:  617:    auto llrhsBinOpExpr = llrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      10*:  618:    if (!llrhsBinOpExpr || llrhsBinOpExpr.getKind() != AffineExprKind::FloorDiv)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
       10:  619:      return nullptr;
    #####:  620:    if (llrhsBinOpExpr.getRHS() == rlrhs && lhs == llrhsBinOpExpr.getLHS())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  621:      return lhs % rlrhs;
call    0 never executed
        -:  622:  }
        -:  623:
        -:  624:  // Process lrhs, which is 'expr floordiv c'.
 57727083:  625:  AffineBinaryOpExpr lrBinOpExpr = lrhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
 57727083:  626:  if (!lrBinOpExpr || lrBinOpExpr.getKind() != AffineExprKind::FloorDiv)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
 57631129:  627:    return nullptr;
        -:  628:
    95954:  629:  llrhs = lrBinOpExpr.getLHS();
    95954:  630:  rlrhs = lrBinOpExpr.getRHS();
        -:  631:
    95954:  632:  if (lhs == llrhs && rlrhs == -rrhs) {
branch  0 taken 21%
branch  1 taken 79%
call    2 returned 100%
branch  3 taken 77% (fallthrough)
branch  4 taken 23%
     4469:  633:    return lhs % rlrhs;
call    0 returned 100%
        -:  634:  }
    91485:  635:  return nullptr;
        -:  636:}
        -:  637:
function _ZNK4mlir10AffineExprplEl called 95508779 returned 100% blocks executed 100%
 95508779:  638:AffineExpr AffineExpr::operator+(int64_t v) const {
 95508779:  639:  return *this + getAffineConstantExpr(v, getContext());
call    0 returned 100%
call    1 returned 100%
        -:  640:}
function _ZNK4mlir10AffineExprplES0_ called 404017406 returned 100% blocks executed 100%
404017406:  641:AffineExpr AffineExpr::operator+(AffineExpr other) const {
404017406:  642:  if (auto simplified = simplifyAdd(*this, other))
call    0 returned 100%
branch  1 taken 76% (fallthrough)
branch  2 taken 24%
308933095:  643:    return simplified;
        -:  644:
 95084312:  645:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 returned 100%
 95084312:  646:  return uniquer.get<AffineBinaryOpExprStorage>(
 95084311:  647:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Add), *this, other);
call    0 returned 100%
        -:  648:}
        -:  649:
        -:  650:/// Simplify a multiply expression. Return nullptr if it can't be simplified.
function _ZL11simplifyMulN4mlir10AffineExprES0_ called 248915160 returned 100% blocks executed 88%
248915160:  651:static AffineExpr simplifyMul(AffineExpr lhs, AffineExpr rhs) {
248915160:  652:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
248915160:  653:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  654:
248915160:  655:  if (lhsConst && rhsConst)
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 46466240:  656:    return getAffineConstantExpr(lhsConst.getValue() * rhsConst.getValue(),
 46466240:  657:                                 lhs.getContext());
call    0 returned 100%
        -:  658:
202448920*:  659:  assert(lhs.isSymbolicOrConstant() || rhs.isSymbolicOrConstant());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        -:  660:
        -:  661:  // Canonicalize the mul expression so that the constant/symbolic term is the
        -:  662:  // RHS. If both the lhs and rhs are symbolic, swap them if the lhs is a
        -:  663:  // constant. (Note that a constant is trivially symbolic).
202448920:  664:  if (!rhs.isSymbolicOrConstant() || lhs.isa<AffineConstantExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  665:    // At least one of them has to be symbolic.
    #####:  666:    return rhs * lhs;
call    0 never executed
        -:  667:  }
        -:  668:
        -:  669:  // At this point, if there was a constant, it would be on the right.
        -:  670:
        -:  671:  // Multiplication with a one is a noop, return the other input.
202448919:  672:  if (rhsConst) {
branch  0 taken 100%
branch  1 taken 1%
202446475:  673:    if (rhsConst.getValue() == 1)
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
112120764:  674:      return lhs;
        -:  675:    // Multiplication with zero.
 90325711:  676:    if (rhsConst.getValue() == 0)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     4384:  677:      return rhsConst;
        -:  678:  }
        -:  679:
        -:  680:  // Fold successive multiplications: eg: (d0 * 2) * 3 into d0 * 6.
 90323771:  681:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
 90323771:  682:  if (lBin && rhsConst && lBin.getKind() == AffineExprKind::Mul) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 3% (fallthrough)
branch  5 taken 97%
    62503:  683:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
    62455:  684:      return lBin.getLHS() * (lrhs.getValue() * rhsConst.getValue());
call    0 returned 100%
        -:  685:  }
        -:  686:
        -:  687:  // When doing successive multiplication, bring constant to the right: turn (d0
        -:  688:  // * 2) * d1 into (d0 * d1) * 2.
 90261316:  689:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
       48:  690:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  691:      return (lBin.getLHS() * rhs) * lrhs;
call    0 never executed
call    1 never executed
        -:  692:    }
        -:  693:  }
        -:  694:
 90261316:  695:  return nullptr;
        -:  696:}
        -:  697:
function _ZNK4mlir10AffineExprmlEl called 104945066 returned 100% blocks executed 100%
104945066:  698:AffineExpr AffineExpr::operator*(int64_t v) const {
104945066:  699:  return *this * getAffineConstantExpr(v, getContext());
call    0 returned 100%
call    1 returned 100%
        -:  700:}
function _ZNK4mlir10AffineExprmlES0_ called 248915159 returned 100% blocks executed 100%
248915159:  701:AffineExpr AffineExpr::operator*(AffineExpr other) const {
248915159:  702:  if (auto simplified = simplifyMul(*this, other))
call    0 returned 100%
branch  1 taken 64% (fallthrough)
branch  2 taken 36%
158653843:  703:    return simplified;
        -:  704:
 90261316:  705:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 returned 100%
 90261321:  706:  return uniquer.get<AffineBinaryOpExprStorage>(
 90261316:  707:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Mul), *this, other);
call    0 returned 100%
        -:  708:}
        -:  709:
        -:  710:// Unary minus, delegate to operator*.
function _ZNK4mlir10AffineExprngEv called 4403689 returned 100% blocks executed 100%
  4403689:  711:AffineExpr AffineExpr::operator-() const {
  4403689:  712:  return *this * getAffineConstantExpr(-1, getContext());
call    0 returned 100%
call    1 returned 100%
        -:  713:}
        -:  714:
        -:  715:// Delegate to operator+.
function _ZNK4mlir10AffineExprmiEl called 6408 returned 100% blocks executed 100%
     6408:  716:AffineExpr AffineExpr::operator-(int64_t v) const { return *this + (-v); }
call    0 returned 100%
function _ZNK4mlir10AffineExprmiES0_ called 4383927 returned 100% blocks executed 100%
  4383927:  717:AffineExpr AffineExpr::operator-(AffineExpr other) const {
  4383927:  718:  return *this + (-other);
call    0 returned 100%
call    1 returned 100%
        -:  719:}
        -:  720:
function _ZL16simplifyFloorDivN4mlir10AffineExprES0_ called 1764438 returned 100% blocks executed 91%
  1764438:  721:static AffineExpr simplifyFloorDiv(AffineExpr lhs, AffineExpr rhs) {
  1764438:  722:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
  1764438:  723:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  724:
        -:  725:  // mlir floordiv by zero or negative numbers is undefined and preserved as is.
  1764438:  726:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  727:    return nullptr;
        -:  728:
  1764438:  729:  if (lhsConst)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
   126331:  730:    return getAffineConstantExpr(
   126331:  731:        floorDiv(lhsConst.getValue(), rhsConst.getValue()), lhs.getContext());
call    0 returned 100%
call    1 returned 100%
        -:  732:
        -:  733:  // Fold floordiv of a multiply with a constant that is a multiple of the
        -:  734:  // divisor. Eg: (i * 128) floordiv 64 = i * 2.
  1638107:  735:  if (rhsConst == 1)
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      406:  736:    return lhs;
        -:  737:
        -:  738:  // Simplify (expr * const) floordiv divConst when expr is known to be a
        -:  739:  // multiple of divConst.
  1637701:  740:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
  1637701:  741:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
   176980:  742:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  743:      // rhsConst is known to be a positive constant.
   176980:  744:      if (lrhs.getValue() % rhsConst.getValue() == 0)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     2013:  745:        return lBin.getLHS() * (lrhs.getValue() / rhsConst.getValue());
call    0 returned 100%
        -:  746:    }
        -:  747:  }
        -:  748:
        -:  749:  // Simplify (expr1 + expr2) floordiv divConst when either expr1 or expr2 is
        -:  750:  // known to be a multiple of divConst.
  1635688:  751:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
   252169:  752:    int64_t llhsDiv = lBin.getLHS().getLargestKnownDivisor();
call    0 returned 100%
   252169:  753:    int64_t lrhsDiv = lBin.getRHS().getLargestKnownDivisor();
call    0 returned 100%
        -:  754:    // rhsConst is known to be a positive constant.
   252169:  755:    if (llhsDiv % rhsConst.getValue() == 0 ||
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   250274:  756:        lrhsDiv % rhsConst.getValue() == 0)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    15468:  757:      return lBin.getLHS().floorDiv(rhsConst.getValue()) +
     5156:  758:             lBin.getRHS().floorDiv(rhsConst.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  759:  }
        -:  760:
  1630532:  761:  return nullptr;
        -:  762:}
        -:  763:
function _ZNK4mlir10AffineExpr8floorDivEm called 68624 returned 100% blocks executed 100%
    68624:  764:AffineExpr AffineExpr::floorDiv(uint64_t v) const {
    68624:  765:  return floorDiv(getAffineConstantExpr(v, getContext()));
call    0 returned 100%
call    1 returned 100%
        -:  766:}
function _ZNK4mlir10AffineExpr8floorDivES0_ called 1764438 returned 100% blocks executed 100%
  1764438:  767:AffineExpr AffineExpr::floorDiv(AffineExpr other) const {
  1764438:  768:  if (auto simplified = simplifyFloorDiv(*this, other))
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
   133906:  769:    return simplified;
        -:  770:
  1630532:  771:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 returned 100%
  1630532:  772:  return uniquer.get<AffineBinaryOpExprStorage>(
  1630532:  773:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::FloorDiv), *this,
call    0 returned 100%
  1630532:  774:      other);
        -:  775:}
        -:  776:
function _ZL15simplifyCeilDivN4mlir10AffineExprES0_ called 1893661 returned 100% blocks executed 88%
  1893661:  777:static AffineExpr simplifyCeilDiv(AffineExpr lhs, AffineExpr rhs) {
  1893661:  778:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
  1893661:  779:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  780:
  1893661:  781:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
       59:  782:    return nullptr;
        -:  783:
  1893602:  784:  if (lhsConst)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
   109165:  785:    return getAffineConstantExpr(
   109165:  786:        ceilDiv(lhsConst.getValue(), rhsConst.getValue()), lhs.getContext());
call    0 returned 100%
call    1 returned 100%
        -:  787:
        -:  788:  // Fold ceildiv of a multiply with a constant that is a multiple of the
        -:  789:  // divisor. Eg: (i * 128) ceildiv 64 = i * 2.
  1784437:  790:  if (rhsConst.getValue() == 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       25:  791:    return lhs;
        -:  792:
        -:  793:  // Simplify (expr * const) ceildiv divConst when const is known to be a
        -:  794:  // multiple of divConst.
  1784412:  795:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
  1784412:  796:  if (lBin && lBin.getKind() == AffineExprKind::Mul) {
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
   186170:  797:    if (auto lrhs = lBin.getRHS().dyn_cast<AffineConstantExpr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  798:      // rhsConst is known to be a positive constant.
   186170:  799:      if (lrhs.getValue() % rhsConst.getValue() == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  800:        return lBin.getLHS() * (lrhs.getValue() / rhsConst.getValue());
call    0 never executed
        -:  801:    }
        -:  802:  }
        -:  803:
  1784412:  804:  return nullptr;
        -:  805:}
        -:  806:
function _ZNK4mlir10AffineExpr7ceilDivEm called 18713 returned 100% blocks executed 100%
    18713:  807:AffineExpr AffineExpr::ceilDiv(uint64_t v) const {
    18713:  808:  return ceilDiv(getAffineConstantExpr(v, getContext()));
call    0 returned 100%
call    1 returned 100%
        -:  809:}
function _ZNK4mlir10AffineExpr7ceilDivES0_ called 1893661 returned 100% blocks executed 100%
  1893661:  810:AffineExpr AffineExpr::ceilDiv(AffineExpr other) const {
  1893661:  811:  if (auto simplified = simplifyCeilDiv(*this, other))
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
   109190:  812:    return simplified;
        -:  813:
  1784471:  814:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 returned 100%
  1784471:  815:  return uniquer.get<AffineBinaryOpExprStorage>(
  1784471:  816:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::CeilDiv), *this,
call    0 returned 100%
  1784471:  817:      other);
        -:  818:}
        -:  819:
function _ZL11simplifyModN4mlir10AffineExprES0_ called 1792058 returned 100% blocks executed 85%
  1792058:  820:static AffineExpr simplifyMod(AffineExpr lhs, AffineExpr rhs) {
  1792058:  821:  auto lhsConst = lhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
  1792058:  822:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  823:
        -:  824:  // mod w.r.t zero or negative numbers is undefined and preserved as is.
  1792058:  825:  if (!rhsConst || rhsConst.getValue() < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  826:    return nullptr;
        -:  827:
  1792058:  828:  if (lhsConst)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
    64150:  829:    return getAffineConstantExpr(mod(lhsConst.getValue(), rhsConst.getValue()),
    67187:  830:                                 lhs.getContext());
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
call    2 returned 100%
        -:  831:
        -:  832:  // Fold modulo of an expression that is known to be a multiple of a constant
        -:  833:  // to zero if that constant is a multiple of the modulo factor. Eg: (i * 128)
        -:  834:  // mod 64 is folded to 0, and less trivially, (i*(j*4*(k*32))) mod 128 = 0.
  1727908:  835:  if (lhs.getLargestKnownDivisor() % rhsConst.getValue() == 0)
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        2:  836:    return getAffineConstantExpr(0, lhs.getContext());
call    0 returned 100%
        -:  837:
        -:  838:  // Simplify (expr1 + expr2) mod divConst when either expr1 or expr2 is
        -:  839:  // known to be a multiple of divConst.
  1727906:  840:  auto lBin = lhs.dyn_cast<AffineBinaryOpExpr>();
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
  1727906:  841:  if (lBin && lBin.getKind() == AffineExprKind::Add) {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
branch  2 taken 37% (fallthrough)
branch  3 taken 63%
   248387:  842:    int64_t llhsDiv = lBin.getLHS().getLargestKnownDivisor();
call    0 returned 100%
   248387:  843:    int64_t lrhsDiv = lBin.getRHS().getLargestKnownDivisor();
call    0 returned 100%
        -:  844:    // rhsConst is known to be a positive constant.
   248387:  845:    if (llhsDiv % rhsConst.getValue() == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  846:      return lBin.getRHS() % rhsConst.getValue();
call    0 never executed
   248387:  847:    if (lrhsDiv % rhsConst.getValue() == 0)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     2206:  848:      return lBin.getLHS() % rhsConst.getValue();
call    0 returned 100%
        -:  849:  }
        -:  850:
        -:  851:  // Simplify (e % a) % b to e % b when b evenly divides a
  1725700:  852:  if (lBin && lBin.getKind() == AffineExprKind::Mod) {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
    49056:  853:    auto intermediate = lBin.getRHS().dyn_cast<AffineConstantExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    49056:  854:    if (intermediate && intermediate.getValue() >= 1 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    49056:  855:        mod(intermediate.getValue(), rhsConst.getValue()) == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
       28:  856:      return lBin.getLHS() % rhsConst.getValue();
call    0 returned 100%
        -:  857:    }
        -:  858:  }
        -:  859:
  1725672:  860:  return nullptr;
        -:  861:}
        -:  862:
function _ZNK4mlir10AffineExprrmEm called 2234 returned 100% blocks executed 100%
     2234:  863:AffineExpr AffineExpr::operator%(uint64_t v) const {
     2234:  864:  return *this % getAffineConstantExpr(v, getContext());
call    0 returned 100%
call    1 returned 100%
        -:  865:}
function _ZNK4mlir10AffineExprrmES0_ called 1792058 returned 100% blocks executed 100%
  1792058:  866:AffineExpr AffineExpr::operator%(AffineExpr other) const {
  1792058:  867:  if (auto simplified = simplifyMod(*this, other))
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
    66386:  868:    return simplified;
        -:  869:
  1725672:  870:  StorageUniquer &uniquer = getContext()->getAffineUniquer();
call    0 returned 100%
  1725672:  871:  return uniquer.get<AffineBinaryOpExprStorage>(
  1725672:  872:      /*initFn=*/{}, static_cast<unsigned>(AffineExprKind::Mod), *this, other);
call    0 returned 100%
        -:  873:}
        -:  874:
function _ZNK4mlir10AffineExpr7composeENS_9AffineMapE called 1889319435 returned 100% blocks executed 100%
1889319435:  875:AffineExpr AffineExpr::compose(AffineMap map) const {
1889319395:  876:  SmallVector<AffineExpr, 8> dimReplacements(map.getResults().begin(),
call    0 returned 100%
1889319435:  877:                                             map.getResults().end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
1889319399:  878:  return replaceDimsAndSymbols(dimReplacements, {});
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        -:  879:}
function _ZN4mlirlsERN4llvm11raw_ostreamENS_10AffineExprE called 0 returned 0% blocks executed 0%
    #####:  880:raw_ostream &mlir::operator<<(raw_ostream &os, AffineExpr expr) {
    #####:  881:  expr.print(os);
call    0 never executed
    #####:  882:  return os;
        -:  883:}
        -:  884:
        -:  885:/// Constructs an affine expression from a flat ArrayRef. If there are local
        -:  886:/// identifiers (neither dimensional nor symbolic) that appear in the sum of
        -:  887:/// products expression, `localExprs` is expected to have the AffineExpr
        -:  888:/// for it, and is substituted into. The ArrayRef `flatExprs` is expected to be
        -:  889:/// in the format [dims, symbols, locals, constant term].
function _ZN4mlir25getAffineExprFromFlatFormEN4llvm8ArrayRefIlEEjjNS1_INS_10AffineExprEEEPNS_11MLIRContextE called 154132299 returned 100% blocks executed 85%
154132299:  890:AffineExpr mlir::getAffineExprFromFlatForm(ArrayRef<int64_t> flatExprs,
        -:  891:                                           unsigned numDims,
        -:  892:                                           unsigned numSymbols,
        -:  893:                                           ArrayRef<AffineExpr> localExprs,
        -:  894:                                           MLIRContext *context) {
        -:  895:  // Assert expected numLocals = flatExprs.size() - numDims - numSymbols - 1.
154132299*:  896:  assert(flatExprs.size() - numDims - numSymbols - 1 == localExprs.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  897:         "unexpected number of local expressions");
        -:  898:
154132299:  899:  auto expr = getAffineConstantExpr(0, context);
        -:  900:  // Dimensions and symbols.
647805344:  901:  for (unsigned j = 0; j < numDims + numSymbols; j++) {
call    0 returned 100%
branch  1 taken 76% (fallthrough)
branch  2 taken 24%
493673046:  902:    if (flatExprs[j] == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
390493996:  903:      continue;
103171178:  904:    auto id = j < numDims ? getAffineDimExpr(j, context)
103179050:  905:                          : getAffineSymbolExpr(j - numDims, context);
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
103179050:  906:    expr = expr + id * flatExprs[j];
call    0 returned 100%
call    1 returned 100%
        -:  907:  }
        -:  908:
        -:  909:  // Local identifiers.
154168720:  910:  for (unsigned j = numDims + numSymbols, e = flatExprs.size() - 1; j < e;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  911:       j++) {
    36420:  912:    if (flatExprs[j] == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
    12424:  913:      continue;
    23996:  914:    auto term = localExprs[j - numDims - numSymbols] * flatExprs[j];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
    23996:  915:    expr = expr + term;
call    0 returned 100%
        -:  916:  }
        -:  917:
        -:  918:  // Constant term.
154132300:  919:  int64_t constTerm = flatExprs[flatExprs.size() - 1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
154132300:  920:  if (constTerm != 0)
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
 95388544:  921:    expr = expr + constTerm;
call    0 returned 100%
154132299:  922:  return expr;
        -:  923:}
        -:  924:
        -:  925:/// Constructs a semi-affine expression from a flat ArrayRef. If there are
        -:  926:/// local identifiers (neither dimensional nor symbolic) that appear in the sum
        -:  927:/// of products expression, `localExprs` is expected to have the AffineExprs for
        -:  928:/// it, and is substituted into. The ArrayRef `flatExprs` is expected to be in
        -:  929:/// the format [dims, symbols, locals, constant term]. The semi-affine
        -:  930:/// expression is constructed in the sorted order of dimension and symbol
        -:  931:/// position numbers. Note:  local expressions/ids are used for mod, div as well
        -:  932:/// as symbolic RHS terms for terms that are not pure affine.
function _ZL29getSemiAffineExprFromFlatFormN4llvm8ArrayRefIlEEjjNS0_IN4mlir10AffineExprEEEPNS2_11MLIRContextE called 23 returned 100% blocks executed 64%
       23:  933:static AffineExpr getSemiAffineExprFromFlatForm(ArrayRef<int64_t> flatExprs,
        -:  934:                                                unsigned numDims,
        -:  935:                                                unsigned numSymbols,
        -:  936:                                                ArrayRef<AffineExpr> localExprs,
        -:  937:                                                MLIRContext *context) {
      23*:  938:  assert(!flatExprs.empty() && "flatExprs cannot be empty");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  939:
        -:  940:  // Assert expected numLocals = flatExprs.size() - numDims - numSymbols - 1.
      23*:  941:  assert(flatExprs.size() - numDims - numSymbols - 1 == localExprs.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  942:         "unexpected number of local expressions");
        -:  943:
       23:  944:  AffineExpr expr = getAffineConstantExpr(0, context);
call    0 returned 100%
        -:  945:
        -:  946:  // We design indices as a pair which help us present the semi-affine map as
        -:  947:  // sum of product where terms are sorted based on dimension or symbol
        -:  948:  // position: <keyA, keyB> for expressions of the form dimension * symbol,
        -:  949:  // where keyA is the position number of the dimension and keyB is the
        -:  950:  // position number of the symbol. For dimensional expressions we set the index
        -:  951:  // as (position number of the dimension, -1), as we want dimensional
        -:  952:  // expressions to appear before symbolic and product of dimensional and
        -:  953:  // symbolic expressions having the dimension with the same position number.
        -:  954:  // For symbolic expression set the index as (position number of the symbol,
        -:  955:  // maximum of last dimension and symbol position) number. For example, we want
        -:  956:  // the expression we are constructing to look something like: d0 + d0 * s0 +
        -:  957:  // s0 + d1*s1 + s1.
        -:  958:
        -:  959:  // Stores the affine expression corresponding to a given index.
       23:  960:  DenseMap<std::pair<unsigned, signed>, AffineExpr> indexToExprMap;
call    0 returned 100%
        -:  961:  // Stores the constant coefficient value corresponding to a given
        -:  962:  // dimension, symbol or a non-pure affine expression stored in `localExprs`.
       46:  963:  DenseMap<std::pair<unsigned, signed>, int64_t> coefficients;
call    0 returned 100%
call    1 returned 100%
        -:  964:  // Stores the indices as defined above, and later sorted to produce
        -:  965:  // the semi-affine expression in the desired form.
       46:  966:  SmallVector<std::pair<unsigned, signed>, 8> indices;
call    0 returned 100%
        -:  967:
        -:  968:  // Example: expression = d0 + d0 * s0 + 2 * s0.
        -:  969:  // indices = [{0,-1}, {0, 0}, {0, 1}]
        -:  970:  // coefficients = [{{0, -1}, 1}, {{0, 0}, 1}, {{0, 1}, 2}]
        -:  971:  // indexToExprMap = [{{0, -1}, d0}, {{0, 0}, d0 * s0}, {{0, 1}, s0}]
        -:  972:
        -:  973:  // Adds entries to `indexToExprMap`, `coefficients` and `indices`.
function _ZZL29getSemiAffineExprFromFlatFormN4llvm8ArrayRefIlEEjjNS0_IN4mlir10AffineExprEEEPNS2_11MLIRContextEENKUlSt4pairIjiElS3_E_clES8_lS3_ called 67 returned 100% blocks executed 83%
       90:  974:  auto addEntry = [&](std::pair<unsigned, signed> index, int64_t coefficient,
        -:  975:                      AffineExpr expr) {
      67*:  976:    assert(!llvm::is_contained(indices, index) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  977:           "Key is already present in indices vector and overwriting will "
        -:  978:           "happen in `indexToExprMap` and `coefficients`!");
        -:  979:
       67:  980:    indices.push_back(index);
call    0 returned 100%
       67:  981:    coefficients.insert({index, coefficient});
call    0 returned 100%
       67:  982:    indexToExprMap.insert({index, expr});
call    0 returned 100%
       90:  983:  };
        -:  984:
        -:  985:  // Design indices for dimensional or symbolic terms, and store the indices,
        -:  986:  // constant coefficient corresponding to the indices in `coefficients` map,
        -:  987:  // and affine expression corresponding to indices in `indexToExprMap` map.
        -:  988:
       90:  989:  for (unsigned j = 0; j < numDims; ++j) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
       67:  990:    if (flatExprs[j] == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
       23:  991:      continue;
        -:  992:    // For dimensional expressions we set the index as <position number of the
        -:  993:    // dimension, 0>, as we want dimensional expressions to appear before
        -:  994:    // symbolic ones and products of dimensional and symbolic expressions
        -:  995:    // having the dimension with the same position number.
       44:  996:    std::pair<unsigned, signed> indexEntry(j, -1);
call    0 returned 100%
       44:  997:    addEntry(indexEntry, flatExprs[j], getAffineDimExpr(j, context));
call    0 returned 100%
call    1 returned 100%
        -:  998:  }
        -:  999:  // Ensure we do not have duplicate keys in `indexToExpr` map.
        -: 1000:  unsigned offset = 0;
       46: 1001:  for (unsigned j = numDims; j < numDims + numSymbols; ++j) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       23: 1002:    if (flatExprs[j] == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 83% (fallthrough)
branch  3 taken 17%
       19: 1003:      continue;
        -: 1004:    // For symbolic expression set the index as <position number
        -: 1005:    // of the symbol, max(dimCount, symCount)> number,
        -: 1006:    // as we want symbolic expressions with the same positional number to
        -: 1007:    // appear after dimensional expressions having the same positional number.
        4: 1008:    std::pair<unsigned, signed> indexEntry(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        4: 1009:        j - numDims, std::max(numDims, numSymbols) + offset++);
call    0 returned 100%
        4: 1010:    addEntry(indexEntry, flatExprs[j],
call    0 returned 100%
call    1 returned 100%
        -: 1011:             getAffineSymbolExpr(j - numDims, context));
        -: 1012:  }
        -: 1013:
        -: 1014:  // Denotes semi-affine product, modulo or division terms, which has been added
        -: 1015:  // to the `indexToExpr` map.
       23: 1016:  SmallVector<bool, 4> addedToMap(flatExprs.size() - numDims - numSymbols - 1,
call    0 returned 100%
       46: 1017:                                  false);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       23: 1018:  unsigned lhsPos, rhsPos;
        -: 1019:  // Construct indices for product terms involving dimension, symbol or constant
        -: 1020:  // as lhs/rhs, and store the indices, constant coefficient corresponding to
        -: 1021:  // the indices in `coefficients` map, and affine expression corresponding to
        -: 1022:  // in indices in `indexToExprMap` map.
       46: 1023:  for (const auto &it : llvm::enumerate(localExprs)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       23: 1024:    AffineExpr expr = it.value();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       23: 1025:    if (flatExprs[numDims + numSymbols + it.index()] == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 17% (fallthrough)
branch  3 taken 83%
       23: 1026:      continue;
call    0 returned 100%
       19: 1027:    AffineExpr lhs = expr.cast<AffineBinaryOpExpr>().getLHS();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       19: 1028:    AffineExpr rhs = expr.cast<AffineBinaryOpExpr>().getRHS();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      19*: 1029:    if (!((lhs.isa<AffineDimExpr>() || lhs.isa<AffineSymbolExpr>()) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      19*: 1030:          (rhs.isa<AffineDimExpr>() || rhs.isa<AffineSymbolExpr>() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####: 1031:           rhs.isa<AffineConstantExpr>()))) {
branch  0 never executed
branch  1 never executed
    #####: 1032:      continue;
        -: 1033:    }
       19: 1034:    if (rhs.isa<AffineConstantExpr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1035:      // For product/modulo/division expressions, when rhs of modulo/division
        -: 1036:      // expression is constant, we put 0 in place of keyB, because we want
        -: 1037:      // them to appear earlier in the semi-affine expression we are
        -: 1038:      // constructing. When rhs is constant, we place 0 in place of keyB.
    #####: 1039:      if (lhs.isa<AffineDimExpr>()) {
branch  0 never executed
branch  1 never executed
    #####: 1040:        lhsPos = lhs.cast<AffineDimExpr>().getPosition();
call    0 never executed
    #####: 1041:        std::pair<unsigned, signed> indexEntry(lhsPos, -1);
call    0 never executed
    #####: 1042:        addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()],
call    0 never executed
        -: 1043:                 expr);
        -: 1044:      } else {
    #####: 1045:        lhsPos = lhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1046:        std::pair<unsigned, signed> indexEntry(
branch  0 never executed
branch  1 never executed
    #####: 1047:            lhsPos, std::max(numDims, numSymbols) + offset++);
call    0 never executed
    #####: 1048:        addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()],
call    0 never executed
        -: 1049:                 expr);
        -: 1050:      }
       19: 1051:    } else if (lhs.isa<AffineDimExpr>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1052:      // For product/modulo/division expressions having lhs as dimension and rhs
        -: 1053:      // as symbol, we order the terms in the semi-affine expression based on
        -: 1054:      // the pair: <keyA, keyB> for expressions of the form dimension * symbol,
        -: 1055:      // where keyA is the position number of the dimension and keyB is the
        -: 1056:      // position number of the symbol.
       19: 1057:      lhsPos = lhs.cast<AffineDimExpr>().getPosition();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       19: 1058:      rhsPos = rhs.cast<AffineSymbolExpr>().getPosition();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       19: 1059:      std::pair<unsigned, signed> indexEntry(lhsPos, rhsPos);
call    0 returned 100%
       19: 1060:      addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()], expr);
call    0 returned 100%
        -: 1061:    } else {
        -: 1062:      // For product/modulo/division expressions having both lhs and rhs as
        -: 1063:      // symbol, we design indices as a pair: <keyA, keyB> for expressions
        -: 1064:      // of the form dimension * symbol, where keyA is the position number of
        -: 1065:      // the dimension and keyB is the position number of the symbol.
    #####: 1066:      lhsPos = lhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1067:      rhsPos = rhs.cast<AffineSymbolExpr>().getPosition();
branch  0 never executed
branch  1 never executed
    #####: 1068:      std::pair<unsigned, signed> indexEntry(
branch  0 never executed
branch  1 never executed
    #####: 1069:          lhsPos, std::max(numDims, numSymbols) + offset++);
call    0 never executed
    #####: 1070:      addEntry(indexEntry, flatExprs[numDims + numSymbols + it.index()], expr);
call    0 never executed
        -: 1071:    }
       19: 1072:    addedToMap[it.index()] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1073:  }
        -: 1074:
        -: 1075:  // Constructing the simplified semi-affine sum of product/division/mod
        -: 1076:  // expression from the flattened form in the desired sorted order of indices
        -: 1077:  // of the various individual product/division/mod expressions.
       23: 1078:  llvm::sort(indices);
call    0 returned 100%
       90: 1079:  for (const std::pair<unsigned, unsigned> index : indices) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
     134*: 1080:    assert(indexToExprMap.lookup(index) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1081:           "cannot find key in `indexToExprMap` map");
      201: 1082:    expr = expr + indexToExprMap.lookup(index) * coefficients.lookup(index);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 1083:  }
        -: 1084:
        -: 1085:  // Local identifiers.
       46: 1086:  for (unsigned j = numDims + numSymbols, e = flatExprs.size() - 1; j < e;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1087:       j++) {
        -: 1088:    // If the coefficient of the local expression is 0, continue as we need not
        -: 1089:    // add it in out final expression.
       23: 1090:    if (flatExprs[j] == 0 || addedToMap[j - numDims - numSymbols])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 83% (fallthrough)
branch  3 taken 17%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
       23: 1091:      continue;
    #####: 1092:    auto term = localExprs[j - numDims - numSymbols] * flatExprs[j];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1093:    expr = expr + term;
call    0 never executed
        -: 1094:  }
        -: 1095:
        -: 1096:  // Constant term.
       23: 1097:  int64_t constTerm = flatExprs.back();
call    0 returned 100%
       23: 1098:  if (constTerm != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1099:    expr = expr + constTerm;
call    0 never executed
       23: 1100:  return expr;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1101:}
        -: 1102:
function _ZN4mlir25SimpleAffineExprFlattenerC2Ejj called 49245 returned 100% blocks executed 100%
154103658: 1103:SimpleAffineExprFlattener::SimpleAffineExprFlattener(unsigned numDims,
154103658: 1104:                                                     unsigned numSymbols)
    49245: 1105:    : numDims(numDims), numSymbols(numSymbols), numLocals(0) {
call    0 returned 100%
154103658: 1106:  operandExprStack.reserve(8);
call    0 returned 100%
call    1 returned 100%
    49245: 1107:}
        -: 1108:
        -: 1109:// In pure affine t = expr * c, we multiply each coefficient of lhs with c.
        -: 1110://
        -: 1111:// In case of semi affine multiplication expressions, t = expr * symbolic_expr,
        -: 1112:// introduce a local variable p (= expr * symbolic_expr), and the affine
        -: 1113:// expression expr * symbolic_expr is added to `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitMulExprENS_18AffineBinaryOpExprE called 42776787 returned 100% blocks executed 84%
 42776787: 1114:void SimpleAffineExprFlattener::visitMulExpr(AffineBinaryOpExpr expr) {
42776787*: 1115:  assert(operandExprStack.size() >= 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 85553179: 1116:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 42776787: 1117:  operandExprStack.pop_back();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
 42776787: 1118:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -: 1119:
        -: 1120:  // Flatten semi-affine multiplication expressions by introducing a local
        -: 1121:  // variable in place of the product; the affine expression
        -: 1122:  // corresponding to the quantifier is added to `localExprs`.
 42776787: 1123:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      395: 1124:    MLIRContext *context = expr.getContext();
      395: 1125:    AffineExpr a = getAffineExprFromFlatForm(lhs, numDims, numSymbols,
      395: 1126:                                             localExprs, context);
call    0 returned 100%
      395: 1127:    AffineExpr b = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
      395: 1128:                                             localExprs, context);
call    0 returned 100%
      395: 1129:    addLocalVariableSemiAffine(a * b, lhs, lhs.size());
call    0 returned 100%
call    1 returned 100%
      395: 1130:    return;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1131:  }
        -: 1132:
        -: 1133:  // Get the RHS constant.
 42776392: 1134:  auto rhsConst = rhs[getConstantIndex()];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
197996602: 1135:  for (unsigned i = 0, e = lhs.size(); i < e; i++) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
155220210: 1136:    lhs[i] *= rhsConst;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1137:  }
        -: 1138:}
        -: 1139:
function _ZN4mlir25SimpleAffineExprFlattener12visitAddExprENS_18AffineBinaryOpExprE called 44562924 returned 100% blocks executed 71%
 44562924: 1140:void SimpleAffineExprFlattener::visitAddExpr(AffineBinaryOpExpr expr) {
44562924*: 1141:  assert(operandExprStack.size() >= 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 44562924: 1142:  const auto &rhs = operandExprStack.back();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 44562924: 1143:  auto &lhs = operandExprStack[operandExprStack.size() - 2];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
44562924*: 1144:  assert(lhs.size() == rhs.size());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        -: 1145:  // Update the LHS in place.
206192372: 1146:  for (unsigned i = 0, e = rhs.size(); i < e; i++) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
161629448: 1147:    lhs[i] += rhs[i];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1148:  }
        -: 1149:  // Pop off the RHS.
 44562924: 1150:  operandExprStack.pop_back();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
 44562924: 1151:}
        -: 1152:
        -: 1153://
        -: 1154:// t = expr mod c   <=>  t = expr - c*q and c*q <= expr <= c*q + c - 1
        -: 1155://
        -: 1156:// A mod expression "expr mod c" is thus flattened by introducing a new local
        -: 1157:// variable q (= expr floordiv c), such that expr mod c is replaced with
        -: 1158:// 'expr - c * q' and c * q <= expr <= c * q + c - 1 are added to localVarCst.
        -: 1159://
        -: 1160:// In case of semi-affine modulo expressions, t = expr mod symbolic_expr,
        -: 1161:// introduce a local variable m (= expr mod symbolic_expr), and the affine
        -: 1162:// expression expr mod symbolic_expr is added to `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitModExprENS_18AffineBinaryOpExprE called 6922 returned 100% blocks executed 78%
     6922: 1163:void SimpleAffineExprFlattener::visitModExpr(AffineBinaryOpExpr expr) {
    6922*: 1164:  assert(operandExprStack.size() >= 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1165:
    13834: 1166:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     6922: 1167:  operandExprStack.pop_back();
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     6922: 1168:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     6922: 1169:  MLIRContext *context = expr.getContext();
        -: 1170:
        -: 1171:  // Flatten semi affine modulo expressions by introducing a local
        -: 1172:  // variable in place of the modulo value, and the affine expression
        -: 1173:  // corresponding to the quantifier is added to `localExprs`.
     6922: 1174:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1175:    AffineExpr dividendExpr = getAffineExprFromFlatForm(
    #####: 1176:        lhs, numDims, numSymbols, localExprs, context);
call    0 never executed
    #####: 1177:    AffineExpr divisorExpr = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
    #####: 1178:                                                       localExprs, context);
call    0 never executed
    #####: 1179:    AffineExpr modExpr = dividendExpr % divisorExpr;
call    0 never executed
    #####: 1180:    addLocalVariableSemiAffine(modExpr, lhs, lhs.size());
call    0 never executed
    #####: 1181:    return;
        -: 1182:  }
        -: 1183:
     6922: 1184:  int64_t rhsConst = rhs[getConstantIndex()];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1185:  // TODO: handle modulo by zero case when this issue is fixed
        -: 1186:  // at the other places in the IR.
    6922*: 1187:  assert(rhsConst > 0 && "RHS constant has to be positive");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1188:
        -: 1189:  // Check if the LHS expression is a multiple of modulo factor.
     6922: 1190:  unsigned i, e;
    13764: 1191:  for (i = 0, e = lhs.size(); i < e; i++)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    13754: 1192:    if (lhs[i] % rhsConst != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -: 1193:      break;
        -: 1194:  // If yes, modulo expression here simplifies to zero.
     6922: 1195:  if (i == lhs.size()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       20: 1196:    std::fill(lhs.begin(), lhs.end(), 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1197:    return;
        -: 1198:  }
        -: 1199:
        -: 1200:  // Add a local variable for the quotient, i.e., expr % c is replaced by
        -: 1201:  // (expr - q * c) where q = expr floordiv c. Do this while canceling out
        -: 1202:  // the GCD of expr and c.
    13824: 1203:  SmallVector<int64_t, 8> floorDividend(lhs);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
     6912: 1204:  uint64_t gcd = rhsConst;
    32798: 1205:  for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
    51772: 1206:    gcd = std::gcd(gcd, (uint64_t)std::abs(lhs[i]));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1207:  // Simplify the numerator and the denominator.
     6912: 1208:  if (gcd != 1) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     1367: 1209:    for (unsigned i = 0, e = floorDividend.size(); i < e; i++)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     1027: 1210:      floorDividend[i] = floorDividend[i] / static_cast<int64_t>(gcd);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1211:  }
     6912: 1212:  int64_t floorDivisor = rhsConst / static_cast<int64_t>(gcd);
        -: 1213:
        -: 1214:  // Construct the AffineExpr form of the floordiv to store in localExprs.
        -: 1215:
     6912: 1216:  AffineExpr dividendExpr = getAffineExprFromFlatForm(
     6912: 1217:      floorDividend, numDims, numSymbols, localExprs, context);
call    0 returned 100%
     6912: 1218:  AffineExpr divisorExpr = getAffineConstantExpr(floorDivisor, context);
call    0 returned 100%
     6912: 1219:  AffineExpr floorDivExpr = dividendExpr.floorDiv(divisorExpr);
call    0 returned 100%
     6912: 1220:  int loc;
     6912: 1221:  if ((loc = findLocalId(floorDivExpr)) == -1) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
     6476: 1222:    addLocalFloorDivId(floorDividend, floorDivisor, floorDivExpr);
call    0 returned 100%
        -: 1223:    // Set result at top of stack to "lhs - rhsConst * q".
     6476: 1224:    lhs[getLocalVarStartIndex() + numLocals - 1] = -rhsConst;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1225:  } else {
        -: 1226:    // Reuse the existing local id.
      436: 1227:    lhs[getLocalVarStartIndex() + loc] = -rhsConst;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1228:  }
        -: 1229:}
        -: 1230:
function _ZN4mlir25SimpleAffineExprFlattener16visitCeilDivExprENS_18AffineBinaryOpExprE called 7232 returned 100% blocks executed 100%
    7232*: 1231:void SimpleAffineExprFlattener::visitCeilDivExpr(AffineBinaryOpExpr expr) {
    7232*: 1232:  visitDivExpr(expr, /*isCeil=*/true);
call    0 never executed
call    1 returned 100%
     7232: 1233:}
function _ZN4mlir25SimpleAffineExprFlattener17visitFloorDivExprENS_18AffineBinaryOpExprE called 7094 returned 100% blocks executed 100%
    7094*: 1234:void SimpleAffineExprFlattener::visitFloorDivExpr(AffineBinaryOpExpr expr) {
    7094*: 1235:  visitDivExpr(expr, /*isCeil=*/false);
call    0 never executed
call    1 returned 100%
     7094: 1236:}
        -: 1237:
function _ZN4mlir25SimpleAffineExprFlattener12visitDimExprENS_13AffineDimExprE called 103167020 returned 100% blocks executed 67%
103167020: 1238:void SimpleAffineExprFlattener::visitDimExpr(AffineDimExpr expr) {
103167020: 1239:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
103167023: 1240:  auto &eq = operandExprStack.back();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
103167023*: 1241:  assert(expr.getPosition() < numDims && "Inconsistent number of dims");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
103167023: 1242:  eq[getDimStartIndex() + expr.getPosition()] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
103167023: 1243:}
        -: 1244:
function _ZN4mlir25SimpleAffineExprFlattener15visitSymbolExprENS_16AffineSymbolExprE called 9486 returned 100% blocks executed 67%
     9486: 1245:void SimpleAffineExprFlattener::visitSymbolExpr(AffineSymbolExpr expr) {
     9486: 1246:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     9486: 1247:  auto &eq = operandExprStack.back();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    9486*: 1248:  assert(expr.getPosition() < numSymbols && "inconsistent number of symbols");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     9486: 1249:  eq[getSymbolStartIndex() + expr.getPosition()] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     9486: 1250:}
        -: 1251:
function _ZN4mlir25SimpleAffineExprFlattener17visitConstantExprENS_18AffineConstantExprE called 138336412 returned 100% blocks executed 71%
138336412: 1252:void SimpleAffineExprFlattener::visitConstantExpr(AffineConstantExpr expr) {
138336412: 1253:  operandExprStack.emplace_back(SmallVector<int64_t, 32>(getNumCols(), 0));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
138336415: 1254:  auto &eq = operandExprStack.back();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
138336415: 1255:  eq[getConstantIndex()] = expr.getValue();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
138336415: 1256:}
        -: 1257:
function _ZN4mlir25SimpleAffineExprFlattener26addLocalVariableSemiAffineENS_10AffineExprERN4llvm15SmallVectorImplIlEEm called 405 returned 100% blocks executed 81%
      405: 1258:void SimpleAffineExprFlattener::addLocalVariableSemiAffine(
        -: 1259:    AffineExpr expr, SmallVectorImpl<int64_t> &result,
        -: 1260:    unsigned long resultSize) {
     405*: 1261:  assert(result.size() == resultSize &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1262:         "`result` vector passed is not of correct size");
      405: 1263:  int loc;
      405: 1264:  if ((loc = findLocalId(expr)) == -1)
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
      401: 1265:    addLocalIdSemiAffine(expr);
call    0 returned 100%
      405: 1266:  std::fill(result.begin(), result.end(), 0);
      405: 1267:  if (loc == -1)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      401: 1268:    result[getLocalVarStartIndex() + numLocals - 1] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  else
        4: 1270:    result[getLocalVarStartIndex() + loc] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      405: 1271:}
        -: 1272:
        -: 1273:// t = expr floordiv c   <=> t = q, c * q <= expr <= c * q + c - 1
        -: 1274:// A floordiv is thus flattened by introducing a new local variable q, and
        -: 1275:// replacing that expression with 'q' while adding the constraints
        -: 1276:// c * q <= expr <= c * q + c - 1 to localVarCst (done by
        -: 1277:// FlatAffineConstraints::addLocalFloorDiv).
        -: 1278://
        -: 1279:// A ceildiv is similarly flattened:
        -: 1280:// t = expr ceildiv c   <=> t =  (expr + c - 1) floordiv c
        -: 1281://
        -: 1282:// In case of semi affine division expressions, t = expr floordiv symbolic_expr
        -: 1283:// or t = expr ceildiv symbolic_expr, introduce a local variable q (= expr
        -: 1284:// floordiv/ceildiv symbolic_expr), and the affine floordiv/ceildiv is added to
        -: 1285:// `localExprs`.
function _ZN4mlir25SimpleAffineExprFlattener12visitDivExprENS_18AffineBinaryOpExprEb called 14326 returned 100% blocks executed 87%
    14326: 1286:void SimpleAffineExprFlattener::visitDivExpr(AffineBinaryOpExpr expr,
        -: 1287:                                             bool isCeil) {
   14326*: 1288:  assert(operandExprStack.size() >= 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1289:
    14326: 1290:  MLIRContext *context = expr.getContext();
    28548: 1291:  SmallVector<int64_t, 8> rhs = operandExprStack.back();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    14326: 1292:  operandExprStack.pop_back();
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    14326: 1293:  SmallVector<int64_t, 8> &lhs = operandExprStack.back();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -: 1294:
        -: 1295:  // Flatten semi affine division expressions by introducing a local
        -: 1296:  // variable in place of the quotient, and the affine expression corresponding
        -: 1297:  // to the quantifier is added to `localExprs`.
    14326: 1298:  if (!expr.getRHS().isa<AffineConstantExpr>()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       10: 1299:    AffineExpr a = getAffineExprFromFlatForm(lhs, numDims, numSymbols,
       10: 1300:                                             localExprs, context);
call    0 returned 100%
       10: 1301:    AffineExpr b = getAffineExprFromFlatForm(rhs, numDims, numSymbols,
       10: 1302:                                             localExprs, context);
call    0 returned 100%
      10*: 1303:    AffineExpr divExpr = isCeil ? a.ceilDiv(b) : a.floorDiv(b);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
       10: 1304:    addLocalVariableSemiAffine(divExpr, lhs, lhs.size());
call    0 returned 100%
       10: 1305:    return;
        -: 1306:  }
        -: 1307:
        -: 1308:  // This is a pure affine expr; the RHS is a positive constant.
    14316: 1309:  int64_t rhsConst = rhs[getConstantIndex()];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1310:  // TODO: handle division by zero at the same time the issue is
        -: 1311:  // fixed at other places.
   14316*: 1312:  assert(rhsConst > 0 && "RHS constant has to be positive");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1313:
        -: 1314:  // Simplify the floordiv, ceildiv if possible by canceling out the greatest
        -: 1315:  // common divisors of the numerator and denominator.
    14316: 1316:  uint64_t gcd = std::abs(rhsConst);
    68270: 1317:  for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
   107908: 1318:    gcd = std::gcd(gcd, (uint64_t)std::abs(lhs[i]));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1319:  // Simplify the numerator and the denominator.
    14316: 1320:  if (gcd != 1) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
     3515: 1321:    for (unsigned i = 0, e = lhs.size(); i < e; i++)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     2647: 1322:      lhs[i] = lhs[i] / static_cast<int64_t>(gcd);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1323:  }
    14316: 1324:  int64_t divisor = rhsConst / static_cast<int64_t>(gcd);
        -: 1325:  // If the divisor becomes 1, the updated LHS is the result. (The
        -: 1326:  // divisor can't be negative since rhsConst is positive).
    14316: 1327:  if (divisor == 1)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 1328:    return;
        -: 1329:
        -: 1330:  // If the divisor cannot be simplified to one, we will have to retain
        -: 1331:  // the ceil/floor expr (simplified up until here). Add an existential
        -: 1332:  // quantifier to express its result, i.e., expr1 div expr2 is replaced
        -: 1333:  // by a new identifier, q.
    14222: 1334:  AffineExpr a =
    14222: 1335:      getAffineExprFromFlatForm(lhs, numDims, numSymbols, localExprs, context);
call    0 returned 100%
    14222: 1336:  AffineExpr b = getAffineConstantExpr(divisor, context);
call    0 returned 100%
        -: 1337:
    14222: 1338:  int loc;
    14222: 1339:  AffineExpr divExpr = isCeil ? a.ceilDiv(b) : a.floorDiv(b);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
    14222: 1340:  if ((loc = findLocalId(divExpr)) == -1) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
    13387: 1341:    if (!isCeil) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    13426: 1342:      SmallVector<int64_t, 8> dividend(lhs);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     6713: 1343:      addLocalFloorDivId(dividend, divisor, divExpr);
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        -: 1344:    } else {
        -: 1345:      // lhs ceildiv c <=>  (lhs + c - 1) floordiv c
    13348: 1346:      SmallVector<int64_t, 8> dividend(lhs);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     6674: 1347:      dividend.back() += divisor - 1;
call    0 returned 100%
     6674: 1348:      addLocalFloorDivId(dividend, divisor, divExpr);
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        -: 1349:    }
        -: 1350:  }
        -: 1351:  // Set the expression on stack to the local var introduced to capture the
        -: 1352:  // result of the division (floor or ceil).
    14222: 1353:  std::fill(lhs.begin(), lhs.end(), 0);
    14222: 1354:  if (loc == -1)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
    13387: 1355:    lhs[getLocalVarStartIndex() + numLocals - 1] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1356:  else
      835: 1357:    lhs[getLocalVarStartIndex() + loc] = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1358:}
        -: 1359:
        -: 1360:// Add a local identifier (needed to flatten a mod, floordiv, ceildiv expr).
        -: 1361:// The local identifier added is always a floordiv of a pure add/mul affine
        -: 1362:// function of other identifiers, coefficients of which are specified in
        -: 1363:// dividend and with respect to a positive constant divisor. localExpr is the
        -: 1364:// simplified tree expression (AffineExpr) corresponding to the quantifier.
function _ZN4mlir25SimpleAffineExprFlattener18addLocalFloorDivIdEN4llvm8ArrayRefIlEElNS_10AffineExprE called 19863 returned 100% blocks executed 88%
    19863: 1365:void SimpleAffineExprFlattener::addLocalFloorDivId(ArrayRef<int64_t> dividend,
        -: 1366:                                                   int64_t divisor,
        -: 1367:                                                   AffineExpr localExpr) {
   19863*: 1368:  assert(divisor > 0 && "positive constant divisor expected");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    44828: 1369:  for (SmallVector<int64_t, 8> &subExpr : operandExprStack)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
call    2 returned 100%
    24965: 1370:    subExpr.insert(subExpr.begin() + getLocalVarStartIndex() + numLocals, 0);
call    0 returned 100%
    19863: 1371:  localExprs.push_back(localExpr);
call    0 returned 100%
    19863: 1372:  numLocals++;
        -: 1373:  // dividend and divisor are not used here; an override of this method uses it.
    19863: 1374:}
        -: 1375:
function _ZN4mlir25SimpleAffineExprFlattener20addLocalIdSemiAffineENS_10AffineExprE called 401 returned 100% blocks executed 100%
      401: 1376:void SimpleAffineExprFlattener::addLocalIdSemiAffine(AffineExpr localExpr) {
     1173: 1377:  for (SmallVector<int64_t, 8> &subExpr : operandExprStack)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
call    2 returned 100%
      772: 1378:    subExpr.insert(subExpr.begin() + getLocalVarStartIndex() + numLocals, 0);
call    0 returned 100%
      401: 1379:  localExprs.push_back(localExpr);
call    0 returned 100%
      401: 1380:  ++numLocals;
      401: 1381:}
        -: 1382:
function _ZN4mlir25SimpleAffineExprFlattener11findLocalIdENS_10AffineExprE called 21539 returned 100% blocks executed 100%
    21539: 1383:int SimpleAffineExprFlattener::findLocalId(AffineExpr localExpr) {
    21539: 1384:  SmallVectorImpl<AffineExpr>::iterator it;
    21539: 1385:  if ((it = llvm::find(localExprs, localExpr)) == localExprs.end())
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -: 1386:    return -1;
     1275: 1387:  return it - localExprs.begin();
        -: 1388:}
        -: 1389:
        -: 1390:/// Simplify the affine expression by flattening it and reconstructing it.
function _ZN4mlir18simplifyAffineExprENS_10AffineExprEjj called 154054416 returned 100% blocks executed 95%
154054416: 1391:AffineExpr mlir::simplifyAffineExpr(AffineExpr expr, unsigned numDims,
        -: 1392:                                    unsigned numSymbols) {
        -: 1393:  // Simplify semi-affine expressions separately.
154054416: 1394:  if (!expr.isPureAffine())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      354: 1395:    expr = simplifySemiAffine(expr);
call    0 returned 100%
        -: 1396:
308108827: 1397:  SimpleAffineExprFlattener flattener(numDims, numSymbols);
call    0 returned 100%
call    1 returned 100%
154054413: 1398:  flattener.walkPostOrder(expr);
call    0 returned 100%
154054415: 1399:  ArrayRef<int64_t> flattenedExpr = flattener.operandExprStack.back();
call    0 returned 100%
154054769: 1400:  if (!expr.isPureAffine() &&
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
branch  3 taken 94% (fallthrough)
branch  4 taken 6%
      354: 1401:      expr == getAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
        -: 1402:                                        flattener.localExprs,
        -: 1403:                                        expr.getContext()))
      331: 1404:    return expr;
154054084: 1405:  AffineExpr simplifiedExpr =
154054084: 1406:      expr.isPureAffine()
call    0 returned 100%
        -: 1407:          ? getAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
154054061: 1408:                                      flattener.localExprs, expr.getContext())
call    0 returned 100%
        -: 1409:          : getSemiAffineExprFromFlatForm(flattenedExpr, numDims, numSymbols,
        -: 1410:                                          flattener.localExprs,
154054084: 1411:                                          expr.getContext());
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
        -: 1412:
154054083: 1413:  flattener.operandExprStack.pop_back();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
154054083*: 1414:  assert(flattener.operandExprStack.empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
154054083: 1415:  return simplifiedExpr;
        -: 1416:}
