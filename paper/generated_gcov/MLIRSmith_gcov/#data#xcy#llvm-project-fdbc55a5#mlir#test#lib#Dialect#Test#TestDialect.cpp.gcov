        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/test/lib/Dialect/Test/TestDialect.cpp
        -:    0:Graph:../tools/mlir/test/lib/Dialect/Test/CMakeFiles/MLIRTestDialect.dir/TestDialect.cpp.gcno
        -:    0:Data:../tools/mlir/test/lib/Dialect/Test/CMakeFiles/MLIRTestDialect.dir/TestDialect.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- TestDialect.cpp - MLIR Dialect for Testing -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "TestDialect.h"
        -:   10:#include "TestAttributes.h"
        -:   11:#include "TestInterfaces.h"
        -:   12:#include "TestTypes.h"
        -:   13:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   14:#include "mlir/Dialect/DLTI/DLTI.h"
        -:   15:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   16:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   17:#include "mlir/IR/AsmState.h"
        -:   18:#include "mlir/IR/BuiltinAttributes.h"
        -:   19:#include "mlir/IR/BuiltinOps.h"
        -:   20:#include "mlir/IR/Diagnostics.h"
        -:   21:#include "mlir/IR/DialectImplementation.h"
        -:   22:#include "mlir/IR/ExtensibleDialect.h"
        -:   23:#include "mlir/IR/MLIRContext.h"
        -:   24:#include "mlir/IR/OperationSupport.h"
        -:   25:#include "mlir/IR/PatternMatch.h"
        -:   26:#include "mlir/IR/TypeUtilities.h"
        -:   27:#include "mlir/IR/Verifier.h"
        -:   28:#include "mlir/Interfaces/InferIntRangeInterface.h"
        -:   29:#include "mlir/Reducer/ReductionPatternInterface.h"
        -:   30:#include "mlir/Transforms/FoldUtils.h"
        -:   31:#include "mlir/Transforms/InliningUtils.h"
        -:   32:#include "llvm/ADT/SmallString.h"
        -:   33:#include "llvm/ADT/StringExtras.h"
        -:   34:#include "llvm/ADT/StringSwitch.h"
        -:   35:
        -:   36:// Include this before the using namespace lines below to
        -:   37:// test that we don't have namespace dependencies.
        -:   38:#include "TestOpsDialect.cpp.inc"
        -:   39:
        -:   40:using namespace mlir;
        -:   41:using namespace test;
        -:   42:
function _ZN4test19registerTestDialectERN4mlir15DialectRegistryE called 116161 returned 100% blocks executed 100%
   116161:   43:void test::registerTestDialect(DialectRegistry &registry) {
   116161:   44:  registry.insert<TestDialect>();
call    0 returned 100%
   116161:   45:}
        -:   46:
        -:   47://===----------------------------------------------------------------------===//
        -:   48:// TestDialect Interfaces
        -:   49://===----------------------------------------------------------------------===//
        -:   50:
        -:   51:namespace {
        -:   52:
        -:   53:/// Testing the correctness of some traits.
        -:   54:static_assert(
        -:   55:    llvm::is_detected<OpTrait::has_implicit_terminator_t,
        -:   56:                      SingleBlockImplicitTerminatorOp>::value,
        -:   57:    "has_implicit_terminator_t does not match SingleBlockImplicitTerminatorOp");
        -:   58:static_assert(OpTrait::hasSingleBlockImplicitTerminator<
        -:   59:                  SingleBlockImplicitTerminatorOp>::value,
        -:   60:              "hasSingleBlockImplicitTerminator does not match "
        -:   61:              "SingleBlockImplicitTerminatorOp");
        -:   62:
        -:   63:struct TestResourceBlobManagerInterface
        -:   64:    : public ResourceBlobManagerDialectInterfaceBase<
        -:   65:          TestDialectResourceBlobHandle> {
        -:   66:  using ResourceBlobManagerDialectInterfaceBase<
     2511:   67:      TestDialectResourceBlobHandle>::ResourceBlobManagerDialectInterfaceBase;
call    0 returned 100%
call    1 returned 100%
        -:   68:};
        -:   69:
        -:   70:// Test support for interacting with the AsmPrinter.
        -:   71:struct TestOpAsmInterface : public OpAsmDialectInterface {
        -:   72:  using OpAsmDialectInterface::OpAsmDialectInterface;
     2511:   73:  TestOpAsmInterface(Dialect *dialect, TestResourceBlobManagerInterface &mgr)
     2511:   74:      : OpAsmDialectInterface(dialect), blobManager(mgr) {}
call    0 returned 100%
call    1 returned 100%
        -:   75:
        -:   76:  //===------------------------------------------------------------------===//
        -:   77:  // Aliases
        -:   78:  //===------------------------------------------------------------------===//
        -:   79:
function _ZNK12_GLOBAL__N_118TestOpAsmInterface8getAliasEN4mlir9AttributeERN4llvm11raw_ostreamE called 159842 returned 100% blocks executed 81%
   159842:   80:  AliasResult getAlias(Attribute attr, raw_ostream &os) const final {
   159842:   81:    StringAttr strAttr = attr.dyn_cast<StringAttr>();
call    0 returned 100%
   159842:   82:    if (!strAttr)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   83:      return AliasResult::NoAlias;
        -:   84:
        -:   85:    // Check the contents of the string attribute to see what the test alias
        -:   86:    // should be named.
     1355:   87:    Optional<StringRef> aliasName =
     1355:   88:        StringSwitch<Optional<StringRef>>(strAttr.getValue())
call    0 returned 100%
call    1 returned 100%
     1355:   89:            .Case("alias_test:dot_in_name", StringRef("test.alias"))
call    0 returned 100%
call    1 returned 100%
     1355:   90:            .Case("alias_test:trailing_digit", StringRef("test_alias0"))
call    0 returned 100%
     1355:   91:            .Case("alias_test:prefixed_digit", StringRef("0_test_alias"))
call    0 returned 100%
call    1 returned 100%
        -:   92:            .Case("alias_test:sanitize_conflict_a",
     1355:   93:                  StringRef("test_alias_conflict0"))
call    0 returned 100%
call    1 returned 100%
        -:   94:            .Case("alias_test:sanitize_conflict_b",
     1355:   95:                  StringRef("test_alias_conflict0_"))
call    0 returned 100%
call    1 returned 100%
     1355:   96:            .Case("alias_test:tensor_encoding", StringRef("test_encoding"))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1355:   97:            .Default(llvm::None);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1355:   98:    if (!aliasName)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   99:      return AliasResult::NoAlias;
        -:  100:
    #####:  101:    os << *aliasName;
call    0 never executed
    #####:  102:    return AliasResult::FinalAlias;
call    0 never executed
        -:  103:  }
        -:  104:
function _ZNK12_GLOBAL__N_118TestOpAsmInterface8getAliasEN4mlir4TypeERN4llvm11raw_ostreamE called 120368 returned 100% blocks executed 29%
   120368:  105:  AliasResult getAlias(Type type, raw_ostream &os) const final {
   120368:  106:    if (auto tupleType = type.dyn_cast<TupleType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  107:      if (tupleType.size() > 0 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  108:          llvm::all_of(tupleType.getTypes(), [](Type elemType) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  109:            return elemType.isa<SimpleAType>();
        -:  110:          })) {
    #####:  111:        os << "test_tuple";
call    0 never executed
    #####:  112:        return AliasResult::FinalAlias;
        -:  113:      }
        -:  114:    }
   120368:  115:    if (auto intType = type.dyn_cast<TestIntegerType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  116:      if (intType.getSignedness() ==
call    0 never executed
    #####:  117:              TestIntegerType::SignednessSemantics::Unsigned &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  118:          intType.getWidth() == 8) {
call    0 never executed
    #####:  119:        os << "test_ui8";
call    0 never executed
    #####:  120:        return AliasResult::FinalAlias;
        -:  121:      }
        -:  122:    }
   120368:  123:    if (auto recType = type.dyn_cast<TestRecursiveType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  124:      if (recType.getName() == "type_to_alias") {
branch  0 never executed
branch  1 never executed
        -:  125:        // We only make alias for a specific recursive type.
    #####:  126:        os << "testrec";
    #####:  127:        return AliasResult::FinalAlias;
call    0 never executed
        -:  128:      }
        -:  129:    }
        -:  130:    return AliasResult::NoAlias;
        -:  131:  }
        -:  132:
        -:  133:  //===------------------------------------------------------------------===//
        -:  134:  // Resources
        -:  135:  //===------------------------------------------------------------------===//
        -:  136:
        -:  137:  std::string
function _ZNK12_GLOBAL__N_118TestOpAsmInterface14getResourceKeyERKN4mlir24AsmDialectResourceHandleE called 0 returned 0% blocks executed 0%
    #####:  138:  getResourceKey(const AsmDialectResourceHandle &handle) const override {
    #####:  139:    return cast<TestDialectResourceBlobHandle>(handle).getKey().str();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  140:  }
        -:  141:
        -:  142:  FailureOr<AsmDialectResourceHandle>
function _ZNK12_GLOBAL__N_118TestOpAsmInterface15declareResourceEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  143:  declareResource(StringRef key) const final {
    #####:  144:    return blobManager.insert(key);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  145:  }
        -:  146:
function _ZNK12_GLOBAL__N_118TestOpAsmInterface13parseResourceERN4mlir22AsmParsedResourceEntryE called 0 returned 0% blocks executed 0%
    #####:  147:  LogicalResult parseResource(AsmParsedResourceEntry &entry) const final {
    #####:  148:    FailureOr<AsmResourceBlob> blob = entry.parseAsBlob();
call    0 never executed
    #####:  149:    if (failed(blob))
branch  0 never executed
branch  1 never executed
    #####:  150:      return failure();
        -:  151:
        -:  152:    // Update the blob for this entry.
    #####:  153:    blobManager.update(entry.getKey(), std::move(*blob));
call    0 never executed
call    1 never executed
    #####:  154:    return success();
branch  0 never executed
branch  1 never executed
        -:  155:  }
        -:  156:
        -:  157:  void
function _ZNK12_GLOBAL__N_118TestOpAsmInterface14buildResourcesEPN4mlir9OperationERKN4llvm9SetVectorINS1_24AsmDialectResourceHandleESt6vectorIS6_SaIS6_EENS4_8DenseSetIS6_NS4_12DenseMapInfoIS6_vEEEEEERNS1_18AsmResourceBuilderE called 845 returned 100% blocks executed 100%
      845:  158:  buildResources(Operation *op,
        -:  159:                 const SetVector<AsmDialectResourceHandle> &referencedResources,
        -:  160:                 AsmResourceBuilder &provider) const final {
      845:  161:    blobManager.buildResources(provider, referencedResources.getArrayRef());
call    0 returned 100%
      845:  162:  }
        -:  163:
        -:  164:private:
        -:  165:  /// The blob manager for the dialect.
        -:  166:  TestResourceBlobManagerInterface &blobManager;
        -:  167:};
        -:  168:
        -:  169:struct TestDialectFoldInterface : public DialectFoldInterface {
        -:  170:  using DialectFoldInterface::DialectFoldInterface;
        -:  171:
        -:  172:  /// Registered hook to check if the given region, which is attached to an
        -:  173:  /// operation that is *not* isolated from above, should be used when
        -:  174:  /// materializing constants.
function _ZNK12_GLOBAL__N_124TestDialectFoldInterface21shouldMaterializeIntoEPN4mlir6RegionE called 0 returned 0% blocks executed 0%
    #####:  175:  bool shouldMaterializeInto(Region *region) const final {
        -:  176:    // If this is a one region operation, then insert into it.
    #####:  177:    return isa<OneRegionOp>(region->getParentOp());
call    0 never executed
        -:  178:  }
        -:  179:};
        -:  180:
        -:  181:/// This class defines the interface for handling inlining with standard
        -:  182:/// operations.
        -:  183:struct TestInlinerInterface : public DialectInlinerInterface {
        -:  184:  using DialectInlinerInterface::DialectInlinerInterface;
        -:  185:
        -:  186:  //===--------------------------------------------------------------------===//
        -:  187:  // Analysis Hooks
        -:  188:  //===--------------------------------------------------------------------===//
        -:  189:
function _ZNK12_GLOBAL__N_120TestInlinerInterface15isLegalToInlineEPN4mlir9OperationES3_b called 0 returned 0% blocks executed 0%
    #####:  190:  bool isLegalToInline(Operation *call, Operation *callable,
        -:  191:                       bool wouldBeCloned) const final {
        -:  192:    // Don't allow inlining calls that are marked `noinline`.
    #####:  193:    return !call->hasAttr("noinline");
call    0 never executed
        -:  194:  }
function _ZNK12_GLOBAL__N_120TestInlinerInterface15isLegalToInlineEPN4mlir6RegionES3_bRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  195:  bool isLegalToInline(Region *, Region *, bool,
        -:  196:                       BlockAndValueMapping &) const final {
        -:  197:    // Inlining into test dialect regions is legal.
    #####:  198:    return true;
        -:  199:  }
function _ZNK12_GLOBAL__N_120TestInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  200:  bool isLegalToInline(Operation *, Region *, bool,
        -:  201:                       BlockAndValueMapping &) const final {
    #####:  202:    return true;
        -:  203:  }
        -:  204:
function _ZNK12_GLOBAL__N_120TestInlinerInterface24shouldAnalyzeRecursivelyEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  205:  bool shouldAnalyzeRecursively(Operation *op) const final {
        -:  206:    // Analyze recursively if this is not a functional region operation, it
        -:  207:    // froms a separate functional scope.
    #####:  208:    return !isa<FunctionalRegionOp>(op);
call    0 never executed
        -:  209:  }
        -:  210:
        -:  211:  //===--------------------------------------------------------------------===//
        -:  212:  // Transformation Hooks
        -:  213:  //===--------------------------------------------------------------------===//
        -:  214:
        -:  215:  /// Handle the given inlined terminator by replacing it with a new operation
        -:  216:  /// as necessary.
function _ZNK12_GLOBAL__N_120TestInlinerInterface16handleTerminatorEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  217:  void handleTerminator(Operation *op,
        -:  218:                        ArrayRef<Value> valuesToRepl) const final {
        -:  219:    // Only handle "test.return" here.
    #####:  220:    auto returnOp = dyn_cast<TestReturnOp>(op);
call    0 never executed
    #####:  221:    if (!returnOp)
branch  0 never executed
branch  1 never executed
    #####:  222:      return;
        -:  223:
        -:  224:    // Replace the values directly with the return operands.
    #####:  225:    assert(returnOp.getNumOperands() == valuesToRepl.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  226:    for (const auto &it : llvm::enumerate(returnOp.getOperands()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  227:      valuesToRepl[it.index()].replaceAllUsesWith(it.value());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  228:  }
        -:  229:
        -:  230:  /// Attempt to materialize a conversion for a type mismatch between a call
        -:  231:  /// from this dialect, and a callable region. This method should generate an
        -:  232:  /// operation that takes 'input' as the only operand, and produces a single
        -:  233:  /// result of 'resultType'. If a conversion can not be generated, nullptr
        -:  234:  /// should be returned.
function _ZNK12_GLOBAL__N_120TestInlinerInterface25materializeCallConversionERN4mlir9OpBuilderENS1_5ValueENS1_4TypeENS1_8LocationE called 0 returned 0% blocks executed 0%
    #####:  235:  Operation *materializeCallConversion(OpBuilder &builder, Value input,
        -:  236:                                       Type resultType,
        -:  237:                                       Location conversionLoc) const final {
        -:  238:    // Only allow conversion for i16/i32 types.
    #####:  239:    if (!(resultType.isSignlessInteger(16) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  240:          resultType.isSignlessInteger(32)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  241:        !(input.getType().isSignlessInteger(16) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  242:          input.getType().isSignlessInteger(32)))
call    0 never executed
    #####:  243:      return nullptr;
    #####:  244:    return builder.create<TestCastOp>(conversionLoc, resultType, input);
call    0 never executed
        -:  245:  }
        -:  246:
function _ZNK12_GLOBAL__N_120TestInlinerInterface24processInlinedCallBlocksEPN4mlir9OperationEN4llvm14iterator_rangeINS4_14ilist_iteratorINS4_12ilist_detail12node_optionsINS1_5BlockELb1ELb0EvEELb0ELb0EEEEE called 0 returned 0% blocks executed 0%
    #####:  247:  void processInlinedCallBlocks(
        -:  248:      Operation *call,
        -:  249:      iterator_range<Region::iterator> inlinedBlocks) const final {
    #####:  250:    if (!isa<ConversionCallOp>(call))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  251:      return;
        -:  252:
        -:  253:    // Set attributed on all ops in the inlined blocks.
    #####:  254:    for (Block &block : inlinedBlocks) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
function _ZZNK12_GLOBAL__N_120TestInlinerInterface24processInlinedCallBlocksEPN4mlir9OperationEN4llvm14iterator_rangeINS4_14ilist_iteratorINS4_12ilist_detail12node_optionsINS1_5BlockELb1ELb0EvEELb0ELb0EEEEEENKUlS3_E_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  255:      block.walk([&](Operation *op) {
call    0 never executed
    #####:  256:        op->setAttr("inlined_conversion", UnitAttr::get(call->getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  257:      });
        -:  258:    }
        -:  259:  }
        -:  260:};
        -:  261:
        -:  262:struct TestReductionPatternInterface : public DialectReductionPatternInterface {
        -:  263:public:
        -:  264:  TestReductionPatternInterface(Dialect *dialect)
        -:  265:      : DialectReductionPatternInterface(dialect) {}
        -:  266:
function _ZNK12_GLOBAL__N_129TestReductionPatternInterface25populateReductionPatternsERN4mlir17RewritePatternSetE called 0 returned 0% blocks executed 0%
    #####:  267:  void populateReductionPatterns(RewritePatternSet &patterns) const final {
    #####:  268:    populateTestReductionPatterns(patterns);
call    0 never executed
    #####:  269:  }
        -:  270:};
        -:  271:
        -:  272:} // namespace
        -:  273:
        -:  274://===----------------------------------------------------------------------===//
        -:  275:// Dynamic operations
        -:  276://===----------------------------------------------------------------------===//
        -:  277:
function _Z19getDynamicGenericOpPN4test11TestDialectE called 2511 returned 100% blocks executed 100%
     2511:  278:std::unique_ptr<DynamicOpDefinition> getDynamicGenericOp(TestDialect *dialect) {
     2511:  279:  return DynamicOpDefinition::get(
    #####:  280:      "dynamic_generic", dialect, [](Operation *op) { return success(); },
    2511*:  281:      [](Operation *op) { return success(); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  282:}
        -:  283:
        -:  284:std::unique_ptr<DynamicOpDefinition>
function _Z32getDynamicOneOperandTwoResultsOpPN4test11TestDialectE called 2511 returned 100% blocks executed 100%
     2511:  285:getDynamicOneOperandTwoResultsOp(TestDialect *dialect) {
     2511:  286:  return DynamicOpDefinition::get(
        -:  287:      "dynamic_one_operand_two_results", dialect,
function _ZZ32getDynamicOneOperandTwoResultsOpPN4test11TestDialectEENKUlPN4mlir9OperationEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  288:      [](Operation *op) {
    #####:  289:        if (op->getNumOperands() != 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  290:          op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  291:              << "expected 1 operand, but had " << op->getNumOperands();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  292:          return failure();
        -:  293:        }
    #####:  294:        if (op->getNumResults() != 2) {
branch  0 never executed
branch  1 never executed
    #####:  295:          op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  296:              << "expected 2 results, but had " << op->getNumResults();
call    0 never executed
call    1 never executed
    #####:  297:          return failure();
        -:  298:        }
    #####:  299:        return success();
        -:  300:      },
    2511*:  301:      [](Operation *op) { return success(); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  302:}
        -:  303:
        -:  304:std::unique_ptr<DynamicOpDefinition>
function _Z31getDynamicCustomParserPrinterOpPN4test11TestDialectE called 2511 returned 100% blocks executed 100%
     2511:  305:getDynamicCustomParserPrinterOp(TestDialect *dialect) {
function _ZZ31getDynamicCustomParserPrinterOpPN4test11TestDialectEENKUlPN4mlir9OperationEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    2511*:  306:  auto verifier = [](Operation *op) {
    #####:  307:    if (op->getNumOperands() == 0 && op->getNumResults() == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  308:      return success();
    #####:  309:    op->emitError() << "operation should have no operands and no results";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  310:    return failure();
        -:  311:  };
    2511*:  312:  auto regionVerifier = [](Operation *op) { return success(); };
        -:  313:
    2511*:  314:  auto parser = [](OpAsmParser &parser, OperationState &state) {
    #####:  315:    return parser.parseKeyword("custom_keyword");
call    0 never executed
        -:  316:  };
        -:  317:
function _ZZ31getDynamicCustomParserPrinterOpPN4test11TestDialectEENKUlPN4mlir9OperationERNS2_12OpAsmPrinterEN4llvm9StringRefEE2_clES4_S6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  318:  auto printer = [](Operation *op, OpAsmPrinter &printer, llvm::StringRef) {
    #####:  319:    printer << op->getName() << " custom_keyword";
call    0 never executed
call    1 never executed
    #####:  320:  };
        -:  321:
     2511:  322:  return DynamicOpDefinition::get("dynamic_custom_parser_printer", dialect,
     2511:  323:                                  verifier, regionVerifier, parser, printer);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
        -:  324:}
        -:  325:
        -:  326://===----------------------------------------------------------------------===//
        -:  327:// TestDialect
        -:  328://===----------------------------------------------------------------------===//
        -:  329:
        -:  330:static void testSideEffectOpGetEffect(
        -:  331:    Operation *op,
        -:  332:    SmallVectorImpl<SideEffects::EffectInstance<TestEffects::Effect>> &effects);
        -:  333:
        -:  334:// This is the implementation of a dialect fallback for `TestEffectOpInterface`.
     2511:  335:struct TestOpEffectInterfaceFallback
        -:  336:    : public TestEffectOpInterface::FallbackModel<
        -:  337:          TestOpEffectInterfaceFallback> {
        -:  338:  static bool classof(Operation *op) {
        -:  339:    bool isSupportedOp =
        -:  340:        op->getName().getStringRef() == "test.unregistered_side_effect_op";
        -:  341:    assert(isSupportedOp && "Unexpected dispatch");
        -:  342:    return isSupportedOp;
        -:  343:  }
        -:  344:
        -:  345:  void
    #####:  346:  getEffects(Operation *op,
        -:  347:             SmallVectorImpl<SideEffects::EffectInstance<TestEffects::Effect>>
        -:  348:                 &effects) const {
    #####:  349:    testSideEffectOpGetEffect(op, effects);
call    0 never executed
        -:  350:  }
        -:  351:};
        -:  352:
function _ZN4test11TestDialect10initializeEv called 2511 returned 100% blocks executed 100%
     2511:  353:void TestDialect::initialize() {
     2511:  354:  registerAttributes();
call    0 returned 100%
     2511:  355:  registerTypes();
call    0 returned 100%
     2511:  356:  addOperations<
        -:  357:#define GET_OP_LIST
        -:  358:#include "TestOps.cpp.inc"
     2511:  359:      >();
call    0 returned 100%
     2511:  360:  registerDynamicOp(getDynamicGenericOp(this));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2511:  361:  registerDynamicOp(getDynamicOneOperandTwoResultsOp(this));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2511:  362:  registerDynamicOp(getDynamicCustomParserPrinterOp(this));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  363:
     2511:  364:  auto &blobInterface = addInterface<TestResourceBlobManagerInterface>();
call    0 returned 100%
     2511:  365:  addInterface<TestOpAsmInterface>(blobInterface);
call    0 returned 100%
        -:  366:
     2511:  367:  addInterfaces<TestDialectFoldInterface, TestInlinerInterface,
     2511:  368:                TestReductionPatternInterface>();
call    0 returned 100%
     2511:  369:  allowUnknownOperations();
call    0 returned 100%
        -:  370:
        -:  371:  // Instantiate our fallback op interface that we'll use on specific
        -:  372:  // unregistered op.
     2511:  373:  fallbackEffectOpInterfaces = new TestOpEffectInterfaceFallback;
call    0 returned 100%
     2511:  374:}
     5002:  375:TestDialect::~TestDialect() {
     2501:  376:  delete static_cast<TestOpEffectInterfaceFallback *>(
     2501:  377:      fallbackEffectOpInterfaces);
     5002:  378:}
------------------
_ZN4test11TestDialectD0Ev:
function _ZN4test11TestDialectD0Ev called 2501 returned 100% blocks executed 100%
     2501:  375:TestDialect::~TestDialect() {
        -:  376:  delete static_cast<TestOpEffectInterfaceFallback *>(
        -:  377:      fallbackEffectOpInterfaces);
     2501:  378:}
call    0 returned 100%
call    1 returned 100%
------------------
_ZN4test11TestDialectD2Ev:
function _ZN4test11TestDialectD2Ev called 2501 returned 100% blocks executed 100%
     2501:  375:TestDialect::~TestDialect() {
call    0 returned 100%
     2501:  376:  delete static_cast<TestOpEffectInterfaceFallback *>(
     2501:  377:      fallbackEffectOpInterfaces);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     2501:  378:}
------------------
        -:  379:
function _ZN4test11TestDialect19materializeConstantERN4mlir9OpBuilderENS1_9AttributeENS1_4TypeENS1_8LocationE called 0 returned 0% blocks executed 0%
    #####:  380:Operation *TestDialect::materializeConstant(OpBuilder &builder, Attribute value,
        -:  381:                                            Type type, Location loc) {
    #####:  382:  return builder.create<TestOpConstant>(loc, type, value);
call    0 never executed
        -:  383:}
        -:  384:
function _ZN4test18FormatInferType2Op16inferReturnTypesEPN4mlir11MLIRContextEN4llvm8OptionalINS1_8LocationEEENS1_10ValueRangeENS1_14DictionaryAttrENS1_11RegionRangeERNS4_15SmallVectorImplINS1_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  385:::mlir::LogicalResult FormatInferType2Op::inferReturnTypes(
        -:  386:    ::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location,
        -:  387:    ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes,
        -:  388:    ::mlir::RegionRange regions,
        -:  389:    ::llvm::SmallVectorImpl<::mlir::Type> &inferredReturnTypes) {
    #####:  390:  inferredReturnTypes.assign({::mlir::IntegerType::get(context, 16)});
call    0 never executed
call    1 never executed
    #####:  391:  return ::mlir::success();
        -:  392:}
        -:  393:
function _ZN4test11TestDialect27getRegisteredInterfaceForOpEN4mlir6TypeIDENS1_13OperationNameE called 0 returned 0% blocks executed 0%
    #####:  394:void *TestDialect::getRegisteredInterfaceForOp(TypeID typeID,
        -:  395:                                               OperationName opName) {
    #####:  396:  if (opName.getIdentifier() == "test.unregistered_side_effect_op" &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  397:      typeID == TypeID::get<TestEffectOpInterface>())
branch  0 never executed
branch  1 never executed
    #####:  398:    return fallbackEffectOpInterfaces;
        -:  399:  return nullptr;
        -:  400:}
        -:  401:
function _ZN4test11TestDialect24verifyOperationAttributeEPN4mlir9OperationENS1_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  402:LogicalResult TestDialect::verifyOperationAttribute(Operation *op,
        -:  403:                                                    NamedAttribute namedAttr) {
    #####:  404:  if (namedAttr.getName() == "test.invalid_attr")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  405:    return op->emitError() << "invalid to use 'test.invalid_attr'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  406:  return success();
        -:  407:}
        -:  408:
function _ZN4test11TestDialect24verifyRegionArgAttributeEPN4mlir9OperationEjjNS1_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  409:LogicalResult TestDialect::verifyRegionArgAttribute(Operation *op,
        -:  410:                                                    unsigned regionIndex,
        -:  411:                                                    unsigned argIndex,
        -:  412:                                                    NamedAttribute namedAttr) {
    #####:  413:  if (namedAttr.getName() == "test.invalid_attr")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  414:    return op->emitError() << "invalid to use 'test.invalid_attr'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  415:  return success();
        -:  416:}
        -:  417:
        -:  418:LogicalResult
function _ZN4test11TestDialect27verifyRegionResultAttributeEPN4mlir9OperationEjjNS1_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  419:TestDialect::verifyRegionResultAttribute(Operation *op, unsigned regionIndex,
        -:  420:                                         unsigned resultIndex,
        -:  421:                                         NamedAttribute namedAttr) {
    #####:  422:  if (namedAttr.getName() == "test.invalid_attr")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  423:    return op->emitError() << "invalid to use 'test.invalid_attr'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  424:  return success();
        -:  425:}
        -:  426:
        -:  427:Optional<Dialect::ParseOpHook>
function _ZNK4test11TestDialect21getParseOperationHookEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  428:TestDialect::getParseOperationHook(StringRef opName) const {
    #####:  429:  if (opName == "test.dialect_custom_printer") {
branch  0 never executed
branch  1 never executed
    #####:  430:    return ParseOpHook{[](OpAsmParser &parser, OperationState &state) {
    #####:  431:      return parser.parseKeyword("custom_format");
call    0 never executed
    #####:  432:    }};
        -:  433:  }
    #####:  434:  if (opName == "test.dialect_custom_format_fallback") {
branch  0 never executed
branch  1 never executed
    #####:  435:    return ParseOpHook{[](OpAsmParser &parser, OperationState &state) {
    #####:  436:      return parser.parseKeyword("custom_format_fallback");
call    0 never executed
    #####:  437:    }};
        -:  438:  }
    #####:  439:  if (opName == "test.dialect_custom_printer.with.dot") {
branch  0 never executed
branch  1 never executed
    #####:  440:    return ParseOpHook{[](OpAsmParser &parser, OperationState &state) {
    #####:  441:      return ParseResult::success();
    #####:  442:    }};
        -:  443:  }
    #####:  444:  return None;
        -:  445:}
        -:  446:
        -:  447:llvm::unique_function<void(Operation *, OpAsmPrinter &)>
function _ZNK4test11TestDialect19getOperationPrinterEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  448:TestDialect::getOperationPrinter(Operation *op) const {
    #####:  449:  StringRef opName = op->getName().getStringRef();
call    0 never executed
    #####:  450:  if (opName == "test.dialect_custom_printer") {
branch  0 never executed
branch  1 never executed
function _ZZNK4test11TestDialect19getOperationPrinterEPN4mlir9OperationEENKUlS3_RNS1_12OpAsmPrinterEE_clES3_S5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  451:    return [](Operation *op, OpAsmPrinter &printer) {
    #####:  452:      printer.getStream() << " custom_format";
call    0 never executed
call    1 never executed
    #####:  453:    };
call    0 never executed
        -:  454:  }
    #####:  455:  if (opName == "test.dialect_custom_format_fallback") {
branch  0 never executed
branch  1 never executed
function _ZZNK4test11TestDialect19getOperationPrinterEPN4mlir9OperationEENKUlS3_RNS1_12OpAsmPrinterEE0_clES3_S5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  456:    return [](Operation *op, OpAsmPrinter &printer) {
    #####:  457:      printer.getStream() << " custom_format_fallback";
call    0 never executed
call    1 never executed
    #####:  458:    };
call    0 never executed
        -:  459:  }
    #####:  460:  return {};
        -:  461:}
        -:  462:
        -:  463://===----------------------------------------------------------------------===//
        -:  464:// TypedAttrOp
        -:  465://===----------------------------------------------------------------------===//
        -:  466:
        -:  467:/// Parse an attribute with a given type.
    #####:  468:static ParseResult parseAttrElideType(AsmParser &parser, TypeAttr type,
        -:  469:                                      Attribute &attr) {
    #####:  470:  return parser.parseAttribute(attr, type.getValue());
call    0 never executed
call    1 never executed
        -:  471:}
        -:  472:
        -:  473:/// Print an attribute without its type.
    #####:  474:static void printAttrElideType(AsmPrinter &printer, Operation *op,
        -:  475:                               TypeAttr type, Attribute attr) {
    #####:  476:  printer.printAttributeWithoutType(attr);
call    0 never executed
        -:  477:}
        -:  478:
        -:  479://===----------------------------------------------------------------------===//
        -:  480:// TestBranchOp
        -:  481://===----------------------------------------------------------------------===//
        -:  482:
function _ZN4test12TestBranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  483:SuccessorOperands TestBranchOp::getSuccessorOperands(unsigned index) {
    #####:  484:  assert(index == 0 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  485:  return SuccessorOperands(getTargetOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  486:}
        -:  487:
        -:  488://===----------------------------------------------------------------------===//
        -:  489:// TestProducingBranchOp
        -:  490://===----------------------------------------------------------------------===//
        -:  491:
function _ZN4test21TestProducingBranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  492:SuccessorOperands TestProducingBranchOp::getSuccessorOperands(unsigned index) {
    #####:  493:  assert(index <= 1 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  494:  if (index == 1)
branch  0 never executed
branch  1 never executed
    #####:  495:    return SuccessorOperands(getFirstOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  496:  return SuccessorOperands(getSecondOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  497:}
        -:  498:
        -:  499://===----------------------------------------------------------------------===//
        -:  500:// TestProducingBranchOp
        -:  501://===----------------------------------------------------------------------===//
        -:  502:
function _ZN4test20TestInternalBranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  503:SuccessorOperands TestInternalBranchOp::getSuccessorOperands(unsigned index) {
    #####:  504:  assert(index <= 1 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  505:  if (index == 0)
branch  0 never executed
branch  1 never executed
    #####:  506:    return SuccessorOperands(0, getSuccessOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  507:  return SuccessorOperands(1, getErrorOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  508:}
        -:  509:
        -:  510://===----------------------------------------------------------------------===//
        -:  511:// TestDialectCanonicalizerOp
        -:  512://===----------------------------------------------------------------------===//
        -:  513:
        -:  514:static LogicalResult
function _ZL30dialectCanonicalizationPatternN4test26TestDialectCanonicalizerOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  515:dialectCanonicalizationPattern(TestDialectCanonicalizerOp op,
        -:  516:                               PatternRewriter &rewriter) {
    #####:  517:  rewriter.replaceOpWithNewOp<arith::ConstantOp>(
    #####:  518:      op, rewriter.getI32IntegerAttr(42));
call    0 never executed
call    1 never executed
    #####:  519:  return success();
        -:  520:}
        -:  521:
function _ZNK4test11TestDialect27getCanonicalizationPatternsERN4mlir17RewritePatternSetE called 39 returned 100% blocks executed 100%
       39:  522:void TestDialect::getCanonicalizationPatterns(
        -:  523:    RewritePatternSet &results) const {
       39:  524:  results.add(&dialectCanonicalizationPattern);
call    0 returned 100%
       39:  525:}
        -:  526:
        -:  527://===----------------------------------------------------------------------===//
        -:  528:// TestCallOp
        -:  529://===----------------------------------------------------------------------===//
        -:  530:
function _ZN4test10TestCallOp16verifySymbolUsesERN4mlir21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####:  531:LogicalResult TestCallOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
        -:  532:  // Check that the callee attribute was specified.
    #####:  533:  auto fnAttr = (*this)->getAttrOfType<FlatSymbolRefAttr>("callee");
call    0 never executed
    #####:  534:  if (!fnAttr)
branch  0 never executed
branch  1 never executed
    #####:  535:    return emitOpError("requires a 'callee' symbol reference attribute");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  536:  if (!symbolTable.lookupNearestSymbolFrom<FunctionOpInterface>(*this, fnAttr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  537:    return emitOpError() << "'" << fnAttr.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  538:                         << "' does not reference a valid function";
call    0 never executed
    #####:  539:  return success();
        -:  540:}
        -:  541:
        -:  542://===----------------------------------------------------------------------===//
        -:  543:// TestFoldToCallOp
        -:  544://===----------------------------------------------------------------------===//
        -:  545:
        -:  546:namespace {
        -:  547:struct FoldToCallOpPattern : public OpRewritePattern<FoldToCallOp> {
        -:  548:  using OpRewritePattern<FoldToCallOp>::OpRewritePattern;
        -:  549:
function _ZNK12_GLOBAL__N_119FoldToCallOpPattern15matchAndRewriteEN4test12FoldToCallOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  550:  LogicalResult matchAndRewrite(FoldToCallOp op,
        -:  551:                                PatternRewriter &rewriter) const override {
    #####:  552:    rewriter.replaceOpWithNewOp<func::CallOp>(op, TypeRange(),
call    0 never executed
    #####:  553:                                              op.getCalleeAttr(), ValueRange());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  554:    return success();
        -:  555:  }
        -:  556:};
        -:  557:} // namespace
        -:  558:
function _ZN4test12FoldToCallOp27getCanonicalizationPatternsERN4mlir17RewritePatternSetEPNS1_11MLIRContextE called 39 returned 100% blocks executed 100%
       39:  559:void FoldToCallOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  560:                                               MLIRContext *context) {
       39:  561:  results.add<FoldToCallOpPattern>(context);
call    0 returned 100%
       39:  562:}
        -:  563:
        -:  564://===----------------------------------------------------------------------===//
        -:  565:// Test Format* operations
        -:  566://===----------------------------------------------------------------------===//
        -:  567:
        -:  568://===----------------------------------------------------------------------===//
        -:  569:// Parsing
        -:  570:
function _ZL26parseCustomOptionalOperandRN4mlir11OpAsmParserERN4llvm8OptionalINS0_17UnresolvedOperandEEE called 0 returned 0% blocks executed 0%
    #####:  571:static ParseResult parseCustomOptionalOperand(
        -:  572:    OpAsmParser &parser, Optional<OpAsmParser::UnresolvedOperand> &optOperand) {
    #####:  573:  if (succeeded(parser.parseOptionalLParen())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  574:    optOperand.emplace();
call    0 never executed
    #####:  575:    if (parser.parseOperand(*optOperand) || parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  576:      return failure();
        -:  577:  }
    #####:  578:  return success();
        -:  579:}
        -:  580:
function _ZL28parseCustomDirectiveOperandsRN4mlir11OpAsmParserERNS0_17UnresolvedOperandERN4llvm8OptionalIS2_EERNS4_15SmallVectorImplIS2_EE called 0 returned 0% blocks executed 0%
    #####:  581:static ParseResult parseCustomDirectiveOperands(
        -:  582:    OpAsmParser &parser, OpAsmParser::UnresolvedOperand &operand,
        -:  583:    Optional<OpAsmParser::UnresolvedOperand> &optOperand,
        -:  584:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &varOperands) {
    #####:  585:  if (parser.parseOperand(operand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  586:    return failure();
    #####:  587:  if (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  588:    optOperand.emplace();
call    0 never executed
    #####:  589:    if (parser.parseOperand(*optOperand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  590:      return failure();
        -:  591:  }
    #####:  592:  if (parser.parseArrow() || parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  593:      parser.parseOperandList(varOperands) || parser.parseRParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  594:    return failure();
    #####:  595:  return success();
        -:  596:}
        -:  597:static ParseResult
function _ZL27parseCustomDirectiveResultsRN4mlir11OpAsmParserERNS_4TypeES3_RN4llvm15SmallVectorImplIS2_EE called 0 returned 0% blocks executed 0%
    #####:  598:parseCustomDirectiveResults(OpAsmParser &parser, Type &operandType,
        -:  599:                            Type &optOperandType,
        -:  600:                            SmallVectorImpl<Type> &varOperandTypes) {
    #####:  601:  if (parser.parseColon())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  602:    return failure();
        -:  603:
    #####:  604:  if (parser.parseType(operandType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  605:    return failure();
    #####:  606:  if (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  607:    if (parser.parseType(optOperandType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  608:      return failure();
        -:  609:  }
    #####:  610:  if (parser.parseArrow() || parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  611:      parser.parseTypeList(varOperandTypes) || parser.parseRParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  612:    return failure();
    #####:  613:  return success();
        -:  614:}
        -:  615:static ParseResult
function _ZL32parseCustomDirectiveWithTypeRefsRN4mlir11OpAsmParserENS_4TypeES2_RKN4llvm15SmallVectorImplIS2_EE called 0 returned 0% blocks executed 0%
    #####:  616:parseCustomDirectiveWithTypeRefs(OpAsmParser &parser, Type operandType,
        -:  617:                                 Type optOperandType,
        -:  618:                                 const SmallVectorImpl<Type> &varOperandTypes) {
    #####:  619:  if (parser.parseKeyword("type_refs_capture"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  620:    return failure();
        -:  621:
    #####:  622:  Type operandType2, optOperandType2;
    #####:  623:  SmallVector<Type, 1> varOperandTypes2;
call    0 never executed
    #####:  624:  if (parseCustomDirectiveResults(parser, operandType2, optOperandType2,
branch  0 never executed
branch  1 never executed
    #####:  625:                                  varOperandTypes2))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  626:    return failure();
        -:  627:
    #####:  628:  if (operandType != operandType2 || optOperandType != optOperandType2 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  629:      varOperandTypes != varOperandTypes2)
branch  0 never executed
branch  1 never executed
    #####:  630:    return failure();
        -:  631:
    #####:  632:  return success();
        -:  633:}
function _ZL36parseCustomDirectiveOperandsAndTypesRN4mlir11OpAsmParserERNS0_17UnresolvedOperandERN4llvm8OptionalIS2_EERNS4_15SmallVectorImplIS2_EERNS_4TypeESC_RNS8_ISB_EE called 0 returned 0% blocks executed 0%
    #####:  634:static ParseResult parseCustomDirectiveOperandsAndTypes(
        -:  635:    OpAsmParser &parser, OpAsmParser::UnresolvedOperand &operand,
        -:  636:    Optional<OpAsmParser::UnresolvedOperand> &optOperand,
        -:  637:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &varOperands,
        -:  638:    Type &operandType, Type &optOperandType,
        -:  639:    SmallVectorImpl<Type> &varOperandTypes) {
    #####:  640:  if (parseCustomDirectiveOperands(parser, operand, optOperand, varOperands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  641:      parseCustomDirectiveResults(parser, operandType, optOperandType,
    #####:  642:                                  varOperandTypes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  643:    return failure();
    #####:  644:  return success();
        -:  645:}
function _ZL27parseCustomDirectiveRegionsRN4mlir11OpAsmParserERNS_6RegionERN4llvm15SmallVectorImplISt10unique_ptrIS2_St14default_deleteIS2_EEEE called 0 returned 0% blocks executed 0%
    #####:  646:static ParseResult parseCustomDirectiveRegions(
        -:  647:    OpAsmParser &parser, Region &region,
        -:  648:    SmallVectorImpl<std::unique_ptr<Region>> &varRegions) {
    #####:  649:  if (parser.parseRegion(region))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  650:    return failure();
    #####:  651:  if (failed(parser.parseOptionalComma()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  652:    return success();
    #####:  653:  std::unique_ptr<Region> varRegion = std::make_unique<Region>();
call    0 never executed
    #####:  654:  if (parser.parseRegion(*varRegion))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  655:    return failure();
    #####:  656:  varRegions.emplace_back(std::move(varRegion));
call    0 never executed
    #####:  657:  return success();
        -:  658:}
        -:  659:static ParseResult
function _ZL30parseCustomDirectiveSuccessorsRN4mlir11OpAsmParserERPNS_5BlockERN4llvm15SmallVectorImplIS3_EE called 0 returned 0% blocks executed 0%
    #####:  660:parseCustomDirectiveSuccessors(OpAsmParser &parser, Block *&successor,
        -:  661:                               SmallVectorImpl<Block *> &varSuccessors) {
    #####:  662:  if (parser.parseSuccessor(successor))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  663:    return failure();
    #####:  664:  if (failed(parser.parseOptionalComma()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  665:    return success();
    #####:  666:  Block *varSuccessor;
    #####:  667:  if (parser.parseSuccessor(varSuccessor))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  668:    return failure();
    #####:  669:  varSuccessors.append(2, varSuccessor);
call    0 never executed
    #####:  670:  return success();
        -:  671:}
function _ZL30parseCustomDirectiveAttributesRN4mlir11OpAsmParserERNS_11IntegerAttrES3_ called 0 returned 0% blocks executed 0%
    #####:  672:static ParseResult parseCustomDirectiveAttributes(OpAsmParser &parser,
        -:  673:                                                  IntegerAttr &attr,
        -:  674:                                                  IntegerAttr &optAttr) {
    #####:  675:  if (parser.parseAttribute(attr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  676:    return failure();
    #####:  677:  if (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  678:    if (parser.parseAttribute(optAttr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  679:      return failure();
        -:  680:  }
    #####:  681:  return success();
        -:  682:}
        -:  683:
    #####:  684:static ParseResult parseCustomDirectiveAttrDict(OpAsmParser &parser,
        -:  685:                                                NamedAttrList &attrs) {
    #####:  686:  return parser.parseOptionalAttrDict(attrs);
call    0 never executed
        -:  687:}
function _ZL38parseCustomDirectiveOptionalOperandRefRN4mlir11OpAsmParserERN4llvm8OptionalINS0_17UnresolvedOperandEEE called 0 returned 0% blocks executed 0%
    #####:  688:static ParseResult parseCustomDirectiveOptionalOperandRef(
        -:  689:    OpAsmParser &parser, Optional<OpAsmParser::UnresolvedOperand> &optOperand) {
    #####:  690:  int64_t operandCount = 0;
    #####:  691:  if (parser.parseInteger(operandCount))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  692:    return failure();
    #####:  693:  bool expectedOptionalOperand = operandCount == 0;
    #####:  694:  return success(expectedOptionalOperand != optOperand.has_value());
        -:  695:}
        -:  696:
        -:  697://===----------------------------------------------------------------------===//
        -:  698:// Printing
        -:  699:
        -:  700:static void printCustomOptionalOperand(OpAsmPrinter &printer, Operation *,
        -:  701:                                       Value optOperand) {
        -:  702:  if (optOperand)
        -:  703:    printer << "(" << optOperand << ") ";
        -:  704:}
        -:  705:
        -:  706:static void printCustomDirectiveOperands(OpAsmPrinter &printer, Operation *,
        -:  707:                                         Value operand, Value optOperand,
        -:  708:                                         OperandRange varOperands) {
        -:  709:  printer << operand;
        -:  710:  if (optOperand)
        -:  711:    printer << ", " << optOperand;
        -:  712:  printer << " -> (" << varOperands << ")";
        -:  713:}
        -:  714:static void printCustomDirectiveResults(OpAsmPrinter &printer, Operation *,
        -:  715:                                        Type operandType, Type optOperandType,
        -:  716:                                        TypeRange varOperandTypes) {
        -:  717:  printer << " : " << operandType;
        -:  718:  if (optOperandType)
        -:  719:    printer << ", " << optOperandType;
        -:  720:  printer << " -> (" << varOperandTypes << ")";
        -:  721:}
        -:  722:static void printCustomDirectiveWithTypeRefs(OpAsmPrinter &printer,
        -:  723:                                             Operation *op, Type operandType,
        -:  724:                                             Type optOperandType,
        -:  725:                                             TypeRange varOperandTypes) {
        -:  726:  printer << " type_refs_capture ";
        -:  727:  printCustomDirectiveResults(printer, op, operandType, optOperandType,
        -:  728:                              varOperandTypes);
        -:  729:}
    #####:  730:static void printCustomDirectiveOperandsAndTypes(
        -:  731:    OpAsmPrinter &printer, Operation *op, Value operand, Value optOperand,
        -:  732:    OperandRange varOperands, Type operandType, Type optOperandType,
        -:  733:    TypeRange varOperandTypes) {
    #####:  734:  printCustomDirectiveOperands(printer, op, operand, optOperand, varOperands);
call    0 never executed
    #####:  735:  printCustomDirectiveResults(printer, op, operandType, optOperandType,
call    0 never executed
        -:  736:                              varOperandTypes);
        -:  737:}
        -:  738:static void printCustomDirectiveRegions(OpAsmPrinter &printer, Operation *,
        -:  739:                                        Region &region,
        -:  740:                                        MutableArrayRef<Region> varRegions) {
        -:  741:  printer.printRegion(region);
        -:  742:  if (!varRegions.empty()) {
        -:  743:    printer << ", ";
        -:  744:    for (Region &region : varRegions)
        -:  745:      printer.printRegion(region);
        -:  746:  }
        -:  747:}
        -:  748:static void printCustomDirectiveSuccessors(OpAsmPrinter &printer, Operation *,
        -:  749:                                           Block *successor,
        -:  750:                                           SuccessorRange varSuccessors) {
        -:  751:  printer << successor;
        -:  752:  if (!varSuccessors.empty())
        -:  753:    printer << ", " << varSuccessors.front();
        -:  754:}
        -:  755:static void printCustomDirectiveAttributes(OpAsmPrinter &printer, Operation *,
        -:  756:                                           Attribute attribute,
        -:  757:                                           Attribute optAttribute) {
        -:  758:  printer << attribute;
        -:  759:  if (optAttribute)
        -:  760:    printer << ", " << optAttribute;
        -:  761:}
        -:  762:
        -:  763:static void printCustomDirectiveAttrDict(OpAsmPrinter &printer, Operation *op,
        -:  764:                                         DictionaryAttr attrs) {
        -:  765:  printer.printOptionalAttrDict(attrs.getValue());
        -:  766:}
        -:  767:
        -:  768:static void printCustomDirectiveOptionalOperandRef(OpAsmPrinter &printer,
        -:  769:                                                   Operation *op,
        -:  770:                                                   Value optOperand) {
        -:  771:  printer << (optOperand ? "1" : "0");
        -:  772:}
        -:  773:
        -:  774://===----------------------------------------------------------------------===//
        -:  775:// Test IsolatedRegionOp - parse passthrough region arguments.
        -:  776://===----------------------------------------------------------------------===//
        -:  777:
function _ZN4test16IsolatedRegionOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  778:ParseResult IsolatedRegionOp::parse(OpAsmParser &parser,
        -:  779:                                    OperationState &result) {
        -:  780:  // Parse the input operand.
    #####:  781:  OpAsmParser::Argument argInfo;
call    0 never executed
    #####:  782:  argInfo.type = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####:  783:  if (parser.parseOperand(argInfo.ssaName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  784:      parser.resolveOperand(argInfo.ssaName, argInfo.type, result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  785:    return failure();
        -:  786:
        -:  787:  // Parse the body region, and reuse the operand info as the argument info.
    #####:  788:  Region *body = result.addRegion();
call    0 never executed
    #####:  789:  return parser.parseRegion(*body, argInfo, /*enableNameShadowing=*/true);
call    0 never executed
        -:  790:}
        -:  791:
function _ZN4test16IsolatedRegionOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  792:void IsolatedRegionOp::print(OpAsmPrinter &p) {
    #####:  793:  p << "test.isolated_region ";
call    0 never executed
    #####:  794:  p.printOperand(getOperand());
call    0 never executed
call    1 never executed
    #####:  795:  p.shadowRegionArgs(getRegion(), getOperand());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  796:  p << ' ';
call    0 never executed
    #####:  797:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false);
call    0 never executed
call    1 never executed
    #####:  798:}
        -:  799:
        -:  800://===----------------------------------------------------------------------===//
        -:  801:// Test SSACFGRegionOp
        -:  802://===----------------------------------------------------------------------===//
        -:  803:
function _ZN4test14SSACFGRegionOp13getRegionKindEj called 0 returned 0% blocks executed 0%
    #####:  804:RegionKind SSACFGRegionOp::getRegionKind(unsigned index) {
    #####:  805:  return RegionKind::SSACFG;
        -:  806:}
        -:  807:
        -:  808://===----------------------------------------------------------------------===//
        -:  809:// Test GraphRegionOp
        -:  810://===----------------------------------------------------------------------===//
        -:  811:
function _ZN4test13GraphRegionOp13getRegionKindEj called 0 returned 0% blocks executed 0%
    #####:  812:RegionKind GraphRegionOp::getRegionKind(unsigned index) {
    #####:  813:  return RegionKind::Graph;
        -:  814:}
        -:  815:
        -:  816://===----------------------------------------------------------------------===//
        -:  817:// Test AffineScopeOp
        -:  818://===----------------------------------------------------------------------===//
        -:  819:
function _ZN4test13AffineScopeOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  820:ParseResult AffineScopeOp::parse(OpAsmParser &parser, OperationState &result) {
        -:  821:  // Parse the body region, and reuse the operand info as the argument info.
    #####:  822:  Region *body = result.addRegion();
call    0 never executed
    #####:  823:  return parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{});
call    0 never executed
        -:  824:}
        -:  825:
function _ZN4test13AffineScopeOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  826:void AffineScopeOp::print(OpAsmPrinter &p) {
    #####:  827:  p << "test.affine_scope ";
call    0 never executed
    #####:  828:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false);
call    0 never executed
call    1 never executed
    #####:  829:}
        -:  830:
        -:  831://===----------------------------------------------------------------------===//
        -:  832:// Test parser.
        -:  833://===----------------------------------------------------------------------===//
        -:  834:
function _ZN4test21ParseIntegerLiteralOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  835:ParseResult ParseIntegerLiteralOp::parse(OpAsmParser &parser,
        -:  836:                                         OperationState &result) {
    #####:  837:  if (parser.parseOptionalColon())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  838:    return success();
    #####:  839:  uint64_t numResults;
    #####:  840:  if (parser.parseInteger(numResults))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  841:    return failure();
        -:  842:
    #####:  843:  IndexType type = parser.getBuilder().getIndexType();
call    0 never executed
    #####:  844:  for (unsigned i = 0; i < numResults; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:    result.addTypes(type);
call    0 never executed
    #####:  846:  return success();
        -:  847:}
        -:  848:
function _ZN4test21ParseIntegerLiteralOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  849:void ParseIntegerLiteralOp::print(OpAsmPrinter &p) {
    #####:  850:  if (unsigned numResults = getNumResults())
branch  0 never executed
branch  1 never executed
    #####:  851:    p << " : " << numResults;
call    0 never executed
call    1 never executed
    #####:  852:}
        -:  853:
function _ZN4test21ParseWrappedKeywordOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  854:ParseResult ParseWrappedKeywordOp::parse(OpAsmParser &parser,
        -:  855:                                         OperationState &result) {
    #####:  856:  StringRef keyword;
    #####:  857:  if (parser.parseKeyword(&keyword))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  858:    return failure();
    #####:  859:  result.addAttribute("keyword", parser.getBuilder().getStringAttr(keyword));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  860:  return success();
        -:  861:}
        -:  862:
function _ZN4test21ParseWrappedKeywordOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  863:void ParseWrappedKeywordOp::print(OpAsmPrinter &p) { p << " " << getKeyword(); }
call    0 never executed
call    1 never executed
call    2 never executed
        -:  864:
        -:  865://===----------------------------------------------------------------------===//
        -:  866:// Test WrapRegionOp - wrapping op exercising `parseGenericOperation()`.
        -:  867:
function _ZN4test16WrappingRegionOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  868:ParseResult WrappingRegionOp::parse(OpAsmParser &parser,
        -:  869:                                    OperationState &result) {
    #####:  870:  if (parser.parseKeyword("wraps"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  871:    return failure();
        -:  872:
        -:  873:  // Parse the wrapped op in a region
    #####:  874:  Region &body = *result.addRegion();
call    0 never executed
    #####:  875:  body.push_back(new Block);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  876:  Block &block = body.back();
call    0 never executed
    #####:  877:  Operation *wrappedOp = parser.parseGenericOperation(&block, block.begin());
call    0 never executed
    #####:  878:  if (!wrappedOp)
branch  0 never executed
branch  1 never executed
    #####:  879:    return failure();
        -:  880:
        -:  881:  // Create a return terminator in the inner region, pass as operand to the
        -:  882:  // terminator the returned values from the wrapped operation.
    #####:  883:  SmallVector<Value, 8> returnOperands(wrappedOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  884:  OpBuilder builder(parser.getContext());
call    0 never executed
call    1 never executed
    #####:  885:  builder.setInsertionPointToEnd(&block);
call    0 never executed
    #####:  886:  builder.create<TestReturnOp>(wrappedOp->getLoc(), returnOperands);
call    0 never executed
        -:  887:
        -:  888:  // Get the results type for the wrapping op from the terminator operands.
    #####:  889:  Operation &returnOp = body.back().back();
call    0 never executed
call    1 never executed
    #####:  890:  result.types.append(returnOp.operand_type_begin(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  891:                      returnOp.operand_type_end());
        -:  892:
        -:  893:  // Use the location of the wrapped op for the "test.wrapping_region" op.
    #####:  894:  result.location = wrappedOp->getLoc();
branch  0 never executed
branch  1 never executed
        -:  895:
    #####:  896:  return success();
branch  0 never executed
branch  1 never executed
        -:  897:}
        -:  898:
function _ZN4test16WrappingRegionOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  899:void WrappingRegionOp::print(OpAsmPrinter &p) {
    #####:  900:  p << " wraps ";
call    0 never executed
    #####:  901:  p.printGenericOp(&getRegion().front().front());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  902:}
        -:  903:
        -:  904://===----------------------------------------------------------------------===//
        -:  905:// Test PrettyPrintedRegionOp -  exercising the following parser APIs
        -:  906://   parseGenericOperationAfterOpName
        -:  907://   parseCustomOperationName
        -:  908://===----------------------------------------------------------------------===//
        -:  909:
function _ZN4test21PrettyPrintedRegionOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  910:ParseResult PrettyPrintedRegionOp::parse(OpAsmParser &parser,
        -:  911:                                         OperationState &result) {
        -:  912:
    #####:  913:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  914:  Location currLocation = parser.getEncodedSourceLoc(loc);
call    0 never executed
        -:  915:
        -:  916:  // Parse the operands.
    #####:  917:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operands;
call    0 never executed
    #####:  918:  if (parser.parseOperandList(operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  919:    return failure();
        -:  920:
        -:  921:  // Check if we are parsing the pretty-printed version
        -:  922:  //  test.pretty_printed_region start <inner-op> end : <functional-type>
        -:  923:  // Else fallback to parsing the "non pretty-printed" version.
    #####:  924:  if (!succeeded(parser.parseOptionalKeyword("start")))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  925:    return parser.parseGenericOperationAfterOpName(
    #####:  926:        result, llvm::makeArrayRef(operands));
call    0 never executed
        -:  927:
    #####:  928:  FailureOr<OperationName> parseOpNameInfo = parser.parseCustomOperationName();
call    0 never executed
    #####:  929:  if (failed(parseOpNameInfo))
branch  0 never executed
branch  1 never executed
    #####:  930:    return failure();
        -:  931:
    #####:  932:  StringAttr innerOpName = parseOpNameInfo->getIdentifier();
call    0 never executed
        -:  933:
    #####:  934:  FunctionType opFntype;
    #####:  935:  Optional<Location> explicitLoc;
    #####:  936:  if (parser.parseKeyword("end") || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  937:      parser.parseType(opFntype) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  938:      parser.parseOptionalLocationSpecifier(explicitLoc))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  939:    return failure();
        -:  940:
        -:  941:  // If location of the op is explicitly provided, then use it; Else use
        -:  942:  // the parser's current location.
    #####:  943:  Location opLoc = explicitLoc.value_or(currLocation);
branch  0 never executed
branch  1 never executed
        -:  944:
        -:  945:  // Derive the SSA-values for op's operands.
    #####:  946:  if (parser.resolveOperands(operands, opFntype.getInputs(), loc,
branch  0 never executed
branch  1 never executed
    #####:  947:                             result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  948:    return failure();
        -:  949:
        -:  950:  // Add a region for op.
    #####:  951:  Region &region = *result.addRegion();
call    0 never executed
        -:  952:
        -:  953:  // Create a basic-block inside op's region.
    #####:  954:  Block &block = region.emplaceBlock();
call    0 never executed
        -:  955:
        -:  956:  // Create and insert an "inner-op" operation in the block.
        -:  957:  // Just for testing purposes, we can assume that inner op is a binary op with
        -:  958:  // result and operand types all same as the test-op's first operand.
    #####:  959:  Type innerOpType = opFntype.getInput(0);
call    0 never executed
    #####:  960:  Value lhs = block.addArgument(innerOpType, opLoc);
call    0 never executed
    #####:  961:  Value rhs = block.addArgument(innerOpType, opLoc);
call    0 never executed
        -:  962:
    #####:  963:  OpBuilder builder(parser.getBuilder().getContext());
call    0 never executed
call    1 never executed
    #####:  964:  builder.setInsertionPointToStart(&block);
call    0 never executed
        -:  965:
    #####:  966:  Operation *innerOp =
    #####:  967:      builder.create(opLoc, innerOpName, /*operands=*/{lhs, rhs}, innerOpType);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  968:
        -:  969:  // Insert a return statement in the block returning the inner-op's result.
    #####:  970:  builder.create<TestReturnOp>(innerOp->getLoc(), innerOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  971:
        -:  972:  // Populate the op operation-state with result-type and location.
    #####:  973:  result.addTypes(opFntype.getResults());
call    0 never executed
call    1 never executed
    #####:  974:  result.location = innerOp->getLoc();
        -:  975:
    #####:  976:  return success();
        -:  977:}
        -:  978:
function _ZN4test21PrettyPrintedRegionOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  979:void PrettyPrintedRegionOp::print(OpAsmPrinter &p) {
    #####:  980:  p << ' ';
call    0 never executed
    #####:  981:  p.printOperands(getOperands());
call    0 never executed
call    1 never executed
        -:  982:
    #####:  983:  Operation &innerOp = getRegion().front().front();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  984:  // Assuming that region has a single non-terminator inner-op, if the inner-op
        -:  985:  // meets some criteria (which in this case is a simple one  based on the name
        -:  986:  // of inner-op), then we can print the entire region in a succinct way.
        -:  987:  // Here we assume that the prototype of "special.op" can be trivially derived
        -:  988:  // while parsing it back.
    #####:  989:  if (innerOp.getName().getStringRef().equals("special.op")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  990:    p << " start special.op end";
call    0 never executed
        -:  991:  } else {
    #####:  992:    p << " (";
call    0 never executed
    #####:  993:    p.printRegion(getRegion());
call    0 never executed
call    1 never executed
    #####:  994:    p << ")";
call    0 never executed
        -:  995:  }
        -:  996:
    #####:  997:  p << " : ";
call    0 never executed
    #####:  998:  p.printFunctionalType(*this);
call    0 never executed
    #####:  999:}
        -: 1000:
        -: 1001://===----------------------------------------------------------------------===//
        -: 1002:// Test PolyForOp - parse list of region arguments.
        -: 1003://===----------------------------------------------------------------------===//
        -: 1004:
function _ZN4test9PolyForOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1005:ParseResult PolyForOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 1006:  SmallVector<OpAsmParser::Argument, 4> ivsInfo;
call    0 never executed
        -: 1007:  // Parse list of region arguments without a delimiter.
    #####: 1008:  if (parser.parseArgumentList(ivsInfo, OpAsmParser::Delimiter::None))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1009:    return failure();
        -: 1010:
        -: 1011:  // Parse the body region.
    #####: 1012:  Region *body = result.addRegion();
call    0 never executed
    #####: 1013:  for (auto &iv : ivsInfo)
branch  0 never executed
branch  1 never executed
    #####: 1014:    iv.type = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 1015:  return parser.parseRegion(*body, ivsInfo);
call    0 never executed
        -: 1016:}
        -: 1017:
function _ZN4test9PolyForOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1018:void PolyForOp::print(OpAsmPrinter &p) { p.printGenericOp(*this); }
call    0 never executed
call    1 never executed
        -: 1019:
function _ZN4test9PolyForOp24getAsmBlockArgumentNamesERN4mlir6RegionEN4llvm12function_refIFvNS1_5ValueENS4_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1020:void PolyForOp::getAsmBlockArgumentNames(Region &region,
        -: 1021:                                         OpAsmSetValueNameFn setNameFn) {
    #####: 1022:  auto arrayAttr = getOperation()->getAttrOfType<ArrayAttr>("arg_names");
call    0 never executed
    #####: 1023:  if (!arrayAttr)
branch  0 never executed
branch  1 never executed
    #####: 1024:    return;
    #####: 1025:  auto args = getRegion().front().getArguments();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1026:  auto e = std::min(arrayAttr.size(), args.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1027:  for (unsigned i = 0; i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1028:    if (auto strAttr = arrayAttr[i].dyn_cast<StringAttr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1029:      setNameFn(args[i], strAttr.getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1030:  }
        -: 1031:}
        -: 1032:
        -: 1033://===----------------------------------------------------------------------===//
        -: 1034:// TestAttrWithLoc - parse/printOptionalLocationSpecifier
        -: 1035://===----------------------------------------------------------------------===//
        -: 1036:
function _ZL16parseOptionalLocRN4mlir11OpAsmParserERNS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1037:static ParseResult parseOptionalLoc(OpAsmParser &p, Attribute &loc) {
    #####: 1038:  Optional<Location> result;
    #####: 1039:  SMLoc sourceLoc = p.getCurrentLocation();
call    0 never executed
    #####: 1040:  if (p.parseOptionalLocationSpecifier(result))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1041:    return failure();
    #####: 1042:  if (result)
branch  0 never executed
branch  1 never executed
    #####: 1043:    loc = *result;
        -: 1044:  else
    #####: 1045:    loc = p.getEncodedSourceLoc(sourceLoc);
call    0 never executed
    #####: 1046:  return success();
        -: 1047:}
        -: 1048:
        -: 1049:static void printOptionalLoc(OpAsmPrinter &p, Operation *op, Attribute loc) {
        -: 1050:  p.printOptionalLocationSpecifier(loc.cast<LocationAttr>());
        -: 1051:}
        -: 1052:
        -: 1053://===----------------------------------------------------------------------===//
        -: 1054:// Test removing op with inner ops.
        -: 1055://===----------------------------------------------------------------------===//
        -: 1056:
        -: 1057:namespace {
        -: 1058:struct TestRemoveOpWithInnerOps
        -: 1059:    : public OpRewritePattern<TestOpWithRegionPattern> {
        -: 1060:  using OpRewritePattern<TestOpWithRegionPattern>::OpRewritePattern;
        -: 1061:
        -: 1062:  void initialize() { setDebugName("TestRemoveOpWithInnerOps"); }
        -: 1063:
function _ZNK12_GLOBAL__N_124TestRemoveOpWithInnerOps15matchAndRewriteEN4test23TestOpWithRegionPatternERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1064:  LogicalResult matchAndRewrite(TestOpWithRegionPattern op,
        -: 1065:                                PatternRewriter &rewriter) const override {
    #####: 1066:    rewriter.eraseOp(op);
call    0 never executed
    #####: 1067:    return success();
        -: 1068:  }
        -: 1069:};
        -: 1070:} // namespace
        -: 1071:
function _ZN4test23TestOpWithRegionPattern27getCanonicalizationPatternsERN4mlir17RewritePatternSetEPNS1_11MLIRContextE called 39 returned 100% blocks executed 100%
       39: 1072:void TestOpWithRegionPattern::getCanonicalizationPatterns(
        -: 1073:    RewritePatternSet &results, MLIRContext *context) {
       39: 1074:  results.add<TestRemoveOpWithInnerOps>(context);
call    0 returned 100%
       39: 1075:}
        -: 1076:
function _ZN4test20TestOpWithRegionFold4foldEN4llvm8ArrayRefIN4mlir9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1077:OpFoldResult TestOpWithRegionFold::fold(ArrayRef<Attribute> operands) {
    #####: 1078:  return getOperand();
call    0 never executed
call    1 never executed
        -: 1079:}
        -: 1080:
function _ZN4test14TestOpConstant4foldEN4llvm8ArrayRefIN4mlir9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1081:OpFoldResult TestOpConstant::fold(ArrayRef<Attribute> operands) {
    #####: 1082:  return getValue();
call    0 never executed
call    1 never executed
        -: 1083:}
        -: 1084:
function _ZN4test34TestOpWithVariadicResultsAndFolder4foldEN4llvm8ArrayRefIN4mlir9AttributeEEERNS1_15SmallVectorImplINS3_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1085:LogicalResult TestOpWithVariadicResultsAndFolder::fold(
        -: 1086:    ArrayRef<Attribute> operands, SmallVectorImpl<OpFoldResult> &results) {
    #####: 1087:  for (Value input : this->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1088:    results.push_back(input);
call    0 never executed
call    1 never executed
        -: 1089:  }
    #####: 1090:  return success();
        -: 1091:}
        -: 1092:
function _ZN4test17TestOpInPlaceFold4foldEN4llvm8ArrayRefIN4mlir9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1093:OpFoldResult TestOpInPlaceFold::fold(ArrayRef<Attribute> operands) {
    #####: 1094:  assert(operands.size() == 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1095:  if (operands.front()) {
branch  0 never executed
branch  1 never executed
    #####: 1096:    (*this)->setAttr("attr", operands.front());
call    0 never executed
    #####: 1097:    return getResult();
call    0 never executed
        -: 1098:  }
    #####: 1099:  return {};
        -: 1100:}
        -: 1101:
function _ZN4test19TestPassthroughFold4foldEN4llvm8ArrayRefIN4mlir9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1102:OpFoldResult TestPassthroughFold::fold(ArrayRef<Attribute> operands) {
    #####: 1103:  return getOperand();
call    0 never executed
call    1 never executed
        -: 1104:}
        -: 1105:
function _ZN4test26OpWithInferTypeInterfaceOp16inferReturnTypesEPN4mlir11MLIRContextEN4llvm8OptionalINS1_8LocationEEENS1_10ValueRangeENS1_14DictionaryAttrENS1_11RegionRangeERNS4_15SmallVectorImplINS1_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 1106:LogicalResult OpWithInferTypeInterfaceOp::inferReturnTypes(
        -: 1107:    MLIRContext *, Optional<Location> location, ValueRange operands,
        -: 1108:    DictionaryAttr attributes, RegionRange regions,
        -: 1109:    SmallVectorImpl<Type> &inferredReturnTypes) {
    #####: 1110:  if (operands[0].getType() != operands[1].getType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1111:    return emitOptionalError(location, "operand type mismatch ",
    #####: 1112:                             operands[0].getType(), " vs ",
call    0 never executed
call    1 never executed
    #####: 1113:                             operands[1].getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1114:  }
    #####: 1115:  inferredReturnTypes.assign({operands[0].getType()});
call    0 never executed
call    1 never executed
    #####: 1116:  return success();
        -: 1117:}
        -: 1118:
        -: 1119:// TODO: We should be able to only define either inferReturnType or
        -: 1120:// refineReturnType, currently only refineReturnType can be omitted.
function _ZN4test27OpWithRefineTypeInterfaceOp16inferReturnTypesEPN4mlir11MLIRContextEN4llvm8OptionalINS1_8LocationEEENS1_10ValueRangeENS1_14DictionaryAttrENS1_11RegionRangeERNS4_15SmallVectorImplINS1_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 1121:LogicalResult OpWithRefineTypeInterfaceOp::inferReturnTypes(
        -: 1122:    MLIRContext *context, Optional<Location> location, ValueRange operands,
        -: 1123:    DictionaryAttr attributes, RegionRange regions,
        -: 1124:    SmallVectorImpl<Type> &returnTypes) {
    #####: 1125:  returnTypes.clear();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1126:  return OpWithRefineTypeInterfaceOp::refineReturnTypes(
    #####: 1127:      context, location, operands, attributes, regions, returnTypes);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1128:}
        -: 1129:
function _ZN4test27OpWithRefineTypeInterfaceOp17refineReturnTypesEPN4mlir11MLIRContextEN4llvm8OptionalINS1_8LocationEEENS1_10ValueRangeENS1_14DictionaryAttrENS1_11RegionRangeERNS4_15SmallVectorImplINS1_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 1130:LogicalResult OpWithRefineTypeInterfaceOp::refineReturnTypes(
        -: 1131:    MLIRContext *, Optional<Location> location, ValueRange operands,
        -: 1132:    DictionaryAttr attributes, RegionRange regions,
        -: 1133:    SmallVectorImpl<Type> &returnTypes) {
    #####: 1134:  if (operands[0].getType() != operands[1].getType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1135:    return emitOptionalError(location, "operand type mismatch ",
    #####: 1136:                             operands[0].getType(), " vs ",
call    0 never executed
call    1 never executed
    #####: 1137:                             operands[1].getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1138:  }
        -: 1139:  // TODO: Add helper to make this more concise to write.
    #####: 1140:  if (returnTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 1141:    returnTypes.resize(1, nullptr);
call    0 never executed
    #####: 1142:  if (returnTypes[0] && returnTypes[0] != operands[0].getType())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1143:    return emitOptionalError(location,
    #####: 1144:                             "required first operand and result to match");
call    0 never executed
    #####: 1145:  returnTypes[0] = operands[0].getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1146:  return success();
        -: 1147:}
        -: 1148:
function _ZN4test36OpWithShapedTypeInferTypeInterfaceOp25inferReturnTypeComponentsEPN4mlir11MLIRContextEN4llvm8OptionalINS1_8LocationEEENS1_15ValueShapeRangeENS1_14DictionaryAttrENS1_11RegionRangeERNS4_15SmallVectorImplINS1_20ShapedTypeComponentsEEE called 0 returned 0% blocks executed 0%
    #####: 1149:LogicalResult OpWithShapedTypeInferTypeInterfaceOp::inferReturnTypeComponents(
        -: 1150:    MLIRContext *context, Optional<Location> location, ValueShapeRange operands,
        -: 1151:    DictionaryAttr attributes, RegionRange regions,
        -: 1152:    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
        -: 1153:  // Create return type consisting of the last element of the first operand.
    #####: 1154:  auto operandType = operands.front().getType();
call    0 never executed
call    1 never executed
    #####: 1155:  auto sval = operandType.dyn_cast<ShapedType>();
call    0 never executed
    #####: 1156:  if (!sval) {
branch  0 never executed
branch  1 never executed
    #####: 1157:    return emitOptionalError(location, "only shaped type operands allowed");
call    0 never executed
        -: 1158:  }
    #####: 1159:  int64_t dim =
    #####: 1160:      sval.hasRank() ? sval.getShape().front() : ShapedType::kDynamicSize;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1161:  auto type = IntegerType::get(context, 17);
call    0 never executed
    #####: 1162:  inferredReturnShapes.push_back(ShapedTypeComponents({dim}, type));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1163:  return success();
        -: 1164:}
        -: 1165:
function _ZN4test36OpWithShapedTypeInferTypeInterfaceOp21reifyReturnTypeShapesERN4mlir9OpBuilderENS1_10ValueRangeERN4llvm15SmallVectorImplINS1_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1166:LogicalResult OpWithShapedTypeInferTypeInterfaceOp::reifyReturnTypeShapes(
        -: 1167:    OpBuilder &builder, ValueRange operands,
        -: 1168:    llvm::SmallVectorImpl<Value> &shapes) {
    #####: 1169:  shapes = SmallVector<Value, 1>{
call    0 never executed
    #####: 1170:      builder.createOrFold<tensor::DimOp>(getLoc(), operands.front(), 0)};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1171:  return success();
        -: 1172:}
        -: 1173:
function _ZN4test28OpWithResultShapeInterfaceOp21reifyReturnTypeShapesERN4mlir9OpBuilderENS1_10ValueRangeERN4llvm15SmallVectorImplINS1_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1174:LogicalResult OpWithResultShapeInterfaceOp::reifyReturnTypeShapes(
        -: 1175:    OpBuilder &builder, ValueRange operands,
        -: 1176:    llvm::SmallVectorImpl<Value> &shapes) {
    #####: 1177:  Location loc = getLoc();
branch  0 never executed
branch  1 never executed
    #####: 1178:  shapes.reserve(operands.size());
branch  0 never executed
branch  1 never executed
    #####: 1179:  for (Value operand : llvm::reverse(operands)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1180:    auto rank = operand.getType().cast<RankedTensorType>().getRank();
call    0 never executed
call    1 never executed
    #####: 1181:    auto currShape = llvm::to_vector<4>(
    #####: 1182:        llvm::map_range(llvm::seq<int64_t>(0, rank), [&](int64_t dim) -> Value {
call    0 never executed
    #####: 1183:          return builder.createOrFold<tensor::DimOp>(loc, operand, dim);
call    0 never executed
    #####: 1184:        }));
call    0 never executed
call    1 never executed
    #####: 1185:    shapes.push_back(builder.create<tensor::FromElementsOp>(
call    0 never executed
    #####: 1186:        getLoc(), RankedTensorType::get({rank}, builder.getIndexType()),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1187:        currShape));
call    0 never executed
call    1 never executed
        -: 1188:  }
    #####: 1189:  return success();
        -: 1190:}
        -: 1191:
function _ZN4test34OpWithResultShapePerDimInterfaceOp17reifyResultShapesERN4mlir9OpBuilderERN4llvm11SmallVectorINS5_INS1_5ValueELj6EEELj1EEE called 0 returned 0% blocks executed 0%
    #####: 1192:LogicalResult OpWithResultShapePerDimInterfaceOp::reifyResultShapes(
        -: 1193:    OpBuilder &builder, ReifiedRankedShapedTypeDims &shapes) {
    #####: 1194:  Location loc = getLoc();
call    0 never executed
    #####: 1195:  shapes.reserve(getNumOperands());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1196:  for (Value operand : llvm::reverse(getOperands())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1197:    auto currShape = llvm::to_vector<4>(llvm::map_range(
        -: 1198:        llvm::seq<int64_t>(
    #####: 1199:            0, operand.getType().cast<RankedTensorType>().getRank()),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1200:        [&](int64_t dim) -> Value {
    #####: 1201:          return builder.createOrFold<tensor::DimOp>(loc, operand, dim);
call    0 never executed
    #####: 1202:        }));
call    0 never executed
    #####: 1203:    shapes.emplace_back(std::move(currShape));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1204:  }
    #####: 1205:  return success();
        -: 1206:}
        -: 1207:
        -: 1208://===----------------------------------------------------------------------===//
        -: 1209:// Test SideEffect interfaces
        -: 1210://===----------------------------------------------------------------------===//
        -: 1211:
        -: 1212:namespace {
        -: 1213:/// A test resource for side effects.
    #####: 1214:struct TestResource : public SideEffects::Resource::Base<TestResource> {
call    0 never executed
call    1 never executed
function _ZN12_GLOBAL__N_112TestResource13resolveTypeIDEv called 0 returned 0% blocks executed 0%
    #####: 1215:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestResource)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1216:
function _ZN12_GLOBAL__N_112TestResource7getNameEv called 0 returned 0% blocks executed 0%
    #####: 1217:  StringRef getName() final { return "<Test>"; }
        -: 1218:};
        -: 1219:} // namespace
        -: 1220:
function _ZL25testSideEffectOpGetEffectPN4mlir9OperationERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_11TestEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####: 1221:static void testSideEffectOpGetEffect(
        -: 1222:    Operation *op,
        -: 1223:    SmallVectorImpl<SideEffects::EffectInstance<TestEffects::Effect>>
        -: 1224:        &effects) {
    #####: 1225:  auto effectsAttr = op->getAttrOfType<AffineMapAttr>("effect_parameter");
call    0 never executed
    #####: 1226:  if (!effectsAttr)
branch  0 never executed
branch  1 never executed
    #####: 1227:    return;
        -: 1228:
    #####: 1229:  effects.emplace_back(TestEffects::Concrete::get(), effectsAttr);
call    0 never executed
call    1 never executed
        -: 1230:}
        -: 1231:
function _ZN4test12SideEffectOp10getEffectsERN4llvm15SmallVectorImplIN4mlir11SideEffects14EffectInstanceINS3_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####: 1232:void SideEffectOp::getEffects(
        -: 1233:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
        -: 1234:  // Check for an effects attribute on the op instance.
    #####: 1235:  ArrayAttr effectsAttr = (*this)->getAttrOfType<ArrayAttr>("effects");
call    0 never executed
    #####: 1236:  if (!effectsAttr)
branch  0 never executed
branch  1 never executed
    #####: 1237:    return;
        -: 1238:
        -: 1239:  // If there is one, it is an array of dictionary attributes that hold
        -: 1240:  // information on the effects of this operation.
    #####: 1241:  for (Attribute element : effectsAttr) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1242:    DictionaryAttr effectElement = element.cast<DictionaryAttr>();
call    0 never executed
        -: 1243:
        -: 1244:    // Get the specific memory effect.
    #####: 1245:    MemoryEffects::Effect *effect =
call    0 never executed
    #####: 1246:        StringSwitch<MemoryEffects::Effect *>(
call    0 never executed
    #####: 1247:            effectElement.get("effect").cast<StringAttr>().getValue())
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1248:            .Case("allocate", MemoryEffects::Allocate::get())
call    0 never executed
    #####: 1249:            .Case("free", MemoryEffects::Free::get())
call    0 never executed
    #####: 1250:            .Case("read", MemoryEffects::Read::get())
call    0 never executed
    #####: 1251:            .Case("write", MemoryEffects::Write::get());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1252:
        -: 1253:    // Check for a non-default resource to use.
    #####: 1254:    SideEffects::Resource *resource = SideEffects::DefaultResource::get();
call    0 never executed
    #####: 1255:    if (effectElement.get("test_resource"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1256:      resource = TestResource::get();
call    0 never executed
        -: 1257:
        -: 1258:    // Check for a result to affect.
    #####: 1259:    if (effectElement.get("on_result"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1260:      effects.emplace_back(effect, getResult(), resource);
call    0 never executed
call    1 never executed
    #####: 1261:    else if (Attribute ref = effectElement.get("on_reference"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1262:      effects.emplace_back(effect, ref.cast<SymbolRefAttr>(), resource);
call    0 never executed
call    1 never executed
        -: 1263:    else
    #####: 1264:      effects.emplace_back(effect, resource);
call    0 never executed
        -: 1265:  }
        -: 1266:}
        -: 1267:
function _ZN4test12SideEffectOp10getEffectsERN4llvm15SmallVectorImplIN4mlir11SideEffects14EffectInstanceINS3_11TestEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####: 1268:void SideEffectOp::getEffects(
        -: 1269:    SmallVectorImpl<TestEffects::EffectInstance> &effects) {
    #####: 1270:  testSideEffectOpGetEffect(getOperation(), effects);
call    0 never executed
call    1 never executed
    #####: 1271:}
        -: 1272:
        -: 1273://===----------------------------------------------------------------------===//
        -: 1274:// StringAttrPrettyNameOp
        -: 1275://===----------------------------------------------------------------------===//
        -: 1276:
        -: 1277:// This op has fancy handling of its SSA result name.
function _ZN4test22StringAttrPrettyNameOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1278:ParseResult StringAttrPrettyNameOp::parse(OpAsmParser &parser,
        -: 1279:                                          OperationState &result) {
        -: 1280:  // Add the result types.
    #####: 1281:  for (size_t i = 0, e = parser.getNumResults(); i != e; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1282:    result.addTypes(parser.getBuilder().getIntegerType(32));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1283:
    #####: 1284:  if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1285:    return failure();
        -: 1286:
        -: 1287:  // If the attribute dictionary contains no 'names' attribute, infer it from
        -: 1288:  // the SSA name (if specified).
function _ZZN4test22StringAttrPrettyNameOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateEENKUlNS1_14NamedAttributeEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1289:  bool hadNames = llvm::any_of(result.attributes, [](NamedAttribute attr) {
call    0 never executed
    #####: 1290:    return attr.getName() == "names";
call    0 never executed
call    1 never executed
        -: 1291:  });
        -: 1292:
        -: 1293:  // If there was no name specified, check to see if there was a useful name
        -: 1294:  // specified in the asm file.
    #####: 1295:  if (hadNames || parser.getNumResults() == 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1296:    return success();
        -: 1297:
    #####: 1298:  SmallVector<StringRef, 4> names;
call    0 never executed
    #####: 1299:  auto *context = result.getContext();
call    0 never executed
        -: 1300:
    #####: 1301:  for (size_t i = 0, e = parser.getNumResults(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1302:    auto resultName = parser.getResultName(i);
call    0 never executed
    #####: 1303:    StringRef nameStr;
    #####: 1304:    if (!resultName.first.empty() && !isdigit(resultName.first[0]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1305:      nameStr = resultName.first;
        -: 1306:
    #####: 1307:    names.push_back(nameStr);
call    0 never executed
        -: 1308:  }
        -: 1309:
    #####: 1310:  auto namesAttr = parser.getBuilder().getStrArrayAttr(names);
call    0 never executed
call    1 never executed
    #####: 1311:  result.attributes.push_back({StringAttr::get(context, "names"), namesAttr});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1312:  return success();
branch  0 never executed
branch  1 never executed
        -: 1313:}
        -: 1314:
function _ZN4test22StringAttrPrettyNameOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1315:void StringAttrPrettyNameOp::print(OpAsmPrinter &p) {
        -: 1316:  // Note that we only need to print the "name" attribute if the asmprinter
        -: 1317:  // result name disagrees with it.  This can happen in strange cases, e.g.
        -: 1318:  // when there are conflicts.
    #####: 1319:  bool namesDisagree = getNames().size() != getNumResults();
call    0 never executed
call    1 never executed
        -: 1320:
    #####: 1321:  SmallString<32> resultNameStr;
    #####: 1322:  for (size_t i = 0, e = getNumResults(); i != e && !namesDisagree; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1323:    resultNameStr.clear();
call    0 never executed
    #####: 1324:    llvm::raw_svector_ostream tmpStream(resultNameStr);
call    0 never executed
    #####: 1325:    p.printOperand(getResult(i), tmpStream);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1326:
    #####: 1327:    auto expectedName = getNames()[i].dyn_cast<StringAttr>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1328:    if (!expectedName ||
branch  0 never executed
branch  1 never executed
    #####: 1329:        tmpStream.str().drop_front() != expectedName.getValue()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1330:      namesDisagree = true;
        -: 1331:    }
        -: 1332:  }
        -: 1333:
    #####: 1334:  if (namesDisagree)
branch  0 never executed
branch  1 never executed
    #####: 1335:    p.printOptionalAttrDictWithKeyword((*this)->getAttrs());
call    0 never executed
call    1 never executed
        -: 1336:  else
    #####: 1337:    p.printOptionalAttrDictWithKeyword((*this)->getAttrs(), {"names"});
call    0 never executed
call    1 never executed
    #####: 1338:}
        -: 1339:
        -: 1340:// We set the SSA name in the asm syntax to the contents of the name
        -: 1341:// attribute.
function _ZN4test22StringAttrPrettyNameOp17getAsmResultNamesEN4llvm12function_refIFvN4mlir5ValueENS1_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1342:void StringAttrPrettyNameOp::getAsmResultNames(
        -: 1343:    function_ref<void(Value, StringRef)> setNameFn) {
        -: 1344:
    #####: 1345:  auto value = getNames();
call    0 never executed
    #####: 1346:  for (size_t i = 0, e = value.size(); i != e; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1347:    if (auto str = value[i].dyn_cast<StringAttr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1348:      if (!str.getValue().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1349:        setNameFn(getResult(i), str.getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1350:}
        -: 1351:
function _ZN4test19CustomResultsNameOp17getAsmResultNamesEN4llvm12function_refIFvN4mlir5ValueENS1_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 1352:void CustomResultsNameOp::getAsmResultNames(
        -: 1353:    function_ref<void(Value, StringRef)> setNameFn) {
    #####: 1354:  ArrayAttr value = getNames();
call    0 never executed
    #####: 1355:  for (size_t i = 0, e = value.size(); i != e; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1356:    if (auto str = value[i].dyn_cast<StringAttr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1357:      if (!str.getValue().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1358:        setNameFn(getResult(i), str.getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1359:}
        -: 1360:
        -: 1361://===----------------------------------------------------------------------===//
        -: 1362:// ResultTypeWithTraitOp
        -: 1363://===----------------------------------------------------------------------===//
        -: 1364:
function _ZN4test21ResultTypeWithTraitOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1365:LogicalResult ResultTypeWithTraitOp::verify() {
    #####: 1366:  if ((*this)->getResultTypes()[0].hasTrait<TypeTrait::TestTypeTrait>())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1367:    return success();
    #####: 1368:  return emitError("result type should have trait 'TestTypeTrait'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1369:}
        -: 1370:
        -: 1371://===----------------------------------------------------------------------===//
        -: 1372:// AttrWithTraitOp
        -: 1373://===----------------------------------------------------------------------===//
        -: 1374:
function _ZN4test15AttrWithTraitOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1375:LogicalResult AttrWithTraitOp::verify() {
    #####: 1376:  if (getAttr().hasTrait<AttributeTrait::TestAttrTrait>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1377:    return success();
    #####: 1378:  return emitError("'attr' attribute should have trait 'TestAttrTrait'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1379:}
        -: 1380:
        -: 1381://===----------------------------------------------------------------------===//
        -: 1382:// RegionIfOp
        -: 1383://===----------------------------------------------------------------------===//
        -: 1384:
function _ZN4test10RegionIfOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1385:void RegionIfOp::print(OpAsmPrinter &p) {
    #####: 1386:  p << " ";
call    0 never executed
    #####: 1387:  p.printOperands(getOperands());
call    0 never executed
call    1 never executed
    #####: 1388:  p << ": " << getOperandTypes();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1389:  p.printArrowTypeList(getResultTypes());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1390:  p << " then ";
call    0 never executed
    #####: 1391:  p.printRegion(getThenRegion(),
call    0 never executed
        -: 1392:                /*printEntryBlockArgs=*/true,
    #####: 1393:                /*printBlockTerminators=*/true);
call    0 never executed
    #####: 1394:  p << " else ";
call    0 never executed
    #####: 1395:  p.printRegion(getElseRegion(),
call    0 never executed
        -: 1396:                /*printEntryBlockArgs=*/true,
    #####: 1397:                /*printBlockTerminators=*/true);
call    0 never executed
    #####: 1398:  p << " join ";
call    0 never executed
    #####: 1399:  p.printRegion(getJoinRegion(),
call    0 never executed
        -: 1400:                /*printEntryBlockArgs=*/true,
    #####: 1401:                /*printBlockTerminators=*/true);
call    0 never executed
    #####: 1402:}
        -: 1403:
function _ZN4test10RegionIfOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1404:ParseResult RegionIfOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 1405:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandInfos;
branch  0 never executed
branch  1 never executed
    #####: 1406:  SmallVector<Type, 2> operandTypes;
branch  0 never executed
branch  1 never executed
        -: 1407:
    #####: 1408:  result.regions.reserve(3);
branch  0 never executed
branch  1 never executed
    #####: 1409:  Region *thenRegion = result.addRegion();
call    0 never executed
    #####: 1410:  Region *elseRegion = result.addRegion();
call    0 never executed
    #####: 1411:  Region *joinRegion = result.addRegion();
call    0 never executed
        -: 1412:
        -: 1413:  // Parse operand, type and arrow type lists.
    #####: 1414:  if (parser.parseOperandList(operandInfos) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1415:      parser.parseColonTypeList(operandTypes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1416:      parser.parseArrowTypeList(result.types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1417:    return failure();
        -: 1418:
        -: 1419:  // Parse all attached regions.
    #####: 1420:  if (parser.parseKeyword("then") || parser.parseRegion(*thenRegion, {}, {}) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1421:      parser.parseKeyword("else") || parser.parseRegion(*elseRegion, {}, {}) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1422:      parser.parseKeyword("join") || parser.parseRegion(*joinRegion, {}, {}))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1423:    return failure();
        -: 1424:
    #####: 1425:  return parser.resolveOperands(operandInfos, operandTypes,
    #####: 1426:                                parser.getCurrentLocation(), result.operands);
call    0 never executed
call    1 never executed
        -: 1427:}
        -: 1428:
function _ZN4test10RegionIfOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 0 returned 0% blocks executed 0%
    #####: 1429:OperandRange RegionIfOp::getSuccessorEntryOperands(Optional<unsigned> index) {
    #####: 1430:  assert(index && *index < 2 && "invalid region index");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1431:  return getOperands();
call    0 never executed
        -: 1432:}
        -: 1433:
function _ZN4test10RegionIfOp19getSuccessorRegionsEN4llvm8OptionalIjEENS1_8ArrayRefIN4mlir9AttributeEEERNS1_15SmallVectorImplINS5_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####: 1434:void RegionIfOp::getSuccessorRegions(
        -: 1435:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -: 1436:    SmallVectorImpl<RegionSuccessor> &regions) {
        -: 1437:  // We always branch to the join region.
    #####: 1438:  if (index.has_value()) {
branch  0 never executed
branch  1 never executed
    #####: 1439:    if (index.value() < 2)
branch  0 never executed
branch  1 never executed
    #####: 1440:      regions.push_back(RegionSuccessor(&getJoinRegion(), getJoinArgs()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1441:    else
    #####: 1442:      regions.push_back(RegionSuccessor(getResults()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1443:    return;
        -: 1444:  }
        -: 1445:
        -: 1446:  // The then and else regions are the entry regions of this op.
    #####: 1447:  regions.push_back(RegionSuccessor(&getThenRegion(), getThenArgs()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1448:  regions.push_back(RegionSuccessor(&getElseRegion(), getElseArgs()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1449:}
        -: 1450:
function _ZN4test10RegionIfOp25getRegionInvocationBoundsEN4llvm8ArrayRefIN4mlir9AttributeEEERNS1_15SmallVectorImplINS3_16InvocationBoundsEEE called 0 returned 0% blocks executed 0%
    #####: 1451:void RegionIfOp::getRegionInvocationBounds(
        -: 1452:    ArrayRef<Attribute> operands,
        -: 1453:    SmallVectorImpl<InvocationBounds> &invocationBounds) {
        -: 1454:  // Each region is invoked at most once.
    #####: 1455:  invocationBounds.assign(/*NumElts=*/3, /*Elt=*/{0, 1});
call    0 never executed
call    1 never executed
    #####: 1456:}
        -: 1457:
        -: 1458://===----------------------------------------------------------------------===//
        -: 1459:// AnyCondOp
        -: 1460://===----------------------------------------------------------------------===//
        -: 1461:
function _ZN4test9AnyCondOp19getSuccessorRegionsEN4llvm8OptionalIjEENS1_8ArrayRefIN4mlir9AttributeEEERNS1_15SmallVectorImplINS5_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####: 1462:void AnyCondOp::getSuccessorRegions(Optional<unsigned> index,
        -: 1463:                                    ArrayRef<Attribute> operands,
        -: 1464:                                    SmallVectorImpl<RegionSuccessor> &regions) {
        -: 1465:  // The parent op branches into the only region, and the region branches back
        -: 1466:  // to the parent op.
    #####: 1467:  if (!index)
branch  0 never executed
branch  1 never executed
    #####: 1468:    regions.emplace_back(&getRegion());
call    0 never executed
call    1 never executed
        -: 1469:  else
    #####: 1470:    regions.emplace_back(getResults());
call    0 never executed
call    1 never executed
    #####: 1471:}
        -: 1472:
function _ZN4test9AnyCondOp25getRegionInvocationBoundsEN4llvm8ArrayRefIN4mlir9AttributeEEERNS1_15SmallVectorImplINS3_16InvocationBoundsEEE called 0 returned 0% blocks executed 0%
    #####: 1473:void AnyCondOp::getRegionInvocationBounds(
        -: 1474:    ArrayRef<Attribute> operands,
        -: 1475:    SmallVectorImpl<InvocationBounds> &invocationBounds) {
    #####: 1476:  invocationBounds.emplace_back(1, 1);
call    0 never executed
call    1 never executed
    #####: 1477:}
        -: 1478:
        -: 1479://===----------------------------------------------------------------------===//
        -: 1480:// SingleNoTerminatorCustomAsmOp
        -: 1481://===----------------------------------------------------------------------===//
        -: 1482:
function _ZN4test29SingleNoTerminatorCustomAsmOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1483:ParseResult SingleNoTerminatorCustomAsmOp::parse(OpAsmParser &parser,
        -: 1484:                                                 OperationState &state) {
    #####: 1485:  Region *body = state.addRegion();
call    0 never executed
    #####: 1486:  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1487:    return failure();
    #####: 1488:  return success();
        -: 1489:}
        -: 1490:
function _ZN4test29SingleNoTerminatorCustomAsmOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1491:void SingleNoTerminatorCustomAsmOp::print(OpAsmPrinter &printer) {
    #####: 1492:  printer.printRegion(
call    0 never executed
        -: 1493:      getRegion(), /*printEntryBlockArgs=*/false,
        -: 1494:      // This op has a single block without terminators. But explicitly mark
        -: 1495:      // as not printing block terminators for testing.
    #####: 1496:      /*printBlockTerminators=*/false);
call    0 never executed
    #####: 1497:}
        -: 1498:
        -: 1499://===----------------------------------------------------------------------===//
        -: 1500:// TestVerifiersOp
        -: 1501://===----------------------------------------------------------------------===//
        -: 1502:
function _ZN4test15TestVerifiersOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1503:LogicalResult TestVerifiersOp::verify() {
    #####: 1504:  if (!getRegion().hasOneBlock())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1505:    return emitOpError("`hasOneBlock` trait hasn't been verified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1506:
    #####: 1507:  Operation *definingOp = getInput().getDefiningOp();
call    0 never executed
call    1 never executed
    #####: 1508:  if (definingOp && failed(mlir::verify(definingOp)))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1509:    return emitOpError("operand hasn't been verified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1510:
    #####: 1511:  emitRemark("success run of verifier");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1512:
    #####: 1513:  return success();
        -: 1514:}
        -: 1515:
function _ZN4test15TestVerifiersOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 1516:LogicalResult TestVerifiersOp::verifyRegions() {
    #####: 1517:  if (!getRegion().hasOneBlock())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1518:    return emitOpError("`hasOneBlock` trait hasn't been verified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1519:
    #####: 1520:  for (Block &block : getRegion())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1521:    for (Operation &op : block)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1522:      if (failed(mlir::verify(&op)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1523:        return emitOpError("nested op hasn't been verified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1524:
    #####: 1525:  emitRemark("success run of region verifier");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1526:
    #####: 1527:  return success();
        -: 1528:}
        -: 1529:
        -: 1530://===----------------------------------------------------------------------===//
        -: 1531:// Test InferIntRangeInterface
        -: 1532://===----------------------------------------------------------------------===//
        -: 1533:
function _ZN4test16TestWithBoundsOp17inferResultRangesEN4llvm8ArrayRefIN4mlir17ConstantIntRangesEEENS1_12function_refIFvNS3_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1534:void TestWithBoundsOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -: 1535:                                         SetIntRangeFn setResultRanges) {
    #####: 1536:  setResultRanges(getResult(), {getUmin(), getUmax(), getSmin(), getSmax()});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1537:}
        -: 1538:
function _ZN4test22TestWithBoundsRegionOp5parseERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1539:ParseResult TestWithBoundsRegionOp::parse(OpAsmParser &parser,
        -: 1540:                                          OperationState &result) {
    #####: 1541:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1542:    return failure();
        -: 1543:
        -: 1544:  // Parse the input argument
    #####: 1545:  OpAsmParser::Argument argInfo;
call    0 never executed
    #####: 1546:  argInfo.type = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 1547:  if (failed(parser.parseArgument(argInfo)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1548:    return failure();
        -: 1549:
        -: 1550:  // Parse the body region, and reuse the operand info as the argument info.
    #####: 1551:  Region *body = result.addRegion();
call    0 never executed
    #####: 1552:  return parser.parseRegion(*body, argInfo, /*enableNameShadowing=*/false);
call    0 never executed
        -: 1553:}
        -: 1554:
function _ZN4test22TestWithBoundsRegionOp5printERN4mlir12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1555:void TestWithBoundsRegionOp::print(OpAsmPrinter &p) {
    #####: 1556:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 1557:  p << ' ';
call    0 never executed
    #####: 1558:  p.printRegionArgument(getRegion().getArgument(0), /*argAttrs=*/{},
call    0 never executed
call    1 never executed
    #####: 1559:                        /*omitType=*/true);
call    0 never executed
    #####: 1560:  p << ' ';
call    0 never executed
    #####: 1561:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false);
call    0 never executed
call    1 never executed
    #####: 1562:}
        -: 1563:
function _ZN4test22TestWithBoundsRegionOp17inferResultRangesEN4llvm8ArrayRefIN4mlir17ConstantIntRangesEEENS1_12function_refIFvNS3_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1564:void TestWithBoundsRegionOp::inferResultRanges(
        -: 1565:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRanges) {
    #####: 1566:  Value arg = getRegion().getArgument(0);
call    0 never executed
call    1 never executed
    #####: 1567:  setResultRanges(arg, {getUmin(), getUmax(), getSmin(), getSmax()});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1568:}
        -: 1569:
function _ZN4test15TestIncrementOp17inferResultRangesEN4llvm8ArrayRefIN4mlir17ConstantIntRangesEEENS1_12function_refIFvNS3_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1570:void TestIncrementOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -: 1571:                                        SetIntRangeFn setResultRanges) {
    #####: 1572:  const ConstantIntRanges &range = argRanges[0];
branch  0 never executed
branch  1 never executed
    #####: 1573:  APInt one(range.umin().getBitWidth(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1574:  setResultRanges(getResult(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1575:                  {range.umin().uadd_sat(one), range.umax().uadd_sat(one),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1576:                   range.smin().sadd_sat(one), range.smax().sadd_sat(one)});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1577:}
        -: 1578:
function _ZN4test19TestReflectBoundsOp17inferResultRangesEN4llvm8ArrayRefIN4mlir17ConstantIntRangesEEENS1_12function_refIFvNS3_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1579:void TestReflectBoundsOp::inferResultRanges(
        -: 1580:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRanges) {
    #####: 1581:  const ConstantIntRanges &range = argRanges[0];
branch  0 never executed
branch  1 never executed
    #####: 1582:  MLIRContext *ctx = getContext();
call    0 never executed
    #####: 1583:  Builder b(ctx);
call    0 never executed
    #####: 1584:  setUminAttr(b.getIndexAttr(range.umin().getZExtValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1585:  setUmaxAttr(b.getIndexAttr(range.umax().getZExtValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1586:  setSminAttr(b.getIndexAttr(range.smin().getSExtValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1587:  setSmaxAttr(b.getIndexAttr(range.smax().getSExtValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1588:  setResultRanges(getResult(), range);
call    0 never executed
call    1 never executed
    #####: 1589:}
        -: 1590:
        -: 1591:#include "TestOpEnums.cpp.inc"
        -: 1592:#include "TestOpInterfaces.cpp.inc"
        -: 1593:#include "TestTypeInterfaces.cpp.inc"
        -: 1594:
        -: 1595:#define GET_OP_CLASSES
        -: 1596:#include "TestOps.cpp.inc"
