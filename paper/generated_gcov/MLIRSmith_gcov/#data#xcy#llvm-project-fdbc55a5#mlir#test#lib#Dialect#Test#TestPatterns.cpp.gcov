        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/test/lib/Dialect/Test/TestPatterns.cpp
        -:    0:Graph:../tools/mlir/test/lib/Dialect/Test/CMakeFiles/MLIRTestDialect.dir/TestPatterns.cpp.gcno
        -:    0:Data:../tools/mlir/test/lib/Dialect/Test/CMakeFiles/MLIRTestDialect.dir/TestPatterns.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- TestPatterns.cpp - Test dialect pattern driver ---------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "TestDialect.h"
        -:   10:#include "TestTypes.h"
        -:   11:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   12:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   13:#include "mlir/Dialect/Func/Transforms/FuncConversions.h"
        -:   14:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   15:#include "mlir/IR/Matchers.h"
        -:   16:#include "mlir/Pass/Pass.h"
        -:   17:#include "mlir/Transforms/DialectConversion.h"
        -:   18:#include "mlir/Transforms/FoldUtils.h"
        -:   19:#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
        -:   20:
        -:   21:using namespace mlir;
        -:   22:using namespace test;
        -:   23:
        -:   24:// Native function for testing NativeCodeCall
    #####:   25:static Value chooseOperand(Value input1, Value input2, BoolAttr choice) {
    #####:   26:  return choice.getValue() ? input1 : input2;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   27:}
        -:   28:
    #####:   29:static void createOpI(PatternRewriter &rewriter, Location loc, Value input) {
    #####:   30:  rewriter.create<OpI>(loc, input);
call    0 never executed
        -:   31:}
        -:   32:
function _ZL16handleNoResultOpRN4mlir15PatternRewriterEN4test23OpSymbolBindingNoResultE called 0 returned 0% blocks executed 0%
    #####:   33:static void handleNoResultOp(PatternRewriter &rewriter,
        -:   34:                             OpSymbolBindingNoResult op) {
        -:   35:  // Turn the no result op to a one-result op.
    #####:   36:  rewriter.create<OpSymbolBindingB>(op.getLoc(), op.getOperand().getType(),
call    0 never executed
call    1 never executed
    #####:   37:                                    op.getOperand());
call    0 never executed
call    1 never executed
    #####:   38:}
        -:   39:
    #####:   40:static bool getFirstI32Result(Operation *op, Value &value) {
    #####:   41:  if (!Type(op->getResult(0).getType()).isSignlessInteger(32))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   42:    return false;
    #####:   43:  value = op->getResult(0);
    #####:   44:  return true;
        -:   45:}
        -:   46:
    #####:   47:static Value bindNativeCodeCallResult(Value value) { return value; }
call    0 never executed
        -:   48:
    #####:   49:static SmallVector<Value, 2> bindMultipleNativeCodeCallResult(Value input1,
        -:   50:                                                              Value input2) {
    #####:   51:  return SmallVector<Value, 2>({input2, input1});
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:}
        -:   53:
        -:   54:// Test that natives calls are only called once during rewrites.
        -:   55:// OpM_Test will return Pi, increased by 1 for each subsequent calls.
        -:   56:// This let us check the number of times OpM_Test was called by inspecting
        -:   57:// the returned value in the MLIR output.
        -:   58:static int64_t opMIncreasingValue = 314159265;
        -:   59:static Attribute opMTest(PatternRewriter &rewriter, Value val) {
        -:   60:  int64_t i = opMIncreasingValue++;
        -:   61:  return rewriter.getIntegerAttr(rewriter.getIntegerType(32), i);
        -:   62:}
        -:   63:
        -:   64:namespace {
        -:   65:#include "TestPatterns.inc"
        -:   66:} // namespace
        -:   67:
        -:   68://===----------------------------------------------------------------------===//
        -:   69:// Test Reduce Pattern Interface
        -:   70://===----------------------------------------------------------------------===//
        -:   71:
function _ZN4test29populateTestReductionPatternsERN4mlir17RewritePatternSetE called 0 returned 0% blocks executed 0%
    #####:   72:void test::populateTestReductionPatterns(RewritePatternSet &patterns) {
    #####:   73:  populateWithGenerated(patterns);
call    0 never executed
    #####:   74:}
        -:   75:
        -:   76://===----------------------------------------------------------------------===//
        -:   77:// Canonicalizer Driver.
        -:   78://===----------------------------------------------------------------------===//
        -:   79:
        -:   80:namespace {
        -:   81:struct FoldingPattern : public RewritePattern {
        -:   82:public:
function _ZN12_GLOBAL__N_114FoldingPatternC2EPN4mlir11MLIRContextE called 409 returned 100% blocks executed 100%
      409:   83:  FoldingPattern(MLIRContext *context)
      409:   84:      : RewritePattern(TestOpInPlaceFoldAnchor::getOperationName(),
call    0 returned 100%
      409:   85:                       /*benefit=*/1, context) {}
call    0 returned 100%
        -:   86:
function _ZNK12_GLOBAL__N_114FoldingPattern15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   87:  LogicalResult matchAndRewrite(Operation *op,
        -:   88:                                PatternRewriter &rewriter) const override {
        -:   89:    // Exercise OperationFolder API for a single-result operation that is folded
        -:   90:    // upon construction. The operation being created through the folder has an
        -:   91:    // in-place folder, and it should be still present in the output.
        -:   92:    // Furthermore, the folder should not crash when attempting to recover the
        -:   93:    // (unchanged) operation result.
    #####:   94:    OperationFolder folder(op->getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   95:    Value result = folder.create<TestOpInPlaceFold>(
    #####:   96:        rewriter, op->getLoc(), rewriter.getIntegerType(32), op->getOperand(0),
call    0 never executed
    #####:   97:        rewriter.getI32IntegerAttr(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   98:    assert(result);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   99:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  100:    return success();
call    0 never executed
        -:  101:  }
        -:  102:};
        -:  103:
        -:  104:/// This pattern creates a foldable operation at the entry point of the block.
        -:  105:/// This tests the situation where the operation folder will need to replace an
        -:  106:/// operation with a previously created constant that does not initially
        -:  107:/// dominate the operation to replace.
        -:  108:struct FolderInsertBeforePreviouslyFoldedConstantPattern
        -:  109:    : public OpRewritePattern<TestCastOp> {
        -:  110:public:
        -:  111:  using OpRewritePattern<TestCastOp>::OpRewritePattern;
        -:  112:
function _ZNK12_GLOBAL__N_149FolderInsertBeforePreviouslyFoldedConstantPattern15matchAndRewriteEN4test10TestCastOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  113:  LogicalResult matchAndRewrite(TestCastOp op,
        -:  114:                                PatternRewriter &rewriter) const override {
    #####:  115:    if (!op->hasAttr("test_fold_before_previously_folded_op"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  116:      return failure();
    #####:  117:    rewriter.setInsertionPointToStart(op->getBlock());
call    0 never executed
        -:  118:
    #####:  119:    auto constOp = rewriter.create<arith::ConstantOp>(
    #####:  120:        op.getLoc(), rewriter.getBoolAttr(true));
call    0 never executed
call    1 never executed
    #####:  121:    rewriter.replaceOpWithNewOp<TestCastOp>(op, rewriter.getI32Type(),
    #####:  122:                                            Value(constOp));
call    0 never executed
call    1 never executed
    #####:  123:    return success();
        -:  124:  }
        -:  125:};
        -:  126:
        -:  127:/// This pattern matches test.op_commutative2 with the first operand being
        -:  128:/// another test.op_commutative2 with a constant on the right side and fold it
        -:  129:/// away by propagating it as its result. This is intend to check that patterns
        -:  130:/// are applied after the commutative property moves constant to the right.
        -:  131:struct FolderCommutativeOp2WithConstant
        -:  132:    : public OpRewritePattern<TestCommutative2Op> {
        -:  133:public:
        -:  134:  using OpRewritePattern<TestCommutative2Op>::OpRewritePattern;
        -:  135:
function _ZNK12_GLOBAL__N_132FolderCommutativeOp2WithConstant15matchAndRewriteEN4test18TestCommutative2OpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  136:  LogicalResult matchAndRewrite(TestCommutative2Op op,
        -:  137:                                PatternRewriter &rewriter) const override {
    #####:  138:    auto operand =
    #####:  139:        dyn_cast_or_null<TestCommutative2Op>(op->getOperand(0).getDefiningOp());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  140:    if (!operand)
branch  0 never executed
branch  1 never executed
    #####:  141:      return failure();
    #####:  142:    Attribute constInput;
    #####:  143:    if (!matchPattern(operand->getOperand(1), m_Constant(&constInput)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  144:      return failure();
    #####:  145:    rewriter.replaceOp(op, operand->getOperand(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  146:    return success();
        -:  147:  }
        -:  148:};
        -:  149:
        -:  150:struct TestPatternDriver
        -:  151:    : public PassWrapper<TestPatternDriver, OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_117TestPatternDriver13resolveTypeIDEv called 116673 returned 100% blocks executed 100%
   116673:  152:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestPatternDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  153:
function _ZN12_GLOBAL__N_117TestPatternDriverC2Ev called 116673 returned 100% blocks executed 100%
   116673:  154:  TestPatternDriver() = default;
call    0 returned 100%
call    1 returned 100%
function _ZN12_GLOBAL__N_117TestPatternDriverC2ERKS0_ called 27720 returned 100% blocks executed 100%
    27720:  155:  TestPatternDriver(const TestPatternDriver &other) : PassWrapper(other) {}
call    0 returned 100%
call    1 returned 100%
        -:  156:
function _ZNK12_GLOBAL__N_117TestPatternDriver11getArgumentEv called 116180 returned 100% blocks executed 100%
   116180:  157:  StringRef getArgument() const final { return "test-patterns"; }
function _ZNK12_GLOBAL__N_117TestPatternDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  158:  StringRef getDescription() const final { return "Run test dialect patterns"; }
function _ZN12_GLOBAL__N_117TestPatternDriver14runOnOperationEv called 409 returned 100% blocks executed 100%
      409:  159:  void runOnOperation() override {
      409:  160:    mlir::RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      409:  161:    populateWithGenerated(patterns);
call    0 returned 100%
        -:  162:
        -:  163:    // Verify named pattern is generated with expected name.
      408:  164:    patterns.add<FoldingPattern, TestNamedPatternRule,
        -:  165:                 FolderInsertBeforePreviouslyFoldedConstantPattern,
      408:  166:                 FolderCommutativeOp2WithConstant>(&getContext());
call    0 returned 100%
call    1 returned 100%
        -:  167:
      408:  168:    GreedyRewriteConfig config;
      408:  169:    config.useTopDownTraversal = this->useTopDownTraversal;
call    0 returned 100%
      408:  170:    (void)applyPatternsAndFoldGreedily(getOperation(), std::move(patterns),
call    0 returned 100%
call    1 returned 100%
      817:  171:                                       config);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      409:  172:  }
        -:  173:
        -:  174:  Option<bool> useTopDownTraversal{
        -:  175:      *this, "top-down",
        -:  176:      llvm::cl::desc("Seed the worklist in general top-down order"),
        -:  177:      llvm::cl::init(GreedyRewriteConfig().useTopDownTraversal)};
        -:  178:};
        -:  179:
        -:  180:struct TestStrictPatternDriver
        -:  181:    : public PassWrapper<TestStrictPatternDriver, OperationPass<func::FuncOp>> {
        -:  182:public:
function _ZN12_GLOBAL__N_123TestStrictPatternDriver13resolveTypeIDEv called 116643 returned 100% blocks executed 100%
   116643:  183:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestStrictPatternDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  184:
   116643:  185:  TestStrictPatternDriver() = default;
call    0 returned 100%
    24624:  186:  TestStrictPatternDriver(const TestStrictPatternDriver &other) = default;
call    0 returned 100%
        -:  187:
function _ZNK12_GLOBAL__N_123TestStrictPatternDriver11getArgumentEv called 116172 returned 100% blocks executed 100%
   116172:  188:  StringRef getArgument() const final { return "test-strict-pattern-driver"; }
function _ZNK12_GLOBAL__N_123TestStrictPatternDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  189:  StringRef getDescription() const final {
   116163:  190:    return "Run strict mode of pattern driver";
        -:  191:  }
        -:  192:
function _ZN12_GLOBAL__N_123TestStrictPatternDriver14runOnOperationEv called 347 returned 100% blocks executed 92%
      347:  193:  void runOnOperation() override {
      347:  194:    mlir::RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      348:  195:    patterns.add<InsertSameOp, ReplaceWithSameOp, EraseOp>(&getContext());
call    0 returned 100%
call    1 returned 100%
      696:  196:    SmallVector<Operation *> ops;
call    0 returned 100%
call    1 returned 100%
function _ZZN12_GLOBAL__N_123TestStrictPatternDriver14runOnOperationEvENKUlPN4mlir9OperationEE_clES3_.isra.0 called 746608 returned 100% blocks executed 89%
      348:  197:    getOperation()->walk([&](Operation *op) {
call    0 returned 100%
call    1 returned 100%
   746608:  198:      StringRef opName = op->getName().getStringRef();
call    0 returned 100%
  785054*:  199:      if (opName == "test.insert_same_op" ||
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
  746613*:  200:          opName == "test.replace_with_same_op" || opName == "test.erase_op") {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
call    4 never executed
    #####:  201:        ops.push_back(op);
call    0 never executed
        -:  202:      }
   746610:  203:    });
        -:  204:
        -:  205:    // Check if these transformations introduce visiting of operations that
        -:  206:    // are not in the `ops` set (The new created ops are valid). An invalid
        -:  207:    // operation will trigger the assertion while processing.
      348:  208:    (void)applyOpPatternsAndFold(makeArrayRef(ops), std::move(patterns),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  209:                                 /*strict=*/true);
      348:  210:  }
        -:  211:
        -:  212:private:
        -:  213:  // New inserted operation is valid for further transformation.
        -:  214:  class InsertSameOp : public RewritePattern {
        -:  215:  public:
function _ZN12_GLOBAL__N_123TestStrictPatternDriver12InsertSameOpC2EPN4mlir11MLIRContextE called 348 returned 100% blocks executed 100%
      348:  216:    InsertSameOp(MLIRContext *context)
      348:  217:        : RewritePattern("test.insert_same_op", /*benefit=*/1, context) {}
call    0 returned 100%
call    1 returned 100%
        -:  218:
function _ZNK12_GLOBAL__N_123TestStrictPatternDriver12InsertSameOp15matchAndRewriteEPN4mlir9OperationERNS2_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  219:    LogicalResult matchAndRewrite(Operation *op,
        -:  220:                                  PatternRewriter &rewriter) const override {
    #####:  221:      if (op->hasAttr("skip"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  222:        return failure();
        -:  223:
    #####:  224:      Operation *newOp =
    #####:  225:          rewriter.create(op->getLoc(), op->getName().getIdentifier(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  226:                          op->getOperands(), op->getResultTypes());
    #####:  227:      op->setAttr("skip", rewriter.getBoolAttr(true));
call    0 never executed
call    1 never executed
    #####:  228:      newOp->setAttr("skip", rewriter.getBoolAttr(true));
call    0 never executed
call    1 never executed
        -:  229:
    #####:  230:      return success();
        -:  231:    }
        -:  232:  };
        -:  233:
        -:  234:  // Replace an operation may introduce the re-visiting of its users.
        -:  235:  class ReplaceWithSameOp : public RewritePattern {
        -:  236:  public:
function _ZN12_GLOBAL__N_123TestStrictPatternDriver17ReplaceWithSameOpC2EPN4mlir11MLIRContextE called 348 returned 100% blocks executed 100%
      348:  237:    ReplaceWithSameOp(MLIRContext *context)
      348:  238:        : RewritePattern("test.replace_with_same_op", /*benefit=*/1, context) {}
call    0 returned 100%
call    1 returned 100%
        -:  239:
function _ZNK12_GLOBAL__N_123TestStrictPatternDriver17ReplaceWithSameOp15matchAndRewriteEPN4mlir9OperationERNS2_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  240:    LogicalResult matchAndRewrite(Operation *op,
        -:  241:                                  PatternRewriter &rewriter) const override {
    #####:  242:      Operation *newOp =
    #####:  243:          rewriter.create(op->getLoc(), op->getName().getIdentifier(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  244:                          op->getOperands(), op->getResultTypes());
    #####:  245:      rewriter.replaceOp(op, newOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  246:      return success();
        -:  247:    }
        -:  248:  };
        -:  249:
        -:  250:  // Remove an operation may introduce the re-visiting of its opreands.
        -:  251:  class EraseOp : public RewritePattern {
        -:  252:  public:
function _ZN12_GLOBAL__N_123TestStrictPatternDriver7EraseOpC2EPN4mlir11MLIRContextE called 348 returned 100% blocks executed 100%
      348:  253:    EraseOp(MLIRContext *context)
      348:  254:        : RewritePattern("test.erase_op", /*benefit=*/1, context) {}
call    0 returned 100%
call    1 returned 100%
function _ZNK12_GLOBAL__N_123TestStrictPatternDriver7EraseOp15matchAndRewriteEPN4mlir9OperationERNS2_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  255:    LogicalResult matchAndRewrite(Operation *op,
        -:  256:                                  PatternRewriter &rewriter) const override {
    #####:  257:      rewriter.eraseOp(op);
call    0 never executed
    #####:  258:      return success();
        -:  259:    }
        -:  260:  };
        -:  261:};
        -:  262:
        -:  263:} // namespace
        -:  264:
        -:  265://===----------------------------------------------------------------------===//
        -:  266:// ReturnType Driver.
        -:  267://===----------------------------------------------------------------------===//
        -:  268:
        -:  269:namespace {
        -:  270:// Generate ops for each instance where the type can be successfully inferred.
        -:  271:template <typename OpTy>
    #####:  272:static void invokeCreateWithInferredReturnType(Operation *op) {
    #####:  273:  auto *context = op->getContext();
    #####:  274:  auto fop = op->getParentOfType<func::FuncOp>();
    #####:  275:  auto location = UnknownLoc::get(context);
    #####:  276:  OpBuilder b(op);
    #####:  277:  b.setInsertionPointAfter(op);
        -:  278:
        -:  279:  // Use permutations of 2 args as operands.
    #####:  280:  assert(fop.getNumArguments() >= 2);
    #####:  281:  for (int i = 0, e = fop.getNumArguments(); i < e; ++i) {
    #####:  282:    for (int j = 0; j < e; ++j) {
    #####:  283:      std::array<Value, 2> values = {{fop.getArgument(i), fop.getArgument(j)}};
    #####:  284:      SmallVector<Type, 2> inferredReturnTypes;
    #####:  285:      if (succeeded(OpTy::inferReturnTypes(
        -:  286:              context, llvm::None, values, op->getAttrDictionary(),
        -:  287:              op->getRegions(), inferredReturnTypes))) {
    #####:  288:        OperationState state(location, OpTy::getOperationName());
        -:  289:        // TODO: Expand to regions.
    #####:  290:        OpTy::build(b, state, values, op->getAttrs());
    #####:  291:        (void)b.create(state);
        -:  292:      }
        -:  293:    }
        -:  294:  }
    #####:  295:}
------------------
_ZN12_GLOBAL__N_1L34invokeCreateWithInferredReturnTypeIN4test36OpWithShapedTypeInferTypeInterfaceOpEEEvPN4mlir9OperationE:
function _ZN12_GLOBAL__N_1L34invokeCreateWithInferredReturnTypeIN4test36OpWithShapedTypeInferTypeInterfaceOpEEEvPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  272:static void invokeCreateWithInferredReturnType(Operation *op) {
call    0 never executed
    #####:  273:  auto *context = op->getContext();
    #####:  274:  auto fop = op->getParentOfType<func::FuncOp>();
call    0 never executed
    #####:  275:  auto location = UnknownLoc::get(context);
call    0 never executed
    #####:  276:  OpBuilder b(op);
call    0 never executed
call    1 never executed
    #####:  277:  b.setInsertionPointAfter(op);
call    0 never executed
        -:  278:
        -:  279:  // Use permutations of 2 args as operands.
    #####:  280:  assert(fop.getNumArguments() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  281:  for (int i = 0, e = fop.getNumArguments(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  282:    for (int j = 0; j < e; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  283:      std::array<Value, 2> values = {{fop.getArgument(i), fop.getArgument(j)}};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  284:      SmallVector<Type, 2> inferredReturnTypes;
branch  0 never executed
branch  1 never executed
    #####:  285:      if (succeeded(OpTy::inferReturnTypes(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  286:              context, llvm::None, values, op->getAttrDictionary(),
        -:  287:              op->getRegions(), inferredReturnTypes))) {
    #####:  288:        OperationState state(location, OpTy::getOperationName());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  289:        // TODO: Expand to regions.
    #####:  290:        OpTy::build(b, state, values, op->getAttrs());
call    0 never executed
call    1 never executed
    #####:  291:        (void)b.create(state);
call    0 never executed
        -:  292:      }
        -:  293:    }
        -:  294:  }
    #####:  295:}
------------------
_ZN12_GLOBAL__N_1L34invokeCreateWithInferredReturnTypeIN4test26OpWithInferTypeInterfaceOpEEEvPN4mlir9OperationE:
function _ZN12_GLOBAL__N_1L34invokeCreateWithInferredReturnTypeIN4test26OpWithInferTypeInterfaceOpEEEvPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  272:static void invokeCreateWithInferredReturnType(Operation *op) {
call    0 never executed
    #####:  273:  auto *context = op->getContext();
    #####:  274:  auto fop = op->getParentOfType<func::FuncOp>();
call    0 never executed
    #####:  275:  auto location = UnknownLoc::get(context);
call    0 never executed
    #####:  276:  OpBuilder b(op);
call    0 never executed
call    1 never executed
    #####:  277:  b.setInsertionPointAfter(op);
call    0 never executed
        -:  278:
        -:  279:  // Use permutations of 2 args as operands.
    #####:  280:  assert(fop.getNumArguments() >= 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  281:  for (int i = 0, e = fop.getNumArguments(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  282:    for (int j = 0; j < e; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  283:      std::array<Value, 2> values = {{fop.getArgument(i), fop.getArgument(j)}};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  284:      SmallVector<Type, 2> inferredReturnTypes;
branch  0 never executed
branch  1 never executed
    #####:  285:      if (succeeded(OpTy::inferReturnTypes(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  286:              context, llvm::None, values, op->getAttrDictionary(),
        -:  287:              op->getRegions(), inferredReturnTypes))) {
    #####:  288:        OperationState state(location, OpTy::getOperationName());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  289:        // TODO: Expand to regions.
    #####:  290:        OpTy::build(b, state, values, op->getAttrs());
call    0 never executed
call    1 never executed
    #####:  291:        (void)b.create(state);
call    0 never executed
        -:  292:      }
        -:  293:    }
        -:  294:  }
    #####:  295:}
------------------
        -:  296:
function _ZN12_GLOBAL__N_1L16reifyReturnShapeEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  297:static void reifyReturnShape(Operation *op) {
    #####:  298:  OpBuilder b(op);
call    0 never executed
        -:  299:
        -:  300:  // Use permutations of 2 args as operands.
    #####:  301:  auto shapedOp = cast<OpWithShapedTypeInferTypeInterfaceOp>(op);
call    0 never executed
    #####:  302:  SmallVector<Value, 2> shapes;
call    0 never executed
    #####:  303:  if (failed(shapedOp.reifyReturnTypeShapes(b, op->getOperands(), shapes)) ||
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  304:      !llvm::hasSingleElement(shapes))
    #####:  305:    return;
branch  0 never executed
branch  1 never executed
    #####:  306:  for (const auto &it : llvm::enumerate(shapes)) {
branch  0 never executed
branch  1 never executed
    #####:  307:    op->emitRemark() << "value " << it.index() << ": "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  308:                     << it.value().getDefiningOp();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  309:  }
        -:  310:}
        -:  311:
   144249:  312:struct TestReturnTypeDriver
call    0 returned 100%
call    1 returned 100%
        -:  313:    : public PassWrapper<TestReturnTypeDriver, OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_120TestReturnTypeDriver13resolveTypeIDEv called 116673 returned 100% blocks executed 100%
   116673:  314:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestReturnTypeDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  315:
function _ZNK12_GLOBAL__N_120TestReturnTypeDriver20getDependentDialectsERN4mlir15DialectRegistryE called 510 returned 100% blocks executed 100%
      510:  316:  void getDependentDialects(DialectRegistry &registry) const override {
      510:  317:    registry.insert<tensor::TensorDialect>();
call    0 returned 100%
      510:  318:  }
function _ZNK12_GLOBAL__N_120TestReturnTypeDriver11getArgumentEv called 116184 returned 100% blocks executed 100%
   116184:  319:  StringRef getArgument() const final { return "test-return-type"; }
function _ZNK12_GLOBAL__N_120TestReturnTypeDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  320:  StringRef getDescription() const final { return "Run return type functions"; }
        -:  321:
function _ZN12_GLOBAL__N_120TestReturnTypeDriver14runOnOperationEv called 403 returned 100% blocks executed 22%
      403:  322:  void runOnOperation() override {
     804*:  323:    if (getOperation().getName() == "testCreateFunctions") {
call    0 returned 100%
call    1 returned 100%
    #####:  324:      std::vector<Operation *> ops;
call    0 never executed
        -:  325:      // Collect ops to avoid triggering on inserted ops.
    #####:  326:      for (auto &op : getOperation().getBody().front())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  327:        ops.push_back(&op);
call    0 never executed
        -:  328:      // Generate test patterns for each, but skip terminator.
    #####:  329:      for (auto *op : llvm::makeArrayRef(ops).drop_back()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  330:        // Test create method of each of the Op classes below. The resultant
        -:  331:        // output would be in reverse order underneath `op` from which
        -:  332:        // the attributes and regions are used.
    #####:  333:        invokeCreateWithInferredReturnType<OpWithInferTypeInterfaceOp>(op);
call    0 never executed
    #####:  334:        invokeCreateWithInferredReturnType<
    #####:  335:            OpWithShapedTypeInferTypeInterfaceOp>(op);
call    0 never executed
    #####:  336:      };
    #####:  337:      return;
branch  0 never executed
branch  1 never executed
        -:  338:    }
     802*:  339:    if (getOperation().getName() == "testReifyFunctions") {
call    0 returned 100%
call    1 returned 100%
    #####:  340:      std::vector<Operation *> ops;
call    0 never executed
        -:  341:      // Collect ops to avoid triggering on inserted ops.
    #####:  342:      for (auto &op : getOperation().getBody().front())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  343:        if (isa<OpWithShapedTypeInferTypeInterfaceOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  344:          ops.push_back(&op);
call    0 never executed
        -:  345:      // Generate test patterns for each, but skip terminator.
    #####:  346:      for (auto *op : ops)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  347:        reifyReturnShape(op);
call    0 never executed
        -:  348:    }
        -:  349:  }
        -:  350:};
        -:  351:} // namespace
        -:  352:
        -:  353:namespace {
   146265:  354:struct TestDerivedAttributeDriver
call    0 returned 100%
call    1 returned 100%
        -:  355:    : public PassWrapper<TestDerivedAttributeDriver,
        -:  356:                         OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_126TestDerivedAttributeDriver13resolveTypeIDEv called 116673 returned 100% blocks executed 100%
   116673:  357:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestDerivedAttributeDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  358:
function _ZNK12_GLOBAL__N_126TestDerivedAttributeDriver11getArgumentEv called 116179 returned 100% blocks executed 100%
   116179:  359:  StringRef getArgument() const final { return "test-derived-attr"; }
function _ZNK12_GLOBAL__N_126TestDerivedAttributeDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  360:  StringRef getDescription() const final {
   116163:  361:    return "Run test derived attributes";
        -:  362:  }
        -:  363:  void runOnOperation() override;
        -:  364:};
        -:  365:} // namespace
        -:  366:
function _ZN12_GLOBAL__N_126TestDerivedAttributeDriver14runOnOperationEv called 477 returned 98% blocks executed 100%
      477:  367:void TestDerivedAttributeDriver::runOnOperation() {
function _ZZN12_GLOBAL__N_126TestDerivedAttributeDriver14runOnOperationEvENKUlN4mlir27DerivedAttributeOpInterfaceEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     477*:  368:  getOperation().walk([](DerivedAttributeOpInterface dOp) {
call    0 returned 100%
call    1 returned 98%
    #####:  369:    auto dAttr = dOp.materializeDerivedAttributes();
call    0 never executed
    #####:  370:    if (!dAttr)
branch  0 never executed
branch  1 never executed
    #####:  371:      return;
    #####:  372:    for (auto d : dAttr)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  373:      dOp.emitRemark() << d.getName().getValue() << " = " << d.getValue();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  374:  });
      468:  375:}
        -:  376:
        -:  377://===----------------------------------------------------------------------===//
        -:  378:// Legalization Driver.
        -:  379://===----------------------------------------------------------------------===//
        -:  380:
        -:  381:namespace {
        -:  382://===----------------------------------------------------------------------===//
        -:  383:// Region-Block Rewrite Testing
        -:  384:
        -:  385:/// This pattern is a simple pattern that inlines the first region of a given
        -:  386:/// operation into the parent region.
        -:  387:struct TestRegionRewriteBlockMovement : public ConversionPattern {
function _ZN12_GLOBAL__N_130TestRegionRewriteBlockMovementC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  388:  TestRegionRewriteBlockMovement(MLIRContext *ctx)
      377:  389:      : ConversionPattern("test.region", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  390:
        -:  391:  LogicalResult
function _ZNK12_GLOBAL__N_130TestRegionRewriteBlockMovement15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  392:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  393:                  ConversionPatternRewriter &rewriter) const final {
        -:  394:    // Inline this region into the parent region.
    #####:  395:    auto &parentRegion = *op->getParentRegion();
branch  0 never executed
branch  1 never executed
    #####:  396:    auto &opRegion = op->getRegion(0);
call    0 never executed
    #####:  397:    if (op->getAttr("legalizer.should_clone"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  398:      rewriter.cloneRegionBefore(opRegion, parentRegion, parentRegion.end());
call    0 never executed
        -:  399:    else
    #####:  400:      rewriter.inlineRegionBefore(opRegion, parentRegion, parentRegion.end());
call    0 never executed
        -:  401:
    #####:  402:    if (op->getAttr("legalizer.erase_old_blocks")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  403:      while (!opRegion.empty())
branch  0 never executed
branch  1 never executed
    #####:  404:        rewriter.eraseBlock(&opRegion.front());
call    0 never executed
call    1 never executed
        -:  405:    }
        -:  406:
        -:  407:    // Drop this operation.
    #####:  408:    rewriter.eraseOp(op);
call    0 never executed
    #####:  409:    return success();
        -:  410:  }
        -:  411:};
        -:  412:/// This pattern is a simple pattern that generates a region containing an
        -:  413:/// illegal operation.
        -:  414:struct TestRegionRewriteUndo : public RewritePattern {
function _ZN12_GLOBAL__N_121TestRegionRewriteUndoC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  415:  TestRegionRewriteUndo(MLIRContext *ctx)
      377:  416:      : RewritePattern("test.region_builder", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  417:
function _ZNK12_GLOBAL__N_121TestRegionRewriteUndo15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  418:  LogicalResult matchAndRewrite(Operation *op,
        -:  419:                                PatternRewriter &rewriter) const final {
        -:  420:    // Create the region operation with an entry block containing arguments.
    #####:  421:    OperationState newRegion(op->getLoc(), "test.region");
call    0 never executed
call    1 never executed
    #####:  422:    newRegion.addRegion();
call    0 never executed
    #####:  423:    auto *regionOp = rewriter.create(newRegion);
call    0 never executed
    #####:  424:    auto *entryBlock = rewriter.createBlock(&regionOp->getRegion(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  425:    entryBlock->addArgument(rewriter.getIntegerType(64),
call    0 never executed
    #####:  426:                            rewriter.getUnknownLoc());
call    0 never executed
call    1 never executed
        -:  427:
        -:  428:    // Add an explicitly illegal operation to ensure the conversion fails.
    #####:  429:    rewriter.create<ILLegalOpF>(op->getLoc(), rewriter.getIntegerType(32));
call    0 never executed
call    1 never executed
    #####:  430:    rewriter.create<TestValidOp>(op->getLoc(), ArrayRef<Value>());
call    0 never executed
        -:  431:
        -:  432:    // Drop this operation.
    #####:  433:    rewriter.eraseOp(op);
call    0 never executed
    #####:  434:    return success();
call    0 never executed
        -:  435:  }
        -:  436:};
        -:  437:/// A simple pattern that creates a block at the end of the parent region of the
        -:  438:/// matched operation.
        -:  439:struct TestCreateBlock : public RewritePattern {
function _ZN12_GLOBAL__N_115TestCreateBlockC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  440:  TestCreateBlock(MLIRContext *ctx)
      377:  441:      : RewritePattern("test.create_block", /*benefit=*/1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  442:
function _ZNK12_GLOBAL__N_115TestCreateBlock15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  443:  LogicalResult matchAndRewrite(Operation *op,
        -:  444:                                PatternRewriter &rewriter) const final {
    #####:  445:    Region &region = *op->getParentRegion();
branch  0 never executed
branch  1 never executed
    #####:  446:    Type i32Type = rewriter.getIntegerType(32);
call    0 never executed
    #####:  447:    Location loc = op->getLoc();
call    0 never executed
    #####:  448:    rewriter.createBlock(&region, region.end(), {i32Type, i32Type}, {loc, loc});
call    0 never executed
call    1 never executed
    #####:  449:    rewriter.create<TerminatorOp>(loc);
call    0 never executed
    #####:  450:    rewriter.replaceOp(op, {});
call    0 never executed
call    1 never executed
    #####:  451:    return success();
        -:  452:  }
        -:  453:};
        -:  454:
        -:  455:/// A simple pattern that creates a block containing an invalid operation in
        -:  456:/// order to trigger the block creation undo mechanism.
        -:  457:struct TestCreateIllegalBlock : public RewritePattern {
function _ZN12_GLOBAL__N_122TestCreateIllegalBlockC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  458:  TestCreateIllegalBlock(MLIRContext *ctx)
      377:  459:      : RewritePattern("test.create_illegal_block", /*benefit=*/1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  460:
function _ZNK12_GLOBAL__N_122TestCreateIllegalBlock15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  461:  LogicalResult matchAndRewrite(Operation *op,
        -:  462:                                PatternRewriter &rewriter) const final {
    #####:  463:    Region &region = *op->getParentRegion();
branch  0 never executed
branch  1 never executed
    #####:  464:    Type i32Type = rewriter.getIntegerType(32);
call    0 never executed
    #####:  465:    Location loc = op->getLoc();
call    0 never executed
    #####:  466:    rewriter.createBlock(&region, region.end(), {i32Type, i32Type}, {loc, loc});
call    0 never executed
call    1 never executed
        -:  467:    // Create an illegal op to ensure the conversion fails.
    #####:  468:    rewriter.create<ILLegalOpF>(loc, i32Type);
call    0 never executed
    #####:  469:    rewriter.create<TerminatorOp>(loc);
call    0 never executed
    #####:  470:    rewriter.replaceOp(op, {});
call    0 never executed
call    1 never executed
    #####:  471:    return success();
        -:  472:  }
        -:  473:};
        -:  474:
        -:  475:/// A simple pattern that tests the undo mechanism when replacing the uses of a
        -:  476:/// block argument.
        -:  477:struct TestUndoBlockArgReplace : public ConversionPattern {
function _ZN12_GLOBAL__N_123TestUndoBlockArgReplaceC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  478:  TestUndoBlockArgReplace(MLIRContext *ctx)
      377:  479:      : ConversionPattern("test.undo_block_arg_replace", /*benefit=*/1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  480:
        -:  481:  LogicalResult
function _ZNK12_GLOBAL__N_123TestUndoBlockArgReplace15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  482:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  483:                  ConversionPatternRewriter &rewriter) const final {
    #####:  484:    auto illegalOp =
    #####:  485:        rewriter.create<ILLegalOpF>(op->getLoc(), rewriter.getF32Type());
call    0 never executed
call    1 never executed
    #####:  486:    rewriter.replaceUsesOfBlockArgument(op->getRegion(0).getArgument(0),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  487:                                        illegalOp);
    #####:  488:    rewriter.updateRootInPlace(op, [] {});
call    0 never executed
call    1 never executed
    #####:  489:    return success();
        -:  490:  }
        -:  491:};
        -:  492:
        -:  493:/// A rewrite pattern that tests the undo mechanism when erasing a block.
        -:  494:struct TestUndoBlockErase : public ConversionPattern {
function _ZN12_GLOBAL__N_118TestUndoBlockEraseC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  495:  TestUndoBlockErase(MLIRContext *ctx)
      377:  496:      : ConversionPattern("test.undo_block_erase", /*benefit=*/1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  497:
        -:  498:  LogicalResult
function _ZNK12_GLOBAL__N_118TestUndoBlockErase15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  499:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  500:                  ConversionPatternRewriter &rewriter) const final {
    #####:  501:    Block *secondBlock = &*std::next(op->getRegion(0).begin());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  502:    rewriter.setInsertionPointToStart(secondBlock);
call    0 never executed
    #####:  503:    rewriter.create<ILLegalOpF>(op->getLoc(), rewriter.getF32Type());
call    0 never executed
call    1 never executed
    #####:  504:    rewriter.eraseBlock(secondBlock);
call    0 never executed
    #####:  505:    rewriter.updateRootInPlace(op, [] {});
call    0 never executed
call    1 never executed
    #####:  506:    return success();
        -:  507:  }
        -:  508:};
        -:  509:
        -:  510://===----------------------------------------------------------------------===//
        -:  511:// Type-Conversion Rewrite Testing
        -:  512:
        -:  513:/// This patterns erases a region operation that has had a type conversion.
        -:  514:struct TestDropOpSignatureConversion : public ConversionPattern {
        -:  515:  TestDropOpSignatureConversion(MLIRContext *ctx, TypeConverter &converter)
        -:  516:      : ConversionPattern(converter, "test.drop_region_op", 1, ctx) {}
        -:  517:  LogicalResult
function _ZNK12_GLOBAL__N_129TestDropOpSignatureConversion15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  518:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  519:                  ConversionPatternRewriter &rewriter) const override {
    #####:  520:    Region &region = op->getRegion(0);
call    0 never executed
    #####:  521:    Block *entry = &region.front();
call    0 never executed
        -:  522:
        -:  523:    // Convert the original entry arguments.
    #####:  524:    TypeConverter &converter = *getTypeConverter();
call    0 never executed
    #####:  525:    TypeConverter::SignatureConversion result(entry->getNumArguments());
call    0 never executed
    #####:  526:    if (failed(converter.convertSignatureArgs(entry->getArgumentTypes(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  527:                                              result)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  528:        failed(rewriter.convertRegionTypes(&region, converter, &result)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  529:      return failure();
        -:  530:
        -:  531:    // Convert the region signature and just drop the operation.
    #####:  532:    rewriter.eraseOp(op);
call    0 never executed
    #####:  533:    return success();
call    0 never executed
        -:  534:  }
        -:  535:};
        -:  536:/// This pattern simply updates the operands of the given operation.
        -:  537:struct TestPassthroughInvalidOp : public ConversionPattern {
function _ZN12_GLOBAL__N_124TestPassthroughInvalidOpC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  538:  TestPassthroughInvalidOp(MLIRContext *ctx)
      377:  539:      : ConversionPattern("test.invalid", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  540:  LogicalResult
function _ZNK12_GLOBAL__N_124TestPassthroughInvalidOp15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  541:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  542:                  ConversionPatternRewriter &rewriter) const final {
    #####:  543:    rewriter.replaceOpWithNewOp<TestValidOp>(op, llvm::None, operands,
    #####:  544:                                             llvm::None);
call    0 never executed
    #####:  545:    return success();
        -:  546:  }
        -:  547:};
        -:  548:/// This pattern handles the case of a split return value.
        -:  549:struct TestSplitReturnType : public ConversionPattern {
function _ZN12_GLOBAL__N_119TestSplitReturnTypeC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  550:  TestSplitReturnType(MLIRContext *ctx)
      377:  551:      : ConversionPattern("test.return", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  552:  LogicalResult
function _ZNK12_GLOBAL__N_119TestSplitReturnType15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  553:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  554:                  ConversionPatternRewriter &rewriter) const final {
        -:  555:    // Check for a return of F32.
    #####:  556:    if (op->getNumOperands() != 1 || !op->getOperand(0).getType().isF32())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  557:      return failure();
        -:  558:
        -:  559:    // Check if the first operation is a cast operation, if it is we use the
        -:  560:    // results directly.
    #####:  561:    auto *defOp = operands[0].getDefiningOp();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  562:    if (auto packerOp =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  563:            llvm::dyn_cast_or_null<UnrealizedConversionCastOp>(defOp)) {
branch  0 never executed
branch  1 never executed
    #####:  564:      rewriter.replaceOpWithNewOp<TestReturnOp>(op, packerOp.getOperands());
call    0 never executed
call    1 never executed
    #####:  565:      return success();
        -:  566:    }
        -:  567:
        -:  568:    // Otherwise, fail to match.
    #####:  569:    return failure();
        -:  570:  }
        -:  571:};
        -:  572:
        -:  573://===----------------------------------------------------------------------===//
        -:  574:// Multi-Level Type-Conversion Rewrite Testing
        -:  575:struct TestChangeProducerTypeI32ToF32 : public ConversionPattern {
function _ZN12_GLOBAL__N_130TestChangeProducerTypeI32ToF32C2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  576:  TestChangeProducerTypeI32ToF32(MLIRContext *ctx)
      377:  577:      : ConversionPattern("test.type_producer", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  578:  LogicalResult
function _ZNK12_GLOBAL__N_130TestChangeProducerTypeI32ToF3215matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  579:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  580:                  ConversionPatternRewriter &rewriter) const final {
        -:  581:    // If the type is I32, change the type to F32.
    #####:  582:    if (!Type(*op->result_type_begin()).isSignlessInteger(32))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  583:      return failure();
    #####:  584:    rewriter.replaceOpWithNewOp<TestTypeProducerOp>(op, rewriter.getF32Type());
call    0 never executed
call    1 never executed
    #####:  585:    return success();
        -:  586:  }
        -:  587:};
        -:  588:struct TestChangeProducerTypeF32ToF64 : public ConversionPattern {
function _ZN12_GLOBAL__N_130TestChangeProducerTypeF32ToF64C2EPN4mlir11MLIRContextE called 853 returned 100% blocks executed 100%
      853:  589:  TestChangeProducerTypeF32ToF64(MLIRContext *ctx)
      853:  590:      : ConversionPattern("test.type_producer", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  591:  LogicalResult
function _ZNK12_GLOBAL__N_130TestChangeProducerTypeF32ToF6415matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  592:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  593:                  ConversionPatternRewriter &rewriter) const final {
        -:  594:    // If the type is F32, change the type to F64.
    #####:  595:    if (!Type(*op->result_type_begin()).isF32())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  596:      return rewriter.notifyMatchFailure(op, "expected single f32 operand");
call    0 never executed
    #####:  597:    rewriter.replaceOpWithNewOp<TestTypeProducerOp>(op, rewriter.getF64Type());
call    0 never executed
call    1 never executed
    #####:  598:    return success();
        -:  599:  }
        -:  600:};
        -:  601:struct TestChangeProducerTypeF32ToInvalid : public ConversionPattern {
function _ZN12_GLOBAL__N_134TestChangeProducerTypeF32ToInvalidC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  602:  TestChangeProducerTypeF32ToInvalid(MLIRContext *ctx)
      377:  603:      : ConversionPattern("test.type_producer", 10, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  604:  LogicalResult
function _ZNK12_GLOBAL__N_134TestChangeProducerTypeF32ToInvalid15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  605:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  606:                  ConversionPatternRewriter &rewriter) const final {
        -:  607:    // Always convert to B16, even though it is not a legal type. This tests
        -:  608:    // that values are unmapped correctly.
    #####:  609:    rewriter.replaceOpWithNewOp<TestTypeProducerOp>(op, rewriter.getBF16Type());
call    0 never executed
call    1 never executed
    #####:  610:    return success();
        -:  611:  }
        -:  612:};
        -:  613:struct TestUpdateConsumerType : public ConversionPattern {
function _ZN12_GLOBAL__N_122TestUpdateConsumerTypeC2EPN4mlir11MLIRContextE called 856 returned 100% blocks executed 100%
      856:  614:  TestUpdateConsumerType(MLIRContext *ctx)
      856:  615:      : ConversionPattern("test.type_consumer", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  616:  LogicalResult
function _ZNK12_GLOBAL__N_122TestUpdateConsumerType15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  617:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  618:                  ConversionPatternRewriter &rewriter) const final {
        -:  619:    // Verify that the incoming operand has been successfully remapped to F64.
    #####:  620:    if (!operands[0].getType().isF64())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  621:      return failure();
    #####:  622:    rewriter.replaceOpWithNewOp<TestTypeConsumerOp>(op, operands[0]);
call    0 never executed
    #####:  623:    return success();
        -:  624:  }
        -:  625:};
        -:  626:
        -:  627://===----------------------------------------------------------------------===//
        -:  628:// Non-Root Replacement Rewrite Testing
        -:  629:/// This pattern generates an invalid operation, but replaces it before the
        -:  630:/// pattern is finished. This checks that we don't need to legalize the
        -:  631:/// temporary op.
        -:  632:struct TestNonRootReplacement : public RewritePattern {
function _ZN12_GLOBAL__N_122TestNonRootReplacementC2EPN4mlir11MLIRContextE called 377 returned 100% blocks executed 100%
      377:  633:  TestNonRootReplacement(MLIRContext *ctx)
      377:  634:      : RewritePattern("test.replace_non_root", 1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -:  635:
function _ZNK12_GLOBAL__N_122TestNonRootReplacement15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  636:  LogicalResult matchAndRewrite(Operation *op,
        -:  637:                                PatternRewriter &rewriter) const final {
    #####:  638:    auto resultType = *op->result_type_begin();
call    0 never executed
call    1 never executed
    #####:  639:    auto illegalOp = rewriter.create<ILLegalOpF>(op->getLoc(), resultType);
call    0 never executed
    #####:  640:    auto legalOp = rewriter.create<LegalOpB>(op->getLoc(), resultType);
call    0 never executed
        -:  641:
    #####:  642:    rewriter.replaceOp(illegalOp, {legalOp});
call    0 never executed
call    1 never executed
    #####:  643:    rewriter.replaceOp(op, {illegalOp});
call    0 never executed
call    1 never executed
    #####:  644:    return success();
        -:  645:  }
        -:  646:};
        -:  647:
        -:  648://===----------------------------------------------------------------------===//
        -:  649:// Recursive Rewrite Testing
        -:  650:/// This pattern is applied to the same operation multiple times, but has a
        -:  651:/// bounded recursion.
        -:  652:struct TestBoundedRecursiveRewrite
        -:  653:    : public OpRewritePattern<TestRecursiveRewriteOp> {
        -:  654:  using OpRewritePattern<TestRecursiveRewriteOp>::OpRewritePattern;
        -:  655:
        -:  656:  void initialize() {
        -:  657:    // The conversion target handles bounding the recursion of this pattern.
        -:  658:    setHasBoundedRewriteRecursion();
        -:  659:  }
        -:  660:
function _ZNK12_GLOBAL__N_127TestBoundedRecursiveRewrite15matchAndRewriteEN4test22TestRecursiveRewriteOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  661:  LogicalResult matchAndRewrite(TestRecursiveRewriteOp op,
        -:  662:                                PatternRewriter &rewriter) const final {
        -:  663:    // Decrement the depth of the op in-place.
function _ZZNK12_GLOBAL__N_127TestBoundedRecursiveRewrite15matchAndRewriteEN4test22TestRecursiveRewriteOpERN4mlir15PatternRewriterEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  664:    rewriter.updateRootInPlace(op, [&] {
call    0 never executed
    #####:  665:      op->setAttr("depth", rewriter.getI64IntegerAttr(op.getDepth() - 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  666:    });
    #####:  667:    return success();
        -:  668:  }
        -:  669:};
        -:  670:
        -:  671:struct TestNestedOpCreationUndoRewrite
        -:  672:    : public OpRewritePattern<IllegalOpWithRegionAnchor> {
        -:  673:  using OpRewritePattern<IllegalOpWithRegionAnchor>::OpRewritePattern;
        -:  674:
function _ZNK12_GLOBAL__N_131TestNestedOpCreationUndoRewrite15matchAndRewriteEN4test25IllegalOpWithRegionAnchorERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  675:  LogicalResult matchAndRewrite(IllegalOpWithRegionAnchor op,
        -:  676:                                PatternRewriter &rewriter) const final {
        -:  677:    // rewriter.replaceOpWithNewOp<IllegalOpWithRegion>(op);
    #####:  678:    rewriter.replaceOpWithNewOp<IllegalOpWithRegion>(op);
call    0 never executed
    #####:  679:    return success();
        -:  680:  };
        -:  681:};
        -:  682:
        -:  683:// This pattern matches `test.blackhole` and delete this op and its producer.
        -:  684:struct TestReplaceEraseOp : public OpRewritePattern<BlackHoleOp> {
        -:  685:  using OpRewritePattern<BlackHoleOp>::OpRewritePattern;
        -:  686:
function _ZNK12_GLOBAL__N_118TestReplaceEraseOp15matchAndRewriteEN4test11BlackHoleOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  687:  LogicalResult matchAndRewrite(BlackHoleOp op,
        -:  688:                                PatternRewriter &rewriter) const final {
    #####:  689:    Operation *producer = op.getOperand().getDefiningOp();
call    0 never executed
call    1 never executed
        -:  690:    // Always erase the user before the producer, the framework should handle
        -:  691:    // this correctly.
    #####:  692:    rewriter.eraseOp(op);
call    0 never executed
    #####:  693:    rewriter.eraseOp(producer);
call    0 never executed
    #####:  694:    return success();
        -:  695:  };
        -:  696:};
        -:  697:
        -:  698:// This pattern replaces explicitly illegal op with explicitly legal op,
        -:  699:// but in addition creates unregistered operation.
        -:  700:struct TestCreateUnregisteredOp : public OpRewritePattern<ILLegalOpG> {
        -:  701:  using OpRewritePattern<ILLegalOpG>::OpRewritePattern;
        -:  702:
function _ZNK12_GLOBAL__N_124TestCreateUnregisteredOp15matchAndRewriteEN4test10ILLegalOpGERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  703:  LogicalResult matchAndRewrite(ILLegalOpG op,
        -:  704:                                PatternRewriter &rewriter) const final {
    #####:  705:    IntegerAttr attr = rewriter.getI32IntegerAttr(0);
call    0 never executed
    #####:  706:    Value val = rewriter.create<arith::ConstantOp>(op->getLoc(), attr);
call    0 never executed
call    1 never executed
    #####:  707:    rewriter.replaceOpWithNewOp<LegalOpC>(op, val);
call    0 never executed
    #####:  708:    return success();
        -:  709:  };
        -:  710:};
        -:  711:} // namespace
        -:  712:
        -:  713:namespace {
     377*:  714:struct TestTypeConverter : public TypeConverter {
call    0 returned 100%
        -:  715:  using TypeConverter::TypeConverter;
function _ZN12_GLOBAL__N_117TestTypeConverterC2Ev called 377 returned 100% blocks executed 100%
      377:  716:  TestTypeConverter() {
call    0 returned 100%
      377:  717:    addConversion(convertType);
call    0 returned 100%
      377:  718:    addArgumentMaterialization(materializeCast);
call    0 returned 100%
      377:  719:    addSourceMaterialization(materializeCast);
call    0 returned 100%
      377:  720:  }
        -:  721:
function _ZN12_GLOBAL__N_117TestTypeConverter11convertTypeEN4mlir4TypeERN4llvm15SmallVectorImplIS2_EE called 853 returned 100% blocks executed 83%
      853:  722:  static LogicalResult convertType(Type t, SmallVectorImpl<Type> &results) {
        -:  723:    // Drop I16 types.
      853:  724:    if (t.isSignlessInteger(16))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
       13:  725:      return success();
        -:  726:
        -:  727:    // Convert I64 to F64.
      840:  728:    if (t.isSignlessInteger(64)) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
       20:  729:      results.push_back(FloatType::getF64(t.getContext()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       20:  730:      return success();
        -:  731:    }
        -:  732:
        -:  733:    // Convert I42 to I43.
      820:  734:    if (t.isInteger(42)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  735:      results.push_back(IntegerType::get(t.getContext(), 43));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  736:      return success();
        -:  737:    }
        -:  738:
        -:  739:    // Split F32 into F16,F16.
      820:  740:    if (t.isF32()) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
       44:  741:      results.assign(2, FloatType::getF16(t.getContext()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       44:  742:      return success();
        -:  743:    }
        -:  744:
        -:  745:    // Otherwise, convert the type directly.
      776:  746:    results.push_back(t);
call    0 returned 100%
      776:  747:    return success();
        -:  748:  }
        -:  749:
        -:  750:  /// Hook for materializing a conversion. This is necessary because we generate
        -:  751:  /// 1->N type mappings.
function _ZN12_GLOBAL__N_117TestTypeConverter15materializeCastERN4mlir9OpBuilderENS1_4TypeENS1_10ValueRangeENS1_8LocationE called 0 returned 0% blocks executed 0%
    #####:  752:  static Optional<Value> materializeCast(OpBuilder &builder, Type resultType,
        -:  753:                                         ValueRange inputs, Location loc) {
    #####:  754:    return builder.create<TestCastOp>(loc, resultType, inputs).getResult();
call    0 never executed
        -:  755:  }
        -:  756:};
        -:  757:
    #####:  758:struct TestLegalizePatternDriver
call    0 never executed
        -:  759:    : public PassWrapper<TestLegalizePatternDriver, OperationPass<ModuleOp>> {
function _ZN12_GLOBAL__N_125TestLegalizePatternDriver13resolveTypeIDEv called 116677 returned 100% blocks executed 100%
   116677:  760:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestLegalizePatternDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  761:
function _ZNK12_GLOBAL__N_125TestLegalizePatternDriver11getArgumentEv called 116182 returned 100% blocks executed 100%
   116182:  762:  StringRef getArgument() const final { return "test-legalize-patterns"; }
function _ZNK12_GLOBAL__N_125TestLegalizePatternDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  763:  StringRef getDescription() const final {
   116163:  764:    return "Run test dialect legalization patterns";
        -:  765:  }
        -:  766:  /// The mode of conversion to use with the driver.
        -:  767:  enum class ConversionMode { Analysis, Full, Partial };
        -:  768:
   116677:  769:  TestLegalizePatternDriver(ConversionMode mode) : mode(mode) {}
call    0 returned 100%
        -:  770:
function _ZNK12_GLOBAL__N_125TestLegalizePatternDriver20getDependentDialectsERN4mlir15DialectRegistryE called 514 returned 100% blocks executed 100%
      514:  771:  void getDependentDialects(DialectRegistry &registry) const override {
      514:  772:    registry.insert<func::FuncDialect>();
call    0 returned 100%
      514:  773:  }
        -:  774:
function _ZN12_GLOBAL__N_125TestLegalizePatternDriver14runOnOperationEv called 377 returned 100% blocks executed 57%
      377:  775:  void runOnOperation() override {
     377*:  776:    TestTypeConverter converter;
call    0 returned 100%
     377*:  777:    mlir::RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      377:  778:    populateWithGenerated(patterns);
call    0 returned 100%
      377:  779:    patterns
        -:  780:        .add<TestRegionRewriteBlockMovement, TestRegionRewriteUndo,
        -:  781:             TestCreateBlock, TestCreateIllegalBlock, TestUndoBlockArgReplace,
        -:  782:             TestUndoBlockErase, TestPassthroughInvalidOp, TestSplitReturnType,
        -:  783:             TestChangeProducerTypeI32ToF32, TestChangeProducerTypeF32ToF64,
        -:  784:             TestChangeProducerTypeF32ToInvalid, TestUpdateConsumerType,
        -:  785:             TestNonRootReplacement, TestBoundedRecursiveRewrite,
        -:  786:             TestNestedOpCreationUndoRewrite, TestReplaceEraseOp,
      377:  787:             TestCreateUnregisteredOp>(&getContext());
call    0 returned 100%
call    1 returned 100%
      377:  788:    patterns.add<TestDropOpSignatureConversion>(&getContext(), converter);
call    0 returned 100%
call    1 returned 100%
      377:  789:    mlir::populateFunctionOpInterfaceTypeConversionPattern<func::FuncOp>(
call    0 returned 100%
        -:  790:        patterns, converter);
      377:  791:    mlir::populateCallOpTypeConversionPattern(patterns, converter);
call    0 returned 100%
        -:  792:
        -:  793:    // Define the conversion target used for the test.
     377*:  794:    ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 never executed
      377:  795:    target.addLegalOp<ModuleOp>();
call    0 returned 100%
      377:  796:    target.addLegalOp<LegalOpA, LegalOpB, LegalOpC, TestCastOp, TestValidOp,
call    0 returned 100%
      377:  797:                      TerminatorOp>();
      377:  798:    target
      377:  799:        .addIllegalOp<ILLegalOpF, TestRegionBuilderOp, TestOpWithRegionFold>();
call    0 returned 100%
function _ZZN12_GLOBAL__N_125TestLegalizePatternDriver14runOnOperationEvENKUlN4test12TestReturnOpEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     377*:  800:    target.addDynamicallyLegalOp<TestReturnOp>([](TestReturnOp op) {
call    0 returned 100%
        -:  801:      // Don't allow F32 operands.
    #####:  802:      return llvm::none_of(op.getOperandTypes(),
call    0 never executed
call    1 never executed
    #####:  803:                           [](Type type) { return type.isF32(); });
        -:  804:    });
function _ZZN12_GLOBAL__N_125TestLegalizePatternDriver14runOnOperationEvENKUlN4mlir4func6FuncOpEE0_clES3_.isra.0 called 919 returned 100% blocks executed 89%
     1296:  805:    target.addDynamicallyLegalOp<func::FuncOp>([&](func::FuncOp op) {
call    0 returned 100%
     1647:  806:      return converter.isSignatureLegal(op.getFunctionType()) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
      728:  807:             converter.isLegal(&op.getBody());
call    0 returned 100%
call    1 returned 100%
        -:  808:    });
      377:  809:    target.addDynamicallyLegalOp<func::CallOp>(
call    0 returned 100%
       80:  810:        [&](func::CallOp op) { return converter.isLegal(op); });
call    0 returned 100%
        -:  811:
        -:  812:    // TestCreateUnregisteredOp creates `arith.constant` operation,
        -:  813:    // which was not added to target intentionally to test
        -:  814:    // correct error code from conversion driver.
     377*:  815:    target.addDynamicallyLegalOp<ILLegalOpG>([](ILLegalOpG) { return false; });
call    0 returned 100%
        -:  816:
        -:  817:    // Expect the type_producer/type_consumer operations to only operate on f64.
      377:  818:    target.addDynamicallyLegalOp<TestTypeProducerOp>(
call    0 returned 100%
    #####:  819:        [](TestTypeProducerOp op) { return op.getType().isF64(); });
call    0 never executed
function _ZZN12_GLOBAL__N_125TestLegalizePatternDriver14runOnOperationEvENKUlN4test18TestTypeConsumerOpEE4_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     377*:  820:    target.addDynamicallyLegalOp<TestTypeConsumerOp>([](TestTypeConsumerOp op) {
call    0 returned 100%
    #####:  821:      return op.getOperand().getType().isF64();
call    0 never executed
call    1 never executed
        -:  822:    });
        -:  823:
        -:  824:    // Check support for marking certain operations as recursively legal.
      754:  825:    target.markOpRecursivelyLegal<func::FuncOp, ModuleOp>([](Operation *op) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1107:  826:      return static_cast<bool>(
call    0 returned 100%
     1107:  827:          op->getAttrOfType<UnitAttr>("test.recursively_legal"));
call    0 returned 100%
        -:  828:    });
        -:  829:
        -:  830:    // Mark the bound recursion operation as dynamically legal.
      377:  831:    target.addDynamicallyLegalOp<TestRecursiveRewriteOp>(
call    0 returned 100%
    #####:  832:        [](TestRecursiveRewriteOp op) { return op.getDepth() == 0; });
call    0 never executed
        -:  833:
        -:  834:    // Handle a partial conversion.
      377:  835:    if (mode == ConversionMode::Partial) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      754:  836:      DenseSet<Operation *> unlegalizedOps;
call    0 returned 100%
     1131:  837:      if (failed(applyPartialConversion(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
      754:  838:              getOperation(), target, std::move(patterns), &unlegalizedOps))) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        3:  839:        getOperation()->emitRemark() << "applyPartialConversion failed";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  840:      }
        -:  841:      // Emit remarks for each legalizable operation.
   786539:  842:      for (auto *op : unlegalizedOps)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
   786162:  843:        op->emitRemark() << "op '" << op->getName() << "' is not legalizable";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
      377:  844:      return;
call    0 returned 100%
        -:  845:    }
        -:  846:
        -:  847:    // Handle a full conversion.
    #####:  848:    if (mode == ConversionMode::Full) {
branch  0 never executed
branch  1 never executed
        -:  849:      // Check support for marking unknown operations as dynamically legal.
    #####:  850:      target.markUnknownOpDynamicallyLegal([](Operation *op) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  851:        return (bool)op->getAttrOfType<UnitAttr>("test.dynamically_legal");
call    0 never executed
        -:  852:      });
        -:  853:
    #####:  854:      if (failed(applyFullConversion(getOperation(), target,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  855:                                     std::move(patterns)))) {
call    0 never executed
    #####:  856:        getOperation()->emitRemark() << "applyFullConversion failed";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  857:      }
    #####:  858:      return;
        -:  859:    }
        -:  860:
        -:  861:    // Otherwise, handle an analysis conversion.
    #####:  862:    assert(mode == ConversionMode::Analysis);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  863:
        -:  864:    // Analyze the convertible operations.
    #####:  865:    DenseSet<Operation *> legalizedOps;
call    0 never executed
call    1 never executed
    #####:  866:    if (failed(applyAnalysisConversion(getOperation(), target,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  867:                                       std::move(patterns), legalizedOps)))
call    0 never executed
     377*:  868:      return signalPassFailure();
call    0 never executed
call    1 never executed
call    2 returned 100%
        -:  869:
        -:  870:    // Emit remarks for each legalizable operation.
    #####:  871:    for (auto *op : legalizedOps)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  872:      op->emitRemark() << "op '" << op->getName() << "' is legalizable";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  873:  }
        -:  874:
        -:  875:  /// The mode of conversion to use.
        -:  876:  ConversionMode mode;
        -:  877:};
        -:  878:} // namespace
        -:  879:
        -:  880:static llvm::cl::opt<TestLegalizePatternDriver::ConversionMode>
        -:  881:    legalizerConversionMode(
        -:  882:        "test-legalize-mode",
        -:  883:        llvm::cl::desc("The legalization mode to use with the test driver"),
        -:  884:        llvm::cl::init(TestLegalizePatternDriver::ConversionMode::Partial),
        -:  885:        llvm::cl::values(
        -:  886:            clEnumValN(TestLegalizePatternDriver::ConversionMode::Analysis,
        -:  887:                       "analysis", "Perform an analysis conversion"),
        -:  888:            clEnumValN(TestLegalizePatternDriver::ConversionMode::Full, "full",
        -:  889:                       "Perform a full conversion"),
        -:  890:            clEnumValN(TestLegalizePatternDriver::ConversionMode::Partial,
        -:  891:                       "partial", "Perform a partial conversion")));
        -:  892:
        -:  893://===----------------------------------------------------------------------===//
        -:  894:// ConversionPatternRewriter::getRemappedValue testing. This method is used
        -:  895:// to get the remapped value of an original value that was replaced using
        -:  896:// ConversionPatternRewriter.
        -:  897:namespace {
      473:  898:struct TestRemapValueTypeConverter : public TypeConverter {
        -:  899:  using TypeConverter::TypeConverter;
        -:  900:
function _ZN12_GLOBAL__N_127TestRemapValueTypeConverterC2Ev called 478 returned 101% blocks executed 100%
      478:  901:  TestRemapValueTypeConverter() {
call    0 returned 100%
      479:  902:    addConversion(
call    0 returned 100%
    #####:  903:        [](Float32Type type) { return Float64Type::get(type.getContext()); });
call    0 never executed
call    1 never executed
     481*:  904:    addConversion([](Type type) { return type; });
call    0 never executed
call    1 returned 100%
      481:  905:  }
        -:  906:};
        -:  907:
        -:  908:/// Converter that replaces a one-result one-operand OneVResOneVOperandOp1 with
        -:  909:/// a one-operand two-result OneVResOneVOperandOp1 by replicating its original
        -:  910:/// operand twice.
        -:  911:///
        -:  912:/// Example:
        -:  913:///   %1 = test.one_variadic_out_one_variadic_in1"(%0)
        -:  914:/// is replaced with:
        -:  915:///   %1 = test.one_variadic_out_one_variadic_in1"(%0, %0)
        -:  916:struct OneVResOneVOperandOp1Converter
        -:  917:    : public OpConversionPattern<OneVResOneVOperandOp1> {
        -:  918:  using OpConversionPattern<OneVResOneVOperandOp1>::OpConversionPattern;
        -:  919:
        -:  920:  LogicalResult
function _ZNK12_GLOBAL__N_130OneVResOneVOperandOp1Converter15matchAndRewriteEN4test21OneVResOneVOperandOp1ENS1_28OneVResOneVOperandOp1AdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  921:  matchAndRewrite(OneVResOneVOperandOp1 op, OpAdaptor adaptor,
        -:  922:                  ConversionPatternRewriter &rewriter) const override {
    #####:  923:    auto origOps = op.getOperands();
call    0 never executed
    #####:  924:    assert(std::distance(origOps.begin(), origOps.end()) == 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  925:           "One operand expected");
    #####:  926:    Value origOp = *origOps.begin();
call    0 never executed
    #####:  927:    SmallVector<Value, 2> remappedOperands;
call    0 never executed
        -:  928:    // Replicate the remapped original operand twice. Note that we don't used
        -:  929:    // the remapped 'operand' since the goal is testing 'getRemappedValue'.
    #####:  930:    remappedOperands.push_back(rewriter.getRemappedValue(origOp));
call    0 never executed
call    1 never executed
    #####:  931:    remappedOperands.push_back(rewriter.getRemappedValue(origOp));
call    0 never executed
call    1 never executed
        -:  932:
    #####:  933:    rewriter.replaceOpWithNewOp<OneVResOneVOperandOp1>(op, op.getResultTypes(),
    #####:  934:                                                       remappedOperands);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  935:    return success();
branch  0 never executed
branch  1 never executed
        -:  936:  }
        -:  937:};
        -:  938:
        -:  939:/// A rewriter pattern that tests that blocks can be merged.
        -:  940:struct TestRemapValueInRegion
        -:  941:    : public OpConversionPattern<TestRemappedValueRegionOp> {
        -:  942:  using OpConversionPattern<TestRemappedValueRegionOp>::OpConversionPattern;
        -:  943:
        -:  944:  LogicalResult
function _ZNK12_GLOBAL__N_122TestRemapValueInRegion15matchAndRewriteEN4test25TestRemappedValueRegionOpENS1_32TestRemappedValueRegionOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  945:  matchAndRewrite(TestRemappedValueRegionOp op, OpAdaptor adaptor,
        -:  946:                  ConversionPatternRewriter &rewriter) const final {
    #####:  947:    Block &block = op.getBody().front();
call    0 never executed
call    1 never executed
    #####:  948:    Operation *terminator = block.getTerminator();
call    0 never executed
        -:  949:
        -:  950:    // Merge the block into the parent region.
    #####:  951:    Block *parentBlock = op->getBlock();
call    0 never executed
    #####:  952:    Block *finalBlock = rewriter.splitBlock(parentBlock, op->getIterator());
call    0 never executed
    #####:  953:    rewriter.mergeBlocks(&block, parentBlock, ValueRange());
call    0 never executed
call    1 never executed
    #####:  954:    rewriter.mergeBlocks(finalBlock, parentBlock, ValueRange());
call    0 never executed
call    1 never executed
        -:  955:
        -:  956:    // Replace the results of this operation with the remapped terminator
        -:  957:    // values.
    #####:  958:    SmallVector<Value> terminatorOperands;
call    0 never executed
    #####:  959:    if (failed(rewriter.getRemappedValues(terminator->getOperands(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  960:                                          terminatorOperands)))
    #####:  961:      return failure();
        -:  962:
    #####:  963:    rewriter.eraseOp(terminator);
call    0 never executed
    #####:  964:    rewriter.replaceOp(op, terminatorOperands);
call    0 never executed
call    1 never executed
    #####:  965:    return success();
branch  0 never executed
branch  1 never executed
        -:  966:  }
        -:  967:};
        -:  968:
   145128:  969:struct TestRemappedValue
call    0 returned 100%
call    1 returned 100%
        -:  970:    : public mlir::PassWrapper<TestRemappedValue, OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_117TestRemappedValue13resolveTypeIDEv called 116688 returned 100% blocks executed 100%
   116688:  971:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestRemappedValue)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  972:
function _ZNK12_GLOBAL__N_117TestRemappedValue11getArgumentEv called 116186 returned 100% blocks executed 100%
   116186:  973:  StringRef getArgument() const final { return "test-remapped-value"; }
function _ZNK12_GLOBAL__N_117TestRemappedValue14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163:  974:  StringRef getDescription() const final {
   116163:  975:    return "Test public remapped value mechanism in ConversionPatternRewriter";
        -:  976:  }
function _ZN12_GLOBAL__N_117TestRemappedValue14runOnOperationEv called 478 returned 99% blocks executed 100%
      478:  977:  void runOnOperation() override {
      478:  978:    TestRemapValueTypeConverter typeConverter;
call    0 returned 101%
        -:  979:
      954:  980:    mlir::RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      480:  981:    patterns.add<OneVResOneVOperandOp1Converter>(&getContext());
call    0 returned 100%
call    1 returned 98%
      471:  982:    patterns.add<TestChangeProducerTypeF32ToF64, TestUpdateConsumerType>(
      471:  983:        &getContext());
call    0 returned 100%
call    1 returned 101%
      475:  984:    patterns.add<TestRemapValueInRegion>(typeConverter, &getContext());
call    0 returned 100%
call    1 returned 101%
        -:  985:
      959:  986:    mlir::ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 98%
call    3 returned 100%
      479:  987:    target.addLegalOp<ModuleOp, func::FuncOp, TestReturnOp>();
call    0 returned 99%
        -:  988:
        -:  989:    // Expect the type_producer/type_consumer operations to only operate on f64.
      476:  990:    target.addDynamicallyLegalOp<TestTypeProducerOp>(
call    0 returned 99%
    #####:  991:        [](TestTypeProducerOp op) { return op.getType().isF64(); });
call    0 never executed
function _ZZN12_GLOBAL__N_117TestRemappedValue14runOnOperationEvENKUlN4test18TestTypeConsumerOpEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     473*:  992:    target.addDynamicallyLegalOp<TestTypeConsumerOp>([](TestTypeConsumerOp op) {
call    0 returned 99%
    #####:  993:      return op.getOperand().getType().isF64();
call    0 never executed
call    1 never executed
        -:  994:    });
        -:  995:
        -:  996:    // We make OneVResOneVOperandOp1 legal only when it has more that one
        -:  997:    // operand. This will trigger the conversion that will replace one-operand
        -:  998:    // OneVResOneVOperandOp1 with two-operand OneVResOneVOperandOp1.
      469:  999:    target.addDynamicallyLegalOp<OneVResOneVOperandOp1>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
function _ZZN12_GLOBAL__N_117TestRemappedValue14runOnOperationEvENKUlPN4mlir9OperationEE1_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1000:        [](Operation *op) { return op->getNumOperands() > 1; });
branch  0 never executed
branch  1 never executed
        -: 1001:
      469: 1002:    if (failed(mlir::applyFullConversion(getOperation(), target,
call    0 returned 101%
call    1 returned 100%
call    2 returned 101%
call    3 returned 100%
branch  4 taken 87% (fallthrough)
branch  5 taken 13%
      469: 1003:                                         std::move(patterns)))) {
call    0 returned 101%
      416: 1004:      signalPassFailure();
call    0 returned 100%
        -: 1005:    }
      472: 1006:  }
        -: 1007:};
        -: 1008:} // namespace
        -: 1009:
        -: 1010://===----------------------------------------------------------------------===//
        -: 1011:// Test patterns without a specific root operation kind
        -: 1012://===----------------------------------------------------------------------===//
        -: 1013:
        -: 1014:namespace {
        -: 1015:/// This pattern matches and removes any operation in the test dialect.
        -: 1016:struct RemoveTestDialectOps : public RewritePattern {
function _ZN12_GLOBAL__N_120RemoveTestDialectOpsC2EPN4mlir11MLIRContextE called 542 returned 100% blocks executed 100%
      542: 1017:  RemoveTestDialectOps(MLIRContext *context)
      542: 1018:      : RewritePattern(MatchAnyOpTypeTag(), /*benefit=*/1, context) {}
call    0 returned 100%
call    1 returned 100%
        -: 1019:
function _ZNK12_GLOBAL__N_120RemoveTestDialectOps15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 1182474 returned 100% blocks executed 56%
  1182474: 1020:  LogicalResult matchAndRewrite(Operation *op,
        -: 1021:                                PatternRewriter &rewriter) const override {
  1182474: 1022:    if (!isa<TestDialect>(op->getDialect()))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
  1182474: 1023:      return failure();
    #####: 1024:    rewriter.eraseOp(op);
call    0 never executed
    #####: 1025:    return success();
        -: 1026:  }
        -: 1027:};
        -: 1028:
   145771: 1029:struct TestUnknownRootOpDriver
call    0 returned 100%
call    1 returned 100%
        -: 1030:    : public mlir::PassWrapper<TestUnknownRootOpDriver,
        -: 1031:                               OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_123TestUnknownRootOpDriver13resolveTypeIDEv called 116683 returned 100% blocks executed 100%
   116683: 1032:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestUnknownRootOpDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1033:
function _ZNK12_GLOBAL__N_123TestUnknownRootOpDriver11getArgumentEv called 116174 returned 100% blocks executed 100%
   116174: 1034:  StringRef getArgument() const final {
   116174: 1035:    return "test-legalize-unknown-root-patterns";
        -: 1036:  }
function _ZNK12_GLOBAL__N_123TestUnknownRootOpDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1037:  StringRef getDescription() const final {
   116163: 1038:    return "Test public remapped value mechanism in ConversionPatternRewriter";
        -: 1039:  }
function _ZN12_GLOBAL__N_123TestUnknownRootOpDriver14runOnOperationEv called 546 returned 100% blocks executed 94%
      546: 1040:  void runOnOperation() override {
      546: 1041:    mlir::RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 99%
      546: 1042:    patterns.add<RemoveTestDialectOps>(&getContext());
call    0 returned 99%
call    1 returned 99%
        -: 1043:
     1083: 1044:    mlir::ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 99%
call    2 returned 98%
call    3 returned 100%
      537: 1045:    target.addIllegalDialect<TestDialect>();
call    0 returned 101%
      541: 1046:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
call    1 returned 100%
call    2 returned 101%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
      541: 1047:                                      std::move(patterns))))
call    0 returned 100%
    #####: 1048:      signalPassFailure();
call    0 never executed
      544: 1049:  }
        -: 1050:};
        -: 1051:} // namespace
        -: 1052:
        -: 1053://===----------------------------------------------------------------------===//
        -: 1054:// Test patterns that uses operations and types defined at runtime
        -: 1055://===----------------------------------------------------------------------===//
        -: 1056:
        -: 1057:namespace {
        -: 1058:/// This pattern matches dynamic operations 'test.one_operand_two_results' and
        -: 1059:/// replace them with dynamic operations 'test.generic_dynamic_op'.
        -: 1060:struct RewriteDynamicOp : public RewritePattern {
function _ZN12_GLOBAL__N_116RewriteDynamicOpC2EPN4mlir11MLIRContextE called 403 returned 100% blocks executed 100%
      403: 1061:  RewriteDynamicOp(MLIRContext *context)
      403: 1062:      : RewritePattern("test.dynamic_one_operand_two_results", /*benefit=*/1,
      403: 1063:                       context) {}
call    0 returned 100%
call    1 returned 100%
        -: 1064:
function _ZNK12_GLOBAL__N_116RewriteDynamicOp15matchAndRewriteEPN4mlir9OperationERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1065:  LogicalResult matchAndRewrite(Operation *op,
        -: 1066:                                PatternRewriter &rewriter) const override {
    #####: 1067:    assert(op->getName().getStringRef() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1068:               "test.dynamic_one_operand_two_results" &&
        -: 1069:           "rewrite pattern should only match operations with the right name");
        -: 1070:
    #####: 1071:    OperationState state(op->getLoc(), "test.dynamic_generic",
        -: 1072:                         op->getOperands(), op->getResultTypes(),
    #####: 1073:                         op->getAttrs());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 1074:    auto *newOp = rewriter.create(state);
call    0 never executed
    #####: 1075:    rewriter.replaceOp(op, newOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1076:    return success();
call    0 never executed
        -: 1077:  }
        -: 1078:};
        -: 1079:
   144326: 1080:struct TestRewriteDynamicOpDriver
call    0 returned 100%
call    1 returned 100%
        -: 1081:    : public PassWrapper<TestRewriteDynamicOpDriver,
        -: 1082:                         OperationPass<func::FuncOp>> {
function _ZN12_GLOBAL__N_126TestRewriteDynamicOpDriver13resolveTypeIDEv called 116678 returned 100% blocks executed 100%
   116678: 1083:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestRewriteDynamicOpDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1084:
function _ZNK12_GLOBAL__N_126TestRewriteDynamicOpDriver20getDependentDialectsERN4mlir15DialectRegistryE called 515 returned 100% blocks executed 100%
      515: 1085:  void getDependentDialects(DialectRegistry &registry) const override {
      515: 1086:    registry.insert<TestDialect>();
call    0 returned 100%
      515: 1087:  }
function _ZNK12_GLOBAL__N_126TestRewriteDynamicOpDriver11getArgumentEv called 116177 returned 100% blocks executed 100%
   116177: 1088:  StringRef getArgument() const final { return "test-rewrite-dynamic-op"; }
function _ZNK12_GLOBAL__N_126TestRewriteDynamicOpDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1089:  StringRef getDescription() const final {
   116163: 1090:    return "Test rewritting on dynamic operations";
        -: 1091:  }
function _ZN12_GLOBAL__N_126TestRewriteDynamicOpDriver14runOnOperationEv called 403 returned 100% blocks executed 95%
      403: 1092:  void runOnOperation() override {
      403: 1093:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      403: 1094:    patterns.add<RewriteDynamicOp>(&getContext());
call    0 returned 100%
call    1 returned 100%
        -: 1095:
      807: 1096:    ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      402: 1097:    target.addIllegalOp(
call    0 returned 100%
call    1 returned 100%
      402: 1098:        OperationName("test.dynamic_one_operand_two_results", &getContext()));
call    0 returned 100%
call    1 returned 100%
      402: 1099:    target.addLegalOp(OperationName("test.dynamic_generic", &getContext()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      403: 1100:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
      403: 1101:                                      std::move(patterns))))
call    0 returned 100%
    #####: 1102:      signalPassFailure();
call    0 never executed
      403: 1103:  }
        -: 1104:};
        -: 1105:} // end anonymous namespace
        -: 1106:
        -: 1107://===----------------------------------------------------------------------===//
        -: 1108:// Test type conversions
        -: 1109://===----------------------------------------------------------------------===//
        -: 1110:
        -: 1111:namespace {
        -: 1112:struct TestTypeConversionProducer
        -: 1113:    : public OpConversionPattern<TestTypeProducerOp> {
        -: 1114:  using OpConversionPattern<TestTypeProducerOp>::OpConversionPattern;
        -: 1115:  LogicalResult
function _ZNK12_GLOBAL__N_126TestTypeConversionProducer15matchAndRewriteEN4test18TestTypeProducerOpENS1_25TestTypeProducerOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1116:  matchAndRewrite(TestTypeProducerOp op, OpAdaptor adaptor,
        -: 1117:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1118:    Type resultType = op.getType();
branch  0 never executed
branch  1 never executed
    #####: 1119:    Type convertedType = getTypeConverter()
branch  0 never executed
branch  1 never executed
    #####: 1120:                             ? getTypeConverter()->convertType(resultType)
call    0 never executed
    #####: 1121:                             : resultType;
branch  0 never executed
branch  1 never executed
    #####: 1122:    if (resultType.isa<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1123:      resultType = rewriter.getF64Type();
call    0 never executed
    #####: 1124:    else if (resultType.isInteger(16))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1125:      resultType = rewriter.getIntegerType(64);
call    0 never executed
    #####: 1126:    else if (resultType.isa<test::TestRecursiveType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1127:             convertedType != resultType)
branch  0 never executed
branch  1 never executed
    #####: 1128:      resultType = convertedType;
        -: 1129:    else
    #####: 1130:      return failure();
        -: 1131:
    #####: 1132:    rewriter.replaceOpWithNewOp<TestTypeProducerOp>(op, resultType);
call    0 never executed
    #####: 1133:    return success();
        -: 1134:  }
        -: 1135:};
        -: 1136:
        -: 1137:/// Call signature conversion and then fail the rewrite to trigger the undo
        -: 1138:/// mechanism.
        -: 1139:struct TestSignatureConversionUndo
        -: 1140:    : public OpConversionPattern<TestSignatureConversionUndoOp> {
        -: 1141:  using OpConversionPattern<TestSignatureConversionUndoOp>::OpConversionPattern;
        -: 1142:
        -: 1143:  LogicalResult
function _ZNK12_GLOBAL__N_127TestSignatureConversionUndo15matchAndRewriteEN4test29TestSignatureConversionUndoOpENS1_36TestSignatureConversionUndoOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1144:  matchAndRewrite(TestSignatureConversionUndoOp op, OpAdaptor adaptor,
        -: 1145:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1146:    (void)rewriter.convertRegionTypes(&op->getRegion(0), *getTypeConverter());
call    0 never executed
call    1 never executed
    #####: 1147:    return failure();
        -: 1148:  }
        -: 1149:};
        -: 1150:
        -: 1151:/// Call signature conversion without providing a type converter to handle
        -: 1152:/// materializations.
        -: 1153:struct TestTestSignatureConversionNoConverter
        -: 1154:    : public OpConversionPattern<TestSignatureConversionNoConverterOp> {
        -: 1155:  TestTestSignatureConversionNoConverter(TypeConverter &converter,
        -: 1156:                                         MLIRContext *context)
        -: 1157:      : OpConversionPattern<TestSignatureConversionNoConverterOp>(context),
        -: 1158:        converter(converter) {}
        -: 1159:
        -: 1160:  LogicalResult
function _ZNK12_GLOBAL__N_138TestTestSignatureConversionNoConverter15matchAndRewriteEN4test36TestSignatureConversionNoConverterOpENS1_43TestSignatureConversionNoConverterOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1161:  matchAndRewrite(TestSignatureConversionNoConverterOp op, OpAdaptor adaptor,
        -: 1162:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1163:    Region &region = op->getRegion(0);
call    0 never executed
    #####: 1164:    Block *entry = &region.front();
call    0 never executed
        -: 1165:
        -: 1166:    // Convert the original entry arguments.
    #####: 1167:    TypeConverter::SignatureConversion result(entry->getNumArguments());
call    0 never executed
    #####: 1168:    if (failed(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1169:            converter.convertSignatureArgs(entry->getArgumentTypes(), result)))
call    0 never executed
    #####: 1170:      return failure();
    #####: 1171:    rewriter.updateRootInPlace(
call    0 never executed
    #####: 1172:        op, [&] { rewriter.applySignatureConversion(&region, result); });
call    0 never executed
    #####: 1173:    return success();
call    0 never executed
        -: 1174:  }
        -: 1175:
        -: 1176:  TypeConverter &converter;
        -: 1177:};
        -: 1178:
        -: 1179:/// Just forward the operands to the root op. This is essentially a no-op
        -: 1180:/// pattern that is used to trigger target materialization.
        -: 1181:struct TestTypeConsumerForward
        -: 1182:    : public OpConversionPattern<TestTypeConsumerOp> {
        -: 1183:  using OpConversionPattern<TestTypeConsumerOp>::OpConversionPattern;
        -: 1184:
        -: 1185:  LogicalResult
function _ZNK12_GLOBAL__N_123TestTypeConsumerForward15matchAndRewriteEN4test18TestTypeConsumerOpENS1_25TestTypeConsumerOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1186:  matchAndRewrite(TestTypeConsumerOp op, OpAdaptor adaptor,
        -: 1187:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1188:    rewriter.updateRootInPlace(op,
call    0 never executed
    #####: 1189:                               [&] { op->setOperands(adaptor.getOperands()); });
call    0 never executed
call    1 never executed
    #####: 1190:    return success();
        -: 1191:  }
        -: 1192:};
        -: 1193:
        -: 1194:struct TestTypeConversionAnotherProducer
        -: 1195:    : public OpRewritePattern<TestAnotherTypeProducerOp> {
        -: 1196:  using OpRewritePattern<TestAnotherTypeProducerOp>::OpRewritePattern;
        -: 1197:
function _ZNK12_GLOBAL__N_133TestTypeConversionAnotherProducer15matchAndRewriteEN4test25TestAnotherTypeProducerOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1198:  LogicalResult matchAndRewrite(TestAnotherTypeProducerOp op,
        -: 1199:                                PatternRewriter &rewriter) const final {
    #####: 1200:    rewriter.replaceOpWithNewOp<TestTypeProducerOp>(op, op.getType());
call    0 never executed
    #####: 1201:    return success();
        -: 1202:  }
        -: 1203:};
        -: 1204:
  116717*: 1205:struct TestTypeConversionDriver
call    0 never executed
call    1 returned 100%
        -: 1206:    : public PassWrapper<TestTypeConversionDriver, OperationPass<ModuleOp>> {
function _ZN12_GLOBAL__N_124TestTypeConversionDriver13resolveTypeIDEv called 116717 returned 100% blocks executed 100%
   116717: 1207:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestTypeConversionDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1208:
function _ZNK12_GLOBAL__N_124TestTypeConversionDriver20getDependentDialectsERN4mlir15DialectRegistryE called 554 returned 100% blocks executed 100%
      554: 1209:  void getDependentDialects(DialectRegistry &registry) const override {
      554: 1210:    registry.insert<TestDialect>();
call    0 returned 100%
      554: 1211:  }
function _ZNK12_GLOBAL__N_124TestTypeConversionDriver11getArgumentEv called 116186 returned 100% blocks executed 100%
   116186: 1212:  StringRef getArgument() const final {
   116186: 1213:    return "test-legalize-type-conversion";
        -: 1214:  }
function _ZNK12_GLOBAL__N_124TestTypeConversionDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1215:  StringRef getDescription() const final {
   116163: 1216:    return "Test various type conversion functionalities in DialectConversion";
        -: 1217:  }
        -: 1218:
function _ZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEv called 408 returned 100% blocks executed 100%
      408: 1219:  void runOnOperation() override {
        -: 1220:    // Initialize the type converter.
      816: 1221:    TypeConverter converter;
call    0 returned 100%
call    1 returned 100%
        -: 1222:
        -: 1223:    /// Add the legal set of type conversions.
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4mlir4TypeEE_clES2_.isra.0 called 421 returned 100% blocks executed 100%
      829: 1224:    converter.addConversion([](Type type) -> Type {
call    0 returned 100%
        -: 1225:      // Treat F64 as legal.
      421: 1226:      if (type.isF64())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        5: 1227:        return type;
        -: 1228:      // Allow converting BF16/F16/F32 to F64.
      416: 1229:      if (type.isBF16() || type.isF16() || type.isF32())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 98% (fallthrough)
branch  5 taken 2%
call    6 returned 100%
branch  7 taken 8% (fallthrough)
branch  8 taken 92%
       41: 1230:        return FloatType::getF64(type.getContext());
call    0 returned 100%
call    1 returned 100%
        -: 1231:      // Otherwise, the type is illegal.
      375: 1232:      return nullptr;
        -: 1233:    });
      408: 1234:    converter.addConversion([](IntegerType type, SmallVectorImpl<Type> &) {
call    0 returned 100%
        -: 1235:      // Drop all integer types.
       53: 1236:      return success();
        -: 1237:    });
      408: 1238:    converter.addConversion(
call    0 returned 100%
        -: 1239:        // Convert a recursive self-referring type into a non-self-referring
        -: 1240:        // type named "outer_converted_type" that contains a SimpleAType.
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4test17TestRecursiveTypeERN4llvm15SmallVectorImplIN4mlir4TypeEEENS3_8ArrayRefIS6_EEE1_clES2_S8_SA_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1241:        [&](test::TestRecursiveType type, SmallVectorImpl<Type> &results,
        -: 1242:            ArrayRef<Type> callStack) -> Optional<LogicalResult> {
        -: 1243:          // If the type is already converted, return it to indicate that it is
        -: 1244:          // legal.
    #####: 1245:          if (type.getName() == "outer_converted_type") {
branch  0 never executed
branch  1 never executed
    #####: 1246:            results.push_back(type);
call    0 never executed
    #####: 1247:            return success();
        -: 1248:          }
        -: 1249:
        -: 1250:          // If the type is on the call stack more than once (it is there at
        -: 1251:          // least once because of the _current_ call, which is always the last
        -: 1252:          // element on the stack), we've hit the recursive case. Just return
        -: 1253:          // SimpleAType here to create a non-recursive type as a result.
    #####: 1254:          if (llvm::is_contained(callStack.drop_back(), type)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1255:            results.push_back(test::SimpleAType::get(type.getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1256:            return success();
        -: 1257:          }
        -: 1258:
        -: 1259:          // Convert the body recursively.
    #####: 1260:          auto result = test::TestRecursiveType::get(type.getContext(),
call    0 never executed
    #####: 1261:                                                     "outer_converted_type");
call    0 never executed
call    1 never executed
    #####: 1262:          if (failed(result.setBody(converter.convertType(type.getBody()))))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1263:            return failure();
    #####: 1264:          results.push_back(result);
call    0 never executed
    #####: 1265:          return success();
        -: 1266:        });
        -: 1267:
        -: 1268:    /// Add the legal set of type materializations.
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlRN4mlir9OpBuilderENS1_4TypeENS1_10ValueRangeENS1_8LocationEE2_clES3_S4_S5_S6_.isra.0 called 0 returned 0% blocks executed 0%
     408*: 1269:    converter.addSourceMaterialization([](OpBuilder &builder, Type resultType,
call    0 returned 100%
        -: 1270:                                          ValueRange inputs,
        -: 1271:                                          Location loc) -> Value {
        -: 1272:      // Allow casting from F64 back to F32.
    #####: 1273:      if (!resultType.isF16() && inputs.size() == 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1274:          inputs[0].getType().isF64())
call    0 never executed
call    1 never executed
    #####: 1275:        return builder.create<TestCastOp>(loc, resultType, inputs).getResult();
call    0 never executed
        -: 1276:      // Allow producing an i32 or i64 from nothing.
    #####: 1277:      if ((resultType.isInteger(32) || resultType.isInteger(64)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1278:          inputs.empty())
branch  0 never executed
branch  1 never executed
    #####: 1279:        return builder.create<TestTypeProducerOp>(loc, resultType);
call    0 never executed
        -: 1280:      // Allow producing an i64 from an integer.
    #####: 1281:      if (resultType.isa<IntegerType>() && inputs.size() == 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1282:          inputs[0].getType().isa<IntegerType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1283:        return builder.create<TestCastOp>(loc, resultType, inputs).getResult();
call    0 never executed
        -: 1284:      // Otherwise, fail.
    #####: 1285:      return nullptr;
        -: 1286:    });
        -: 1287:
        -: 1288:    // Initialize the conversion target.
      408: 1289:    mlir::ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4test18TestTypeProducerOpEE3_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     408*: 1290:    target.addDynamicallyLegalOp<TestTypeProducerOp>([](TestTypeProducerOp op) {
call    0 returned 100%
    #####: 1291:      auto recursiveType = op.getType().dyn_cast<test::TestRecursiveType>();
call    0 never executed
    #####: 1292:      return op.getType().isF64() || op.getType().isInteger(64) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1293:             (recursiveType &&
    #####: 1294:              recursiveType.getName() == "outer_converted_type");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1295:    });
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4mlir4func6FuncOpEE4_clES3_.isra.0 called 1256 returned 100% blocks executed 100%
     1664: 1296:    target.addDynamicallyLegalOp<func::FuncOp>([&](func::FuncOp op) {
call    0 returned 100%
     1343: 1297:      return converter.isSignatureLegal(op.getFunctionType()) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
branch  4 taken 3% (fallthrough)
branch  5 taken 97%
       87: 1298:             converter.isLegal(&op.getBody());
call    0 returned 100%
call    1 returned 100%
        -: 1299:    });
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4test10TestCastOpEE5_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     408*: 1300:    target.addDynamicallyLegalOp<TestCastOp>([&](TestCastOp op) {
call    0 returned 100%
        -: 1301:      // Allow casts from F64 to F32.
    #####: 1302:      return (*op.operand_type_begin()).isF64() && op.getType().isF32();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 1303:    });
      408: 1304:    target.addDynamicallyLegalOp<TestSignatureConversionNoConverterOp>(
call    0 returned 100%
function _ZZN12_GLOBAL__N_124TestTypeConversionDriver14runOnOperationEvENKUlN4test36TestSignatureConversionNoConverterOpEE6_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1305:        [&](TestSignatureConversionNoConverterOp op) {
    #####: 1306:          return converter.isLegal(op.getRegion().front().getArgumentTypes());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1307:        });
        -: 1308:
        -: 1309:    // Initialize the set of rewrite patterns.
      816: 1310:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      408: 1311:    patterns.add<TestTypeConsumerForward, TestTypeConversionProducer,
        -: 1312:                 TestSignatureConversionUndo,
        -: 1313:                 TestTestSignatureConversionNoConverter>(converter,
      408: 1314:                                                         &getContext());
call    0 returned 100%
call    1 returned 100%
      408: 1315:    patterns.add<TestTypeConversionAnotherProducer>(&getContext());
call    0 returned 100%
call    1 returned 100%
      408: 1316:    mlir::populateFunctionOpInterfaceTypeConversionPattern<func::FuncOp>(
call    0 returned 100%
        -: 1317:        patterns, converter);
        -: 1318:
      408: 1319:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 88% (fallthrough)
branch  5 taken 12%
      408: 1320:                                      std::move(patterns))))
call    0 returned 100%
      359: 1321:      signalPassFailure();
call    0 returned 100%
      408: 1322:  }
        -: 1323:};
        -: 1324:} // namespace
        -: 1325:
        -: 1326://===----------------------------------------------------------------------===//
        -: 1327:// Test Target Materialization With No Uses
        -: 1328://===----------------------------------------------------------------------===//
        -: 1329:
        -: 1330:namespace {
        -: 1331:struct ForwardOperandPattern : public OpConversionPattern<TestTypeChangerOp> {
        -: 1332:  using OpConversionPattern<TestTypeChangerOp>::OpConversionPattern;
        -: 1333:
        -: 1334:  LogicalResult
function _ZNK12_GLOBAL__N_121ForwardOperandPattern15matchAndRewriteEN4test17TestTypeChangerOpENS1_24TestTypeChangerOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1335:  matchAndRewrite(TestTypeChangerOp op, OpAdaptor adaptor,
        -: 1336:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1337:    rewriter.replaceOp(op, adaptor.getOperands());
call    0 never executed
call    1 never executed
    #####: 1338:    return success();
        -: 1339:  }
        -: 1340:};
        -: 1341:
  116641*: 1342:struct TestTargetMaterializationWithNoUses
call    0 never executed
call    1 returned 100%
        -: 1343:    : public PassWrapper<TestTargetMaterializationWithNoUses,
        -: 1344:                         OperationPass<ModuleOp>> {
function _ZN12_GLOBAL__N_135TestTargetMaterializationWithNoUses13resolveTypeIDEv called 116641 returned 100% blocks executed 100%
   116641: 1345:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1346:      TestTargetMaterializationWithNoUses)
        -: 1347:
function _ZNK12_GLOBAL__N_135TestTargetMaterializationWithNoUses11getArgumentEv called 116185 returned 100% blocks executed 100%
   116185: 1348:  StringRef getArgument() const final {
   116185: 1349:    return "test-target-materialization-with-no-uses";
        -: 1350:  }
function _ZNK12_GLOBAL__N_135TestTargetMaterializationWithNoUses14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1351:  StringRef getDescription() const final {
   116163: 1352:    return "Test a special case of target materialization in DialectConversion";
        -: 1353:  }
        -: 1354:
function _ZN12_GLOBAL__N_135TestTargetMaterializationWithNoUses14runOnOperationEv called 365 returned 100% blocks executed 95%
      365: 1355:  void runOnOperation() override {
      730: 1356:    TypeConverter converter;
call    0 returned 100%
call    1 returned 100%
     365*: 1357:    converter.addConversion([](Type t) { return t; });
call    0 never executed
call    1 returned 100%
function _ZZN12_GLOBAL__N_135TestTargetMaterializationWithNoUses14runOnOperationEvENKUlN4mlir11IntegerTypeEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
     365*: 1358:    converter.addConversion([](IntegerType intTy) -> Type {
call    0 returned 100%
    #####: 1359:      if (intTy.getWidth() == 16)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1360:        return IntegerType::get(intTy.getContext(), 64);
call    0 never executed
call    1 never executed
    #####: 1361:      return intTy;
        -: 1362:    });
      365: 1363:    converter.addTargetMaterialization(
call    0 returned 100%
    #####: 1364:        [](OpBuilder &builder, Type type, ValueRange inputs, Location loc) {
    #####: 1365:          return builder.create<TestCastOp>(loc, type, inputs).getResult();
call    0 never executed
        -: 1366:        });
        -: 1367:
      365: 1368:    ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
      365: 1369:    target.addIllegalOp<TestTypeChangerOp>();
call    0 returned 100%
        -: 1370:
      730: 1371:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      365: 1372:    patterns.add<ForwardOperandPattern>(converter, &getContext());
call    0 returned 100%
call    1 returned 100%
        -: 1373:
      365: 1374:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
      365: 1375:                                      std::move(patterns))))
call    0 returned 100%
    #####: 1376:      signalPassFailure();
call    0 never executed
      365: 1377:  }
        -: 1378:};
        -: 1379:} // namespace
        -: 1380:
        -: 1381://===----------------------------------------------------------------------===//
        -: 1382:// Test Block Merging
        -: 1383://===----------------------------------------------------------------------===//
        -: 1384:
        -: 1385:namespace {
        -: 1386:/// A rewriter pattern that tests that blocks can be merged.
        -: 1387:struct TestMergeBlock : public OpConversionPattern<TestMergeBlocksOp> {
        -: 1388:  using OpConversionPattern<TestMergeBlocksOp>::OpConversionPattern;
        -: 1389:
        -: 1390:  LogicalResult
function _ZNK12_GLOBAL__N_114TestMergeBlock15matchAndRewriteEN4test17TestMergeBlocksOpENS1_24TestMergeBlocksOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1391:  matchAndRewrite(TestMergeBlocksOp op, OpAdaptor adaptor,
        -: 1392:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1393:    Block &firstBlock = op.getBody().front();
call    0 never executed
call    1 never executed
    #####: 1394:    Operation *branchOp = firstBlock.getTerminator();
call    0 never executed
    #####: 1395:    Block *secondBlock = &*(std::next(op.getBody().begin()));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1396:    auto succOperands = branchOp->getOperands();
call    0 never executed
    #####: 1397:    SmallVector<Value, 2> replacements(succOperands);
call    0 never executed
    #####: 1398:    rewriter.eraseOp(branchOp);
call    0 never executed
    #####: 1399:    rewriter.mergeBlocks(secondBlock, &firstBlock, replacements);
call    0 never executed
call    1 never executed
    #####: 1400:    rewriter.updateRootInPlace(op, [] {});
call    0 never executed
call    1 never executed
    #####: 1401:    return success();
branch  0 never executed
branch  1 never executed
        -: 1402:  }
        -: 1403:};
        -: 1404:
        -: 1405:/// A rewrite pattern to tests the undo mechanism of blocks being merged.
        -: 1406:struct TestUndoBlocksMerge : public ConversionPattern {
function _ZN12_GLOBAL__N_119TestUndoBlocksMergeC2EPN4mlir11MLIRContextE called 396 returned 100% blocks executed 100%
      396: 1407:  TestUndoBlocksMerge(MLIRContext *ctx)
      396: 1408:      : ConversionPattern("test.undo_blocks_merge", /*benefit=*/1, ctx) {}
call    0 returned 100%
call    1 returned 100%
        -: 1409:  LogicalResult
function _ZNK12_GLOBAL__N_119TestUndoBlocksMerge15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1410:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -: 1411:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1412:    Block &firstBlock = op->getRegion(0).front();
call    0 never executed
call    1 never executed
    #####: 1413:    Operation *branchOp = firstBlock.getTerminator();
call    0 never executed
    #####: 1414:    Block *secondBlock = &*(std::next(op->getRegion(0).begin()));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1415:    rewriter.setInsertionPointToStart(secondBlock);
call    0 never executed
    #####: 1416:    rewriter.create<ILLegalOpF>(op->getLoc(), rewriter.getF32Type());
call    0 never executed
call    1 never executed
    #####: 1417:    auto succOperands = branchOp->getOperands();
call    0 never executed
    #####: 1418:    SmallVector<Value, 2> replacements(succOperands);
call    0 never executed
    #####: 1419:    rewriter.eraseOp(branchOp);
call    0 never executed
    #####: 1420:    rewriter.mergeBlocks(secondBlock, &firstBlock, replacements);
call    0 never executed
call    1 never executed
    #####: 1421:    rewriter.updateRootInPlace(op, [] {});
call    0 never executed
call    1 never executed
    #####: 1422:    return success();
branch  0 never executed
branch  1 never executed
        -: 1423:  }
        -: 1424:};
        -: 1425:
        -: 1426:/// A rewrite mechanism to inline the body of the op into its parent, when both
        -: 1427:/// ops can have a single block.
        -: 1428:struct TestMergeSingleBlockOps
        -: 1429:    : public OpConversionPattern<SingleBlockImplicitTerminatorOp> {
        -: 1430:  using OpConversionPattern<
        -: 1431:      SingleBlockImplicitTerminatorOp>::OpConversionPattern;
        -: 1432:
        -: 1433:  LogicalResult
function _ZNK12_GLOBAL__N_123TestMergeSingleBlockOps15matchAndRewriteEN4test31SingleBlockImplicitTerminatorOpENS1_38SingleBlockImplicitTerminatorOpAdaptorERN4mlir25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1434:  matchAndRewrite(SingleBlockImplicitTerminatorOp op, OpAdaptor adaptor,
        -: 1435:                  ConversionPatternRewriter &rewriter) const final {
    #####: 1436:    SingleBlockImplicitTerminatorOp parentOp =
    #####: 1437:        op->getParentOfType<SingleBlockImplicitTerminatorOp>();
call    0 never executed
    #####: 1438:    if (!parentOp)
branch  0 never executed
branch  1 never executed
    #####: 1439:      return failure();
    #####: 1440:    Block &innerBlock = op.getRegion().front();
call    0 never executed
call    1 never executed
    #####: 1441:    TerminatorOp innerTerminator =
    #####: 1442:        cast<TerminatorOp>(innerBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####: 1443:    rewriter.mergeBlockBefore(&innerBlock, op);
call    0 never executed
call    1 never executed
    #####: 1444:    rewriter.eraseOp(innerTerminator);
call    0 never executed
    #####: 1445:    rewriter.eraseOp(op);
call    0 never executed
    #####: 1446:    rewriter.updateRootInPlace(op, [] {});
call    0 never executed
call    1 never executed
    #####: 1447:    return success();
        -: 1448:  }
        -: 1449:};
        -: 1450:
  116717*: 1451:struct TestMergeBlocksPatternDriver
call    0 never executed
call    1 returned 100%
        -: 1452:    : public PassWrapper<TestMergeBlocksPatternDriver,
        -: 1453:                         OperationPass<ModuleOp>> {
function _ZN12_GLOBAL__N_128TestMergeBlocksPatternDriver13resolveTypeIDEv called 116717 returned 100% blocks executed 100%
   116717: 1454:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TestMergeBlocksPatternDriver)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1455:
function _ZNK12_GLOBAL__N_128TestMergeBlocksPatternDriver11getArgumentEv called 116175 returned 100% blocks executed 100%
   116175: 1456:  StringRef getArgument() const final { return "test-merge-blocks"; }
function _ZNK12_GLOBAL__N_128TestMergeBlocksPatternDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1457:  StringRef getDescription() const final {
   116163: 1458:    return "Test Merging operation in ConversionPatternRewriter";
        -: 1459:  }
function _ZN12_GLOBAL__N_128TestMergeBlocksPatternDriver14runOnOperationEv called 396 returned 100% blocks executed 100%
      396: 1460:  void runOnOperation() override {
      396: 1461:    MLIRContext *context = &getContext();
call    0 returned 100%
      396: 1462:    mlir::RewritePatternSet patterns(context);
call    0 returned 100%
      396: 1463:    patterns.add<TestMergeBlock, TestUndoBlocksMerge, TestMergeSingleBlockOps>(
      396: 1464:        context);
call    0 returned 100%
      792: 1465:    ConversionTarget target(*context);
call    0 returned 100%
call    1 returned 100%
      396: 1466:    target.addLegalOp<func::FuncOp, ModuleOp, TerminatorOp, TestBranchOp,
      396: 1467:                      TestTypeConsumerOp, TestTypeProducerOp, TestReturnOp>();
call    0 returned 100%
      396: 1468:    target.addIllegalOp<ILLegalOpF>();
call    0 returned 100%
        -: 1469:
        -: 1470:    /// Expect the op to have a single block after legalization.
      396: 1471:    target.addDynamicallyLegalOp<TestMergeBlocksOp>(
call    0 returned 100%
    #####: 1472:        [&](TestMergeBlocksOp op) -> bool {
    #####: 1473:          return llvm::hasSingleElement(op.getBody());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1474:        });
        -: 1475:
        -: 1476:    /// Only allow `test.br` within test.merge_blocks op.
     396*: 1477:    target.addDynamicallyLegalOp<TestBranchOp>([&](TestBranchOp op) -> bool {
call    0 returned 100%
    #####: 1478:      return op->getParentOfType<TestMergeBlocksOp>();
call    0 never executed
        -: 1479:    });
        -: 1480:
        -: 1481:    /// Expect that all nested test.SingleBlockImplicitTerminator ops are
        -: 1482:    /// inlined.
      396: 1483:    target.addDynamicallyLegalOp<SingleBlockImplicitTerminatorOp>(
call    0 returned 100%
    #####: 1484:        [&](SingleBlockImplicitTerminatorOp op) -> bool {
    #####: 1485:          return !op->getParentOfType<SingleBlockImplicitTerminatorOp>();
call    0 never executed
        -: 1486:        });
        -: 1487:
      792: 1488:    DenseSet<Operation *> unlegalizedOps;
call    0 returned 100%
call    1 returned 100%
      396: 1489:    (void)applyPartialConversion(getOperation(), target, std::move(patterns),
call    0 returned 100%
call    1 returned 100%
      792: 1490:                                 &unlegalizedOps);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   768048: 1491:    for (auto *op : unlegalizedOps)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
   767652: 1492:      op->emitRemark() << "op '" << op->getName() << "' is not legalizable";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
      396: 1493:  }
        -: 1494:};
        -: 1495:} // namespace
        -: 1496:
        -: 1497://===----------------------------------------------------------------------===//
        -: 1498:// Test Selective Replacement
        -: 1499://===----------------------------------------------------------------------===//
        -: 1500:
        -: 1501:namespace {
        -: 1502:/// A rewrite mechanism to inline the body of the op into its parent, when both
        -: 1503:/// ops can have a single block.
        -: 1504:struct TestSelectiveOpReplacementPattern : public OpRewritePattern<TestCastOp> {
        -: 1505:  using OpRewritePattern<TestCastOp>::OpRewritePattern;
        -: 1506:
function _ZNK12_GLOBAL__N_133TestSelectiveOpReplacementPattern15matchAndRewriteEN4test10TestCastOpERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1507:  LogicalResult matchAndRewrite(TestCastOp op,
        -: 1508:                                PatternRewriter &rewriter) const final {
    #####: 1509:    if (op.getNumOperands() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1510:      return failure();
    #####: 1511:    OperandRange operands = op.getOperands();
call    0 never executed
        -: 1512:
        -: 1513:    // Replace non-terminator uses with the first operand.
    #####: 1514:    rewriter.replaceOpWithIf(op, operands[0], [](OpOperand &operand) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1515:      return operand.getOwner()->hasTrait<OpTrait::IsTerminator>();
call    0 never executed
        -: 1516:    });
        -: 1517:    // Replace everything else with the second operand if the operation isn't
        -: 1518:    // dead.
    #####: 1519:    rewriter.replaceOp(op, op.getOperand(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1520:    return success();
        -: 1521:  }
        -: 1522:};
        -: 1523:
  116676*: 1524:struct TestSelectiveReplacementPatternDriver
call    0 never executed
call    1 returned 100%
        -: 1525:    : public PassWrapper<TestSelectiveReplacementPatternDriver,
        -: 1526:                         OperationPass<>> {
function _ZN12_GLOBAL__N_137TestSelectiveReplacementPatternDriver13resolveTypeIDEv called 116676 returned 100% blocks executed 100%
   116676: 1527:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -: 1528:      TestSelectiveReplacementPatternDriver)
        -: 1529:
function _ZNK12_GLOBAL__N_137TestSelectiveReplacementPatternDriver11getArgumentEv called 116181 returned 100% blocks executed 100%
   116181: 1530:  StringRef getArgument() const final {
   116181: 1531:    return "test-pattern-selective-replacement";
        -: 1532:  }
function _ZNK12_GLOBAL__N_137TestSelectiveReplacementPatternDriver14getDescriptionEv called 116163 returned 100% blocks executed 100%
   116163: 1533:  StringRef getDescription() const final {
   116163: 1534:    return "Test selective replacement in the PatternRewriter";
        -: 1535:  }
function _ZN12_GLOBAL__N_137TestSelectiveReplacementPatternDriver14runOnOperationEv called 389 returned 100% blocks executed 92%
      389: 1536:  void runOnOperation() override {
      389: 1537:    MLIRContext *context = &getContext();
call    0 returned 100%
      389: 1538:    mlir::RewritePatternSet patterns(context);
call    0 returned 100%
      389: 1539:    patterns.add<TestSelectiveOpReplacementPattern>(context);
call    0 returned 100%
      389: 1540:    (void)applyPatternsAndFoldGreedily(getOperation()->getRegions(),
      778: 1541:                                       std::move(patterns));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
      389: 1542:  }
        -: 1543:};
        -: 1544:} // namespace
        -: 1545:
        -: 1546://===----------------------------------------------------------------------===//
        -: 1547:// PassRegistration
        -: 1548://===----------------------------------------------------------------------===//
        -: 1549:
        -: 1550:namespace mlir {
        -: 1551:namespace test {
function _ZN4mlir4test24registerPatternsTestPassEv called 116163 returned 100% blocks executed 100%
   116163: 1552:void registerPatternsTestPass() {
   116163: 1553:  PassRegistration<TestReturnTypeDriver>();
call    0 returned 100%
        -: 1554:
   116163: 1555:  PassRegistration<TestDerivedAttributeDriver>();
call    0 returned 100%
        -: 1556:
   116163: 1557:  PassRegistration<TestPatternDriver>();
call    0 returned 100%
   116163: 1558:  PassRegistration<TestStrictPatternDriver>();
call    0 returned 100%
        -: 1559:
   116163: 1560:  PassRegistration<TestLegalizePatternDriver>([] {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   116677: 1561:    return std::make_unique<TestLegalizePatternDriver>(legalizerConversionMode);
call    0 returned 100%
        -: 1562:  });
        -: 1563:
   116163: 1564:  PassRegistration<TestRemappedValue>();
call    0 returned 100%
        -: 1565:
   116163: 1566:  PassRegistration<TestUnknownRootOpDriver>();
call    0 returned 100%
        -: 1567:
   116163: 1568:  PassRegistration<TestTypeConversionDriver>();
call    0 returned 100%
   116163: 1569:  PassRegistration<TestTargetMaterializationWithNoUses>();
call    0 returned 100%
        -: 1570:
   116163: 1571:  PassRegistration<TestRewriteDynamicOpDriver>();
call    0 returned 100%
        -: 1572:
   116163: 1573:  PassRegistration<TestMergeBlocksPatternDriver>();
call    0 returned 100%
   116163: 1574:  PassRegistration<TestSelectiveReplacementPatternDriver>();
call    0 returned 100%
   116163: 1575:}
        -: 1576:} // namespace test
        -: 1577:} // namespace mlir
