        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Dialect/LLVMIR/LLVMTypes.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:116169
        -:    1://===- LLVMTypes.h - MLIR LLVM dialect types --------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the types for the LLVM dialect in MLIR. These MLIR types
        -:   10:// correspond to the LLVM IR type system.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef MLIR_DIALECT_LLVMIR_LLVMTYPES_H_
        -:   15:#define MLIR_DIALECT_LLVMIR_LLVMTYPES_H_
        -:   16:
        -:   17:#include "mlir/IR/SubElementInterfaces.h"
        -:   18:#include "mlir/IR/Types.h"
        -:   19:#include "mlir/Interfaces/DataLayoutInterfaces.h"
        -:   20:
        -:   21:namespace llvm {
        -:   22:class ElementCount;
        -:   23:class TypeSize;
        -:   24:} // namespace llvm
        -:   25:
        -:   26:namespace mlir {
        -:   27:
        -:   28:class AsmParser;
        -:   29:class AsmPrinter;
        -:   30:
        -:   31:namespace LLVM {
        -:   32:class LLVMDialect;
        -:   33:
        -:   34:namespace detail {
        -:   35:struct LLVMFunctionTypeStorage;
        -:   36:struct LLVMPointerTypeStorage;
        -:   37:struct LLVMStructTypeStorage;
        -:   38:struct LLVMTypeAndSizeStorage;
        -:   39:} // namespace detail
        -:   40:} // namespace LLVM
        -:   41:} // namespace mlir
        -:   42:
        -:   43://===----------------------------------------------------------------------===//
        -:   44:// ODS-Generated Declarations
        -:   45://===----------------------------------------------------------------------===//
        -:   46:
        -:   47:#include "mlir/Dialect/LLVMIR/LLVMTypeInterfaces.h.inc"
        -:   48:
        -:   49:#define GET_TYPEDEF_CLASSES
        -:   50:#include "mlir/Dialect/LLVMIR/LLVMTypes.h.inc"
        -:   51:
        -:   52:namespace mlir {
        -:   53:namespace LLVM {
        -:   54:
        -:   55://===----------------------------------------------------------------------===//
        -:   56:// Trivial types.
        -:   57://===----------------------------------------------------------------------===//
        -:   58:
        -:   59:// Batch-define trivial types.
        -:   60:#define DEFINE_TRIVIAL_LLVM_TYPE(ClassName)                                    \
        -:   61:  class ClassName : public Type::TypeBase<ClassName, Type, TypeStorage> {      \
        -:   62:  public:                                                                      \
        -:   63:    using Base::Base;                                                          \
        -:   64:  }
        -:   65:
    #####:   66:DEFINE_TRIVIAL_LLVM_TYPE(LLVMVoidType);
        -:   67:DEFINE_TRIVIAL_LLVM_TYPE(LLVMPPCFP128Type);
        -:   68:DEFINE_TRIVIAL_LLVM_TYPE(LLVMX86MMXType);
        -:   69:DEFINE_TRIVIAL_LLVM_TYPE(LLVMTokenType);
        -:   70:DEFINE_TRIVIAL_LLVM_TYPE(LLVMLabelType);
        -:   71:DEFINE_TRIVIAL_LLVM_TYPE(LLVMMetadataType);
        -:   72:
        -:   73:#undef DEFINE_TRIVIAL_LLVM_TYPE
        -:   74:
        -:   75://===----------------------------------------------------------------------===//
        -:   76:// LLVMStructType.
        -:   77://===----------------------------------------------------------------------===//
        -:   78:
        -:   79:/// LLVM dialect structure type representing a collection of different-typed
        -:   80:/// elements manipulated together. Structured can optionally be packed, meaning
        -:   81:/// that their elements immediately follow each other in memory without
        -:   82:/// accounting for potential alignment.
        -:   83:///
        -:   84:/// Structure types can be identified (named) or literal. Literal structures
        -:   85:/// are uniquely represented by the list of types they contain and packedness.
        -:   86:/// Literal structure types are immutable after construction.
        -:   87:///
        -:   88:/// Identified structures are uniquely represented by their name, a string. They
        -:   89:/// have a mutable component, consisting of the list of types they contain,
        -:   90:/// the packedness and the opacity bits. Identified structs can be created
        -:   91:/// without providing the lists of element types, making them suitable to
        -:   92:/// represent recursive, i.e. self-referring, structures. Identified structs
        -:   93:/// without body are considered opaque. For such structs, one can set the body.
        -:   94:/// Identified structs can be created as intentionally-opaque, implying that the
        -:   95:/// caller does not intend to ever set the body (e.g. forward-declarations of
        -:   96:/// structs from another module) and wants to disallow further modification of
        -:   97:/// the body. For intentionally-opaque structs or non-opaque structs with the
        -:   98:/// body, one is not allowed to set another body (however, one can set exactly
        -:   99:/// the same body).
        -:  100:///
        -:  101:/// Note that the packedness of the struct takes place in uniquing of literal
        -:  102:/// structs, but does not in uniquing of identified structs.
        -:  103:class LLVMStructType
        -:  104:    : public Type::TypeBase<LLVMStructType, Type, detail::LLVMStructTypeStorage,
        -:  105:                            DataLayoutTypeInterface::Trait,
        -:  106:                            SubElementTypeInterface::Trait,
        -:  107:                            TypeTrait::IsMutable> {
        -:  108:public:
        -:  109:  /// Inherit base constructors.
    #####:  110:  using Base::Base;
        -:  111:
        -:  112:  /// Checks if the given type can be contained in a structure type.
        -:  113:  static bool isValidElementType(Type type);
        -:  114:
        -:  115:  /// Gets or creates an identified struct with the given name in the provided
        -:  116:  /// context. Note that unlike llvm::StructType::create, this function will
        -:  117:  /// _NOT_ rename a struct in case a struct with the same name already exists
        -:  118:  /// in the context. Instead, it will just return the existing struct,
        -:  119:  /// similarly to the rest of MLIR type ::get methods.
        -:  120:  static LLVMStructType getIdentified(MLIRContext *context, StringRef name);
        -:  121:  static LLVMStructType
        -:  122:  getIdentifiedChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  123:                       MLIRContext *context, StringRef name);
        -:  124:
        -:  125:  /// Gets a new identified struct with the given body. The body _cannot_ be
        -:  126:  /// changed later. If a struct with the given name already exists, renames
        -:  127:  /// the struct by appending a `.` followed by a number to the name. Renaming
        -:  128:  /// happens even if the existing struct has the same body.
        -:  129:  static LLVMStructType getNewIdentified(MLIRContext *context, StringRef name,
        -:  130:                                         ArrayRef<Type> elements,
        -:  131:                                         bool isPacked = false);
        -:  132:
        -:  133:  /// Gets or creates a literal struct with the given body in the provided
        -:  134:  /// context.
        -:  135:  static LLVMStructType getLiteral(MLIRContext *context, ArrayRef<Type> types,
        -:  136:                                   bool isPacked = false);
        -:  137:  static LLVMStructType
        -:  138:  getLiteralChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  139:                    MLIRContext *context, ArrayRef<Type> types,
        -:  140:                    bool isPacked = false);
        -:  141:
        -:  142:  /// Gets or creates an intentionally-opaque identified struct. Such a struct
        -:  143:  /// cannot have its body set. To create an opaque struct with a mutable body,
        -:  144:  /// use `getIdentified`. Note that unlike llvm::StructType::create, this
        -:  145:  /// function will _NOT_ rename a struct in case a struct with the same name
        -:  146:  /// already exists in the context. Instead, it will just return the existing
        -:  147:  /// struct, similarly to the rest of MLIR type ::get methods.
        -:  148:  static LLVMStructType getOpaque(StringRef name, MLIRContext *context);
        -:  149:  static LLVMStructType
        -:  150:  getOpaqueChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  151:                   MLIRContext *context, StringRef name);
        -:  152:
        -:  153:  /// Set the body of an identified struct. Returns failure if the body could
        -:  154:  /// not be set, e.g. if the struct already has a body or if it was marked as
        -:  155:  /// intentionally opaque. This might happen in a multi-threaded context when a
        -:  156:  /// different thread modified the struct after it was created. Most callers
        -:  157:  /// are likely to assert this always succeeds, but it is possible to implement
        -:  158:  /// a local renaming scheme based on the result of this call.
        -:  159:  LogicalResult setBody(ArrayRef<Type> types, bool isPacked);
        -:  160:
        -:  161:  /// Checks if a struct is packed.
        -:  162:  bool isPacked() const;
        -:  163:
        -:  164:  /// Checks if a struct is identified.
        -:  165:  bool isIdentified() const;
        -:  166:
        -:  167:  /// Checks if a struct is opaque.
        -:  168:  bool isOpaque();
        -:  169:
        -:  170:  /// Checks if a struct is initialized.
        -:  171:  bool isInitialized();
        -:  172:
        -:  173:  /// Returns the name of an identified struct.
        -:  174:  StringRef getName();
        -:  175:
        -:  176:  /// Returns the list of element types contained in a non-opaque struct.
        -:  177:  ArrayRef<Type> getBody() const;
        -:  178:
        -:  179:  /// Verifies that the type about to be constructed is well-formed.
        -:  180:  static LogicalResult verify(function_ref<InFlightDiagnostic()> emitError,
        -:  181:                              StringRef, bool);
        -:  182:  static LogicalResult verify(function_ref<InFlightDiagnostic()> emitError,
        -:  183:                              ArrayRef<Type> types, bool);
        -:  184:
        -:  185:  /// Hooks for DataLayoutTypeInterface. Should not be called directly. Obtain a
        -:  186:  /// DataLayout instance and query it instead.
        -:  187:  unsigned getTypeSizeInBits(const DataLayout &dataLayout,
        -:  188:                             DataLayoutEntryListRef params) const;
        -:  189:
        -:  190:  unsigned getABIAlignment(const DataLayout &dataLayout,
        -:  191:                           DataLayoutEntryListRef params) const;
        -:  192:
        -:  193:  unsigned getPreferredAlignment(const DataLayout &dataLayout,
        -:  194:                                 DataLayoutEntryListRef params) const;
        -:  195:
        -:  196:  bool areCompatible(DataLayoutEntryListRef oldLayout,
        -:  197:                     DataLayoutEntryListRef newLayout) const;
        -:  198:
        -:  199:  LogicalResult verifyEntries(DataLayoutEntryListRef entries,
        -:  200:                              Location loc) const;
        -:  201:
        -:  202:  void walkImmediateSubElements(function_ref<void(Attribute)> walkAttrsFn,
        -:  203:                                function_ref<void(Type)> walkTypesFn) const;
        -:  204:  Type replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  205:                                   ArrayRef<Type> replTypes) const;
        -:  206:};
        -:  207:
        -:  208://===----------------------------------------------------------------------===//
        -:  209:// Printing and parsing.
        -:  210://===----------------------------------------------------------------------===//
        -:  211:
        -:  212:namespace detail {
        -:  213:/// Parses an LLVM dialect type.
        -:  214:Type parseType(DialectAsmParser &parser);
        -:  215:
        -:  216:/// Prints an LLVM Dialect type.
        -:  217:void printType(Type type, AsmPrinter &printer);
        -:  218:} // namespace detail
        -:  219:
        -:  220:/// Parse any MLIR type or a concise syntax for LLVM types.
        -:  221:ParseResult parsePrettyLLVMType(AsmParser &p, FailureOr<Type> &type);
        -:  222:/// Print any MLIR type or a concise syntax for LLVM types.
        -:  223:void printPrettyLLVMType(AsmPrinter &p, Type type);
        -:  224:
        -:  225://===----------------------------------------------------------------------===//
        -:  226:// Utility functions.
        -:  227://===----------------------------------------------------------------------===//
        -:  228:
        -:  229:/// Returns `true` if the given type is compatible with the LLVM dialect. This
        -:  230:/// is an alias to `LLVMDialect::isCompatibleType`.
        -:  231:bool isCompatibleType(Type type);
        -:  232:
        -:  233:/// Returns `true` if the given outer type is compatible with the LLVM dialect
        -:  234:/// without checking its potential nested types such as struct elements.
        -:  235:bool isCompatibleOuterType(Type type);
        -:  236:
        -:  237:/// Returns `true` if the given type is a floating-point type compatible with
        -:  238:/// the LLVM dialect.
        -:  239:bool isCompatibleFloatingPointType(Type type);
        -:  240:
        -:  241:/// Returns `true` if the given type is a vector type compatible with the LLVM
        -:  242:/// dialect. Compatible types include 1D built-in vector types of built-in
        -:  243:/// integers and floating-point values, LLVM dialect fixed vector types of LLVM
        -:  244:/// dialect pointers and LLVM dialect scalable vector types.
        -:  245:bool isCompatibleVectorType(Type type);
        -:  246:
        -:  247:/// Returns the element type of any vector type compatible with the LLVM
        -:  248:/// dialect.
        -:  249:Type getVectorElementType(Type type);
        -:  250:
        -:  251:/// Returns the element count of any LLVM-compatible vector type.
        -:  252:llvm::ElementCount getVectorNumElements(Type type);
        -:  253:
        -:  254:/// Returns whether a vector type is scalable or not.
        -:  255:bool isScalableVectorType(Type vectorType);
        -:  256:
        -:  257:/// Creates an LLVM dialect-compatible vector type with the given element type
        -:  258:/// and length.
        -:  259:Type getVectorType(Type elementType, unsigned numElements,
        -:  260:                   bool isScalable = false);
        -:  261:
        -:  262:/// Creates an LLVM dialect-compatible vector type with the given element type
        -:  263:/// and length.
        -:  264:Type getVectorType(Type elementType, const llvm::ElementCount &numElements);
        -:  265:
        -:  266:/// Creates an LLVM dialect-compatible type with the given element type and
        -:  267:/// length.
        -:  268:Type getFixedVectorType(Type elementType, unsigned numElements);
        -:  269:
        -:  270:/// Creates an LLVM dialect-compatible type with the given element type and
        -:  271:/// length.
        -:  272:Type getScalableVectorType(Type elementType, unsigned numElements);
        -:  273:
        -:  274:/// Returns the size of the given primitive LLVM dialect-compatible type
        -:  275:/// (including vectors) in bits, for example, the size of i16 is 16 and
        -:  276:/// the size of vector<4xi16> is 64. Returns 0 for non-primitive
        -:  277:/// (aggregates such as struct) or types that don't have a size (such as void).
        -:  278:llvm::TypeSize getPrimitiveTypeSizeInBits(Type type);
        -:  279:
        -:  280:/// The positions of different values in the data layout entry for pointers.
        -:  281:enum class PtrDLEntryPos { Size = 0, Abi = 1, Preferred = 2, Index = 3 };
        -:  282:
        -:  283:/// Returns the value that corresponds to named position `pos` from the
        -:  284:/// data layout entry `attr` assuming it's a dense integer elements attribute.
        -:  285:/// Returns `None` if `pos` is not present in the entry.
        -:  286:/// Currently only `PtrDLEntryPos::Index` is optional, and all other positions
        -:  287:/// may be assumed to be present.
        -:  288:Optional<unsigned> extractPointerSpecValue(Attribute attr, PtrDLEntryPos pos);
        -:  289:
        -:  290:} // namespace LLVM
        -:  291:} // namespace mlir
        -:  292:
        -:  293:#endif // MLIR_DIALECT_LLVMIR_LLVMTYPES_H_
