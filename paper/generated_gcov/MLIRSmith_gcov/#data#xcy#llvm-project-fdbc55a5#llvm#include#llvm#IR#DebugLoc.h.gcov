        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/llvm/include/llvm/IR/DebugLoc.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcda
        -:    0:Runs:116169
        -:    1://===- DebugLoc.h - Debug Location Information ------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines a number of light weight data structures used
        -:   10:// to describe and track debug location information.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_IR_DEBUGLOC_H
        -:   15:#define LLVM_IR_DEBUGLOC_H
        -:   16:
        -:   17:#include "llvm/IR/TrackingMDRef.h"
        -:   18:#include "llvm/Support/DataTypes.h"
        -:   19:
        -:   20:namespace llvm {
        -:   21:
        -:   22:  class LLVMContext;
        -:   23:  class raw_ostream;
        -:   24:  class DILocation;
        -:   25:
        -:   26:  /// A debug info location.
        -:   27:  ///
        -:   28:  /// This class is a wrapper around a tracking reference to an \a DILocation
        -:   29:  /// pointer.
        -:   30:  ///
        -:   31:  /// To avoid extra includes, \a DebugLoc doubles the \a DILocation API with a
        -:   32:  /// one based on relatively opaque \a MDNode pointers.
    #####:   33:  class DebugLoc {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   34:    TrackingMDNodeRef Loc;
        -:   35:
        -:   36:  public:
        -:   37:    DebugLoc() = default;
        -:   38:
        -:   39:    /// Construct from an \a DILocation.
        -:   40:    DebugLoc(const DILocation *L);
        -:   41:
        -:   42:    /// Construct from an \a MDNode.
        -:   43:    ///
        -:   44:    /// Note: if \c N is not an \a DILocation, a verifier check will fail, and
        -:   45:    /// accessors will crash.  However, construction from other nodes is
        -:   46:    /// supported in order to handle forward references when reading textual
        -:   47:    /// IR.
        -:   48:    explicit DebugLoc(const MDNode *N);
        -:   49:
        -:   50:    /// Get the underlying \a DILocation.
        -:   51:    ///
        -:   52:    /// \pre !*this or \c isa<DILocation>(getAsMDNode()).
        -:   53:    /// @{
        -:   54:    DILocation *get() const;
        -:   55:    operator DILocation *() const { return get(); }
        -:   56:    DILocation *operator->() const { return get(); }
        -:   57:    DILocation &operator*() const { return *get(); }
        -:   58:    /// @}
        -:   59:
        -:   60:    /// Check for null.
        -:   61:    ///
        -:   62:    /// Check for null in a way that is safe with broken debug info.  Unlike
        -:   63:    /// the conversion to \c DILocation, this doesn't require that \c Loc is of
        -:   64:    /// the right type.  Important for cases like \a llvm::StripDebugInfo() and
        -:   65:    /// \a Instruction::hasMetadata().
        -:   66:    explicit operator bool() const { return Loc; }
        -:   67:
        -:   68:    /// Check whether this has a trivial destructor.
        -:   69:    bool hasTrivialDestructor() const { return Loc.hasTrivialDestructor(); }
        -:   70:
        -:   71:    enum { ReplaceLastInlinedAt = true };
        -:   72:    /// Rebuild the entire inlined-at chain for this instruction so that the top of
        -:   73:    /// the chain now is inlined-at the new call site.
        -:   74:    /// \param   InlinedAt    The new outermost inlined-at in the chain.
        -:   75:    static DebugLoc appendInlinedAt(const DebugLoc &DL, DILocation *InlinedAt,
        -:   76:                                    LLVMContext &Ctx,
        -:   77:                                    DenseMap<const MDNode *, MDNode *> &Cache);
        -:   78:
        -:   79:    unsigned getLine() const;
        -:   80:    unsigned getCol() const;
        -:   81:    MDNode *getScope() const;
        -:   82:    DILocation *getInlinedAt() const;
        -:   83:
        -:   84:    /// Get the fully inlined-at scope for a DebugLoc.
        -:   85:    ///
        -:   86:    /// Gets the inlined-at scope for a DebugLoc.
        -:   87:    MDNode *getInlinedAtScope() const;
        -:   88:
        -:   89:    /// Find the debug info location for the start of the function.
        -:   90:    ///
        -:   91:    /// Walk up the scope chain of given debug loc and find line number info
        -:   92:    /// for the function.
        -:   93:    ///
        -:   94:    /// FIXME: Remove this.  Users should use DILocation/DILocalScope API to
        -:   95:    /// find the subprogram, and then DILocation::get().
        -:   96:    DebugLoc getFnDebugLoc() const;
        -:   97:
        -:   98:    /// Return \c this as a bar \a MDNode.
    #####:   99:    MDNode *getAsMDNode() const { return Loc; }
call    0 never executed
        -:  100:
        -:  101:    /// Check if the DebugLoc corresponds to an implicit code.
        -:  102:    bool isImplicitCode() const;
        -:  103:    void setImplicitCode(bool ImplicitCode);
        -:  104:
        -:  105:    bool operator==(const DebugLoc &DL) const { return Loc == DL.Loc; }
        -:  106:    bool operator!=(const DebugLoc &DL) const { return Loc != DL.Loc; }
        -:  107:
        -:  108:    void dump() const;
        -:  109:
        -:  110:    /// prints source location /path/to/file.exe:line:col @[inlined at]
        -:  111:    void print(raw_ostream &OS) const;
        -:  112:  };
        -:  113:
        -:  114:} // end namespace llvm
        -:  115:
        -:  116:#endif // LLVM_IR_DEBUGLOC_H
