        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/Operation.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Operation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Operation.cpp.gcda
        -:    0:Runs:116164
        -:    1://===- Operation.cpp - Operation support code -----------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/Operation.h"
        -:   10:#include "mlir/IR/BlockAndValueMapping.h"
        -:   11:#include "mlir/IR/BuiltinTypes.h"
        -:   12:#include "mlir/IR/Dialect.h"
        -:   13:#include "mlir/IR/OpImplementation.h"
        -:   14:#include "mlir/IR/PatternMatch.h"
        -:   15:#include "mlir/IR/TypeUtilities.h"
        -:   16:#include "mlir/Interfaces/FoldInterfaces.h"
        -:   17:#include "llvm/ADT/StringExtras.h"
        -:   18:#include <numeric>
        -:   19:
        -:   20:using namespace mlir;
        -:   21:
        -:   22://===----------------------------------------------------------------------===//
        -:   23:// Operation
        -:   24://===----------------------------------------------------------------------===//
        -:   25:
        -:   26:/// Create a new Operation from operation state.
function _ZN4mlir9Operation6createERKNS_14OperationStateE called 250155187 returned 100% blocks executed 100%
250155187:   27:Operation *Operation::create(const OperationState &state) {
250155181:   28:  return create(state.location, state.name, state.types, state.operands,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 1% (fallthrough)
branch  7 taken 100%
        -:   29:                state.attributes.getDictionary(state.getContext()),
250155187:   30:                state.successors, state.regions);
call    0 returned 100%
call    1 returned 100%
        -:   31:}
        -:   32:
        -:   33:/// Create a new Operation with the specific fields.
function _ZN4mlir9Operation6createENS_8LocationENS_13OperationNameENS_9TypeRangeENS_10ValueRangeEONS_13NamedAttrListENS_10BlockRangeENS_11RegionRangeE called 250155167 returned 100% blocks executed 100%
250155167:   34:Operation *Operation::create(Location location, OperationName name,
        -:   35:                             TypeRange resultTypes, ValueRange operands,
        -:   36:                             NamedAttrList &&attributes, BlockRange successors,
        -:   37:                             RegionRange regions) {
250155167:   38:  unsigned numRegions = regions.size();
call    0 returned 100%
250155167:   39:  Operation *op = create(location, name, resultTypes, operands,
call    0 returned 100%
250155167:   40:                         std::move(attributes), successors, numRegions);
261983390:   41:  for (unsigned i = 0; i < numRegions; ++i)
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
 11828223:   42:    if (regions[i])
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 11828223:   43:      op->getRegion(i).takeBody(*regions[i]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
250155171:   44:  return op;
        -:   45:}
        -:   46:
        -:   47:/// Overload of create that takes an existing DictionaryAttr to avoid
        -:   48:/// unnecessarily uniquing a list of attributes.
function _ZN4mlir9Operation6createENS_8LocationENS_13OperationNameENS_9TypeRangeENS_10ValueRangeEONS_13NamedAttrListENS_10BlockRangeEj called 257986681 returned 100% blocks executed 83%
257986681:   49:Operation *Operation::create(Location location, OperationName name,
        -:   50:                             TypeRange resultTypes, ValueRange operands,
        -:   51:                             NamedAttrList &&attributes, BlockRange successors,
        -:   52:                             unsigned numRegions) {
257986681*:   53:  assert(llvm::all_of(resultTypes, [](Type t) { return t; }) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   54:         "unexpected null result type");
        -:   55:
        -:   56:  // We only need to allocate additional memory for a subset of results.
257986682:   57:  unsigned numTrailingResults = OpResult::getNumTrailing(resultTypes.size());
call    0 returned 100%
257986681:   58:  unsigned numInlineResults = OpResult::getNumInline(resultTypes.size());
call    0 returned 100%
257986705:   59:  unsigned numSuccessors = successors.size();
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
257986705:   60:  unsigned numOperands = operands.size();
257986705:   61:  unsigned numResults = resultTypes.size();
        -:   62:
        -:   63:  // If the operation is known to have no operands, don't allocate an operand
        -:   64:  // storage.
257986705:   65:  bool needsOperandStorage =
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
257986705:   66:      operands.empty() ? !name.hasTrait<OpTrait::ZeroOperands>() : true;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
call    2 returned 100%
        -:   67:
        -:   68:  // Compute the byte size for the operation and the operand storage. This takes
        -:   69:  // into account the size of the operation, its trailing objects, and its
        -:   70:  // prefixed objects.
257986703:   71:  size_t byteSize =
257986703:   72:      totalSizeToAlloc<detail::OperandStorage, BlockOperand, Region, OpOperand>(
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:   73:          needsOperandStorage ? 1 : 0, numSuccessors, numRegions, numOperands);
257986703:   74:  size_t prefixByteSize = llvm::alignTo(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   75:      Operation::prefixAllocSize(numTrailingResults, numInlineResults),
        -:   76:      alignof(Operation));
257986703:   77:  char *mallocMem = reinterpret_cast<char *>(malloc(byteSize + prefixByteSize));
257986703:   78:  void *rawMem = mallocMem + prefixByteSize;
        -:   79:
        -:   80:  // Populate default attributes.
515973406:   81:  if (Optional<RegisteredOperationName> info = name.getRegisteredInfo())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
257986701:   82:    info->populateDefaultAttrs(attributes);
call    0 returned 100%
        -:   83:
        -:   84:  // Create the new Operation.
257986698:   85:  Operation *op = ::new (rawMem) Operation(
        -:   86:      location, name, numResults, numSuccessors, numRegions,
257986698:   87:      attributes.getDictionary(location.getContext()), needsOperandStorage);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   88:
258099956*:   89:  assert((numSuccessors == 0 || op->mightHaveTrait<OpTrait::IsTerminator>()) &&
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:   90:         "unexpected successors in a non-terminator operation");
        -:   91:
        -:   92:  // Initialize the results.
257986688:   93:  auto resultTypeIt = resultTypes.begin();
477732646:   94:  for (unsigned i = 0; i < numInlineResults; ++i, ++resultTypeIt)
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
219745962:   95:    new (op->getInlineOpResult(i)) detail::InlineOpResult(*resultTypeIt, i);
call    0 returned 100%
call    1 returned 100%
257986684*:   96:  for (unsigned i = 0; i < numTrailingResults; ++i, ++resultTypeIt) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   97:    new (op->getOutOfLineOpResult(i))
call    0 never executed
call    1 never executed
    #####:   98:        detail::OutOfLineOpResult(*resultTypeIt, i);
call    0 never executed
        -:   99:  }
        -:  100:
        -:  101:  // Initialize the regions.
270159936:  102:  for (unsigned i = 0; i != numRegions; ++i)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
 12173252:  103:    new (&op->getRegion(i)) Region(op);
call    0 returned 100%
call    1 returned 100%
        -:  104:
        -:  105:  // Initialize the operands.
257986684:  106:  if (needsOperandStorage) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
464350896:  107:    new (&op->getOperandStorage()) detail::OperandStorage(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
232175448:  108:        op, op->getTrailingObjects<OpOperand>(), operands);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  109:  }
        -:  110:
        -:  111:  // Initialize the successors.
257986684:  112:  auto blockOperands = op->getBlockOperands();
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
258136467:  113:  for (unsigned i = 0; i != numSuccessors; ++i)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
   149783:  114:    new (&blockOperands[i]) BlockOperand(op, successors[i]);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  115:
257986684:  116:  return op;
        -:  117:}
        -:  118:
function _ZN4mlir9OperationC2ENS_8LocationENS_13OperationNameEjjjNS_14DictionaryAttrEb called 257986689 returned 100% blocks executed 33%
257986689:  119:Operation::Operation(Location location, OperationName name, unsigned numResults,
        -:  120:                     unsigned numSuccessors, unsigned numRegions,
257986689:  121:                     DictionaryAttr attributes, bool hasOperandStorage)
        -:  122:    : location(location), numResults(numResults), numSuccs(numSuccessors),
257986689:  123:      numRegions(numRegions), hasOperandStorage(hasOperandStorage), name(name),
257986689:  124:      attrs(attributes) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
257986689*:  125:  assert(attributes && "unexpected null attribute dictionary");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  126:#ifndef NDEBUG
257986689*:  127:  if (!getDialect() && !getContext()->allowsUnregisteredDialects())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  128:    llvm::report_fatal_error(
call    0 never executed
    #####:  129:        name.getStringRef() +
call    0 never executed
        -:  130:        " created with unregistered dialect. If this is intended, please call "
        -:  131:        "allowUnregisteredDialects() on the MLIRContext, or use "
    #####:  132:        "-allow-unregistered-dialect with the MLIR tool used.");
call    0 never executed
        -:  133:#endif
257986689:  134:}
        -:  135:
        -:  136:// Operations are deleted through the destroy() member because they are
        -:  137:// allocated via malloc.
function _ZN4mlir9OperationD2Ev called 257305316 returned 100% blocks executed 59%
514610640:  138:Operation::~Operation() {
257305316*:  139:  assert(block == nullptr && "operation destroyed but still in a block");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  140:#ifndef NDEBUG
514610628:  141:  if (!use_empty()) {
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  142:    {
    #####:  143:      InFlightDiagnostic diag =
    #####:  144:          emitOpError("operation destroyed but still has uses");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  145:      for (Operation *user : getUsers())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  146:        diag.attachNote(user->getLoc()) << "- use: " << *user << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  147:    }
    #####:  148:    llvm::report_fatal_error("operation destroyed but still has uses");
call    0 never executed
        -:  149:  }
        -:  150:#endif
        -:  151:  // Explicitly run the destructors for the operands.
257305312:  152:  if (hasOperandStorage)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
231540367:  153:    getOperandStorage().~OperandStorage();
call    0 returned 100%
        -:  154:
        -:  155:  // Explicitly run the destructors for the successors.
283219663:  156:  for (auto &successor : getBlockOperands())
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
   154757:  157:    successor.~BlockOperand();
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  158:
        -:  159:  // Explicitly destroy the regions.
269452411:  160:  for (auto &region : getRegions())
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
 12147087:  161:    region.~Region();
call    0 returned 100%
257305324:  162:}
        -:  163:
        -:  164:/// Destroy this operation or one of its subclasses.
function _ZN4mlir9Operation7destroyEv called 257305328 returned 100% blocks executed 100%
257305328:  165:void Operation::destroy() {
        -:  166:  // Operations may have additional prefixed allocation, which needs to be
        -:  167:  // accounted for here when computing the address to free.
514610644:  168:  char *rawMem = reinterpret_cast<char *>(this) -
257305328:  169:                 llvm::alignTo(prefixAllocSize(), alignof(Operation));
call    0 returned 100%
call    1 returned 100%
257305316:  170:  this->~Operation();
call    0 returned 100%
257305325:  171:  free(rawMem);
257305325:  172:}
        -:  173:
        -:  174:/// Return true if this operation is a proper ancestor of the `other`
        -:  175:/// operation.
function _ZN4mlir9Operation16isProperAncestorEPS0_ called 6716760 returned 100% blocks executed 100%
  6716760:  176:bool Operation::isProperAncestor(Operation *other) {
 51441653:  177:  while ((other = other->getParentOp()))
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 22479445:  178:    if (this == other)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  179:      return true;
        -:  180:  return false;
        -:  181:}
        -:  182:
        -:  183:/// Replace any uses of 'from' with 'to' within this operation.
function _ZN4mlir9Operation17replaceUsesOfWithENS_5ValueES1_ called 0 returned 0% blocks executed 0%
    #####:  184:void Operation::replaceUsesOfWith(Value from, Value to) {
    #####:  185:  if (from == to)
branch  0 never executed
branch  1 never executed
        -:  186:    return;
    #####:  187:  for (auto &operand : getOpOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  188:    if (operand.get() == from)
branch  0 never executed
branch  1 never executed
    #####:  189:      operand.set(to);
branch  0 never executed
branch  1 never executed
        -:  190:}
        -:  191:
        -:  192:/// Replace the current operands of this operation with the ones provided in
        -:  193:/// 'operands'.
function _ZN4mlir9Operation11setOperandsENS_10ValueRangeE called 7560378 returned 100% blocks executed 71%
  7560378:  194:void Operation::setOperands(ValueRange operands) {
  7560378:  195:  if (LLVM_LIKELY(hasOperandStorage))
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  7190879:  196:    return getOperandStorage().setOperands(this, operands);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  369499*:  197:  assert(operands.empty() && "setting operands without an operand storage");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  198:}
        -:  199:
        -:  200:/// Replace the operands beginning at 'start' and ending at 'start' + 'length'
        -:  201:/// with the ones provided in 'operands'. 'operands' may be smaller or larger
        -:  202:/// than the range pointed to by 'start'+'length'.
function _ZN4mlir9Operation11setOperandsEjjNS_10ValueRangeE called 2666 returned 100% blocks executed 62%
     2666:  203:void Operation::setOperands(unsigned start, unsigned length,
        -:  204:                            ValueRange operands) {
    5332*:  205:  assert((start + length) <= getNumOperands() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  206:         "invalid operand range specified");
     2666:  207:  if (LLVM_LIKELY(hasOperandStorage))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2666:  208:    return getOperandStorage().setOperands(this, start, length, operands);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
    #####:  209:  assert(operands.empty() && "setting operands without an operand storage");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  210:}
        -:  211:
        -:  212:/// Insert the given operands into the operand list at the given 'index'.
function _ZN4mlir9Operation14insertOperandsEjNS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  213:void Operation::insertOperands(unsigned index, ValueRange operands) {
    #####:  214:  if (LLVM_LIKELY(hasOperandStorage))
branch  0 never executed
branch  1 never executed
    #####:  215:    return setOperands(index, /*length=*/0, operands);
call    0 never executed
    #####:  216:  assert(operands.empty() && "inserting operands without an operand storage");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  217:}
        -:  218:
        -:  219://===----------------------------------------------------------------------===//
        -:  220:// Diagnostics
        -:  221://===----------------------------------------------------------------------===//
        -:  222:
        -:  223:/// Emit an error about fatal conditions with this operation, reporting up to
        -:  224:/// any diagnostic handlers that may be listening.
function _ZN4mlir9Operation9emitErrorERKN4llvm5TwineE called 3102128 returned 100% blocks executed 100%
  3102128:  225:InFlightDiagnostic Operation::emitError(const Twine &message) {
  3102128:  226:  InFlightDiagnostic diag = mlir::emitError(getLoc(), message);
call    0 returned 100%
  3102122:  227:  if (getContext()->shouldPrintOpOnDiagnostic()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
  3100399:  228:    diag.attachNote(getLoc())
call    0 returned 100%
call    1 returned 100%
  3100410:  229:        .append("see current operation: ")
  3100410:  230:        .appendOp(*this, OpPrintingFlags().printGenericOpForm());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  231:  }
  3102121:  232:  return diag;
        -:  233:}
        -:  234:
        -:  235:/// Emit a warning about this operation, reporting up to any diagnostic
        -:  236:/// handlers that may be listening.
function _ZN4mlir9Operation11emitWarningERKN4llvm5TwineE called 0 returned 0% blocks executed 0%
    #####:  237:InFlightDiagnostic Operation::emitWarning(const Twine &message) {
    #####:  238:  InFlightDiagnostic diag = mlir::emitWarning(getLoc(), message);
call    0 never executed
    #####:  239:  if (getContext()->shouldPrintOpOnDiagnostic())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  240:    diag.attachNote(getLoc()) << "see current operation: " << *this;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  241:  return diag;
        -:  242:}
        -:  243:
        -:  244:/// Emit a remark about this operation, reporting up to any diagnostic
        -:  245:/// handlers that may be listening.
function _ZN4mlir9Operation10emitRemarkERKN4llvm5TwineE called 3210008 returned 100% blocks executed 100%
  3210008:  246:InFlightDiagnostic Operation::emitRemark(const Twine &message) {
  3210008:  247:  InFlightDiagnostic diag = mlir::emitRemark(getLoc(), message);
call    0 returned 100%
  3210008:  248:  if (getContext()->shouldPrintOpOnDiagnostic())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
  3189495:  249:    diag.attachNote(getLoc()) << "see current operation: " << *this;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  3210008:  250:  return diag;
        -:  251:}
        -:  252:
        -:  253://===----------------------------------------------------------------------===//
        -:  254:// Operation Ordering
        -:  255://===----------------------------------------------------------------------===//
        -:  256:
        -:  257:constexpr unsigned Operation::kInvalidOrderIdx;
        -:  258:constexpr unsigned Operation::kOrderStride;
        -:  259:
        -:  260:/// Given an operation 'other' that is within the same parent block, return
        -:  261:/// whether the current operation is before 'other' in the operation list
        -:  262:/// of the parent block.
        -:  263:/// Note: This function has an average complexity of O(1), but worst case may
        -:  264:/// take O(N) where N is the number of operations within the parent block.
function _ZN4mlir9Operation15isBeforeInBlockEPS0_ called 22563705807 returned 100% blocks executed 82%
22563705807:  265:bool Operation::isBeforeInBlock(Operation *other) {
22563705807*:  266:  assert(block && "Operations without parent blocks have no order.");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
22563705807*:  267:  assert(other && other->block == block &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  268:         "Expected other operation to have the same parent block.");
        -:  269:  // If the order of the block is already invalid, directly recompute the
        -:  270:  // parent.
22563705807:  271:  if (!block->isOpOrderValid()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
  8943363:  272:    block->recomputeOpOrder();
call    0 returned 100%
        -:  273:  } else {
        -:  274:    // Update the order either operation if necessary.
22554762563:  275:    updateOrderIfNecessary();
call    0 returned 100%
22554762507:  276:    other->updateOrderIfNecessary();
call    0 returned 100%
        -:  277:  }
        -:  278:
22563705778:  279:  return orderIndex < other->orderIndex;
        -:  280:}
        -:  281:
        -:  282:/// Update the order index of this operation of this operation if necessary,
        -:  283:/// potentially recomputing the order of the parent block.
function _ZN4mlir9Operation22updateOrderIfNecessaryEv called 45109524360 returned 100% blocks executed 88%
45109524360:  284:void Operation::updateOrderIfNecessary() {
45109524360*:  285:  assert(block && "expected valid parent");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  286:
        -:  287:  // If the order is valid for this operation there is nothing to do.
45109524360:  288:  if (hasValidOrder())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  289:    return;
   479524:  290:  Operation *blockFront = &block->front();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   479524:  291:  Operation *blockBack = &block->back();
call    0 returned 100%
        -:  292:
        -:  293:  // This method is expected to only be invoked on blocks with more than one
        -:  294:  // operation.
  479524*:  295:  assert(blockFront != blockBack && "expected more than one operation");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  296:
        -:  297:  // If the operation is at the end of the block.
   479524:  298:  if (this == blockBack) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     1086:  299:    Operation *prevNode = getPrevNode();
call    0 returned 100%
     1086:  300:    if (!prevNode->hasValidOrder())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  301:      return block->recomputeOpOrder();
call    0 returned 100%
        -:  302:
        -:  303:    // Add the stride to the previous operation.
     1084:  304:    orderIndex = prevNode->orderIndex + kOrderStride;
     1084:  305:    return;
        -:  306:  }
        -:  307:
        -:  308:  // If this is the first operation try to use the next operation to compute the
        -:  309:  // ordering.
   478438:  310:  if (this == blockFront) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    30426:  311:    Operation *nextNode = getNextNode();
call    0 returned 100%
    30426:  312:    if (!nextNode->hasValidOrder())
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     8171:  313:      return block->recomputeOpOrder();
call    0 returned 100%
        -:  314:    // There is no order to give this operation.
    22255:  315:    if (nextNode->orderIndex == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  316:      return block->recomputeOpOrder();
call    0 never executed
        -:  317:
        -:  318:    // If we can't use the stride, just take the middle value left. This is safe
        -:  319:    // because we know there is at least one valid index to assign to.
    22255:  320:    if (nextNode->orderIndex <= kOrderStride)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      241:  321:      orderIndex = (nextNode->orderIndex / 2);
        -:  322:    else
    22014:  323:      orderIndex = kOrderStride;
    22255:  324:    return;
        -:  325:  }
        -:  326:
        -:  327:  // Otherwise, this operation is between two others. Place this operation in
        -:  328:  // the middle of the previous and next if possible.
   448012:  329:  Operation *prevNode = getPrevNode(), *nextNode = getNextNode();
call    0 returned 100%
call    1 returned 100%
   448012:  330:  if (!prevNode->hasValidOrder() || !nextNode->hasValidOrder())
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
branch  2 taken 19% (fallthrough)
branch  3 taken 81%
   147490:  331:    return block->recomputeOpOrder();
call    0 returned 100%
   300522:  332:  unsigned prevOrder = prevNode->orderIndex, nextOrder = nextNode->orderIndex;
        -:  333:
        -:  334:  // Check to see if there is a valid order between the two.
   300522:  335:  if (prevOrder + 1 == nextOrder)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  336:    return block->recomputeOpOrder();
call    0 returned 100%
   300520:  337:  orderIndex = prevOrder + ((nextOrder - prevOrder) / 2);
        -:  338:}
        -:  339:
        -:  340://===----------------------------------------------------------------------===//
        -:  341:// ilist_traits for Operation
        -:  342://===----------------------------------------------------------------------===//
        -:  343:
function _ZN4llvm12ilist_detail18SpecificNodeAccessINS0_12node_optionsIN4mlir9OperationELb1ELb0EvEEE10getNodePtrEPS4_ called 812973566 returned 100% blocks executed 100%
813065162:  344:auto llvm::ilist_detail::SpecificNodeAccess<
        -:  345:    typename llvm::ilist_detail::compute_node_options<
        -:  346:        ::mlir::Operation>::type>::getNodePtr(pointer n) -> node_type * {
    91596:  347:  return NodeAccess::getNodePtr<OptionsT>(n);
call    0 returned 100%
        -:  348:}
        -:  349:
function _ZN4llvm12ilist_detail18SpecificNodeAccessINS0_12node_optionsIN4mlir9OperationELb1ELb0EvEEE10getNodePtrEPKS4_ called 0 returned 0% blocks executed 0%
    #####:  350:auto llvm::ilist_detail::SpecificNodeAccess<
        -:  351:    typename llvm::ilist_detail::compute_node_options<
        -:  352:        ::mlir::Operation>::type>::getNodePtr(const_pointer n)
        -:  353:    -> const node_type * {
    #####:  354:  return NodeAccess::getNodePtr<OptionsT>(n);
        -:  355:}
        -:  356:
function _ZN4llvm12ilist_detail18SpecificNodeAccessINS0_12node_optionsIN4mlir9OperationELb1ELb0EvEEE11getValuePtrEPNS_15ilist_node_implIS5_EE called 361536356855 returned 100% blocks executed 100%
371900262163:  357:auto llvm::ilist_detail::SpecificNodeAccess<
        -:  358:    typename llvm::ilist_detail::compute_node_options<
        -:  359:        ::mlir::Operation>::type>::getValuePtr(node_type *n) -> pointer {
9901232142:  360:  return NodeAccess::getValuePtr<OptionsT>(n);
call    0 returned 100%
call    1 returned 100%
        -:  361:}
        -:  362:
function _ZN4llvm12ilist_detail18SpecificNodeAccessINS0_12node_optionsIN4mlir9OperationELb1ELb0EvEEE11getValuePtrEPKNS_15ilist_node_implIS5_EE called 0 returned 0% blocks executed 0%
    #####:  363:auto llvm::ilist_detail::SpecificNodeAccess<
        -:  364:    typename llvm::ilist_detail::compute_node_options<
        -:  365:        ::mlir::Operation>::type>::getValuePtr(const node_type *n)
        -:  366:    -> const_pointer {
    #####:  367:  return NodeAccess::getValuePtr<OptionsT>(n);
        -:  368:}
        -:  369:
function _ZN4llvm12ilist_traitsIN4mlir9OperationEE10deleteNodeEPS2_ called 221734610 returned 100% blocks executed 100%
221734610:  370:void llvm::ilist_traits<::mlir::Operation>::deleteNode(Operation *op) {
221734610:  371:  op->destroy();
call    0 returned 100%
221734610:  372:}
        -:  373:
function _ZN4llvm12ilist_traitsIN4mlir9OperationEE18getContainingBlockEv called 0 returned 0% blocks executed 0%
260180325*:  374:Block *llvm::ilist_traits<::mlir::Operation>::getContainingBlock() {
260180325*:  375:  size_t offset(size_t(&((Block *)nullptr->*Block::getSublistAccess(nullptr))));
260180325*:  376:  iplist<Operation> *anchor(static_cast<iplist<Operation> *>(this));
 1148808*:  377:  return reinterpret_cast<Block *>(reinterpret_cast<char *>(anchor) - offset);
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  378:}
        -:  379:
        -:  380:/// This is a trait method invoked when an operation is added to a block.  We
        -:  381:/// keep the block pointer up to date.
function _ZN4llvm12ilist_traitsIN4mlir9OperationEE13addNodeToListEPS2_ called 257882709 returned 100% blocks executed 67%
257882709:  382:void llvm::ilist_traits<::mlir::Operation>::addNodeToList(Operation *op) {
257882709*:  383:  assert(!op->getBlock() && "already in an operation block!");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
257882709:  384:  op->block = getContainingBlock();
        -:  385:
        -:  386:  // Invalidate the order on the operation.
257882709:  387:  op->orderIndex = Operation::kInvalidOrderIdx;
257882709:  388:}
        -:  389:
        -:  390:/// This is a trait method invoked when an operation is removed from a block.
        -:  391:/// We keep the block pointer up to date.
function _ZN4llvm12ilist_traitsIN4mlir9OperationEE18removeNodeFromListEPS2_ called 222051032 returned 100% blocks executed 67%
222051032:  392:void llvm::ilist_traits<::mlir::Operation>::removeNodeFromList(Operation *op) {
222051032*:  393:  assert(op->block && "not already in an operation block!");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
222051032:  394:  op->block = nullptr;
222051032:  395:}
        -:  396:
        -:  397:/// This is a trait method invoked when an operation is moved from one block
        -:  398:/// to another.  We keep the block pointer up to date.
function _ZN4llvm12ilist_traitsIN4mlir9OperationEE21transferNodesFromListERS3_NS_14ilist_iteratorINS_12ilist_detail12node_optionsIS2_Lb1ELb0EvEELb0ELb0EEES9_ called 1148808 returned 100% blocks executed 86%
  1148808:  399:void llvm::ilist_traits<::mlir::Operation>::transferNodesFromList(
        -:  400:    ilist_traits<Operation> &otherList, op_iterator first, op_iterator last) {
  1148808:  401:  Block *curParent = getContainingBlock();
call    0 returned 100%
        -:  402:
        -:  403:  // Invalidate the ordering of the parent block.
  1148808:  404:  curParent->invalidateOpOrder();
call    0 returned 100%
        -:  405:
        -:  406:  // If we are transferring operations within the same block, the block
        -:  407:  // pointer doesn't need to be updated.
  1148808:  408:  if (curParent == otherList.getContainingBlock())
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  409:    return;
        -:  410:
        -:  411:  // Update the 'block' member of each operation.
 10201545:  412:  for (; first != last; ++first)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
  9547078:  413:    first->block = curParent;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  414:}
        -:  415:
        -:  416:/// Remove this operation (and its descendants) from its Block and delete
        -:  417:/// all of them.
function _ZN4mlir9Operation5eraseEv called 35564582 returned 100% blocks executed 100%
 35564582:  418:void Operation::erase() {
 35564582:  419:  if (auto *parent = getBlock())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
 35059227:  420:    parent->getOperations().erase(this);
call    0 returned 100%
        -:  421:  else
   505355:  422:    destroy();
call    0 returned 100%
 35564585:  423:}
        -:  424:
        -:  425:/// Remove the operation from its parent block, but don't delete it.
function _ZN4mlir9Operation6removeEv called 91596 returned 100% blocks executed 100%
    91596:  426:void Operation::remove() {
    91596:  427:  if (Block *parent = getBlock())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    91596:  428:    parent->getOperations().remove(this);
call    0 returned 100%
    91596:  429:}
        -:  430:
        -:  431:/// Unlink this operation from its current block and insert it right before
        -:  432:/// `existingOp` which may be in the same or another block in the same
        -:  433:/// function.
function _ZN4mlir9Operation10moveBeforeEPS0_ called 945598 returned 100% blocks executed 100%
   945598:  434:void Operation::moveBefore(Operation *existingOp) {
   945598:  435:  moveBefore(existingOp->getBlock(), existingOp->getIterator());
call    0 returned 100%
   945598:  436:}
        -:  437:
        -:  438:/// Unlink this operation from its current basic block and insert it right
        -:  439:/// before `iterator` in the specified basic block.
function _ZN4mlir9Operation10moveBeforeEPNS_5BlockEN4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsIS0_Lb1ELb0EvEELb0ELb0EEE called 948575 returned 100% blocks executed 100%
   948575:  440:void Operation::moveBefore(Block *block,
        -:  441:                           llvm::iplist<Operation>::iterator iterator) {
   948575:  442:  block->getOperations().splice(iterator, getBlock()->getOperations(),
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -:  443:                                getIterator());
   948575:  444:}
        -:  445:
        -:  446:/// Unlink this operation from its current block and insert it right after
        -:  447:/// `existingOp` which may be in the same or another block in the same function.
function _ZN4mlir9Operation9moveAfterEPS0_ called 163 returned 100% blocks executed 100%
      163:  448:void Operation::moveAfter(Operation *existingOp) {
      163:  449:  moveAfter(existingOp->getBlock(), existingOp->getIterator());
call    0 returned 100%
      163:  450:}
        -:  451:
        -:  452:/// Unlink this operation from its current block and insert it right after
        -:  453:/// `iterator` in the specified block.
function _ZN4mlir9Operation9moveAfterEPNS_5BlockEN4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsIS0_Lb1ELb0EvEELb0ELb0EEE called 163 returned 100% blocks executed 86%
      163:  454:void Operation::moveAfter(Block *block,
        -:  455:                          llvm::iplist<Operation>::iterator iterator) {
     163*:  456:  assert(iterator != block->end() && "cannot move after end of block");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
      163:  457:  moveBefore(block, std::next(iterator));
call    0 returned 100%
      163:  458:}
        -:  459:
        -:  460:/// This drops all operand uses from this operation, which is an essential
        -:  461:/// step in breaking cyclic dependences between references when they are to
        -:  462:/// be deleted.
function _ZN4mlir9Operation17dropAllReferencesEv called 1364391113 returned 100% blocks executed 100%
1364391113:  463:void Operation::dropAllReferences() {
4835062359:  464:  for (auto &op : getOpOperands())
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
4019401644:  465:    op.drop();
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -:  466:
1521216635:  467:  for (auto &region : getRegions())
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
 57534850:  468:    region.dropAllReferences();
call    0 returned 100%
        -:  469:
1464049467:  470:  for (auto &dest : getBlockOperands())
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
   449148:  471:    dest.drop();
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
1364391113:  472:}
        -:  473:
        -:  474:/// This drops all uses of any values defined by this operation or its nested
        -:  475:/// regions, wherever they are located.
function _ZN4mlir9Operation23dropAllDefinedValueUsesEv called 102 returned 100% blocks executed 38%
      102:  476:void Operation::dropAllDefinedValueUses() {
      102:  477:  dropAllUses();
call    0 returned 100%
        -:  478:
     102*:  479:  for (auto &region : getRegions())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  480:    for (auto &block : region)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  481:      block.dropAllDefinedValueUses();
call    0 never executed
      102:  482:}
        -:  483:
function _ZN4mlir9Operation12setSuccessorEPNS_5BlockEj called 0 returned 0% blocks executed 0%
    #####:  484:void Operation::setSuccessor(Block *block, unsigned index) {
    #####:  485:  assert(index < getNumSuccessors());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  486:  getBlockOperands()[index].set(block);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  487:}
        -:  488:
        -:  489:/// Attempt to fold this operation using the Op's registered foldHook.
function _ZN4mlir9Operation4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 143042308 returned 100% blocks executed 75%
143042308:  490:LogicalResult Operation::fold(ArrayRef<Attribute> operands,
        -:  491:                              SmallVectorImpl<OpFoldResult> &results) {
        -:  492:  // If we have a registered operation definition matching this one, use it to
        -:  493:  // try to constant fold the operation.
143042308:  494:  Optional<RegisteredOperationName> info = getRegisteredInfo();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
143042308:  495:  if (info && succeeded(info->foldHook(this, operands, results)))
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 68% (fallthrough)
branch  4 taken 32%
 97110879:  496:    return success();
        -:  497:
        -:  498:  // Otherwise, fall back on the dialect hook to handle it.
 45931233:  499:  Dialect *dialect = getDialect();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 45931233:  500:  if (!dialect)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  501:    return failure();
        -:  502:
 45931233:  503:  auto *interface = dyn_cast<DialectFoldInterface>(dialect);
call    0 returned 100%
 45931214:  504:  if (!interface)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 45931214:  505:    return failure();
        -:  506:
    #####:  507:  return interface->fold(this, operands, results);
call    0 never executed
        -:  508:}
        -:  509:
        -:  510:/// Emit an error with the op name prefixed, like "'dim' op " which is
        -:  511:/// convenient for verifiers.
function _ZN4mlir9Operation11emitOpErrorERKN4llvm5TwineE called 2989004 returned 100% blocks executed 100%
  2989004:  512:InFlightDiagnostic Operation::emitOpError(const Twine &message) {
  2989004:  513:  return emitError() << "'" << getName() << "' op " << message;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
        -:  514:}
        -:  515:
        -:  516://===----------------------------------------------------------------------===//
        -:  517:// Operation Cloning
        -:  518://===----------------------------------------------------------------------===//
        -:  519:
function _ZN4mlir9Operation12CloneOptionsC2Ev called 0 returned 0% blocks executed 0%
  759038*:  520:Operation::CloneOptions::CloneOptions()
    #####:  521:    : cloneRegionsFlag(false), cloneOperandsFlag(false) {}
        -:  522:
function _ZN4mlir9Operation12CloneOptionsC2Ebb called 0 returned 0% blocks executed 0%
    #####:  523:Operation::CloneOptions::CloneOptions(bool cloneRegions, bool cloneOperands)
    #####:  524:    : cloneRegionsFlag(cloneRegions), cloneOperandsFlag(cloneOperands) {}
        -:  525:
function _ZN4mlir9Operation12CloneOptions3allEv called 758825 returned 100% blocks executed 100%
  759038*:  526:Operation::CloneOptions Operation::CloneOptions::all() {
  759038*:  527:  return CloneOptions().cloneRegions().cloneOperands();
        -:  528:}
        -:  529:
function _ZN4mlir9Operation12CloneOptions12cloneRegionsEb called 339495 returned 100% blocks executed 100%
 1098533*:  530:Operation::CloneOptions &Operation::CloneOptions::cloneRegions(bool enable) {
 1098533*:  531:  cloneRegionsFlag = enable;
 1098533*:  532:  return *this;
        -:  533:}
        -:  534:
function _ZN4mlir9Operation12CloneOptions13cloneOperandsEb called 339495 returned 100% blocks executed 100%
 1098533*:  535:Operation::CloneOptions &Operation::CloneOptions::cloneOperands(bool enable) {
 1098533*:  536:  cloneOperandsFlag = enable;
 1098533*:  537:  return *this;
        -:  538:}
        -:  539:
        -:  540:/// Create a deep copy of this operation but keep the operation regions empty.
        -:  541:/// Operands are remapped using `mapper` (if present), and `mapper` is updated
        -:  542:/// to contain the results. The `mapResults` flag specifies whether the results
        -:  543:/// of the cloned operation should be added to the map.
function _ZN4mlir9Operation19cloneWithoutRegionsERNS_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
     213*:  544:Operation *Operation::cloneWithoutRegions(BlockAndValueMapping &mapper) {
    #####:  545:  return clone(mapper, CloneOptions::all().cloneRegions(false));
call    0 never executed
        -:  546:}
        -:  547:
function _ZN4mlir9Operation19cloneWithoutRegionsEv called 213 returned 100% blocks executed 100%
      213:  548:Operation *Operation::cloneWithoutRegions() {
      213:  549:  BlockAndValueMapping mapper;
call    0 returned 100%
      213:  550:  return cloneWithoutRegions(mapper);
call    0 returned 100%
call    1 returned 100%
        -:  551:}
        -:  552:
        -:  553:/// Create a deep copy of this operation, remapping any operands that use
        -:  554:/// values outside of the operation using the map that is provided (leaving
        -:  555:/// them alone if no entry is present).  Replaces references to cloned
        -:  556:/// sub-operations to the corresponding operation that is copied, and adds
        -:  557:/// those mappings to the map.
function _ZN4mlir9Operation5cloneERNS_20BlockAndValueMappingENS0_12CloneOptionsE called 7831514 returned 100% blocks executed 81%
  7831514:  558:Operation *Operation::clone(BlockAndValueMapping &mapper,
        -:  559:                            CloneOptions options) {
  7831514:  560:  SmallVector<Value, 8> operands;
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
  7831514:  561:  SmallVector<Block *, 2> successors;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  562:
        -:  563:  // Remap the operands.
  7831514:  564:  if (options.shouldCloneOperands()) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
   790361:  565:    operands.reserve(getNumOperands());
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
  1238373:  566:    for (auto opValue : getOperands())
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
call    3 returned 100%
   818830:  567:      operands.push_back(mapper.lookupOrDefault(opValue));
call    0 returned 100%
call    1 returned 100%
        -:  568:  }
        -:  569:
        -:  570:  // Remap the successors.
  7831514:  571:  successors.reserve(getNumSuccessors());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 7831514*:  572:  for (Block *successor : getSuccessors())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    #####:  573:    successors.push_back(mapper.lookupOrDefault(successor));
call    0 never executed
call    1 never executed
        -:  574:
        -:  575:  // Create the new operation.
 15663028:  576:  auto *newOp = create(getLoc(), getName(), getResultTypes(), operands, attrs,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 88% (fallthrough)
branch  4 taken 12%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:  577:                       successors, getNumRegions());
        -:  578:
        -:  579:  // Clone the regions.
  7831514:  580:  if (options.shouldCloneRegions()) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
   440013:  581:    for (unsigned i = 0; i != numRegions; ++i)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
    20683:  582:      getRegion(i).cloneInto(&newOp->getRegion(i), mapper);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  583:  }
        -:  584:
        -:  585:  // Remember the mapping of any results.
 14745661:  586:  for (unsigned i = 0, e = getNumResults(); i != e; ++i)
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
 20742441:  587:    mapper.map(getResult(i), newOp->getResult(i));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
        -:  588:
  7831514:  589:  return newOp;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  590:}
        -:  591:
function _ZN4mlir9Operation5cloneENS0_12CloneOptionsE called 2400 returned 100% blocks executed 100%
     2400:  592:Operation *Operation::clone(CloneOptions options) {
     4800:  593:  BlockAndValueMapping mapper;
call    0 returned 100%
call    1 returned 100%
     2400:  594:  return clone(mapper, options);
call    0 returned 100%
        -:  595:}
        -:  596:
        -:  597://===----------------------------------------------------------------------===//
        -:  598:// OpState trait class.
        -:  599://===----------------------------------------------------------------------===//
        -:  600:
        -:  601:// The fallback for the parser is to try for a dialect operation parser.
        -:  602:// Otherwise, reject the custom assembly form.
function _ZN4mlir7OpState5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  603:ParseResult OpState::parse(OpAsmParser &parser, OperationState &result) {
    #####:  604:  if (auto parseFn = result.name.getDialect()->getParseOperationHook(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  605:          result.name.getStringRef()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  606:    return (*parseFn)(parser, result);
call    0 never executed
    #####:  607:  return parser.emitError(parser.getNameLoc(), "has no custom assembly form");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  608:}
        -:  609:
        -:  610:// The fallback for the printer is to try for a dialect operation printer.
        -:  611:// Otherwise, it prints the generic form.
function _ZN4mlir7OpState5printEPNS_9OperationERNS_12OpAsmPrinterEN4llvm9StringRefE called 117304 returned 100% blocks executed 67%
   117304:  612:void OpState::print(Operation *op, OpAsmPrinter &p, StringRef defaultDialect) {
   117304:  613:  if (auto printFn = op->getDialect()->getOperationPrinter(op)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  614:    printOpName(op, p, defaultDialect);
call    0 never executed
    #####:  615:    printFn(op, p);
call    0 never executed
        -:  616:  } else {
   117304:  617:    p.printGenericOp(op);
call    0 returned 100%
        -:  618:  }
   117304:  619:}
        -:  620:
        -:  621:/// Print an operation name, eliding the dialect prefix if necessary and doesn't
        -:  622:/// lead to ambiguities.
function _ZN4mlir7OpState11printOpNameEPNS_9OperationERNS_12OpAsmPrinterEN4llvm9StringRefE called 304810315 returned 100% blocks executed 84%
304810315:  623:void OpState::printOpName(Operation *op, OpAsmPrinter &p,
        -:  624:                          StringRef defaultDialect) {
304810315:  625:  StringRef name = op->getName().getStringRef();
call    0 returned 100%
304974856:  626:  if (name.startswith((defaultDialect + ".").str()) && name.count('.') == 1)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 1% (fallthrough)
branch  9 taken 100%
   164541:  627:    name = name.drop_front(defaultDialect.size() + 1);
call    0 returned 100%
304810315:  628:  p.getStream() << name;
call    0 returned 100%
call    1 returned 100%
304810315:  629:}
        -:  630:
        -:  631:/// Emit an error about fatal conditions with this operation, reporting up to
        -:  632:/// any diagnostic handlers that may be listening.
function _ZN4mlir7OpState9emitErrorERKN4llvm5TwineE called 4291 returned 100% blocks executed 100%
     4291:  633:InFlightDiagnostic OpState::emitError(const Twine &message) {
     4291:  634:  return getOperation()->emitError(message);
call    0 returned 100%
        -:  635:}
        -:  636:
        -:  637:/// Emit an error with the op name prefixed, like "'dim' op " which is
        -:  638:/// convenient for verifiers.
function _ZN4mlir7OpState11emitOpErrorERKN4llvm5TwineE called 27344 returned 100% blocks executed 100%
    27344:  639:InFlightDiagnostic OpState::emitOpError(const Twine &message) {
    27344:  640:  return getOperation()->emitOpError(message);
call    0 returned 100%
        -:  641:}
        -:  642:
        -:  643:/// Emit a warning about this operation, reporting up to any diagnostic
        -:  644:/// handlers that may be listening.
function _ZN4mlir7OpState11emitWarningERKN4llvm5TwineE called 0 returned 0% blocks executed 0%
    #####:  645:InFlightDiagnostic OpState::emitWarning(const Twine &message) {
    #####:  646:  return getOperation()->emitWarning(message);
call    0 never executed
        -:  647:}
        -:  648:
        -:  649:/// Emit a remark about this operation, reporting up to any diagnostic
        -:  650:/// handlers that may be listening.
function _ZN4mlir7OpState10emitRemarkERKN4llvm5TwineE called 704302 returned 100% blocks executed 100%
   704302:  651:InFlightDiagnostic OpState::emitRemark(const Twine &message) {
   704302:  652:  return getOperation()->emitRemark(message);
call    0 returned 100%
        -:  653:}
        -:  654:
        -:  655://===----------------------------------------------------------------------===//
        -:  656:// Op Trait implementations
        -:  657://===----------------------------------------------------------------------===//
        -:  658:
function _ZN4mlir7OpTrait4impl14foldIdempotentEPNS_9OperationE called 139693 returned 100% blocks executed 56%
   139693:  659:OpFoldResult OpTrait::impl::foldIdempotent(Operation *op) {
   279386:  660:  if (op->getNumOperands() == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  661:    auto *argumentOp = op->getOperand(0).getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  662:    if (argumentOp && op->getName() == argumentOp->getName()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  663:      // Replace the outer operation output with the inner operation.
    #####:  664:      return op->getOperand(0);
call    0 never executed
call    1 never executed
        -:  665:    }
   139693:  666:  } else if (op->getOperand(0) == op->getOperand(1)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 9% (fallthrough)
branch  3 taken 91%
    12598:  667:    return op->getOperand(0);
call    0 returned 100%
        -:  668:  }
        -:  669:
   127095:  670:  return {};
        -:  671:}
        -:  672:
function _ZN4mlir7OpTrait4impl14foldInvolutionEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  673:OpFoldResult OpTrait::impl::foldInvolution(Operation *op) {
    #####:  674:  auto *argumentOp = op->getOperand(0).getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  675:  if (argumentOp && op->getName() == argumentOp->getName()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  676:    // Replace the outer involutions output with inner's input.
    #####:  677:    return argumentOp->getOperand(0);
call    0 never executed
call    1 never executed
        -:  678:  }
        -:  679:
    #####:  680:  return {};
        -:  681:}
        -:  682:
function _ZN4mlir7OpTrait4impl18verifyZeroOperandsEPNS_9OperationE called 790161080 returned 100% blocks executed 42%
790161080:  683:LogicalResult OpTrait::impl::verifyZeroOperands(Operation *op) {
790161183:  684:  if (op->getNumOperands() != 0)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  685:    return op->emitOpError() << "requires zero operands";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
790161080:  686:  return success();
        -:  687:}
        -:  688:
function _ZN4mlir7OpTrait4impl16verifyOneOperandEPNS_9OperationE called 3056678909 returned 100% blocks executed 50%
3056678909:  689:LogicalResult OpTrait::impl::verifyOneOperand(Operation *op) {
6113357818:  690:  if (op->getNumOperands() != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken -0% (fallthrough)
branch  3 taken 100%
    #####:  691:    return op->emitOpError() << "requires a single operand";
call    0 returned -0%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
3056678934:  692:  return success();
        -:  693:}
        -:  694:
function _ZN4mlir7OpTrait4impl15verifyNOperandsEPNS_9OperationEj called 3191085120 returned 100% blocks executed 30%
3191085120:  695:LogicalResult OpTrait::impl::verifyNOperands(Operation *op,
        -:  696:                                             unsigned numOperands) {
6382170240:  697:  if (op->getNumOperands() != numOperands) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  698:    return op->emitOpError() << "expected " << numOperands
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  699:                             << " operands, but found " << op->getNumOperands();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  700:  }
3191085120:  701:  return success();
        -:  702:}
        -:  703:
function _ZN4mlir7OpTrait4impl22verifyAtLeastNOperandsEPNS_9OperationEj called 4191592402 returned 100% blocks executed 30%
4191592402:  704:LogicalResult OpTrait::impl::verifyAtLeastNOperands(Operation *op,
        -:  705:                                                    unsigned numOperands) {
8383184804:  706:  if (op->getNumOperands() < numOperands)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  707:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  708:           << "expected " << numOperands << " or more operands, but found "
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  709:           << op->getNumOperands();
call    0 never executed
call    1 never executed
call    2 never executed
4191592402:  710:  return success();
        -:  711:}
        -:  712:
        -:  713:/// If this is a vector type, or a tensor type, return the scalar element type
        -:  714:/// that it is built around, otherwise return the type unmodified.
function _ZL28getTensorOrVectorElementTypeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:  715:static Type getTensorOrVectorElementType(Type type) {
    #####:  716:  if (auto vec = type.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  717:    return vec.getElementType();
call    0 never executed
        -:  718:
        -:  719:  // Look through tensor<vector<...>> to find the underlying element type.
    #####:  720:  if (auto tensor = type.dyn_cast<TensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  721:    return getTensorOrVectorElementType(tensor.getElementType());
call    0 never executed
call    1 never executed
    #####:  722:  return type;
        -:  723:}
        -:  724:
function _ZN4mlir7OpTrait4impl18verifyIsIdempotentEPNS_9OperationE called 109146325 returned 100% blocks executed 100%
109146325:  725:LogicalResult OpTrait::impl::verifyIsIdempotent(Operation *op) {
        -:  726:  // FIXME: Add back check for no side effects on operation.
        -:  727:  // Currently adding it would cause the shared library build
        -:  728:  // to fail since there would be a dependency of IR on SideEffectInterfaces
        -:  729:  // which is cyclical.
109146325:  730:  return success();
        -:  731:}
        -:  732:
function _ZN4mlir7OpTrait4impl18verifyIsInvolutionEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  733:LogicalResult OpTrait::impl::verifyIsInvolution(Operation *op) {
        -:  734:  // FIXME: Add back check for no side effects on operation.
        -:  735:  // Currently adding it would cause the shared library build
        -:  736:  // to fail since there would be a dependency of IR on SideEffectInterfaces
        -:  737:  // which is cyclical.
    #####:  738:  return success();
        -:  739:}
        -:  740:
        -:  741:LogicalResult
function _ZN4mlir7OpTrait4impl36verifyOperandsAreSignlessIntegerLikeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  742:OpTrait::impl::verifyOperandsAreSignlessIntegerLike(Operation *op) {
    #####:  743:  for (auto opType : op->getOperandTypes()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  744:    auto type = getTensorOrVectorElementType(opType);
call    0 never executed
    #####:  745:    if (!type.isSignlessIntOrIndex())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  746:      return op->emitOpError() << "requires an integer or index type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  747:  }
    #####:  748:  return success();
        -:  749:}
        -:  750:
function _ZN4mlir7OpTrait4impl26verifyOperandsAreFloatLikeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  751:LogicalResult OpTrait::impl::verifyOperandsAreFloatLike(Operation *op) {
    #####:  752:  for (auto opType : op->getOperandTypes()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  753:    auto type = getTensorOrVectorElementType(opType);
call    0 never executed
    #####:  754:    if (!type.isa<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:      return op->emitOpError("requires a float type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  756:  }
    #####:  757:  return success();
        -:  758:}
        -:  759:
function _ZN4mlir7OpTrait4impl22verifySameTypeOperandsEPNS_9OperationE called 114587840 returned 100% blocks executed 65%
114587840:  760:LogicalResult OpTrait::impl::verifySameTypeOperands(Operation *op) {
        -:  761:  // Zero or one operand always have the "same" type.
114587840:  762:  unsigned nOperands = op->getNumOperands();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
114587840:  763:  if (nOperands < 2)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        8:  764:    return success();
        -:  765:
114587832:  766:  auto type = op->getOperand(0).getType();
call    0 returned 100%
call    1 returned 100%
229175663:  767:  for (auto opType : llvm::drop_begin(op->getOperandTypes(), 1))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
114587832:  768:    if (opType != type)
branch  0 taken 0%
branch  1 taken 100%
    #####:  769:      return op->emitOpError() << "requires all operands to have the same type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
114587832:  770:  return success();
        -:  771:}
        -:  772:
function _ZN4mlir7OpTrait4impl17verifyZeroRegionsEPNS_9OperationE called 9614201115 returned 100% blocks executed 33%
9614201115:  773:LogicalResult OpTrait::impl::verifyZeroRegions(Operation *op) {
9614201115:  774:  if (op->getNumRegions() != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  775:    return op->emitOpError() << "requires zero regions";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
9614201115:  776:  return success();
        -:  777:}
        -:  778:
function _ZN4mlir7OpTrait4impl15verifyOneRegionEPNS_9OperationE called 237571481 returned 100% blocks executed 33%
237571481:  779:LogicalResult OpTrait::impl::verifyOneRegion(Operation *op) {
237571481:  780:  if (op->getNumRegions() != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  781:    return op->emitOpError() << "requires one region";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
237571481:  782:  return success();
        -:  783:}
        -:  784:
function _ZN4mlir7OpTrait4impl14verifyNRegionsEPNS_9OperationEj called 69878496 returned 100% blocks executed 27%
 69878496:  785:LogicalResult OpTrait::impl::verifyNRegions(Operation *op,
        -:  786:                                            unsigned numRegions) {
 69878496:  787:  if (op->getNumRegions() != numRegions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  788:    return op->emitOpError() << "expected " << numRegions << " regions";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 69878496:  789:  return success();
        -:  790:}
        -:  791:
function _ZN4mlir7OpTrait4impl21verifyAtLeastNRegionsEPNS_9OperationEj called 25869331 returned 100% blocks executed 27%
 25869331:  792:LogicalResult OpTrait::impl::verifyAtLeastNRegions(Operation *op,
        -:  793:                                                   unsigned numRegions) {
 25869331:  794:  if (op->getNumRegions() < numRegions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  795:    return op->emitOpError() << "expected " << numRegions << " or more regions";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 25869331:  796:  return success();
        -:  797:}
        -:  798:
function _ZN4mlir7OpTrait4impl17verifyZeroResultsEPNS_9OperationE called 1070642715 returned 100% blocks executed 33%
1070642715:  799:LogicalResult OpTrait::impl::verifyZeroResults(Operation *op) {
1070642715:  800:  if (op->getNumResults() != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  801:    return op->emitOpError() << "requires zero results";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
1070642715:  802:  return success();
        -:  803:}
        -:  804:
function _ZN4mlir7OpTrait4impl15verifyOneResultEPNS_9OperationE called 7622068874 returned 100% blocks executed 33%
7622068874:  805:LogicalResult OpTrait::impl::verifyOneResult(Operation *op) {
7622068874:  806:  if (op->getNumResults() != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  807:    return op->emitOpError() << "requires one result";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
7622068874:  808:  return success();
        -:  809:}
        -:  810:
function _ZN4mlir7OpTrait4impl14verifyNResultsEPNS_9OperationEj called 60377292 returned 100% blocks executed 27%
 60377292:  811:LogicalResult OpTrait::impl::verifyNResults(Operation *op,
        -:  812:                                            unsigned numOperands) {
 60377292:  813:  if (op->getNumResults() != numOperands)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  814:    return op->emitOpError() << "expected " << numOperands << " results";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 60377292:  815:  return success();
        -:  816:}
        -:  817:
function _ZN4mlir7OpTrait4impl21verifyAtLeastNResultsEPNS_9OperationEj called 3041340583 returned 100% blocks executed 27%
3041340583:  818:LogicalResult OpTrait::impl::verifyAtLeastNResults(Operation *op,
        -:  819:                                                   unsigned numOperands) {
3041340583:  820:  if (op->getNumResults() < numOperands)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  821:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  822:           << "expected " << numOperands << " or more results";
call    0 never executed
call    1 never executed
call    2 never executed
3041340583:  823:  return success();
        -:  824:}
        -:  825:
function _ZN4mlir7OpTrait4impl23verifySameOperandsShapeEPNS_9OperationE called 107866263 returned 100% blocks executed 53%
107866263:  826:LogicalResult OpTrait::impl::verifySameOperandsShape(Operation *op) {
107866263:  827:  if (failed(verifyAtLeastNOperands(op, 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  828:    return failure();
        -:  829:
107866262:  830:  if (failed(verifyCompatibleShapes(op->getOperandTypes())))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  831:    return op->emitOpError() << "requires the same shape for all operands";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  832:
107866261:  833:  return success();
        -:  834:}
        -:  835:
function _ZN4mlir7OpTrait4impl32verifySameOperandsAndResultShapeEPNS_9OperationE called 290248359 returned 100% blocks executed 68%
290248359:  836:LogicalResult OpTrait::impl::verifySameOperandsAndResultShape(Operation *op) {
290248359:  837:  if (failed(verifyAtLeastNOperands(op, 1)) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
290248358:  838:      failed(verifyAtLeastNResults(op, 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  839:    return failure();
        -:  840:
290248358:  841:  SmallVector<Type, 8> types(op->getOperandTypes());
call    0 returned 100%
call    1 returned 100%
580496710:  842:  types.append(llvm::to_vector<4>(op->getResultTypes()));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  843:
290248354:  844:  if (failed(verifyCompatibleShapes(types)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  845:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  846:           << "requires the same shape for all operands and results";
call    0 never executed
        -:  847:
290248341:  848:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  849:}
        -:  850:
function _ZN4mlir7OpTrait4impl29verifySameOperandsElementTypeEPNS_9OperationE called 107866263 returned 100% blocks executed 67%
107866263:  851:LogicalResult OpTrait::impl::verifySameOperandsElementType(Operation *op) {
107866263:  852:  if (failed(verifyAtLeastNOperands(op, 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  853:    return failure();
107866264:  854:  auto elementType = getElementTypeOrSelf(op->getOperand(0));
call    0 returned 100%
call    1 returned 100%
        -:  855:
215732517:  856:  for (auto operand : llvm::drop_begin(op->getOperands(), 1)) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
107866260:  857:    if (getElementTypeOrSelf(operand) != elementType)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  858:      return op->emitOpError("requires the same element type for all operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  859:  }
        -:  860:
107866257:  861:  return success();
        -:  862:}
        -:  863:
        -:  864:LogicalResult
function _ZN4mlir7OpTrait4impl38verifySameOperandsAndResultElementTypeEPNS_9OperationE called 81936664 returned 100% blocks executed 53%
 81936664:  865:OpTrait::impl::verifySameOperandsAndResultElementType(Operation *op) {
 81936664:  866:  if (failed(verifyAtLeastNOperands(op, 1)) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 81936663:  867:      failed(verifyAtLeastNResults(op, 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  868:    return failure();
        -:  869:
 81936663:  870:  auto elementType = getElementTypeOrSelf(op->getResult(0));
call    0 returned 100%
        -:  871:
        -:  872:  // Verify result element type matches first result's element type.
163873324*:  873:  for (auto result : llvm::drop_begin(op->getResults(), 1)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
    #####:  874:    if (getElementTypeOrSelf(result) != elementType)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  875:      return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  876:          "requires the same element type for all operands and results");
call    0 never executed
        -:  877:  }
        -:  878:
        -:  879:  // Verify operand's element type matches first result's element type.
163873335:  880:  for (auto operand : op->getOperands()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
 81936670:  881:    if (getElementTypeOrSelf(operand) != elementType)
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  882:      return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  883:          "requires the same element type for all operands and results");
call    0 never executed
        -:  884:  }
        -:  885:
 81936662:  886:  return success();
        -:  887:}
        -:  888:
function _ZN4mlir7OpTrait4impl31verifySameOperandsAndResultTypeEPNS_9OperationE called 2669154379 returned 100% blocks executed 56%
2669154379:  889:LogicalResult OpTrait::impl::verifySameOperandsAndResultType(Operation *op) {
2669154379:  890:  if (failed(verifyAtLeastNOperands(op, 1)) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
2669154404:  891:      failed(verifyAtLeastNResults(op, 1)))
call    0 returned 100%
branch  1 taken -0% (fallthrough)
branch  2 taken 100%
    #####:  892:    return failure();
        -:  893:
2669154420:  894:  auto type = op->getResult(0).getType();
call    0 returned 100%
2669154420:  895:  auto elementType = getElementTypeOrSelf(type);
call    0 returned 100%
5338307488*:  896:  for (auto resultType : llvm::drop_begin(op->getResultTypes())) {
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
call    4 returned 0%
    #####:  897:    if (getElementTypeOrSelf(resultType) != elementType ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:        failed(verifyCompatibleShape(resultType, type)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  899:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  900:             << "requires the same type for all operands and results";
call    0 never executed
        -:  901:  }
11249028162:  902:  for (auto opType : op->getOperandTypes()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
8579877696*:  903:    if (getElementTypeOrSelf(opType) != elementType ||
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
4289936227:  904:        failed(verifyCompatibleShape(opType, type)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  905:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  906:             << "requires the same type for all operands and results";
call    0 never executed
        -:  907:  }
2669155173:  908:  return success();
        -:  909:}
        -:  910:
function _ZN4mlir7OpTrait4impl18verifyIsTerminatorEPNS_9OperationE called 457864233 returned 100% blocks executed 100%
457864233:  911:LogicalResult OpTrait::impl::verifyIsTerminator(Operation *op) {
457864233:  912:  Block *block = op->getBlock();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  913:  // Verify that the operation is at the end of the respective parent block.
915728454:  914:  if (!block || &block->back() != op)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
       34:  915:    return op->emitOpError("must be the last operation in the parent block");
call    0 returned 121%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
457864187:  916:  return success();
        -:  917:}
        -:  918:
function _ZL26verifyTerminatorSuccessorsPN4mlir9OperationE called 17518 returned 100% blocks executed 67%
    17518:  919:static LogicalResult verifyTerminatorSuccessors(Operation *op) {
    17518:  920:  auto *parent = op->getParentRegion();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  921:
        -:  922:  // Verify that the operands lines up with the BB arguments in the successor.
    41103:  923:  for (Block *succ : op->getSuccessors())
call    0 returned 100%
branch  1 taken 43% (fallthrough)
branch  2 taken 57%
call    3 returned 100%
    23583:  924:    if (succ->getParent() != parent)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  925:      return op->emitError("reference to block defined in another region");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    17522:  926:  return success();
        -:  927:}
        -:  928:
function _ZN4mlir7OpTrait4impl20verifyZeroSuccessorsEPNS_9OperationE called 9947491390 returned 100% blocks executed 33%
9947491390:  929:LogicalResult OpTrait::impl::verifyZeroSuccessors(Operation *op) {
9947491390:  930:  if (op->getNumSuccessors() != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  931:    return op->emitOpError("requires 0 successors but found ")
call    0 never executed
call    1 never executed
    #####:  932:           << op->getNumSuccessors();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  933:  }
9947491390:  934:  return success();
        -:  935:}
        -:  936:
function _ZN4mlir7OpTrait4impl18verifyOneSuccessorEPNS_9OperationE called 11487 returned 100% blocks executed 33%
    11487:  937:LogicalResult OpTrait::impl::verifyOneSuccessor(Operation *op) {
    11487:  938:  if (op->getNumSuccessors() != 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  939:    return op->emitOpError("requires 1 successor but found ")
call    0 never executed
call    1 never executed
    #####:  940:           << op->getNumSuccessors();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  941:  }
    11487:  942:  return verifyTerminatorSuccessors(op);
call    0 returned 100%
        -:  943:}
function _ZN4mlir7OpTrait4impl17verifyNSuccessorsEPNS_9OperationEj called 6033 returned 100% blocks executed 27%
     6033:  944:LogicalResult OpTrait::impl::verifyNSuccessors(Operation *op,
        -:  945:                                               unsigned numSuccessors) {
     6033:  946:  if (op->getNumSuccessors() != numSuccessors) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  947:    return op->emitOpError("requires ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  948:           << numSuccessors << " successors but found "
call    0 never executed
    #####:  949:           << op->getNumSuccessors();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  950:  }
     6033:  951:  return verifyTerminatorSuccessors(op);
call    0 returned 100%
        -:  952:}
function _ZN4mlir7OpTrait4impl24verifyAtLeastNSuccessorsEPNS_9OperationEj called 0 returned 0% blocks executed 0%
    #####:  953:LogicalResult OpTrait::impl::verifyAtLeastNSuccessors(Operation *op,
        -:  954:                                                      unsigned numSuccessors) {
    #####:  955:  if (op->getNumSuccessors() < numSuccessors) {
branch  0 never executed
branch  1 never executed
    #####:  956:    return op->emitOpError("requires at least ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  957:           << numSuccessors << " successors but found "
call    0 never executed
    #####:  958:           << op->getNumSuccessors();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  959:  }
    #####:  960:  return verifyTerminatorSuccessors(op);
call    0 never executed
        -:  961:}
        -:  962:
function _ZN4mlir7OpTrait4impl24verifyResultsAreBoolLikeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  963:LogicalResult OpTrait::impl::verifyResultsAreBoolLike(Operation *op) {
    #####:  964:  for (auto resultType : op->getResultTypes()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  965:    auto elementType = getTensorOrVectorElementType(resultType);
call    0 never executed
    #####:  966:    bool isBoolType = elementType.isInteger(1);
call    0 never executed
    #####:  967:    if (!isBoolType)
branch  0 never executed
branch  1 never executed
    #####:  968:      return op->emitOpError() << "requires a bool result type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  969:  }
        -:  970:
    #####:  971:  return success();
        -:  972:}
        -:  973:
function _ZN4mlir7OpTrait4impl25verifyResultsAreFloatLikeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  974:LogicalResult OpTrait::impl::verifyResultsAreFloatLike(Operation *op) {
    #####:  975:  for (auto resultType : op->getResultTypes())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  976:    if (!getTensorOrVectorElementType(resultType).isa<FloatType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  977:      return op->emitOpError() << "requires a floating point type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  978:
    #####:  979:  return success();
        -:  980:}
        -:  981:
        -:  982:LogicalResult
function _ZN4mlir7OpTrait4impl35verifyResultsAreSignlessIntegerLikeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  983:OpTrait::impl::verifyResultsAreSignlessIntegerLike(Operation *op) {
    #####:  984:  for (auto resultType : op->getResultTypes())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  985:    if (!getTensorOrVectorElementType(resultType).isSignlessIntOrIndex())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  986:      return op->emitOpError() << "requires an integer or index type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  987:  return success();
        -:  988:}
        -:  989:
function _ZN4mlir7OpTrait4impl19verifyValueSizeAttrEPNS_9OperationEN4llvm9StringRefES5_m called 487875244 returned 100% blocks executed 25%
487875244:  990:LogicalResult OpTrait::impl::verifyValueSizeAttr(Operation *op,
        -:  991:                                                 StringRef attrName,
        -:  992:                                                 StringRef valueGroupName,
        -:  993:                                                 size_t expectedCount) {
487875244:  994:  auto sizeAttr = op->getAttrOfType<DenseI32ArrayAttr>(attrName);
call    0 returned 100%
487875443:  995:  if (!sizeAttr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  996:    return op->emitOpError("requires dense i32 array attribute '")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  997:           << attrName << "'";
call    0 never executed
call    1 never executed
        -:  998:
487875443:  999:  ArrayRef<int32_t> sizes = sizeAttr.asArrayRef();
call    0 returned 100%
487875447: 1000:  if (llvm::any_of(sizes, [](int32_t element) { return element < 0; }))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1001:    return op->emitOpError("'")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1002:           << attrName << "' attribute cannot have negative elements";
call    0 never executed
call    1 never executed
        -: 1003:
        -: 1004:  size_t totalCount =
1702284483: 1005:      std::accumulate(sizes.begin(), sizes.end(), 0,
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
1214409036: 1006:                      [](unsigned all, int32_t one) { return all + one; });
        -: 1007:
487875447: 1008:  if (totalCount != expectedCount)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1009:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1010:           << valueGroupName << " count (" << expectedCount
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1011:           << ") does not match with the total size (" << totalCount
call    0 never executed
call    1 never executed
    #####: 1012:           << ") specified in attribute '" << attrName << "'";
call    0 never executed
call    1 never executed
call    2 never executed
487875447: 1013:  return success();
        -: 1014:}
        -: 1015:
function _ZN4mlir7OpTrait4impl21verifyOperandSizeAttrEPNS_9OperationEN4llvm9StringRefE called 487875185 returned 100% blocks executed 83%
487875185: 1016:LogicalResult OpTrait::impl::verifyOperandSizeAttr(Operation *op,
        -: 1017:                                                   StringRef attrName) {
975750370: 1018:  return verifyValueSizeAttr(op, attrName, "operand", op->getNumOperands());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 1019:}
        -: 1020:
function _ZN4mlir7OpTrait4impl20verifyResultSizeAttrEPNS_9OperationEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1021:LogicalResult OpTrait::impl::verifyResultSizeAttr(Operation *op,
        -: 1022:                                                  StringRef attrName) {
    #####: 1023:  return verifyValueSizeAttr(op, attrName, "result", op->getNumResults());
call    0 never executed
        -: 1024:}
        -: 1025:
function _ZN4mlir7OpTrait4impl23verifyNoRegionArgumentsEPNS_9OperationE called 71165343 returned 100% blocks executed 44%
 71165343: 1026:LogicalResult OpTrait::impl::verifyNoRegionArguments(Operation *op) {
213495717: 1027:  for (Region &region : op->getRegions()) {
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
branch  2 taken 62% (fallthrough)
branch  3 taken 38%
117544193: 1028:    if (region.empty())
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
  7525838: 1029:      continue;
        -: 1030:
110018355: 1031:    if (region.getNumArguments() != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1032:      if (op->getNumRegions() > 1)
branch  0 never executed
branch  1 never executed
    #####: 1033:        return op->emitOpError("region #")
call    0 never executed
call    1 never executed
    #####: 1034:               << region.getRegionNumber() << " should have no arguments";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1035:      return op->emitOpError("region should have no arguments");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1036:    }
        -: 1037:  }
 71165343: 1038:  return success();
        -: 1039:}
        -: 1040:
function _ZN4mlir7OpTrait4impl17verifyElementwiseEPNS_9OperationE called 3042093836 returned 100% blocks executed 59%
3042093836: 1041:LogicalResult OpTrait::impl::verifyElementwise(Operation *op) {
11357507278: 1042:  auto isMappableType = [](Type type) {
8315413442: 1043:    return type.isa<VectorType, TensorType>();
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
call    3 returned 100%
branch  4 taken 32% (fallthrough)
branch  5 taken 68%
        -: 1044:  };
3042093836: 1045:  auto resultMappableTypes = llvm::to_vector<1>(
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
3042093630: 1046:      llvm::make_filter_range(op->getResultTypes(), isMappableType));
call    0 returned 100%
call    1 returned 100%
3042092377: 1047:  auto operandMappableTypes = llvm::to_vector<2>(
6084184875: 1048:      llvm::make_filter_range(op->getOperandTypes(), isMappableType));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1049:
        -: 1050:  // If the op only has scalar operand/result types, then we have nothing to
        -: 1051:  // check.
3042092752: 1052:  if (resultMappableTypes.empty() && operandMappableTypes.empty())
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
2072730905: 1053:    return success();
        -: 1054:
969361847: 1055:  if (!resultMappableTypes.empty() && operandMappableTypes.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 1056:    return op->emitOpError("if a result is non-scalar, then at least one "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1057:                           "operand must be non-scalar");
call    0 never executed
        -: 1058:
969361847*: 1059:  assert(!operandMappableTypes.empty());
branch  0 taken 0%
branch  1 taken 100%
call    2 never executed
        -: 1060:
969361847: 1061:  if (resultMappableTypes.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1062:    return op->emitOpError("if an operand is non-scalar, then there must be at "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1063:                           "least one non-scalar result");
call    0 never executed
        -: 1064:
969361847: 1065:  if (resultMappableTypes.size() != op->getNumResults())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1066:    return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1067:        "if an operand is non-scalar, then all results must be non-scalar");
call    0 never executed
        -: 1068:
969361847: 1069:  SmallVector<Type, 4> types = llvm::to_vector<2>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
4980816149: 1070:      llvm::concat<Type>(operandMappableTypes, resultMappableTypes));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
969361804: 1071:  TypeID expectedBaseTy = types.front().getTypeID();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
969361804: 1072:  if (!llvm::all_of(types,
call    0 returned 100%
3252378274: 1073:                    [&](Type t) { return t.getTypeID() == expectedBaseTy; }) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
969361762: 1074:      failed(verifyCompatibleShapes(types))) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken -0%
    #####: 1075:    return op->emitOpError() << "all non-scalar operands/results must have the "
call    0 returned -0%
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1076:                                "same shape and base type";
call    0 never executed
        -: 1077:  }
        -: 1078:
969361593: 1079:  return success();
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
        -: 1080:}
        -: 1081:
        -: 1082:/// Check for any values used by operations regions attached to the
        -: 1083:/// specified "IsIsolatedFromAbove" operation defined outside of it.
function _ZN4mlir7OpTrait4impl25verifyIsIsolatedFromAboveEPNS_9OperationE called 3843735 returned 100% blocks executed 87%
  3843735: 1084:LogicalResult OpTrait::impl::verifyIsIsolatedFromAbove(Operation *isolatedOp) {
 3843735*: 1085:  assert(isolatedOp->hasTrait<OpTrait::IsIsolatedFromAbove>() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1086:         "Intended to check IsolatedFromAbove ops");
        -: 1087:
        -: 1088:  // List of regions to analyze.  Each region is processed independently, with
        -: 1089:  // respect to the common `limit` region, so we can look at them in any order.
        -: 1090:  // Therefore, use a simple vector and push/pop back the current region.
  3844274: 1091:  SmallVector<Region *, 8> pendingRegions;
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
 11535822: 1092:  for (auto &region : isolatedOp->getRegions()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
  3844254: 1093:    pendingRegions.push_back(&region);
call    0 returned 100%
        -: 1094:
        -: 1095:    // Traverse all operations in the region.
466478582: 1096:    while (!pendingRegions.empty()) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
10816467488: 1097:      for (Operation &op : pendingRegions.pop_back_val()->getOps()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
call    4 returned 100%
33073679631: 1098:        for (Value operand : op.getOperands()) {
call    0 returned 100%
branch  1 taken 30% (fallthrough)
branch  2 taken 70%
call    3 returned 100%
        -: 1099:          // Check that any value that is used by an operation is defined in the
        -: 1100:          // same region as either an operation result.
23182474329: 1101:          auto *operandRegion = operand.getParentRegion();
call    0 returned 100%
23182474187: 1102:          if (!operandRegion)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1103:            return op.emitError("operation's operand is unlinked");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
25675816930: 1104:          if (!region.isAncestor(operandRegion)) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
      178: 1105:            return op.emitOpError("using value defined outside the region")
call    0 returned 100%
call    1 returned 100%
      178: 1106:                       .attachNote(isolatedOp->getLoc())
call    0 returned 100%
call    1 returned 100%
       89: 1107:                   << "required by region isolation constraints";
call    0 returned 100%
call    1 returned 100%
        -: 1108:          }
        -: 1109:        }
        -: 1110:
        -: 1111:        // Schedule any regions in the operation for further checking.  Don't
        -: 1112:        // recurse into other IsolatedFromAbove ops, because they will check
        -: 1113:        // themselves.
9891204983: 1114:        if (op.getNumRegions() &&
branch  0 taken 3%
branch  1 taken 97%
327512298: 1115:            !op.hasTrait<OpTrait::IsIsolatedFromAbove>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
834979112: 1116:          for (Region &subRegion : op.getRegions())
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
458787243: 1117:            pendingRegions.push_back(&subRegion);
call    0 returned 100%
        -: 1118:        }
        -: 1119:      }
        -: 1120:    }
        -: 1121:  }
        -: 1122:
  3847403: 1123:  return success();
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        -: 1124:}
        -: 1125:
function _ZN4mlir7OpTrait28hasElementwiseMappableTraitsEPNS_9OperationE called 4049978 returned 100% blocks executed 90%
  4049978: 1126:bool OpTrait::hasElementwiseMappableTraits(Operation *op) {
  5002336: 1127:  return op->hasTrait<Elementwise>() && op->hasTrait<Scalarizable>() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  5954736: 1128:         op->hasTrait<Vectorizable>() && op->hasTrait<Tensorizable>();
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 1129:}
        -: 1130:
        -: 1131://===----------------------------------------------------------------------===//
        -: 1132:// CastOpInterface
        -: 1133://===----------------------------------------------------------------------===//
        -: 1134:
        -: 1135:/// Attempt to fold the given cast operation.
        -: 1136:LogicalResult
function _ZN4mlir4impl19foldCastInterfaceOpEPNS_9OperationEN4llvm8ArrayRefINS_9AttributeEEERNS3_15SmallVectorImplINS_12OpFoldResultEEE called 2146920 returned 100% blocks executed 92%
  2146920: 1137:impl::foldCastInterfaceOp(Operation *op, ArrayRef<Attribute> attrOperands,
        -: 1138:                          SmallVectorImpl<OpFoldResult> &foldResults) {
  2146920: 1139:  OperandRange operands = op->getOperands();
call    0 returned 100%
  2146920: 1140:  if (operands.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1141:    return failure();
  2146920: 1142:  ResultRange results = op->getResults();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1143:
        -: 1144:  // Check for the case where the input and output types match 1-1.
  2146920: 1145:  if (operands.getTypes() == results.getTypes()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
     8478: 1146:    foldResults.append(operands.begin(), operands.end());
call    0 returned 100%
     8478: 1147:    return success();
        -: 1148:  }
        -: 1149:
  2138442: 1150:  return failure();
        -: 1151:}
        -: 1152:
        -: 1153:/// Attempt to verify the given cast operation.
function _ZN4mlir4impl21verifyCastInterfaceOpEPNS_9OperationEN4llvm12function_refIFbNS_9TypeRangeES5_EEE called 299986702 returned 100% blocks executed 29%
299986702: 1154:LogicalResult impl::verifyCastInterfaceOp(
        -: 1155:    Operation *op, function_ref<bool(TypeRange, TypeRange)> areCastCompatible) {
299986702: 1156:  auto resultTypes = op->getResultTypes();
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
299986693*: 1157:  if (resultTypes.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
    #####: 1158:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1159:           << "expected at least one result for cast operation";
call    0 never executed
        -: 1160:
299986693: 1161:  auto operandTypes = op->getOperandTypes();
call    0 returned 100%
299986691: 1162:  if (!areCastCompatible(operandTypes, resultTypes)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1163:    InFlightDiagnostic diag = op->emitOpError("operand type");
call    0 never executed
call    1 never executed
    #####: 1164:    if (operandTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 1165:      diag << "s []";
call    0 never executed
    #####: 1166:    else if (llvm::size(operandTypes) == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1167:      diag << " " << *operandTypes.begin();
call    0 never executed
call    1 never executed
        -: 1168:    else
    #####: 1169:      diag << "s " << operandTypes;
call    0 never executed
call    1 never executed
    #####: 1170:    return diag << " and result type" << (resultTypes.size() == 1 ? " " : "s ")
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 1171:                << resultTypes << " are cast incompatible";
call    0 never executed
call    1 never executed
        -: 1172:  }
        -: 1173:
299986689: 1174:  return success();
        -: 1175:}
        -: 1176:
        -: 1177://===----------------------------------------------------------------------===//
        -: 1178:// Misc. utils
        -: 1179://===----------------------------------------------------------------------===//
        -: 1180:
        -: 1181:/// Insert an operation, generated by `buildTerminatorOp`, at the end of the
        -: 1182:/// region's only block if it does not have a terminator already. If the region
        -: 1183:/// is empty, insert a new block first. `buildTerminatorOp` should return the
        -: 1184:/// terminator operation to insert.
function _ZN4mlir4impl22ensureRegionTerminatorERNS_6RegionERNS_9OpBuilderENS_8LocationEN4llvm12function_refIFPNS_9OperationES4_S5_EEE called 4603142 returned 100% blocks executed 80%
  4603142: 1185:void impl::ensureRegionTerminator(
        -: 1186:    Region &region, OpBuilder &builder, Location loc,
        -: 1187:    function_ref<Operation *(OpBuilder &, Location)> buildTerminatorOp) {
  5913599: 1188:  OpBuilder::InsertionGuard guard(builder);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  4603142: 1189:  if (region.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1190:    builder.createBlock(&region);
call    0 never executed
call    1 never executed
        -: 1191:
  4603142: 1192:  Block &block = region.back();
call    0 returned 100%
  8932550: 1193:  if (!block.empty() && block.back().hasTrait<OpTrait::IsTerminator>())
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
call    2 returned 100%
branch  3 taken 76% (fallthrough)
branch  4 taken 24%
  6585370: 1194:    return;
branch  0 taken 0%
branch  1 taken 100%
        -: 1195:
  1310457: 1196:  builder.setInsertionPointToEnd(&block);
call    0 returned 100%
  1310457: 1197:  builder.insert(buildTerminatorOp(builder, loc));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1%
branch  3 taken 100%
        -: 1198:}
        -: 1199:
        -: 1200:/// Create a simple OpBuilder and forward to the OpBuilder version of this
        -: 1201:/// function.
function _ZN4mlir4impl22ensureRegionTerminatorERNS_6RegionERNS_7BuilderENS_8LocationEN4llvm12function_refIFPNS_9OperationERNS_9OpBuilderES5_EEE called 4598486 returned 100% blocks executed 100%
  4598486: 1202:void impl::ensureRegionTerminator(
        -: 1203:    Region &region, Builder &builder, Location loc,
        -: 1204:    function_ref<Operation *(OpBuilder &, Location)> buildTerminatorOp) {
  4598486: 1205:  OpBuilder opBuilder(builder.getContext());
call    0 returned 100%
  4598486: 1206:  ensureRegionTerminator(region, opBuilder, loc, buildTerminatorOp);
call    0 returned 100%
  4598486: 1207:}
