        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/llvm/include/llvm/MC/MCStreamer.h
        -:    0:Graph:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUTransforms.dir/Transforms/SerializeToHsaco.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUTransforms.dir/Transforms/SerializeToHsaco.cpp.gcda
        -:    0:Runs:116158
        -:    1://===- MCStreamer.h - High-level Streaming Machine Code Output --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file declares the MCStreamer class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_MC_MCSTREAMER_H
        -:   14:#define LLVM_MC_MCSTREAMER_H
        -:   15:
        -:   16:#include "llvm/ADT/ArrayRef.h"
        -:   17:#include "llvm/ADT/DenseMap.h"
        -:   18:#include "llvm/ADT/Optional.h"
        -:   19:#include "llvm/ADT/SmallVector.h"
        -:   20:#include "llvm/ADT/StringRef.h"
        -:   21:#include "llvm/MC/MCDirectives.h"
        -:   22:#include "llvm/MC/MCDwarf.h"
        -:   23:#include "llvm/MC/MCLinkerOptimizationHint.h"
        -:   24:#include "llvm/MC/MCPseudoProbe.h"
        -:   25:#include "llvm/MC/MCWinEH.h"
        -:   26:#include "llvm/Support/ARMTargetParser.h"
        -:   27:#include "llvm/Support/Error.h"
        -:   28:#include "llvm/Support/MD5.h"
        -:   29:#include "llvm/Support/SMLoc.h"
        -:   30:#include "llvm/Support/VersionTuple.h"
        -:   31:#include <cassert>
        -:   32:#include <cstdint>
        -:   33:#include <memory>
        -:   34:#include <string>
        -:   35:#include <utility>
        -:   36:#include <vector>
        -:   37:
        -:   38:namespace llvm {
        -:   39:
        -:   40:class APInt;
        -:   41:class AssemblerConstantPools;
        -:   42:class MCAsmBackend;
        -:   43:class MCAssembler;
        -:   44:class MCContext;
        -:   45:class MCExpr;
        -:   46:class MCFragment;
        -:   47:class MCInst;
        -:   48:class MCInstPrinter;
        -:   49:class MCRegister;
        -:   50:class MCSection;
        -:   51:class MCStreamer;
        -:   52:class MCSubtargetInfo;
        -:   53:class MCSymbol;
        -:   54:class MCSymbolRefExpr;
        -:   55:class Triple;
        -:   56:class Twine;
        -:   57:class raw_ostream;
        -:   58:
        -:   59:namespace codeview {
        -:   60:struct DefRangeRegisterRelHeader;
        -:   61:struct DefRangeSubfieldRegisterHeader;
        -:   62:struct DefRangeRegisterHeader;
        -:   63:struct DefRangeFramePointerRelHeader;
        -:   64:}
        -:   65:
        -:   66:using MCSectionSubPair = std::pair<MCSection *, const MCExpr *>;
        -:   67:
        -:   68:/// Target specific streamer interface. This is used so that targets can
        -:   69:/// implement support for target specific assembly directives.
        -:   70:///
        -:   71:/// If target foo wants to use this, it should implement 3 classes:
        -:   72:/// * FooTargetStreamer : public MCTargetStreamer
        -:   73:/// * FooTargetAsmStreamer : public FooTargetStreamer
        -:   74:/// * FooTargetELFStreamer : public FooTargetStreamer
        -:   75:///
        -:   76:/// FooTargetStreamer should have a pure virtual method for each directive. For
        -:   77:/// example, for a ".bar symbol_name" directive, it should have
        -:   78:/// virtual emitBar(const MCSymbol &Symbol) = 0;
        -:   79:///
        -:   80:/// The FooTargetAsmStreamer and FooTargetELFStreamer classes implement the
        -:   81:/// method. The assembly streamer just prints ".bar symbol_name". The object
        -:   82:/// streamer does whatever is needed to implement .bar in the object file.
        -:   83:///
        -:   84:/// In the assembly printer and parser the target streamer can be used by
        -:   85:/// calling getTargetStreamer and casting it to FooTargetStreamer:
        -:   86:///
        -:   87:/// MCTargetStreamer &TS = OutStreamer.getTargetStreamer();
        -:   88:/// FooTargetStreamer &ATS = static_cast<FooTargetStreamer &>(TS);
        -:   89:///
        -:   90:/// The base classes FooTargetAsmStreamer and FooTargetELFStreamer should
        -:   91:/// *never* be treated differently. Callers should always talk to a
        -:   92:/// FooTargetStreamer.
        -:   93:class MCTargetStreamer {
        -:   94:protected:
        -:   95:  MCStreamer &Streamer;
        -:   96:
        -:   97:public:
        -:   98:  MCTargetStreamer(MCStreamer &S);
        -:   99:  virtual ~MCTargetStreamer();
        -:  100:
        -:  101:  MCStreamer &getStreamer() { return Streamer; }
        -:  102:
        -:  103:  // Allow a target to add behavior to the EmitLabel of MCStreamer.
        -:  104:  virtual void emitLabel(MCSymbol *Symbol);
        -:  105:  // Allow a target to add behavior to the emitAssignment of MCStreamer.
        -:  106:  virtual void emitAssignment(MCSymbol *Symbol, const MCExpr *Value);
        -:  107:
        -:  108:  virtual void prettyPrintAsm(MCInstPrinter &InstPrinter, uint64_t Address,
        -:  109:                              const MCInst &Inst, const MCSubtargetInfo &STI,
        -:  110:                              raw_ostream &OS);
        -:  111:
        -:  112:  virtual void emitDwarfFileDirective(StringRef Directive);
        -:  113:
        -:  114:  /// Update streamer for a new active section.
        -:  115:  ///
        -:  116:  /// This is called by popSection and switchSection, if the current
        -:  117:  /// section changes.
        -:  118:  virtual void changeSection(const MCSection *CurSection, MCSection *Section,
        -:  119:                             const MCExpr *SubSection, raw_ostream &OS);
        -:  120:
        -:  121:  virtual void emitValue(const MCExpr *Value);
        -:  122:
        -:  123:  /// Emit the bytes in \p Data into the output.
        -:  124:  ///
        -:  125:  /// This is used to emit bytes in \p Data as sequence of .byte directives.
        -:  126:  virtual void emitRawBytes(StringRef Data);
        -:  127:
        -:  128:  virtual void emitConstantPools();
        -:  129:
        -:  130:  virtual void finish();
        -:  131:};
        -:  132:
        -:  133:// FIXME: declared here because it is used from
        -:  134:// lib/CodeGen/AsmPrinter/ARMException.cpp.
        -:  135:class ARMTargetStreamer : public MCTargetStreamer {
        -:  136:public:
        -:  137:  ARMTargetStreamer(MCStreamer &S);
        -:  138:  ~ARMTargetStreamer() override;
        -:  139:
        -:  140:  virtual void emitFnStart();
        -:  141:  virtual void emitFnEnd();
        -:  142:  virtual void emitCantUnwind();
        -:  143:  virtual void emitPersonality(const MCSymbol *Personality);
        -:  144:  virtual void emitPersonalityIndex(unsigned Index);
        -:  145:  virtual void emitHandlerData();
        -:  146:  virtual void emitSetFP(unsigned FpReg, unsigned SpReg,
        -:  147:                         int64_t Offset = 0);
        -:  148:  virtual void emitMovSP(unsigned Reg, int64_t Offset = 0);
        -:  149:  virtual void emitPad(int64_t Offset);
        -:  150:  virtual void emitRegSave(const SmallVectorImpl<unsigned> &RegList,
        -:  151:                           bool isVector);
        -:  152:  virtual void emitUnwindRaw(int64_t StackOffset,
        -:  153:                             const SmallVectorImpl<uint8_t> &Opcodes);
        -:  154:
        -:  155:  virtual void switchVendor(StringRef Vendor);
        -:  156:  virtual void emitAttribute(unsigned Attribute, unsigned Value);
        -:  157:  virtual void emitTextAttribute(unsigned Attribute, StringRef String);
        -:  158:  virtual void emitIntTextAttribute(unsigned Attribute, unsigned IntValue,
        -:  159:                                    StringRef StringValue = "");
        -:  160:  virtual void emitFPU(unsigned FPU);
        -:  161:  virtual void emitArch(ARM::ArchKind Arch);
        -:  162:  virtual void emitArchExtension(uint64_t ArchExt);
        -:  163:  virtual void emitObjectArch(ARM::ArchKind Arch);
        -:  164:  void emitTargetAttributes(const MCSubtargetInfo &STI);
        -:  165:  virtual void finishAttributeSection();
        -:  166:  virtual void emitInst(uint32_t Inst, char Suffix = '\0');
        -:  167:
        -:  168:  virtual void annotateTLSDescriptorSequence(const MCSymbolRefExpr *SRE);
        -:  169:
        -:  170:  virtual void emitThumbSet(MCSymbol *Symbol, const MCExpr *Value);
        -:  171:
        -:  172:  void emitConstantPools() override;
        -:  173:
        -:  174:  virtual void emitARMWinCFIAllocStack(unsigned Size, bool Wide);
        -:  175:  virtual void emitARMWinCFISaveRegMask(unsigned Mask, bool Wide);
        -:  176:  virtual void emitARMWinCFISaveSP(unsigned Reg);
        -:  177:  virtual void emitARMWinCFISaveFRegs(unsigned First, unsigned Last);
        -:  178:  virtual void emitARMWinCFISaveLR(unsigned Offset);
        -:  179:  virtual void emitARMWinCFIPrologEnd(bool Fragment);
        -:  180:  virtual void emitARMWinCFINop(bool Wide);
        -:  181:  virtual void emitARMWinCFIEpilogStart(unsigned Condition);
        -:  182:  virtual void emitARMWinCFIEpilogEnd();
        -:  183:  virtual void emitARMWinCFICustom(unsigned Opcode);
        -:  184:
        -:  185:  /// Reset any state between object emissions, i.e. the equivalent of
        -:  186:  /// MCStreamer's reset method.
        -:  187:  virtual void reset();
        -:  188:
        -:  189:  /// Callback used to implement the ldr= pseudo.
        -:  190:  /// Add a new entry to the constant pool for the current section and return an
        -:  191:  /// MCExpr that can be used to refer to the constant pool location.
        -:  192:  const MCExpr *addConstantPoolEntry(const MCExpr *, SMLoc Loc);
        -:  193:
        -:  194:  /// Callback used to implement the .ltorg directive.
        -:  195:  /// Emit contents of constant pool for the current section.
        -:  196:  void emitCurrentConstantPool();
        -:  197:
        -:  198:private:
        -:  199:  std::unique_ptr<AssemblerConstantPools> ConstantPools;
        -:  200:};
        -:  201:
        -:  202:/// Streaming machine code generation interface.
        -:  203:///
        -:  204:/// This interface is intended to provide a programmatic interface that is very
        -:  205:/// similar to the level that an assembler .s file provides.  It has callbacks
        -:  206:/// to emit bytes, handle directives, etc.  The implementation of this interface
        -:  207:/// retains state to know what the current section is etc.
        -:  208:///
        -:  209:/// There are multiple implementations of this interface: one for writing out
        -:  210:/// a .s file, and implementations that write out .o files of various formats.
        -:  211:///
        -:  212:class MCStreamer {
        -:  213:  MCContext &Context;
        -:  214:  std::unique_ptr<MCTargetStreamer> TargetStreamer;
        -:  215:
        -:  216:  std::vector<MCDwarfFrameInfo> DwarfFrameInfos;
        -:  217:  MCDwarfFrameInfo *getCurrentDwarfFrameInfo();
        -:  218:
        -:  219:  /// Similar to DwarfFrameInfos, but for SEH unwind info. Chained frames may
        -:  220:  /// refer to each other, so use std::unique_ptr to provide pointer stability.
        -:  221:  std::vector<std::unique_ptr<WinEH::FrameInfo>> WinFrameInfos;
        -:  222:
        -:  223:  WinEH::FrameInfo *CurrentWinFrameInfo;
        -:  224:  size_t CurrentProcWinFrameInfoStartIndex;
        -:  225:
        -:  226:  /// Tracks an index to represent the order a symbol was emitted in.
        -:  227:  /// Zero means we did not emit that symbol.
        -:  228:  DenseMap<const MCSymbol *, unsigned> SymbolOrdering;
        -:  229:
        -:  230:  /// This is stack of current and previous section values saved by
        -:  231:  /// pushSection.
        -:  232:  SmallVector<std::pair<MCSectionSubPair, MCSectionSubPair>, 4> SectionStack;
        -:  233:
        -:  234:  /// Pointer to the parser's SMLoc if available. This is used to provide
        -:  235:  /// locations for diagnostics.
        -:  236:  const SMLoc *StartTokLocPtr = nullptr;
        -:  237:
        -:  238:  /// The next unique ID to use when creating a WinCFI-related section (.pdata
        -:  239:  /// or .xdata). This ID ensures that we have a one-to-one mapping from
        -:  240:  /// code section to unwind info section, which MSVC's incremental linker
        -:  241:  /// requires.
        -:  242:  unsigned NextWinCFIID = 0;
        -:  243:
        -:  244:  bool UseAssemblerInfoForParsing;
        -:  245:
        -:  246:  /// Is the assembler allowed to insert padding automatically?  For
        -:  247:  /// correctness reasons, we sometimes need to ensure instructions aren't
        -:  248:  /// separated in unexpected ways.  At the moment, this feature is only
        -:  249:  /// useable from an integrated assembler, but assembly syntax is under
        -:  250:  /// discussion for future inclusion.
        -:  251:  bool AllowAutoPadding = false;
        -:  252:
        -:  253:protected:
        -:  254:  MCStreamer(MCContext &Ctx);
        -:  255:
        -:  256:  virtual void emitCFIStartProcImpl(MCDwarfFrameInfo &Frame);
        -:  257:  virtual void emitCFIEndProcImpl(MCDwarfFrameInfo &CurFrame);
        -:  258:
        -:  259:  WinEH::FrameInfo *getCurrentWinFrameInfo() {
        -:  260:    return CurrentWinFrameInfo;
        -:  261:  }
        -:  262:
        -:  263:  virtual void emitWindowsUnwindTables(WinEH::FrameInfo *Frame);
        -:  264:
        -:  265:  virtual void emitWindowsUnwindTables();
        -:  266:
        -:  267:  virtual void emitRawTextImpl(StringRef String);
        -:  268:
        -:  269:  /// Returns true if the the .cv_loc directive is in the right section.
        -:  270:  bool checkCVLocSection(unsigned FuncId, unsigned FileNo, SMLoc Loc);
        -:  271:
        -:  272:public:
        -:  273:  MCStreamer(const MCStreamer &) = delete;
        -:  274:  MCStreamer &operator=(const MCStreamer &) = delete;
        -:  275:  virtual ~MCStreamer();
        -:  276:
        -:  277:  void visitUsedExpr(const MCExpr &Expr);
        -:  278:  virtual void visitUsedSymbol(const MCSymbol &Sym);
        -:  279:
        -:  280:  void setTargetStreamer(MCTargetStreamer *TS) {
        -:  281:    TargetStreamer.reset(TS);
        -:  282:  }
        -:  283:
        -:  284:  void setStartTokLocPtr(const SMLoc *Loc) { StartTokLocPtr = Loc; }
        -:  285:  SMLoc getStartTokLoc() const {
        -:  286:    return StartTokLocPtr ? *StartTokLocPtr : SMLoc();
        -:  287:  }
        -:  288:
        -:  289:  /// State management
        -:  290:  ///
        -:  291:  virtual void reset();
        -:  292:
        -:  293:  MCContext &getContext() const { return Context; }
        -:  294:
        -:  295:  virtual MCAssembler *getAssemblerPtr() { return nullptr; }
        -:  296:
    #####:  297:  void setUseAssemblerInfoForParsing(bool v) { UseAssemblerInfoForParsing = v; }
call    0 never executed
        -:  298:  bool getUseAssemblerInfoForParsing() { return UseAssemblerInfoForParsing; }
        -:  299:
        -:  300:  MCTargetStreamer *getTargetStreamer() {
        -:  301:    return TargetStreamer.get();
        -:  302:  }
        -:  303:
        -:  304:  void setAllowAutoPadding(bool v) { AllowAutoPadding = v; }
        -:  305:  bool getAllowAutoPadding() const { return AllowAutoPadding; }
        -:  306:
        -:  307:  /// When emitting an object file, create and emit a real label. When emitting
        -:  308:  /// textual assembly, this should do nothing to avoid polluting our output.
        -:  309:  virtual MCSymbol *emitCFILabel();
        -:  310:
        -:  311:  /// Retrieve the current frame info if one is available and it is not yet
        -:  312:  /// closed. Otherwise, issue an error and return null.
        -:  313:  WinEH::FrameInfo *EnsureValidWinFrameInfo(SMLoc Loc);
        -:  314:
        -:  315:  unsigned getNumFrameInfos();
        -:  316:  ArrayRef<MCDwarfFrameInfo> getDwarfFrameInfos() const;
        -:  317:
        -:  318:  bool hasUnfinishedDwarfFrameInfo();
        -:  319:
        -:  320:  unsigned getNumWinFrameInfos() { return WinFrameInfos.size(); }
        -:  321:  ArrayRef<std::unique_ptr<WinEH::FrameInfo>> getWinFrameInfos() const {
        -:  322:    return WinFrameInfos;
        -:  323:  }
        -:  324:
        -:  325:  void generateCompactUnwindEncodings(MCAsmBackend *MAB);
        -:  326:
        -:  327:  /// \name Assembly File Formatting.
        -:  328:  /// @{
        -:  329:
        -:  330:  /// Return true if this streamer supports verbose assembly and if it is
        -:  331:  /// enabled.
        -:  332:  virtual bool isVerboseAsm() const { return false; }
        -:  333:
        -:  334:  /// Return true if this asm streamer supports emitting unformatted text
        -:  335:  /// to the .s file with EmitRawText.
        -:  336:  virtual bool hasRawTextSupport() const { return false; }
        -:  337:
        -:  338:  /// Is the integrated assembler required for this streamer to function
        -:  339:  /// correctly?
        -:  340:  virtual bool isIntegratedAssemblerRequired() const { return false; }
        -:  341:
        -:  342:  /// Add a textual comment.
        -:  343:  ///
        -:  344:  /// Typically for comments that can be emitted to the generated .s
        -:  345:  /// file if applicable as a QoI issue to make the output of the compiler
        -:  346:  /// more readable.  This only affects the MCAsmStreamer, and only when
        -:  347:  /// verbose assembly output is enabled.
        -:  348:  ///
        -:  349:  /// If the comment includes embedded \n's, they will each get the comment
        -:  350:  /// prefix as appropriate.  The added comment should not end with a \n.
        -:  351:  /// By default, each comment is terminated with an end of line, i.e. the
        -:  352:  /// EOL param is set to true by default. If one prefers not to end the
        -:  353:  /// comment with a new line then the EOL param should be passed
        -:  354:  /// with a false value.
        -:  355:  virtual void AddComment(const Twine &T, bool EOL = true) {}
        -:  356:
        -:  357:  /// Return a raw_ostream that comments can be written to. Unlike
        -:  358:  /// AddComment, you are required to terminate comments with \n if you use this
        -:  359:  /// method.
        -:  360:  virtual raw_ostream &getCommentOS();
        -:  361:
        -:  362:  /// Print T and prefix it with the comment string (normally #) and
        -:  363:  /// optionally a tab. This prints the comment immediately, not at the end of
        -:  364:  /// the current line. It is basically a safe version of EmitRawText: since it
        -:  365:  /// only prints comments, the object streamer ignores it instead of asserting.
        -:  366:  virtual void emitRawComment(const Twine &T, bool TabPrefix = true);
        -:  367:
        -:  368:  /// Add explicit comment T. T is required to be a valid
        -:  369:  /// comment in the output and does not need to be escaped.
        -:  370:  virtual void addExplicitComment(const Twine &T);
        -:  371:
        -:  372:  /// Emit added explicit comments.
        -:  373:  virtual void emitExplicitComments();
        -:  374:
        -:  375:  /// Emit a blank line to a .s file to pretty it up.
        -:  376:  virtual void addBlankLine() {}
        -:  377:
        -:  378:  /// @}
        -:  379:
        -:  380:  /// \name Symbol & Section Management
        -:  381:  /// @{
        -:  382:
        -:  383:  /// Return the current section that the streamer is emitting code to.
        -:  384:  MCSectionSubPair getCurrentSection() const {
        -:  385:    if (!SectionStack.empty())
        -:  386:      return SectionStack.back().first;
        -:  387:    return MCSectionSubPair();
        -:  388:  }
        -:  389:  MCSection *getCurrentSectionOnly() const { return getCurrentSection().first; }
        -:  390:
        -:  391:  /// Return the previous section that the streamer is emitting code to.
        -:  392:  MCSectionSubPair getPreviousSection() const {
        -:  393:    if (!SectionStack.empty())
        -:  394:      return SectionStack.back().second;
        -:  395:    return MCSectionSubPair();
        -:  396:  }
        -:  397:
        -:  398:  /// Returns an index to represent the order a symbol was emitted in.
        -:  399:  /// (zero if we did not emit that symbol)
        -:  400:  unsigned getSymbolOrder(const MCSymbol *Sym) const {
        -:  401:    return SymbolOrdering.lookup(Sym);
        -:  402:  }
        -:  403:
        -:  404:  /// Update streamer for a new active section.
        -:  405:  ///
        -:  406:  /// This is called by popSection and switchSection, if the current
        -:  407:  /// section changes.
        -:  408:  virtual void changeSection(MCSection *, const MCExpr *);
        -:  409:
        -:  410:  /// Save the current and previous section on the section stack.
        -:  411:  void pushSection() {
        -:  412:    SectionStack.push_back(
        -:  413:        std::make_pair(getCurrentSection(), getPreviousSection()));
        -:  414:  }
        -:  415:
        -:  416:  /// Restore the current and previous section from the section stack.
        -:  417:  /// Calls changeSection as needed.
        -:  418:  ///
        -:  419:  /// Returns false if the stack was empty.
        -:  420:  bool popSection() {
        -:  421:    if (SectionStack.size() <= 1)
        -:  422:      return false;
        -:  423:    auto I = SectionStack.end();
        -:  424:    --I;
        -:  425:    MCSectionSubPair OldSection = I->first;
        -:  426:    --I;
        -:  427:    MCSectionSubPair NewSection = I->first;
        -:  428:
        -:  429:    if (NewSection.first && OldSection != NewSection)
        -:  430:      changeSection(NewSection.first, NewSection.second);
        -:  431:    SectionStack.pop_back();
        -:  432:    return true;
        -:  433:  }
        -:  434:
        -:  435:  bool subSection(const MCExpr *Subsection) {
        -:  436:    if (SectionStack.empty())
        -:  437:      return false;
        -:  438:
        -:  439:    switchSection(SectionStack.back().first.first, Subsection);
        -:  440:    return true;
        -:  441:  }
        -:  442:
        -:  443:  /// Set the current section where code is being emitted to \p Section.  This
        -:  444:  /// is required to update CurSection.
        -:  445:  ///
        -:  446:  /// This corresponds to assembler directives like .section, .text, etc.
        -:  447:  virtual void switchSection(MCSection *Section,
        -:  448:                             const MCExpr *Subsection = nullptr);
        -:  449:
        -:  450:  /// Set the current section where code is being emitted to \p Section.
        -:  451:  /// This is required to update CurSection. This version does not call
        -:  452:  /// changeSection.
        -:  453:  void switchSectionNoChange(MCSection *Section,
        -:  454:                             const MCExpr *Subsection = nullptr) {
        -:  455:    assert(Section && "Cannot switch to a null section!");
        -:  456:    MCSectionSubPair curSection = SectionStack.back().first;
        -:  457:    SectionStack.back().second = curSection;
        -:  458:    if (MCSectionSubPair(Section, Subsection) != curSection)
        -:  459:      SectionStack.back().first = MCSectionSubPair(Section, Subsection);
        -:  460:  }
        -:  461:
        -:  462:  /// Create the default sections and set the initial one.
        -:  463:  virtual void initSections(bool NoExecStack, const MCSubtargetInfo &STI);
        -:  464:
        -:  465:  MCSymbol *endSection(MCSection *Section);
        -:  466:
        -:  467:  /// Sets the symbol's section.
        -:  468:  ///
        -:  469:  /// Each emitted symbol will be tracked in the ordering table,
        -:  470:  /// so we can sort on them later.
        -:  471:  void assignFragment(MCSymbol *Symbol, MCFragment *Fragment);
        -:  472:
        -:  473:  /// Returns the mnemonic for \p MI, if the streamer has access to a
        -:  474:  /// instruction printer and returns an empty string otherwise.
        -:  475:  virtual StringRef getMnemonic(MCInst &MI) { return ""; }
        -:  476:
        -:  477:  /// Emit a label for \p Symbol into the current section.
        -:  478:  ///
        -:  479:  /// This corresponds to an assembler statement such as:
        -:  480:  ///   foo:
        -:  481:  ///
        -:  482:  /// \param Symbol - The symbol to emit. A given symbol should only be
        -:  483:  /// emitted as a label once, and symbols emitted as a label should never be
        -:  484:  /// used in an assignment.
        -:  485:  // FIXME: These emission are non-const because we mutate the symbol to
        -:  486:  // add the section we're emitting it to later.
        -:  487:  virtual void emitLabel(MCSymbol *Symbol, SMLoc Loc = SMLoc());
        -:  488:
        -:  489:  virtual void emitEHSymAttributes(const MCSymbol *Symbol, MCSymbol *EHSymbol);
        -:  490:
        -:  491:  /// Note in the output the specified \p Flag.
        -:  492:  virtual void emitAssemblerFlag(MCAssemblerFlag Flag);
        -:  493:
        -:  494:  /// Emit the given list \p Options of strings as linker
        -:  495:  /// options into the output.
        -:  496:  virtual void emitLinkerOptions(ArrayRef<std::string> Kind) {}
        -:  497:
        -:  498:  /// Note in the output the specified region \p Kind.
        -:  499:  virtual void emitDataRegion(MCDataRegionType Kind) {}
        -:  500:
        -:  501:  /// Specify the Mach-O minimum deployment target version.
        -:  502:  virtual void emitVersionMin(MCVersionMinType Type, unsigned Major,
        -:  503:                              unsigned Minor, unsigned Update,
        -:  504:                              VersionTuple SDKVersion) {}
        -:  505:
        -:  506:  /// Emit/Specify Mach-O build version command.
        -:  507:  /// \p Platform should be one of MachO::PlatformType.
        -:  508:  virtual void emitBuildVersion(unsigned Platform, unsigned Major,
        -:  509:                                unsigned Minor, unsigned Update,
        -:  510:                                VersionTuple SDKVersion) {}
        -:  511:
        -:  512:  virtual void emitDarwinTargetVariantBuildVersion(unsigned Platform,
        -:  513:                                                   unsigned Major,
        -:  514:                                                   unsigned Minor,
        -:  515:                                                   unsigned Update,
        -:  516:                                                   VersionTuple SDKVersion) {}
        -:  517:
        -:  518:  void emitVersionForTarget(const Triple &Target,
        -:  519:                            const VersionTuple &SDKVersion,
        -:  520:                            const Triple *DarwinTargetVariantTriple,
        -:  521:                            const VersionTuple &DarwinTargetVariantSDKVersion);
        -:  522:
        -:  523:  /// Note in the output that the specified \p Func is a Thumb mode
        -:  524:  /// function (ARM target only).
        -:  525:  virtual void emitThumbFunc(MCSymbol *Func);
        -:  526:
        -:  527:  /// Emit an assignment of \p Value to \p Symbol.
        -:  528:  ///
        -:  529:  /// This corresponds to an assembler statement such as:
        -:  530:  ///  symbol = value
        -:  531:  ///
        -:  532:  /// The assignment generates no code, but has the side effect of binding the
        -:  533:  /// value in the current context. For the assembly streamer, this prints the
        -:  534:  /// binding into the .s file.
        -:  535:  ///
        -:  536:  /// \param Symbol - The symbol being assigned to.
        -:  537:  /// \param Value - The value for the symbol.
        -:  538:  virtual void emitAssignment(MCSymbol *Symbol, const MCExpr *Value);
        -:  539:
        -:  540:  /// Emit an assignment of \p Value to \p Symbol, but only if \p Value is also
        -:  541:  /// emitted.
        -:  542:  virtual void emitConditionalAssignment(MCSymbol *Symbol, const MCExpr *Value);
        -:  543:
        -:  544:  /// Emit an weak reference from \p Alias to \p Symbol.
        -:  545:  ///
        -:  546:  /// This corresponds to an assembler statement such as:
        -:  547:  ///  .weakref alias, symbol
        -:  548:  ///
        -:  549:  /// \param Alias - The alias that is being created.
        -:  550:  /// \param Symbol - The symbol being aliased.
        -:  551:  virtual void emitWeakReference(MCSymbol *Alias, const MCSymbol *Symbol);
        -:  552:
        -:  553:  /// Add the given \p Attribute to \p Symbol.
        -:  554:  virtual bool emitSymbolAttribute(MCSymbol *Symbol,
        -:  555:                                   MCSymbolAttr Attribute) = 0;
        -:  556:
        -:  557:  /// Set the \p DescValue for the \p Symbol.
        -:  558:  ///
        -:  559:  /// \param Symbol - The symbol to have its n_desc field set.
        -:  560:  /// \param DescValue - The value to set into the n_desc field.
        -:  561:  virtual void emitSymbolDesc(MCSymbol *Symbol, unsigned DescValue);
        -:  562:
        -:  563:  /// Start emitting COFF symbol definition
        -:  564:  ///
        -:  565:  /// \param Symbol - The symbol to have its External & Type fields set.
        -:  566:  virtual void beginCOFFSymbolDef(const MCSymbol *Symbol);
        -:  567:
        -:  568:  /// Emit the storage class of the symbol.
        -:  569:  ///
        -:  570:  /// \param StorageClass - The storage class the symbol should have.
        -:  571:  virtual void emitCOFFSymbolStorageClass(int StorageClass);
        -:  572:
        -:  573:  /// Emit the type of the symbol.
        -:  574:  ///
        -:  575:  /// \param Type - A COFF type identifier (see COFF::SymbolType in X86COFF.h)
        -:  576:  virtual void emitCOFFSymbolType(int Type);
        -:  577:
        -:  578:  /// Marks the end of the symbol definition.
        -:  579:  virtual void endCOFFSymbolDef();
        -:  580:
        -:  581:  virtual void emitCOFFSafeSEH(MCSymbol const *Symbol);
        -:  582:
        -:  583:  /// Emits the symbol table index of a Symbol into the current section.
        -:  584:  virtual void emitCOFFSymbolIndex(MCSymbol const *Symbol);
        -:  585:
        -:  586:  /// Emits a COFF section index.
        -:  587:  ///
        -:  588:  /// \param Symbol - Symbol the section number relocation should point to.
        -:  589:  virtual void emitCOFFSectionIndex(MCSymbol const *Symbol);
        -:  590:
        -:  591:  /// Emits a COFF section relative relocation.
        -:  592:  ///
        -:  593:  /// \param Symbol - Symbol the section relative relocation should point to.
        -:  594:  virtual void emitCOFFSecRel32(MCSymbol const *Symbol, uint64_t Offset);
        -:  595:
        -:  596:  /// Emits a COFF image relative relocation.
        -:  597:  ///
        -:  598:  /// \param Symbol - Symbol the image relative relocation should point to.
        -:  599:  virtual void emitCOFFImgRel32(MCSymbol const *Symbol, int64_t Offset);
        -:  600:
        -:  601:  /// Emits an lcomm directive with XCOFF csect information.
        -:  602:  ///
        -:  603:  /// \param LabelSym - Label on the block of storage.
        -:  604:  /// \param Size - The size of the block of storage.
        -:  605:  /// \param CsectSym - Csect name for the block of storage.
        -:  606:  /// \param ByteAlignment - The alignment of the symbol in bytes. Must be a
        -:  607:  /// power of 2.
        -:  608:  virtual void emitXCOFFLocalCommonSymbol(MCSymbol *LabelSym, uint64_t Size,
        -:  609:                                          MCSymbol *CsectSym,
        -:  610:                                          unsigned ByteAlignment);
        -:  611:
        -:  612:  /// Emit a symbol's linkage and visibility with a linkage directive for XCOFF.
        -:  613:  ///
        -:  614:  /// \param Symbol - The symbol to emit.
        -:  615:  /// \param Linkage - The linkage of the symbol to emit.
        -:  616:  /// \param Visibility - The visibility of the symbol to emit or MCSA_Invalid
        -:  617:  /// if the symbol does not have an explicit visibility.
        -:  618:  virtual void emitXCOFFSymbolLinkageWithVisibility(MCSymbol *Symbol,
        -:  619:                                                    MCSymbolAttr Linkage,
        -:  620:                                                    MCSymbolAttr Visibility);
        -:  621:
        -:  622:  /// Emit a XCOFF .rename directive which creates a synonym for an illegal or
        -:  623:  /// undesirable name.
        -:  624:  ///
        -:  625:  /// \param Name - The name used internally in the assembly for references to
        -:  626:  /// the symbol.
        -:  627:  /// \param Rename - The value to which the Name parameter is
        -:  628:  /// changed at the end of assembly.
        -:  629:  virtual void emitXCOFFRenameDirective(const MCSymbol *Name, StringRef Rename);
        -:  630:
        -:  631:  /// Emit an XCOFF .except directive which adds information about
        -:  632:  /// a trap instruction to the object file exception section
        -:  633:  ///
        -:  634:  /// \param Symbol - The function containing the trap.
        -:  635:  /// \param Lang - The language code for the exception entry.
        -:  636:  /// \param Reason - The reason code for the exception entry.
        -:  637:  virtual void emitXCOFFExceptDirective(const MCSymbol *Symbol, MCSymbol *Trap,
        -:  638:                                        unsigned Lang, unsigned Reason,
        -:  639:                                        unsigned FunctionSize, bool hasDebug);
        -:  640:
        -:  641:  /// Emit a XCOFF .ref directive which creates R_REF type entry in the
        -:  642:  /// relocation table for one or more symbols.
        -:  643:  ///
        -:  644:  /// \param Sym - The symbol on the .ref directive.
        -:  645:  virtual void emitXCOFFRefDirective(StringRef Sym);
        -:  646:
        -:  647:  /// Emit an ELF .size directive.
        -:  648:  ///
        -:  649:  /// This corresponds to an assembler statement such as:
        -:  650:  ///  .size symbol, expression
        -:  651:  virtual void emitELFSize(MCSymbol *Symbol, const MCExpr *Value);
        -:  652:
        -:  653:  /// Emit an ELF .symver directive.
        -:  654:  ///
        -:  655:  /// This corresponds to an assembler statement such as:
        -:  656:  ///  .symver _start, foo@@SOME_VERSION
        -:  657:  virtual void emitELFSymverDirective(const MCSymbol *OriginalSym,
        -:  658:                                      StringRef Name, bool KeepOriginalSym);
        -:  659:
        -:  660:  /// Emit a Linker Optimization Hint (LOH) directive.
        -:  661:  /// \param Args - Arguments of the LOH.
        -:  662:  virtual void emitLOHDirective(MCLOHType Kind, const MCLOHArgs &Args) {}
        -:  663:
        -:  664:  /// Emit a .gnu_attribute directive.
        -:  665:  virtual void emitGNUAttribute(unsigned Tag, unsigned Value) {}
        -:  666:
        -:  667:  /// Emit a common symbol.
        -:  668:  ///
        -:  669:  /// \param Symbol - The common symbol to emit.
        -:  670:  /// \param Size - The size of the common symbol.
        -:  671:  /// \param ByteAlignment - The alignment of the symbol if
        -:  672:  /// non-zero. This must be a power of 2.
        -:  673:  virtual void emitCommonSymbol(MCSymbol *Symbol, uint64_t Size,
        -:  674:                                unsigned ByteAlignment) = 0;
        -:  675:
        -:  676:  /// Emit a local common (.lcomm) symbol.
        -:  677:  ///
        -:  678:  /// \param Symbol - The common symbol to emit.
        -:  679:  /// \param Size - The size of the common symbol.
        -:  680:  /// \param ByteAlignment - The alignment of the common symbol in bytes.
        -:  681:  virtual void emitLocalCommonSymbol(MCSymbol *Symbol, uint64_t Size,
        -:  682:                                     unsigned ByteAlignment);
        -:  683:
        -:  684:  /// Emit the zerofill section and an optional symbol.
        -:  685:  ///
        -:  686:  /// \param Section - The zerofill section to create and or to put the symbol
        -:  687:  /// \param Symbol - The zerofill symbol to emit, if non-NULL.
        -:  688:  /// \param Size - The size of the zerofill symbol.
        -:  689:  /// \param ByteAlignment - The alignment of the zerofill symbol if
        -:  690:  /// non-zero. This must be a power of 2 on some targets.
        -:  691:  virtual void emitZerofill(MCSection *Section, MCSymbol *Symbol = nullptr,
        -:  692:                            uint64_t Size = 0, unsigned ByteAlignment = 0,
        -:  693:                            SMLoc Loc = SMLoc()) = 0;
        -:  694:
        -:  695:  /// Emit a thread local bss (.tbss) symbol.
        -:  696:  ///
        -:  697:  /// \param Section - The thread local common section.
        -:  698:  /// \param Symbol - The thread local common symbol to emit.
        -:  699:  /// \param Size - The size of the symbol.
        -:  700:  /// \param ByteAlignment - The alignment of the thread local common symbol
        -:  701:  /// if non-zero.  This must be a power of 2 on some targets.
        -:  702:  virtual void emitTBSSSymbol(MCSection *Section, MCSymbol *Symbol,
        -:  703:                              uint64_t Size, unsigned ByteAlignment = 0);
        -:  704:
        -:  705:  /// @}
        -:  706:  /// \name Generating Data
        -:  707:  /// @{
        -:  708:
        -:  709:  /// Emit the bytes in \p Data into the output.
        -:  710:  ///
        -:  711:  /// This is used to implement assembler directives such as .byte, .ascii,
        -:  712:  /// etc.
        -:  713:  virtual void emitBytes(StringRef Data);
        -:  714:
        -:  715:  /// Functionally identical to EmitBytes. When emitting textual assembly, this
        -:  716:  /// method uses .byte directives instead of .ascii or .asciz for readability.
        -:  717:  virtual void emitBinaryData(StringRef Data);
        -:  718:
        -:  719:  /// Emit the expression \p Value into the output as a native
        -:  720:  /// integer of the given \p Size bytes.
        -:  721:  ///
        -:  722:  /// This is used to implement assembler directives such as .word, .quad,
        -:  723:  /// etc.
        -:  724:  ///
        -:  725:  /// \param Value - The value to emit.
        -:  726:  /// \param Size - The size of the integer (in bytes) to emit. This must
        -:  727:  /// match a native machine width.
        -:  728:  /// \param Loc - The location of the expression for error reporting.
        -:  729:  virtual void emitValueImpl(const MCExpr *Value, unsigned Size,
        -:  730:                             SMLoc Loc = SMLoc());
        -:  731:
        -:  732:  void emitValue(const MCExpr *Value, unsigned Size, SMLoc Loc = SMLoc());
        -:  733:
        -:  734:  /// Special case of EmitValue that avoids the client having
        -:  735:  /// to pass in a MCExpr for constant integers.
        -:  736:  virtual void emitIntValue(uint64_t Value, unsigned Size);
        -:  737:  virtual void emitIntValue(APInt Value);
        -:  738:
        -:  739:  /// Special case of EmitValue that avoids the client having to pass
        -:  740:  /// in a MCExpr for constant integers & prints in Hex format for certain
        -:  741:  /// modes.
        -:  742:  virtual void emitIntValueInHex(uint64_t Value, unsigned Size) {
        -:  743:    emitIntValue(Value, Size);
        -:  744:  }
        -:  745:
        -:  746:  void emitInt8(uint64_t Value) { emitIntValue(Value, 1); }
        -:  747:  void emitInt16(uint64_t Value) { emitIntValue(Value, 2); }
        -:  748:  void emitInt32(uint64_t Value) { emitIntValue(Value, 4); }
        -:  749:  void emitInt64(uint64_t Value) { emitIntValue(Value, 8); }
        -:  750:
        -:  751:  /// Special case of EmitValue that avoids the client having to pass
        -:  752:  /// in a MCExpr for constant integers & prints in Hex format for certain
        -:  753:  /// modes, pads the field with leading zeros to Size width
        -:  754:  virtual void emitIntValueInHexWithPadding(uint64_t Value, unsigned Size) {
        -:  755:    emitIntValue(Value, Size);
        -:  756:  }
        -:  757:
        -:  758:  virtual void emitULEB128Value(const MCExpr *Value);
        -:  759:
        -:  760:  virtual void emitSLEB128Value(const MCExpr *Value);
        -:  761:
        -:  762:  /// Special case of EmitULEB128Value that avoids the client having to
        -:  763:  /// pass in a MCExpr for constant integers.
        -:  764:  void emitULEB128IntValue(uint64_t Value, unsigned PadTo = 0);
        -:  765:
        -:  766:  /// Special case of EmitSLEB128Value that avoids the client having to
        -:  767:  /// pass in a MCExpr for constant integers.
        -:  768:  void emitSLEB128IntValue(int64_t Value);
        -:  769:
        -:  770:  /// Special case of EmitValue that avoids the client having to pass in
        -:  771:  /// a MCExpr for MCSymbols.
        -:  772:  void emitSymbolValue(const MCSymbol *Sym, unsigned Size,
        -:  773:                       bool IsSectionRelative = false);
        -:  774:
        -:  775:  /// Emit the expression \p Value into the output as a dtprel
        -:  776:  /// (64-bit DTP relative) value.
        -:  777:  ///
        -:  778:  /// This is used to implement assembler directives such as .dtpreldword on
        -:  779:  /// targets that support them.
        -:  780:  virtual void emitDTPRel64Value(const MCExpr *Value);
        -:  781:
        -:  782:  /// Emit the expression \p Value into the output as a dtprel
        -:  783:  /// (32-bit DTP relative) value.
        -:  784:  ///
        -:  785:  /// This is used to implement assembler directives such as .dtprelword on
        -:  786:  /// targets that support them.
        -:  787:  virtual void emitDTPRel32Value(const MCExpr *Value);
        -:  788:
        -:  789:  /// Emit the expression \p Value into the output as a tprel
        -:  790:  /// (64-bit TP relative) value.
        -:  791:  ///
        -:  792:  /// This is used to implement assembler directives such as .tpreldword on
        -:  793:  /// targets that support them.
        -:  794:  virtual void emitTPRel64Value(const MCExpr *Value);
        -:  795:
        -:  796:  /// Emit the expression \p Value into the output as a tprel
        -:  797:  /// (32-bit TP relative) value.
        -:  798:  ///
        -:  799:  /// This is used to implement assembler directives such as .tprelword on
        -:  800:  /// targets that support them.
        -:  801:  virtual void emitTPRel32Value(const MCExpr *Value);
        -:  802:
        -:  803:  /// Emit the expression \p Value into the output as a gprel64 (64-bit
        -:  804:  /// GP relative) value.
        -:  805:  ///
        -:  806:  /// This is used to implement assembler directives such as .gpdword on
        -:  807:  /// targets that support them.
        -:  808:  virtual void emitGPRel64Value(const MCExpr *Value);
        -:  809:
        -:  810:  /// Emit the expression \p Value into the output as a gprel32 (32-bit
        -:  811:  /// GP relative) value.
        -:  812:  ///
        -:  813:  /// This is used to implement assembler directives such as .gprel32 on
        -:  814:  /// targets that support them.
        -:  815:  virtual void emitGPRel32Value(const MCExpr *Value);
        -:  816:
        -:  817:  /// Emit NumBytes bytes worth of the value specified by FillValue.
        -:  818:  /// This implements directives such as '.space'.
        -:  819:  void emitFill(uint64_t NumBytes, uint8_t FillValue);
        -:  820:
        -:  821:  /// Emit \p Size bytes worth of the value specified by \p FillValue.
        -:  822:  ///
        -:  823:  /// This is used to implement assembler directives such as .space or .skip.
        -:  824:  ///
        -:  825:  /// \param NumBytes - The number of bytes to emit.
        -:  826:  /// \param FillValue - The value to use when filling bytes.
        -:  827:  /// \param Loc - The location of the expression for error reporting.
        -:  828:  virtual void emitFill(const MCExpr &NumBytes, uint64_t FillValue,
        -:  829:                        SMLoc Loc = SMLoc());
        -:  830:
        -:  831:  /// Emit \p NumValues copies of \p Size bytes. Each \p Size bytes is
        -:  832:  /// taken from the lowest order 4 bytes of \p Expr expression.
        -:  833:  ///
        -:  834:  /// This is used to implement assembler directives such as .fill.
        -:  835:  ///
        -:  836:  /// \param NumValues - The number of copies of \p Size bytes to emit.
        -:  837:  /// \param Size - The size (in bytes) of each repeated value.
        -:  838:  /// \param Expr - The expression from which \p Size bytes are used.
        -:  839:  virtual void emitFill(const MCExpr &NumValues, int64_t Size, int64_t Expr,
        -:  840:                        SMLoc Loc = SMLoc());
        -:  841:
        -:  842:  virtual void emitNops(int64_t NumBytes, int64_t ControlledNopLength,
        -:  843:                        SMLoc Loc, const MCSubtargetInfo& STI);
        -:  844:
        -:  845:  /// Emit NumBytes worth of zeros.
        -:  846:  /// This function properly handles data in virtual sections.
        -:  847:  void emitZeros(uint64_t NumBytes);
        -:  848:
        -:  849:  /// Emit some number of copies of \p Value until the byte alignment \p
        -:  850:  /// ByteAlignment is reached.
        -:  851:  ///
        -:  852:  /// If the number of bytes need to emit for the alignment is not a multiple
        -:  853:  /// of \p ValueSize, then the contents of the emitted fill bytes is
        -:  854:  /// undefined.
        -:  855:  ///
        -:  856:  /// This used to implement the .align assembler directive.
        -:  857:  ///
        -:  858:  /// \param ByteAlignment - The alignment to reach. This must be a power of
        -:  859:  /// two on some targets.
        -:  860:  /// \param Value - The value to use when filling bytes.
        -:  861:  /// \param ValueSize - The size of the integer (in bytes) to emit for
        -:  862:  /// \p Value. This must match a native machine width.
        -:  863:  /// \param MaxBytesToEmit - The maximum numbers of bytes to emit, or 0. If
        -:  864:  /// the alignment cannot be reached in this many bytes, no bytes are
        -:  865:  /// emitted.
        -:  866:  virtual void emitValueToAlignment(unsigned ByteAlignment, int64_t Value = 0,
        -:  867:                                    unsigned ValueSize = 1,
        -:  868:                                    unsigned MaxBytesToEmit = 0);
        -:  869:
        -:  870:  /// Emit nops until the byte alignment \p ByteAlignment is reached.
        -:  871:  ///
        -:  872:  /// This used to align code where the alignment bytes may be executed.  This
        -:  873:  /// can emit different bytes for different sizes to optimize execution.
        -:  874:  ///
        -:  875:  /// \param ByteAlignment - The alignment to reach. This must be a power of
        -:  876:  /// two on some targets.
        -:  877:  /// \param STI - The MCSubtargetInfo in operation when padding is emitted.
        -:  878:  /// \param MaxBytesToEmit - The maximum numbers of bytes to emit, or 0. If
        -:  879:  /// the alignment cannot be reached in this many bytes, no bytes are
        -:  880:  /// emitted.
        -:  881:  virtual void emitCodeAlignment(unsigned ByteAlignment,
        -:  882:                                 const MCSubtargetInfo *STI,
        -:  883:                                 unsigned MaxBytesToEmit = 0);
        -:  884:
        -:  885:  /// Emit some number of copies of \p Value until the byte offset \p
        -:  886:  /// Offset is reached.
        -:  887:  ///
        -:  888:  /// This is used to implement assembler directives such as .org.
        -:  889:  ///
        -:  890:  /// \param Offset - The offset to reach. This may be an expression, but the
        -:  891:  /// expression must be associated with the current section.
        -:  892:  /// \param Value - The value to use when filling bytes.
        -:  893:  virtual void emitValueToOffset(const MCExpr *Offset, unsigned char Value,
        -:  894:                                 SMLoc Loc);
        -:  895:
        -:  896:  /// @}
        -:  897:
        -:  898:  /// Switch to a new logical file.  This is used to implement the '.file
        -:  899:  /// "foo.c"' assembler directive.
        -:  900:  virtual void emitFileDirective(StringRef Filename);
        -:  901:
        -:  902:  /// Emit ".file assembler diretive with additioal info.
        -:  903:  virtual void emitFileDirective(StringRef Filename, StringRef CompilerVerion,
        -:  904:                                 StringRef TimeStamp, StringRef Description);
        -:  905:
        -:  906:  /// Emit the "identifiers" directive.  This implements the
        -:  907:  /// '.ident "version foo"' assembler directive.
        -:  908:  virtual void emitIdent(StringRef IdentString) {}
        -:  909:
        -:  910:  /// Associate a filename with a specified logical file number.  This
        -:  911:  /// implements the DWARF2 '.file 4 "foo.c"' assembler directive.
        -:  912:  unsigned emitDwarfFileDirective(unsigned FileNo, StringRef Directory,
        -:  913:                                  StringRef Filename,
        -:  914:                                  Optional<MD5::MD5Result> Checksum = None,
        -:  915:                                  Optional<StringRef> Source = None,
        -:  916:                                  unsigned CUID = 0) {
        -:  917:    return cantFail(
        -:  918:        tryEmitDwarfFileDirective(FileNo, Directory, Filename, Checksum,
        -:  919:                                  Source, CUID));
        -:  920:  }
        -:  921:
        -:  922:  /// Associate a filename with a specified logical file number.
        -:  923:  /// Also associate a directory, optional checksum, and optional source
        -:  924:  /// text with the logical file.  This implements the DWARF2
        -:  925:  /// '.file 4 "dir/foo.c"' assembler directive, and the DWARF5
        -:  926:  /// '.file 4 "dir/foo.c" md5 "..." source "..."' assembler directive.
        -:  927:  virtual Expected<unsigned> tryEmitDwarfFileDirective(
        -:  928:      unsigned FileNo, StringRef Directory, StringRef Filename,
        -:  929:      Optional<MD5::MD5Result> Checksum = None, Optional<StringRef> Source = None,
        -:  930:      unsigned CUID = 0);
        -:  931:
        -:  932:  /// Specify the "root" file of the compilation, using the ".file 0" extension.
        -:  933:  virtual void emitDwarfFile0Directive(StringRef Directory, StringRef Filename,
        -:  934:                                       Optional<MD5::MD5Result> Checksum,
        -:  935:                                       Optional<StringRef> Source,
        -:  936:                                       unsigned CUID = 0);
        -:  937:
        -:  938:  virtual void emitCFIBKeyFrame();
        -:  939:  virtual void emitCFIMTETaggedFrame();
        -:  940:
        -:  941:  /// This implements the DWARF2 '.loc fileno lineno ...' assembler
        -:  942:  /// directive.
        -:  943:  virtual void emitDwarfLocDirective(unsigned FileNo, unsigned Line,
        -:  944:                                     unsigned Column, unsigned Flags,
        -:  945:                                     unsigned Isa, unsigned Discriminator,
        -:  946:                                     StringRef FileName);
        -:  947:
        -:  948:  /// Associate a filename with a specified logical file number, and also
        -:  949:  /// specify that file's checksum information.  This implements the '.cv_file 4
        -:  950:  /// "foo.c"' assembler directive. Returns true on success.
        -:  951:  virtual bool emitCVFileDirective(unsigned FileNo, StringRef Filename,
        -:  952:                                   ArrayRef<uint8_t> Checksum,
        -:  953:                                   unsigned ChecksumKind);
        -:  954:
        -:  955:  /// Introduces a function id for use with .cv_loc.
        -:  956:  virtual bool emitCVFuncIdDirective(unsigned FunctionId);
        -:  957:
        -:  958:  /// Introduces an inline call site id for use with .cv_loc. Includes
        -:  959:  /// extra information for inline line table generation.
        -:  960:  virtual bool emitCVInlineSiteIdDirective(unsigned FunctionId, unsigned IAFunc,
        -:  961:                                           unsigned IAFile, unsigned IALine,
        -:  962:                                           unsigned IACol, SMLoc Loc);
        -:  963:
        -:  964:  /// This implements the CodeView '.cv_loc' assembler directive.
        -:  965:  virtual void emitCVLocDirective(unsigned FunctionId, unsigned FileNo,
        -:  966:                                  unsigned Line, unsigned Column,
        -:  967:                                  bool PrologueEnd, bool IsStmt,
        -:  968:                                  StringRef FileName, SMLoc Loc);
        -:  969:
        -:  970:  /// This implements the CodeView '.cv_linetable' assembler directive.
        -:  971:  virtual void emitCVLinetableDirective(unsigned FunctionId,
        -:  972:                                        const MCSymbol *FnStart,
        -:  973:                                        const MCSymbol *FnEnd);
        -:  974:
        -:  975:  /// This implements the CodeView '.cv_inline_linetable' assembler
        -:  976:  /// directive.
        -:  977:  virtual void emitCVInlineLinetableDirective(unsigned PrimaryFunctionId,
        -:  978:                                              unsigned SourceFileId,
        -:  979:                                              unsigned SourceLineNum,
        -:  980:                                              const MCSymbol *FnStartSym,
        -:  981:                                              const MCSymbol *FnEndSym);
        -:  982:
        -:  983:  /// This implements the CodeView '.cv_def_range' assembler
        -:  984:  /// directive.
        -:  985:  virtual void emitCVDefRangeDirective(
        -:  986:      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,
        -:  987:      StringRef FixedSizePortion);
        -:  988:
        -:  989:  virtual void emitCVDefRangeDirective(
        -:  990:      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,
        -:  991:      codeview::DefRangeRegisterRelHeader DRHdr);
        -:  992:
        -:  993:  virtual void emitCVDefRangeDirective(
        -:  994:      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,
        -:  995:      codeview::DefRangeSubfieldRegisterHeader DRHdr);
        -:  996:
        -:  997:  virtual void emitCVDefRangeDirective(
        -:  998:      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,
        -:  999:      codeview::DefRangeRegisterHeader DRHdr);
        -: 1000:
        -: 1001:  virtual void emitCVDefRangeDirective(
        -: 1002:      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,
        -: 1003:      codeview::DefRangeFramePointerRelHeader DRHdr);
        -: 1004:
        -: 1005:  /// This implements the CodeView '.cv_stringtable' assembler directive.
        -: 1006:  virtual void emitCVStringTableDirective() {}
        -: 1007:
        -: 1008:  /// This implements the CodeView '.cv_filechecksums' assembler directive.
        -: 1009:  virtual void emitCVFileChecksumsDirective() {}
        -: 1010:
        -: 1011:  /// This implements the CodeView '.cv_filechecksumoffset' assembler
        -: 1012:  /// directive.
        -: 1013:  virtual void emitCVFileChecksumOffsetDirective(unsigned FileNo) {}
        -: 1014:
        -: 1015:  /// This implements the CodeView '.cv_fpo_data' assembler directive.
        -: 1016:  virtual void emitCVFPOData(const MCSymbol *ProcSym, SMLoc Loc = {}) {}
        -: 1017:
        -: 1018:  /// Emit the absolute difference between two symbols.
        -: 1019:  ///
        -: 1020:  /// \pre Offset of \c Hi is greater than the offset \c Lo.
        -: 1021:  virtual void emitAbsoluteSymbolDiff(const MCSymbol *Hi, const MCSymbol *Lo,
        -: 1022:                                      unsigned Size);
        -: 1023:
        -: 1024:  /// Emit the absolute difference between two symbols encoded with ULEB128.
        -: 1025:  virtual void emitAbsoluteSymbolDiffAsULEB128(const MCSymbol *Hi,
        -: 1026:                                               const MCSymbol *Lo);
        -: 1027:
        -: 1028:  virtual MCSymbol *getDwarfLineTableSymbol(unsigned CUID);
        -: 1029:  virtual void emitCFISections(bool EH, bool Debug);
        -: 1030:  void emitCFIStartProc(bool IsSimple, SMLoc Loc = SMLoc());
        -: 1031:  void emitCFIEndProc();
        -: 1032:  virtual void emitCFIDefCfa(int64_t Register, int64_t Offset);
        -: 1033:  virtual void emitCFIDefCfaOffset(int64_t Offset);
        -: 1034:  virtual void emitCFIDefCfaRegister(int64_t Register);
        -: 1035:  virtual void emitCFILLVMDefAspaceCfa(int64_t Register, int64_t Offset,
        -: 1036:                                       int64_t AddressSpace);
        -: 1037:  virtual void emitCFIOffset(int64_t Register, int64_t Offset);
        -: 1038:  virtual void emitCFIPersonality(const MCSymbol *Sym, unsigned Encoding);
        -: 1039:  virtual void emitCFILsda(const MCSymbol *Sym, unsigned Encoding);
        -: 1040:  virtual void emitCFIRememberState();
        -: 1041:  virtual void emitCFIRestoreState();
        -: 1042:  virtual void emitCFISameValue(int64_t Register);
        -: 1043:  virtual void emitCFIRestore(int64_t Register);
        -: 1044:  virtual void emitCFIRelOffset(int64_t Register, int64_t Offset);
        -: 1045:  virtual void emitCFIAdjustCfaOffset(int64_t Adjustment);
        -: 1046:  virtual void emitCFIEscape(StringRef Values);
        -: 1047:  virtual void emitCFIReturnColumn(int64_t Register);
        -: 1048:  virtual void emitCFIGnuArgsSize(int64_t Size);
        -: 1049:  virtual void emitCFISignalFrame();
        -: 1050:  virtual void emitCFIUndefined(int64_t Register);
        -: 1051:  virtual void emitCFIRegister(int64_t Register1, int64_t Register2);
        -: 1052:  virtual void emitCFIWindowSave();
        -: 1053:  virtual void emitCFINegateRAState();
        -: 1054:
        -: 1055:  virtual void emitWinCFIStartProc(const MCSymbol *Symbol, SMLoc Loc = SMLoc());
        -: 1056:  virtual void emitWinCFIEndProc(SMLoc Loc = SMLoc());
        -: 1057:  /// This is used on platforms, such as Windows on ARM64, that require function
        -: 1058:  /// or funclet sizes to be emitted in .xdata before the End marker is emitted
        -: 1059:  /// for the frame.  We cannot use the End marker, as it is not set at the
        -: 1060:  /// point of emitting .xdata, in order to indicate that the frame is active.
        -: 1061:  virtual void emitWinCFIFuncletOrFuncEnd(SMLoc Loc = SMLoc());
        -: 1062:  virtual void emitWinCFIStartChained(SMLoc Loc = SMLoc());
        -: 1063:  virtual void emitWinCFIEndChained(SMLoc Loc = SMLoc());
        -: 1064:  virtual void emitWinCFIPushReg(MCRegister Register, SMLoc Loc = SMLoc());
        -: 1065:  virtual void emitWinCFISetFrame(MCRegister Register, unsigned Offset,
        -: 1066:                                  SMLoc Loc = SMLoc());
        -: 1067:  virtual void emitWinCFIAllocStack(unsigned Size, SMLoc Loc = SMLoc());
        -: 1068:  virtual void emitWinCFISaveReg(MCRegister Register, unsigned Offset,
        -: 1069:                                 SMLoc Loc = SMLoc());
        -: 1070:  virtual void emitWinCFISaveXMM(MCRegister Register, unsigned Offset,
        -: 1071:                                 SMLoc Loc = SMLoc());
        -: 1072:  virtual void emitWinCFIPushFrame(bool Code, SMLoc Loc = SMLoc());
        -: 1073:  virtual void emitWinCFIEndProlog(SMLoc Loc = SMLoc());
        -: 1074:  virtual void emitWinEHHandler(const MCSymbol *Sym, bool Unwind, bool Except,
        -: 1075:                                SMLoc Loc = SMLoc());
        -: 1076:  virtual void emitWinEHHandlerData(SMLoc Loc = SMLoc());
        -: 1077:
        -: 1078:  virtual void emitCGProfileEntry(const MCSymbolRefExpr *From,
        -: 1079:                                  const MCSymbolRefExpr *To, uint64_t Count);
        -: 1080:
        -: 1081:  /// Get the .pdata section used for the given section. Typically the given
        -: 1082:  /// section is either the main .text section or some other COMDAT .text
        -: 1083:  /// section, but it may be any section containing code.
        -: 1084:  MCSection *getAssociatedPDataSection(const MCSection *TextSec);
        -: 1085:
        -: 1086:  /// Get the .xdata section used for the given section.
        -: 1087:  MCSection *getAssociatedXDataSection(const MCSection *TextSec);
        -: 1088:
        -: 1089:  virtual void emitSyntaxDirective();
        -: 1090:
        -: 1091:  /// Record a relocation described by the .reloc directive. Return None if
        -: 1092:  /// succeeded. Otherwise, return a pair (Name is invalid, error message).
        -: 1093:  virtual Optional<std::pair<bool, std::string>>
        -: 1094:  emitRelocDirective(const MCExpr &Offset, StringRef Name, const MCExpr *Expr,
        -: 1095:                     SMLoc Loc, const MCSubtargetInfo &STI) {
        -: 1096:    return None;
        -: 1097:  }
        -: 1098:
        -: 1099:  virtual void emitAddrsig() {}
        -: 1100:  virtual void emitAddrsigSym(const MCSymbol *Sym) {}
        -: 1101:
        -: 1102:  /// Emit the given \p Instruction into the current section.
        -: 1103:  virtual void emitInstruction(const MCInst &Inst, const MCSubtargetInfo &STI);
        -: 1104:
        -: 1105:  /// Emit the a pseudo probe into the current section.
        -: 1106:  virtual void emitPseudoProbe(uint64_t Guid, uint64_t Index, uint64_t Type,
        -: 1107:                               uint64_t Attr,
        -: 1108:                               const MCPseudoProbeInlineStack &InlineStack,
        -: 1109:                               MCSymbol *FnSym);
        -: 1110:
        -: 1111:  /// Set the bundle alignment mode from now on in the section.
        -: 1112:  /// The argument is the power of 2 to which the alignment is set. The
        -: 1113:  /// value 0 means turn the bundle alignment off.
        -: 1114:  virtual void emitBundleAlignMode(unsigned AlignPow2);
        -: 1115:
        -: 1116:  /// The following instructions are a bundle-locked group.
        -: 1117:  ///
        -: 1118:  /// \param AlignToEnd - If true, the bundle-locked group will be aligned to
        -: 1119:  ///                     the end of a bundle.
        -: 1120:  virtual void emitBundleLock(bool AlignToEnd);
        -: 1121:
        -: 1122:  /// Ends a bundle-locked group.
        -: 1123:  virtual void emitBundleUnlock();
        -: 1124:
        -: 1125:  /// If this file is backed by a assembly streamer, this dumps the
        -: 1126:  /// specified string in the output .s file.  This capability is indicated by
        -: 1127:  /// the hasRawTextSupport() predicate.  By default this aborts.
        -: 1128:  void emitRawText(const Twine &String);
        -: 1129:
        -: 1130:  /// Streamer specific finalization.
        -: 1131:  virtual void finishImpl();
        -: 1132:  /// Finish emission of machine code.
        -: 1133:  void finish(SMLoc EndLoc = SMLoc());
        -: 1134:
        -: 1135:  virtual bool mayHaveInstructions(MCSection &Sec) const { return true; }
        -: 1136:
        -: 1137:  /// Emit a special value of 0xffffffff if producing 64-bit debugging info.
        -: 1138:  void maybeEmitDwarf64Mark();
        -: 1139:
        -: 1140:  /// Emit a unit length field. The actual format, DWARF32 or DWARF64, is chosen
        -: 1141:  /// according to the settings.
        -: 1142:  virtual void emitDwarfUnitLength(uint64_t Length, const Twine &Comment);
        -: 1143:
        -: 1144:  /// Emit a unit length field. The actual format, DWARF32 or DWARF64, is chosen
        -: 1145:  /// according to the settings.
        -: 1146:  /// Return the end symbol generated inside, the caller needs to emit it.
        -: 1147:  virtual MCSymbol *emitDwarfUnitLength(const Twine &Prefix,
        -: 1148:                                        const Twine &Comment);
        -: 1149:
        -: 1150:  /// Emit the debug line start label.
        -: 1151:  virtual void emitDwarfLineStartLabel(MCSymbol *StartSym);
        -: 1152:
        -: 1153:  /// Emit the debug line end entry.
        -: 1154:  virtual void emitDwarfLineEndEntry(MCSection *Section, MCSymbol *LastLabel) {}
        -: 1155:
        -: 1156:  /// If targets does not support representing debug line section by .loc/.file
        -: 1157:  /// directives in assembly output, we need to populate debug line section with
        -: 1158:  /// raw debug line contents.
        -: 1159:  virtual void emitDwarfAdvanceLineAddr(int64_t LineDelta,
        -: 1160:                                        const MCSymbol *LastLabel,
        -: 1161:                                        const MCSymbol *Label,
        -: 1162:                                        unsigned PointerSize) {}
        -: 1163:
        -: 1164:  /// Do finalization for the streamer at the end of a section.
        -: 1165:  virtual void doFinalizationAtSectionEnd(MCSection *Section) {}
        -: 1166:};
        -: 1167:
        -: 1168:/// Create a dummy machine code streamer, which does nothing. This is useful for
        -: 1169:/// timing the assembler front end.
        -: 1170:MCStreamer *createNullStreamer(MCContext &Ctx);
        -: 1171:
        -: 1172:} // end namespace llvm
        -: 1173:
        -: 1174:#endif // LLVM_MC_MCSTREAMER_H
