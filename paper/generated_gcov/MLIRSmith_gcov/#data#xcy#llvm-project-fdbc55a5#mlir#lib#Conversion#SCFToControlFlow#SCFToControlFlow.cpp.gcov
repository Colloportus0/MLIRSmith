        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/SCFToControlFlow/SCFToControlFlow.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/SCFToControlFlow/CMakeFiles/obj.MLIRSCFToControlFlow.dir/SCFToControlFlow.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/SCFToControlFlow/CMakeFiles/obj.MLIRSCFToControlFlow.dir/SCFToControlFlow.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- SCFToControlFlow.cpp - SCF to CF conversion ------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements a pass to convert scf.for, scf.if and loop.terminator
        -:   10:// ops into standard CFG ops.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h"
        -:   15:
        -:   16:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   17:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
        -:   18:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   19:#include "mlir/IR/BlockAndValueMapping.h"
        -:   20:#include "mlir/IR/Builders.h"
        -:   21:#include "mlir/IR/BuiltinOps.h"
        -:   22:#include "mlir/IR/MLIRContext.h"
        -:   23:#include "mlir/IR/PatternMatch.h"
        -:   24:#include "mlir/Transforms/DialectConversion.h"
        -:   25:#include "mlir/Transforms/Passes.h"
        -:   26:
        -:   27:namespace mlir {
        -:   28:#define GEN_PASS_DEF_SCFTOCONTROLFLOW
        -:   29:#include "mlir/Conversion/Passes.h.inc"
        -:   30:} // namespace mlir
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace mlir::scf;
        -:   34:
        -:   35:namespace {
        -:   36:
   117460:   37:struct SCFToControlFlowPass
call    0 returned 100%
call    1 returned 100%
        -:   38:    : public impl::SCFToControlFlowBase<SCFToControlFlowPass> {
        -:   39:  void runOnOperation() override;
        -:   40:};
        -:   41:
        -:   42:// Create a CFG subgraph for the loop around its body blocks (if the body
        -:   43:// contained other loops, they have been already lowered to a flow of blocks).
        -:   44:// Maintain the invariants that a CFG subgraph created for any loop has a single
        -:   45:// entry and a single exit, and that the entry/exit blocks are respectively
        -:   46:// first/last blocks in the parent region.  The original loop operation is
        -:   47:// replaced by the initialization operations that set up the initial value of
        -:   48:// the loop induction variable (%iv) and computes the loop bounds that are loop-
        -:   49:// invariant for affine loops.  The operations following the original scf.for
        -:   50:// are split out into a separate continuation (exit) block. A condition block is
        -:   51:// created before the continuation block. It checks the exit condition of the
        -:   52:// loop and branches either to the continuation block, or to the first block of
        -:   53:// the body. The condition block takes as arguments the values of the induction
        -:   54:// variable followed by loop-carried values. Since it dominates both the body
        -:   55:// blocks and the continuation block, loop-carried values are visible in all of
        -:   56:// those blocks. Induction variable modification is appended to the last block
        -:   57:// of the body (which is the exit block from the body subgraph thanks to the
        -:   58:// invariant we maintain) along with a branch that loops back to the condition
        -:   59:// block. Loop-carried values are the loop terminator operands, which are
        -:   60:// forwarded to the branch.
        -:   61://
        -:   62://      +---------------------------------+
        -:   63://      |   <code before the ForOp>       |
        -:   64://      |   <definitions of %init...>     |
        -:   65://      |   <compute initial %iv value>   |
        -:   66://      |   cf.br cond(%iv, %init...)        |
        -:   67://      +---------------------------------+
        -:   68://             |
        -:   69://  -------|   |
        -:   70://  |      v   v
        -:   71://  |   +--------------------------------+
        -:   72://  |   | cond(%iv, %init...):           |
        -:   73://  |   |   <compare %iv to upper bound> |
        -:   74://  |   |   cf.cond_br %r, body, end        |
        -:   75://  |   +--------------------------------+
        -:   76://  |          |               |
        -:   77://  |          |               -------------|
        -:   78://  |          v                            |
        -:   79://  |   +--------------------------------+  |
        -:   80://  |   | body-first:                    |  |
        -:   81://  |   |   <%init visible by dominance> |  |
        -:   82://  |   |   <body contents>              |  |
        -:   83://  |   +--------------------------------+  |
        -:   84://  |                   |                   |
        -:   85://  |                  ...                  |
        -:   86://  |                   |                   |
        -:   87://  |   +--------------------------------+  |
        -:   88://  |   | body-last:                     |  |
        -:   89://  |   |   <body contents>              |  |
        -:   90://  |   |   <operands of yield = %yields>|  |
        -:   91://  |   |   %new_iv =<add step to %iv>   |  |
        -:   92://  |   |   cf.br cond(%new_iv, %yields)    |  |
        -:   93://  |   +--------------------------------+  |
        -:   94://  |          |                            |
        -:   95://  |-----------        |--------------------
        -:   96://                      v
        -:   97://      +--------------------------------+
        -:   98://      | end:                           |
        -:   99://      |   <code after the ForOp>       |
        -:  100://      |   <%init visible by dominance> |
        -:  101://      +--------------------------------+
        -:  102://
        -:  103:struct ForLowering : public OpRewritePattern<ForOp> {
        -:  104:  using OpRewritePattern<ForOp>::OpRewritePattern;
        -:  105:
        -:  106:  LogicalResult matchAndRewrite(ForOp forOp,
        -:  107:                                PatternRewriter &rewriter) const override;
        -:  108:};
        -:  109:
        -:  110:// Create a CFG subgraph for the scf.if operation (including its "then" and
        -:  111:// optional "else" operation blocks).  We maintain the invariants that the
        -:  112:// subgraph has a single entry and a single exit point, and that the entry/exit
        -:  113:// blocks are respectively the first/last block of the enclosing region. The
        -:  114:// operations following the scf.if are split into a continuation (subgraph
        -:  115:// exit) block. The condition is lowered to a chain of blocks that implement the
        -:  116:// short-circuit scheme. The "scf.if" operation is replaced with a conditional
        -:  117:// branch to either the first block of the "then" region, or to the first block
        -:  118:// of the "else" region. In these blocks, "scf.yield" is unconditional branches
        -:  119:// to the post-dominating block. When the "scf.if" does not return values, the
        -:  120:// post-dominating block is the same as the continuation block. When it returns
        -:  121:// values, the post-dominating block is a new block with arguments that
        -:  122:// correspond to the values returned by the "scf.if" that unconditionally
        -:  123:// branches to the continuation block. This allows block arguments to dominate
        -:  124:// any uses of the hitherto "scf.if" results that they replaced. (Inserting a
        -:  125:// new block allows us to avoid modifying the argument list of an existing
        -:  126:// block, which is illegal in a conversion pattern). When the "else" region is
        -:  127:// empty, which is only allowed for "scf.if"s that don't return values, the
        -:  128:// condition branches directly to the continuation block.
        -:  129://
        -:  130:// CFG for a scf.if with else and without results.
        -:  131://
        -:  132://      +--------------------------------+
        -:  133://      | <code before the IfOp>         |
        -:  134://      | cf.cond_br %cond, %then, %else    |
        -:  135://      +--------------------------------+
        -:  136://             |              |
        -:  137://             |              --------------|
        -:  138://             v                            |
        -:  139://      +--------------------------------+  |
        -:  140://      | then:                          |  |
        -:  141://      |   <then contents>              |  |
        -:  142://      |   cf.br continue                  |  |
        -:  143://      +--------------------------------+  |
        -:  144://             |                            |
        -:  145://   |----------               |-------------
        -:  146://   |                         V
        -:  147://   |  +--------------------------------+
        -:  148://   |  | else:                          |
        -:  149://   |  |   <else contents>              |
        -:  150://   |  |   cf.br continue                  |
        -:  151://   |  +--------------------------------+
        -:  152://   |         |
        -:  153://   ------|   |
        -:  154://         v   v
        -:  155://      +--------------------------------+
        -:  156://      | continue:                      |
        -:  157://      |   <code after the IfOp>        |
        -:  158://      +--------------------------------+
        -:  159://
        -:  160:// CFG for a scf.if with results.
        -:  161://
        -:  162://      +--------------------------------+
        -:  163://      | <code before the IfOp>         |
        -:  164://      | cf.cond_br %cond, %then, %else    |
        -:  165://      +--------------------------------+
        -:  166://             |              |
        -:  167://             |              --------------|
        -:  168://             v                            |
        -:  169://      +--------------------------------+  |
        -:  170://      | then:                          |  |
        -:  171://      |   <then contents>              |  |
        -:  172://      |   cf.br dom(%args...)             |  |
        -:  173://      +--------------------------------+  |
        -:  174://             |                            |
        -:  175://   |----------               |-------------
        -:  176://   |                         V
        -:  177://   |  +--------------------------------+
        -:  178://   |  | else:                          |
        -:  179://   |  |   <else contents>              |
        -:  180://   |  |   cf.br dom(%args...)             |
        -:  181://   |  +--------------------------------+
        -:  182://   |         |
        -:  183://   ------|   |
        -:  184://         v   v
        -:  185://      +--------------------------------+
        -:  186://      | dom(%args...):                 |
        -:  187://      |   cf.br continue                  |
        -:  188://      +--------------------------------+
        -:  189://             |
        -:  190://             v
        -:  191://      +--------------------------------+
        -:  192://      | continue:                      |
        -:  193://      | <code after the IfOp>          |
        -:  194://      +--------------------------------+
        -:  195://
        -:  196:struct IfLowering : public OpRewritePattern<IfOp> {
        -:  197:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -:  198:
        -:  199:  LogicalResult matchAndRewrite(IfOp ifOp,
        -:  200:                                PatternRewriter &rewriter) const override;
        -:  201:};
        -:  202:
        -:  203:struct ExecuteRegionLowering : public OpRewritePattern<ExecuteRegionOp> {
        -:  204:  using OpRewritePattern<ExecuteRegionOp>::OpRewritePattern;
        -:  205:
        -:  206:  LogicalResult matchAndRewrite(ExecuteRegionOp op,
        -:  207:                                PatternRewriter &rewriter) const override;
        -:  208:};
        -:  209:
        -:  210:struct ParallelLowering : public OpRewritePattern<mlir::scf::ParallelOp> {
        -:  211:  using OpRewritePattern<mlir::scf::ParallelOp>::OpRewritePattern;
        -:  212:
        -:  213:  LogicalResult matchAndRewrite(mlir::scf::ParallelOp parallelOp,
        -:  214:                                PatternRewriter &rewriter) const override;
        -:  215:};
        -:  216:
        -:  217:/// Create a CFG subgraph for this loop construct. The regions of the loop need
        -:  218:/// not be a single block anymore (for example, if other SCF constructs that
        -:  219:/// they contain have been already converted to CFG), but need to be single-exit
        -:  220:/// from the last block of each region. The operations following the original
        -:  221:/// WhileOp are split into a new continuation block. Both regions of the WhileOp
        -:  222:/// are inlined, and their terminators are rewritten to organize the control
        -:  223:/// flow implementing the loop as follows.
        -:  224:///
        -:  225:///      +---------------------------------+
        -:  226:///      |   <code before the WhileOp>     |
        -:  227:///      |   cf.br ^before(%operands...)      |
        -:  228:///      +---------------------------------+
        -:  229:///             |
        -:  230:///  -------|   |
        -:  231:///  |      v   v
        -:  232:///  |   +--------------------------------+
        -:  233:///  |   | ^before(%bargs...):            |
        -:  234:///  |   |   %vals... = <some payload>    |
        -:  235:///  |   +--------------------------------+
        -:  236:///  |                   |
        -:  237:///  |                  ...
        -:  238:///  |                   |
        -:  239:///  |   +--------------------------------+
        -:  240:///  |   | ^before-last:
        -:  241:///  |   |   %cond = <compute condition>  |
        -:  242:///  |   |   cf.cond_br %cond,               |
        -:  243:///  |   |        ^after(%vals...), ^cont |
        -:  244:///  |   +--------------------------------+
        -:  245:///  |          |               |
        -:  246:///  |          |               -------------|
        -:  247:///  |          v                            |
        -:  248:///  |   +--------------------------------+  |
        -:  249:///  |   | ^after(%aargs...):             |  |
        -:  250:///  |   |   <body contents>              |  |
        -:  251:///  |   +--------------------------------+  |
        -:  252:///  |                   |                   |
        -:  253:///  |                  ...                  |
        -:  254:///  |                   |                   |
        -:  255:///  |   +--------------------------------+  |
        -:  256:///  |   | ^after-last:                   |  |
        -:  257:///  |   |   %yields... = <some payload>  |  |
        -:  258:///  |   |   cf.br ^before(%yields...)       |  |
        -:  259:///  |   +--------------------------------+  |
        -:  260:///  |          |                            |
        -:  261:///  |-----------        |--------------------
        -:  262:///                      v
        -:  263:///      +--------------------------------+
        -:  264:///      | ^cont:                         |
        -:  265:///      |   <code after the WhileOp>     |
        -:  266:///      |   <%vals from 'before' region  |
        -:  267:///      |          visible by dominance> |
        -:  268:///      +--------------------------------+
        -:  269:///
        -:  270:/// Values are communicated between ex-regions (the groups of blocks that used
        -:  271:/// to form a region before inlining) through block arguments of their
        -:  272:/// entry blocks, which are visible in all other dominated blocks. Similarly,
        -:  273:/// the results of the WhileOp are defined in the 'before' region, which is
        -:  274:/// required to have a single existing block, and are therefore accessible in
        -:  275:/// the continuation block due to dominance.
        -:  276:struct WhileLowering : public OpRewritePattern<WhileOp> {
        -:  277:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -:  278:
        -:  279:  LogicalResult matchAndRewrite(WhileOp whileOp,
        -:  280:                                PatternRewriter &rewriter) const override;
        -:  281:};
        -:  282:
        -:  283:/// Optimized version of the above for the case of the "after" region merely
        -:  284:/// forwarding its arguments back to the "before" region (i.e., a "do-while"
        -:  285:/// loop). This avoid inlining the "after" region completely and branches back
        -:  286:/// to the "before" entry instead.
        -:  287:struct DoWhileLowering : public OpRewritePattern<WhileOp> {
        -:  288:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -:  289:
        -:  290:  LogicalResult matchAndRewrite(WhileOp whileOp,
        -:  291:                                PatternRewriter &rewriter) const override;
        -:  292:};
        -:  293:
        -:  294:/// Lower an `scf.index_switch` operation to a `cf.switch` operation.
        -:  295:struct IndexSwitchLowering : public OpRewritePattern<IndexSwitchOp> {
        -:  296:  using OpRewritePattern::OpRewritePattern;
        -:  297:
        -:  298:  LogicalResult matchAndRewrite(IndexSwitchOp op,
        -:  299:                                PatternRewriter &rewriter) const override;
        -:  300:};
        -:  301:} // namespace
        -:  302:
function _ZNK12_GLOBAL__N_111ForLowering15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterE called 1341 returned 100% blocks executed 90%
     1341:  303:LogicalResult ForLowering::matchAndRewrite(ForOp forOp,
        -:  304:                                           PatternRewriter &rewriter) const {
     1341:  305:  Location loc = forOp.getLoc();
call    0 returned 100%
        -:  306:
        -:  307:  // Start by splitting the block containing the 'scf.for' into two parts.
        -:  308:  // The part before will get the init code, the part after will be the end
        -:  309:  // point.
     1341:  310:  auto *initBlock = rewriter.getInsertionBlock();
call    0 returned 100%
     1341:  311:  auto initPosition = rewriter.getInsertionPoint();
call    0 returned 100%
     1341:  312:  auto *endBlock = rewriter.splitBlock(initBlock, initPosition);
call    0 returned 100%
        -:  313:
        -:  314:  // Use the first block of the loop body as the condition block since it is the
        -:  315:  // block that has the induction variable and loop-carried values as arguments.
        -:  316:  // Split out all operations from the first block into a new block. Move all
        -:  317:  // body blocks from the loop body region to the region containing the loop.
     1341:  318:  auto *conditionBlock = &forOp.getRegion().front();
call    0 returned 100%
call    1 returned 100%
     1341:  319:  auto *firstBodyBlock =
     1341:  320:      rewriter.splitBlock(conditionBlock, conditionBlock->begin());
call    0 returned 100%
     1341:  321:  auto *lastBodyBlock = &forOp.getRegion().back();
call    0 returned 100%
call    1 returned 100%
     1341:  322:  rewriter.inlineRegionBefore(forOp.getRegion(), endBlock);
call    0 returned 100%
call    1 returned 100%
     1341:  323:  auto iv = conditionBlock->getArgument(0);
call    0 returned 100%
        -:  324:
        -:  325:  // Append the induction variable stepping logic to the last body block and
        -:  326:  // branch back to the condition block. Loop-carried values are taken from
        -:  327:  // operands of the loop terminator.
     1341:  328:  Operation *terminator = lastBodyBlock->getTerminator();
call    0 returned 100%
     1341:  329:  rewriter.setInsertionPointToEnd(lastBodyBlock);
call    0 returned 100%
     1341:  330:  auto step = forOp.getStep();
call    0 returned 100%
     1341:  331:  auto stepped = rewriter.create<arith::AddIOp>(loc, iv, step).getResult();
call    0 returned 100%
call    1 returned 100%
     1341:  332:  if (!stepped)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  333:    return failure();
        -:  334:
     1341:  335:  SmallVector<Value, 8> loopCarried;
call    0 returned 100%
     1341:  336:  loopCarried.push_back(stepped);
call    0 returned 100%
     1341:  337:  loopCarried.append(terminator->operand_begin(), terminator->operand_end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1341:  338:  rewriter.create<cf::BranchOp>(loc, conditionBlock, loopCarried);
call    0 returned 100%
     1341:  339:  rewriter.eraseOp(terminator);
call    0 returned 100%
        -:  340:
        -:  341:  // Compute loop bounds before branching to the condition.
     1341:  342:  rewriter.setInsertionPointToEnd(initBlock);
call    0 returned 100%
     1341:  343:  Value lowerBound = forOp.getLowerBound();
call    0 returned 100%
     1341:  344:  Value upperBound = forOp.getUpperBound();
call    0 returned 100%
     1341:  345:  if (!lowerBound || !upperBound)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  346:    return failure();
        -:  347:
        -:  348:  // The initial values of loop-carried values is obtained from the operands
        -:  349:  // of the loop operation.
     2682:  350:  SmallVector<Value, 8> destOperands;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1341:  351:  destOperands.push_back(lowerBound);
call    0 returned 100%
     1341:  352:  auto iterOperands = forOp.getIterOperands();
call    0 returned 100%
     1341:  353:  destOperands.append(iterOperands.begin(), iterOperands.end());
call    0 returned 100%
     1341:  354:  rewriter.create<cf::BranchOp>(loc, conditionBlock, destOperands);
call    0 returned 100%
        -:  355:
        -:  356:  // With the body block done, we can fill in the condition block.
     1341:  357:  rewriter.setInsertionPointToEnd(conditionBlock);
call    0 returned 100%
     1341:  358:  auto comparison = rewriter.create<arith::CmpIOp>(
     1341:  359:      loc, arith::CmpIPredicate::slt, iv, upperBound);
call    0 returned 100%
        -:  360:
     1341:  361:  rewriter.create<cf::CondBranchOp>(loc, comparison, firstBodyBlock,
     1341:  362:                                    ArrayRef<Value>(), endBlock,
call    0 returned 100%
     1341:  363:                                    ArrayRef<Value>());
call    0 returned 100%
        -:  364:  // The result of the loop operation is the values of the condition block
        -:  365:  // arguments except the induction variable on the last iteration.
     1341:  366:  rewriter.replaceOp(forOp, conditionBlock->getArguments().drop_front());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1341:  367:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  368:}
        -:  369:
function _ZNK12_GLOBAL__N_110IfLowering15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 2653 returned 100% blocks executed 97%
     2653:  370:LogicalResult IfLowering::matchAndRewrite(IfOp ifOp,
        -:  371:                                          PatternRewriter &rewriter) const {
     2653:  372:  auto loc = ifOp.getLoc();
call    0 returned 100%
        -:  373:
        -:  374:  // Start by splitting the block containing the 'scf.if' into two parts.
        -:  375:  // The part before will contain the condition, the part after will be the
        -:  376:  // continuation point.
     2653:  377:  auto *condBlock = rewriter.getInsertionBlock();
call    0 returned 100%
     2653:  378:  auto opPosition = rewriter.getInsertionPoint();
call    0 returned 100%
     2653:  379:  auto *remainingOpsBlock = rewriter.splitBlock(condBlock, opPosition);
call    0 returned 100%
     2653:  380:  Block *continueBlock;
     2653:  381:  if (ifOp.getNumResults() == 0) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
     1201:  382:    continueBlock = remainingOpsBlock;
        -:  383:  } else {
     2904:  384:    continueBlock =
     2904:  385:        rewriter.createBlock(remainingOpsBlock, ifOp.getResultTypes(),
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     1452:  386:                             SmallVector<Location>(ifOp.getNumResults(), loc));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1452:  387:    rewriter.create<cf::BranchOp>(loc, remainingOpsBlock);
call    0 returned 100%
        -:  388:  }
        -:  389:
        -:  390:  // Move blocks from the "then" region to the region containing 'scf.if',
        -:  391:  // place it before the continuation block, and branch to it.
     2653:  392:  auto &thenRegion = ifOp.getThenRegion();
call    0 returned 100%
     2653:  393:  auto *thenBlock = &thenRegion.front();
call    0 returned 100%
     2653:  394:  Operation *thenTerminator = thenRegion.back().getTerminator();
call    0 returned 100%
call    1 returned 100%
     2653:  395:  ValueRange thenTerminatorOperands = thenTerminator->getOperands();
call    0 returned 100%
call    1 returned 100%
     2653:  396:  rewriter.setInsertionPointToEnd(&thenRegion.back());
call    0 returned 100%
call    1 returned 100%
     2653:  397:  rewriter.create<cf::BranchOp>(loc, continueBlock, thenTerminatorOperands);
call    0 returned 100%
     2653:  398:  rewriter.eraseOp(thenTerminator);
call    0 returned 100%
     2653:  399:  rewriter.inlineRegionBefore(thenRegion, continueBlock);
call    0 returned 100%
        -:  400:
        -:  401:  // Move blocks from the "else" region (if present) to the region containing
        -:  402:  // 'scf.if', place it before the continuation block and branch to it.  It
        -:  403:  // will be placed after the "then" regions.
     2653:  404:  auto *elseBlock = continueBlock;
     2653:  405:  auto &elseRegion = ifOp.getElseRegion();
call    0 returned 100%
     2653:  406:  if (!elseRegion.empty()) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
     1931:  407:    elseBlock = &elseRegion.front();
call    0 returned 100%
     1931:  408:    Operation *elseTerminator = elseRegion.back().getTerminator();
call    0 returned 100%
call    1 returned 100%
     1931:  409:    ValueRange elseTerminatorOperands = elseTerminator->getOperands();
call    0 returned 100%
call    1 returned 100%
     1931:  410:    rewriter.setInsertionPointToEnd(&elseRegion.back());
call    0 returned 100%
call    1 returned 100%
     1931:  411:    rewriter.create<cf::BranchOp>(loc, continueBlock, elseTerminatorOperands);
call    0 returned 100%
     1931:  412:    rewriter.eraseOp(elseTerminator);
call    0 returned 100%
     1931:  413:    rewriter.inlineRegionBefore(elseRegion, continueBlock);
call    0 returned 100%
        -:  414:  }
        -:  415:
     2653:  416:  rewriter.setInsertionPointToEnd(condBlock);
call    0 returned 100%
     5306:  417:  rewriter.create<cf::CondBranchOp>(loc, ifOp.getCondition(), thenBlock,
     2653:  418:                                    /*trueArgs=*/ArrayRef<Value>(), elseBlock,
call    0 returned 100%
     2653:  419:                                    /*falseArgs=*/ArrayRef<Value>());
call    0 returned 100%
call    1 returned 100%
        -:  420:
        -:  421:  // Ok, we're done!
     2653:  422:  rewriter.replaceOp(ifOp, continueBlock->getArguments());
call    0 returned 100%
call    1 returned 100%
     2653:  423:  return success();
        -:  424:}
        -:  425:
        -:  426:LogicalResult
function _ZNK12_GLOBAL__N_121ExecuteRegionLowering15matchAndRewriteEN4mlir3scf15ExecuteRegionOpERNS1_15PatternRewriterE called 2674 returned 100% blocks executed 91%
     2674:  427:ExecuteRegionLowering::matchAndRewrite(ExecuteRegionOp op,
        -:  428:                                       PatternRewriter &rewriter) const {
     2674:  429:  auto loc = op.getLoc();
call    0 returned 100%
        -:  430:
     2674:  431:  auto *condBlock = rewriter.getInsertionBlock();
call    0 returned 100%
     2674:  432:  auto opPosition = rewriter.getInsertionPoint();
call    0 returned 100%
     2674:  433:  auto *remainingOpsBlock = rewriter.splitBlock(condBlock, opPosition);
call    0 returned 100%
        -:  434:
     2674:  435:  auto &region = op.getRegion();
call    0 returned 100%
     2674:  436:  rewriter.setInsertionPointToEnd(condBlock);
call    0 returned 100%
     2674:  437:  rewriter.create<cf::BranchOp>(loc, &region.front());
call    0 returned 100%
call    1 returned 100%
        -:  438:
     5348:  439:  for (Block &block : region) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2674:  440:    if (auto terminator = dyn_cast<scf::YieldOp>(block.getTerminator())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2674:  441:      ValueRange terminatorOperands = terminator->getOperands();
call    0 returned 100%
call    1 returned 100%
     2674:  442:      rewriter.setInsertionPointToEnd(&block);
call    0 returned 100%
     2674:  443:      rewriter.create<cf::BranchOp>(loc, remainingOpsBlock, terminatorOperands);
call    0 returned 100%
     2674:  444:      rewriter.eraseOp(terminator);
call    0 returned 100%
        -:  445:    }
        -:  446:  }
        -:  447:
     2674:  448:  rewriter.inlineRegionBefore(region, remainingOpsBlock);
call    0 returned 100%
        -:  449:
     2674:  450:  SmallVector<Value> vals;
call    0 returned 100%
     5348:  451:  SmallVector<Location> argLocs(op.getNumResults(), op->getLoc());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1519:  452:  for (auto arg :
     6867:  453:       remainingOpsBlock->addArguments(op->getResultTypes(), argLocs))
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 36% (fallthrough)
branch  5 taken 64%
     1519:  454:    vals.push_back(arg);
call    0 returned 100%
     2674:  455:  rewriter.replaceOp(op, vals);
call    0 returned 100%
call    1 returned 100%
     2674:  456:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  457:}
        -:  458:
        -:  459:LogicalResult
function _ZNK12_GLOBAL__N_116ParallelLowering15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterE called 827 returned 100% blocks executed 89%
      827:  460:ParallelLowering::matchAndRewrite(ParallelOp parallelOp,
        -:  461:                                  PatternRewriter &rewriter) const {
      827:  462:  Location loc = parallelOp.getLoc();
call    0 returned 100%
        -:  463:
        -:  464:  // For a parallel loop, we essentially need to create an n-dimensional loop
        -:  465:  // nest. We do this by translating to scf.for ops and have those lowered in
        -:  466:  // a further rewrite. If a parallel loop contains reductions (and thus returns
        -:  467:  // values), forward the initial values for the reductions down the loop
        -:  468:  // hierarchy and bubble up the results by modifying the "yield" terminator.
      827:  469:  SmallVector<Value, 4> iterArgs = llvm::to_vector<4>(parallelOp.getInitVals());
call    0 returned 100%
call    1 returned 100%
     1654:  470:  SmallVector<Value, 4> ivs;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      827:  471:  ivs.reserve(parallelOp.getNumLoops());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      827:  472:  bool first = true;
     1654:  473:  SmallVector<Value, 4> loopResults(iterArgs);
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2680:  474:  for (auto [iv, lower, upper, step] :
call    0 returned 100%
      827:  475:       llvm::zip(parallelOp.getInductionVars(), parallelOp.getLowerBound(),
call    0 returned 100%
call    1 returned 100%
     4334:  476:                 parallelOp.getUpperBound(), parallelOp.getStep())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 62% (fallthrough)
branch  3 taken 38%
call    4 returned 100%
     1340:  477:    ForOp forOp = rewriter.create<ForOp>(loc, lower, upper, step, iterArgs);
call    0 returned 100%
     1340:  478:    ivs.push_back(forOp.getInductionVar());
call    0 returned 100%
call    1 returned 100%
     1340:  479:    auto iterRange = forOp.getRegionIterArgs();
call    0 returned 100%
     1340:  480:    iterArgs.assign(iterRange.begin(), iterRange.end());
call    0 returned 100%
        -:  481:
     1340:  482:    if (first) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:  483:      // Store the results of the outermost loop that will be used to replace
        -:  484:      // the results of the parallel loop when it is fully rewritten.
     1205:  485:      loopResults.assign(forOp.result_begin(), forOp.result_end());
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
call    2 returned 100%
      827:  486:      first = false;
      513:  487:    } else if (!forOp.getResults().empty()) {
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
        -:  488:      // A loop is constructed with an empty "yield" terminator if there are
        -:  489:      // no results.
      228:  490:      rewriter.setInsertionPointToEnd(rewriter.getInsertionBlock());
call    0 returned 100%
      228:  491:      rewriter.create<scf::YieldOp>(loc, forOp.getResults());
call    0 returned 100%
call    1 returned 100%
        -:  492:    }
        -:  493:
     1340:  494:    rewriter.setInsertionPointToStart(forOp.getBody());
call    0 returned 100%
        -:  495:  }
        -:  496:
        -:  497:  // First, merge reduction blocks into the main region.
     1654:  498:  SmallVector<Value, 4> yieldOperands;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      827:  499:  yieldOperands.reserve(parallelOp.getNumResults());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15824:  500:  for (auto &op : *parallelOp.getBody()) {
call    0 returned 100%
branch  1 taken 95% (fallthrough)
branch  2 taken 5%
call    3 returned 100%
    14997:  501:    auto reduce = dyn_cast<ReduceOp>(op);
call    0 returned 100%
    14997:  502:    if (!reduce)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
    14619:  503:      continue;
        -:  504:
      378:  505:    Block &reduceBlock = reduce.getReductionOperator().front();
call    0 returned 100%
call    1 returned 100%
      378:  506:    Value arg = iterArgs[yieldOperands.size()];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      378:  507:    yieldOperands.push_back(reduceBlock.getTerminator()->getOperand(0));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      378:  508:    rewriter.eraseOp(reduceBlock.getTerminator());
call    0 returned 100%
call    1 returned 100%
      378:  509:    rewriter.mergeBlockBefore(&reduceBlock, &op, {arg, reduce.getOperand()});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      378:  510:    rewriter.eraseOp(reduce);
call    0 returned 100%
        -:  511:  }
        -:  512:
        -:  513:  // Then merge the loop body without the terminator.
      827:  514:  rewriter.eraseOp(parallelOp.getBody()->getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      827:  515:  Block *newBody = rewriter.getInsertionBlock();
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
      827:  516:  if (newBody->empty())
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
      378:  517:    rewriter.mergeBlocks(parallelOp.getBody(), newBody, ivs);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  518:  else
      449:  519:    rewriter.mergeBlockBefore(parallelOp.getBody(), newBody->getTerminator(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  520:                              ivs);
        -:  521:
        -:  522:  // Finally, create the terminator if required (for loops with no results, it
        -:  523:  // has been already created in loop construction).
      827:  524:  if (!yieldOperands.empty()) {
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
      378:  525:    rewriter.setInsertionPointToEnd(rewriter.getInsertionBlock());
call    0 returned 100%
      378:  526:    rewriter.create<scf::YieldOp>(loc, yieldOperands);
call    0 returned 100%
        -:  527:  }
        -:  528:
      827:  529:  rewriter.replaceOp(parallelOp, loopResults);
call    0 returned 100%
call    1 returned 100%
        -:  530:
      827:  531:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  532:}
        -:  533:
function _ZNK12_GLOBAL__N_113WhileLowering15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 2515 returned 100% blocks executed 97%
     2515:  534:LogicalResult WhileLowering::matchAndRewrite(WhileOp whileOp,
        -:  535:                                             PatternRewriter &rewriter) const {
     2515:  536:  OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
     2515:  537:  Location loc = whileOp.getLoc();
call    0 returned 100%
        -:  538:
        -:  539:  // Split the current block before the WhileOp to create the inlining point.
     2515:  540:  Block *currentBlock = rewriter.getInsertionBlock();
     2515:  541:  Block *continuation =
     2515:  542:      rewriter.splitBlock(currentBlock, rewriter.getInsertionPoint());
call    0 returned 100%
        -:  543:
        -:  544:  // Inline both regions.
     2515:  545:  Block *after = &whileOp.getAfter().front();
call    0 returned 100%
call    1 returned 100%
     2515:  546:  Block *afterLast = &whileOp.getAfter().back();
call    0 returned 100%
call    1 returned 100%
     2515:  547:  Block *before = &whileOp.getBefore().front();
call    0 returned 100%
call    1 returned 100%
     2515:  548:  Block *beforeLast = &whileOp.getBefore().back();
call    0 returned 100%
call    1 returned 100%
     2515:  549:  rewriter.inlineRegionBefore(whileOp.getAfter(), continuation);
call    0 returned 100%
call    1 returned 100%
     2515:  550:  rewriter.inlineRegionBefore(whileOp.getBefore(), after);
call    0 returned 100%
call    1 returned 100%
        -:  551:
        -:  552:  // Branch to the "before" region.
     2515:  553:  rewriter.setInsertionPointToEnd(currentBlock);
call    0 returned 100%
     2515:  554:  rewriter.create<cf::BranchOp>(loc, before, whileOp.getInits());
call    0 returned 100%
call    1 returned 100%
        -:  555:
        -:  556:  // Replace terminators with branches. Assuming bodies are SESE, which holds
        -:  557:  // given only the patterns from this file, we only need to look at the last
        -:  558:  // block. This should be reconsidered if we allow break/continue in SCF.
     2515:  559:  rewriter.setInsertionPointToEnd(beforeLast);
call    0 returned 100%
     2515:  560:  auto condOp = cast<ConditionOp>(beforeLast->getTerminator());
call    0 returned 100%
call    1 returned 100%
     2515:  561:  rewriter.replaceOpWithNewOp<cf::CondBranchOp>(condOp, condOp.getCondition(),
call    0 returned 100%
     2515:  562:                                                after, condOp.getArgs(),
call    0 returned 100%
     5030:  563:                                                continuation, ValueRange());
call    0 returned 100%
call    1 returned 100%
        -:  564:
     2515:  565:  rewriter.setInsertionPointToEnd(afterLast);
call    0 returned 100%
     2515:  566:  auto yieldOp = cast<scf::YieldOp>(afterLast->getTerminator());
call    0 returned 100%
call    1 returned 100%
     2515:  567:  rewriter.replaceOpWithNewOp<cf::BranchOp>(yieldOp, before,
     2515:  568:                                            yieldOp.getResults());
call    0 returned 100%
call    1 returned 100%
        -:  569:
        -:  570:  // Replace the op with values "yielded" from the "before" region, which are
        -:  571:  // visible by dominance.
     2515:  572:  rewriter.replaceOp(whileOp, condOp.getArgs());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  573:
     2515:  574:  return success();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  575:}
        -:  576:
        -:  577:LogicalResult
function _ZNK12_GLOBAL__N_115DoWhileLowering15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 2518 returned 100% blocks executed 95%
     2518:  578:DoWhileLowering::matchAndRewrite(WhileOp whileOp,
        -:  579:                                 PatternRewriter &rewriter) const {
    2518*:  580:  if (!llvm::hasSingleElement(whileOp.getAfter()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  581:    return rewriter.notifyMatchFailure(whileOp,
        -:  582:                                       "do-while simplification applicable to "
    #####:  583:                                       "single-block 'after' region only");
call    0 never executed
        -:  584:
     2518:  585:  Block &afterBlock = whileOp.getAfter().front();
call    0 returned 100%
call    1 returned 100%
     2518:  586:  if (!llvm::hasSingleElement(afterBlock))
branch  0 taken 100%
branch  1 taken 0%
     2493:  587:    return rewriter.notifyMatchFailure(whileOp,
        -:  588:                                       "do-while simplification applicable "
     2493:  589:                                       "only if 'after' region has no payload");
call    0 returned 100%
        -:  590:
       25:  591:  auto yield = dyn_cast<scf::YieldOp>(&afterBlock.front());
call    0 returned 100%
call    1 returned 100%
       25:  592:  if (!yield || yield.getResults() != afterBlock.getArguments())
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 12% (fallthrough)
branch  5 taken 88%
       22:  593:    return rewriter.notifyMatchFailure(whileOp,
        -:  594:                                       "do-while simplification applicable "
       22:  595:                                       "only to forwarding 'after' regions");
call    0 returned 100%
        -:  596:
        -:  597:  // Split the current block before the WhileOp to create the inlining point.
        3:  598:  OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        3:  599:  Block *currentBlock = rewriter.getInsertionBlock();
        3:  600:  Block *continuation =
        3:  601:      rewriter.splitBlock(currentBlock, rewriter.getInsertionPoint());
call    0 returned 100%
        -:  602:
        -:  603:  // Only the "before" region should be inlined.
        3:  604:  Block *before = &whileOp.getBefore().front();
call    0 returned 100%
call    1 returned 100%
        3:  605:  Block *beforeLast = &whileOp.getBefore().back();
call    0 returned 100%
call    1 returned 100%
        3:  606:  rewriter.inlineRegionBefore(whileOp.getBefore(), continuation);
call    0 returned 100%
call    1 returned 100%
        -:  607:
        -:  608:  // Branch to the "before" region.
        3:  609:  rewriter.setInsertionPointToEnd(currentBlock);
call    0 returned 100%
        3:  610:  rewriter.create<cf::BranchOp>(whileOp.getLoc(), before, whileOp.getInits());
call    0 returned 100%
call    1 returned 100%
        -:  611:
        -:  612:  // Loop around the "before" region based on condition.
        3:  613:  rewriter.setInsertionPointToEnd(beforeLast);
call    0 returned 100%
        3:  614:  auto condOp = cast<ConditionOp>(beforeLast->getTerminator());
call    0 returned 100%
call    1 returned 100%
        3:  615:  rewriter.replaceOpWithNewOp<cf::CondBranchOp>(condOp, condOp.getCondition(),
call    0 returned 100%
        3:  616:                                                before, condOp.getArgs(),
call    0 returned 100%
        6:  617:                                                continuation, ValueRange());
call    0 returned 100%
call    1 returned 100%
        -:  618:
        -:  619:  // Replace the op with values "yielded" from the "before" region, which are
        -:  620:  // visible by dominance.
        3:  621:  rewriter.replaceOp(whileOp, condOp.getArgs());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  622:
        3:  623:  return success();
branch  0 taken 100%
branch  1 taken 0%
        -:  624:}
        -:  625:
        -:  626:LogicalResult
function _ZNK12_GLOBAL__N_119IndexSwitchLowering15matchAndRewriteEN4mlir3scf13IndexSwitchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  627:IndexSwitchLowering::matchAndRewrite(IndexSwitchOp op,
        -:  628:                                     PatternRewriter &rewriter) const {
        -:  629:  // Split the block at the op.
    #####:  630:  Block *condBlock = rewriter.getInsertionBlock();
call    0 never executed
    #####:  631:  Block *continueBlock = rewriter.splitBlock(condBlock, Block::iterator(op));
call    0 never executed
call    1 never executed
        -:  632:
        -:  633:  // Create the arguments on the continue block with which to replace the
        -:  634:  // results of the op.
    #####:  635:  SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
    #####:  636:  results.reserve(op.getNumResults());
branch  0 never executed
branch  1 never executed
    #####:  637:  for (Type resultType : op.getResultTypes())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  638:    results.push_back(continueBlock->addArgument(resultType, op.getLoc()));
call    0 never executed
call    1 never executed
        -:  639:
        -:  640:  // Handle the regions.
function _ZZNK12_GLOBAL__N_119IndexSwitchLowering15matchAndRewriteEN4mlir3scf13IndexSwitchOpERNS1_15PatternRewriterEENKUlRNS1_6RegionEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  641:  auto convertRegion = [&](Region &region) -> FailureOr<Block *> {
    #####:  642:    Block *block = &region.front();
call    0 never executed
        -:  643:
        -:  644:    // Convert the yield terminator to a branch to the continue block.
    #####:  645:    auto yield = cast<scf::YieldOp>(block->getTerminator());
call    0 never executed
call    1 never executed
    #####:  646:    rewriter.setInsertionPoint(yield);
call    0 never executed
    #####:  647:    rewriter.replaceOpWithNewOp<cf::BranchOp>(yield, continueBlock,
    #####:  648:                                              yield.getOperands());
call    0 never executed
call    1 never executed
        -:  649:
        -:  650:    // Inline the region.
    #####:  651:    rewriter.inlineRegionBefore(region, continueBlock);
call    0 never executed
    #####:  652:    return block;
    #####:  653:  };
        -:  654:
        -:  655:  // Convert the case regions.
    #####:  656:  SmallVector<Block *> caseSuccessors;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  657:  SmallVector<int32_t> caseValues;
branch  0 never executed
branch  1 never executed
    #####:  658:  caseSuccessors.reserve(op.getCases().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  659:  caseValues.reserve(op.getCases().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  660:  for (auto [region, value] : llvm::zip(op.getCaseRegions(), op.getCases())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  661:    FailureOr<Block *> block = convertRegion(region);
call    0 never executed
    #####:  662:    if (failed(block))
branch  0 never executed
branch  1 never executed
    #####:  663:      return failure();
    #####:  664:    caseSuccessors.push_back(*block);
call    0 never executed
    #####:  665:    caseValues.push_back(value);
call    0 never executed
        -:  666:  }
        -:  667:
        -:  668:  // Convert the default region.
    #####:  669:  FailureOr<Block *> defaultBlock = convertRegion(op.getDefaultRegion());
call    0 never executed
call    1 never executed
    #####:  670:  if (failed(defaultBlock))
branch  0 never executed
branch  1 never executed
    #####:  671:    return failure();
        -:  672:
        -:  673:  // Create the switch.
    #####:  674:  rewriter.setInsertionPointToEnd(condBlock);
call    0 never executed
    #####:  675:  SmallVector<ValueRange> caseOperands(caseSuccessors.size(), {});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  676:  rewriter.create<cf::SwitchOp>(
    #####:  677:      op.getLoc(), op.getArg(), *defaultBlock, ValueRange(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  678:      rewriter.getDenseI32ArrayAttr(caseValues), caseSuccessors, caseOperands);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  679:  rewriter.replaceOp(op, continueBlock->getArguments());
call    0 never executed
call    1 never executed
    #####:  680:  return success();
branch  0 never executed
branch  1 never executed
        -:  681:}
        -:  682:
function _ZN4mlir42populateSCFToControlFlowConversionPatternsERNS_17RewritePatternSetE called 845 returned 100% blocks executed 100%
      845:  683:void mlir::populateSCFToControlFlowConversionPatterns(
        -:  684:    RewritePatternSet &patterns) {
      845:  685:  patterns.add<ForLowering, IfLowering, ParallelLowering, WhileLowering,
        -:  686:               ExecuteRegionLowering, IndexSwitchLowering>(
      845:  687:      patterns.getContext());
call    0 returned 100%
      845:  688:  patterns.add<DoWhileLowering>(patterns.getContext(), /*benefit=*/2);
call    0 returned 100%
      845:  689:}
        -:  690:
function _ZN12_GLOBAL__N_120SCFToControlFlowPass14runOnOperationEv called 417 returned 100% blocks executed 89%
      417:  691:void SCFToControlFlowPass::runOnOperation() {
      417:  692:  RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      417:  693:  populateSCFToControlFlowConversionPatterns(patterns);
call    0 returned 100%
        -:  694:
        -:  695:  // Configure conversion to lower out SCF operations.
      834:  696:  ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      417:  697:  target.addIllegalOp<scf::ForOp, scf::IfOp, scf::ParallelOp, scf::WhileOp,
      417:  698:                      scf::ExecuteRegionOp>();
call    0 returned 100%
      417:  699:  target.markUnknownOpDynamicallyLegal([](Operation *) { return true; });
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      417:  700:  if (failed(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      417:  701:          applyPartialConversion(getOperation(), target, std::move(patterns))))
call    0 returned 100%
    #####:  702:    signalPassFailure();
call    0 never executed
      417:  703:}
        -:  704:
function _ZN4mlir24createConvertSCFToCFPassEv called 117100 returned 100% blocks executed 100%
   117100:  705:std::unique_ptr<Pass> mlir::createConvertSCFToCFPass() {
   117100:  706:  return std::make_unique<SCFToControlFlowPass>();
call    0 returned 100%
        -:  707:}
