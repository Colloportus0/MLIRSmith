        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/NVGPUToNVVM/NVGPUToNVVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/NVGPUToNVVM/CMakeFiles/obj.MLIRNVGPUToNVVM.dir/NVGPUToNVVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/NVGPUToNVVM/CMakeFiles/obj.MLIRNVGPUToNVVM.dir/NVGPUToNVVM.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- NVGPUToNVVM.cpp - NVGPU to NVVM dialect conversion -----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/NVGPUToNVVM/NVGPUToNVVM.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
        -:   12:#include "mlir/Conversion/LLVMCommon/Pattern.h"
        -:   13:#include "mlir/Dialect/GPU/IR/GPUDialect.h"
        -:   14:#include "mlir/Dialect/LLVMIR/NVVMDialect.h"
        -:   15:#include "mlir/Dialect/NVGPU/IR/NVGPUDialect.h"
        -:   16:#include "mlir/Pass/Pass.h"
        -:   17:
        -:   18:namespace mlir {
        -:   19:#define GEN_PASS_DEF_CONVERTNVGPUTONVVM
        -:   20:#include "mlir/Conversion/Passes.h.inc"
        -:   21:} // namespace mlir
        -:   22:
        -:   23:using namespace mlir;
        -:   24:
        -:   25:/// Returns the type for the intrinsic given the vectorResultType of the
        -:   26:/// `gpu.mma.sync` operation.
function _ZL24inferIntrinsicResultTypeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:   27:static Type inferIntrinsicResultType(Type vectorResultType) {
    #####:   28:  MLIRContext *ctx = vectorResultType.getContext();
call    0 never executed
    #####:   29:  auto a = vectorResultType.cast<LLVM::LLVMArrayType>();
call    0 never executed
    #####:   30:  auto f16x2Ty = LLVM::getFixedVectorType(Float16Type::get(ctx), 2);
call    0 never executed
call    1 never executed
    #####:   31:  auto i32Ty = IntegerType::get(ctx, 32);
call    0 never executed
    #####:   32:  auto i32x2Ty = LLVM::getFixedVectorType(i32Ty, 2);
call    0 never executed
    #####:   33:  Type f64Ty = Float64Type::get(ctx);
call    0 never executed
    #####:   34:  Type f64x2Ty = LLVM::getFixedVectorType(f64Ty, 2);
call    0 never executed
    #####:   35:  Type f32Ty = Float32Type::get(ctx);
call    0 never executed
    #####:   36:  Type f32x2Ty = LLVM::getFixedVectorType(f32Ty, 2);
call    0 never executed
    #####:   37:  if (a.getElementType() == f16x2Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   38:    return LLVM::LLVMStructType::getLiteral(
    #####:   39:        ctx, SmallVector<Type>(a.getNumElements(), f16x2Ty));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   40:  }
    #####:   41:  if (a.getElementType() == i32x2Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   42:    return LLVM::LLVMStructType::getLiteral(
        -:   43:        ctx,
    #####:   44:        SmallVector<Type>(static_cast<size_t>(a.getNumElements()) * 2, i32Ty));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   45:  }
    #####:   46:  if (a.getElementType() == f64x2Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   47:    return LLVM::LLVMStructType::getLiteral(ctx, {f64Ty, f64Ty});
call    0 never executed
        -:   48:  }
    #####:   49:  if (a.getElementType() == f32x2Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   50:    return LLVM::LLVMStructType::getLiteral(
        -:   51:        ctx,
    #####:   52:        SmallVector<Type>(static_cast<size_t>(a.getNumElements()) * 2, f32Ty));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   53:  }
    #####:   54:  if (a.getElementType() == LLVM::getFixedVectorType(f32Ty, 1)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   55:    return LLVM::LLVMStructType::getLiteral(
    #####:   56:        ctx, SmallVector<Type>(static_cast<size_t>(a.getNumElements()), f32Ty));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   57:  }
    #####:   58:  return vectorResultType;
        -:   59:}
        -:   60:
        -:   61:/// Convert the SSA result of the NVVM intrinsic `nvvm.mma.sync` (which is
        -:   62:/// always an LLVM struct) into a fragment that is compatible with the vector
        -:   63:/// type of this operation. This involves extracting elements from the struct
        -:   64:/// and inserting them into an LLVM array. These extra data-movement
        -:   65:/// operations should be canonicalized away by the LLVM backend.
function _ZL22convertIntrinsicResultN4mlir8LocationENS_4TypeES1_NS_5ValueERNS_12RewriterBaseE called 0 returned 0% blocks executed 0%
    #####:   66:static Value convertIntrinsicResult(Location loc, Type intrinsicResultType,
        -:   67:                                    Type resultType, Value intrinsicResult,
        -:   68:                                    RewriterBase &rewriter) {
    #####:   69:  MLIRContext *ctx = rewriter.getContext();
call    0 never executed
    #####:   70:  auto structType = intrinsicResultType.dyn_cast<LLVM::LLVMStructType>();
call    0 never executed
    #####:   71:  auto arrayType = resultType.dyn_cast<LLVM::LLVMArrayType>();
call    0 never executed
    #####:   72:  Type i32Ty = rewriter.getI32Type();
call    0 never executed
    #####:   73:  Type f32Ty = rewriter.getF32Type();
call    0 never executed
    #####:   74:  Type f64Ty = rewriter.getF64Type();
call    0 never executed
    #####:   75:  Type f16x2Ty = LLVM::getFixedVectorType(rewriter.getF16Type(), 2);
call    0 never executed
call    1 never executed
    #####:   76:  Type i32x2Ty = LLVM::getFixedVectorType(i32Ty, 2);
call    0 never executed
    #####:   77:  Type f64x2Ty = LLVM::getFixedVectorType(f64Ty, 2);
call    0 never executed
    #####:   78:  Type f32x2Ty = LLVM::getFixedVectorType(f32Ty, 2);
call    0 never executed
    #####:   79:  Type f32x1Ty = LLVM::getFixedVectorType(f32Ty, 1);
call    0 never executed
        -:   80:
function _ZZL22convertIntrinsicResultN4mlir8LocationENS_4TypeES1_NS_5ValueERNS_12RewriterBaseEENKUliE_clEi called 0 returned 0% blocks executed 0%
    #####:   81:  auto makeConst = [&](int32_t index) -> Value {
    #####:   82:    return rewriter.create<LLVM::ConstantOp>(loc, IntegerType::get(ctx, 32),
call    0 never executed
    #####:   83:                                             rewriter.getI32IntegerAttr(index));
call    0 never executed
call    1 never executed
    #####:   84:  };
        -:   85:
    #####:   86:  if (arrayType) {
branch  0 never executed
branch  1 never executed
    #####:   87:    SmallVector<Value, 4> elements;
call    0 never executed
        -:   88:
        -:   89:    // The intrinsic returns 32-bit wide elements in a form which can be
        -:   90:    // directly bitcasted and inserted into the result vector.
    #####:   91:    if (arrayType.getElementType() == f16x2Ty ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   92:        arrayType.getElementType() == f32x1Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   93:      for (unsigned i = 0; i < structType.getBody().size(); i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:        Value el =
    #####:   95:            rewriter.create<LLVM::ExtractValueOp>(loc, intrinsicResult, i);
call    0 never executed
call    1 never executed
    #####:   96:        el = rewriter.createOrFold<LLVM::BitcastOp>(
    #####:   97:            loc, arrayType.getElementType(), el);
call    0 never executed
call    1 never executed
    #####:   98:        elements.push_back(el);
call    0 never executed
        -:   99:      }
        -:  100:    }
        -:  101:
        -:  102:    // The intrinsic returns i32, f64, and f32 values as individual scalars,
        -:  103:    // even when the result is notionally a 64-bit wide element (e.g. f32x2). We
        -:  104:    // need to extract them from the struct and pack them into the 64-bit wide
        -:  105:    // rows of the vector result.
    #####:  106:    if (arrayType.getElementType() == i32x2Ty ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  107:        arrayType.getElementType() == f64x2Ty ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  108:        arrayType.getElementType() == f32x2Ty) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  109:
    #####:  110:      for (unsigned i = 0, e = structType.getBody().size() / 2; i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  111:        Value vec =
    #####:  112:            rewriter.create<LLVM::UndefOp>(loc, arrayType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  113:        Value x1 =
    #####:  114:            rewriter.create<LLVM::ExtractValueOp>(loc, intrinsicResult, i * 2);
call    0 never executed
call    1 never executed
    #####:  115:        Value x2 = rewriter.create<LLVM::ExtractValueOp>(loc, intrinsicResult,
    #####:  116:                                                         i * 2 + 1);
call    0 never executed
call    1 never executed
    #####:  117:        vec = rewriter.create<LLVM::InsertElementOp>(loc, vec.getType(), vec,
call    0 never executed
    #####:  118:                                                     x1, makeConst(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  119:        vec = rewriter.create<LLVM::InsertElementOp>(loc, vec.getType(), vec,
call    0 never executed
    #####:  120:                                                     x2, makeConst(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  121:        elements.push_back(vec);
call    0 never executed
        -:  122:      }
        -:  123:    }
        -:  124:
        -:  125:    // Create the final vectorized result.
    #####:  126:    Value result = rewriter.create<LLVM::UndefOp>(loc, arrayType);
call    0 never executed
    #####:  127:    for (const auto &el : llvm::enumerate(elements)) {
branch  0 never executed
branch  1 never executed
    #####:  128:      result = rewriter.create<LLVM::InsertValueOp>(loc, result, el.value(),
call    0 never executed
    #####:  129:                                                    el.index());
call    0 never executed
call    1 never executed
        -:  130:    }
    #####:  131:    return result;
branch  0 never executed
branch  1 never executed
        -:  132:  }
        -:  133:
    #####:  134:  return intrinsicResult;
        -:  135:}
        -:  136:
        -:  137:/// The `gpu.mma.sync` converter below expects matrix fragment operands to be
        -:  138:/// given as 2D `vectors` where the rows are 32b or 64b wide. The
        -:  139:/// `nvvm.mma.sync` op expects these argments to be a given in a long list of
        -:  140:/// scalars of certain types. This function helps unpack the `vector` arguments
        -:  141:/// and cast them to the types expected by `nvvm.mma.sync`.
function _ZL19unpackOperandVectorRN4mlir12RewriterBaseENS_8LocationENS_5ValueENS_4NVVM8MMATypesE called 0 returned 0% blocks executed 0%
    #####:  142:static SmallVector<Value> unpackOperandVector(RewriterBase &rewriter,
        -:  143:                                              Location loc, Value operand,
        -:  144:                                              NVVM::MMATypes operandPtxType) {
    #####:  145:  SmallVector<Value> result;
call    0 never executed
    #####:  146:  Type i32Ty = rewriter.getI32Type();
call    0 never executed
    #####:  147:  Type f64Ty = rewriter.getF64Type();
call    0 never executed
    #####:  148:  Type f32Ty = rewriter.getF32Type();
call    0 never executed
    #####:  149:  Type i8Ty = rewriter.getI8Type();
call    0 never executed
    #####:  150:  Type i4Ty = rewriter.getIntegerType(4);
call    0 never executed
    #####:  151:  Type i8x4Ty = LLVM::getFixedVectorType(i8Ty, 4);
call    0 never executed
    #####:  152:  Type i4x8Ty = LLVM::getFixedVectorType(i4Ty, 8);
call    0 never executed
    #####:  153:  Type f32x1Ty = LLVM::getFixedVectorType(f32Ty, 1);
call    0 never executed
    #####:  154:  auto arrayTy = operand.getType().cast<LLVM::LLVMArrayType>();
call    0 never executed
        -:  155:
    #####:  156:  for (unsigned i = 0, e = arrayTy.getNumElements(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  157:    Value toUse = rewriter.create<LLVM::ExtractValueOp>(loc, operand, i);
call    0 never executed
call    1 never executed
        -:  158:
        -:  159:    // For 4xi8 vectors, the intrinsic expects these to be provided as i32
        -:  160:    // scalar types.
    #####:  161:    if (arrayTy.getElementType() == i8x4Ty ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  162:        arrayTy.getElementType() == i4x8Ty ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  163:        (arrayTy.getElementType() == f32x1Ty &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  164:         operandPtxType == NVVM::MMATypes::tf32)) {
    #####:  165:      result.push_back(
call    0 never executed
    #####:  166:          rewriter.create<LLVM::BitcastOp>(loc, rewriter.getI32Type(), toUse));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  167:      continue;
        -:  168:    }
        -:  169:
        -:  170:    // For some element types (i32, f32, f64), we need to unpack the inner
        -:  171:    // vector/array type as well because the intrinsic expects individual
        -:  172:    // scalars to be provided.
    #####:  173:    VectorType innerArrayTy = arrayTy.getElementType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####:  174:    if (innerArrayTy && (innerArrayTy.getElementType() == i32Ty ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  175:                         innerArrayTy.getElementType() == f64Ty ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  176:                         innerArrayTy.getElementType() == f32Ty)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  177:      for (unsigned idx = 0, innerSize = innerArrayTy.getNumElements();
call    0 never executed
    #####:  178:           idx < innerSize; idx++) {
branch  0 never executed
branch  1 never executed
    #####:  179:        result.push_back(rewriter.create<LLVM::ExtractElementOp>(
call    0 never executed
        -:  180:            loc, toUse,
    #####:  181:            rewriter.create<LLVM::ConstantOp>(
    #####:  182:                loc, rewriter.getI64Type(), rewriter.getI64IntegerAttr(idx))));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  183:      }
    #####:  184:      continue;
        -:  185:    }
    #####:  186:    result.push_back(toUse);
call    0 never executed
        -:  187:  }
    #####:  188:  return result;
        -:  189:}
        -:  190:
        -:  191:namespace {
        -:  192:
        -:  193:struct MmaLdMatrixOpToNVVM : public ConvertOpToLLVMPattern<nvgpu::LdMatrixOp> {
      403:  194:  using ConvertOpToLLVMPattern<nvgpu::LdMatrixOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  195:
        -:  196:  LogicalResult
function _ZNK12_GLOBAL__N_119MmaLdMatrixOpToNVVM15matchAndRewriteEN4mlir5nvgpu10LdMatrixOpENS2_17LdMatrixOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  197:  matchAndRewrite(nvgpu::LdMatrixOp op, OpAdaptor adaptor,
        -:  198:                  ConversionPatternRewriter &rewriter) const override {
    #####:  199:    MLIRContext *ctx = getContext();
branch  0 never executed
branch  1 never executed
    #####:  200:    Location loc = op->getLoc();
branch  0 never executed
branch  1 never executed
        -:  201:
        -:  202:    // The result type of ldmatrix will always be a struct of 32bit integer
        -:  203:    // registers if more than one 32bit value is returned. Otherwise, the result
        -:  204:    // is a single i32. The result type of the GPU operation is always a vector
        -:  205:    // of shape (NumRegisters, VectorRegister) where VectorRegister is the
        -:  206:    // vector type of the result and always 32 bits long. We bitcast the result
        -:  207:    // of the NVVM::LdMatrix to this vector type.
    #####:  208:    auto vectorResultType = op->getResultTypes()[0].dyn_cast<VectorType>();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  209:    if (!vectorResultType) {
branch  0 never executed
branch  1 never executed
    #####:  210:      return failure();
        -:  211:    }
    #####:  212:    Type innerVectorType = LLVM::getFixedVectorType(
    #####:  213:        vectorResultType.getElementType(), vectorResultType.getDimSize(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  214:
    #####:  215:    int64_t num32BitRegs = vectorResultType.getDimSize(0);
call    0 never executed
        -:  216:
    #####:  217:    Type ldMatrixResultType;
    #####:  218:    if (num32BitRegs > 1) {
branch  0 never executed
branch  1 never executed
    #####:  219:      ldMatrixResultType = LLVM::LLVMStructType::getLiteral(
    #####:  220:          ctx, SmallVector<Type>(num32BitRegs, rewriter.getI32Type()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  221:    } else {
    #####:  222:      ldMatrixResultType = rewriter.getI32Type();
call    0 never executed
        -:  223:    }
        -:  224:
    #####:  225:    auto srcMemrefType = op.getSrcMemref().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  226:    Value srcPtr =
        -:  227:        getStridedElementPtr(loc, srcMemrefType, adaptor.getSrcMemref(),
    #####:  228:                             adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  229:    Value ldMatrixResult = rewriter.create<NVVM::LdMatrixOp>(
        -:  230:        loc, ldMatrixResultType, srcPtr,
    #####:  231:        /*num=*/op.getNumTiles(),
    #####:  232:        /*layout=*/op.getTranspose() ? NVVM::MMALayout::col
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  233:                                     : NVVM::MMALayout::row);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  234:
        -:  235:    // The ldmatrix operation returns either a single i32 value or a struct of
        -:  236:    // i32 values. Here we unpack those values and cast them back to their
        -:  237:    // actual vector type (still of width 32b) and repack them into a result
        -:  238:    // struct.
    #####:  239:    Type finalResultType = typeConverter->convertType(vectorResultType);
call    0 never executed
    #####:  240:    Value result = rewriter.create<LLVM::UndefOp>(loc, finalResultType);
call    0 never executed
call    1 never executed
    #####:  241:    for (int64_t i = 0, e = vectorResultType.getDimSize(0); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  242:      Value i32Register =
        -:  243:          num32BitRegs > 1
    #####:  244:              ? rewriter.create<LLVM::ExtractValueOp>(loc, ldMatrixResult, i)
call    0 never executed
    #####:  245:              : ldMatrixResult;
branch  0 never executed
branch  1 never executed
    #####:  246:      Value casted =
    #####:  247:          rewriter.create<LLVM::BitcastOp>(loc, innerVectorType, i32Register);
call    0 never executed
call    1 never executed
    #####:  248:      result = rewriter.create<LLVM::InsertValueOp>(loc, result, casted, i);
call    0 never executed
        -:  249:    }
        -:  250:
    #####:  251:    rewriter.replaceOp(op, result);
call    0 never executed
call    1 never executed
    #####:  252:    return success();
        -:  253:  }
        -:  254:};
        -:  255:
        -:  256:struct MmaSyncOptoNVVM : public ConvertOpToLLVMPattern<nvgpu::MmaSyncOp> {
      403:  257:  using ConvertOpToLLVMPattern<nvgpu::MmaSyncOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  258:
        -:  259:  LogicalResult
function _ZNK12_GLOBAL__N_115MmaSyncOptoNVVM15matchAndRewriteEN4mlir5nvgpu9MmaSyncOpENS2_16MmaSyncOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  260:  matchAndRewrite(nvgpu::MmaSyncOp op, OpAdaptor adaptor,
        -:  261:                  ConversionPatternRewriter &rewriter) const override {
    #####:  262:    Location loc = op->getLoc();
call    0 never executed
        -:  263:    // Get the shapes of the MMAMatrix type being used. The shapes will
        -:  264:    // choose which intrinsic this op will be lowered to.
    #####:  265:    auto aType = op.getMatrixA().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  266:    auto cType = op.getMatrixC().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  267:
    #####:  268:    int64_t m = op.getMmaShape()[0].cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  269:    int64_t n = op.getMmaShape()[1].cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  270:    int64_t k = op.getMmaShape()[2].cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  271:    std::array<int64_t, 3> gemmShape{m, n, k};
        -:  272:
    #####:  273:    NVVM::MMATypes ptxTypeA;
    #####:  274:    NVVM::MMATypes ptxTypeB;
    #####:  275:    Optional<NVVM::MMATypes> ptxTypeC = NVVM::MmaOp::inferOperandMMAType(
    #####:  276:        cType.getElementType(), /*isAccumulator=*/true);
call    0 never executed
call    1 never executed
    #####:  277:    if (!ptxTypeC)
branch  0 never executed
branch  1 never executed
    #####:  278:      return op->emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  279:          "could not infer the PTX type for the accumulator/result");
call    0 never executed
        -:  280:
        -:  281:    // Tensor Cores (mma.sync) on F32 works only with TensorFloat32 (TF32).
    #####:  282:    bool tf32Enabled = op->hasAttr(op.getTf32EnabledAttrName());
call    0 never executed
call    1 never executed
    #####:  283:    if (aType.getElementType().isF32() && !tf32Enabled)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  284:      return failure();
        -:  285:
    #####:  286:    Optional<NVVM::MMAIntOverflow> overflow(llvm::None);
    #####:  287:    if (aType.getElementType().isInteger(8)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  288:      ptxTypeA = NVVM::MMATypes::s8;
    #####:  289:      ptxTypeB = NVVM::MMATypes::s8;
    #####:  290:      overflow = NVVM::MMAIntOverflow::satfinite;
branch  0 never executed
branch  1 never executed
    #####:  291:    } else if (aType.getElementType().isInteger(4)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  292:      ptxTypeA = NVVM::MMATypes::s4;
    #####:  293:      ptxTypeB = NVVM::MMATypes::s4;
    #####:  294:      overflow = NVVM::MMAIntOverflow::satfinite;
branch  0 never executed
branch  1 never executed
    #####:  295:    } else if (aType.getElementType().isF16()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  296:      ptxTypeA = NVVM::MMATypes::f16;
        -:  297:      ptxTypeB = NVVM::MMATypes::f16;
    #####:  298:    } else if (aType.getElementType().isF64()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  299:      ptxTypeA = NVVM::MMATypes::f64;
        -:  300:      ptxTypeB = NVVM::MMATypes::f64;
    #####:  301:    } else if (aType.getElementType().isF32()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  302:      ptxTypeA = NVVM::MMATypes::tf32;
        -:  303:      ptxTypeB = NVVM::MMATypes::tf32;
        -:  304:    } else {
    #####:  305:      return op->emitError("could not deduce operand PTX types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  306:    }
        -:  307:
    #####:  308:    SmallVector<Value> matA =
    #####:  309:        unpackOperandVector(rewriter, loc, adaptor.getMatrixA(), ptxTypeA);
call    0 never executed
call    1 never executed
    #####:  310:    SmallVector<Value> matB =
    #####:  311:        unpackOperandVector(rewriter, loc, adaptor.getMatrixB(), ptxTypeB);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  312:    SmallVector<Value> matC =
call    0 never executed
    #####:  313:        unpackOperandVector(rewriter, loc, adaptor.getMatrixC(), *ptxTypeC);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  314:
    #####:  315:    Type desiredRetTy = typeConverter->convertType(op->getResultTypes()[0]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  316:    Type intrinsicResTy = inferIntrinsicResultType(
    #####:  317:        typeConverter->convertType(op->getResultTypes()[0]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  318:    Value intrinsicResult = rewriter.create<NVVM::MmaOp>(
        -:  319:        op.getLoc(), intrinsicResTy, matA, matB, matC,
        -:  320:        /*shape=*/gemmShape,
        -:  321:        /*b1Op=*/llvm::None,
        -:  322:        /*intOverflow=*/overflow,
        -:  323:        /*multiplicandPtxTypes=*/
    #####:  324:        std::array<NVVM::MMATypes, 2>{ptxTypeA, ptxTypeB},
        -:  325:        /*multiplicandLayouts=*/
    #####:  326:        std::array<NVVM::MMALayout, 2>{NVVM::MMALayout::row,
    #####:  327:                                       NVVM::MMALayout::col});
call    0 never executed
call    1 never executed
    #####:  328:    rewriter.replaceOp(op, convertIntrinsicResult(op.getLoc(), intrinsicResTy,
call    0 never executed
        -:  329:                                                  desiredRetTy, intrinsicResult,
    #####:  330:                                                  rewriter));
call    0 never executed
call    1 never executed
    #####:  331:    return success();
branch  0 never executed
branch  1 never executed
        -:  332:  }
        -:  333:};
        -:  334:
    #####:  335:struct ConvertNVGPUToNVVMPass
call    0 never executed
        -:  336:    : public impl::ConvertNVGPUToNVVMBase<ConvertNVGPUToNVVMPass> {
   116716:  337:  ConvertNVGPUToNVVMPass() = default;
call    0 returned 100%
        -:  338:
function _ZN12_GLOBAL__N_122ConvertNVGPUToNVVMPass14runOnOperationEv called 403 returned 100% blocks executed 91%
      403:  339:  void runOnOperation() override {
      403:  340:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      806:  341:    LLVMTypeConverter converter(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  342:    /// device-side async tokens cannot be materialized in nvvm. We just convert
        -:  343:    /// them to a dummy i32 type in order to easily drop them during conversion.
function _ZZN12_GLOBAL__N_122ConvertNVGPUToNVVMPass14runOnOperationEvENKUlN4mlir5nvgpu20DeviceAsyncTokenTypeEE_clES3_.isra.0 called 0 returned 0% blocks executed 0%
     403*:  344:    converter.addConversion([&](nvgpu::DeviceAsyncTokenType type) -> Type {
call    0 returned 100%
    #####:  345:      return converter.convertType(IntegerType::get(type.getContext(), 32));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  346:    });
      806:  347:    populateNVGPUToNVVMConversionPatterns(converter, patterns);
      806:  348:    LLVMConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      403:  349:    target.addLegalDialect<::mlir::LLVM::LLVMDialect>();
call    0 returned 100%
      403:  350:    target.addLegalDialect<::mlir::NVVM::NVVMDialect>();
call    0 returned 100%
      403:  351:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      403:  352:                                      std::move(patterns))))
call    0 returned 100%
    #####:  353:      signalPassFailure();
call    0 never executed
      403:  354:  }
        -:  355:};
        -:  356:
function _ZN12_GLOBAL__N_1L21emitCpAsyncOpZfillAsmEN4mlir8LocationENS0_5ValueES2_S2_S2_NS0_10MemRefTypeERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  357:static void emitCpAsyncOpZfillAsm(Location loc, Value dstPtr, Value srcPtr,
        -:  358:                                  Value dstBytes, Value srcElements,
        -:  359:                                  mlir::MemRefType elementType,
        -:  360:                                  ConversionPatternRewriter &rewriter) {
    #####:  361:  auto asmDialectAttr = LLVM::AsmDialectAttr::get(rewriter.getContext(),
    #####:  362:                                                  LLVM::AsmDialect::AD_ATT);
call    0 never executed
    #####:  363:  const char *asmStr = "cp.async.cg.shared.global [$0], [$1], $2, $3;\n";
    #####:  364:  const char *asmConstraints = "r,l,n,r";
        -:  365:
    #####:  366:  Value c3I32 = rewriter.create<LLVM::ConstantOp>(
    #####:  367:      loc, rewriter.getI32Type(), rewriter.getI32IntegerAttr(3));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  368:  Value bitwidth = rewriter.create<LLVM::ConstantOp>(
    #####:  369:      loc, rewriter.getI32Type(),
call    0 never executed
    #####:  370:      rewriter.getI32IntegerAttr(elementType.getElementTypeBitWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  371:  Value srcElementsI32 =
    #####:  372:      rewriter.create<LLVM::TruncOp>(loc, rewriter.getI32Type(), srcElements);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  373:  Value srcBytes = rewriter.create<LLVM::LShrOp>(
    #####:  374:      loc, rewriter.create<LLVM::MulOp>(loc, bitwidth, srcElementsI32), c3I32);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  375:
    #####:  376:  SmallVector<Value> asmVals{dstPtr, srcPtr, dstBytes, srcBytes};
call    0 never executed
        -:  377:
    #####:  378:  rewriter.create<LLVM::InlineAsmOp>(
    #####:  379:      loc, LLVM::LLVMVoidType::get(rewriter.getContext()), /*operands=*/asmVals,
        -:  380:      /*asm_string=*/asmStr,
    #####:  381:      /*constraints=*/asmConstraints, /*has_side_effects=*/true,
    #####:  382:      /*is_align_stack=*/false, /*asm_dialect=*/asmDialectAttr,
call    0 never executed
    #####:  383:      /*operand_attrs=*/ArrayAttr());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  384:}
        -:  385:
        -:  386:struct NVGPUAsyncCopyLowering
        -:  387:    : public ConvertOpToLLVMPattern<nvgpu::DeviceAsyncCopyOp> {
        -:  388:  using ConvertOpToLLVMPattern<
      403:  389:      nvgpu::DeviceAsyncCopyOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  390:
        -:  391:  LogicalResult
function _ZNK12_GLOBAL__N_122NVGPUAsyncCopyLowering15matchAndRewriteEN4mlir5nvgpu17DeviceAsyncCopyOpENS2_24DeviceAsyncCopyOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  392:  matchAndRewrite(nvgpu::DeviceAsyncCopyOp op, OpAdaptor adaptor,
        -:  393:                  ConversionPatternRewriter &rewriter) const override {
    #####:  394:    Location loc = op->getLoc();
call    0 never executed
    #####:  395:    auto dstMemrefType = op.getDst().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  396:    Value dstPtr = getStridedElementPtr(loc, dstMemrefType, adaptor.getDst(),
    #####:  397:                                        adaptor.getDstIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  398:    auto i8Ty = IntegerType::get(op.getContext(), 8);
call    0 never executed
call    1 never executed
    #####:  399:    auto dstPointerType =
    #####:  400:        LLVM::LLVMPointerType::get(i8Ty, dstMemrefType.getMemorySpaceAsInt());
call    0 never executed
call    1 never executed
    #####:  401:    dstPtr = rewriter.create<LLVM::BitcastOp>(loc, dstPointerType, dstPtr);
call    0 never executed
call    1 never executed
        -:  402:
    #####:  403:    auto srcMemrefType = op.getSrc().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  404:
    #####:  405:    Value scrPtr = getStridedElementPtr(loc, srcMemrefType, adaptor.getSrc(),
    #####:  406:                                        adaptor.getSrcIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  407:    auto srcPointerType =
    #####:  408:        LLVM::LLVMPointerType::get(i8Ty, srcMemrefType.getMemorySpaceAsInt());
call    0 never executed
call    1 never executed
    #####:  409:    scrPtr = rewriter.create<LLVM::BitcastOp>(loc, srcPointerType, scrPtr);
call    0 never executed
call    1 never executed
        -:  410:    // Intrinsics takes a global pointer so we need an address space cast.
    #####:  411:    auto srcPointerGlobalType = LLVM::LLVMPointerType::get(
    #####:  412:        i8Ty, NVVM::NVVMMemorySpace::kGlobalMemorySpace);
call    0 never executed
    #####:  413:    scrPtr = rewriter.create<LLVM::AddrSpaceCastOp>(loc, srcPointerGlobalType,
    #####:  414:                                                    scrPtr);
call    0 never executed
call    1 never executed
    #####:  415:    int64_t dstElements = adaptor.getDstElements().getZExtValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  416:    int64_t sizeInBytes =
call    0 never executed
    #####:  417:        (dstMemrefType.getElementTypeBitWidth() * dstElements) / 8;
        -:  418:    // bypass L1 is only supported for byte sizes of 16, we drop the hint
        -:  419:    // otherwise.
    #####:  420:    UnitAttr bypassL1 =
    #####:  421:        sizeInBytes == 16 ? adaptor.getBypassL1Attr() : UnitAttr();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  422:
        -:  423:    // When the optional SrcElements argument is present, the source (global
        -:  424:    // memory) of CpAsyncOp is read only for SrcElements number of elements. The
        -:  425:    // rest of the DstElements in the destination (shared memory) are filled
        -:  426:    // with zeros.
    #####:  427:    if (op.getSrcElements())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  428:      emitCpAsyncOpZfillAsm(loc, dstPtr, scrPtr,
call    0 never executed
call    1 never executed
    #####:  429:                            rewriter.create<LLVM::ConstantOp>(
    #####:  430:                                loc, rewriter.getI32Type(),
call    0 never executed
    #####:  431:                                rewriter.getI32IntegerAttr(sizeInBytes)),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  432:                            adaptor.getSrcElements(), srcMemrefType, rewriter);
        -:  433:
        -:  434:    // When the optional SrcElements argument is *not* present, the regular
        -:  435:    // CpAsyncOp is generated. CopyAsyncOp reads bytes from source (global
        -:  436:    // memory) to fill DstElements number of elements in the destination (shared
        -:  437:    // memory).
        -:  438:    else
    #####:  439:      rewriter.create<NVVM::CpAsyncOp>(loc, dstPtr, scrPtr,
    #####:  440:                                       rewriter.getI32IntegerAttr(sizeInBytes),
call    0 never executed
    #####:  441:                                       bypassL1);
call    0 never executed
        -:  442:
        -:  443:    // Drop the result token.
    #####:  444:    Value zero = rewriter.create<LLVM::ConstantOp>(
    #####:  445:        op->getLoc(), IntegerType::get(op.getContext(), 32),
call    0 never executed
    #####:  446:        rewriter.getI32IntegerAttr(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  447:    rewriter.replaceOp(op, zero);
call    0 never executed
call    1 never executed
    #####:  448:    return success();
        -:  449:  }
        -:  450:};
        -:  451:
        -:  452:struct NVGPUAsyncCreateGroupLowering
        -:  453:    : public ConvertOpToLLVMPattern<nvgpu::DeviceAsyncCreateGroupOp> {
        -:  454:  using ConvertOpToLLVMPattern<
      403:  455:      nvgpu::DeviceAsyncCreateGroupOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  456:
        -:  457:  LogicalResult
function _ZNK12_GLOBAL__N_129NVGPUAsyncCreateGroupLowering15matchAndRewriteEN4mlir5nvgpu24DeviceAsyncCreateGroupOpENS2_31DeviceAsyncCreateGroupOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  458:  matchAndRewrite(nvgpu::DeviceAsyncCreateGroupOp op, OpAdaptor adaptor,
        -:  459:                  ConversionPatternRewriter &rewriter) const override {
    #####:  460:    rewriter.create<NVVM::CpAsyncCommitGroupOp>(op.getLoc());
call    0 never executed
        -:  461:    // Drop the result token.
    #####:  462:    Value zero = rewriter.create<LLVM::ConstantOp>(
    #####:  463:        op->getLoc(), IntegerType::get(op.getContext(), 32),
call    0 never executed
    #####:  464:        rewriter.getI32IntegerAttr(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  465:    rewriter.replaceOp(op, zero);
call    0 never executed
call    1 never executed
    #####:  466:    return success();
        -:  467:  }
        -:  468:};
        -:  469:
        -:  470:struct NVGPUAsyncWaitLowering
        -:  471:    : public ConvertOpToLLVMPattern<nvgpu::DeviceAsyncWaitOp> {
        -:  472:  using ConvertOpToLLVMPattern<
      403:  473:      nvgpu::DeviceAsyncWaitOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  474:
        -:  475:  LogicalResult
function _ZNK12_GLOBAL__N_122NVGPUAsyncWaitLowering15matchAndRewriteEN4mlir5nvgpu17DeviceAsyncWaitOpENS2_24DeviceAsyncWaitOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  476:  matchAndRewrite(nvgpu::DeviceAsyncWaitOp op, OpAdaptor adaptor,
        -:  477:                  ConversionPatternRewriter &rewriter) const override {
        -:  478:    // If numGroup is not present pick 0 as a conservative correct value.
    #####:  479:    int32_t numGroups = adaptor.getNumGroups().value_or(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  480:    rewriter.create<NVVM::CpAsyncWaitGroupOp>(op.getLoc(), numGroups);
call    0 never executed
    #####:  481:    rewriter.eraseOp(op);
call    0 never executed
    #####:  482:    return success();
        -:  483:  }
        -:  484:};
        -:  485:
        -:  486:} // namespace
        -:  487:
function _ZN4mlir37populateNVGPUToNVVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 0 returned 0% blocks executed 0%
     403*:  488:void mlir::populateNVGPUToNVVMConversionPatterns(LLVMTypeConverter &converter,
        -:  489:                                                 RewritePatternSet &patterns) {
     403*:  490:  patterns.add<MmaSyncOptoNVVM, MmaLdMatrixOpToNVVM, NVGPUAsyncCopyLowering,
        -:  491:               NVGPUAsyncCreateGroupLowering, NVGPUAsyncWaitLowering>(
     403*:  492:      converter);
call    0 never executed
call    1 returned 100%
    #####:  493:}
        -:  494:
function _ZN4mlir28createConvertNVGPUToNVVMPassEv called 116716 returned 100% blocks executed 100%
   116716:  495:std::unique_ptr<Pass> mlir::createConvertNVGPUToNVVMPass() {
   116716:  496:  return std::make_unique<ConvertNVGPUToNVVMPass>();
call    0 returned 100%
        -:  497:}
