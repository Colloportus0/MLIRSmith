        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Analysis/Presburger/Fraction.h
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcda
        -:    0:Runs:116175
        -:    1://===- Fraction.h - MLIR Fraction Class -------------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This is a simple class to represent fractions. It supports multiplication,
        -:   10:// comparison, floor, and ceiling operations.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef MLIR_ANALYSIS_PRESBURGER_FRACTION_H
        -:   15:#define MLIR_ANALYSIS_PRESBURGER_FRACTION_H
        -:   16:
        -:   17:#include "mlir/Analysis/Presburger/MPInt.h"
        -:   18:#include "mlir/Support/MathExtras.h"
        -:   19:
        -:   20:namespace mlir {
        -:   21:namespace presburger {
        -:   22:
        -:   23:/// A class to represent fractions. The sign of the fraction is represented
        -:   24:/// in the sign of the numerator; the denominator is always positive.
        -:   25:///
        -:   26:/// Note that overflows may occur if the numerator or denominator are not
        -:   27:/// representable by 64-bit integers.
        -:   28:struct Fraction {
        -:   29:  /// Default constructor initializes the represented rational number to zero.
    #####:   30:  Fraction() = default;
        -:   31:
        -:   32:  /// Construct a Fraction from a numerator and denominator.
        -:   33:  Fraction(const MPInt &oNum, const MPInt &oDen) : num(oNum), den(oDen) {
        -:   34:    if (den < 0) {
        -:   35:      num = -num;
        -:   36:      den = -den;
        -:   37:    }
        -:   38:  }
        -:   39:  /// Overloads for passing literals.
        -:   40:  Fraction(const MPInt &num, int64_t den) : Fraction(num, MPInt(den)) {}
        -:   41:  Fraction(int64_t num, const MPInt &den) : Fraction(MPInt(num), den) {}
        -:   42:  Fraction(int64_t num, int64_t den) : Fraction(MPInt(num), MPInt(den)) {}
        -:   43:
        -:   44:  // Return the value of the fraction as an integer. This should only be called
        -:   45:  // when the fraction's value is really an integer.
        -:   46:  MPInt getAsInteger() const {
        -:   47:    assert(num % den == 0 && "Get as integer called on non-integral fraction!");
        -:   48:    return num / den;
        -:   49:  }
        -:   50:
        -:   51:  /// The numerator and denominator, respectively. The denominator is always
        -:   52:  /// positive.
        -:   53:  MPInt num{0}, den{1};
        -:   54:};
        -:   55:
        -:   56:/// Three-way comparison between two fractions.
        -:   57:/// Returns +1, 0, and -1 if the first fraction is greater than, equal to, or
        -:   58:/// less than the second fraction, respectively.
        -:   59:inline int compare(const Fraction &x, const Fraction &y) {
        -:   60:  MPInt diff = x.num * y.den - y.num * x.den;
        -:   61:  if (diff > 0)
        -:   62:    return +1;
        -:   63:  if (diff < 0)
        -:   64:    return -1;
        -:   65:  return 0;
        -:   66:}
        -:   67:
        -:   68:inline MPInt floor(const Fraction &f) { return floorDiv(f.num, f.den); }
        -:   69:
function _ZN4mlir10presburger4ceilERKNS0_8FractionE called 0 returned 0% blocks executed 0%
    #####:   70:inline MPInt ceil(const Fraction &f) { return ceilDiv(f.num, f.den); }
branch  0 never executed
branch  1 never executed
        -:   71:
        -:   72:inline Fraction operator-(const Fraction &x) { return Fraction(-x.num, x.den); }
        -:   73:
        -:   74:inline bool operator<(const Fraction &x, const Fraction &y) {
        -:   75:  return compare(x, y) < 0;
        -:   76:}
        -:   77:
        -:   78:inline bool operator<=(const Fraction &x, const Fraction &y) {
        -:   79:  return compare(x, y) <= 0;
        -:   80:}
        -:   81:
        -:   82:inline bool operator==(const Fraction &x, const Fraction &y) {
        -:   83:  return compare(x, y) == 0;
        -:   84:}
        -:   85:
        -:   86:inline bool operator!=(const Fraction &x, const Fraction &y) {
        -:   87:  return compare(x, y) != 0;
        -:   88:}
        -:   89:
        -:   90:inline bool operator>(const Fraction &x, const Fraction &y) {
        -:   91:  return compare(x, y) > 0;
        -:   92:}
        -:   93:
        -:   94:inline bool operator>=(const Fraction &x, const Fraction &y) {
        -:   95:  return compare(x, y) >= 0;
        -:   96:}
        -:   97:
        -:   98:inline Fraction operator*(const Fraction &x, const Fraction &y) {
        -:   99:  return Fraction(x.num * y.num, x.den * y.den);
        -:  100:}
        -:  101:
        -:  102:} // namespace presburger
        -:  103:} // namespace mlir
        -:  104:
        -:  105:#endif // MLIR_ANALYSIS_PRESBURGER_FRACTION_H
