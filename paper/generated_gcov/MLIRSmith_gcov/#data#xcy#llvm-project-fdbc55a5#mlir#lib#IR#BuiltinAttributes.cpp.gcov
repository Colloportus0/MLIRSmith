        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/BuiltinAttributes.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/BuiltinAttributes.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/BuiltinAttributes.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- BuiltinAttributes.cpp - MLIR Builtin Attribute Classes -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/BuiltinAttributes.h"
        -:   10:#include "AttributeDetail.h"
        -:   11:#include "mlir/IR/AffineMap.h"
        -:   12:#include "mlir/IR/BuiltinDialect.h"
        -:   13:#include "mlir/IR/Dialect.h"
        -:   14:#include "mlir/IR/DialectResourceBlobManager.h"
        -:   15:#include "mlir/IR/IntegerSet.h"
        -:   16:#include "mlir/IR/OpImplementation.h"
        -:   17:#include "mlir/IR/Operation.h"
        -:   18:#include "mlir/IR/SymbolTable.h"
        -:   19:#include "mlir/IR/Types.h"
        -:   20:#include "llvm/ADT/APSInt.h"
        -:   21:#include "llvm/ADT/Sequence.h"
        -:   22:#include "llvm/ADT/TypeSwitch.h"
        -:   23:#include "llvm/Support/Endian.h"
        -:   24:
        -:   25:using namespace mlir;
        -:   26:using namespace mlir::detail;
        -:   27:
        -:   28://===----------------------------------------------------------------------===//
        -:   29:/// Tablegen Attribute Definitions
        -:   30://===----------------------------------------------------------------------===//
        -:   31:
        -:   32:#define GET_ATTRDEF_CLASSES
        -:   33:#include "mlir/IR/BuiltinAttributes.cpp.inc"
        -:   34:
        -:   35://===----------------------------------------------------------------------===//
        -:   36:// BuiltinDialect
        -:   37://===----------------------------------------------------------------------===//
        -:   38:
function _ZN4mlir14BuiltinDialect18registerAttributesEv called 189144 returned 100% blocks executed 100%
   189144:   39:void BuiltinDialect::registerAttributes() {
   189144:   40:  addAttributes<
        -:   41:#define GET_ATTRDEF_LIST
        -:   42:#include "mlir/IR/BuiltinAttributes.cpp.inc"
   189144:   43:      >();
call    0 returned 100%
   189144:   44:}
        -:   45:
        -:   46://===----------------------------------------------------------------------===//
        -:   47:// ArrayAttr
        -:   48://===----------------------------------------------------------------------===//
        -:   49:
function _ZNK4mlir9ArrayAttr24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
 6346820*:   50:void ArrayAttr::walkImmediateSubElements(
        -:   51:    function_ref<void(Attribute)> walkAttrsFn,
        -:   52:    function_ref<void(Type)> walkTypesFn) const {
26223397*:   53:  for (Attribute attr : getValue())
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
branch  2 never executed
branch  3 never executed
19876577*:   54:    walkAttrsFn(attr);
call    0 returned 100%
call    1 never executed
    #####:   55:}
        -:   56:
        -:   57:Attribute
function _ZNK4mlir9ArrayAttr27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:   58:ArrayAttr::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:   59:                                       ArrayRef<Type> replTypes) const {
    #####:   60:  return get(getContext(), replAttrs);
call    0 never executed
call    1 never executed
        -:   61:}
        -:   62:
        -:   63://===----------------------------------------------------------------------===//
        -:   64:// DictionaryAttr
        -:   65://===----------------------------------------------------------------------===//
        -:   66:
        -:   67:/// Helper function that does either an in place sort or sorts from source array
        -:   68:/// into destination. If inPlace then storage is both the source and the
        -:   69:/// destination, else value is the source and storage destination. Returns
        -:   70:/// whether source was sorted.
        -:   71:template <bool inPlace>
274505520:   72:static bool dictionaryAttrSort(ArrayRef<NamedAttribute> value,
        -:   73:                               SmallVectorImpl<NamedAttribute> &storage) {
        -:   74:  // Specialize for the common case.
274505520:   75:  switch (value.size()) {
178671560:   76:  case 0:
        -:   77:    // Zero already sorted.
        -:   78:    if (!inPlace)
178671560:   79:      storage.clear();
        -:   80:    break;
 63676850:   81:  case 1:
        -:   82:    // One already sorted but may need to be copied.
        -:   83:    if (!inPlace)
 63676850:   84:      storage.assign({value[0]});
 63676851:   85:    break;
 18900006:   86:  case 2: {
 18900006:   87:    bool isSorted = value[0] < value[1];
        -:   88:    if (inPlace) {
  2925050:   89:      if (!isSorted)
  2925050:   90:        std::swap(storage[0], storage[1]);
 15974953:   91:    } else if (isSorted) {
 15974953:   92:      storage.assign({value[0], value[1]});
        -:   93:    } else {
    #####:   94:      storage.assign({value[1], value[0]});
        -:   95:    }
 15974958:   96:    return !isSorted;
        -:   97:  }
 10255642:   98:  default:
        -:   99:    if (!inPlace)
 10255642:  100:      storage.assign(value.begin(), value.end());
        -:  101:    // Check to see they are sorted already.
 12452142:  102:    bool isSorted = llvm::is_sorted(value);
        -:  103:    // If not, do a general sort.
 12452142:  104:    if (!isSorted)
 2196505*:  105:      llvm::array_pod_sort(storage.begin(), storage.end());
 12452142:  106:    return !isSorted;
        -:  107:  }
        -:  108:  return false;
        -:  109:}
------------------
_Z18dictionaryAttrSortILb1EEbN4llvm8ArrayRefIN4mlir14NamedAttributeEEERNS0_15SmallVectorImplIS3_EE:
function _Z18dictionaryAttrSortILb1EEbN4llvm8ArrayRefIN4mlir14NamedAttributeEEERNS0_15SmallVectorImplIS3_EE called 5926512 returned 100% blocks executed 86%
  5926512:   72:static bool dictionaryAttrSort(ArrayRef<NamedAttribute> value,
        -:   73:                               SmallVectorImpl<NamedAttribute> &storage) {
        -:   74:  // Specialize for the common case.
  5926512:   75:  switch (value.size()) {
branch  0 taken 49%
branch  1 taken 37%
branch  2 taken 14%
        -:   76:  case 0:
        -:   77:    // Zero already sorted.
        -:   78:    if (!inPlace)
        -:   79:      storage.clear();
        -:   80:    break;
        -:   81:  case 1:
        -:   82:    // One already sorted but may need to be copied.
        -:   83:    if (!inPlace)
        -:   84:      storage.assign({value[0]});
        -:   85:    break;
  2925050:   86:  case 2: {
  2925050:   87:    bool isSorted = value[0] < value[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:   88:    if (inPlace) {
  2925050:   89:      if (!isSorted)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2925050:   90:        std::swap(storage[0], storage[1]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:    } else if (isSorted) {
        -:   92:      storage.assign({value[0], value[1]});
        -:   93:    } else {
        -:   94:      storage.assign({value[1], value[0]});
        -:   95:    }
        -:   96:    return !isSorted;
        -:   97:  }
        -:   98:  default:
        -:   99:    if (!inPlace)
        -:  100:      storage.assign(value.begin(), value.end());
        -:  101:    // Check to see they are sorted already.
  2196505:  102:    bool isSorted = llvm::is_sorted(value);
        -:  103:    // If not, do a general sort.
  2196505:  104:    if (!isSorted)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2196505:  105:      llvm::array_pod_sort(storage.begin(), storage.end());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2196505:  106:    return !isSorted;
        -:  107:  }
        -:  108:  return false;
        -:  109:}
------------------
_Z18dictionaryAttrSortILb0EEbN4llvm8ArrayRefIN4mlir14NamedAttributeEEERNS0_15SmallVectorImplIS3_EE:
function _Z18dictionaryAttrSortILb0EEbN4llvm8ArrayRefIN4mlir14NamedAttributeEEERNS0_15SmallVectorImplIS3_EE called 268579008 returned 100% blocks executed 73%
268579008:   72:static bool dictionaryAttrSort(ArrayRef<NamedAttribute> value,
        -:   73:                               SmallVectorImpl<NamedAttribute> &storage) {
        -:   74:  // Specialize for the common case.
268579008:   75:  switch (value.size()) {
branch  0 taken 67%
branch  1 taken 24%
branch  2 taken 6%
branch  3 taken 4%
178671560:   76:  case 0:
        -:   77:    // Zero already sorted.
        -:   78:    if (!inPlace)
178671560:   79:      storage.clear();
        -:   80:    break;
 63676850:   81:  case 1:
        -:   82:    // One already sorted but may need to be copied.
        -:   83:    if (!inPlace)
 63676850:   84:      storage.assign({value[0]});
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
 63676851:   85:    break;
 15974956:   86:  case 2: {
 15974956:   87:    bool isSorted = value[0] < value[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:   88:    if (inPlace) {
        -:   89:      if (!isSorted)
        -:   90:        std::swap(storage[0], storage[1]);
 15974953:   91:    } else if (isSorted) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 15974953:   92:      storage.assign({value[0], value[1]});
call    0 returned 100%
        -:   93:    } else {
    #####:   94:      storage.assign({value[1], value[0]});
call    0 never executed
        -:   95:    }
 15974958:   96:    return !isSorted;
        -:   97:  }
 10255642:   98:  default:
        -:   99:    if (!inPlace)
 10255642:  100:      storage.assign(value.begin(), value.end());
call    0 returned 100%
call    1 returned 100%
        -:  101:    // Check to see they are sorted already.
 10255637:  102:    bool isSorted = llvm::is_sorted(value);
        -:  103:    // If not, do a general sort.
 10255637:  104:    if (!isSorted)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  105:      llvm::array_pod_sort(storage.begin(), storage.end());
branch  0 never executed
branch  1 never executed
 10255637:  106:    return !isSorted;
        -:  107:  }
        -:  108:  return false;
        -:  109:}
------------------
        -:  110:
        -:  111:/// Returns an entry with a duplicate name from the given sorted array of named
        -:  112:/// attributes. Returns llvm::None if all elements have unique names.
        -:  113:static Optional<NamedAttribute>
function _ZL20findDuplicateElementN4llvm8ArrayRefIN4mlir14NamedAttributeEEE called 570445101 returned 100% blocks executed 85%
570445101:  114:findDuplicateElement(ArrayRef<NamedAttribute> value) {
570445101:  115:  const Optional<NamedAttribute> none{llvm::None};
570445101:  116:  if (value.size() < 2)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
507942109:  117:    return none;
        -:  118:
 62502992:  119:  if (value.size() == 2)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
37555905*:  120:    return value[0].getName() == value[1].getName() ? value[0] : none;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  121:
 24947087:  122:  const auto *it = std::adjacent_find(value.begin(), value.end(),
call    0 returned 100%
function _ZZL20findDuplicateElementN4llvm8ArrayRefIN4mlir14NamedAttributeEEEENKUlS2_S2_E_clES2_S2_.isra.0 called 49946965 returned 100% blocks executed 100%
 49946965:  123:                                      [](NamedAttribute l, NamedAttribute r) {
 49946965:  124:                                        return l.getName() == r.getName();
call    0 returned 100%
call    1 returned 100%
        -:  125:                                      });
 24947079:  126:  return it != value.end() ? *it : none;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  127:}
        -:  128:
function _ZN4mlir14DictionaryAttr4sortEN4llvm8ArrayRefINS_14NamedAttributeEEERNS1_15SmallVectorImplIS3_EE called 265603631 returned 100% blocks executed 80%
265603631:  129:bool DictionaryAttr::sort(ArrayRef<NamedAttribute> value,
        -:  130:                          SmallVectorImpl<NamedAttribute> &storage) {
265603631:  131:  bool isSorted = dictionaryAttrSort</*inPlace=*/false>(value, storage);
call    0 returned 100%
265603630*:  132:  assert(!findDuplicateElement(storage) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  133:         "DictionaryAttr element names must be unique");
265603621:  134:  return isSorted;
        -:  135:}
        -:  136:
function _ZN4mlir14DictionaryAttr11sortInPlaceERN4llvm15SmallVectorImplINS_14NamedAttributeEEE called 980428 returned 100% blocks executed 80%
   980428:  137:bool DictionaryAttr::sortInPlace(SmallVectorImpl<NamedAttribute> &array) {
   980428:  138:  bool isSorted = dictionaryAttrSort</*inPlace=*/true>(array, array);
call    0 returned 100%
  980428*:  139:  assert(!findDuplicateElement(array) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  140:         "DictionaryAttr element names must be unique");
   980428:  141:  return isSorted;
        -:  142:}
        -:  143:
        -:  144:Optional<NamedAttribute>
function _ZN4mlir14DictionaryAttr13findDuplicateERN4llvm15SmallVectorImplINS_14NamedAttributeEEEb called 206949739 returned 100% blocks executed 100%
206949739:  145:DictionaryAttr::findDuplicate(SmallVectorImpl<NamedAttribute> &array,
        -:  146:                              bool isSorted) {
206949739:  147:  if (!isSorted)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
  4946084:  148:    dictionaryAttrSort</*inPlace=*/true>(array, array);
call    0 returned 100%
206949739:  149:  return findDuplicateElement(array);
call    0 returned 100%
        -:  150:}
        -:  151:
function _ZN4mlir14DictionaryAttr3getEPNS_11MLIRContextEN4llvm8ArrayRefINS_14NamedAttributeEEE called 2975469 returned 100% blocks executed 77%
  2975469:  152:DictionaryAttr DictionaryAttr::get(MLIRContext *context,
        -:  153:                                   ArrayRef<NamedAttribute> value) {
  2975469:  154:  if (value.empty())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      102:  155:    return DictionaryAttr::getEmpty(context);
call    0 returned 100%
        -:  156:
        -:  157:  // We need to sort the element list to canonicalize it.
  2975367:  158:  SmallVector<NamedAttribute, 8> storage;
call    0 returned 100%
  2975367:  159:  if (dictionaryAttrSort</*inPlace=*/false>(value, storage))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  160:    value = storage;
 2975367*:  161:  assert(!findDuplicateElement(value) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  162:         "DictionaryAttr element names must be unique");
  2975367:  163:  return Base::get(context, value);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  164:}
        -:  165:/// Construct a dictionary with an array of values that is known to already be
        -:  166:/// sorted by name and uniqued.
function _ZN4mlir14DictionaryAttr13getWithSortedEPNS_11MLIRContextEN4llvm8ArrayRefINS_14NamedAttributeEEE called 268502870 returned 100% blocks executed 80%
268502870:  167:DictionaryAttr DictionaryAttr::getWithSorted(MLIRContext *context,
        -:  168:                                             ArrayRef<NamedAttribute> value) {
268502870:  169:  if (value.empty())
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
174566914:  170:    return DictionaryAttr::getEmpty(context);
call    0 returned 100%
        -:  171:  // Ensure that the attribute elements are unique and sorted.
93935956*:  172:  assert(llvm::is_sorted(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  173:             value, [](NamedAttribute l, NamedAttribute r) { return l < r; }) &&
        -:  174:         "expected attribute values to be sorted");
93935948*:  175:  assert(!findDuplicateElement(value) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  176:         "DictionaryAttr element names must be unique");
 93935945:  177:  return Base::get(context, value);
call    0 returned 100%
        -:  178:}
        -:  179:
        -:  180:/// Return the specified attribute if present, null otherwise.
function _ZNK4mlir14DictionaryAttr3getEN4llvm9StringRefE called 1867491390 returned 100% blocks executed 100%
1867491390:  181:Attribute DictionaryAttr::get(StringRef name) const {
1867491390:  182:  auto it = impl::findAttrSorted(begin(), end(), name);
1867506307:  183:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  184:}
function _ZNK4mlir14DictionaryAttr3getENS_10StringAttrE called 6640697 returned 100% blocks executed 80%
  6640697:  185:Attribute DictionaryAttr::get(StringAttr name) const {
  6640697:  186:  auto it = impl::findAttrSorted(begin(), end(), name);
 6640697*:  187:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  188:}
        -:  189:
        -:  190:/// Return the specified named attribute if present, None otherwise.
function _ZNK4mlir14DictionaryAttr8getNamedEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  191:Optional<NamedAttribute> DictionaryAttr::getNamed(StringRef name) const {
    #####:  192:  auto it = impl::findAttrSorted(begin(), end(), name);
    #####:  193:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:  194:}
function _ZNK4mlir14DictionaryAttr8getNamedENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:  195:Optional<NamedAttribute> DictionaryAttr::getNamed(StringAttr name) const {
    #####:  196:  auto it = impl::findAttrSorted(begin(), end(), name);
    #####:  197:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:  198:}
        -:  199:
        -:  200:/// Return whether the specified attribute is present.
function _ZNK4mlir14DictionaryAttr8containsEN4llvm9StringRefE called 113339406 returned 100% blocks executed 100%
113339406:  201:bool DictionaryAttr::contains(StringRef name) const {
226678811:  202:  return impl::findAttrSorted(begin(), end(), name).second;
        -:  203:}
function _ZNK4mlir14DictionaryAttr8containsENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:  204:bool DictionaryAttr::contains(StringAttr name) const {
    #####:  205:  return impl::findAttrSorted(begin(), end(), name).second;
        -:  206:}
        -:  207:
function _ZNK4mlir14DictionaryAttr5beginEv called 142684671 returned 100% blocks executed 100%
2130156164*:  208:DictionaryAttr::iterator DictionaryAttr::begin() const {
1987471493*:  209:  return getValue().begin();
call    0 never executed
call    1 returned 100%
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 returned 100%
        -:  210:}
function _ZNK4mlir14DictionaryAttr3endEv called 142684671 returned 100% blocks executed 100%
2130156164*:  211:DictionaryAttr::iterator DictionaryAttr::end() const {
1987471493*:  212:  return getValue().end();
call    0 never executed
call    1 returned 100%
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 returned 100%
        -:  213:}
function _ZNK4mlir14DictionaryAttr4sizeEv called 12796205 returned 100% blocks executed 100%
 12796205:  214:size_t DictionaryAttr::size() const { return getValue().size(); }
        -:  215:
function _ZN4mlir14DictionaryAttr17getEmptyUncheckedEPNS_11MLIRContextE called 189144 returned 100% blocks executed 100%
   189144:  216:DictionaryAttr DictionaryAttr::getEmptyUnchecked(MLIRContext *context) {
   189144:  217:  return Base::get(context, ArrayRef<NamedAttribute>());
call    0 returned 100%
        -:  218:}
        -:  219:
function _ZNK4mlir14DictionaryAttr24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
 4014093*:  220:void DictionaryAttr::walkImmediateSubElements(
        -:  221:    function_ref<void(Attribute)> walkAttrsFn,
        -:  222:    function_ref<void(Type)> walkTypesFn) const {
10748614*:  223:  for (const NamedAttribute &attr : getValue())
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
branch  2 never executed
branch  3 never executed
 6734521*:  224:    walkAttrsFn(attr.getValue());
call    0 returned 100%
call    1 never executed
    #####:  225:}
        -:  226:
        -:  227:Attribute
function _ZNK4mlir14DictionaryAttr27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  228:DictionaryAttr::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  229:                                            ArrayRef<Type> replTypes) const {
    #####:  230:  std::vector<NamedAttribute> vec = getValue().vec();
call    0 never executed
    #####:  231:  for (auto &it : llvm::enumerate(replAttrs))
branch  0 never executed
branch  1 never executed
    #####:  232:    vec[it.index()].setValue(it.value());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  233:
        -:  234:  // The above only modifies the mapped value, but not the key, and therefore
        -:  235:  // not the order of the elements. It remains sorted
    #####:  236:  return getWithSorted(getContext(), vec);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  237:}
        -:  238:
        -:  239://===----------------------------------------------------------------------===//
        -:  240:// StridedLayoutAttr
        -:  241://===----------------------------------------------------------------------===//
        -:  242:
        -:  243:/// Prints a strided layout attribute.
function _ZNK4mlir17StridedLayoutAttr5printERN4llvm11raw_ostreamE called 2 returned 100% blocks executed 100%
        2:  244:void StridedLayoutAttr::print(llvm::raw_ostream &os) const {
function _ZZNK4mlir17StridedLayoutAttr5printERN4llvm11raw_ostreamEENKUllE_clEl.isra.0 called 8 returned 100% blocks executed 80%
        8:  245:  auto printIntOrQuestion = [&](int64_t value) {
        8:  246:    if (value == ShapedType::kDynamicStrideOrOffset)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       8*:  247:      os << "?";
call    0 returned 100%
        -:  248:    else
    #####:  249:      os << value;
call    0 never executed
       10:  250:  };
        -:  251:
        2:  252:  os << "strided<[";
call    0 returned 100%
        2:  253:  llvm::interleaveComma(getStrides(), os, printIntOrQuestion);
call    0 returned 100%
        2:  254:  os << "]";
call    0 returned 100%
        -:  255:
        2:  256:  if (getOffset() != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  257:    os << ", offset: ";
call    0 returned 100%
        2:  258:    printIntOrQuestion(getOffset());
call    0 returned 100%
        -:  259:  }
        2:  260:  os << ">";
call    0 returned 100%
        2:  261:}
        -:  262:
        -:  263:/// Returns the strided layout as an affine map.
function _ZNK4mlir17StridedLayoutAttr12getAffineMapEv called 12 returned 100% blocks executed 100%
       12:  264:AffineMap StridedLayoutAttr::getAffineMap() const {
       12:  265:  return makeStridedLinearLayoutMap(getStrides(), getOffset(), getContext());
call    0 returned 100%
call    1 returned 100%
        -:  266:}
        -:  267:
        -:  268:/// Checks that the type-agnostic strided layout invariants are satisfied.
        -:  269:LogicalResult
function _ZN4mlir17StridedLayoutAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEElNS1_8ArrayRefIlEE called 266 returned 100% blocks executed 38%
      266:  270:StridedLayoutAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  271:                          int64_t offset, ArrayRef<int64_t> strides) {
      266:  272:  if (llvm::any_of(strides, [&](int64_t stride) { return stride == 0; }))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  273:    return emitError() << "strides must not be zero";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  274:
      266:  275:  return success();
        -:  276:}
        -:  277:
        -:  278:/// Checks that the type-specific strided layout invariants are satisfied.
function _ZNK4mlir17StridedLayoutAttr12verifyLayoutEN4llvm8ArrayRefIlEENS1_12function_refIFNS_18InFlightDiagnosticEvEEE called 266 returned 100% blocks executed 38%
      266:  279:LogicalResult StridedLayoutAttr::verifyLayout(
        -:  280:    ArrayRef<int64_t> shape,
        -:  281:    function_ref<InFlightDiagnostic()> emitError) const {
      266:  282:  if (shape.size() != getStrides().size())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  283:    return emitError() << "expected the number of strides to match the rank";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  284:
      266:  285:  return success();
        -:  286:}
        -:  287:
        -:  288://===----------------------------------------------------------------------===//
        -:  289:// StringAttr
        -:  290://===----------------------------------------------------------------------===//
        -:  291:
function _ZN4mlir10StringAttr27getEmptyStringAttrUncheckedEPNS_11MLIRContextE called 189144 returned 100% blocks executed 100%
   189144:  292:StringAttr StringAttr::getEmptyStringAttrUnchecked(MLIRContext *context) {
   189144:  293:  return Base::get(context, "", NoneType::get(context));
call    0 returned 100%
call    1 returned 100%
        -:  294:}
        -:  295:
        -:  296:/// Twine support for StringAttr.
function _ZN4mlir10StringAttr3getEPNS_11MLIRContextERKN4llvm5TwineE called 366967225 returned 100% blocks executed 90%
366967225:  297:StringAttr StringAttr::get(MLIRContext *context, const Twine &twine) {
        -:  298:  // Fast-path empty twine.
366967225:  299:  if (twine.isTriviallyEmpty())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        1:  300:    return get(context);
call    0 returned 0%
366967224:  301:  SmallVector<char, 32> tempStr;
call    0 returned 100%
366967224:  302:  return Base::get(context, twine.toStringRef(tempStr), NoneType::get(context));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0%
branch  4 taken 100%
        -:  303:}
        -:  304:
        -:  305:/// Twine support for StringAttr.
function _ZN4mlir10StringAttr3getERKN4llvm5TwineENS_4TypeE called 624 returned 100% blocks executed 83%
      624:  306:StringAttr StringAttr::get(const Twine &twine, Type type) {
      624:  307:  SmallVector<char, 32> tempStr;
call    0 returned 100%
      624:  308:  return Base::get(type.getContext(), twine.toStringRef(tempStr), type);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  309:}
        -:  310:
function _ZNK4mlir10StringAttr8getValueEv called 20763656920 returned 100% blocks executed 100%
    #####:  311:StringRef StringAttr::getValue() const { return getImpl()->value; }
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  312:
function _ZNK4mlir10StringAttr7getTypeEv called 26858 returned 100% blocks executed 100%
  4112247:  313:Type StringAttr::getType() const { return getImpl()->type; }
        -:  314:
function _ZNK4mlir10StringAttr20getReferencedDialectEv called 5317328950 returned 100% blocks executed 100%
5317328950:  315:Dialect *StringAttr::getReferencedDialect() const {
5317328950:  316:  return getImpl()->referencedDialect;
        -:  317:}
        -:  318:
        -:  319://===----------------------------------------------------------------------===//
        -:  320:// FloatAttr
        -:  321://===----------------------------------------------------------------------===//
        -:  322:
function _ZNK4mlir9FloatAttr16getValueAsDoubleEv called 0 returned 0% blocks executed 0%
    #####:  323:double FloatAttr::getValueAsDouble() const {
    #####:  324:  return getValueAsDouble(getValue());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  325:}
function _ZN4mlir9FloatAttr16getValueAsDoubleEN4llvm7APFloatE called 0 returned 0% blocks executed 0%
    #####:  326:double FloatAttr::getValueAsDouble(APFloat value) {
    #####:  327:  if (&value.getSemantics() != &APFloat::IEEEdouble()) {
branch  0 never executed
branch  1 never executed
    #####:  328:    bool losesInfo = false;
    #####:  329:    value.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,
call    0 never executed
        -:  330:                  &losesInfo);
        -:  331:  }
    #####:  332:  return value.convertToDouble();
call    0 never executed
        -:  333:}
        -:  334:
function _ZN4mlir9FloatAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeENS1_7APFloatE called 3355690 returned 100% blocks executed 41%
  3355690:  335:LogicalResult FloatAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  336:                                Type type, APFloat value) {
        -:  337:  // Verify that the type is correct.
  3355690:  338:  if (!type.isa<FloatType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  339:    return emitError() << "expected floating point type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  340:
        -:  341:  // Verify that the type semantics match that of the value.
  3355690:  342:  if (&type.cast<FloatType>().getFloatSemantics() != &value.getSemantics()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  343:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  344:           << "FloatAttr type doesn't match the type implied by its value";
call    0 never executed
        -:  345:  }
  3355690:  346:  return success();
        -:  347:}
        -:  348:
        -:  349://===----------------------------------------------------------------------===//
        -:  350:// SymbolRefAttr
        -:  351://===----------------------------------------------------------------------===//
        -:  352:
function _ZN4mlir13SymbolRefAttr3getEPNS_11MLIRContextEN4llvm9StringRefENS3_8ArrayRefINS_17FlatSymbolRefAttrEEE called 699 returned 100% blocks executed 100%
      699:  353:SymbolRefAttr SymbolRefAttr::get(MLIRContext *ctx, StringRef value,
        -:  354:                                 ArrayRef<FlatSymbolRefAttr> nestedRefs) {
      699:  355:  return get(StringAttr::get(ctx, value), nestedRefs);
call    0 returned 100%
call    1 returned 100%
        -:  356:}
        -:  357:
function _ZN4mlir13SymbolRefAttr3getEPNS_11MLIRContextEN4llvm9StringRefE called 387 returned 100% blocks executed 100%
      387:  358:FlatSymbolRefAttr SymbolRefAttr::get(MLIRContext *ctx, StringRef value) {
      387:  359:  return get(ctx, value, {}).cast<FlatSymbolRefAttr>();
call    0 returned 100%
call    1 returned 100%
        -:  360:}
        -:  361:
function _ZN4mlir13SymbolRefAttr3getENS_10StringAttrE called 8574443 returned 100% blocks executed 100%
  8574443:  362:FlatSymbolRefAttr SymbolRefAttr::get(StringAttr value) {
 17148886:  363:  return get(value, {}).cast<FlatSymbolRefAttr>();
call    0 returned 100%
call    1 returned 100%
        -:  364:}
        -:  365:
function _ZN4mlir13SymbolRefAttr3getEPNS_9OperationE called 8571640 returned 100% blocks executed 80%
  8571640:  366:FlatSymbolRefAttr SymbolRefAttr::get(Operation *symbol) {
  8571640:  367:  auto symName =
call    0 returned 100%
  8571640:  368:      symbol->getAttrOfType<StringAttr>(SymbolTable::getSymbolAttrName());
call    0 returned 100%
 8571640*:  369:  assert(symName && "value does not have a valid symbol name");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  8571640:  370:  return SymbolRefAttr::get(symName);
call    0 returned 100%
        -:  371:}
        -:  372:
function _ZNK4mlir13SymbolRefAttr16getLeafReferenceEv called 312 returned 100% blocks executed 80%
      312:  373:StringAttr SymbolRefAttr::getLeafReference() const {
      312:  374:  ArrayRef<FlatSymbolRefAttr> nestedRefs = getNestedReferences();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      312:  375:  return nestedRefs.empty() ? getRootReference() : nestedRefs.back().getAttr();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  376:}
        -:  377:
function _ZNK4mlir13SymbolRefAttr24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 4717 returned 100% blocks executed 67%
     4717:  378:void SymbolRefAttr::walkImmediateSubElements(
        -:  379:    function_ref<void(Attribute)> walkAttrsFn,
        -:  380:    function_ref<void(Type)> walkTypesFn) const {
     4717:  381:  walkAttrsFn(getRootReference());
call    0 returned 100%
    4717*:  382:  for (FlatSymbolRefAttr ref : getNestedReferences())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  383:    walkAttrsFn(ref);
call    0 never executed
     4717:  384:}
        -:  385:
        -:  386:Attribute
function _ZNK4mlir13SymbolRefAttr27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  387:SymbolRefAttr::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  388:                                           ArrayRef<Type> replTypes) const {
    #####:  389:  ArrayRef<Attribute> rawNestedRefs = replAttrs.drop_front();
call    0 never executed
    #####:  390:  ArrayRef<FlatSymbolRefAttr> nestedRefs(
    #####:  391:      static_cast<const FlatSymbolRefAttr *>(rawNestedRefs.data()),
branch  0 never executed
branch  1 never executed
    #####:  392:      rawNestedRefs.size());
branch  0 never executed
branch  1 never executed
    #####:  393:  return get(replAttrs[0].cast<StringAttr>(), nestedRefs);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  394:}
        -:  395:
        -:  396://===----------------------------------------------------------------------===//
        -:  397:// IntegerAttr
        -:  398://===----------------------------------------------------------------------===//
        -:  399:
function _ZNK4mlir11IntegerAttr6getIntEv called 3854619434 returned 100% blocks executed 69%
3854619434:  400:int64_t IntegerAttr::getInt() const {
3854619434*:  401:  assert((getType().isIndex() || getType().isSignlessInteger()) &&
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        -:  402:         "must be signless integer");
7709238852:  403:  return getValue().getSExtValue();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  404:}
        -:  405:
function _ZNK4mlir11IntegerAttr7getSIntEv called 0 returned 0% blocks executed 0%
    #####:  406:int64_t IntegerAttr::getSInt() const {
    #####:  407:  assert(getType().isSignedInteger() && "must be signed integer");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  408:  return getValue().getSExtValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  409:}
        -:  410:
function _ZNK4mlir11IntegerAttr7getUIntEv called 0 returned 0% blocks executed 0%
    #####:  411:uint64_t IntegerAttr::getUInt() const {
    #####:  412:  assert(getType().isUnsignedInteger() && "must be unsigned integer");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  413:  return getValue().getZExtValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  414:}
        -:  415:
        -:  416:/// Return the value as an APSInt which carries the signed from the type of
        -:  417:/// the attribute.  This traps on signless integers types!
function _ZNK4mlir11IntegerAttr9getAPSIntEv called 0 returned 0% blocks executed 0%
    #####:  418:APSInt IntegerAttr::getAPSInt() const {
    #####:  419:  assert(!getType().isSignlessInteger() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  420:         "Signless integers don't carry a sign for APSInt");
    #####:  421:  return APSInt(getValue(), getType().isUnsignedInteger());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  422:}
        -:  423:
function _ZN4mlir11IntegerAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeENS1_5APIntE called 56927153 returned 100% blocks executed 31%
 56927153:  424:LogicalResult IntegerAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  425:                                  Type type, APInt value) {
 56927153:  426:  if (IntegerType integerType = type.dyn_cast<IntegerType>()) {
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
 46803471:  427:    if (integerType.getWidth() != value.getBitWidth())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  428:      return emitError() << "integer type bit width (" << integerType.getWidth()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  429:                         << ") doesn't match value bit width ("
    #####:  430:                         << value.getBitWidth() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 46803471:  431:    return success();
        -:  432:  }
 10123682:  433:  if (type.isa<IndexType>()) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
 10123682:  434:    if (value.getBitWidth() != IndexType::kInternalStorageBitWidth)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  435:      return emitError()
call    0 never executed
call    1 never executed
    #####:  436:             << "value bit width (" << value.getBitWidth()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  437:             << ") doesn't match index type internal storage bit width ("
call    0 never executed
    #####:  438:             << IndexType::kInternalStorageBitWidth << ")";
call    0 never executed
call    1 never executed
 10123682:  439:    return success();
        -:  440:  }
    #####:  441:  return emitError() << "expected integer or index type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  442:}
        -:  443:
function _ZN4mlir11IntegerAttr20getBoolAttrUncheckedENS_11IntegerTypeEb called 378288 returned 100% blocks executed 75%
   378288:  444:BoolAttr IntegerAttr::getBoolAttrUnchecked(IntegerType type, bool value) {
   378288:  445:  auto attr = Base::get(type.getContext(), type, APInt(/*numBits=*/1, value));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   378288:  446:  return attr.cast<BoolAttr>();
call    0 returned 100%
        -:  447:}
        -:  448:
        -:  449://===----------------------------------------------------------------------===//
        -:  450:// BoolAttr
        -:  451://===----------------------------------------------------------------------===//
        -:  452:
function _ZNK4mlir8BoolAttr8getValueEv called 97369 returned 100% blocks executed 75%
    97369:  453:bool BoolAttr::getValue() const {
    97369:  454:  auto *storage = reinterpret_cast<IntegerAttrStorage *>(impl);
    97369:  455:  return storage->value.getBoolValue();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  456:}
        -:  457:
function _ZN4mlir8BoolAttr7classofENS_9AttributeE called 131493770 returned 100% blocks executed 100%
131493770:  458:bool BoolAttr::classof(Attribute attr) {
131493770:  459:  IntegerAttr intAttr = attr.dyn_cast<IntegerAttr>();
call    0 returned 100%
131493771:  460:  return intAttr && intAttr.getType().isSignlessInteger(1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
        -:  461:}
        -:  462:
        -:  463://===----------------------------------------------------------------------===//
        -:  464:// OpaqueAttr
        -:  465://===----------------------------------------------------------------------===//
        -:  466:
function _ZN4mlir10OpaqueAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_10StringAttrENS1_9StringRefENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  467:LogicalResult OpaqueAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  468:                                 StringAttr dialect, StringRef attrData,
        -:  469:                                 Type type) {
    #####:  470:  if (!Dialect::isValidNamespace(dialect.strref()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  471:    return emitError() << "invalid dialect namespace '" << dialect << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  472:
        -:  473:  // Check that the dialect is actually registered.
    #####:  474:  MLIRContext *context = dialect.getContext();
call    0 never executed
    #####:  475:  if (!context->allowsUnregisteredDialects() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  476:      !context->getLoadedDialect(dialect.strref())) {
call    0 never executed
    #####:  477:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  478:           << "#" << dialect << "<\"" << attrData << "\"> : " << type
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  479:           << " attribute created with unregistered dialect. If this is "
        -:  480:              "intended, please call allowUnregisteredDialects() on the "
        -:  481:              "MLIRContext, or use -allow-unregistered-dialect with "
    #####:  482:              "the MLIR opt tool used";
call    0 never executed
        -:  483:  }
        -:  484:
    #####:  485:  return success();
        -:  486:}
        -:  487:
        -:  488://===----------------------------------------------------------------------===//
        -:  489:// DenseElementsAttr Utilities
        -:  490://===----------------------------------------------------------------------===//
        -:  491:
        -:  492:/// Get the bitwidth of a dense element type within the buffer.
        -:  493:/// DenseElementsAttr requires bitwidths greater than 1 to be aligned by 8.
 7886433*:  494:static size_t getDenseElementStorageWidth(size_t origWidth) {
 6057707*:  495:  return origWidth == 1 ? origWidth : llvm::alignTo<8>(origWidth);
        -:  496:}
 2986483*:  497:static size_t getDenseElementStorageWidth(Type elementType) {
 2986483*:  498:  return getDenseElementStorageWidth(getDenseElementBitWidth(elementType));
branch  0 never executed
branch  1 never executed
call    2 returned 100%
branch  3 taken 75% (fallthrough)
branch  4 taken 25%
branch  5 never executed
branch  6 never executed
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 never executed
branch 11 never executed
call   12 returned 100%
branch 13 taken 98% (fallthrough)
branch 14 taken 2%
        -:  499:}
        -:  500:
        -:  501:/// Set a bit to a specific value.
  5248731:  502:static void setBit(char *rawData, size_t bitPos, bool value) {
  5248731:  503:  if (value)
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
  1785553:  504:    rawData[bitPos / CHAR_BIT] |= (1 << (bitPos % CHAR_BIT));
        -:  505:  else
  3463178:  506:    rawData[bitPos / CHAR_BIT] &= ~(1 << (bitPos % CHAR_BIT));
        -:  507:}
        -:  508:
        -:  509:/// Return the value of the specified bit.
 1991601*:  510:static bool getBit(const char *rawData, size_t bitPos) {
    #####:  511:  return (rawData[bitPos / CHAR_BIT] & (1 << (bitPos % CHAR_BIT))) != 0;
        -:  512:}
        -:  513:
        -:  514:/// Copy actual `numBytes` data from `value` (APInt) to char array(`result`) for
        -:  515:/// BE format.
        -:  516:static void copyAPIntToArrayForBEmachine(APInt value, size_t numBytes,
        -:  517:                                         char *result) {
        -:  518:  assert(llvm::support::endian::system_endianness() == // NOLINT
        -:  519:         llvm::support::endianness::big);              // NOLINT
        -:  520:  assert(value.getNumWords() * APInt::APINT_WORD_SIZE >= numBytes);
        -:  521:
        -:  522:  // Copy the words filled with data.
        -:  523:  // For example, when `value` has 2 words, the first word is filled with data.
        -:  524:  // `value` (10 bytes, BE):|abcdefgh|------ij| ==> `result` (BE):|abcdefgh|--|
        -:  525:  size_t numFilledWords = (value.getNumWords() - 1) * APInt::APINT_WORD_SIZE;
        -:  526:  std::copy_n(reinterpret_cast<const char *>(value.getRawData()),
        -:  527:              numFilledWords, result);
        -:  528:  // Convert last word of APInt to LE format and store it in char
        -:  529:  // array(`valueLE`).
        -:  530:  // ex. last word of `value` (BE): |------ij|  ==> `valueLE` (LE): |ji------|
        -:  531:  size_t lastWordPos = numFilledWords;
        -:  532:  SmallVector<char, 8> valueLE(APInt::APINT_WORD_SIZE);
        -:  533:  DenseIntOrFPElementsAttr::convertEndianOfCharForBEmachine(
        -:  534:      reinterpret_cast<const char *>(value.getRawData()) + lastWordPos,
        -:  535:      valueLE.begin(), APInt::APINT_BITS_PER_WORD, 1);
        -:  536:  // Extract actual APInt data from `valueLE`, convert endianness to BE format,
        -:  537:  // and store it in `result`.
        -:  538:  // ex. `valueLE` (LE): |ji------|  ==> `result` (BE): |abcdefgh|ij|
        -:  539:  DenseIntOrFPElementsAttr::convertEndianOfCharForBEmachine(
        -:  540:      valueLE.begin(), result + lastWordPos,
        -:  541:      (numBytes - lastWordPos) * CHAR_BIT, 1);
        -:  542:}
        -:  543:
        -:  544:/// Copy `numBytes` data from `inArray`(char array) to `result`(APINT) for BE
        -:  545:/// format.
        -:  546:static void copyArrayToAPIntForBEmachine(const char *inArray, size_t numBytes,
        -:  547:                                         APInt &result) {
        -:  548:  assert(llvm::support::endian::system_endianness() == // NOLINT
        -:  549:         llvm::support::endianness::big);              // NOLINT
        -:  550:  assert(result.getNumWords() * APInt::APINT_WORD_SIZE >= numBytes);
        -:  551:
        -:  552:  // Copy the data that fills the word of `result` from `inArray`.
        -:  553:  // For example, when `result` has 2 words, the first word will be filled with
        -:  554:  // data. So, the first 8 bytes are copied from `inArray` here.
        -:  555:  // `inArray` (10 bytes, BE): |abcdefgh|ij|
        -:  556:  //                     ==> `result` (2 words, BE): |abcdefgh|--------|
        -:  557:  size_t numFilledWords = (result.getNumWords() - 1) * APInt::APINT_WORD_SIZE;
        -:  558:  std::copy_n(
        -:  559:      inArray, numFilledWords,
        -:  560:      const_cast<char *>(reinterpret_cast<const char *>(result.getRawData())));
        -:  561:
        -:  562:  // Convert array data which will be last word of `result` to LE format, and
        -:  563:  // store it in char array(`inArrayLE`).
        -:  564:  // ex. `inArray` (last two bytes, BE): |ij|  ==> `inArrayLE` (LE): |ji------|
        -:  565:  size_t lastWordPos = numFilledWords;
        -:  566:  SmallVector<char, 8> inArrayLE(APInt::APINT_WORD_SIZE);
        -:  567:  DenseIntOrFPElementsAttr::convertEndianOfCharForBEmachine(
        -:  568:      inArray + lastWordPos, inArrayLE.begin(),
        -:  569:      (numBytes - lastWordPos) * CHAR_BIT, 1);
        -:  570:
        -:  571:  // Convert `inArrayLE` to BE format, and store it in last word of `result`.
        -:  572:  // ex. `inArrayLE` (LE): |ji------|  ==> `result` (BE): |abcdefgh|------ij|
        -:  573:  DenseIntOrFPElementsAttr::convertEndianOfCharForBEmachine(
        -:  574:      inArrayLE.begin(),
        -:  575:      const_cast<char *>(reinterpret_cast<const char *>(result.getRawData())) +
        -:  576:          lastWordPos,
        -:  577:      APInt::APINT_BITS_PER_WORD, 1);
        -:  578:}
        -:  579:
        -:  580:/// Writes value to the bit position `bitPos` in array `rawData`.
function _ZL9writeBitsPcmN4llvm5APIntE called 30695174 returned 100% blocks executed 85%
 30695174:  581:static void writeBits(char *rawData, size_t bitPos, APInt value) {
 30695174:  582:  size_t bitWidth = value.getBitWidth();
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  583:
        -:  584:  // If the bitwidth is 1 we just toggle the specific bit.
 30695174:  585:  if (bitWidth == 1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
 10489012:  586:    return setBit(rawData, bitPos, value.isOneValue());
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
        -:  587:
        -:  588:  // Otherwise, the bit position is guaranteed to be byte aligned.
25450668*:  589:  assert((bitPos % CHAR_BIT) == 0 && "expected bitPos to be 8-bit aligned");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 25450668:  590:  if (llvm::support::endian::system_endianness() ==
        -:  591:      llvm::support::endianness::big) {
        -:  592:    // Copy from `value` to `rawData + (bitPos / CHAR_BIT)`.
        -:  593:    // Copying the first `llvm::divideCeil(bitWidth, CHAR_BIT)` bytes doesn't
        -:  594:    // work correctly in BE format.
        -:  595:    // ex. `value` (2 words including 10 bytes)
        -:  596:    // ==> BE: |abcdefgh|------ij|,  LE: |hgfedcba|ji------|
        -:  597:    copyAPIntToArrayForBEmachine(value, llvm::divideCeil(bitWidth, CHAR_BIT),
        -:  598:                                 rawData + (bitPos / CHAR_BIT));
        -:  599:  } else {
 25450668:  600:    std::copy_n(reinterpret_cast<const char *>(value.getRawData()),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  601:                llvm::divideCeil(bitWidth, CHAR_BIT),
 25450668:  602:                rawData + (bitPos / CHAR_BIT));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  603:  }
        -:  604:}
        -:  605:
        -:  606:/// Reads the next `bitWidth` bits from the bit position `bitPos` in array
        -:  607:/// `rawData`.
function _ZL8readBitsPKcmm called 1929615 returned 100% blocks executed 80%
  1929615:  608:static APInt readBits(const char *rawData, size_t bitPos, size_t bitWidth) {
        -:  609:  // Handle a boolean bit position.
  1929615:  610:  if (bitWidth == 1)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
   332121:  611:    return APInt(1, getBit(rawData, bitPos) ? 1 : 0);
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  612:
        -:  613:  // Otherwise, the bit position must be 8-bit aligned.
 1597494*:  614:  assert((bitPos % CHAR_BIT) == 0 && "expected bitPos to be 8-bit aligned");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  1597494:  615:  APInt result(bitWidth, 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1597494:  616:  if (llvm::support::endian::system_endianness() ==
        -:  617:      llvm::support::endianness::big) {
        -:  618:    // Copy from `rawData + (bitPos / CHAR_BIT)` to `result`.
        -:  619:    // Copying the first `llvm::divideCeil(bitWidth, CHAR_BIT)` bytes doesn't
        -:  620:    // work correctly in BE format.
        -:  621:    // ex. `result` (2 words including 10 bytes)
        -:  622:    // ==> BE: |abcdefgh|------ij|,  LE: |hgfedcba|ji------| This function
        -:  623:    copyArrayToAPIntForBEmachine(rawData + (bitPos / CHAR_BIT),
        -:  624:                                 llvm::divideCeil(bitWidth, CHAR_BIT), result);
        -:  625:  } else {
  1597494:  626:    std::copy_n(rawData + (bitPos / CHAR_BIT),
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  627:                llvm::divideCeil(bitWidth, CHAR_BIT),
        -:  628:                const_cast<char *>(
  1597494:  629:                    reinterpret_cast<const char *>(result.getRawData())));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  630:  }
  1597494:  631:  return result;
        -:  632:}
        -:  633:
        -:  634:/// Returns true if 'values' corresponds to a splat, i.e. one element, or has
        -:  635:/// the same element count as 'type'.
        -:  636:template <typename Values>
 2976900*:  637:static bool hasSameElementsOrSplat(ShapedType type, const Values &values) {
  159804*:  638:  return (values.size() == 1) ||
branch  0 never executed
branch  1 never executed
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 never executed
branch  5 never executed
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
  159804*:  639:         (type.getNumElements() == static_cast<int64_t>(values.size()));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 100% (fallthrough)
branch 14 taken 0%
call   15 returned 100%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
        -:  640:}
        -:  641:
        -:  642://===----------------------------------------------------------------------===//
        -:  643:// DenseElementsAttr Iterators
        -:  644://===----------------------------------------------------------------------===//
        -:  645:
        -:  646://===----------------------------------------------------------------------===//
        -:  647:// AttributeElementIterator
        -:  648:
function _ZN4mlir17DenseElementsAttr24AttributeElementIteratorC2ES0_m called 16830 returned 100% blocks executed 100%
    16929:  649:DenseElementsAttr::AttributeElementIterator::AttributeElementIterator(
        -:  650:    DenseElementsAttr attr, size_t index)
        -:  651:    : llvm::indexed_accessor_iterator<AttributeElementIterator, const void *,
        -:  652:                                      Attribute, Attribute, Attribute>(
    16929:  653:          attr.getAsOpaquePointer(), index) {}
        -:  654:
function _ZNK4mlir17DenseElementsAttr24AttributeElementIteratordeEv called 60176 returned 100% blocks executed 31%
    60176:  655:Attribute DenseElementsAttr::AttributeElementIterator::operator*() const {
    60176:  656:  auto owner = getFromOpaquePointer(base).cast<DenseElementsAttr>();
call    0 returned 100%
   120352:  657:  Type eltTy = owner.getElementType();
    60176:  658:  if (auto intEltTy = eltTy.dyn_cast<IntegerType>())
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
    47141:  659:    return IntegerAttr::get(eltTy, *IntElementIterator(owner, index));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    13035:  660:  if (eltTy.isa<IndexType>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       10:  661:    return IntegerAttr::get(eltTy, *IntElementIterator(owner, index));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    13025:  662:  if (auto floatEltTy = eltTy.dyn_cast<FloatType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    13025:  663:    IntElementIterator intIt(owner, index);
call    0 returned 100%
    13025:  664:    FloatElementIterator floatIt(floatEltTy.getFloatSemantics(), intIt);
call    0 returned 100%
call    1 returned 100%
    13025:  665:    return FloatAttr::get(eltTy, *floatIt);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  666:  }
    #####:  667:  if (auto complexTy = eltTy.dyn_cast<ComplexType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  668:    auto complexEltTy = complexTy.getElementType();
call    0 never executed
    #####:  669:    ComplexIntElementIterator complexIntIt(owner, index);
call    0 never executed
    #####:  670:    if (complexEltTy.isa<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  671:      auto value = *complexIntIt;
call    0 never executed
    #####:  672:      auto real = IntegerAttr::get(complexEltTy, value.real());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  673:      auto imag = IntegerAttr::get(complexEltTy, value.imag());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  674:      return ArrayAttr::get(complexTy.getContext(),
    #####:  675:                            ArrayRef<Attribute>{real, imag});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  676:    }
        -:  677:
    #####:  678:    ComplexFloatElementIterator complexFloatIt(
call    0 never executed
    #####:  679:        complexEltTy.cast<FloatType>().getFloatSemantics(), complexIntIt);
call    0 never executed
call    1 never executed
    #####:  680:    auto value = *complexFloatIt;
call    0 never executed
    #####:  681:    auto real = FloatAttr::get(complexEltTy, value.real());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  682:    auto imag = FloatAttr::get(complexEltTy, value.imag());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  683:    return ArrayAttr::get(complexTy.getContext(),
    #####:  684:                          ArrayRef<Attribute>{real, imag});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  685:  }
    #####:  686:  if (owner.isa<DenseStringElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  687:    ArrayRef<StringRef> vals = owner.getRawStringData();
    #####:  688:    return StringAttr::get(owner.isSplat() ? vals.front() : vals[index], eltTy);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  689:  }
    #####:  690:  llvm_unreachable("unexpected element type");
call    0 never executed
        -:  691:}
        -:  692:
        -:  693://===----------------------------------------------------------------------===//
        -:  694:// BoolElementIterator
        -:  695:
function _ZN4mlir17DenseElementsAttr19BoolElementIteratorC2ES0_m called 71006 returned 100% blocks executed 100%
   71006*:  696:DenseElementsAttr::BoolElementIterator::BoolElementIterator(
        -:  697:    DenseElementsAttr attr, size_t dataIndex)
        -:  698:    : DenseElementIndexedIteratorImpl<BoolElementIterator, bool, bool, bool>(
   71006*:  699:          attr.getRawData().data(), attr.isSplat(), dataIndex) {}
        -:  700:
function _ZNK4mlir17DenseElementsAttr19BoolElementIteratordeEv called 1659480 returned 100% blocks executed 100%
 1659480*:  701:bool DenseElementsAttr::BoolElementIterator::operator*() const {
 1659480*:  702:  return getBit(getData(), getDataIndex());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
        -:  703:}
        -:  704:
        -:  705://===----------------------------------------------------------------------===//
        -:  706:// IntElementIterator
        -:  707:
function _ZN4mlir17DenseElementsAttr18IntElementIteratorC2ES0_m called 2322730 returned 100% blocks executed 100%
  2322730:  708:DenseElementsAttr::IntElementIterator::IntElementIterator(
  2322730:  709:    DenseElementsAttr attr, size_t dataIndex)
        -:  710:    : DenseElementIndexedIteratorImpl<IntElementIterator, APInt, APInt, APInt>(
  2322730:  711:          attr.getRawData().data(), attr.isSplat(), dataIndex),
  6968190:  712:      bitWidth(getDenseElementBitWidth(attr.getElementType())) {}
        -:  713:
function _ZNK4mlir17DenseElementsAttr18IntElementIteratordeEv called 1929615 returned 100% blocks executed 100%
  1929615:  714:APInt DenseElementsAttr::IntElementIterator::operator*() const {
  1929615:  715:  return readBits(getData(),
  1929615:  716:                  getDataIndex() * getDenseElementStorageWidth(bitWidth),
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
  3859230:  717:                  bitWidth);
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
call    2 returned 100%
        -:  718:}
        -:  719:
        -:  720://===----------------------------------------------------------------------===//
        -:  721:// ComplexIntElementIterator
        -:  722:
function _ZN4mlir17DenseElementsAttr25ComplexIntElementIteratorC2ES0_m called 0 returned 0% blocks executed 0%
    #####:  723:DenseElementsAttr::ComplexIntElementIterator::ComplexIntElementIterator(
    #####:  724:    DenseElementsAttr attr, size_t dataIndex)
        -:  725:    : DenseElementIndexedIteratorImpl<ComplexIntElementIterator,
        -:  726:                                      std::complex<APInt>, std::complex<APInt>,
        -:  727:                                      std::complex<APInt>>(
    #####:  728:          attr.getRawData().data(), attr.isSplat(), dataIndex) {
    #####:  729:  auto complexType = attr.getElementType().cast<ComplexType>();
    #####:  730:  bitWidth = getDenseElementBitWidth(complexType.getElementType());
call    0 never executed
call    1 never executed
    #####:  731:}
        -:  732:
        -:  733:std::complex<APInt>
function _ZNK4mlir17DenseElementsAttr25ComplexIntElementIteratordeEv called 0 returned 0% blocks executed 0%
    #####:  734:DenseElementsAttr::ComplexIntElementIterator::operator*() const {
    #####:  735:  size_t storageWidth = getDenseElementStorageWidth(bitWidth);
branch  0 never executed
branch  1 never executed
    #####:  736:  size_t offset = getDataIndex() * storageWidth * 2;
branch  0 never executed
branch  1 never executed
    #####:  737:  return {readBits(getData(), offset, bitWidth),
call    0 never executed
    #####:  738:          readBits(getData(), offset + storageWidth, bitWidth)};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  739:}
        -:  740:
        -:  741://===----------------------------------------------------------------------===//
        -:  742:// DenseArrayAttr
        -:  743://===----------------------------------------------------------------------===//
        -:  744:
        -:  745:LogicalResult
function _ZN4mlir14DenseArrayAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_16RankedTensorTypeENS1_8ArrayRefIcEE called 16402547 returned 100% blocks executed 31%
 16402547:  746:DenseArrayAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  747:                       RankedTensorType type, ArrayRef<char> rawData) {
 16402547:  748:  if (type.getRank() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  749:    return emitError() << "expected rank 1 tensor type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 16402547:  750:  if (!type.getElementType().isIntOrIndexOrFloat())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  751:    return emitError() << "expected integer or floating point element type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 16402547:  752:  int64_t dataSize = rawData.size();
call    0 returned 100%
 16402547:  753:  int64_t size = type.getShape().front();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 16402547:  754:  if (type.getElementType().isInteger(1)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  755:    if (size != dataSize)
branch  0 never executed
branch  1 never executed
    #####:  756:      return emitError() << "expected " << size
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  757:                         << " bytes for i1 array but got " << dataSize;
call    0 never executed
call    1 never executed
 32805094:  758:  } else if (size * type.getElementTypeBitWidth() != dataSize * 8) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  759:    return emitError() << "expected data size (" << size << " elements, "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  760:                       << type.getElementTypeBitWidth()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  761:                       << " bits each) does not match: " << dataSize
call    0 never executed
call    1 never executed
    #####:  762:                       << " bytes";
call    0 never executed
        -:  763:  }
 16402547:  764:  return success();
        -:  765:}
        -:  766:
        -:  767:FailureOr<const bool *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIbEE called 0 returned 0% blocks executed 0%
    #####:  768:DenseArrayAttr::try_value_begin_impl(OverloadToken<bool>) const {
    #####:  769:  if (auto attr = dyn_cast<DenseBoolArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  770:    return attr.asArrayRef().begin();
call    0 never executed
    #####:  771:  return failure();
        -:  772:}
        -:  773:FailureOr<const int8_t *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIaEE called 0 returned 0% blocks executed 0%
    #####:  774:DenseArrayAttr::try_value_begin_impl(OverloadToken<int8_t>) const {
    #####:  775:  if (auto attr = dyn_cast<DenseI8ArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  776:    return attr.asArrayRef().begin();
call    0 never executed
    #####:  777:  return failure();
        -:  778:}
        -:  779:FailureOr<const int16_t *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIsEE called 0 returned 0% blocks executed 0%
    #####:  780:DenseArrayAttr::try_value_begin_impl(OverloadToken<int16_t>) const {
    #####:  781:  if (auto attr = dyn_cast<DenseI16ArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  782:    return attr.asArrayRef().begin();
call    0 never executed
    #####:  783:  return failure();
        -:  784:}
        -:  785:FailureOr<const int32_t *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIiEE called 44236 returned 100% blocks executed 83%
    44236:  786:DenseArrayAttr::try_value_begin_impl(OverloadToken<int32_t>) const {
    44236:  787:  if (auto attr = dyn_cast<DenseI32ArrayAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    44236:  788:    return attr.asArrayRef().begin();
call    0 returned 100%
    #####:  789:  return failure();
        -:  790:}
        -:  791:FailureOr<const int64_t *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIlEE called 51528 returned 100% blocks executed 100%
    51528:  792:DenseArrayAttr::try_value_begin_impl(OverloadToken<int64_t>) const {
    51528:  793:  if (auto attr = dyn_cast<DenseI64ArrayAttr>())
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
     7292:  794:    return attr.asArrayRef().begin();
call    0 returned 100%
    44236:  795:  return failure();
        -:  796:}
        -:  797:FailureOr<const float *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIfEE called 0 returned 0% blocks executed 0%
    #####:  798:DenseArrayAttr::try_value_begin_impl(OverloadToken<float>) const {
    #####:  799:  if (auto attr = dyn_cast<DenseF32ArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  800:    return attr.asArrayRef().begin();
call    0 never executed
    #####:  801:  return failure();
        -:  802:}
        -:  803:FailureOr<const double *>
function _ZNK4mlir14DenseArrayAttr20try_value_begin_implENS_6detail17ElementsAttrTraitIS0_E13OverloadTokenIdEE called 0 returned 0% blocks executed 0%
    #####:  804:DenseArrayAttr::try_value_begin_impl(OverloadToken<double>) const {
    #####:  805:  if (auto attr = dyn_cast<DenseF64ArrayAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  806:    return attr.asArrayRef().begin();
call    0 never executed
    #####:  807:  return failure();
        -:  808:}
        -:  809:
        -:  810:namespace {
        -:  811:/// Instantiations of this class provide utilities for interacting with native
        -:  812:/// data types in the context of DenseArrayAttr.
        -:  813:template <size_t width,
        -:  814:          IntegerType::SignednessSemantics signedness = IntegerType::Signless>
        -:  815:struct DenseArrayAttrIntUtil {
3996385642:  816:  static bool checkElementType(Type eltType) {
3996385011:  817:    auto type = eltType.dyn_cast<IntegerType>();
3996385011:  818:    if (!type || type.getWidth() != width)
   191474:  819:      return false;
3996191887*:  820:    return type.getSignedness() == signedness;
        -:  821:  }
------------------
_ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm64ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE:
function _ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm64ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE called 449855698 returned 100% blocks executed 100%
449855698:  816:  static bool checkElementType(Type eltType) {
call    0 returned 100%
449855668:  817:    auto type = eltType.dyn_cast<IntegerType>();
449855668:  818:    if (!type || type.getWidth() != width)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
    44234:  819:      return false;
449811372:  820:    return type.getSignedness() == signedness;
call    0 returned 100%
        -:  821:  }
------------------
_ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm32ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE:
function _ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm32ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE called 3546386298 returned 100% blocks executed 100%
3546386298:  816:  static bool checkElementType(Type eltType) {
call    0 returned 100%
3546385697:  817:    auto type = eltType.dyn_cast<IntegerType>();
3546385697:  818:    if (!type || type.getWidth() != width)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
     3594:  819:      return false;
3546380515:  820:    return type.getSignedness() == signedness;
call    0 returned 100%
        -:  821:  }
------------------
_ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm16ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE:
function _ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm16ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE called 47882 returned 100% blocks executed 75%
    47882:  816:  static bool checkElementType(Type eltType) {
call    0 returned 100%
    47882:  817:    auto type = eltType.dyn_cast<IntegerType>();
    47882:  818:    if (!type || type.getWidth() != width)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    47882:  819:      return false;
    #####:  820:    return type.getSignedness() == signedness;
call    0 never executed
        -:  821:  }
------------------
_ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm8ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE:
function _ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm8ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE called 47882 returned 100% blocks executed 75%
    47882:  816:  static bool checkElementType(Type eltType) {
call    0 returned 100%
    47882:  817:    auto type = eltType.dyn_cast<IntegerType>();
    47882:  818:    if (!type || type.getWidth() != width)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    47882:  819:      return false;
    #####:  820:    return type.getSignedness() == signedness;
call    0 never executed
        -:  821:  }
------------------
_ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm1ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE:
function _ZN12_GLOBAL__N_121DenseArrayAttrIntUtilILm1ELN4mlir11IntegerType19SignednessSemanticsE0EE16checkElementTypeENS1_4TypeE called 47882 returned 100% blocks executed 75%
    47882:  816:  static bool checkElementType(Type eltType) {
call    0 returned 100%
    47882:  817:    auto type = eltType.dyn_cast<IntegerType>();
    47882:  818:    if (!type || type.getWidth() != width)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    47882:  819:      return false;
    #####:  820:    return type.getSignedness() == signedness;
call    0 never executed
        -:  821:  }
------------------
        -:  822:
16402547*:  823:  static Type getElementType(MLIRContext *ctx) {
16402547*:  824:    return IntegerType::get(ctx, width, signedness);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
call    4 never executed
        -:  825:  }
        -:  826:
        -:  827:  template <typename T>
  469703*:  828:  static void printElement(raw_ostream &os, T value) {
  469703*:  829:    os << value;
        -:  830:  }
        -:  831:
        -:  832:  template <typename T>
  617503*:  833:  static ParseResult parseElement(AsmParser &parser, T &value) {
  617503*:  834:    return parser.parseInteger(value);
        -:  835:  }
        -:  836:};
        -:  837:template <typename T>
        -:  838:struct DenseArrayAttrUtil;
        -:  839:
        -:  840:/// Specialization for boolean elements to print 'true' and 'false' literals for
        -:  841:/// elements.
        -:  842:template <>
        -:  843:struct DenseArrayAttrUtil<bool> : public DenseArrayAttrIntUtil<1> {
    #####:  844:  static void printElement(raw_ostream &os, bool value) {
    #####:  845:    os << (value ? "true" : "false");
call    0 never executed
call    1 never executed
        -:  846:  }
        -:  847:};
        -:  848:
        -:  849:/// Specialization for 8-bit integers to ensure values are printed as integers
        -:  850:/// and not characters.
        -:  851:template <>
        -:  852:struct DenseArrayAttrUtil<int8_t> : public DenseArrayAttrIntUtil<8> {
    #####:  853:  static void printElement(raw_ostream &os, int8_t value) {
    #####:  854:    os << static_cast<int>(value);
        -:  855:  }
        -:  856:};
        -:  857:template <>
        -:  858:struct DenseArrayAttrUtil<int16_t> : public DenseArrayAttrIntUtil<16> {};
        -:  859:template <>
        -:  860:struct DenseArrayAttrUtil<int32_t> : public DenseArrayAttrIntUtil<32> {};
        -:  861:template <>
        -:  862:struct DenseArrayAttrUtil<int64_t> : public DenseArrayAttrIntUtil<64> {};
        -:  863:
        -:  864:/// Specialization for 32-bit floats.
        -:  865:template <>
        -:  866:struct DenseArrayAttrUtil<float> {
    #####:  867:  static bool checkElementType(Type eltType) { return eltType.isF32(); }
    #####:  868:  static Type getElementType(MLIRContext *ctx) { return Float32Type::get(ctx); }
call    0 never executed
    #####:  869:  static void printElement(raw_ostream &os, float value) { os << value; }
        -:  870:
        -:  871:  /// Parse a double and cast it to a float.
    #####:  872:  static ParseResult parseElement(AsmParser &parser, float &value) {
    #####:  873:    double doubleVal;
    #####:  874:    if (parser.parseFloat(doubleVal))
branch  0 never executed
branch  1 never executed
    #####:  875:      return failure();
    #####:  876:    value = doubleVal;
    #####:  877:    return success();
        -:  878:  }
        -:  879:};
        -:  880:
        -:  881:/// Specialization for 64-bit floats.
        -:  882:template <>
        -:  883:struct DenseArrayAttrUtil<double> {
    #####:  884:  static bool checkElementType(Type eltType) { return eltType.isF64(); }
    #####:  885:  static Type getElementType(MLIRContext *ctx) { return Float64Type::get(ctx); }
call    0 never executed
    #####:  886:  static void printElement(raw_ostream &os, float value) { os << value; }
    #####:  887:  static ParseResult parseElement(AsmParser &parser, double &value) {
    #####:  888:    return parser.parseFloat(value);
        -:  889:  }
        -:  890:};
        -:  891:} // namespace
        -:  892:
        -:  893:template <typename T>
  365849*:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
  365849*:  895:  print(printer.getStream());
  365849*:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIdE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIdE5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
    #####:  895:  print(printer.getStream());
call    0 never executed
call    1 never executed
    #####:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIfE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIfE5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
    #####:  895:  print(printer.getStream());
call    0 never executed
call    1 never executed
    #####:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIlE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIlE5printERNS_10AsmPrinterE called 364238 returned 100% blocks executed 100%
   364238:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
   364238:  895:  print(printer.getStream());
call    0 returned 100%
call    1 returned 100%
   364238:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIiE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIiE5printERNS_10AsmPrinterE called 1611 returned 100% blocks executed 100%
     1611:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
     1611:  895:  print(printer.getStream());
call    0 returned 100%
call    1 returned 100%
     1611:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIsE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIsE5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
    #####:  895:  print(printer.getStream());
call    0 never executed
call    1 never executed
    #####:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIaE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIaE5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
    #####:  895:  print(printer.getStream());
call    0 never executed
call    1 never executed
    #####:  896:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIbE5printERNS_10AsmPrinterE:
function _ZNK4mlir6detail18DenseArrayAttrImplIbE5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  894:void DenseArrayAttrImpl<T>::print(AsmPrinter &printer) const {
    #####:  895:  print(printer.getStream());
call    0 never executed
call    1 never executed
    #####:  896:}
------------------
        -:  897:
        -:  898:template <typename T>
  365849*:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
  835552*:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
  469703*:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
call    0 never executed
call    1 never executed
        -:  902:  });
  365849*:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIdE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIdE18printWithoutBracesERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
    #####:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
    #####:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIfE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIfE18printWithoutBracesERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
    #####:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
    #####:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIlE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIlE18printWithoutBracesERN4llvm11raw_ostreamE called 364238 returned 100% blocks executed 100%
   364238:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
   364238:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 returned 100%
call    1 returned 100%
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
   364238:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIiE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIiE18printWithoutBracesERN4llvm11raw_ostreamE called 1611 returned 100% blocks executed 100%
     1611:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
     1611:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 returned 100%
call    1 returned 100%
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
     1611:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIsE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIsE18printWithoutBracesERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
    #####:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
    #####:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIaE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIaE18printWithoutBracesERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
    #####:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
    #####:  903:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIbE18printWithoutBracesERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIbE18printWithoutBracesERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  899:void DenseArrayAttrImpl<T>::printWithoutBraces(raw_ostream &os) const {
    #####:  900:  llvm::interleaveComma(asArrayRef(), os, [&](T value) {
call    0 never executed
call    1 never executed
        -:  901:    DenseArrayAttrUtil<T>::printElement(os, value);
        -:  902:  });
    #####:  903:}
------------------
        -:  904:
        -:  905:template <typename T>
  365849*:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
  365849*:  907:  os << "[";
  365849*:  908:  printWithoutBraces(os);
  365849*:  909:  os << "]";
  365849*:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIdE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIdE5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
    #####:  907:  os << "[";
call    0 never executed
    #####:  908:  printWithoutBraces(os);
call    0 never executed
    #####:  909:  os << "]";
call    0 never executed
    #####:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIfE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIfE5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
    #####:  907:  os << "[";
call    0 never executed
    #####:  908:  printWithoutBraces(os);
call    0 never executed
    #####:  909:  os << "]";
call    0 never executed
    #####:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIlE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIlE5printERN4llvm11raw_ostreamE called 364238 returned 100% blocks executed 100%
   364238:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
   364238:  907:  os << "[";
call    0 returned 100%
   364238:  908:  printWithoutBraces(os);
call    0 returned 100%
   364238:  909:  os << "]";
call    0 returned 100%
   364238:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIiE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIiE5printERN4llvm11raw_ostreamE called 1611 returned 100% blocks executed 100%
     1611:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
     1611:  907:  os << "[";
call    0 returned 100%
     1611:  908:  printWithoutBraces(os);
call    0 returned 100%
     1611:  909:  os << "]";
call    0 returned 100%
     1611:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIsE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIsE5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
    #####:  907:  os << "[";
call    0 never executed
    #####:  908:  printWithoutBraces(os);
call    0 never executed
    #####:  909:  os << "]";
call    0 never executed
    #####:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIaE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIaE5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
    #####:  907:  os << "[";
call    0 never executed
    #####:  908:  printWithoutBraces(os);
call    0 never executed
    #####:  909:  os << "]";
call    0 never executed
    #####:  910:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIbE5printERN4llvm11raw_ostreamE:
function _ZNK4mlir6detail18DenseArrayAttrImplIbE5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  906:void DenseArrayAttrImpl<T>::print(raw_ostream &os) const {
    #####:  907:  os << "[";
call    0 never executed
    #####:  908:  printWithoutBraces(os);
call    0 never executed
    #####:  909:  os << "]";
call    0 never executed
    #####:  910:}
------------------
        -:  911:
        -:  912:/// Parse a DenseArrayAttr without the braces: `1, 2, 3`
        -:  913:template <typename T>
  366380*:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
        -:  915:                                                    Type odsType) {
  732760*:  916:  SmallVector<T> data;
  983883*:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
        -:  918:        T value;
  617503*:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
  617503*:  920:          return failure();
  617503*:  921:        data.push_back(value);
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
  617503*:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
  366380*:  925:  return get(parser.getContext(), data);
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIdE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIdE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIfE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIfE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIlE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIlE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 366380 returned 100% blocks executed 78%
   366380:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 returned 100%
        -:  915:                                                    Type odsType) {
   732760:  916:  SmallVector<T> data;
   366380:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
   366380:  925:  return get(parser.getContext(), data);
call    0 returned 100%
call    1 returned 100%
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIiE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIiE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIsE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIsE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIaE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIaE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIbE18parseWithoutBracesERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIbE18parseWithoutBracesERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  914:Attribute DenseArrayAttrImpl<T>::parseWithoutBraces(AsmParser &parser,
call    0 never executed
        -:  915:                                                    Type odsType) {
    #####:  916:  SmallVector<T> data;
    #####:  917:  if (failed(parser.parseCommaSeparatedList([&]() {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:        T value;
        -:  919:        if (DenseArrayAttrUtil<T>::parseElement(parser, value))
        -:  920:          return failure();
        -:  921:        data.push_back(value);
        -:  922:        return success();
        -:  923:      })))
    #####:  924:    return {};
    #####:  925:  return get(parser.getContext(), data);
call    0 never executed
call    1 never executed
        -:  926:}
------------------
        -:  927:
        -:  928:/// Parse a DenseArrayAttr: `[ 1, 2, 3 ]`
        -:  929:template <typename T>
  366380*:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
  366380*:  931:  if (parser.parseLSquare())
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
  366380*:  934:  if (succeeded(parser.parseOptionalRSquare()))
    #####:  935:    return get(parser.getContext(), {});
  366380*:  936:  Attribute result = parseWithoutBraces(parser, odsType);
  366380*:  937:  if (parser.parseRSquare())
    #####:  938:    return {};
  366380*:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIdE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIdE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIfE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIfE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIlE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIlE5parseERNS_9AsmParserENS_4TypeE called 366380 returned 100% blocks executed 64%
   366380:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
   366380:  931:  if (parser.parseLSquare())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
   366380:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
   366380:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 returned 100%
   366380:  937:  if (parser.parseRSquare())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  938:    return {};
   366380:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIiE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIiE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIsE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIsE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIaE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIaE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIbE5parseERNS_9AsmParserENS_4TypeE:
function _ZN4mlir6detail18DenseArrayAttrImplIbE5parseERNS_9AsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  930:Attribute DenseArrayAttrImpl<T>::parse(AsmParser &parser, Type odsType) {
    #####:  931:  if (parser.parseLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:    return {};
        -:  933:  // Handle empty list case.
    #####:  934:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  935:    return get(parser.getContext(), {});
call    0 never executed
call    1 never executed
    #####:  936:  Attribute result = parseWithoutBraces(parser, odsType);
call    0 never executed
    #####:  937:  if (parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return {};
    #####:  939:  return result;
        -:  940:}
------------------
        -:  941:
        -:  942:/// Conversion from DenseArrayAttr<T> to ArrayRef<T>.
        -:  943:template <typename T>
6216333635*:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
6216333635*:  945:  ArrayRef<char> raw = getRawData();
6216333635*:  946:  assert((raw.size() % sizeof(T)) == 0);
6216333635*:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
6216333635*:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIdEcvN4llvm8ArrayRefIdEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIdEcvN4llvm8ArrayRefIdEEEv called 0 returned 0% blocks executed 0%
    #####:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
    #####:  945:  ArrayRef<char> raw = getRawData();
branch  0 never executed
branch  1 never executed
    #####:  946:  assert((raw.size() % sizeof(T)) == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
    #####:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIfEcvN4llvm8ArrayRefIfEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIfEcvN4llvm8ArrayRefIfEEEv called 0 returned 0% blocks executed 0%
    #####:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
    #####:  945:  ArrayRef<char> raw = getRawData();
branch  0 never executed
branch  1 never executed
    #####:  946:  assert((raw.size() % sizeof(T)) == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
    #####:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIlEcvN4llvm8ArrayRefIlEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIlEcvN4llvm8ArrayRefIlEEEv called 303873553 returned 100% blocks executed 67%
303873553:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
303873553:  945:  ArrayRef<char> raw = getRawData();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
303873553*:  946:  assert((raw.size() % sizeof(T)) == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
303873553:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
303873553:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIiEcvN4llvm8ArrayRefIiEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIiEcvN4llvm8ArrayRefIiEEEv called 5912460082 returned 100% blocks executed 67%
5912460082:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
5912460082:  945:  ArrayRef<char> raw = getRawData();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
5912460082*:  946:  assert((raw.size() % sizeof(T)) == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
5912460082:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
5912460082:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIsEcvN4llvm8ArrayRefIsEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIsEcvN4llvm8ArrayRefIsEEEv called 0 returned 0% blocks executed 0%
    #####:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
    #####:  945:  ArrayRef<char> raw = getRawData();
branch  0 never executed
branch  1 never executed
    #####:  946:  assert((raw.size() % sizeof(T)) == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
    #####:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIaEcvN4llvm8ArrayRefIaEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIaEcvN4llvm8ArrayRefIaEEEv called 0 returned 0% blocks executed 0%
    #####:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
    #####:  945:  ArrayRef<char> raw = getRawData();
    #####:  946:  assert((raw.size() % sizeof(T)) == 0);
    #####:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
    #####:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
_ZNK4mlir6detail18DenseArrayAttrImplIbEcvN4llvm8ArrayRefIbEEEv:
function _ZNK4mlir6detail18DenseArrayAttrImplIbEcvN4llvm8ArrayRefIbEEEv called 0 returned 0% blocks executed 0%
    #####:  944:DenseArrayAttrImpl<T>::operator ArrayRef<T>() const {
    #####:  945:  ArrayRef<char> raw = getRawData();
    #####:  946:  assert((raw.size() % sizeof(T)) == 0);
    #####:  947:  return ArrayRef<T>(reinterpret_cast<const T *>(raw.data()),
    #####:  948:                     raw.size() / sizeof(T));
        -:  949:}
------------------
        -:  950:
        -:  951:/// Builds a DenseArrayAttr<T> from an ArrayRef<T>.
        -:  952:template <typename T>
16402547*:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
16402547*:  955:  auto shapedType = RankedTensorType::get(
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
16402547*:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
16402547*:  958:                                 content.size() * sizeof(T));
16402547*:  959:  return Base::get(context, shapedType, rawArray)
16402547*:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIdE3getEPNS_11MLIRContextEN4llvm8ArrayRefIdEE:
function _ZN4mlir6detail18DenseArrayAttrImplIdE3getEPNS_11MLIRContextEN4llvm8ArrayRefIdEE called 0 returned 0% blocks executed 0%
    #####:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
    #####:  955:  auto shapedType = RankedTensorType::get(
call    0 never executed
call    1 never executed
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
    #####:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 never executed
    #####:  958:                                 content.size() * sizeof(T));
call    0 never executed
    #####:  959:  return Base::get(context, shapedType, rawArray)
call    0 never executed
call    1 never executed
    #####:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIfE3getEPNS_11MLIRContextEN4llvm8ArrayRefIfEE:
function _ZN4mlir6detail18DenseArrayAttrImplIfE3getEPNS_11MLIRContextEN4llvm8ArrayRefIfEE called 0 returned 0% blocks executed 0%
    #####:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
    #####:  955:  auto shapedType = RankedTensorType::get(
call    0 never executed
call    1 never executed
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
    #####:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 never executed
    #####:  958:                                 content.size() * sizeof(T));
call    0 never executed
    #####:  959:  return Base::get(context, shapedType, rawArray)
call    0 never executed
call    1 never executed
    #####:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIlE3getEPNS_11MLIRContextEN4llvm8ArrayRefIlEE:
function _ZN4mlir6detail18DenseArrayAttrImplIlE3getEPNS_11MLIRContextEN4llvm8ArrayRefIlEE called 3623037 returned 100% blocks executed 100%
  3623037:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
  3623037:  955:  auto shapedType = RankedTensorType::get(
call    0 returned 100%
call    1 returned 100%
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
  3623037:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 returned 100%
  3623037:  958:                                 content.size() * sizeof(T));
call    0 returned 100%
  3623037:  959:  return Base::get(context, shapedType, rawArray)
call    0 returned 100%
call    1 returned 100%
  3623037:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIiE3getEPNS_11MLIRContextEN4llvm8ArrayRefIiEE:
function _ZN4mlir6detail18DenseArrayAttrImplIiE3getEPNS_11MLIRContextEN4llvm8ArrayRefIiEE called 12779510 returned 100% blocks executed 100%
 12779510:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
 12779510:  955:  auto shapedType = RankedTensorType::get(
call    0 returned 100%
call    1 returned 100%
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
 12779510:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 returned 100%
 12779510:  958:                                 content.size() * sizeof(T));
call    0 returned 100%
 12779510:  959:  return Base::get(context, shapedType, rawArray)
call    0 returned 100%
call    1 returned 100%
 12779510:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIsE3getEPNS_11MLIRContextEN4llvm8ArrayRefIsEE:
function _ZN4mlir6detail18DenseArrayAttrImplIsE3getEPNS_11MLIRContextEN4llvm8ArrayRefIsEE called 0 returned 0% blocks executed 0%
    #####:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
    #####:  955:  auto shapedType = RankedTensorType::get(
call    0 never executed
call    1 never executed
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
    #####:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 never executed
    #####:  958:                                 content.size() * sizeof(T));
call    0 never executed
    #####:  959:  return Base::get(context, shapedType, rawArray)
call    0 never executed
call    1 never executed
    #####:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIaE3getEPNS_11MLIRContextEN4llvm8ArrayRefIaEE:
function _ZN4mlir6detail18DenseArrayAttrImplIaE3getEPNS_11MLIRContextEN4llvm8ArrayRefIaEE called 0 returned 0% blocks executed 0%
    #####:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
    #####:  955:  auto shapedType = RankedTensorType::get(
call    0 never executed
call    1 never executed
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
    #####:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 never executed
        -:  958:                                 content.size() * sizeof(T));
    #####:  959:  return Base::get(context, shapedType, rawArray)
call    0 never executed
call    1 never executed
    #####:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIbE3getEPNS_11MLIRContextEN4llvm8ArrayRefIbEE:
function _ZN4mlir6detail18DenseArrayAttrImplIbE3getEPNS_11MLIRContextEN4llvm8ArrayRefIbEE called 0 returned 0% blocks executed 0%
    #####:  953:DenseArrayAttrImpl<T> DenseArrayAttrImpl<T>::get(MLIRContext *context,
        -:  954:                                                 ArrayRef<T> content) {
    #####:  955:  auto shapedType = RankedTensorType::get(
call    0 never executed
call    1 never executed
        -:  956:      content.size(), DenseArrayAttrUtil<T>::getElementType(context));
    #####:  957:  auto rawArray = ArrayRef<char>(reinterpret_cast<const char *>(content.data()),
call    0 never executed
        -:  958:                                 content.size() * sizeof(T));
    #####:  959:  return Base::get(context, shapedType, rawArray)
call    0 never executed
call    1 never executed
    #####:  960:      .template cast<DenseArrayAttrImpl<T>>();
        -:  961:}
------------------
        -:  962:
        -:  963:template <typename T>
3996379774*:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
3996379559*:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
3996385923*:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIdE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIdE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 never executed
    #####:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 never executed
branch  1 never executed
    #####:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 never executed
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIfE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIfE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 never executed
    #####:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 never executed
branch  1 never executed
    #####:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 never executed
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIlE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIlE7classofENS_9AttributeE called 449855449 returned 100% blocks executed 88%
449855449:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 returned 100%
449855438:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
449855711:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 returned 100%
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIiE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIiE7classofENS_9AttributeE called 3546380679 returned 100% blocks executed 88%
3546380679:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 returned 100%
3546380475:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
3546386566:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 returned 100%
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIsE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIsE7classofENS_9AttributeE called 47882 returned 100% blocks executed 88%
    47882:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 returned 100%
    47882:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    47882:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 returned 100%
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIaE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIaE7classofENS_9AttributeE called 47882 returned 100% blocks executed 88%
    47882:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 returned 100%
    47882:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    47882:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 returned 100%
    #####:  967:  return false;
        -:  968:}
------------------
_ZN4mlir6detail18DenseArrayAttrImplIbE7classofENS_9AttributeE:
function _ZN4mlir6detail18DenseArrayAttrImplIbE7classofENS_9AttributeE called 47882 returned 100% blocks executed 88%
    47882:  964:bool DenseArrayAttrImpl<T>::classof(Attribute attr) {
call    0 returned 100%
    47882:  965:  if (auto denseArray = attr.dyn_cast<DenseArrayAttr>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    47882:  966:    return DenseArrayAttrUtil<T>::checkElementType(denseArray.getElementType());
call    0 returned 100%
    #####:  967:  return false;
        -:  968:}
------------------
        -:  969:
        -:  970:namespace mlir {
        -:  971:namespace detail {
        -:  972:// Explicit instantiation for all the supported DenseArrayAttr.
        -:  973:template class DenseArrayAttrImpl<bool>;
        -:  974:template class DenseArrayAttrImpl<int8_t>;
        -:  975:template class DenseArrayAttrImpl<int16_t>;
        -:  976:template class DenseArrayAttrImpl<int32_t>;
        -:  977:template class DenseArrayAttrImpl<int64_t>;
        -:  978:template class DenseArrayAttrImpl<float>;
        -:  979:template class DenseArrayAttrImpl<double>;
        -:  980:} // namespace detail
        -:  981:} // namespace mlir
        -:  982:
        -:  983://===----------------------------------------------------------------------===//
        -:  984:// DenseElementsAttr
        -:  985://===----------------------------------------------------------------------===//
        -:  986:
        -:  987:/// Method for support type inquiry through isa, cast and dyn_cast.
function _ZN4mlir17DenseElementsAttr7classofENS_9AttributeE called 325311 returned 100% blocks executed 100%
   474189:  988:bool DenseElementsAttr::classof(Attribute attr) {
   474189:  989:  return attr.isa<DenseIntOrFPElementsAttr, DenseStringElementsAttr>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
        -:  990:}
        -:  991:
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefINS_9AttributeEEE called 2970335 returned 100% blocks executed 62%
  2970335:  992:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -:  993:                                         ArrayRef<Attribute> values) {
 3124684*:  994:  assert(hasSameElementsOrSplat(type, values));
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 never executed
        -:  995:
        -:  996:  // If the element type is not based on int/float/index, assume it is a string
        -:  997:  // type.
  2970335:  998:  Type eltType = type.getElementType();
call    0 returned 100%
  2970335:  999:  if (!eltType.isIntOrIndexOrFloat()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1000:    SmallVector<StringRef, 8> stringValues;
branch  0 never executed
branch  1 never executed
    #####: 1001:    stringValues.reserve(values.size());
branch  0 never executed
branch  1 never executed
    #####: 1002:    for (Attribute attr : values) {
branch  0 never executed
branch  1 never executed
    #####: 1003:      assert(attr.isa<StringAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1004:             "expected string value for non integer/index/float element");
    #####: 1005:      stringValues.push_back(attr.cast<StringAttr>().getValue());
call    0 never executed
call    1 never executed
        -: 1006:    }
    #####: 1007:    return get(type, stringValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1008:  }
        -: 1009:
        -: 1010:  // Otherwise, get the raw storage width to use for the allocation.
  2970335: 1011:  size_t bitWidth = getDenseElementBitWidth(eltType);
call    0 returned 100%
  2970335: 1012:  size_t storageBitWidth = getDenseElementStorageWidth(bitWidth);
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -: 1013:
        -: 1014:  // Compress the attribute values into a character buffer.
  2970335: 1015:  SmallVector<char, 8> data(
  2970335: 1016:      llvm::divideCeil(storageBitWidth * values.size(), CHAR_BIT));
call    0 returned 100%
  5940670: 1017:  APInt intVal;
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
 33038089: 1018:  for (unsigned i = 0, e = values.size(); i < e; ++i) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
 30067754: 1019:    if (auto floatAttr = values[i].dyn_cast<FloatAttr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 30% (fallthrough)
branch  4 taken 70%
 8924606*: 1020:      assert(floatAttr.getType() == eltType &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1021:             "expected float attribute type to equal element type");
  8924606: 1022:      intVal = floatAttr.getValue().bitcastToAPInt();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 returned 100%
        -: 1023:    } else {
 21143148: 1024:      auto intAttr = values[i].cast<IntegerAttr>();
call    0 returned 100%
21143148*: 1025:      assert(intAttr.getType() == eltType &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1026:             "expected integer attribute type to equal element type");
 42286296: 1027:      intVal = intAttr.getValue();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1028:    }
        -: 1029:
30067754*: 1030:    assert(intVal.getBitWidth() == bitWidth &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1031:           "expected value to have same bitwidth as element type");
 60135508: 1032:    writeBits(data.data(), i * storageBitWidth, intVal);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1033:  }
        -: 1034:
        -: 1035:  // Handle the special encoding of splat of bool.
  2970335: 1036:  if (values.size() == 1 && eltType.isInteger(1))
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
branch  3 taken 26% (fallthrough)
branch  4 taken 74%
  1139310: 1037:    data[0] = data[0] ? -1 : 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
        -: 1038:
  2970335: 1039:  return DenseIntOrFPElementsAttr::getRaw(type, data);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1040:}
        -: 1041:
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefIbEE called 491 returned 100% blocks executed 90%
      491: 1042:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -: 1043:                                         ArrayRef<bool> values) {
     970*: 1044:  assert(hasSameElementsOrSplat(type, values));
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
call    2 never executed
     491*: 1045:  assert(type.getElementType().isInteger(1));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1046:
      491: 1047:  std::vector<char> buff(llvm::divideCeil(values.size(), CHAR_BIT));
call    0 returned 100%
        -: 1048:
      491: 1049:  if (!values.empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      491: 1050:    bool isSplat = true;
      491: 1051:    bool firstValue = values[0];
     4716: 1052:    for (int i = 0, e = values.size(); i != e; ++i) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
     4225: 1053:      isSplat &= values[i] == firstValue;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     8450: 1054:      setBit(buff.data(), i, values[i]);
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 1055:    }
        -: 1056:
        -: 1057:    // Splat of bool is encoded as a byte with all-ones in it.
      491: 1058:    if (isSplat) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
      261: 1059:      buff.resize(1);
call    0 returned 100%
      286: 1060:      buff[0] = values[0] ? -1 : 0;
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -: 1061:    }
        -: 1062:  }
        -: 1063:
      491: 1064:  return DenseIntOrFPElementsAttr::getRaw(type, buff);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1065:}
        -: 1066:
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefINS2_9StringRefEEE called 0 returned 0% blocks executed 0%
    #####: 1067:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -: 1068:                                         ArrayRef<StringRef> values) {
    #####: 1069:  assert(!type.getElementType().isIntOrFloat());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1070:  return DenseStringElementsAttr::get(type, values);
call    0 never executed
        -: 1071:}
        -: 1072:
        -: 1073:/// Constructs a dense integer elements attribute from an array of APInt
        -: 1074:/// values. Each APInt value is expected to have the same bitwidth as the
        -: 1075:/// element type of 'type'.
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefINS2_5APIntEEE called 5422 returned 100% blocks executed 88%
     5422: 1076:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -: 1077:                                         ArrayRef<APInt> values) {
    5422*: 1078:  assert(type.getElementType().isIntOrIndex());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
   10056*: 1079:  assert(hasSameElementsOrSplat(type, values));
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
call    2 never executed
     5422: 1080:  size_t storageBitWidth = getDenseElementStorageWidth(type.getElementType());
call    0 returned 100%
     5422: 1081:  return DenseIntOrFPElementsAttr::getRaw(type, storageBitWidth, values);
call    0 returned 100%
        -: 1082:}
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefISt7complexINS2_5APIntEEEE called 0 returned 0% blocks executed 0%
    #####: 1083:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -: 1084:                                         ArrayRef<std::complex<APInt>> values) {
    #####: 1085:  ComplexType complex = type.getElementType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####: 1086:  assert(complex.getElementType().isa<IntegerType>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1087:  assert(hasSameElementsOrSplat(type, values));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1088:  size_t storageBitWidth = getDenseElementStorageWidth(complex) / 2;
call    0 never executed
    #####: 1089:  ArrayRef<APInt> intVals(reinterpret_cast<const APInt *>(values.data()),
    #####: 1090:                          values.size() * 2);
call    0 never executed
    #####: 1091:  return DenseIntOrFPElementsAttr::getRaw(type, storageBitWidth, intVals);
call    0 never executed
        -: 1092:}
        -: 1093:
        -: 1094:// Constructs a dense float elements attribute from an array of APFloat
        -: 1095:// values. Each APFloat value is expected to have the same bitwidth as the
        -: 1096:// element type of 'type'.
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefINS2_7APFloatEEE called 652 returned 100% blocks executed 88%
      652: 1097:DenseElementsAttr DenseElementsAttr::get(ShapedType type,
        -: 1098:                                         ArrayRef<APFloat> values) {
     652*: 1099:  assert(type.getElementType().isa<FloatType>());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
     994*: 1100:  assert(hasSameElementsOrSplat(type, values));
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
call    2 never executed
      652: 1101:  size_t storageBitWidth = getDenseElementStorageWidth(type.getElementType());
call    0 returned 100%
      652: 1102:  return DenseIntOrFPElementsAttr::getRaw(type, storageBitWidth, values);
call    0 returned 100%
        -: 1103:}
        -: 1104:DenseElementsAttr
function _ZN4mlir17DenseElementsAttr3getENS_10ShapedTypeEN4llvm8ArrayRefISt7complexINS2_7APFloatEEEE called 0 returned 0% blocks executed 0%
    #####: 1105:DenseElementsAttr::get(ShapedType type,
        -: 1106:                       ArrayRef<std::complex<APFloat>> values) {
    #####: 1107:  ComplexType complex = type.getElementType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####: 1108:  assert(complex.getElementType().isa<FloatType>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1109:  assert(hasSameElementsOrSplat(type, values));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1110:  ArrayRef<APFloat> apVals(reinterpret_cast<const APFloat *>(values.data()),
    #####: 1111:                           values.size() * 2);
call    0 never executed
    #####: 1112:  size_t storageBitWidth = getDenseElementStorageWidth(complex) / 2;
call    0 never executed
    #####: 1113:  return DenseIntOrFPElementsAttr::getRaw(type, storageBitWidth, apVals);
call    0 never executed
        -: 1114:}
        -: 1115:
        -: 1116:/// Construct a dense elements attribute from a raw buffer representing the
        -: 1117:/// data for this attribute. Users should generally not use this methods as
        -: 1118:/// the expected buffer format may not be a form the user expects.
        -: 1119:DenseElementsAttr
function _ZN4mlir17DenseElementsAttr16getFromRawBufferENS_10ShapedTypeEN4llvm8ArrayRefIcEE called 0 returned 0% blocks executed 0%
    #####: 1120:DenseElementsAttr::getFromRawBuffer(ShapedType type, ArrayRef<char> rawBuffer) {
    #####: 1121:  return DenseIntOrFPElementsAttr::getRaw(type, rawBuffer);
call    0 never executed
        -: 1122:}
        -: 1123:
        -: 1124:/// Returns true if the given buffer is a valid raw buffer for the given type.
function _ZN4mlir17DenseElementsAttr16isValidRawBufferENS_10ShapedTypeEN4llvm8ArrayRefIcEERb called 2980409 returned 100% blocks executed 100%
  2980409: 1125:bool DenseElementsAttr::isValidRawBuffer(ShapedType type,
        -: 1126:                                         ArrayRef<char> rawBuffer,
        -: 1127:                                         bool &detectedSplat) {
  2980409: 1128:  size_t storageWidth = getDenseElementStorageWidth(type.getElementType());
call    0 returned 100%
  2980409: 1129:  size_t rawBufferWidth = rawBuffer.size() * CHAR_BIT;
call    0 returned 100%
  2980409: 1130:  int64_t numElements = type.getNumElements();
call    0 returned 100%
        -: 1131:
        -: 1132:  // The initializer is always a splat if the result type has a single element.
  2980409: 1133:  detectedSplat = numElements == 1;
        -: 1134:
        -: 1135:  // Storage width of 1 is special as it is packed by the bit.
  2980409: 1136:  if (storageWidth == 1) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -: 1137:    // Check for a splat, or a buffer equal to the number of elements which
        -: 1138:    // consists of either all 0's or all 1's.
   748596: 1139:    if (rawBuffer.size() == 1) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
   731890: 1140:      auto rawByte = static_cast<uint8_t>(rawBuffer[0]);
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   731890: 1141:      if (rawByte == 0 || rawByte == 0xff) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   722385: 1142:        detectedSplat = true;
   722385: 1143:        return true;
        -: 1144:      }
        -: 1145:    }
        -: 1146:
        -: 1147:    // This is a valid non-splat buffer if it has the right size.
    26211: 1148:    return rawBufferWidth == llvm::alignTo<8>(numElements);
        -: 1149:  }
        -: 1150:
        -: 1151:  // All other types are 8-bit aligned, so we can just check the buffer width
        -: 1152:  // to know if only a single initializer element was passed in.
  2231813: 1153:  if (rawBufferWidth == storageWidth) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
  2100005: 1154:    detectedSplat = true;
  2100005: 1155:    return true;
        -: 1156:  }
        -: 1157:
        -: 1158:  // The raw buffer is valid if it has the right size.
   131808: 1159:  return rawBufferWidth == storageWidth * numElements;
        -: 1160:}
        -: 1161:
        -: 1162:/// Check the information for a C++ data type, check if this type is valid for
        -: 1163:/// the current attribute. This method is used to verify specific type
        -: 1164:/// invariants that the templatized 'getValues' method cannot.
function _ZL17isValidIntOrFloatN4mlir4TypeElbb called 2386 returned 100% blocks executed 67%
     2386: 1165:static bool isValidIntOrFloat(Type type, int64_t dataEltSize, bool isInt,
        -: 1166:                              bool isSigned) {
        -: 1167:  // Make sure that the data element size is the same as the type element width.
     2386: 1168:  if (getDenseElementBitWidth(type) !=
call    0 returned 100%
     2386: 1169:      static_cast<size_t>(dataEltSize * CHAR_BIT))
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 1170:    return false;
        -: 1171:
        -: 1172:  // Check that the element type is either float or integer or index.
     2368: 1173:  if (!isInt)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1174:    return type.isa<FloatType>();
call    0 never executed
     2368: 1175:  if (type.isIndex())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -: 1176:    return true;
        -: 1177:
     2366: 1178:  auto intType = type.dyn_cast<IntegerType>();
call    0 returned 100%
     2366: 1179:  if (!intType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1180:    return false;
        -: 1181:
        -: 1182:  // Make sure signedness semantics is consistent.
     2366: 1183:  if (intType.isSignless())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1184:    return true;
    #####: 1185:  return intType.isSigned() ? isSigned : !isSigned;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1186:}
        -: 1187:
        -: 1188:/// Defaults down the subclass implementation.
function _ZN4mlir17DenseElementsAttr13getRawComplexENS_10ShapedTypeEN4llvm8ArrayRefIcEElbb called 0 returned 0% blocks executed 0%
    #####: 1189:DenseElementsAttr DenseElementsAttr::getRawComplex(ShapedType type,
        -: 1190:                                                   ArrayRef<char> data,
        -: 1191:                                                   int64_t dataEltSize,
        -: 1192:                                                   bool isInt, bool isSigned) {
    #####: 1193:  return DenseIntOrFPElementsAttr::getRawComplex(type, data, dataEltSize, isInt,
    #####: 1194:                                                 isSigned);
call    0 never executed
        -: 1195:}
function _ZN4mlir17DenseElementsAttr16getRawIntOrFloatENS_10ShapedTypeEN4llvm8ArrayRefIcEElbb called 2362 returned 100% blocks executed 100%
     2362: 1196:DenseElementsAttr DenseElementsAttr::getRawIntOrFloat(ShapedType type,
        -: 1197:                                                      ArrayRef<char> data,
        -: 1198:                                                      int64_t dataEltSize,
        -: 1199:                                                      bool isInt,
        -: 1200:                                                      bool isSigned) {
     2362: 1201:  return DenseIntOrFPElementsAttr::getRawIntOrFloat(type, data, dataEltSize,
     2362: 1202:                                                    isInt, isSigned);
call    0 returned 100%
        -: 1203:}
        -: 1204:
function _ZNK4mlir17DenseElementsAttr17isValidIntOrFloatElbb called 24 returned 100% blocks executed 100%
       24: 1205:bool DenseElementsAttr::isValidIntOrFloat(int64_t dataEltSize, bool isInt,
        -: 1206:                                          bool isSigned) const {
       72: 1207:  return ::isValidIntOrFloat(getElementType(), dataEltSize, isInt, isSigned);
        -: 1208:}
function _ZNK4mlir17DenseElementsAttr14isValidComplexElbb called 0 returned 0% blocks executed 0%
    #####: 1209:bool DenseElementsAttr::isValidComplex(int64_t dataEltSize, bool isInt,
        -: 1210:                                       bool isSigned) const {
    #####: 1211:  return ::isValidIntOrFloat(
call    0 never executed
    #####: 1212:      getElementType().cast<ComplexType>().getElementType(), dataEltSize / 2,
call    0 never executed
    #####: 1213:      isInt, isSigned);
        -: 1214:}
        -: 1215:
        -: 1216:/// Returns true if this attribute corresponds to a splat, i.e. if all element
        -: 1217:/// values are the same.
function _ZNK4mlir17DenseElementsAttr7isSplatEv called 2280458 returned 100% blocks executed 100%
 4675116*: 1218:bool DenseElementsAttr::isSplat() const {
     922*: 1219:  return static_cast<DenseElementsAttributeStorage *>(impl)->isSplat;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 returned 100%
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 returned 100%
call   23 never executed
call   24 never executed
call   25 returned 100%
call   26 returned 100%
call   27 returned 100%
        -: 1220:}
        -: 1221:
        -: 1222:/// Return if the given complex type has an integer element type.
function _ZL18isComplexOfIntTypeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1223:static bool isComplexOfIntType(Type type) {
    #####: 1224:  return type.cast<ComplexType>().getElementType().isa<IntegerType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1225:}
        -: 1226:
function _ZNK4mlir17DenseElementsAttr22tryGetComplexIntValuesEv called 0 returned 0% blocks executed 0%
    #####: 1227:auto DenseElementsAttr::tryGetComplexIntValues() const
        -: 1228:    -> FailureOr<iterator_range_impl<ComplexIntElementIterator>> {
    #####: 1229:  if (!isComplexOfIntType(getElementType()))
branch  0 never executed
branch  1 never executed
    #####: 1230:    return failure();
    #####: 1231:  return iterator_range_impl<ComplexIntElementIterator>(
call    0 never executed
        -: 1232:      getType(), ComplexIntElementIterator(*this, 0),
    #####: 1233:      ComplexIntElementIterator(*this, getNumElements()));
        -: 1234:}
        -: 1235:
function _ZNK4mlir17DenseElementsAttr17tryGetFloatValuesEv called 324901 returned 100% blocks executed 89%
   324901: 1236:auto DenseElementsAttr::tryGetFloatValues() const
        -: 1237:    -> FailureOr<iterator_range_impl<FloatElementIterator>> {
   974703: 1238:  auto eltTy = getElementType().dyn_cast<FloatType>();
   324901: 1239:  if (!eltTy)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1240:    return failure();
   324901: 1241:  const auto &elementSemantics = eltTy.getFloatSemantics();
call    0 returned 100%
   324901: 1242:  return iterator_range_impl<FloatElementIterator>(
call    0 returned 100%
call    1 returned 100%
        -: 1243:      getType(), FloatElementIterator(elementSemantics, raw_int_begin()),
   324901: 1244:      FloatElementIterator(elementSemantics, raw_int_end()));
        -: 1245:}
        -: 1246:
function _ZNK4mlir17DenseElementsAttr24tryGetComplexFloatValuesEv called 0 returned 0% blocks executed 0%
    #####: 1247:auto DenseElementsAttr::tryGetComplexFloatValues() const
        -: 1248:    -> FailureOr<iterator_range_impl<ComplexFloatElementIterator>> {
    #####: 1249:  auto complexTy = getElementType().dyn_cast<ComplexType>();
    #####: 1250:  if (!complexTy)
branch  0 never executed
branch  1 never executed
    #####: 1251:    return failure();
    #####: 1252:  auto eltTy = complexTy.getElementType().dyn_cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1253:  if (!eltTy)
branch  0 never executed
branch  1 never executed
    #####: 1254:    return failure();
    #####: 1255:  const auto &semantics = eltTy.getFloatSemantics();
call    0 never executed
    #####: 1256:  return iterator_range_impl<ComplexFloatElementIterator>(
call    0 never executed
        -: 1257:      getType(), {semantics, {*this, 0}},
    #####: 1258:      {semantics, {*this, static_cast<size_t>(getNumElements())}});
        -: 1259:}
        -: 1260:
        -: 1261:/// Return the raw storage data held by this attribute.
function _ZNK4mlir17DenseElementsAttr10getRawDataEv called 17793 returned 100% blocks executed 100%
 2412682*: 1262:ArrayRef<char> DenseElementsAttr::getRawData() const {
 2322736*: 1263:  return static_cast<DenseIntOrFPElementsAttrStorage *>(impl)->data;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 returned 100%
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 returned 100%
call   20 never executed
call   21 returned 100%
        -: 1264:}
        -: 1265:
function _ZNK4mlir17DenseElementsAttr16getRawStringDataEv called 0 returned 0% blocks executed 0%
    #####: 1266:ArrayRef<StringRef> DenseElementsAttr::getRawStringData() const {
    #####: 1267:  return static_cast<DenseStringElementsAttrStorage *>(impl)->data;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1268:}
        -: 1269:
        -: 1270:/// Return a new DenseElementsAttr that has the same data as the current
        -: 1271:/// attribute, but has been reshaped to 'newType'. The new type must have the
        -: 1272:/// same total number of elements as well as element type.
function _ZN4mlir17DenseElementsAttr7reshapeENS_10ShapedTypeE called 1681 returned 100% blocks executed 83%
     1681: 1273:DenseElementsAttr DenseElementsAttr::reshape(ShapedType newType) {
     1681: 1274:  ShapedType curType = getType();
     1681: 1275:  if (curType == newType)
      534: 1276:    return *this;
        -: 1277:
    1147*: 1278:  assert(newType.getElementType() == curType.getElementType() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1279:         "expected the same element type");
    1147*: 1280:  assert(newType.getNumElements() == curType.getNumElements() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1281:         "expected the same number of elements");
     1147: 1282:  return DenseIntOrFPElementsAttr::getRaw(newType, getRawData());
call    0 returned 100%
        -: 1283:}
        -: 1284:
function _ZN4mlir17DenseElementsAttr11resizeSplatENS_10ShapedTypeE called 0 returned 0% blocks executed 0%
    #####: 1285:DenseElementsAttr DenseElementsAttr::resizeSplat(ShapedType newType) {
    #####: 1286:  assert(isSplat() && "expected a splat type");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1287:
    #####: 1288:  ShapedType curType = getType();
    #####: 1289:  if (curType == newType)
    #####: 1290:    return *this;
        -: 1291:
    #####: 1292:  assert(newType.getElementType() == curType.getElementType() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1293:         "expected the same element type");
    #####: 1294:  return DenseIntOrFPElementsAttr::getRaw(newType, getRawData());
call    0 never executed
        -: 1295:}
        -: 1296:
        -: 1297:/// Return a new DenseElementsAttr that has the same data as the current
        -: 1298:/// attribute, but has bitcast elements such that it is now 'newType'. The new
        -: 1299:/// type must have the same shape and element types of the same bitwidth as the
        -: 1300:/// current type.
function _ZN4mlir17DenseElementsAttr7bitcastENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 1301:DenseElementsAttr DenseElementsAttr::bitcast(Type newElType) {
    #####: 1302:  ShapedType curType = getType();
    #####: 1303:  Type curElType = curType.getElementType();
    #####: 1304:  if (curElType == newElType)
branch  0 never executed
branch  1 never executed
    #####: 1305:    return *this;
        -: 1306:
    #####: 1307:  assert(getDenseElementBitWidth(newElType) ==
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1308:             getDenseElementBitWidth(curElType) &&
        -: 1309:         "expected element types with the same bitwidth");
    #####: 1310:  return DenseIntOrFPElementsAttr::getRaw(curType.clone(newElType),
    #####: 1311:                                          getRawData());
call    0 never executed
call    1 never executed
        -: 1312:}
        -: 1313:
        -: 1314:DenseElementsAttr
function _ZNK4mlir17DenseElementsAttr9mapValuesENS_4TypeEN4llvm12function_refIFNS2_5APIntERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1315:DenseElementsAttr::mapValues(Type newElementType,
        -: 1316:                             function_ref<APInt(const APInt &)> mapping) const {
    #####: 1317:  return cast<DenseIntElementsAttr>().mapValues(newElementType, mapping);
call    0 never executed
call    1 never executed
        -: 1318:}
        -: 1319:
function _ZNK4mlir17DenseElementsAttr9mapValuesENS_4TypeEN4llvm12function_refIFNS2_5APIntERKNS2_7APFloatEEEE called 0 returned 0% blocks executed 0%
    #####: 1320:DenseElementsAttr DenseElementsAttr::mapValues(
        -: 1321:    Type newElementType, function_ref<APInt(const APFloat &)> mapping) const {
    #####: 1322:  return cast<DenseFPElementsAttr>().mapValues(newElementType, mapping);
call    0 never executed
call    1 never executed
        -: 1323:}
        -: 1324:
function _ZNK4mlir17DenseElementsAttr7getTypeEv called 1981849 returned 100% blocks executed 100%
78881579*: 1325:ShapedType DenseElementsAttr::getType() const {
  326933*: 1326:  return static_cast<const DenseElementsAttributeStorage *>(impl)->type;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 taken 32% (fallthrough)
branch  4 taken 68%
call    5 never executed
call    6 never executed
        -: 1327:}
        -: 1328:
function _ZNK4mlir17DenseElementsAttr14getElementTypeEv called 827608 returned 100% blocks executed 100%
 3535784*: 1329:Type DenseElementsAttr::getElementType() const {
 3535784*: 1330:  return getType().getElementType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 returned 100%
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 returned 100%
call   12 returned 100%
call   13 never executed
call   14 never executed
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
        -: 1331:}
        -: 1332:
function _ZNK4mlir17DenseElementsAttr14getNumElementsEv called 860930 returned 100% blocks executed 100%
 1186305*: 1333:int64_t DenseElementsAttr::getNumElements() const {
 1186305*: 1334:  return getType().getNumElements();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 returned 100%
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
branch 22 never executed
branch 23 never executed
call   24 never executed
branch 25 never executed
branch 26 never executed
call   27 never executed
branch 28 never executed
branch 29 never executed
call   30 never executed
branch 31 never executed
branch 32 never executed
call   33 never executed
branch 34 never executed
branch 35 never executed
call   36 never executed
branch 37 never executed
branch 38 never executed
call   39 never executed
branch 40 never executed
branch 41 never executed
call   42 never executed
branch 43 never executed
branch 44 never executed
call   45 never executed
branch 46 never executed
branch 47 never executed
call   48 never executed
branch 49 never executed
branch 50 never executed
call   51 never executed
branch 52 never executed
branch 53 never executed
call   54 never executed
branch 55 never executed
branch 56 never executed
call   57 never executed
branch 58 never executed
branch 59 never executed
call   60 returned 100%
branch 61 taken 0% (fallthrough)
branch 62 taken 100%
call   63 never executed
branch 64 never executed
branch 65 never executed
call   66 never executed
branch 67 never executed
branch 68 never executed
call   69 never executed
branch 70 never executed
branch 71 never executed
call   72 returned 100%
branch 73 taken 0% (fallthrough)
branch 74 taken 100%
call   75 never executed
branch 76 never executed
branch 77 never executed
call   78 never executed
branch 79 never executed
branch 80 never executed
call   81 never executed
branch 82 never executed
branch 83 never executed
call   84 returned 100%
call   85 returned 100%
call   86 returned 100%
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 returned 100%
call   92 returned 100%
        -: 1335:}
        -: 1336:
        -: 1337://===----------------------------------------------------------------------===//
        -: 1338:// DenseIntOrFPElementsAttr
        -: 1339://===----------------------------------------------------------------------===//
        -: 1340:
        -: 1341:/// Utility method to write a range of APInt values to a buffer.
        -: 1342:template <typename APRangeT>
     6074: 1343:static void writeAPIntsToBuffer(size_t storageWidth, std::vector<char> &data,
        -: 1344:                                APRangeT &&values) {
     6074: 1345:  size_t numValues = llvm::size(values);
     6074: 1346:  data.resize(llvm::divideCeil(storageWidth * numValues, CHAR_BIT));
     6074: 1347:  size_t offset = 0;
   633494: 1348:  for (auto it = values.begin(), e = values.end(); it != e;
   137760: 1349:       ++it, offset += storageWidth) {
  627420*: 1350:    assert((*it).getBitWidth() <= storageWidth);
   627420: 1351:    writeBits(data.data(), offset, *it);
        -: 1352:  }
        -: 1353:
        -: 1354:  // Handle the special encoding of splat of a boolean.
     6384: 1355:  if (numValues == 1 && (*values.begin()).getBitWidth() == 1)
      93*: 1356:    data[0] = data[0] ? -1 : 0;
     6074: 1357:}
------------------
_Z19writeAPIntsToBufferIRN4llvm8ArrayRefINS0_5APIntEEEEvmRSt6vectorIcSaIcEEOT_:
function _Z19writeAPIntsToBufferIRN4llvm8ArrayRefINS0_5APIntEEEEvmRSt6vectorIcSaIcEEOT_ called 5422 returned 100% blocks executed 79%
     5422: 1343:static void writeAPIntsToBuffer(size_t storageWidth, std::vector<char> &data,
        -: 1344:                                APRangeT &&values) {
     5422: 1345:  size_t numValues = llvm::size(values);
call    0 returned 100%
     5422: 1346:  data.resize(llvm::divideCeil(storageWidth * numValues, CHAR_BIT));
call    0 returned 100%
     5422: 1347:  size_t offset = 0;
   495082: 1348:  for (auto it = values.begin(), e = values.end(); it != e;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 1349:       ++it, offset += storageWidth) {
  489660*: 1350:    assert((*it).getBitWidth() <= storageWidth);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   489660: 1351:    writeBits(data.data(), offset, *it);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1352:  }
        -: 1353:
        -: 1354:  // Handle the special encoding of splat of a boolean.
     5422: 1355:  if (numValues == 1 && (*values.begin()).getBitWidth() == 1)
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
branch  2 taken 8% (fallthrough)
branch  3 taken 92%
       93: 1356:    data[0] = data[0] ? -1 : 0;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     5422: 1357:}
------------------
_Z19writeAPIntsToBufferIN4llvm14iterator_rangeINS0_15mapped_iteratorIPKNS0_7APFloatEZN4mlir24DenseIntOrFPElementsAttr6getRawENS6_10ShapedTypeEmNS0_8ArrayRefIS3_EEEUlRS4_E_NS0_5APIntEEEEEEvmRSt6vectorIcSaIcEEOT_:
function _Z19writeAPIntsToBufferIN4llvm14iterator_rangeINS0_15mapped_iteratorIPKNS0_7APFloatEZN4mlir24DenseIntOrFPElementsAttr6getRawENS6_10ShapedTypeEmNS0_8ArrayRefIS3_EEEUlRS4_E_NS0_5APIntEEEEEEvmRSt6vectorIcSaIcEEOT_ called 652 returned 100% blocks executed 64%
      652: 1343:static void writeAPIntsToBuffer(size_t storageWidth, std::vector<char> &data,
        -: 1344:                                APRangeT &&values) {
      652: 1345:  size_t numValues = llvm::size(values);
call    0 returned 100%
      652: 1346:  data.resize(llvm::divideCeil(storageWidth * numValues, CHAR_BIT));
call    0 returned 100%
      652: 1347:  size_t offset = 0;
   138412: 1348:  for (auto it = values.begin(), e = values.end(); it != e;
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   137760: 1349:       ++it, offset += storageWidth) {
  137760*: 1350:    assert((*it).getBitWidth() <= storageWidth);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
   137760: 1351:    writeBits(data.data(), offset, *it);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1352:  }
        -: 1353:
        -: 1354:  // Handle the special encoding of splat of a boolean.
      962: 1355:  if (numValues == 1 && (*values.begin()).getBitWidth() == 1)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 48% (fallthrough)
branch  6 taken 52%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
    #####: 1356:    data[0] = data[0] ? -1 : 0;
branch  0 never executed
branch  1 never executed
      652: 1357:}
------------------
        -: 1358:
        -: 1359:/// Constructs a dense elements attribute from an array of raw APFloat values.
        -: 1360:/// Each APFloat value is expected to have the same bitwidth as the element
        -: 1361:/// type of 'type'. 'type' must be a vector or tensor with static shape.
function _ZN4mlir24DenseIntOrFPElementsAttr6getRawENS_10ShapedTypeEmN4llvm8ArrayRefINS2_7APFloatEEE called 652 returned 100% blocks executed 100%
      652: 1362:DenseElementsAttr DenseIntOrFPElementsAttr::getRaw(ShapedType type,
        -: 1363:                                                   size_t storageWidth,
        -: 1364:                                                   ArrayRef<APFloat> values) {
      652: 1365:  std::vector<char> data;
call    0 returned 100%
   275830: 1366:  auto unwrapFloat = [](const APFloat &val) { return val.bitcastToAPInt(); };
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      652: 1367:  writeAPIntsToBuffer(storageWidth, data, llvm::map_range(values, unwrapFloat));
call    0 returned 100%
      652: 1368:  return DenseIntOrFPElementsAttr::getRaw(type, data);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1369:}
        -: 1370:
        -: 1371:/// Constructs a dense elements attribute from an array of raw APInt values.
        -: 1372:/// Each APInt value is expected to have the same bitwidth as the element type
        -: 1373:/// of 'type'.
function _ZN4mlir24DenseIntOrFPElementsAttr6getRawENS_10ShapedTypeEmN4llvm8ArrayRefINS2_5APIntEEE called 5422 returned 100% blocks executed 100%
     5422: 1374:DenseElementsAttr DenseIntOrFPElementsAttr::getRaw(ShapedType type,
        -: 1375:                                                   size_t storageWidth,
        -: 1376:                                                   ArrayRef<APInt> values) {
     5422: 1377:  std::vector<char> data;
call    0 returned 100%
     5422: 1378:  writeAPIntsToBuffer(storageWidth, data, values);
call    0 returned 100%
     5422: 1379:  return DenseIntOrFPElementsAttr::getRaw(type, data);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1380:}
        -: 1381:
function _ZN4mlir24DenseIntOrFPElementsAttr6getRawENS_10ShapedTypeEN4llvm8ArrayRefIcEE called 2980409 returned 100% blocks executed 78%
  2980409: 1382:DenseElementsAttr DenseIntOrFPElementsAttr::getRaw(ShapedType type,
        -: 1383:                                                   ArrayRef<char> data) {
 2980409*: 1384:  assert(type.hasStaticShape() && "type must have static shape");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
  2980409: 1385:  bool isSplat = false;
  2980409: 1386:  bool isValid = isValidRawBuffer(type, data, isSplat);
call    0 returned 100%
 2980409*: 1387:  assert(isValid);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  2980409: 1388:  (void)isValid;
  2980409: 1389:  return Base::get(type.getContext(), type, data, isSplat);
call    0 returned 100%
call    1 returned 100%
        -: 1390:}
        -: 1391:
        -: 1392:/// Overload of the raw 'get' method that asserts that the given type is of
        -: 1393:/// complex type. This method is used to verify type invariants that the
        -: 1394:/// templatized 'get' method cannot.
function _ZN4mlir24DenseIntOrFPElementsAttr13getRawComplexENS_10ShapedTypeEN4llvm8ArrayRefIcEElbb called 0 returned 0% blocks executed 0%
    #####: 1395:DenseElementsAttr DenseIntOrFPElementsAttr::getRawComplex(ShapedType type,
        -: 1396:                                                          ArrayRef<char> data,
        -: 1397:                                                          int64_t dataEltSize,
        -: 1398:                                                          bool isInt,
        -: 1399:                                                          bool isSigned) {
    #####: 1400:  assert(::isValidIntOrFloat(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1401:      type.getElementType().cast<ComplexType>().getElementType(),
        -: 1402:      dataEltSize / 2, isInt, isSigned));
        -: 1403:
    #####: 1404:  int64_t numElements = data.size() / dataEltSize;
branch  0 never executed
branch  1 never executed
    #####: 1405:  (void)numElements;
    #####: 1406:  assert(numElements == 1 || numElements == type.getNumElements());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1407:  return getRaw(type, data);
call    0 never executed
        -: 1408:}
        -: 1409:
        -: 1410:/// Overload of the 'getRaw' method that asserts that the given type is of
        -: 1411:/// integer type. This method is used to verify type invariants that the
        -: 1412:/// templatized 'get' method cannot.
        -: 1413:DenseElementsAttr
function _ZN4mlir24DenseIntOrFPElementsAttr16getRawIntOrFloatENS_10ShapedTypeEN4llvm8ArrayRefIcEElbb called 2362 returned 100% blocks executed 80%
     2362: 1414:DenseIntOrFPElementsAttr::getRawIntOrFloat(ShapedType type, ArrayRef<char> data,
        -: 1415:                                           int64_t dataEltSize, bool isInt,
        -: 1416:                                           bool isSigned) {
    2362*: 1417:  assert(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1418:      ::isValidIntOrFloat(type.getElementType(), dataEltSize, isInt, isSigned));
        -: 1419:
     2362: 1420:  int64_t numElements = data.size() / dataEltSize;
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
    2362*: 1421:  assert(numElements == 1 || numElements == type.getNumElements());
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
     2362: 1422:  (void)numElements;
     2362: 1423:  return getRaw(type, data);
call    0 returned 100%
        -: 1424:}
        -: 1425:
function _ZN4mlir24DenseIntOrFPElementsAttr31convertEndianOfCharForBEmachineEPKcPcmm called 0 returned 0% blocks executed 0%
    #####: 1426:void DenseIntOrFPElementsAttr::convertEndianOfCharForBEmachine(
        -: 1427:    const char *inRawData, char *outRawData, size_t elementBitWidth,
        -: 1428:    size_t numElements) {
    #####: 1429:  using llvm::support::ulittle16_t;
    #####: 1430:  using llvm::support::ulittle32_t;
    #####: 1431:  using llvm::support::ulittle64_t;
        -: 1432:
    #####: 1433:  assert(llvm::support::endian::system_endianness() == // NOLINT
        -: 1434:         llvm::support::endianness::big);              // NOLINT
        -: 1435:  // NOLINT to avoid warning message about replacing by static_assert()
        -: 1436:
        -: 1437:  // Following std::copy_n always converts endianness on BE machine.
        -: 1438:  switch (elementBitWidth) {
        -: 1439:  case 16: {
        -: 1440:    const ulittle16_t *inRawDataPos =
        -: 1441:        reinterpret_cast<const ulittle16_t *>(inRawData);
        -: 1442:    uint16_t *outDataPos = reinterpret_cast<uint16_t *>(outRawData);
        -: 1443:    std::copy_n(inRawDataPos, numElements, outDataPos);
        -: 1444:    break;
        -: 1445:  }
        -: 1446:  case 32: {
        -: 1447:    const ulittle32_t *inRawDataPos =
        -: 1448:        reinterpret_cast<const ulittle32_t *>(inRawData);
        -: 1449:    uint32_t *outDataPos = reinterpret_cast<uint32_t *>(outRawData);
        -: 1450:    std::copy_n(inRawDataPos, numElements, outDataPos);
        -: 1451:    break;
        -: 1452:  }
        -: 1453:  case 64: {
        -: 1454:    const ulittle64_t *inRawDataPos =
        -: 1455:        reinterpret_cast<const ulittle64_t *>(inRawData);
        -: 1456:    uint64_t *outDataPos = reinterpret_cast<uint64_t *>(outRawData);
        -: 1457:    std::copy_n(inRawDataPos, numElements, outDataPos);
        -: 1458:    break;
        -: 1459:  }
        -: 1460:  default: {
        -: 1461:    size_t nBytes = elementBitWidth / CHAR_BIT;
        -: 1462:    for (size_t i = 0; i < nBytes; i++)
        -: 1463:      std::copy_n(inRawData + (nBytes - 1 - i), 1, outRawData + i);
        -: 1464:    break;
        -: 1465:  }
        -: 1466:  }
        -: 1467:}
        -: 1468:
function _ZN4mlir24DenseIntOrFPElementsAttr35convertEndianOfArrayRefForBEmachineEN4llvm8ArrayRefIcEENS1_15MutableArrayRefIcEENS_10ShapedTypeE called 0 returned 0% blocks executed 0%
    #####: 1469:void DenseIntOrFPElementsAttr::convertEndianOfArrayRefForBEmachine(
        -: 1470:    ArrayRef<char> inRawData, MutableArrayRef<char> outRawData,
        -: 1471:    ShapedType type) {
    #####: 1472:  size_t numElements = type.getNumElements();
call    0 never executed
    #####: 1473:  Type elementType = type.getElementType();
call    0 never executed
    #####: 1474:  if (ComplexType complexTy = elementType.dyn_cast<ComplexType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1475:    elementType = complexTy.getElementType();
call    0 never executed
    #####: 1476:    numElements = numElements * 2;
        -: 1477:  }
    #####: 1478:  size_t elementBitWidth = getDenseElementStorageWidth(elementType);
call    0 never executed
    #####: 1479:  assert(numElements * elementBitWidth == inRawData.size() * CHAR_BIT &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1480:         inRawData.size() <= outRawData.size());
    #####: 1481:  if (elementBitWidth <= CHAR_BIT)
branch  0 never executed
branch  1 never executed
    #####: 1482:    std::memcpy(outRawData.begin(), inRawData.begin(), inRawData.size());
        -: 1483:  else
    #####: 1484:    convertEndianOfCharForBEmachine(inRawData.begin(), outRawData.begin(),
        -: 1485:                                    elementBitWidth, numElements);
    #####: 1486:}
        -: 1487:
        -: 1488://===----------------------------------------------------------------------===//
        -: 1489:// DenseFPElementsAttr
        -: 1490://===----------------------------------------------------------------------===//
        -: 1491:
        -: 1492:template <typename Fn, typename Attr>
    #####: 1493:static ShapedType mappingHelper(Fn mapping, Attr &attr, ShapedType inType,
        -: 1494:                                Type newElementType,
        -: 1495:                                llvm::SmallVectorImpl<char> &data) {
    #####: 1496:  size_t bitWidth = getDenseElementBitWidth(newElementType);
    #####: 1497:  size_t storageBitWidth = getDenseElementStorageWidth(bitWidth);
        -: 1498:
    #####: 1499:  ShapedType newArrayType = inType.cloneWith(inType.getShape(), newElementType);
        -: 1500:
    #####: 1501:  size_t numRawElements = attr.isSplat() ? 1 : newArrayType.getNumElements();
    #####: 1502:  data.resize(llvm::divideCeil(storageBitWidth * numRawElements, CHAR_BIT));
        -: 1503:
        -: 1504:  // Functor used to process a single element value of the attribute.
    #####: 1505:  auto processElt = [&](decltype(*attr.begin()) value, size_t index) {
    #####: 1506:    auto newInt = mapping(value);
call    0 never executed
call    1 never executed
    #####: 1507:    assert(newInt.getBitWidth() == bitWidth);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1508:    writeBits(data.data(), index * storageBitWidth, newInt);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 1509:  };
        -: 1510:
        -: 1511:  // Check for the splat case.
    #####: 1512:  if (attr.isSplat()) {
    #####: 1513:    if (bitWidth == 1) {
        -: 1514:      // Handle the special encoding of splat of bool.
    #####: 1515:      data[0] = mapping(*attr.begin()).isZero() ? 0 : -1;
        -: 1516:    } else {
    #####: 1517:      processElt(*attr.begin(), /*index=*/0);
        -: 1518:    }
    #####: 1519:    return newArrayType;
        -: 1520:  }
        -: 1521:
        -: 1522:  // Otherwise, process all of the element values.
    #####: 1523:  uint64_t elementIdx = 0;
    #####: 1524:  for (auto value : attr)
    #####: 1525:    processElt(value, elementIdx++);
    #####: 1526:  return newArrayType;
        -: 1527:}
------------------
_Z13mappingHelperIN4llvm12function_refIFNS0_5APIntERKS2_EEEKN4mlir20DenseIntElementsAttrEENS7_10ShapedTypeET_RT0_SA_NS7_4TypeERNS0_15SmallVectorImplIcEE:
function _Z13mappingHelperIN4llvm12function_refIFNS0_5APIntERKS2_EEEKN4mlir20DenseIntElementsAttrEENS7_10ShapedTypeET_RT0_SA_NS7_4TypeERNS0_15SmallVectorImplIcEE called 0 returned 0% blocks executed 0%
    #####: 1493:static ShapedType mappingHelper(Fn mapping, Attr &attr, ShapedType inType,
        -: 1494:                                Type newElementType,
        -: 1495:                                llvm::SmallVectorImpl<char> &data) {
    #####: 1496:  size_t bitWidth = getDenseElementBitWidth(newElementType);
call    0 never executed
    #####: 1497:  size_t storageBitWidth = getDenseElementStorageWidth(bitWidth);
branch  0 never executed
branch  1 never executed
        -: 1498:
    #####: 1499:  ShapedType newArrayType = inType.cloneWith(inType.getShape(), newElementType);
call    0 never executed
call    1 never executed
        -: 1500:
    #####: 1501:  size_t numRawElements = attr.isSplat() ? 1 : newArrayType.getNumElements();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1502:  data.resize(llvm::divideCeil(storageBitWidth * numRawElements, CHAR_BIT));
call    0 never executed
        -: 1503:
        -: 1504:  // Functor used to process a single element value of the attribute.
    #####: 1505:  auto processElt = [&](decltype(*attr.begin()) value, size_t index) {
        -: 1506:    auto newInt = mapping(value);
        -: 1507:    assert(newInt.getBitWidth() == bitWidth);
        -: 1508:    writeBits(data.data(), index * storageBitWidth, newInt);
        -: 1509:  };
        -: 1510:
        -: 1511:  // Check for the splat case.
    #####: 1512:  if (attr.isSplat()) {
branch  0 never executed
branch  1 never executed
    #####: 1513:    if (bitWidth == 1) {
branch  0 never executed
branch  1 never executed
        -: 1514:      // Handle the special encoding of splat of bool.
    #####: 1515:      data[0] = mapping(*attr.begin()).isZero() ? 0 : -1;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 1516:    } else {
    #####: 1517:      processElt(*attr.begin(), /*index=*/0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1518:    }
    #####: 1519:    return newArrayType;
        -: 1520:  }
        -: 1521:
        -: 1522:  // Otherwise, process all of the element values.
    #####: 1523:  uint64_t elementIdx = 0;
    #####: 1524:  for (auto value : attr)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1525:    processElt(value, elementIdx++);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1526:  return newArrayType;
        -: 1527:}
------------------
_Z13mappingHelperIN4llvm12function_refIFNS0_5APIntERKNS0_7APFloatEEEEKN4mlir19DenseFPElementsAttrEENS8_10ShapedTypeET_RT0_SB_NS8_4TypeERNS0_15SmallVectorImplIcEE:
function _Z13mappingHelperIN4llvm12function_refIFNS0_5APIntERKNS0_7APFloatEEEEKN4mlir19DenseFPElementsAttrEENS8_10ShapedTypeET_RT0_SB_NS8_4TypeERNS0_15SmallVectorImplIcEE called 0 returned 0% blocks executed 0%
    #####: 1493:static ShapedType mappingHelper(Fn mapping, Attr &attr, ShapedType inType,
        -: 1494:                                Type newElementType,
        -: 1495:                                llvm::SmallVectorImpl<char> &data) {
    #####: 1496:  size_t bitWidth = getDenseElementBitWidth(newElementType);
call    0 never executed
    #####: 1497:  size_t storageBitWidth = getDenseElementStorageWidth(bitWidth);
branch  0 never executed
branch  1 never executed
        -: 1498:
    #####: 1499:  ShapedType newArrayType = inType.cloneWith(inType.getShape(), newElementType);
call    0 never executed
call    1 never executed
        -: 1500:
    #####: 1501:  size_t numRawElements = attr.isSplat() ? 1 : newArrayType.getNumElements();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1502:  data.resize(llvm::divideCeil(storageBitWidth * numRawElements, CHAR_BIT));
call    0 never executed
        -: 1503:
        -: 1504:  // Functor used to process a single element value of the attribute.
    #####: 1505:  auto processElt = [&](decltype(*attr.begin()) value, size_t index) {
        -: 1506:    auto newInt = mapping(value);
        -: 1507:    assert(newInt.getBitWidth() == bitWidth);
        -: 1508:    writeBits(data.data(), index * storageBitWidth, newInt);
        -: 1509:  };
        -: 1510:
        -: 1511:  // Check for the splat case.
    #####: 1512:  if (attr.isSplat()) {
branch  0 never executed
branch  1 never executed
    #####: 1513:    if (bitWidth == 1) {
branch  0 never executed
branch  1 never executed
        -: 1514:      // Handle the special encoding of splat of bool.
    #####: 1515:      data[0] = mapping(*attr.begin()).isZero() ? 0 : -1;
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
        -: 1516:    } else {
    #####: 1517:      processElt(*attr.begin(), /*index=*/0);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1518:    }
    #####: 1519:    return newArrayType;
        -: 1520:  }
        -: 1521:
        -: 1522:  // Otherwise, process all of the element values.
    #####: 1523:  uint64_t elementIdx = 0;
    #####: 1524:  for (auto value : attr)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1525:    processElt(value, elementIdx++);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1526:  return newArrayType;
        -: 1527:}
------------------
        -: 1528:
function _ZNK4mlir19DenseFPElementsAttr9mapValuesENS_4TypeEN4llvm12function_refIFNS2_5APIntERKNS2_7APFloatEEEE called 0 returned 0% blocks executed 0%
    #####: 1529:DenseElementsAttr DenseFPElementsAttr::mapValues(
        -: 1530:    Type newElementType, function_ref<APInt(const APFloat &)> mapping) const {
    #####: 1531:  llvm::SmallVector<char, 8> elementData;
call    0 never executed
    #####: 1532:  auto newArrayType =
    #####: 1533:      mappingHelper(mapping, *this, getType(), newElementType, elementData);
call    0 never executed
        -: 1534:
    #####: 1535:  return getRaw(newArrayType, elementData);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1536:}
        -: 1537:
        -: 1538:/// Method for supporting type inquiry through isa, cast and dyn_cast.
function _ZN4mlir19DenseFPElementsAttr7classofENS_9AttributeE called 5856 returned 100% blocks executed 100%
     5856: 1539:bool DenseFPElementsAttr::classof(Attribute attr) {
     5856: 1540:  if (auto denseAttr = attr.dyn_cast<DenseElementsAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     5856: 1541:    return denseAttr.getType().getElementType().isa<FloatType>();
call    0 returned 100%
call    1 returned 100%
        -: 1542:  return false;
        -: 1543:}
        -: 1544:
        -: 1545://===----------------------------------------------------------------------===//
        -: 1546:// DenseIntElementsAttr
        -: 1547://===----------------------------------------------------------------------===//
        -: 1548:
function _ZNK4mlir20DenseIntElementsAttr9mapValuesENS_4TypeEN4llvm12function_refIFNS2_5APIntERKS4_EEE called 0 returned 0% blocks executed 0%
    #####: 1549:DenseElementsAttr DenseIntElementsAttr::mapValues(
        -: 1550:    Type newElementType, function_ref<APInt(const APInt &)> mapping) const {
    #####: 1551:  llvm::SmallVector<char, 8> elementData;
call    0 never executed
    #####: 1552:  auto newArrayType =
    #####: 1553:      mappingHelper(mapping, *this, getType(), newElementType, elementData);
call    0 never executed
    #####: 1554:  return getRaw(newArrayType, elementData);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1555:}
        -: 1556:
        -: 1557:/// Method for supporting type inquiry through isa, cast and dyn_cast.
function _ZN4mlir20DenseIntElementsAttr7classofENS_9AttributeE called 82846 returned 100% blocks executed 100%
    82846: 1558:bool DenseIntElementsAttr::classof(Attribute attr) {
    82846: 1559:  if (auto denseAttr = attr.dyn_cast<DenseElementsAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    82846: 1560:    return denseAttr.getType().getElementType().isIntOrIndex();
call    0 returned 100%
call    1 returned 100%
        -: 1561:  return false;
        -: 1562:}
        -: 1563:
        -: 1564://===----------------------------------------------------------------------===//
        -: 1565:// DenseResourceElementsAttr
        -: 1566://===----------------------------------------------------------------------===//
        -: 1567:
        -: 1568:DenseResourceElementsAttr
function _ZN4mlir25DenseResourceElementsAttr3getENS_10ShapedTypeENS_25DialectResourceBlobHandleINS_14BuiltinDialectEEE called 0 returned 0% blocks executed 0%
    #####: 1569:DenseResourceElementsAttr::get(ShapedType type,
        -: 1570:                               DenseResourceElementsHandle handle) {
    #####: 1571:  return Base::get(type.getContext(), type, handle);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1572:}
        -: 1573:
function _ZN4mlir25DenseResourceElementsAttr3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1574:DenseResourceElementsAttr DenseResourceElementsAttr::get(ShapedType type,
        -: 1575:                                                         StringRef blobName,
        -: 1576:                                                         AsmResourceBlob blob) {
        -: 1577:  // Extract the builtin dialect resource manager from context and construct a
        -: 1578:  // handle by inserting a new resource using the provided blob.
    #####: 1579:  auto &manager =
    #####: 1580:      DenseResourceElementsHandle::getManagerInterface(type.getContext());
call    0 never executed
call    1 never executed
    #####: 1581:  return get(type, manager.insert(blobName, std::move(blob)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1582:}
        -: 1583:
        -: 1584://===----------------------------------------------------------------------===//
        -: 1585:// DenseResourceElementsAttrBase
        -: 1586:
        -: 1587:namespace {
        -: 1588:/// Instantiations of this class provide utilities for interacting with native
        -: 1589:/// data types in the context of DenseResourceElementsAttr.
        -: 1590:template <typename T>
        -: 1591:struct DenseResourceAttrUtil;
        -: 1592:template <size_t width, bool isSigned>
        -: 1593:struct DenseResourceElementsAttrIntUtil {
    #####: 1594:  static bool checkElementType(Type eltType) {
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm64ELb0EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm64ELb0EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm32ELb0EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm32ELb0EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm16ELb0EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm16ELb0EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm8ELb0EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm8ELb0EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm64ELb1EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm64ELb1EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm32ELb1EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm32ELb1EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm16ELb1EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm16ELb1EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
_ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm8ELb1EE16checkElementTypeEN4mlir4TypeE:
function _ZN12_GLOBAL__N_132DenseResourceElementsAttrIntUtilILm8ELb1EE16checkElementTypeEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1594:  static bool checkElementType(Type eltType) {
call    0 never executed
    #####: 1595:    IntegerType type = eltType.dyn_cast<IntegerType>();
    #####: 1596:    if (!type || type.getWidth() != width)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1597:      return false;
    #####: 1598:    return isSigned ? !type.isUnsigned() : !type.isSigned();
        -: 1599:  }
------------------
        -: 1600:};
        -: 1601:template <>
        -: 1602:struct DenseResourceAttrUtil<bool> {
    #####: 1603:  static bool checkElementType(Type eltType) {
    #####: 1604:    return eltType.isSignlessInteger(1);
call    0 never executed
call    1 never executed
        -: 1605:  }
        -: 1606:};
        -: 1607:template <>
        -: 1608:struct DenseResourceAttrUtil<int8_t>
        -: 1609:    : public DenseResourceElementsAttrIntUtil<8, true> {};
        -: 1610:template <>
        -: 1611:struct DenseResourceAttrUtil<uint8_t>
        -: 1612:    : public DenseResourceElementsAttrIntUtil<8, false> {};
        -: 1613:template <>
        -: 1614:struct DenseResourceAttrUtil<int16_t>
        -: 1615:    : public DenseResourceElementsAttrIntUtil<16, true> {};
        -: 1616:template <>
        -: 1617:struct DenseResourceAttrUtil<uint16_t>
        -: 1618:    : public DenseResourceElementsAttrIntUtil<16, false> {};
        -: 1619:template <>
        -: 1620:struct DenseResourceAttrUtil<int32_t>
        -: 1621:    : public DenseResourceElementsAttrIntUtil<32, true> {};
        -: 1622:template <>
        -: 1623:struct DenseResourceAttrUtil<uint32_t>
        -: 1624:    : public DenseResourceElementsAttrIntUtil<32, false> {};
        -: 1625:template <>
        -: 1626:struct DenseResourceAttrUtil<int64_t>
        -: 1627:    : public DenseResourceElementsAttrIntUtil<64, true> {};
        -: 1628:template <>
        -: 1629:struct DenseResourceAttrUtil<uint64_t>
        -: 1630:    : public DenseResourceElementsAttrIntUtil<64, false> {};
        -: 1631:template <>
        -: 1632:struct DenseResourceAttrUtil<float> {
    #####: 1633:  static bool checkElementType(Type eltType) { return eltType.isF32(); }
call    0 never executed
call    1 never executed
        -: 1634:};
        -: 1635:template <>
        -: 1636:struct DenseResourceAttrUtil<double> {
    #####: 1637:  static bool checkElementType(Type eltType) { return eltType.isF64(); }
call    0 never executed
call    1 never executed
        -: 1638:};
        -: 1639:} // namespace
        -: 1640:
        -: 1641:template <typename T>
        -: 1642:DenseResourceElementsAttrBase<T>
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIdE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIdE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIfE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIfE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseImE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseImE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIjE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIjE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseItE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseItE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIhE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIhE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
call    0 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIlE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIlE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIiE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIiE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIsE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIsE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIaE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIaE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
call    0 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIbE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIbE3getENS_10ShapedTypeEN4llvm9StringRefENS_15AsmResourceBlobE called 0 returned 0% blocks executed 0%
    #####: 1643:DenseResourceElementsAttrBase<T>::get(ShapedType type, StringRef blobName,
        -: 1644:                                      AsmResourceBlob blob) {
        -: 1645:  // Check that the blob is in the form we were expecting.
    #####: 1646:  assert(blob.getDataAlignment() == alignof(T) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1647:         "alignment mismatch between expected alignment and blob alignment");
    #####: 1648:  assert(((blob.getData().size() % sizeof(T)) == 0) &&
call    0 never executed
        -: 1649:         "size mismatch between expected element width and blob size");
    #####: 1650:  assert(DenseResourceAttrUtil<T>::checkElementType(type.getElementType()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1651:         "invalid shape element type for provided type `T`");
    #####: 1652:  return DenseResourceElementsAttr::get(type, blobName, std::move(blob))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1653:      .template cast<DenseResourceElementsAttrBase<T>>();
call    0 never executed
        -: 1654:}
------------------
        -: 1655:
        -: 1656:template <typename T>
        -: 1657:Optional<ArrayRef<T>>
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIdE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIdE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIfE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIfE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseImE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseImE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIjE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIjE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseItE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseItE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIhE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIhE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIlE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIlE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIiE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIiE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIsE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIsE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIaE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIaE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
_ZNK4mlir6detail29DenseResourceElementsAttrBaseIbE16tryGetAsArrayRefEv:
function _ZNK4mlir6detail29DenseResourceElementsAttrBaseIbE16tryGetAsArrayRefEv called 0 returned 0% blocks executed 0%
    #####: 1658:DenseResourceElementsAttrBase<T>::tryGetAsArrayRef() const {
    #####: 1659:  if (AsmResourceBlob *blob = this->getRawHandle().getBlob())
branch  0 never executed
branch  1 never executed
    #####: 1660:    return blob->template getDataAs<T>();
    #####: 1661:  return llvm::None;
        -: 1662:}
------------------
        -: 1663:
        -: 1664:template <typename T>
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIdE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIdE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIfE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIfE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseImE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseImE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIjE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIjE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseItE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseItE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIhE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIhE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIlE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIlE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIiE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIiE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIsE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIsE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIaE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIaE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
_ZN4mlir6detail29DenseResourceElementsAttrBaseIbE7classofENS_9AttributeE:
function _ZN4mlir6detail29DenseResourceElementsAttrBaseIbE7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####: 1665:bool DenseResourceElementsAttrBase<T>::classof(Attribute attr) {
call    0 never executed
    #####: 1666:  auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>();
    #####: 1667:  return resourceAttr && DenseResourceAttrUtil<T>::checkElementType(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1668:                             resourceAttr.getElementType());
        -: 1669:}
------------------
        -: 1670:
        -: 1671:namespace mlir {
        -: 1672:namespace detail {
        -: 1673:// Explicit instantiation for all the supported DenseResourceElementsAttr.
        -: 1674:template class DenseResourceElementsAttrBase<bool>;
        -: 1675:template class DenseResourceElementsAttrBase<int8_t>;
        -: 1676:template class DenseResourceElementsAttrBase<int16_t>;
        -: 1677:template class DenseResourceElementsAttrBase<int32_t>;
        -: 1678:template class DenseResourceElementsAttrBase<int64_t>;
        -: 1679:template class DenseResourceElementsAttrBase<uint8_t>;
        -: 1680:template class DenseResourceElementsAttrBase<uint16_t>;
        -: 1681:template class DenseResourceElementsAttrBase<uint32_t>;
        -: 1682:template class DenseResourceElementsAttrBase<uint64_t>;
        -: 1683:template class DenseResourceElementsAttrBase<float>;
        -: 1684:template class DenseResourceElementsAttrBase<double>;
        -: 1685:} // namespace detail
        -: 1686:} // namespace mlir
        -: 1687:
        -: 1688://===----------------------------------------------------------------------===//
        -: 1689:// SparseElementsAttr
        -: 1690://===----------------------------------------------------------------------===//
        -: 1691:
        -: 1692:/// Get a zero APFloat for the given sparse attribute.
function _ZNK4mlir18SparseElementsAttr14getZeroAPFloatEv called 0 returned 0% blocks executed 0%
    #####: 1693:APFloat SparseElementsAttr::getZeroAPFloat() const {
    #####: 1694:  auto eltType = getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1695:  return APFloat(eltType.getFloatSemantics());
call    0 never executed
call    1 never executed
        -: 1696:}
        -: 1697:
        -: 1698:/// Get a zero APInt for the given sparse attribute.
function _ZNK4mlir18SparseElementsAttr12getZeroAPIntEv called 0 returned 0% blocks executed 0%
    #####: 1699:APInt SparseElementsAttr::getZeroAPInt() const {
    #####: 1700:  auto eltType = getElementType().cast<IntegerType>();
call    0 never executed
call    1 never executed
    #####: 1701:  return APInt::getZero(eltType.getWidth());
call    0 never executed
call    1 never executed
        -: 1702:}
        -: 1703:
        -: 1704:/// Get a zero attribute for the given attribute type.
function _ZNK4mlir18SparseElementsAttr11getZeroAttrEv called 0 returned 0% blocks executed 0%
    #####: 1705:Attribute SparseElementsAttr::getZeroAttr() const {
    #####: 1706:  auto eltType = getElementType();
call    0 never executed
        -: 1707:
        -: 1708:  // Handle floating point elements.
    #####: 1709:  if (eltType.isa<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1710:    return FloatAttr::get(eltType, 0);
call    0 never executed
        -: 1711:
        -: 1712:  // Handle complex elements.
    #####: 1713:  if (auto complexTy = eltType.dyn_cast<ComplexType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1714:    auto eltType = complexTy.getElementType();
call    0 never executed
    #####: 1715:    Attribute zero;
    #####: 1716:    if (eltType.isa<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1717:      zero = FloatAttr::get(eltType, 0);
call    0 never executed
        -: 1718:    else // must be integer
    #####: 1719:      zero = IntegerAttr::get(eltType, 0);
call    0 never executed
    #####: 1720:    return ArrayAttr::get(complexTy.getContext(),
    #####: 1721:                          ArrayRef<Attribute>{zero, zero});
call    0 never executed
call    1 never executed
        -: 1722:  }
        -: 1723:
        -: 1724:  // Handle string type.
    #####: 1725:  if (getValues().isa<DenseStringElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1726:    return StringAttr::get("", eltType);
call    0 never executed
call    1 never executed
        -: 1727:
        -: 1728:  // Otherwise, this is an integer.
    #####: 1729:  return IntegerAttr::get(eltType, 0);
call    0 never executed
        -: 1730:}
        -: 1731:
        -: 1732:/// Flatten, and return, all of the sparse indices in this attribute in
        -: 1733:/// row-major order.
function _ZNK4mlir18SparseElementsAttr25getFlattenedSparseIndicesEv called 0 returned 0% blocks executed 0%
    #####: 1734:std::vector<ptrdiff_t> SparseElementsAttr::getFlattenedSparseIndices() const {
    #####: 1735:  std::vector<ptrdiff_t> flatSparseIndices;
call    0 never executed
        -: 1736:
        -: 1737:  // The sparse indices are 64-bit integers, so we can reinterpret the raw data
        -: 1738:  // as a 1-D index array.
    #####: 1739:  auto sparseIndices = getIndices();
call    0 never executed
    #####: 1740:  auto sparseIndexValues = sparseIndices.getValues<uint64_t>();
call    0 never executed
    #####: 1741:  if (sparseIndices.isSplat()) {
branch  0 never executed
branch  1 never executed
    #####: 1742:    SmallVector<uint64_t, 8> indices(getType().getRank(),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1743:                                     *sparseIndexValues.begin());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1744:    flatSparseIndices.push_back(getFlattenedIndex(indices));
call    0 never executed
call    1 never executed
    #####: 1745:    return flatSparseIndices;
branch  0 never executed
branch  1 never executed
        -: 1746:  }
        -: 1747:
        -: 1748:  // Otherwise, reinterpret each index as an ArrayRef when flattening.
    #####: 1749:  auto numSparseIndices = sparseIndices.getType().getDimSize(0);
call    0 never executed
    #####: 1750:  size_t rank = getType().getRank();
call    0 never executed
    #####: 1751:  for (size_t i = 0, e = numSparseIndices; i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1752:    flatSparseIndices.push_back(getFlattenedIndex(
call    0 never executed
call    1 never executed
    #####: 1753:        {&*std::next(sparseIndexValues.begin(), i * rank), rank}));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1754:  return flatSparseIndices;
        -: 1755:}
        -: 1756:
        -: 1757:LogicalResult
function _ZN4mlir18SparseElementsAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_10ShapedTypeENS_20DenseIntElementsAttrENS_17DenseElementsAttrE called 0 returned 0% blocks executed 0%
    #####: 1758:SparseElementsAttr::verify(function_ref<InFlightDiagnostic()> emitError,
        -: 1759:                           ShapedType type, DenseIntElementsAttr sparseIndices,
        -: 1760:                           DenseElementsAttr values) {
    #####: 1761:  ShapedType valuesType = values.getType();
    #####: 1762:  if (valuesType.getRank() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1763:    return emitError() << "expected 1-d tensor for sparse element values";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1764:
        -: 1765:  // Verify the indices and values shape.
    #####: 1766:  ShapedType indicesType = sparseIndices.getType();
function _ZZN4mlir18SparseElementsAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_10ShapedTypeENS_20DenseIntElementsAttrENS_17DenseElementsAttrEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####: 1767:  auto emitShapeError = [&]() {
    #####: 1768:    return emitError() << "expected shape ([" << type.getShape()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1769:                       << "]); inferred shape of indices literal (["
    #####: 1770:                       << indicesType.getShape()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1771:                       << "]); inferred shape of values literal (["
    #####: 1772:                       << valuesType.getShape() << "])";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1773:  };
        -: 1774:  // Verify indices shape.
    #####: 1775:  size_t rank = type.getRank(), indicesRank = indicesType.getRank();
call    0 never executed
call    1 never executed
    #####: 1776:  if (indicesRank == 2) {
branch  0 never executed
branch  1 never executed
    #####: 1777:    if (indicesType.getDimSize(1) != static_cast<int64_t>(rank))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1778:      return emitShapeError();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1779:  } else if (indicesRank != 1 || rank != 1) {
branch  0 never executed
branch  1 never executed
    #####: 1780:    return emitShapeError();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1781:  }
        -: 1782:  // Verify the values shape.
    #####: 1783:  int64_t numSparseIndices = indicesType.getDimSize(0);
call    0 never executed
    #####: 1784:  if (numSparseIndices != valuesType.getDimSize(0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1785:    return emitShapeError();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1786:
        -: 1787:  // Verify that the sparse indices are within the value shape.
function _ZZN4mlir18SparseElementsAttr6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_10ShapedTypeENS_20DenseIntElementsAttrENS_17DenseElementsAttrEENKUljNS1_8ArrayRefImEEE0_clEjSA_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1788:  auto emitIndexError = [&](unsigned indexNum, ArrayRef<uint64_t> index) {
    #####: 1789:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1790:           << "sparse index #" << indexNum
call    0 never executed
call    1 never executed
    #####: 1791:           << " is not contained within the value shape, with index=[" << index
call    0 never executed
call    1 never executed
    #####: 1792:           << "], and type=" << type;
call    0 never executed
call    1 never executed
    #####: 1793:  };
        -: 1794:
        -: 1795:  // Handle the case where the index values are a splat.
    #####: 1796:  auto sparseIndexValues = sparseIndices.getValues<uint64_t>();
call    0 never executed
    #####: 1797:  if (sparseIndices.isSplat()) {
branch  0 never executed
branch  1 never executed
    #####: 1798:    SmallVector<uint64_t> indices(rank, *sparseIndexValues.begin());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1799:    if (!ElementsAttr::isValidIndex(type, indices))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1800:      return emitIndexError(0, indices);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1801:    return success();
branch  0 never executed
branch  1 never executed
        -: 1802:  }
        -: 1803:
        -: 1804:  // Otherwise, reinterpret each index as an ArrayRef.
    #####: 1805:  for (size_t i = 0, e = numSparseIndices; i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1806:    ArrayRef<uint64_t> index(&*std::next(sparseIndexValues.begin(), i * rank),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1807:                             rank);
    #####: 1808:    if (!ElementsAttr::isValidIndex(type, index))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1809:      return emitIndexError(i, index);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1810:  }
        -: 1811:
    #####: 1812:  return success();
        -: 1813:}
        -: 1814:
        -: 1815://===----------------------------------------------------------------------===//
        -: 1816:// TypeAttr
        -: 1817://===----------------------------------------------------------------------===//
        -: 1818:
function _ZNK4mlir8TypeAttr24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
    8180*: 1819:void TypeAttr::walkImmediateSubElements(
        -: 1820:    function_ref<void(Attribute)> walkAttrsFn,
        -: 1821:    function_ref<void(Type)> walkTypesFn) const {
    8180*: 1822:  walkTypesFn(getValue());
call    0 returned 100%
call    1 never executed
    #####: 1823:}
        -: 1824:
        -: 1825:Attribute
function _ZNK4mlir8TypeAttr27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 1826:TypeAttr::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -: 1827:                                      ArrayRef<Type> replTypes) const {
    #####: 1828:  return get(replTypes[0]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1829:}
        -: 1830:
        -: 1831://===----------------------------------------------------------------------===//
        -: 1832:// Attribute Utilities
        -: 1833://===----------------------------------------------------------------------===//
        -: 1834:
function _ZN4mlir26makeStridedLinearLayoutMapEN4llvm8ArrayRefIlEElPNS_11MLIRContextE called 12 returned 100% blocks executed 78%
       12: 1835:AffineMap mlir::makeStridedLinearLayoutMap(ArrayRef<int64_t> strides,
        -: 1836:                                           int64_t offset,
        -: 1837:                                           MLIRContext *context) {
       12: 1838:  AffineExpr expr;
       12: 1839:  unsigned nSymbols = 0;
        -: 1840:
        -: 1841:  // AffineExpr for offset.
        -: 1842:  // Static case.
       12: 1843:  if (offset != MemRefType::getDynamicStrideOrOffset()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1844:    auto cst = getAffineConstantExpr(offset, context);
call    0 never executed
    #####: 1845:    expr = cst;
        -: 1846:  } else {
        -: 1847:    // Dynamic case, new symbol for the offset.
       12: 1848:    auto sym = getAffineSymbolExpr(nSymbols++, context);
call    0 returned 100%
       12: 1849:    expr = sym;
        -: 1850:  }
        -: 1851:
        -: 1852:  // AffineExpr for strides.
       36: 1853:  for (const auto &en : llvm::enumerate(strides)) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
call    2 returned 100%
       24: 1854:    auto dim = en.index();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       24: 1855:    auto stride = en.value();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      24*: 1856:    assert(stride != 0 && "Invalid stride specification");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       24: 1857:    auto d = getAffineDimExpr(dim, context);
call    0 returned 100%
       24: 1858:    AffineExpr mult;
        -: 1859:    // Static case.
       24: 1860:    if (stride != MemRefType::getDynamicStrideOrOffset())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1861:      mult = getAffineConstantExpr(stride, context);
call    0 never executed
        -: 1862:    else
        -: 1863:      // Dynamic case, new symbol for each new stride.
       24: 1864:      mult = getAffineSymbolExpr(nSymbols++, context);
call    0 returned 100%
       24: 1865:    expr = expr + d * mult;
call    0 returned 100%
call    1 returned 100%
        -: 1866:  }
        -: 1867:
       12: 1868:  return AffineMap::get(strides.size(), nSymbols, expr);
call    0 returned 100%
        -: 1869:}
