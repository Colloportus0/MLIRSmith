        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/SCF/Utils/Utils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SCF/Utils/CMakeFiles/obj.MLIRSCFUtils.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SCF/Utils/CMakeFiles/obj.MLIRSCFUtils.dir/Utils.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- Utils.cpp ---- Misc utilities for loop transformation ----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements miscellaneous loop transformation routines.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SCF/Utils/Utils.h"
        -:   14:#include "mlir/Analysis/SliceAnalysis.h"
        -:   15:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   16:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   17:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   18:#include "mlir/IR/BlockAndValueMapping.h"
        -:   19:#include "mlir/IR/BuiltinOps.h"
        -:   20:#include "mlir/IR/PatternMatch.h"
        -:   21:#include "mlir/Support/MathExtras.h"
        -:   22:#include "mlir/Transforms/RegionUtils.h"
        -:   23:#include "llvm/ADT/STLExtras.h"
        -:   24:#include "llvm/ADT/SetVector.h"
        -:   25:#include "llvm/ADT/SmallPtrSet.h"
        -:   26:#include "llvm/ADT/SmallVector.h"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:
        -:   30:namespace {
        -:   31:// This structure is to pass and return sets of loop parameters without
        -:   32:// confusing the order.
        -:   33:struct LoopParams {
        -:   34:  Value lowerBound;
        -:   35:  Value upperBound;
        -:   36:  Value step;
        -:   37:};
        -:   38:} // namespace
        -:   39:
        -:   40:scf::ForOp
function _ZN4mlir24replaceLoopWithNewYieldsERNS_9OpBuilderENS_3scf5ForOpENS_10ValueRangeERKSt8functionIFN4llvm11SmallVectorINS_5ValueELj6EEES1_NS_8LocationENS6_8ArrayRefINS_13BlockArgumentEEEEEb called 0 returned 0% blocks executed 0%
    #####:   41:mlir::replaceLoopWithNewYields(OpBuilder &builder, scf::ForOp loop,
        -:   42:                               ValueRange newIterOperands,
        -:   43:                               const NewYieldValueFn &newYieldValuesFn,
        -:   44:                               bool replaceIterOperandsUsesInLoop) {
        -:   45:  // Create a new loop before the existing one, with the extra operands.
    #####:   46:  OpBuilder::InsertionGuard g(builder);
call    0 never executed
    #####:   47:  builder.setInsertionPoint(loop);
call    0 never executed
    #####:   48:  auto operands = llvm::to_vector(loop.getIterOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   49:  operands.append(newIterOperands.begin(), newIterOperands.end());
call    0 never executed
    #####:   50:  scf::ForOp newLoop = builder.create<scf::ForOp>(
    #####:   51:      loop.getLoc(), loop.getLowerBound(), loop.getUpperBound(), loop.getStep(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   52:      operands, [](OpBuilder &, Location, Value, ValueRange) {});
call    0 never executed
        -:   53:
    #####:   54:  Block *loopBody = loop.getBody();
call    0 never executed
    #####:   55:  Block *newLoopBody = newLoop.getBody();
call    0 never executed
        -:   56:
        -:   57:  // Move the body of the original loop to the new loop.
    #####:   58:  newLoopBody->getOperations().splice(newLoopBody->end(),
call    0 never executed
    #####:   59:                                      loopBody->getOperations());
call    0 never executed
        -:   60:
        -:   61:  // Generate the new yield values to use by using the callback and append the
        -:   62:  // yield values to the scf.yield operation.
    #####:   63:  auto yield = cast<scf::YieldOp>(newLoopBody->getTerminator());
call    0 never executed
call    1 never executed
    #####:   64:  ArrayRef<BlockArgument> newBBArgs =
branch  0 never executed
branch  1 never executed
    #####:   65:      newLoopBody->getArguments().take_back(newIterOperands.size());
branch  0 never executed
branch  1 never executed
    #####:   66:  {
    #####:   67:    OpBuilder::InsertionGuard g(builder);
call    0 never executed
    #####:   68:    builder.setInsertionPoint(yield);
call    0 never executed
    #####:   69:    SmallVector<Value> newYieldedValues =
    #####:   70:        newYieldValuesFn(builder, loop.getLoc(), newBBArgs);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   71:    assert(newIterOperands.size() == newYieldedValues.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   72:           "expected as many new yield values as new iter operands");
    #####:   73:    yield.getResultsMutable().append(newYieldedValues);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:   74:  }
        -:   75:
        -:   76:  // Remap the BlockArguments from the original loop to the new loop
        -:   77:  // BlockArguments.
    #####:   78:  ArrayRef<BlockArgument> bbArgs = loopBody->getArguments();
branch  0 never executed
branch  1 never executed
    #####:   79:  for (auto it :
    #####:   80:       llvm::zip(bbArgs, newLoopBody->getArguments().take_front(bbArgs.size())))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   81:    std::get<0>(it).replaceAllUsesWith(std::get<1>(it));
call    0 never executed
        -:   82:
    #####:   83:  if (replaceIterOperandsUsesInLoop) {
branch  0 never executed
branch  1 never executed
        -:   84:    // Replace all uses of `newIterOperands` with the corresponding basic block
        -:   85:    // arguments.
    #####:   86:    for (auto it : llvm::zip(newIterOperands, newBBArgs)) {
branch  0 never executed
branch  1 never executed
    #####:   87:      std::get<0>(it).replaceUsesWithIf(std::get<1>(it), [&](OpOperand &use) {
call    0 never executed
    #####:   88:        Operation *user = use.getOwner();
call    0 never executed
    #####:   89:        return newLoop->isProperAncestor(user);
call    0 never executed
        -:   90:      });
        -:   91:    }
        -:   92:  }
        -:   93:
        -:   94:  // Replace all uses of the original loop with corresponding values from the
        -:   95:  // new loop.
    #####:   96:  loop.replaceAllUsesWith(
    #####:   97:      newLoop.getResults().take_front(loop.getNumResults()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   98:
        -:   99:  // Add a fake yield to the original loop body that just returns the
        -:  100:  // BlockArguments corresponding to the iter_args. This makes it a no-op loop.
        -:  101:  // The loop is dead. The caller is expected to erase it.
    #####:  102:  builder.setInsertionPointToEnd(loopBody);
call    0 never executed
    #####:  103:  builder.create<scf::YieldOp>(loop->getLoc(), loop.getRegionIterArgs());
call    0 never executed
call    1 never executed
        -:  104:
    #####:  105:  return newLoop;
branch  0 never executed
branch  1 never executed
        -:  106:}
        -:  107:
function _ZN4mlir28replaceLoopNestWithNewYieldsERNS_9OpBuilderEN4llvm8ArrayRefINS_3scf5ForOpEEENS_10ValueRangeERKSt8functionIFNS2_11SmallVectorINS_5ValueELj6EEES1_NS_8LocationENS3_INS_13BlockArgumentEEEEEb called 0 returned 0% blocks executed 0%
    #####:  108:SmallVector<scf::ForOp> mlir::replaceLoopNestWithNewYields(
        -:  109:    OpBuilder &builder, ArrayRef<scf::ForOp> loopNest,
        -:  110:    ValueRange newIterOperands, const NewYieldValueFn &newYieldValueFn,
        -:  111:    bool replaceIterOperandsUsesInLoop) {
    #####:  112:  if (loopNest.empty())
branch  0 never executed
branch  1 never executed
    #####:  113:    return {};
        -:  114:  // This method is recursive (to make it more readable). Adding an
        -:  115:  // assertion here to limit the recursion. (See
        -:  116:  // https://discourse.llvm.org/t/rfc-update-to-mlir-developer-policy-on-recursion/62235)
    #####:  117:  assert(loopNest.size() <= 6 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  118:         "exceeded recursion limit when yielding value from loop nest");
        -:  119:
        -:  120:  // To yield a value from a perfectly nested loop nest, the following
        -:  121:  // pattern needs to be created, i.e. starting with
        -:  122:  //
        -:  123:  // ```mlir
        -:  124:  //  scf.for .. {
        -:  125:  //    scf.for .. {
        -:  126:  //      scf.for .. {
        -:  127:  //        %value = ...
        -:  128:  //      }
        -:  129:  //    }
        -:  130:  //  }
        -:  131:  // ```
        -:  132:  //
        -:  133:  // needs to be modified to
        -:  134:  //
        -:  135:  // ```mlir
        -:  136:  // %0 = scf.for .. iter_args(%arg0 = %init) {
        -:  137:  //   %1 = scf.for .. iter_args(%arg1 = %arg0) {
        -:  138:  //     %2 = scf.for .. iter_args(%arg2 = %arg1) {
        -:  139:  //       %value = ...
        -:  140:  //       scf.yield %value
        -:  141:  //     }
        -:  142:  //     scf.yield %2
        -:  143:  //   }
        -:  144:  //   scf.yield %1
        -:  145:  // }
        -:  146:  // ```
        -:  147:  //
        -:  148:  // The inner most loop is handled using the `replaceLoopWithNewYields`
        -:  149:  // that works on a single loop.
    #####:  150:  if (loopNest.size() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  151:    auto innerMostLoop = replaceLoopWithNewYields(
    #####:  152:        builder, loopNest.back(), newIterOperands, newYieldValueFn,
    #####:  153:        replaceIterOperandsUsesInLoop);
call    0 never executed
call    1 never executed
    #####:  154:    return {innerMostLoop};
call    0 never executed
        -:  155:  }
        -:  156:  // The outer loops are modified by calling this method recursively
        -:  157:  // - The return value of the inner loop is the value yielded by this loop.
        -:  158:  // - The region iter args of this loop are the init_args for the inner loop.
    #####:  159:  SmallVector<scf::ForOp> newLoopNest;
call    0 never executed
    #####:  160:  NewYieldValueFn fn =
function _ZZN4mlir28replaceLoopNestWithNewYieldsERNS_9OpBuilderEN4llvm8ArrayRefINS_3scf5ForOpEEENS_10ValueRangeERKSt8functionIFNS2_11SmallVectorINS_5ValueELj6EEES1_NS_8LocationENS3_INS_13BlockArgumentEEEEEbENKUlS1_SC_SE_E_clES1_SC_SE_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  161:      [&](OpBuilder &innerBuilder, Location loc,
        -:  162:          ArrayRef<BlockArgument> innerNewBBArgs) -> SmallVector<Value> {
    #####:  163:    newLoopNest = replaceLoopNestWithNewYields(builder, loopNest.drop_front(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  164:                                               innerNewBBArgs, newYieldValueFn,
    #####:  165:                                               replaceIterOperandsUsesInLoop);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  166:    return llvm::to_vector(llvm::map_range(
    #####:  167:        newLoopNest.front().getResults().take_back(innerNewBBArgs.size()),
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  168:        [](OpResult r) -> Value { return r; }));
call    0 never executed
    #####:  169:  };
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  170:  scf::ForOp outerMostLoop =
    #####:  171:      replaceLoopWithNewYields(builder, loopNest.front(), newIterOperands, fn,
    #####:  172:                               replaceIterOperandsUsesInLoop);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  173:  newLoopNest.insert(newLoopNest.begin(), outerMostLoop);
call    0 never executed
    #####:  174:  return newLoopNest;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  175:}
        -:  176:
        -:  177:/// Outline a region with a single block into a new FuncOp.
        -:  178:/// Assumes the FuncOp result types is the type of the yielded operands of the
        -:  179:/// single block. This constraint makes it easy to determine the result.
        -:  180:/// This method also clones the `arith::ConstantIndexOp` at the start of
        -:  181:/// `outlinedFuncBody` to alloc simple canonicalizations. If `callOp` is
        -:  182:/// provided, it will be set to point to the operation that calls the outlined
        -:  183:/// function.
        -:  184:// TODO: support more than single-block regions.
        -:  185:// TODO: more flexible constant handling.
function _ZN4mlir24outlineSingleBlockRegionERNS_12RewriterBaseENS_8LocationERNS_6RegionEN4llvm9StringRefEPNS_4func6CallOpE called 4149 returned 100% blocks executed 88%
     4149:  186:FailureOr<func::FuncOp> mlir::outlineSingleBlockRegion(RewriterBase &rewriter,
        -:  187:                                                       Location loc,
        -:  188:                                                       Region &region,
        -:  189:                                                       StringRef funcName,
        -:  190:                                                       func::CallOp *callOp) {
    4149*:  191:  assert(!funcName.empty() && "funcName cannot be empty");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    4149*:  192:  if (!region.hasOneBlock())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  193:    return failure();
        -:  194:
     4149:  195:  Block *originalBlock = &region.front();
call    0 returned 100%
     4149:  196:  Operation *originalTerminator = originalBlock->getTerminator();
call    0 returned 100%
        -:  197:
        -:  198:  // Outline before current function.
     4149:  199:  OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
     4149:  200:  rewriter.setInsertionPoint(region.getParentOfType<func::FuncOp>());
call    0 returned 100%
call    1 returned 100%
        -:  201:
     8298:  202:  SetVector<Value> captures;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     4149:  203:  getUsedValuesDefinedAbove(region, captures);
call    0 returned 100%
        -:  204:
     4149:  205:  ValueRange outlinedValues(captures.getArrayRef());
call    0 returned 100%
     8298:  206:  SmallVector<Type> outlinedFuncArgTypes;
call    0 returned 100%
call    1 returned 100%
     4149:  207:  SmallVector<Location> outlinedFuncArgLocs;
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  208:  // Region's arguments are exactly the first block's arguments as per
        -:  209:  // Region::getArguments().
        -:  210:  // Func's arguments are cat(regions's arguments, captures arguments).
    4149*:  211:  for (BlockArgument arg : region.getArguments()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  212:    outlinedFuncArgTypes.push_back(arg.getType());
call    0 never executed
    #####:  213:    outlinedFuncArgLocs.push_back(arg.getLoc());
call    0 never executed
        -:  214:  }
   136581:  215:  for (Value value : outlinedValues) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
    66216:  216:    outlinedFuncArgTypes.push_back(value.getType());
call    0 returned 100%
    66216:  217:    outlinedFuncArgLocs.push_back(value.getLoc());
call    0 returned 100%
call    1 returned 100%
        -:  218:  }
     4149:  219:  FunctionType outlinedFuncType =
        -:  220:      FunctionType::get(rewriter.getContext(), outlinedFuncArgTypes,
     4149:  221:                        originalTerminator->getOperandTypes());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     4149:  222:  auto outlinedFunc =
     4149:  223:      rewriter.create<func::FuncOp>(loc, funcName, outlinedFuncType);
call    0 returned 100%
     4149:  224:  Block *outlinedFuncBody = outlinedFunc.addEntryBlock();
call    0 returned 100%
        -:  225:
        -:  226:  // Merge blocks while replacing the original block operands.
        -:  227:  // Warning: `mergeBlocks` erases the original block, reconstruct it later.
     4149:  228:  int64_t numOriginalBlockArguments = originalBlock->getNumArguments();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     4149:  229:  auto outlinedFuncBlockArgs = outlinedFuncBody->getArguments();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     4149:  230:  {
     4149:  231:    OpBuilder::InsertionGuard g(rewriter);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     4149:  232:    rewriter.setInsertionPointToEnd(outlinedFuncBody);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     4149:  233:    rewriter.mergeBlocks(
call    0 returned 100%
        -:  234:        originalBlock, outlinedFuncBody,
     8298:  235:        outlinedFuncBlockArgs.take_front(numOriginalBlockArguments));
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -:  236:    // Explicitly set up a new ReturnOp terminator.
     4149:  237:    rewriter.setInsertionPointToEnd(outlinedFuncBody);
call    0 returned 100%
    12447:  238:    rewriter.create<func::ReturnOp>(loc, originalTerminator->getResultTypes(),
     8298:  239:                                    originalTerminator->getOperands());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  240:  }
        -:  241:
        -:  242:  // Reconstruct the block that was deleted and add a
        -:  243:  // terminator(call_results).
    12447:  244:  Block *newBlock = rewriter.createBlock(
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
        -:  245:      &region, region.begin(),
     4149:  246:      TypeRange{outlinedFuncArgTypes}.take_front(numOriginalBlockArguments),
call    0 returned 100%
     4149:  247:      ArrayRef<Location>(outlinedFuncArgLocs)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  248:          .take_front(numOriginalBlockArguments));
     4149:  249:  {
     4149:  250:    OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
     4149:  251:    rewriter.setInsertionPointToEnd(newBlock);
call    0 returned 100%
     8298:  252:    SmallVector<Value> callValues;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     4149:  253:    llvm::append_range(callValues, newBlock->getArguments());
call    0 returned 100%
     4149:  254:    llvm::append_range(callValues, outlinedValues);
call    0 returned 100%
     4149:  255:    auto call = rewriter.create<func::CallOp>(loc, outlinedFunc, callValues);
call    0 returned 100%
     4149:  256:    if (callOp)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  257:      *callOp = call;
        -:  258:
        -:  259:    // `originalTerminator` was moved to `outlinedFuncBody` and is still valid.
        -:  260:    // Clone `originalTerminator` to take the callOp results then erase it from
        -:  261:    // `outlinedFuncBody`.
     8298:  262:    BlockAndValueMapping bvm;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
     6755:  263:    bvm.map(originalTerminator->getOperands(), call->getResults());
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
call    2 returned 100%
call    3 returned 100%
     4149:  264:    rewriter.clone(*originalTerminator, bvm);
call    0 returned 100%
     4149:  265:    rewriter.eraseOp(originalTerminator);
call    0 returned 100%
        -:  266:  }
        -:  267:
        -:  268:  // Lastly, explicit RAUW outlinedValues, only for uses within `outlinedFunc`.
        -:  269:  // Clone the `arith::ConstantIndexOp` at the start of `outlinedFuncBody`.
     4149:  270:  for (auto it : llvm::zip(outlinedValues, outlinedFuncBlockArgs.take_back(
    74514:  271:                                               outlinedValues.size()))) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
    66216:  272:    Value orig = std::get<0>(it);
call    0 returned 100%
    66216:  273:    Value repl = std::get<1>(it);
call    0 returned 100%
    66216:  274:    {
    66216:  275:      OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
    66216:  276:      rewriter.setInsertionPointToStart(outlinedFuncBody);
call    0 returned 100%
    66216:  277:      if (Operation *cst = orig.getDefiningOp<arith::ConstantIndexOp>()) {
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
    25758:  278:        BlockAndValueMapping bvm;
call    0 returned 100%
call    1 returned 100%
    12879:  279:        repl = rewriter.clone(*cst, bvm)->getResult(0);
call    0 returned 100%
call    1 returned 100%
        -:  280:      }
        -:  281:    }
    66216:  282:    orig.replaceUsesWithIf(repl, [&](OpOperand &opOperand) {
call    0 returned 100%
  6338311:  283:      return outlinedFunc->isProperAncestor(opOperand.getOwner());
call    0 returned 100%
        -:  284:    });
        -:  285:  }
        -:  286:
     4149:  287:  return outlinedFunc;
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  288:}
        -:  289:
function _ZN4mlir11outlineIfOpERNS_12RewriterBaseENS_3scf4IfOpEPNS_4func6FuncOpEN4llvm9StringRefES6_S8_ called 2399 returned 100% blocks executed 89%
     2399:  290:LogicalResult mlir::outlineIfOp(RewriterBase &b, scf::IfOp ifOp,
        -:  291:                                func::FuncOp *thenFn, StringRef thenFnName,
        -:  292:                                func::FuncOp *elseFn, StringRef elseFnName) {
     2399:  293:  IRRewriter rewriter(b);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2399:  294:  Location loc = ifOp.getLoc();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2399:  295:  FailureOr<func::FuncOp> outlinedFuncOpOrFailure;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2399:  296:  if (thenFn && !ifOp.getThenRegion().empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
     2399:  297:    outlinedFuncOpOrFailure = outlineSingleBlockRegion(
     2399:  298:        rewriter, loc, ifOp.getThenRegion(), thenFnName);
call    0 returned 100%
call    1 returned 100%
     2399:  299:    if (failed(outlinedFuncOpOrFailure))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  300:      return failure();
     2399:  301:    *thenFn = *outlinedFuncOpOrFailure;
        -:  302:  }
     2399:  303:  if (elseFn && !ifOp.getElseRegion().empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 73% (fallthrough)
branch  4 taken 27%
     1750:  304:    outlinedFuncOpOrFailure = outlineSingleBlockRegion(
     1750:  305:        rewriter, loc, ifOp.getElseRegion(), elseFnName);
call    0 returned 100%
call    1 returned 100%
     1750:  306:    if (failed(outlinedFuncOpOrFailure))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  307:      return failure();
     1750:  308:    *elseFn = *outlinedFuncOpOrFailure;
        -:  309:  }
     2399:  310:  return success();
call    0 returned 100%
        -:  311:}
        -:  312:
function _ZN4mlir25getInnermostParallelLoopsEPNS_9OperationERN4llvm15SmallVectorImplINS_3scf10ParallelOpEEE called 836479 returned 100% blocks executed 92%
   836479:  313:bool mlir::getInnermostParallelLoops(Operation *rootOp,
        -:  314:                                     SmallVectorImpl<scf::ParallelOp> &result) {
  836479*:  315:  assert(rootOp != nullptr && "Root operation must not be a nullptr.");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   836479:  316:  bool rootEnclosesPloops = false;
   935001:  317:  for (Region &region : rootOp->getRegions()) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
    95466:  318:    for (Block &block : region.getBlocks()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   883412:  319:      for (Operation &op : block) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
   836051:  320:        bool enclosesPloops = getInnermostParallelLoops(&op, result);
call    0 returned 100%
   836051:  321:        rootEnclosesPloops |= enclosesPloops;
  1672102:  322:        if (auto ploop = dyn_cast<scf::ParallelOp>(op)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      827:  323:          rootEnclosesPloops = true;
        -:  324:
        -:  325:          // Collect parallel loop if it is an innermost one.
      827:  326:          if (!enclosesPloops)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
      826:  327:            result.push_back(ploop);
call    0 returned 100%
        -:  328:        }
        -:  329:      }
        -:  330:    }
        -:  331:  }
   836479:  332:  return rootEnclosesPloops;
        -:  333:}
        -:  334:
        -:  335:// Build the IR that performs ceil division of a positive value by a constant:
        -:  336://    ceildiv(a, B) = divis(a + (B-1), B)
        -:  337:// where divis is rounding-to-zero division.
function _ZL15ceilDivPositiveRN4mlir9OpBuilderENS_8LocationENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####:  338:static Value ceilDivPositive(OpBuilder &builder, Location loc, Value dividend,
        -:  339:                             int64_t divisor) {
    #####:  340:  assert(divisor > 0 && "expected positive divisor");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  341:  assert(dividend.getType().isIndex() && "expected index-typed value");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  342:
    #####:  343:  Value divisorMinusOneCst =
    #####:  344:      builder.create<arith::ConstantIndexOp>(loc, divisor - 1);
call    0 never executed
call    1 never executed
    #####:  345:  Value divisorCst = builder.create<arith::ConstantIndexOp>(loc, divisor);
call    0 never executed
call    1 never executed
    #####:  346:  Value sum = builder.create<arith::AddIOp>(loc, dividend, divisorMinusOneCst);
call    0 never executed
call    1 never executed
    #####:  347:  return builder.create<arith::DivUIOp>(loc, sum, divisorCst);
call    0 never executed
        -:  348:}
        -:  349:
        -:  350:// Build the IR that performs ceil division of a positive value by another
        -:  351:// positive value:
        -:  352://    ceildiv(a, b) = divis(a + (b - 1), b)
        -:  353:// where divis is rounding-to-zero division.
function _ZL15ceilDivPositiveRN4mlir9OpBuilderENS_8LocationENS_5ValueES3_ called 0 returned 0% blocks executed 0%
    #####:  354:static Value ceilDivPositive(OpBuilder &builder, Location loc, Value dividend,
        -:  355:                             Value divisor) {
    #####:  356:  assert(dividend.getType().isIndex() && "expected index-typed value");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  357:
    #####:  358:  Value cstOne = builder.create<arith::ConstantIndexOp>(loc, 1);
call    0 never executed
call    1 never executed
    #####:  359:  Value divisorMinusOne = builder.create<arith::SubIOp>(loc, divisor, cstOne);
call    0 never executed
call    1 never executed
    #####:  360:  Value sum = builder.create<arith::AddIOp>(loc, dividend, divisorMinusOne);
call    0 never executed
call    1 never executed
    #####:  361:  return builder.create<arith::DivUIOp>(loc, sum, divisor);
call    0 never executed
        -:  362:}
        -:  363:
        -:  364:/// Helper to replace uses of loop carried values (iter_args) and loop
        -:  365:/// yield values while promoting single iteration scf.for ops.
function _ZL30replaceIterArgsAndYieldResultsN4mlir3scf5ForOpE called 0 returned 0% blocks executed 0%
    #####:  366:static void replaceIterArgsAndYieldResults(scf::ForOp forOp) {
        -:  367:  // Replace uses of iter arguments with iter operands (initial values).
    #####:  368:  auto iterOperands = forOp.getIterOperands();
call    0 never executed
    #####:  369:  auto iterArgs = forOp.getRegionIterArgs();
call    0 never executed
    #####:  370:  for (auto e : llvm::zip(iterOperands, iterArgs))
branch  0 never executed
branch  1 never executed
    #####:  371:    std::get<1>(e).replaceAllUsesWith(std::get<0>(e));
call    0 never executed
        -:  372:
        -:  373:  // Replace uses of loop results with the values yielded by the loop.
    #####:  374:  auto outerResults = forOp.getResults();
call    0 never executed
    #####:  375:  auto innerResults = forOp.getBody()->getTerminator()->getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  376:  for (auto e : llvm::zip(outerResults, innerResults))
branch  0 never executed
branch  1 never executed
    #####:  377:    std::get<0>(e).replaceAllUsesWith(std::get<1>(e));
call    0 never executed
    #####:  378:}
        -:  379:
        -:  380:/// Promotes the loop body of a forOp to its containing block if the forOp
        -:  381:/// it can be determined that the loop has a single iteration.
function _ZN4mlir24promoteIfSingleIterationENS_3scf5ForOpE called 0 returned 0% blocks executed 0%
    #####:  382:LogicalResult mlir::promoteIfSingleIteration(scf::ForOp forOp) {
    #####:  383:  auto lbCstOp = forOp.getLowerBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  384:  auto ubCstOp = forOp.getUpperBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  385:  auto stepCstOp = forOp.getStep().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  386:  if (!lbCstOp || !ubCstOp || !stepCstOp || lbCstOp.value() < 0 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  387:      ubCstOp.value() < 0 || stepCstOp.value() < 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  388:    return failure();
    #####:  389:  int64_t tripCount =
    #####:  390:      mlir::ceilDiv(ubCstOp.value() - lbCstOp.value(), stepCstOp.value());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  391:  if (tripCount != 1)
branch  0 never executed
branch  1 never executed
    #####:  392:    return failure();
    #####:  393:  auto iv = forOp.getInductionVar();
call    0 never executed
    #####:  394:  iv.replaceAllUsesWith(lbCstOp);
call    0 never executed
        -:  395:
    #####:  396:  replaceIterArgsAndYieldResults(forOp);
call    0 never executed
        -:  397:
        -:  398:  // Move the loop body operations, except for its terminator, to the loop's
        -:  399:  // containing block.
    #####:  400:  auto *parentBlock = forOp->getBlock();
call    0 never executed
    #####:  401:  forOp.getBody()->getTerminator()->erase();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  402:  parentBlock->getOperations().splice(Block::iterator(forOp),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  403:                                      forOp.getBody()->getOperations());
call    0 never executed
call    1 never executed
    #####:  404:  forOp.erase();
call    0 never executed
    #####:  405:  return success();
        -:  406:}
        -:  407:
        -:  408:/// Generates unrolled copies of scf::ForOp 'loopBodyBlock', with
        -:  409:/// associated 'forOpIV' by 'unrollFactor', calling 'ivRemapFn' to remap
        -:  410:/// 'forOpIV' for each unrolled body. If specified, annotates the Ops in each
        -:  411:/// unrolled iteration using annotateFn.
function _ZL20generateUnrolledLoopPN4mlir5BlockENS_5ValueEmN4llvm12function_refIFS2_jS2_NS_9OpBuilderEEEENS4_IFvjPNS_9OperationES5_EEENS_10ValueRangeESC_ called 0 returned 0% blocks executed 0%
    #####:  412:static void generateUnrolledLoop(
        -:  413:    Block *loopBodyBlock, Value forOpIV, uint64_t unrollFactor,
        -:  414:    function_ref<Value(unsigned, Value, OpBuilder)> ivRemapFn,
        -:  415:    function_ref<void(unsigned, Operation *, OpBuilder)> annotateFn,
        -:  416:    ValueRange iterArgs, ValueRange yieldedValues) {
        -:  417:  // Builder to insert unrolled bodies just before the terminator of the body of
        -:  418:  // 'forOp'.
    #####:  419:  auto builder = OpBuilder::atBlockTerminator(loopBodyBlock);
call    0 never executed
        -:  420:
    #####:  421:  if (!annotateFn)
branch  0 never executed
branch  1 never executed
    #####:  422:    annotateFn = [](unsigned, Operation *, OpBuilder) {};
        -:  423:
        -:  424:  // Keep a pointer to the last non-terminator operation in the original block
        -:  425:  // so that we know what to clone (since we are doing this in-place).
    #####:  426:  Block::iterator srcBlockEnd = std::prev(loopBodyBlock->end(), 2);
        -:  427:
        -:  428:  // Unroll the contents of 'forOp' (append unrollFactor - 1 additional copies).
    #####:  429:  SmallVector<Value, 4> lastYielded(yieldedValues);
call    0 never executed
        -:  430:
    #####:  431:  for (unsigned i = 1; i < unrollFactor; i++) {
branch  0 never executed
branch  1 never executed
    #####:  432:    BlockAndValueMapping operandMap;
call    0 never executed
call    1 never executed
        -:  433:
        -:  434:    // Prepare operand map.
    #####:  435:    operandMap.map(iterArgs, lastYielded);
call    0 never executed
        -:  436:
        -:  437:    // If the induction variable is used, create a remapping to the value for
        -:  438:    // this unrolled instance.
    #####:  439:    if (!forOpIV.use_empty()) {
branch  0 never executed
branch  1 never executed
    #####:  440:      Value ivUnroll = ivRemapFn(i, forOpIV, builder);
call    0 never executed
    #####:  441:      operandMap.map(forOpIV, ivUnroll);
call    0 never executed
        -:  442:    }
        -:  443:
        -:  444:    // Clone the original body of 'forOp'.
    #####:  445:    for (auto it = loopBodyBlock->begin(); it != std::next(srcBlockEnd); it++) {
branch  0 never executed
branch  1 never executed
    #####:  446:      Operation *clonedOp = builder.clone(*it, operandMap);
call    0 never executed
call    1 never executed
    #####:  447:      annotateFn(i, clonedOp, builder);
call    0 never executed
        -:  448:    }
        -:  449:
        -:  450:    // Update yielded values.
    #####:  451:    for (unsigned i = 0, e = lastYielded.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####:  452:      lastYielded[i] = operandMap.lookup(yieldedValues[i]);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  453:  }
        -:  454:
        -:  455:  // Make sure we annotate the Ops in the original body. We do this last so that
        -:  456:  // any annotations are not copied into the cloned Ops above.
    #####:  457:  for (auto it = loopBodyBlock->begin(); it != std::next(srcBlockEnd); it++)
branch  0 never executed
branch  1 never executed
    #####:  458:    annotateFn(0, &*it, builder);
call    0 never executed
call    1 never executed
        -:  459:
        -:  460:  // Update operands of the yield statement.
    #####:  461:  loopBodyBlock->getTerminator()->setOperands(lastYielded);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  462:}
        -:  463:
        -:  464:/// Unrolls 'forOp' by 'unrollFactor', returns success if the loop is unrolled.
function _ZN4mlir18loopUnrollByFactorENS_3scf5ForOpEmN4llvm12function_refIFvjPNS_9OperationENS_9OpBuilderEEEE called 6 returned 100% blocks executed 7%
        6:  465:LogicalResult mlir::loopUnrollByFactor(
        -:  466:    scf::ForOp forOp, uint64_t unrollFactor,
        -:  467:    function_ref<void(unsigned, Operation *, OpBuilder)> annotateFn) {
       6*:  468:  assert(unrollFactor > 0 && "expected positive unroll factor");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  469:
        -:  470:  // Return if the loop body is empty.
       6*:  471:  if (llvm::hasSingleElement(forOp.getBody()->getOperations()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        6:  472:    return success();
        -:  473:
        -:  474:  // Compute tripCount = ceilDiv((upperBound - lowerBound), step) and populate
        -:  475:  // 'upperBoundUnrolled' and 'stepUnrolled' for static and dynamic cases.
    #####:  476:  OpBuilder boundsBuilder(forOp);
call    0 never executed
    #####:  477:  auto loc = forOp.getLoc();
call    0 never executed
    #####:  478:  Value step = forOp.getStep();
call    0 never executed
    #####:  479:  Value upperBoundUnrolled;
    #####:  480:  Value stepUnrolled;
    #####:  481:  bool generateEpilogueLoop = true;
        -:  482:
    #####:  483:  auto lbCstOp = forOp.getLowerBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  484:  auto ubCstOp = forOp.getUpperBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  485:  auto stepCstOp = forOp.getStep().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:  486:  if (lbCstOp && ubCstOp && stepCstOp) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  487:    // Constant loop bounds computation.
    #####:  488:    int64_t lbCst = lbCstOp.value();
call    0 never executed
    #####:  489:    int64_t ubCst = ubCstOp.value();
call    0 never executed
    #####:  490:    int64_t stepCst = stepCstOp.value();
call    0 never executed
    #####:  491:    assert(lbCst >= 0 && ubCst >= 0 && stepCst >= 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  492:           "expected positive loop bounds and step");
    #####:  493:    int64_t tripCount = mlir::ceilDiv(ubCst - lbCst, stepCst);
call    0 never executed
        -:  494:
    #####:  495:    if (unrollFactor == 1) {
branch  0 never executed
branch  1 never executed
    #####:  496:      if (tripCount == 1 && failed(promoteIfSingleIteration(forOp)))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  497:        return failure();
    #####:  498:      return success();
        -:  499:    }
        -:  500:
    #####:  501:    int64_t tripCountEvenMultiple = tripCount - (tripCount % unrollFactor);
    #####:  502:    int64_t upperBoundUnrolledCst = lbCst + tripCountEvenMultiple * stepCst;
    #####:  503:    assert(upperBoundUnrolledCst <= ubCst);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  504:    int64_t stepUnrolledCst = stepCst * unrollFactor;
        -:  505:
        -:  506:    // Create constant for 'upperBoundUnrolled' and set epilogue loop flag.
    #####:  507:    generateEpilogueLoop = upperBoundUnrolledCst < ubCst;
    #####:  508:    if (generateEpilogueLoop)
branch  0 never executed
branch  1 never executed
    #####:  509:      upperBoundUnrolled = boundsBuilder.create<arith::ConstantIndexOp>(
    #####:  510:          loc, upperBoundUnrolledCst);
call    0 never executed
        -:  511:    else
    #####:  512:      upperBoundUnrolled = ubCstOp;
        -:  513:
        -:  514:    // Create constant for 'stepUnrolled'.
    #####:  515:    stepUnrolled = stepCst == stepUnrolledCst
branch  0 never executed
branch  1 never executed
        -:  516:                       ? step
    #####:  517:                       : boundsBuilder.create<arith::ConstantIndexOp>(
    #####:  518:                             loc, stepUnrolledCst);
call    0 never executed
        -:  519:  } else {
        -:  520:    // Dynamic loop bounds computation.
        -:  521:    // TODO: Add dynamic asserts for negative lb/ub/step, or
        -:  522:    // consider using ceilDiv from AffineApplyExpander.
    #####:  523:    auto lowerBound = forOp.getLowerBound();
call    0 never executed
    #####:  524:    auto upperBound = forOp.getUpperBound();
call    0 never executed
    #####:  525:    Value diff =
    #####:  526:        boundsBuilder.create<arith::SubIOp>(loc, upperBound, lowerBound);
call    0 never executed
call    1 never executed
    #####:  527:    Value tripCount = ceilDivPositive(boundsBuilder, loc, diff, step);
call    0 never executed
    #####:  528:    Value unrollFactorCst =
    #####:  529:        boundsBuilder.create<arith::ConstantIndexOp>(loc, unrollFactor);
call    0 never executed
call    1 never executed
    #####:  530:    Value tripCountRem =
    #####:  531:        boundsBuilder.create<arith::RemSIOp>(loc, tripCount, unrollFactorCst);
call    0 never executed
call    1 never executed
        -:  532:    // Compute tripCountEvenMultiple = tripCount - (tripCount % unrollFactor)
    #####:  533:    Value tripCountEvenMultiple =
    #####:  534:        boundsBuilder.create<arith::SubIOp>(loc, tripCount, tripCountRem);
call    0 never executed
call    1 never executed
        -:  535:    // Compute upperBoundUnrolled = lowerBound + tripCountEvenMultiple * step
    #####:  536:    upperBoundUnrolled = boundsBuilder.create<arith::AddIOp>(
        -:  537:        loc, lowerBound,
    #####:  538:        boundsBuilder.create<arith::MulIOp>(loc, tripCountEvenMultiple, step));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  539:    // Scale 'step' by 'unrollFactor'.
    #####:  540:    stepUnrolled =
    #####:  541:        boundsBuilder.create<arith::MulIOp>(loc, step, unrollFactorCst);
call    0 never executed
        -:  542:  }
        -:  543:
        -:  544:  // Create epilogue clean up loop starting at 'upperBoundUnrolled'.
    #####:  545:  if (generateEpilogueLoop) {
branch  0 never executed
branch  1 never executed
    #####:  546:    OpBuilder epilogueBuilder(forOp->getContext());
call    0 never executed
call    1 never executed
    #####:  547:    epilogueBuilder.setInsertionPoint(forOp->getBlock(),
call    0 never executed
call    1 never executed
        -:  548:                                      std::next(Block::iterator(forOp)));
    #####:  549:    auto epilogueForOp = cast<scf::ForOp>(epilogueBuilder.clone(*forOp));
call    0 never executed
call    1 never executed
    #####:  550:    epilogueForOp.setLowerBound(upperBoundUnrolled);
call    0 never executed
        -:  551:
        -:  552:    // Update uses of loop results.
    #####:  553:    auto results = forOp.getResults();
call    0 never executed
    #####:  554:    auto epilogueResults = epilogueForOp.getResults();
call    0 never executed
        -:  555:
    #####:  556:    for (auto e : llvm::zip(results, epilogueResults)) {
branch  0 never executed
branch  1 never executed
    #####:  557:      std::get<0>(e).replaceAllUsesWith(std::get<1>(e));
call    0 never executed
        -:  558:    }
    #####:  559:    epilogueForOp->setOperands(epilogueForOp.getNumControlOperands(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  560:                               epilogueForOp.getNumIterOperands(), results);
    #####:  561:    (void)promoteIfSingleIteration(epilogueForOp);
call    0 never executed
        -:  562:  }
        -:  563:
        -:  564:  // Create unrolled loop.
    #####:  565:  forOp.setUpperBound(upperBoundUnrolled);
call    0 never executed
    #####:  566:  forOp.setStep(stepUnrolled);
call    0 never executed
        -:  567:
    #####:  568:  auto iterArgs = ValueRange(forOp.getRegionIterArgs());
call    0 never executed
call    1 never executed
    #####:  569:  auto yieldedValues = forOp.getBody()->getTerminator()->getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  570:
    #####:  571:  generateUnrolledLoop(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  572:      forOp.getBody(), forOp.getInductionVar(), unrollFactor,
function _ZZN4mlir18loopUnrollByFactorENS_3scf5ForOpEmN4llvm12function_refIFvjPNS_9OperationENS_9OpBuilderEEEEENKUljNS_5ValueES6_E_clEjS9_S6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  573:      [&](unsigned i, Value iv, OpBuilder b) {
        -:  574:        // iv' = iv + step * i;
    #####:  575:        auto stride = b.create<arith::MulIOp>(
    #####:  576:            loc, step, b.create<arith::ConstantIndexOp>(loc, i));
call    0 never executed
call    1 never executed
    #####:  577:        return b.create<arith::AddIOp>(loc, iv, stride);
call    0 never executed
        -:  578:      },
        -:  579:      annotateFn, iterArgs, yieldedValues);
        -:  580:  // Promote the loop body up if this has turned into a single iteration loop.
    #####:  581:  (void)promoteIfSingleIteration(forOp);
call    0 never executed
    #####:  582:  return success();
        -:  583:}
        -:  584:
        -:  585:/// Return the new lower bound, upper bound, and step in that order. Insert any
        -:  586:/// additional bounds calculations before the given builder and any additional
        -:  587:/// conversion back to the original loop induction value inside the given Block.
function _ZL13normalizeLoopRN4mlir9OpBuilderES1_NS_8LocationENS_5ValueES3_S3_S3_ called 4 returned 100% blocks executed 81%
        4:  588:static LoopParams normalizeLoop(OpBuilder &boundsBuilder,
        -:  589:                                OpBuilder &insideLoopBuilder, Location loc,
        -:  590:                                Value lowerBound, Value upperBound, Value step,
        -:  591:                                Value inductionVar) {
        -:  592:  // Check if the loop is already known to have a constant zero lower bound or
        -:  593:  // a constant one step.
        4:  594:  bool isZeroBased = false;
        4:  595:  if (auto ubCst = lowerBound.getDefiningOp<arith::ConstantIndexOp>())
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2:  596:    isZeroBased = ubCst.value() == 0;
call    0 returned 100%
        -:  597:
        4:  598:  bool isStepOne = false;
        4:  599:  if (auto stepCst = step.getDefiningOp<arith::ConstantIndexOp>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        4:  600:    isStepOne = stepCst.value() == 1;
call    0 returned 100%
        -:  601:
        -:  602:  // Compute the number of iterations the loop executes: ceildiv(ub - lb, step)
        -:  603:  // assuming the step is strictly positive.  Update the bounds and the step
        -:  604:  // of the loop to go from 0 to the number of iterations, if necessary.
        4:  605:  if (isZeroBased && isStepOne)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  606:    return {/*lowerBound=*/lowerBound, /*upperBound=*/upperBound,
        2:  607:            /*step=*/step};
        -:  608:
        2:  609:  Value diff = boundsBuilder.create<arith::SubIOp>(loc, upperBound, lowerBound);
call    0 returned 100%
call    1 returned 100%
        2:  610:  Value newUpperBound =
        2:  611:      boundsBuilder.create<arith::CeilDivSIOp>(loc, diff, step);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  612:
        2:  613:  Value newLowerBound =
        -:  614:      isZeroBased ? lowerBound
       2*:  615:                  : boundsBuilder.create<arith::ConstantIndexOp>(loc, 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        2:  616:  Value newStep =
       2*:  617:      isStepOne ? step : boundsBuilder.create<arith::ConstantIndexOp>(loc, 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        -:  618:
        -:  619:  // Insert code computing the value of the original loop induction variable
        -:  620:  // from the "normalized" one.
        2:  621:  Value scaled =
        -:  622:      isStepOne
        -:  623:          ? inductionVar
       2*:  624:          : insideLoopBuilder.create<arith::MulIOp>(loc, inductionVar, step);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        2:  625:  Value shifted =
        -:  626:      isZeroBased
        -:  627:          ? scaled
       2*:  628:          : insideLoopBuilder.create<arith::AddIOp>(loc, scaled, lowerBound);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  629:
        2:  630:  SmallPtrSet<Operation *, 2> preserve{scaled.getDefiningOp(),
call    0 returned 100%
        2:  631:                                       shifted.getDefiningOp()};
call    0 returned 100%
call    1 returned 100%
        2:  632:  inductionVar.replaceAllUsesExcept(shifted, preserve);
call    0 returned 100%
        2:  633:  return {/*lowerBound=*/newLowerBound, /*upperBound=*/newUpperBound,
        2:  634:          /*step=*/newStep};
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  635:}
        -:  636:
        -:  637:/// Transform a loop with a strictly positive step
        -:  638:///   for %i = %lb to %ub step %s
        -:  639:/// into a 0-based loop with step 1
        -:  640:///   for %ii = 0 to ceildiv(%ub - %lb, %s) step 1 {
        -:  641:///     %i = %ii * %s + %lb
        -:  642:/// Insert the induction variable remapping in the body of `inner`, which is
        -:  643:/// expected to be either `loop` or another loop perfectly nested under `loop`.
        -:  644:/// Insert the definition of new bounds immediate before `outer`, which is
        -:  645:/// expected to be either `loop` or its parent in the loop nest.
function _ZL13normalizeLoopN4mlir3scf5ForOpES1_S1_ called 4 returned 100% blocks executed 100%
        4:  646:static void normalizeLoop(scf::ForOp loop, scf::ForOp outer, scf::ForOp inner) {
        4:  647:  OpBuilder builder(outer);
call    0 returned 100%
        4:  648:  OpBuilder innerBuilder = OpBuilder::atBlockBegin(inner.getBody());
call    0 returned 100%
call    1 returned 100%
        4:  649:  auto loopPieces = normalizeLoop(builder, innerBuilder, loop.getLoc(),
call    0 returned 100%
        4:  650:                                  loop.getLowerBound(), loop.getUpperBound(),
call    0 returned 100%
call    1 returned 100%
        8:  651:                                  loop.getStep(), loop.getInductionVar());
call    0 returned 100%
call    1 returned 100%
        -:  652:
        4:  653:  loop.setLowerBound(loopPieces.lowerBound);
call    0 returned 100%
        4:  654:  loop.setUpperBound(loopPieces.upperBound);
call    0 returned 100%
        4:  655:  loop.setStep(loopPieces.step);
call    0 returned 100%
        4:  656:}
        -:  657:
function _ZN4mlir13coalesceLoopsEN4llvm15MutableArrayRefINS_3scf5ForOpEEE called 2 returned 100% blocks executed 90%
        2:  658:void mlir::coalesceLoops(MutableArrayRef<scf::ForOp> loops) {
        2:  659:  if (loops.size() < 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  660:    return;
        -:  661:
        2:  662:  scf::ForOp innermost = loops.back();
call    0 returned 100%
        2:  663:  scf::ForOp outermost = loops.front();
        -:  664:
        -:  665:  // 1. Make sure all loops iterate from 0 to upperBound with step 1.  This
        -:  666:  // allows the following code to assume upperBound is the number of iterations.
        6:  667:  for (auto loop : loops)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:  668:    normalizeLoop(loop, outermost, innermost);
call    0 returned 100%
        -:  669:
        -:  670:  // 2. Emit code computing the upper bound of the coalesced loop as product
        -:  671:  // of the number of iterations of all loops.
        2:  672:  OpBuilder builder(outermost);
call    0 returned 100%
        2:  673:  Location loc = outermost.getLoc();
call    0 returned 100%
        2:  674:  Value upperBound = outermost.getUpperBound();
call    0 returned 100%
        4:  675:  for (auto loop : loops.drop_front())
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        2:  676:    upperBound =
        2:  677:        builder.create<arith::MulIOp>(loc, upperBound, loop.getUpperBound());
call    0 returned 100%
call    1 returned 100%
        2:  678:  outermost.setUpperBound(upperBound);
call    0 returned 100%
        -:  679:
        2:  680:  builder.setInsertionPointToStart(outermost.getBody());
call    0 returned 100%
call    1 returned 100%
        -:  681:
        -:  682:  // 3. Remap induction variables. For each original loop, the value of the
        -:  683:  // induction variable can be obtained by dividing the induction variable of
        -:  684:  // the linearized loop by the total number of iterations of the loops nested
        -:  685:  // in it modulo the number of iterations in this loop (remove the values
        -:  686:  // related to the outer loops):
        -:  687:  //   iv_i = floordiv(iv_linear, product-of-loop-ranges-until-i) mod range_i.
        -:  688:  // Compute these iteratively from the innermost loop by creating a "running
        -:  689:  // quotient" of division by the range.
        2:  690:  Value previous = outermost.getInductionVar();
call    0 returned 100%
        6:  691:  for (unsigned i = 0, e = loops.size(); i < e; ++i) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:  692:    unsigned idx = loops.size() - i - 1;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  693:    if (i != 0)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  694:      previous = builder.create<arith::DivSIOp>(loc, previous,
        2:  695:                                                loops[idx + 1].getUpperBound());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -:  696:
        4:  697:    Value iv = (i == e - 1) ? previous
        4:  698:                            : builder.create<arith::RemSIOp>(
        4:  699:                                  loc, previous, loops[idx].getUpperBound());
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
call    5 returned 100%
        4:  700:    replaceAllUsesInRegionWith(loops[idx].getInductionVar(), iv,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        4:  701:                               loops.back().getRegion());
call    0 returned 100%
        -:  702:  }
        -:  703:
        -:  704:  // 4. Move the operations from the innermost just above the second-outermost
        -:  705:  // loop, delete the extra terminator and the second-outermost loop.
        2:  706:  scf::ForOp second = loops[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        2:  707:  innermost.getBody()->back().erase();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2:  708:  outermost.getBody()->getOperations().splice(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  709:      Block::iterator(second.getOperation()),
        2:  710:      innermost.getBody()->getOperations());
call    0 returned 100%
call    1 returned 100%
        2:  711:  second.erase();
call    0 returned 100%
        -:  712:}
        -:  713:
function _ZN4mlir21collapseParallelLoopsENS_3scf10ParallelOpEN4llvm8ArrayRefISt6vectorIjSaIjEEEE called 0 returned 0% blocks executed 0%
    #####:  714:void mlir::collapseParallelLoops(
        -:  715:    scf::ParallelOp loops, ArrayRef<std::vector<unsigned>> combinedDimensions) {
    #####:  716:  OpBuilder outsideBuilder(loops);
call    0 never executed
    #####:  717:  Location loc = loops.getLoc();
call    0 never executed
        -:  718:
        -:  719:  // Presort combined dimensions.
    #####:  720:  auto sortedDimensions = llvm::to_vector<3>(combinedDimensions);
call    0 never executed
    #####:  721:  for (auto &dims : sortedDimensions)
branch  0 never executed
branch  1 never executed
    #####:  722:    llvm::sort(dims);
call    0 never executed
        -:  723:
        -:  724:  // Normalize ParallelOp's iteration pattern.
    #####:  725:  SmallVector<Value, 3> normalizedLowerBounds, normalizedSteps,
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  726:      normalizedUpperBounds;
branch  0 never executed
branch  1 never executed
    #####:  727:  for (unsigned i = 0, e = loops.getNumLoops(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  728:    OpBuilder insideLoopBuilder = OpBuilder::atBlockBegin(loops.getBody());
call    0 never executed
call    1 never executed
    #####:  729:    auto resultBounds =
        -:  730:        normalizeLoop(outsideBuilder, insideLoopBuilder, loc,
    #####:  731:                      loops.getLowerBound()[i], loops.getUpperBound()[i],
call    0 never executed
call    1 never executed
    #####:  732:                      loops.getStep()[i], loops.getBody()->getArgument(i));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  733:
    #####:  734:    normalizedLowerBounds.push_back(resultBounds.lowerBound);
call    0 never executed
    #####:  735:    normalizedUpperBounds.push_back(resultBounds.upperBound);
call    0 never executed
    #####:  736:    normalizedSteps.push_back(resultBounds.step);
call    0 never executed
        -:  737:  }
        -:  738:
        -:  739:  // Combine iteration spaces.
    #####:  740:  SmallVector<Value, 3> lowerBounds, upperBounds, steps;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  741:  auto cst0 = outsideBuilder.create<arith::ConstantIndexOp>(loc, 0);
call    0 never executed
    #####:  742:  auto cst1 = outsideBuilder.create<arith::ConstantIndexOp>(loc, 1);
call    0 never executed
    #####:  743:  for (unsigned i = 0, e = sortedDimensions.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  744:    Value newUpperBound = outsideBuilder.create<arith::ConstantIndexOp>(loc, 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  745:    for (auto idx : sortedDimensions[i]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  746:      newUpperBound = outsideBuilder.create<arith::MulIOp>(
    #####:  747:          loc, newUpperBound, normalizedUpperBounds[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  748:    }
    #####:  749:    lowerBounds.push_back(cst0);
call    0 never executed
    #####:  750:    steps.push_back(cst1);
call    0 never executed
    #####:  751:    upperBounds.push_back(newUpperBound);
call    0 never executed
        -:  752:  }
        -:  753:
        -:  754:  // Create new ParallelLoop with conversions to the original induction values.
        -:  755:  // The loop below uses divisions to get the relevant range of values in the
        -:  756:  // new induction value that represent each range of the original induction
        -:  757:  // value. The remainders then determine based on that range, which iteration
        -:  758:  // of the original induction value this represents. This is a normalized value
        -:  759:  // that is un-normalized already by the previous logic.
    #####:  760:  auto newPloop = outsideBuilder.create<scf::ParallelOp>(
        -:  761:      loc, lowerBounds, upperBounds, steps,
function _ZZN4mlir21collapseParallelLoopsENS_3scf10ParallelOpEN4llvm8ArrayRefISt6vectorIjSaIjEEEEENKUlRNS_9OpBuilderENS_8LocationENS_10ValueRangeEE_clES9_SA_SB_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  762:      [&](OpBuilder &insideBuilder, Location, ValueRange ploopIVs) {
    #####:  763:        for (unsigned i = 0, e = combinedDimensions.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  764:          Value previous = ploopIVs[i];
call    0 never executed
    #####:  765:          unsigned numberCombinedDimensions = combinedDimensions[i].size();
branch  0 never executed
branch  1 never executed
        -:  766:          // Iterate over all except the last induction value.
    #####:  767:          for (unsigned j = numberCombinedDimensions - 1; j > 0; --j) {
branch  0 never executed
branch  1 never executed
    #####:  768:            unsigned idx = combinedDimensions[i][j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  769:
        -:  770:            // Determine the current induction value's current loop iteration
    #####:  771:            Value iv = insideBuilder.create<arith::RemSIOp>(
    #####:  772:                loc, previous, normalizedUpperBounds[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  773:            replaceAllUsesInRegionWith(loops.getBody()->getArgument(idx), iv,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  774:                                       loops.getRegion());
        -:  775:
        -:  776:            // Remove the effect of the current induction value to prepare for
        -:  777:            // the next value.
    #####:  778:            previous = insideBuilder.create<arith::DivSIOp>(
    #####:  779:                loc, previous, normalizedUpperBounds[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  780:          }
        -:  781:
        -:  782:          // The final induction value is just the remaining value.
    #####:  783:          unsigned idx = combinedDimensions[i][0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  784:          replaceAllUsesInRegionWith(loops.getBody()->getArgument(idx),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  785:                                     previous, loops.getRegion());
        -:  786:        }
    #####:  787:      });
call    0 never executed
        -:  788:
        -:  789:  // Replace the old loop with the new loop.
    #####:  790:  loops.getBody()->back().erase();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  791:  newPloop.getBody()->getOperations().splice(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  792:      Block::iterator(newPloop.getBody()->back()),
call    0 never executed
call    1 never executed
    #####:  793:      loops.getBody()->getOperations());
call    0 never executed
call    1 never executed
    #####:  794:  loops.erase();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  795:}
        -:  796:
        -:  797:// Hoist the ops within `outer` that appear before `inner`.
        -:  798:// Such ops include the ops that have been introduced by parametric tiling.
        -:  799:// Ops that come from triangular loops (i.e. that belong to the program slice
        -:  800:// rooted at `outer`) and ops that have side effects cannot be hoisted.
        -:  801:// Return failure when any op fails to hoist.
function _ZL15hoistOpsBetweenN4mlir3scf5ForOpES1_ called 0 returned 0% blocks executed 0%
    #####:  802:static LogicalResult hoistOpsBetween(scf::ForOp outer, scf::ForOp inner) {
    #####:  803:  SetVector<Operation *> forwardSlice;
call    0 never executed
    #####:  804:  getForwardSlice(
call    0 never executed
call    1 never executed
        -:  805:      outer.getInductionVar(), &forwardSlice,
    #####:  806:      [&inner](Operation *op) { return op != inner.getOperation(); });
    #####:  807:  LogicalResult status = success();
call    0 never executed
    #####:  808:  SmallVector<Operation *, 8> toHoist;
call    0 never executed
call    1 never executed
    #####:  809:  for (auto &op : outer.getBody()->without_terminator()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  810:    // Stop when encountering the inner loop.
    #####:  811:    if (&op == inner.getOperation())
branch  0 never executed
branch  1 never executed
        -:  812:      break;
        -:  813:    // Skip over non-hoistable ops.
    #####:  814:    if (forwardSlice.count(&op) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  815:      status = failure();
    #####:  816:      continue;
        -:  817:    }
        -:  818:    // Skip intermediate scf::ForOp, these are not considered a failure.
    #####:  819:    if (isa<scf::ForOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  820:      continue;
        -:  821:    // Skip other ops with regions.
    #####:  822:    if (op.getNumRegions() > 0) {
branch  0 never executed
branch  1 never executed
    #####:  823:      status = failure();
    #####:  824:      continue;
        -:  825:    }
        -:  826:    // Skip if op has side effects.
        -:  827:    // TODO: loads to immutable memory regions are ok.
    #####:  828:    if (!MemoryEffectOpInterface::hasNoEffect(&op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  829:      status = failure();
    #####:  830:      continue;
        -:  831:    }
    #####:  832:    toHoist.push_back(&op);
call    0 never executed
        -:  833:  }
    #####:  834:  auto *outerForOp = outer.getOperation();
    #####:  835:  for (auto *op : toHoist)
branch  0 never executed
branch  1 never executed
    #####:  836:    op->moveBefore(outerForOp);
call    0 never executed
    #####:  837:  return status;
branch  0 never executed
branch  1 never executed
        -:  838:}
        -:  839:
        -:  840:// Traverse the interTile and intraTile loops and try to hoist ops such that
        -:  841:// bands of perfectly nested loops are isolated.
        -:  842:// Return failure if either perfect interTile or perfect intraTile bands cannot
        -:  843:// be formed.
function _ZL15tryIsolateBandsRKSt4pairIN4llvm11SmallVectorIN4mlir3scf5ForOpELj8EEES5_E called 0 returned 0% blocks executed 0%
    #####:  844:static LogicalResult tryIsolateBands(const TileLoops &tileLoops) {
    #####:  845:  LogicalResult status = success();
branch  0 never executed
branch  1 never executed
    #####:  846:  const Loops &interTile = tileLoops.first;
    #####:  847:  const Loops &intraTile = tileLoops.second;
    #####:  848:  auto size = interTile.size();
branch  0 never executed
branch  1 never executed
    #####:  849:  assert(size == intraTile.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  850:  if (size <= 1)
branch  0 never executed
branch  1 never executed
    #####:  851:    return success();
    #####:  852:  for (unsigned s = 1; s < size; ++s)
branch  0 never executed
branch  1 never executed
    #####:  853:    status = succeeded(status) ? hoistOpsBetween(intraTile[0], intraTile[s])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  854:                               : failure();
    #####:  855:  for (unsigned s = 1; s < size; ++s)
branch  0 never executed
branch  1 never executed
    #####:  856:    status = succeeded(status) ? hoistOpsBetween(interTile[0], interTile[s])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  857:                               : failure();
    #####:  858:  return status;
        -:  859:}
        -:  860:
        -:  861:/// Collect perfectly nested loops starting from `rootForOps`.  Loops are
        -:  862:/// perfectly nested if each loop is the first and only non-terminator operation
        -:  863:/// in the parent loop.  Collect at most `maxLoops` loops and append them to
        -:  864:/// `forOps`.
        -:  865:template <typename T>
function _Z27getPerfectlyNestedLoopsImplIN4mlir3scf5ForOpEEvRN4llvm15SmallVectorImplIT_EES5_j called 12 returned 100% blocks executed 100%
       12:  866:static void getPerfectlyNestedLoopsImpl(
        -:  867:    SmallVectorImpl<T> &forOps, T rootForOp,
        -:  868:    unsigned maxLoops = std::numeric_limits<unsigned>::max()) {
       14:  869:  for (unsigned i = 0; i < maxLoops; ++i) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  870:    forOps.push_back(rootForOp);
call    0 returned 100%
       14:  871:    Block &body = rootForOp.getRegion().front();
call    0 returned 100%
call    1 returned 100%
       28:  872:    if (body.begin() != std::prev(body.end(), 2))
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        -:  873:      return;
        -:  874:
        4:  875:    rootForOp = dyn_cast<T>(&body.front());
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        4:  876:    if (!rootForOp)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  877:      return;
        -:  878:  }
        -:  879:}
        -:  880:
function _ZL13stripmineSinkN4mlir3scf5ForOpENS_5ValueEN4llvm8ArrayRefIS1_EE called 0 returned 0% blocks executed 0%
    #####:  881:static Loops stripmineSink(scf::ForOp forOp, Value factor,
        -:  882:                           ArrayRef<scf::ForOp> targets) {
    #####:  883:  auto originalStep = forOp.getStep();
call    0 never executed
    #####:  884:  auto iv = forOp.getInductionVar();
call    0 never executed
        -:  885:
    #####:  886:  OpBuilder b(forOp);
call    0 never executed
    #####:  887:  forOp.setStep(b.create<arith::MulIOp>(forOp.getLoc(), originalStep, factor));
call    0 never executed
call    1 never executed
        -:  888:
    #####:  889:  Loops innerLoops;
    #####:  890:  for (auto t : targets) {
branch  0 never executed
branch  1 never executed
        -:  891:    // Save information for splicing ops out of t when done
    #####:  892:    auto begin = t.getBody()->begin();
call    0 never executed
    #####:  893:    auto nOps = t.getBody()->getOperations().size();
        -:  894:
        -:  895:    // Insert newForOp before the terminator of `t`.
    #####:  896:    auto b = OpBuilder::atBlockTerminator((t.getBody()));
call    0 never executed
    #####:  897:    Value stepped = b.create<arith::AddIOp>(t.getLoc(), iv, forOp.getStep());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  898:    Value less = b.create<arith::CmpIOp>(t.getLoc(), arith::CmpIPredicate::slt,
    #####:  899:                                         forOp.getUpperBound(), stepped);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  900:    Value ub = b.create<arith::SelectOp>(t.getLoc(), less,
    #####:  901:                                         forOp.getUpperBound(), stepped);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  902:
        -:  903:    // Splice [begin, begin + nOps - 1) into `newForOp` and replace uses.
    #####:  904:    auto newForOp = b.create<scf::ForOp>(t.getLoc(), iv, ub, originalStep);
call    0 never executed
    #####:  905:    newForOp.getBody()->getOperations().splice(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  906:        newForOp.getBody()->getOperations().begin(),
branch  0 never executed
branch  1 never executed
    #####:  907:        t.getBody()->getOperations(), begin, std::next(begin, nOps - 1));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  908:    replaceAllUsesInRegionWith(iv, newForOp.getInductionVar(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  909:                               newForOp.getRegion());
        -:  910:
    #####:  911:    innerLoops.push_back(newForOp);
call    0 never executed
        -:  912:  }
        -:  913:
    #####:  914:  return innerLoops;
        -:  915:}
        -:  916:
        -:  917:// Stripmines a `forOp` by `factor` and sinks it under a single `target`.
        -:  918:// Returns the new for operation, nested immediately under `target`.
        -:  919:template <typename SizeType>
        -:  920:static scf::ForOp stripmineSink(scf::ForOp forOp, SizeType factor,
        -:  921:                                scf::ForOp target) {
        -:  922:  // TODO: Use cheap structural assertions that targets are nested under
        -:  923:  // forOp and that targets are not nested under each other when DominanceInfo
        -:  924:  // exposes the capability. It seems overkill to construct a whole function
        -:  925:  // dominance tree at this point.
        -:  926:  auto res = stripmineSink(forOp, factor, ArrayRef<scf::ForOp>(target));
        -:  927:  assert(res.size() == 1 && "Expected 1 inner forOp");
        -:  928:  return res[0];
        -:  929:}
        -:  930:
function _ZN4mlir4tileEN4llvm8ArrayRefINS_3scf5ForOpEEENS1_INS_5ValueEEES4_ called 0 returned 0% blocks executed 0%
    #####:  931:SmallVector<Loops, 8> mlir::tile(ArrayRef<scf::ForOp> forOps,
        -:  932:                                 ArrayRef<Value> sizes,
        -:  933:                                 ArrayRef<scf::ForOp> targets) {
    #####:  934:  SmallVector<SmallVector<scf::ForOp, 8>, 8> res;
call    0 never executed
    #####:  935:  SmallVector<scf::ForOp, 8> currentTargets(targets.begin(), targets.end());
call    0 never executed
    #####:  936:  for (auto it : llvm::zip(forOps, sizes)) {
branch  0 never executed
branch  1 never executed
    #####:  937:    auto step = stripmineSink(std::get<0>(it), std::get<1>(it), currentTargets);
call    0 never executed
    #####:  938:    res.push_back(step);
call    0 never executed
    #####:  939:    currentTargets = step;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  940:  }
    #####:  941:  return res;
branch  0 never executed
branch  1 never executed
        -:  942:}
        -:  943:
function _ZN4mlir4tileEN4llvm8ArrayRefINS_3scf5ForOpEEENS1_INS_5ValueEEES3_ called 0 returned 0% blocks executed 0%
    #####:  944:Loops mlir::tile(ArrayRef<scf::ForOp> forOps, ArrayRef<Value> sizes,
        -:  945:                 scf::ForOp target) {
    #####:  946:  SmallVector<scf::ForOp, 8> res;
call    0 never executed
    #####:  947:  for (auto loops : tile(forOps, sizes, ArrayRef<scf::ForOp>(target))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  948:    assert(loops.size() == 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  949:    res.push_back(loops[0]);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  950:  }
    #####:  951:  return res;
        -:  952:}
        -:  953:
function _ZN4mlir19tilePerfectlyNestedENS_3scf5ForOpEN4llvm8ArrayRefINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  954:Loops mlir::tilePerfectlyNested(scf::ForOp rootForOp, ArrayRef<Value> sizes) {
        -:  955:  // Collect perfectly nested loops.  If more size values provided than nested
        -:  956:  // loops available, truncate `sizes`.
    #####:  957:  SmallVector<scf::ForOp, 4> forOps;
branch  0 never executed
branch  1 never executed
    #####:  958:  forOps.reserve(sizes.size());
branch  0 never executed
branch  1 never executed
    #####:  959:  getPerfectlyNestedLoopsImpl(forOps, rootForOp, sizes.size());
call    0 never executed
    #####:  960:  if (forOps.size() < sizes.size())
branch  0 never executed
branch  1 never executed
    #####:  961:    sizes = sizes.take_front(forOps.size());
call    0 never executed
        -:  962:
    #####:  963:  return ::tile(forOps, sizes, forOps.back());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  964:}
        -:  965:
function _ZN4mlir23getPerfectlyNestedLoopsERN4llvm15SmallVectorImplINS_3scf5ForOpEEES3_ called 12 returned 100% blocks executed 100%
       12:  966:void mlir::getPerfectlyNestedLoops(SmallVectorImpl<scf::ForOp> &nestedLoops,
        -:  967:                                   scf::ForOp root) {
       12:  968:  getPerfectlyNestedLoopsImpl(nestedLoops, root);
call    0 returned 100%
       12:  969:}
        -:  970:
function _ZN4mlir22extractFixedOuterLoopsENS_3scf5ForOpEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:  971:TileLoops mlir::extractFixedOuterLoops(scf::ForOp rootForOp,
        -:  972:                                       ArrayRef<int64_t> sizes) {
        -:  973:  // Collect perfectly nested loops.  If more size values provided than nested
        -:  974:  // loops available, truncate `sizes`.
    #####:  975:  SmallVector<scf::ForOp, 4> forOps;
branch  0 never executed
branch  1 never executed
    #####:  976:  forOps.reserve(sizes.size());
branch  0 never executed
branch  1 never executed
    #####:  977:  getPerfectlyNestedLoopsImpl(forOps, rootForOp, sizes.size());
call    0 never executed
    #####:  978:  if (forOps.size() < sizes.size())
branch  0 never executed
branch  1 never executed
    #####:  979:    sizes = sizes.take_front(forOps.size());
call    0 never executed
        -:  980:
        -:  981:  // Compute the tile sizes such that i-th outer loop executes size[i]
        -:  982:  // iterations.  Given that the loop current executes
        -:  983:  //   numIterations = ceildiv((upperBound - lowerBound), step)
        -:  984:  // iterations, we need to tile with size ceildiv(numIterations, size[i]).
    #####:  985:  SmallVector<Value, 4> tileSizes;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  986:  tileSizes.reserve(sizes.size());
branch  0 never executed
branch  1 never executed
    #####:  987:  for (unsigned i = 0, e = sizes.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  988:    assert(sizes[i] > 0 && "expected strictly positive size for strip-mining");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  989:
    #####:  990:    auto forOp = forOps[i];
branch  0 never executed
branch  1 never executed
    #####:  991:    OpBuilder builder(forOp);
call    0 never executed
    #####:  992:    auto loc = forOp.getLoc();
call    0 never executed
    #####:  993:    Value diff = builder.create<arith::SubIOp>(loc, forOp.getUpperBound(),
call    0 never executed
    #####:  994:                                               forOp.getLowerBound());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  995:    Value numIterations = ceilDivPositive(builder, loc, diff, forOp.getStep());
call    0 never executed
call    1 never executed
    #####:  996:    Value iterationsPerBlock =
    #####:  997:        ceilDivPositive(builder, loc, numIterations, sizes[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  998:    tileSizes.push_back(iterationsPerBlock);
call    0 never executed
        -:  999:  }
        -: 1000:
        -: 1001:  // Call parametric tiling with the given sizes.
    #####: 1002:  auto intraTile = tile(forOps, tileSizes, forOps.back());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1003:  TileLoops tileLoops = std::make_pair(forOps, intraTile);
call    0 never executed
call    1 never executed
        -: 1004:
        -: 1005:  // TODO: for now we just ignore the result of band isolation.
        -: 1006:  // In the future, mapping decisions may be impacted by the ability to
        -: 1007:  // isolate perfectly nested bands.
    #####: 1008:  (void)tryIsolateBands(tileLoops);
call    0 never executed
        -: 1009:
    #####: 1010:  return tileLoops;
branch  0 never executed
branch  1 never executed
        -: 1011:}
