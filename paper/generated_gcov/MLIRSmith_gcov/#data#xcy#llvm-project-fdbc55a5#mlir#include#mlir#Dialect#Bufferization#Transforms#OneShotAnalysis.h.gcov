        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Dialect/Bufferization/Transforms/OneShotAnalysis.h
        -:    0:Graph:../tools/mlir/lib/Dialect/SparseTensor/Pipelines/CMakeFiles/obj.MLIRSparseTensorPipelines.dir/SparseTensorPipelines.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SparseTensor/Pipelines/CMakeFiles/obj.MLIRSparseTensorPipelines.dir/SparseTensorPipelines.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- OneShotAnalysis.h - One-Shot (Single Pass) Analysis ------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef MLIR_DIALECT_BUFFERIZATION_TRANSFORMS_ONESHOTANALYSIS_H
        -:   10:#define MLIR_DIALECT_BUFFERIZATION_TRANSFORMS_ONESHOTANALYSIS_H
        -:   11:
        -:   12:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h"
        -:   13:#include "llvm/ADT/EquivalenceClasses.h"
        -:   14:
        -:   15:namespace mlir {
        -:   16:namespace bufferization {
        -:   17:
        -:   18:struct OneShotBufferizationOptions;
        -:   19:class BufferizationAliasInfo;
        -:   20:class OneShotAnalysisState;
        -:   21:
        -:   22:/// Options for analysis-enabled bufferization.
      778:   23:struct OneShotBufferizationOptions : public BufferizationOptions {
call    0 returned 100%
call    1 returned 100%
        -:   24:  enum class AnalysisHeuristic { BottomUp, TopDown };
        -:   25:
      778:   26:  OneShotBufferizationOptions() = default;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:   27:
        -:   28:  /// Specifies whether returning newly allocated memrefs should be allowed.
        -:   29:  /// Otherwise, a pass failure is triggered.
        -:   30:  bool allowReturnAllocs = false;
        -:   31:
        -:   32:  /// The heuristic controls the order in which ops are traversed during the
        -:   33:  /// analysis.
        -:   34:  AnalysisHeuristic analysisHeuristic = AnalysisHeuristic::BottomUp;
        -:   35:};
        -:   36:
        -:   37:/// The BufferizationAliasInfo class maintains a list of buffer aliases and
        -:   38:/// equivalence classes to support bufferization.
        -:   39:class BufferizationAliasInfo {
        -:   40:public:
        -:   41:  explicit BufferizationAliasInfo(Operation *rootOp);
        -:   42:
        -:   43:  // BufferizationAliasInfo should be passed as a reference.
        -:   44:  BufferizationAliasInfo(const BufferizationAliasInfo &) = delete;
        -:   45:
        -:   46:  /// Add a new entry for `v` in the `aliasInfo` and `equivalentInfo`. In the
        -:   47:  /// beginning the alias and equivalence sets only contain `v` itself.
        -:   48:  void createAliasInfoEntry(Value v);
        -:   49:
        -:   50:  /// Insert an info entry for `newValue` and merge its alias set with that of
        -:   51:  /// `alias`.
        -:   52:  void insertNewBufferAlias(Value newValue, Value alias);
        -:   53:
        -:   54:  /// Insert an info entry for `newValue` and merge its alias set with that of
        -:   55:  /// `alias`. Additionally, merge their equivalence classes.
        -:   56:  void insertNewBufferEquivalence(Value newValue, Value alias);
        -:   57:
        -:   58:  /// Set the inPlace bufferization spec to true.
        -:   59:  /// Merge result's and operand's aliasing sets and iterate to a fixed point.
        -:   60:  void bufferizeInPlace(OpOperand &operand, AnalysisState &state);
        -:   61:
        -:   62:  /// Set the inPlace bufferization spec to false.
        -:   63:  void bufferizeOutOfPlace(OpOperand &operand);
        -:   64:
        -:   65:  /// Return true if `v1` and `v2` may bufferize to aliasing buffers.
        -:   66:  bool areAliasingBufferizedValues(Value v1, Value v2) const {
        -:   67:    return aliasInfo.isEquivalent(v1, v2);
        -:   68:  }
        -:   69:
        -:   70:  /// Return true if `v1` and `v2` bufferize to equivalent buffers.
        -:   71:  bool areEquivalentBufferizedValues(Value v1, Value v2) const {
        -:   72:    return equivalentInfo.isEquivalent(v1, v2);
        -:   73:  }
        -:   74:
        -:   75:  /// Union the alias sets of `v1` and `v2`.
        -:   76:  void unionAliasSets(Value v1, Value v2) { aliasInfo.unionSets(v1, v2); }
        -:   77:
        -:   78:  /// Union the equivalence classes of `v1` and `v2`.
        -:   79:  void unionEquivalenceClasses(Value v1, Value v2) {
        -:   80:    equivalentInfo.unionSets(v1, v2);
        -:   81:  }
        -:   82:
        -:   83:  /// Apply `fun` to all the members of the equivalence class of `v`.
        -:   84:  void applyOnEquivalenceClass(Value v, function_ref<void(Value)> fun) const;
        -:   85:
        -:   86:  /// Apply `fun` to all aliases of `v`.
        -:   87:  void applyOnAliases(Value v, function_ref<void(Value)> fun) const;
        -:   88:
        -:   89:  /// Mark a value as in-place bufferized.
        -:   90:  void markInPlace(OpOperand &o) { inplaceBufferized.insert(&o); }
        -:   91:
        -:   92:  /// Return `true` if a value was marked as in-place bufferized.
        -:   93:  bool isInPlace(OpOperand &opOperand) const;
        -:   94:
        -:   95:private:
        -:   96:  /// llvm::EquivalenceClasses wants comparable elements. This comparator uses
        -:   97:  /// uses pointer comparison on the defining op. This is a poor man's
        -:   98:  /// comparison but it's not like UnionFind needs ordering anyway.
        -:   99:  struct ValueComparator {
        -:  100:    bool operator()(const Value &lhs, const Value &rhs) const {
        -:  101:      return lhs.getImpl() < rhs.getImpl();
        -:  102:    }
        -:  103:  };
        -:  104:
        -:  105:  using EquivalenceClassRangeType = llvm::iterator_range<
        -:  106:      llvm::EquivalenceClasses<Value, ValueComparator>::member_iterator>;
        -:  107:  /// Check that aliasInfo for `v` exists and return a reference to it.
        -:  108:  EquivalenceClassRangeType getAliases(Value v) const;
        -:  109:
        -:  110:  /// Set of all OpResults that were decided to bufferize in-place.
        -:  111:  llvm::DenseSet<OpOperand *> inplaceBufferized;
        -:  112:
        -:  113:  /// Auxiliary structure to store all the values a given value may alias with.
        -:  114:  /// Alias information is "may be" conservative: In the presence of branches, a
        -:  115:  /// value may alias with one of multiple other values. The concrete aliasing
        -:  116:  /// value may not even be known at compile time. All such values are
        -:  117:  /// considered to be aliases.
        -:  118:  llvm::EquivalenceClasses<Value, ValueComparator> aliasInfo;
        -:  119:
        -:  120:  /// Auxiliary structure to store all the equivalent buffer classes. Equivalent
        -:  121:  /// buffer information is "must be" conservative: Only if two values are
        -:  122:  /// guaranteed to be equivalent at runtime, they said to be equivalent. It is
        -:  123:  /// possible that, in the presence of branches, it cannot be determined
        -:  124:  /// statically if two values are equivalent. In that case, the values are
        -:  125:  /// considered to be not equivalent.
        -:  126:  llvm::EquivalenceClasses<Value, ValueComparator> equivalentInfo;
        -:  127:};
        -:  128:
        -:  129:/// State for analysis-enabled bufferization. This class keeps track of alias
        -:  130:/// (via BufferizationAliasInfo) to decide if tensor OpOperands should bufferize
        -:  131:/// in-place.
        -:  132:class OneShotAnalysisState : public AnalysisState {
        -:  133:public:
        -:  134:  OneShotAnalysisState(Operation *op,
        -:  135:                       const OneShotBufferizationOptions &options);
        -:  136:
        -:  137:  OneShotAnalysisState(const OneShotAnalysisState &) = delete;
        -:  138:
        -:  139:  ~OneShotAnalysisState() override = default;
        -:  140:
        -:  141:  /// Return a reference to the BufferizationAliasInfo.
        -:  142:  BufferizationAliasInfo &getAliasInfo() { return aliasInfo; }
        -:  143:
        -:  144:  /// Return `true` if the given OpResult has been decided to bufferize inplace.
        -:  145:  bool isInPlace(OpOperand &opOperand) const override;
        -:  146:
        -:  147:  /// Return true if `v1` and `v2` bufferize to equivalent buffers.
        -:  148:  bool areEquivalentBufferizedValues(Value v1, Value v2) const override;
        -:  149:
        -:  150:  /// Return true if `v1` and `v2` may bufferize to aliasing buffers.
        -:  151:  bool areAliasingBufferizedValues(Value v1, Value v2) const override;
        -:  152:
        -:  153:  /// Return `true` if the given tensor has undefined contents.
        -:  154:  bool hasUndefinedContents(OpOperand *opOperand) const override;
        -:  155:
        -:  156:  /// Return true if the given tensor (or an aliasing tensor) is yielded from
        -:  157:  /// the containing block. Also include all aliasing tensors in the same block.
        -:  158:  bool isTensorYielded(Value tensor) const override;
        -:  159:
        -:  160:  /// Find all tensor values in the given operation that have undefined contents
        -:  161:  /// and store them in `undefinedTensorUses`.
        -:  162:  void gatherUndefinedTensorUses(Operation *op);
        -:  163:
        -:  164:  /// Find all tensors that are yielded/returned from a block and store them in
        -:  165:  /// `yieldedTensors`. Also include all aliasing tensors in the same block.
        -:  166:  void gatherYieldedTensors(Operation *op);
        -:  167:
        -:  168:  /// Return true if the buffer of the given tensor value is written to. Must
        -:  169:  /// not be called for values inside not yet analyzed functions.
        -:  170:  bool isValueWritten(Value value) const;
        -:  171:
        -:  172:  /// Return true if the buffer of the given tensor value is writable.
        -:  173:  bool isWritable(Value value) const;
        -:  174:
        -:  175:private:
        -:  176:  /// `aliasInfo` keeps track of aliasing and equivalent values. Only internal
        -:  177:  /// functions and `runOneShotBufferize` may access this object.
        -:  178:  BufferizationAliasInfo aliasInfo;
        -:  179:
        -:  180:  /// A set of all tensors (and maybe aliasing tensors) that yielded from a
        -:  181:  /// block.
        -:  182:  DenseSet<Value> yieldedTensors;
        -:  183:
        -:  184:  /// A set of uses of tensors that have undefined contents.
        -:  185:  DenseSet<OpOperand *> undefinedTensorUses;
        -:  186:};
        -:  187:
        -:  188:/// Analyze `op` and its nested ops. Bufferization decisions are stored in
        -:  189:/// `state`.
        -:  190:LogicalResult analyzeOp(Operation *op, OneShotAnalysisState &state);
        -:  191:
        -:  192:/// Run One-Shot Bufferize on the given op: Analysis + Bufferization
        -:  193:LogicalResult runOneShotBufferize(Operation *op,
        -:  194:                                  const OneShotBufferizationOptions &options);
        -:  195:
        -:  196:} // namespace bufferization
        -:  197:} // namespace mlir
        -:  198:
        -:  199:#endif // MLIR_DIALECT_BUFFERIZATION_TRANSFORMS_ONESHOTANALYSIS_H
