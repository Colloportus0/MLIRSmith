        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/Bufferization/Transforms/FuncBufferizableOpInterfaceImpl.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Bufferization/Transforms/CMakeFiles/obj.MLIRBufferizationTransforms.dir/FuncBufferizableOpInterfaceImpl.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Bufferization/Transforms/CMakeFiles/obj.MLIRBufferizationTransforms.dir/FuncBufferizableOpInterfaceImpl.cpp.gcda
        -:    0:Runs:116157
        -:    1://===- BufferizableOpInterfaceImpl.cpp - Impl. of BufferizableOpInterface -===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Bufferization/Transforms/FuncBufferizableOpInterfaceImpl.h"
        -:   10:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h"
        -:   11:#include "mlir/Dialect/Bufferization/IR/Bufferization.h"
        -:   12:#include "mlir/Dialect/Bufferization/Transforms/OneShotAnalysis.h"
        -:   13:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   14:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   15:#include "mlir/IR/Dialect.h"
        -:   16:#include "mlir/IR/Operation.h"
        -:   17:
        -:   18:namespace mlir {
        -:   19:namespace bufferization {
        -:   20:namespace func_ext {
        -:   21:
function _ZN4mlir13bufferization8func_ext17FuncAnalysisState21startFunctionAnalysisENS_4func6FuncOpE called 305 returned 100% blocks executed 81%
      305:   22:void FuncAnalysisState::startFunctionAnalysis(FuncOp funcOp) {
      305:   23:  analyzedFuncOps[funcOp] = FuncOpAnalysisState::InProgress;
call    0 returned 100%
      305:   24:  auto createdEquiv = equivalentFuncArgs.try_emplace(funcOp, IndexMapping());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      305:   25:  auto createdAliasingOperands =
      305:   26:      aliasingFuncArgs.try_emplace(funcOp, IndexToIndexListMapping());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      305:   27:  auto createdAliasingResults =
      305:   28:      aliasingReturnVals.try_emplace(funcOp, IndexToIndexListMapping());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      305:   29:  auto createdRead = readBbArgs.try_emplace(funcOp, BbArgIndexSet());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      305:   30:  auto createdWritten = writtenBbArgs.try_emplace(funcOp, BbArgIndexSet());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      305:   31:  (void)createdEquiv;
      305:   32:  (void)createdAliasingOperands;
      305:   33:  (void)createdAliasingResults;
      305:   34:  (void)createdRead;
      305:   35:  (void)createdWritten;
        -:   36:#ifndef NDEBUG
     305*:   37:  assert(createdEquiv.second && "equivalence info exists already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     305*:   38:  assert(createdAliasingOperands.second && "aliasing info exists already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     305*:   39:  assert(createdAliasingResults.second && "aliasing info exists already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     305*:   40:  assert(createdRead.second && "bbarg access info exists already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     305*:   41:  assert(createdWritten.second && "bbarg access info exists already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   42:#endif // NDEBUG
      305:   43:}
        -:   44:
        -:   45:/// Return the unique ReturnOp that terminates `funcOp`.
        -:   46:/// Return nullptr if there is no such unique ReturnOp.
function _ZN4mlir13bufferization8func_extL24getAssumedUniqueReturnOpENS_4func6FuncOpE called 28 returned 100% blocks executed 85%
       28:   47:static func::ReturnOp getAssumedUniqueReturnOp(FuncOp funcOp) {
       28:   48:  func::ReturnOp returnOp;
call    0 returned 100%
       56:   49:  for (Block &b : funcOp.getBody()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
       28:   50:    if (auto candidateOp = dyn_cast<func::ReturnOp>(b.getTerminator())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       28:   51:      if (returnOp)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   52:        return nullptr;
        -:   53:      returnOp = candidateOp;
        -:   54:    }
        -:   55:  }
       28:   56:  return returnOp;
        -:   57:}
        -:   58:
        -:   59:/// Return the index-th bufferized function argument type. This assumes that the
        -:   60:/// specified argument is a tensor. If the tensor is ranked, a layout map may be
        -:   61:/// specified by the user. If no layout map is specified, the default layout map
        -:   62:/// (as per `options.functionBoundaryTypeConversion`) is used.
        -:   63:static BaseMemRefType
        -:   64:getBufferizedFunctionArgType(FuncOp funcOp, int64_t index,
        -:   65:                             const BufferizationOptions &options) {
        -:   66:  auto tensorType =
        -:   67:      funcOp.getFunctionType().getInput(index).dyn_cast<TensorType>();
        -:   68:  assert(tensorType && "expected TensorType");
        -:   69:
        -:   70:  BaseMemRefType memrefType;
        -:   71:  if (options.functionBoundaryTypeConversion ==
        -:   72:      BufferizationOptions::LayoutMapOption::IdentityLayoutMap) {
        -:   73:    memrefType = getMemRefTypeWithStaticIdentityLayout(tensorType);
        -:   74:  } else {
        -:   75:    // Note: Layout maps on function parameters cannot be inferred. The best we
        -:   76:    // can do at the moment is "fully dynamic".
        -:   77:    memrefType = getMemRefTypeWithFullyDynamicLayout(tensorType);
        -:   78:  }
        -:   79:
        -:   80:  auto layoutAttr = funcOp.getArgAttrOfType<AffineMapAttr>(
        -:   81:      index, BufferizationDialect::kBufferLayoutAttrName);
        -:   82:  if (!layoutAttr)
        -:   83:    return memrefType;
        -:   84:
        -:   85:  auto rankedMemrefType = memrefType.dyn_cast<MemRefType>();
        -:   86:  assert(rankedMemrefType && "buffer layout not supported on unranked tensors");
        -:   87:  return MemRefType::get(
        -:   88:      rankedMemrefType.getShape(), rankedMemrefType.getElementType(),
        -:   89:      layoutAttr.getValue(), rankedMemrefType.getMemorySpaceAsInt());
        -:   90:}
        -:   91:
        -:   92:/// Return the FuncOp called by `callOp`.
function _ZN4mlir13bufferization8func_extL17getCalledFunctionENS_15CallOpInterfaceE called 266 returned 100% blocks executed 91%
      266:   93:static FuncOp getCalledFunction(CallOpInterface callOp) {
      266:   94:  SymbolRefAttr sym = callOp.getCallableForCallee().dyn_cast<SymbolRefAttr>();
call    0 returned 100%
call    1 returned 100%
      266:   95:  if (!sym)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   96:    return nullptr;
      266:   97:  return dyn_cast_or_null<FuncOp>(
      266:   98:      SymbolTable::lookupNearestSymbolFrom(callOp, sym));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   99:}
        -:  100:
        -:  101:/// Get FuncAnalysisState.
        -:  102:static const FuncAnalysisState &
function _ZN4mlir13bufferization8func_extL20getFuncAnalysisStateERKNS0_13AnalysisStateE called 255 returned 100% blocks executed 75%
      255:  103:getFuncAnalysisState(const AnalysisState &state) {
      255:  104:  Optional<const FuncAnalysisState *> maybeState =
        -:  105:      state.getDialectState<FuncAnalysisState>(
      255:  106:          func::FuncDialect::getDialectNamespace());
call    0 returned 100%
     255*:  107:  assert(maybeState && "FuncAnalysisState does not exist");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      255:  108:  return **maybeState;
        -:  109:}
        -:  110:
        -:  111:/// Return the state (phase) of analysis of the FuncOp.
function _ZN4mlir13bufferization8func_extL22getFuncOpAnalysisStateERKNS0_13AnalysisStateENS_4func6FuncOpE called 266 returned 100% blocks executed 100%
      266:  112:static FuncOpAnalysisState getFuncOpAnalysisState(const AnalysisState &state,
        -:  113:                                                  FuncOp funcOp) {
      266:  114:  Optional<const FuncAnalysisState *> maybeState =
        -:  115:      state.getDialectState<FuncAnalysisState>(
      266:  116:          func::FuncDialect::getDialectNamespace());
call    0 returned 100%
      266:  117:  if (!maybeState.has_value())
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:  118:    return FuncOpAnalysisState::NotAnalyzed;
      255:  119:  const auto &analyzedFuncOps = maybeState.value()->analyzedFuncOps;
call    0 returned 100%
      255:  120:  auto it = analyzedFuncOps.find(funcOp);
call    0 returned 100%
      255:  121:  if (it == analyzedFuncOps.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  122:    return FuncOpAnalysisState::NotAnalyzed;
      255:  123:  return it->second;
call    0 returned 100%
        -:  124:}
        -:  125:
        -:  126:/// Return the index of the bbArg in the given FuncOp that is equivalent to the
        -:  127:/// specified return value (if any).
function _ZN4mlir13bufferization8func_extL23getEquivalentFuncArgIdxENS_4func6FuncOpERKNS1_17FuncAnalysisStateEl called 0 returned 0% blocks executed 0%
    #####:  128:static Optional<int64_t> getEquivalentFuncArgIdx(FuncOp funcOp,
        -:  129:                                                 const FuncAnalysisState &state,
        -:  130:                                                 int64_t returnValIdx) {
    #####:  131:  auto funcOpIt = state.equivalentFuncArgs.find(funcOp);
call    0 never executed
    #####:  132:  if (funcOpIt == state.equivalentFuncArgs.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  133:    // No equivalence info stores for funcOp.
    #####:  134:    return None;
        -:  135:
    #####:  136:  auto retValIt = funcOpIt->getSecond().find(returnValIdx);
call    0 never executed
call    1 never executed
    #####:  137:  if (retValIt == funcOpIt->getSecond().end())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  138:    // Return value has no equivalent bbArg.
    #####:  139:    return None;
        -:  140:
    #####:  141:  return retValIt->getSecond();
call    0 never executed
        -:  142:}
        -:  143:
    91592:  144:struct CallOpInterface
call    0 returned 100%
        -:  145:    : public BufferizableOpInterface::ExternalModel<CallOpInterface,
        -:  146:                                                    func::CallOp> {
function _ZNK4mlir13bufferization8func_ext15CallOpInterface22bufferizesToMemoryReadEPNS_9OperationERNS_9OpOperandERKNS0_13AnalysisStateE called 50 returned 100% blocks executed 93%
       50:  147:  bool bufferizesToMemoryRead(Operation *op, OpOperand &opOperand,
        -:  148:                              const AnalysisState &state) const {
       50:  149:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 returned 100%
       50:  150:    FuncOp funcOp = getCalledFunction(callOp);
call    0 returned 100%
call    1 returned 100%
      50*:  151:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  152:
       50:  153:    if (getFuncOpAnalysisState(state, funcOp) != FuncOpAnalysisState::Analyzed)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  154:      // FuncOp not analyzed yet. Assume that OpOperand is read.
        -:  155:      return true;
        -:  156:
       50:  157:    const FuncAnalysisState &funcState = getFuncAnalysisState(state);
call    0 returned 100%
      100:  158:    return funcState.readBbArgs.lookup(funcOp).contains(
call    0 returned 100%
       50:  159:        opOperand.getOperandNumber());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  160:  }
        -:  161:
function _ZNK4mlir13bufferization8func_ext15CallOpInterface23bufferizesToMemoryWriteEPNS_9OperationERNS_9OpOperandERKNS0_13AnalysisStateE called 134 returned 100% blocks executed 93%
      134:  162:  bool bufferizesToMemoryWrite(Operation *op, OpOperand &opOperand,
        -:  163:                               const AnalysisState &state) const {
      134:  164:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 returned 100%
      134:  165:    FuncOp funcOp = getCalledFunction(callOp);
call    0 returned 100%
call    1 returned 100%
     134*:  166:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  167:
      134:  168:    if (getFuncOpAnalysisState(state, funcOp) != FuncOpAnalysisState::Analyzed)
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
        -:  169:      // FuncOp not analyzed yet. Assume that OpOperand is written.
        -:  170:      return true;
        -:  171:
      123:  172:    const FuncAnalysisState &funcState = getFuncAnalysisState(state);
call    0 returned 100%
      246:  173:    return funcState.writtenBbArgs.lookup(funcOp).contains(
call    0 returned 100%
      123:  174:        opOperand.getOperandNumber());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  175:  }
        -:  176:
function _ZNK4mlir13bufferization8func_ext15CallOpInterface19getAliasingOpResultEPNS_9OperationERNS_9OpOperandERKNS0_13AnalysisStateE called 82 returned 100% blocks executed 44%
       82:  177:  SmallVector<OpResult> getAliasingOpResult(Operation *op, OpOperand &opOperand,
        -:  178:                                            const AnalysisState &state) const {
       82:  179:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 returned 100%
       82:  180:    FuncOp funcOp = getCalledFunction(callOp);
call    0 returned 100%
call    1 returned 100%
      82*:  181:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       82:  182:    if (getFuncOpAnalysisState(state, funcOp) !=
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  183:        FuncOpAnalysisState::Analyzed) {
        -:  184:      // FuncOp not analyzed yet. Any OpResult may be aliasing.
    #####:  185:      SmallVector<OpResult> result;
branch  0 never executed
branch  1 never executed
    #####:  186:      for (OpResult opResult : op->getOpResults())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  187:        if (opResult.getType().isa<TensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  188:          result.push_back(opResult);
call    0 never executed
    #####:  189:      return result;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  190:    }
        -:  191:
        -:  192:    // Get aliasing results from state.
       82:  193:    const FuncAnalysisState &funcState = getFuncAnalysisState(state);
call    0 returned 100%
       82:  194:    auto aliasingReturnVals =
       82:  195:        funcState.aliasingReturnVals.lookup(funcOp).lookup(
call    0 returned 100%
       82:  196:            opOperand.getOperandNumber());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      164:  197:    SmallVector<OpResult> result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      82*:  198:    for (int64_t resultIdx : aliasingReturnVals)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  199:      result.push_back(callOp->getOpResult(resultIdx));
branch  0 never executed
branch  1 never executed
call    2 never executed
       82:  200:    return result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  201:  }
        -:  202:
        -:  203:  SmallVector<OpOperand *>
function _ZNK4mlir13bufferization8func_ext15CallOpInterface20getAliasingOpOperandEPNS_9OperationENS_8OpResultERKNS0_13AnalysisStateE called 0 returned 0% blocks executed 0%
    #####:  204:  getAliasingOpOperand(Operation *op, OpResult opResult,
        -:  205:                       const AnalysisState &state) const {
    #####:  206:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 never executed
    #####:  207:    FuncOp funcOp = getCalledFunction(callOp);
call    0 never executed
call    1 never executed
    #####:  208:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  209:    if (getFuncOpAnalysisState(state, funcOp) !=
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  210:        FuncOpAnalysisState::Analyzed) {
        -:  211:      // FuncOp not analyzed yet. Any OpOperand may be aliasing.
    #####:  212:      SmallVector<OpOperand *> result;
call    0 never executed
    #####:  213:      for (OpOperand &opOperand : op->getOpOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:        if (opOperand.get().getType().isa<TensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  215:          result.push_back(&opOperand);
call    0 never executed
    #####:  216:      return result;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  217:    }
        -:  218:
        -:  219:    // Get aliasing bbArgs from state.
    #####:  220:    const FuncAnalysisState &funcState = getFuncAnalysisState(state);
call    0 never executed
    #####:  221:    auto aliasingFuncArgs = funcState.aliasingFuncArgs.lookup(funcOp).lookup(
call    0 never executed
call    1 never executed
    #####:  222:        opResult.getResultNumber());
call    0 never executed
call    1 never executed
    #####:  223:    SmallVector<OpOperand *> result;
branch  0 never executed
branch  1 never executed
    #####:  224:    for (int64_t bbArgIdx : aliasingFuncArgs)
branch  0 never executed
branch  1 never executed
    #####:  225:      result.push_back(&callOp->getOpOperand(bbArgIdx));
call    0 never executed
call    1 never executed
    #####:  226:    return result;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  227:  }
        -:  228:
function _ZNK4mlir13bufferization8func_ext15CallOpInterface14bufferRelationEPNS_9OperationENS_8OpResultERKNS0_13AnalysisStateE called 0 returned 0% blocks executed 0%
    #####:  229:  BufferRelation bufferRelation(Operation *op, OpResult opResult,
        -:  230:                                const AnalysisState &state) const {
    #####:  231:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 never executed
    #####:  232:    FuncOp funcOp = getCalledFunction(callOp);
call    0 never executed
call    1 never executed
    #####:  233:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  234:    if (getFuncOpAnalysisState(state, funcOp) !=
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  235:        FuncOpAnalysisState::Analyzed) {
        -:  236:      // Function not analyzed yet. The conservative answer is "None".
        -:  237:      return BufferRelation::None;
        -:  238:    }
        -:  239:
    #####:  240:    const FuncAnalysisState &funcState = getFuncAnalysisState(state);
call    0 never executed
    #####:  241:    Optional<int64_t> maybeEquiv =
call    0 never executed
    #####:  242:        getEquivalentFuncArgIdx(funcOp, funcState, opResult.getResultNumber());
call    0 never executed
    #####:  243:    if (maybeEquiv) {
branch  0 never executed
branch  1 never executed
        -:  244:#ifndef NDEBUG
    #####:  245:      SmallVector<OpOperand *> aliasingOpOperands =
    #####:  246:          getAliasingOpOperand(op, opResult, state);
call    0 never executed
    #####:  247:      assert(aliasingOpOperands.size() == 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  248:             "expected exactly 1 aliasing OpOperand");
    #####:  249:      assert(aliasingOpOperands.front()->getOperandNumber() == *maybeEquiv &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  250:             "inconsistent analysis state");
        -:  251:#endif
    #####:  252:      return BufferRelation::Equivalent;
branch  0 never executed
branch  1 never executed
        -:  253:    }
        -:  254:    return BufferRelation::None;
        -:  255:  }
        -:  256:
        -:  257:  /// All function arguments are writable. It is the responsibility of the
        -:  258:  /// CallOp to insert buffer copies where necessary.
function _ZNK4mlir13bufferization8func_ext15CallOpInterface9bufferizeEPNS_9OperationERNS_12RewriterBaseERKNS0_20BufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  259:  LogicalResult bufferize(Operation *op, RewriterBase &rewriter,
        -:  260:                          const BufferizationOptions &options) const {
    #####:  261:    func::CallOp callOp = cast<func::CallOp>(op);
call    0 never executed
    #####:  262:    unsigned numResults = callOp.getNumResults();
branch  0 never executed
branch  1 never executed
    #####:  263:    unsigned numOperands = callOp->getNumOperands();
branch  0 never executed
branch  1 never executed
    #####:  264:    FuncOp funcOp = getCalledFunction(callOp);
call    0 never executed
call    1 never executed
    #####:  265:    assert(funcOp && "expected CallOp to a FuncOp");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  266:    FunctionType funcType = funcOp.getFunctionType();
call    0 never executed
        -:  267:
        -:  268:    // Result types of the bufferized CallOp.
    #####:  269:    SmallVector<Type> resultTypes;
call    0 never executed
        -:  270:    // Replacement values for the existing CallOp. These are usually the results
        -:  271:    // of the bufferized CallOp, unless a tensor result folds onto an operand.
    #####:  272:    SmallVector<Value> replacementValues(numResults, Value());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  273:    // For non-tensor results: A mapping from return val indices of the old
        -:  274:    // CallOp to return val indices of the bufferized CallOp.
    #####:  275:    SmallVector<Optional<unsigned>> retValMapping(numResults, None);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  276:    // Operands of the bufferized CallOp.
    #####:  277:    SmallVector<Value> newOperands(numOperands, Value());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  278:
        -:  279:    // 1. Compute the result types of the new CallOp.
    #####:  280:    for (const auto &it : llvm::enumerate(callOp.getResultTypes())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  281:      unsigned returnValIdx = it.index();
call    0 never executed
    #####:  282:      Type returnType = it.value();
call    0 never executed
    #####:  283:      if (!returnType.isa<TensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  284:        // Non-tensor values are returned.
    #####:  285:        retValMapping[returnValIdx] = resultTypes.size();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  286:        resultTypes.push_back(returnType);
call    0 never executed
    #####:  287:        continue;
        -:  288:      }
        -:  289:
        -:  290:      // Returning a memref.
    #####:  291:      retValMapping[returnValIdx] = resultTypes.size();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  292:      resultTypes.push_back(funcType.getResult(resultTypes.size()));
call    0 never executed
call    1 never executed
        -:  293:    }
        -:  294:
        -:  295:    // 2. Rewrite tensor operands as memrefs based on `bufferizedFuncType`.
    #####:  296:    for (OpOperand &opOperand : callOp->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  297:      unsigned idx = opOperand.getOperandNumber();
call    0 never executed
    #####:  298:      Value tensorOperand = opOperand.get();
call    0 never executed
        -:  299:
        -:  300:      // Non-tensor operands are just copied.
    #####:  301:      if (!tensorOperand.getType().isa<TensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  302:        newOperands[idx] = tensorOperand;
branch  0 never executed
branch  1 never executed
    #####:  303:        continue;
        -:  304:      }
        -:  305:
        -:  306:      // Retrieve buffers for tensor operands.
    #####:  307:      Value buffer = newOperands[idx];
branch  0 never executed
branch  1 never executed
    #####:  308:      if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  309:        FailureOr<Value> maybeBuffer =
    #####:  310:            getBuffer(rewriter, opOperand.get(), options);
call    0 never executed
    #####:  311:        if (failed(maybeBuffer))
branch  0 never executed
branch  1 never executed
    #####:  312:          return failure();
    #####:  313:        buffer = *maybeBuffer;
        -:  314:      }
        -:  315:
        -:  316:      // Caller / callee type mismatch is handled with a CastOp.
    #####:  317:      auto memRefType = funcType.getInput(idx);
call    0 never executed
        -:  318:      // Since we don't yet have a clear layout story, to_memref may
        -:  319:      // conservatively turn tensors into more dynamic memref than necessary.
        -:  320:      // If the memref type of the callee fails, introduce an extra memref.cast
        -:  321:      // that will either canonicalize away or fail compilation until we can do
        -:  322:      // something better.
    #####:  323:      if (buffer.getType() != memRefType) {
branch  0 never executed
branch  1 never executed
    #####:  324:        assert(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  325:            memref::CastOp::areCastCompatible(buffer.getType(), memRefType) &&
        -:  326:            "CallOp::bufferize: cast incompatible");
    #####:  327:        Value castBuffer = rewriter.create<memref::CastOp>(callOp.getLoc(),
    #####:  328:                                                           memRefType, buffer);
call    0 never executed
    #####:  329:        buffer = castBuffer;
        -:  330:      }
    #####:  331:      newOperands[idx] = buffer;
branch  0 never executed
branch  1 never executed
        -:  332:    }
        -:  333:
        -:  334:    // 3. Create the new CallOp.
    #####:  335:    Operation *newCallOp = rewriter.create<func::CallOp>(
    #####:  336:        callOp.getLoc(), funcOp.getSymName(), resultTypes, newOperands);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  337:    newCallOp->setAttrs(callOp->getAttrs());
call    0 never executed
        -:  338:    // Get replacement values.
    #####:  339:    for (unsigned i = 0; i < replacementValues.size(); ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  340:      if (replacementValues[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  341:        continue;
    #####:  342:      replacementValues[i] = newCallOp->getResult(*retValMapping[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  343:    }
        -:  344:
        -:  345:    // 4. Replace the old op with the new op.
    #####:  346:    replaceOpWithBufferizedValues(rewriter, callOp, replacementValues);
call    0 never executed
call    1 never executed
        -:  347:
    #####:  348:    return success();
branch  0 never executed
branch  1 never executed
        -:  349:  }
        -:  350:};
        -:  351:
    91592:  352:struct ReturnOpInterface
call    0 returned 100%
        -:  353:    : public BufferizableOpInterface::ExternalModel<ReturnOpInterface,
        -:  354:                                                    func::ReturnOp> {
        9:  355:  bool bufferizesToMemoryRead(Operation *op, OpOperand &opOperand,
        -:  356:                              const AnalysisState &state) const {
        9:  357:    return true;
        -:  358:  }
        -:  359:
       39:  360:  bool bufferizesToMemoryWrite(Operation *op, OpOperand &opOperand,
        -:  361:                               const AnalysisState &state) const {
       39:  362:    return false;
        -:  363:  }
        -:  364:
       16:  365:  SmallVector<OpResult> getAliasingOpResult(Operation *op, OpOperand &opOperand,
        -:  366:                                            const AnalysisState &state) const {
       16:  367:    return {};
        -:  368:  }
        -:  369:
        -:  370:  LogicalResult bufferize(Operation *op, RewriterBase &rewriter,
        -:  371:                          const BufferizationOptions &options) const {
        -:  372:#ifndef NDEBUG
        -:  373:    auto returnOp = cast<func::ReturnOp>(op);
        -:  374:    assert(isa<FuncOp>(returnOp->getParentOp()) &&
        -:  375:           "only support FuncOp parent for ReturnOp");
        -:  376:#endif // NDEBUG
        -:  377:
        -:  378:    // ReturnOps are bufferized as part of FuncOps.
        -:  379:    return success();
        -:  380:  }
        -:  381:};
        -:  382:
    91592:  383:struct FuncOpInterface
call    0 returned 100%
        -:  384:    : public BufferizableOpInterface::ExternalModel<FuncOpInterface, FuncOp> {
        -:  385:  /// Rewrite function bbArgs and return values into buffer form. This function
        -:  386:  /// bufferizes the function signature and the ReturnOp. When the entire
        -:  387:  /// function body has been bufferized, function return types can be switched
        -:  388:  /// to more concise memref types as part of `foldMemRefCasts`.
        -:  389:  ///
        -:  390:  /// All function bbArgs are writable unless they are explicitly marked as
        -:  391:  /// read-only. Callers must insert copies when needed.
function _ZNK4mlir13bufferization8func_ext15FuncOpInterface9bufferizeEPNS_9OperationERNS_12RewriterBaseERKNS0_20BufferizationOptionsE called 28 returned 100% blocks executed 70%
       28:  392:  LogicalResult bufferize(Operation *op, RewriterBase &rewriter,
        -:  393:                          const BufferizationOptions &options) const {
       28:  394:    auto funcOp = cast<FuncOp>(op);
call    0 returned 100%
       28:  395:    FunctionType funcType = funcOp.getFunctionType();
call    0 returned 100%
        -:  396:
        -:  397:    // Construct the bufferized function type.
       28:  398:    SmallVector<Type> argTypes;
call    0 returned 100%
      139:  399:    for (const auto &it : llvm::enumerate(funcType.getInputs())) {
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
call    3 returned 100%
      111:  400:      Type argType = it.value();
call    0 returned 100%
      111:  401:      if (auto tensorType = argType.dyn_cast<TensorType>()) {
call    0 returned 100%
branch  1 taken 34% (fallthrough)
branch  2 taken 66%
       38:  402:        argTypes.push_back(
call    0 returned 100%
       38:  403:            getBufferizedFunctionArgType(funcOp, it.index(), options));
call    0 returned 100%
       38:  404:        continue;
        -:  405:      }
       73:  406:      argTypes.push_back(argType);
call    0 returned 100%
        -:  407:    }
        -:  408:
        -:  409:    // Bodiless functions are assumed opaque and we cannot know the
        -:  410:    // bufferization contract they want to enforce. As a consequence, only
        -:  411:    // support functions that don't return any tensors atm.
       28:  412:    if (funcOp.getBody().empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  413:      SmallVector<Type> retTypes;
call    0 never executed
    #####:  414:      for (Type resultType : funcType.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  415:        if (resultType.isa<TensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  416:          return funcOp->emitError() << "cannot bufferize bodiless function "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  417:                                     << "that returns a tensor";
call    0 never executed
    #####:  418:        retTypes.push_back(resultType);
call    0 never executed
        -:  419:      }
    #####:  420:      funcOp.setType(FunctionType::get(op->getContext(), argTypes, retTypes));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  421:      return success();
branch  0 never executed
branch  1 never executed
        -:  422:    }
        -:  423:
        -:  424:    // TODO: Support functions with multiple returns.
       28:  425:    func::ReturnOp returnOp = getAssumedUniqueReturnOp(funcOp);
call    0 returned 100%
      28*:  426:    assert(returnOp && "expected func with single return op");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       28:  427:    Location loc = returnOp.getLoc();
call    0 returned 100%
        -:  428:
        -:  429:    // 1. Rewrite the bbArgs. Turn every tensor bbArg into a memref bbArg.
       28:  430:    Block &frontBlock = funcOp.getBody().front();
call    0 returned 100%
call    1 returned 100%
      139:  431:    for (BlockArgument &bbArg : frontBlock.getArguments()) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      111:  432:      auto tensorType = bbArg.getType().dyn_cast<TensorType>();
call    0 returned 100%
        -:  433:      // Non-tensor types stay the same.
      111:  434:      if (!tensorType)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
       73:  435:        continue;
        -:  436:
        -:  437:      // Collect all uses of the bbArg.
       76:  438:      SmallVector<OpOperand *> bbArgUses;
       39:  439:      for (OpOperand &use : bbArg.getUses())
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        1:  440:        bbArgUses.push_back(&use);
call    0 returned 100%
        -:  441:
        -:  442:      // Change the bbArg type to memref.
       38:  443:      Type memrefType =
call    0 returned 100%
       38:  444:          getBufferizedFunctionArgType(funcOp, bbArg.getArgNumber(), options);
call    0 returned 100%
       38:  445:      bbArg.setType(memrefType);
call    0 returned 100%
        -:  446:
        -:  447:      // Replace all uses of the original tensor bbArg.
       38:  448:      rewriter.setInsertionPointToStart(&frontBlock);
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
       38:  449:      if (!bbArgUses.empty()) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  450:        // Insert to_tensor because the remaining function body has not been
        -:  451:        // bufferized yet.
        1:  452:        Value toTensorOp =
        1:  453:            rewriter.create<bufferization::ToTensorOp>(funcOp.getLoc(), bbArg);
call    0 returned 100%
        2:  454:        for (OpOperand *use : bbArgUses)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  455:          use->set(toTensorOp);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  456:      }
        -:  457:    }
        -:  458:
        -:  459:    // 2. For each result, keep track of which inplace argument it reuses.
       56:  460:    SmallVector<Value> returnValues;
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
       39:  461:    for (OpOperand &returnOperand : returnOp->getOpOperands()) {
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
       11:  462:      Value returnVal = returnOperand.get();
call    0 returned 100%
       11:  463:      auto tensorType = returnVal.getType().dyn_cast<TensorType>();
call    0 returned 100%
       11:  464:      rewriter.setInsertionPoint(returnOp);
call    0 returned 100%
        -:  465:
        -:  466:      // If not a tensor type just forward it.
       11:  467:      if (!tensorType) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
        7:  468:        returnValues.push_back(returnVal);
call    0 returned 100%
        7:  469:        continue;
        -:  470:      }
        -:  471:
        4:  472:      BaseMemRefType resultType;
        4:  473:      if (options.functionBoundaryTypeConversion ==
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  474:          BufferizationOptions::LayoutMapOption::IdentityLayoutMap) {
        4:  475:        resultType = getMemRefTypeWithStaticIdentityLayout(tensorType);
call    0 returned 100%
        -:  476:      } else {
        -:  477:        // Note: If `InferLayoutMap`, cast are later folded away.
    #####:  478:        resultType = getMemRefTypeWithFullyDynamicLayout(tensorType);
call    0 never executed
        -:  479:      }
        8:  480:      Value toMemrefOp = rewriter.create<bufferization::ToMemrefOp>(
        4:  481:          loc, resultType, returnVal);
call    0 returned 100%
call    1 returned 100%
        4:  482:      returnValues.push_back(toMemrefOp);
call    0 returned 100%
        -:  483:    }
        -:  484:
        -:  485:    // 3. Rewrite the terminator without the in-place bufferizable values.
       28:  486:    returnOp.operandsMutable().assign(returnValues);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  487:
        -:  488:    // 4. Rewrite the FuncOp type to buffer form.
       28:  489:    funcOp.setType(FunctionType::get(op->getContext(), argTypes,
call    0 returned 100%
       28:  490:                                     ValueRange(returnValues).getTypes()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  491:
       28:  492:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  493:  }
        -:  494:
        -:  495:  /// Return `true` if the given function argument is writable.
function _ZNK4mlir13bufferization8func_ext15FuncOpInterface10isWritableEPNS_9OperationENS_5ValueERKNS0_13AnalysisStateE called 0 returned 0% blocks executed 0%
    #####:  496:  bool isWritable(Operation *op, Value value,
        -:  497:                  const AnalysisState &state) const {
    #####:  498:    auto funcOp = cast<FuncOp>(op);
call    0 never executed
    #####:  499:    BlockArgument bbArg = value.dyn_cast<BlockArgument>();
call    0 never executed
    #####:  500:    assert(bbArg && "expected BlockArgument");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  501:
        -:  502:    // "bufferization.writable" overrides other writability decisions. This is
        -:  503:    // currently used for testing only.
    #####:  504:    if (BoolAttr writable = funcOp.getArgAttrOfType<BoolAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  505:            bbArg.getArgNumber(), BufferizationDialect::kWritableAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:      return writable.getValue();
call    0 never executed
        -:  507:
        -:  508:    // All function arguments are writable by default.
    #####:  509:    return true;
        -:  510:  }
        -:  511:};
        -:  512:
        -:  513:} // namespace func_ext
        -:  514:} // namespace bufferization
        -:  515:} // namespace mlir
        -:  516:
function _ZN4mlir13bufferization8func_ext45registerBufferizableOpInterfaceExternalModelsERNS_15DialectRegistryE called 116157 returned 100% blocks executed 100%
   116157:  517:void mlir::bufferization::func_ext::
        -:  518:    registerBufferizableOpInterfaceExternalModels(DialectRegistry &registry) {
function _ZZN4mlir13bufferization8func_ext45registerBufferizableOpInterfaceExternalModelsERNS_15DialectRegistryEENKUlPNS_11MLIRContextEPNS_4func11FuncDialectEE_clES5_S8_.isra.0 called 91592 returned 100% blocks executed 100%
   207749:  519:  registry.addExtension(+[](MLIRContext *ctx, func::FuncDialect *dialect) {
call    0 returned 100%
    91592:  520:    func::CallOp::attachInterface<func_ext::CallOpInterface>(*ctx);
call    0 returned 100%
    91592:  521:    func::FuncOp::attachInterface<func_ext::FuncOpInterface>(*ctx);
call    0 returned 100%
    91592:  522:    func::ReturnOp::attachInterface<func_ext::ReturnOpInterface>(*ctx);
call    0 returned 100%
    91592:  523:  });
   116157:  524:}
