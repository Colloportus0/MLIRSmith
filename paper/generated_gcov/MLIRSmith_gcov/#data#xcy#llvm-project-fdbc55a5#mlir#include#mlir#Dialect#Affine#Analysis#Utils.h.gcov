        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Dialect/Affine/Analysis/Utils.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/Utils.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- Utils.h - General analysis utilities ---------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This header file defines prototypes for various transformation utilities for
        -:   10:// memref's and non-loop IR structures. These are not passes by themselves but
        -:   11:// are used either by passes, optimization sequences, or in turn by other
        -:   12:// transformation utilities.
        -:   13://
        -:   14://===----------------------------------------------------------------------===//
        -:   15:
        -:   16:#ifndef MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H
        -:   17:#define MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H
        -:   18:
        -:   19:#include "mlir/Dialect/Affine/Analysis/AffineStructures.h"
        -:   20:#include "mlir/IR/AffineMap.h"
        -:   21:#include "mlir/IR/Block.h"
        -:   22:#include "mlir/IR/Location.h"
        -:   23:#include "mlir/Support/LLVM.h"
        -:   24:#include "llvm/ADT/SmallVector.h"
        -:   25:#include <memory>
        -:   26:
        -:   27:namespace mlir {
        -:   28:
        -:   29:class AffineForOp;
        -:   30:class Block;
        -:   31:class Location;
        -:   32:struct MemRefAccess;
        -:   33:class Operation;
        -:   34:class Value;
        -:   35:
        -:   36:/// Populates 'loops' with IVs of the loops surrounding 'op' ordered from
        -:   37:/// the outermost 'affine.for' operation to the innermost one.
        -:   38://  TODO: handle 'affine.if' ops.
        -:   39:void getLoopIVs(Operation &op, SmallVectorImpl<AffineForOp> *loops);
        -:   40:
        -:   41:/// Populates 'ops' with affine operations enclosing `op` ordered from outermost
        -:   42:/// to innermost. affine.for, affine.if, or affine.parallel ops comprise such
        -:   43:/// surrounding affine ops.
        -:   44:/// TODO: Change this to return a list of enclosing ops up until the op that
        -:   45:/// starts an `AffineScope`. In such a case, `ops` is guaranteed by design to
        -:   46:/// have a successive chain of affine parent ops, and this is primarily what is
        -:   47:/// needed for most analyses.
        -:   48:void getEnclosingAffineOps(Operation &op, SmallVectorImpl<Operation *> *ops);
        -:   49:
        -:   50:/// Returns the nesting depth of this operation, i.e., the number of loops
        -:   51:/// surrounding this operation.
        -:   52:unsigned getNestingDepth(Operation *op);
        -:   53:
        -:   54:/// Returns whether a loop is a parallel loop and contains a reduction loop.
        -:   55:bool isLoopParallelAndContainsReduction(AffineForOp forOp);
        -:   56:
        -:   57:/// Returns in 'sequentialLoops' all sequential loops in loop nest rooted
        -:   58:/// at 'forOp'.
        -:   59:void getSequentialLoops(AffineForOp forOp,
        -:   60:                        llvm::SmallDenseSet<Value, 8> *sequentialLoops);
        -:   61:
        -:   62:/// Enumerates different result statuses of slice computation by
        -:   63:/// `computeSliceUnion`
        -:   64:// TODO: Identify and add different kinds of failures during slice computation.
        -:   65:struct SliceComputationResult {
        -:   66:  enum ResultEnum {
        -:   67:    Success,
        -:   68:    IncorrectSliceFailure, // Slice is computed, but it is incorrect.
        -:   69:    GenericFailure,        // Unable to compute src loop computation slice.
        -:   70:  } value;
    #####:   71:  SliceComputationResult(ResultEnum v) : value(v) {}
        -:   72:};
        -:   73:
        -:   74:/// ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their
        -:   75:/// associated operands for a set of loops within a loop nest (typically the
        -:   76:/// set of loops surrounding a store operation). Loop bound AffineMaps which
        -:   77:/// are non-null represent slices of that loop's iteration space.
    #####:   78:struct ComputationSliceState {
call    0 never executed
        -:   79:  // List of sliced loop IVs (ordered from outermost to innermost).
        -:   80:  // EX: 'ivs[i]' has lower bound 'lbs[i]' and upper bound 'ubs[i]'.
        -:   81:  SmallVector<Value, 4> ivs;
        -:   82:  // List of lower bound AffineMaps.
        -:   83:  SmallVector<AffineMap, 4> lbs;
        -:   84:  // List of upper bound AffineMaps.
        -:   85:  SmallVector<AffineMap, 4> ubs;
        -:   86:  // List of lower bound operands (lbOperands[i] are used by 'lbs[i]').
        -:   87:  std::vector<SmallVector<Value, 4>> lbOperands;
        -:   88:  // List of upper bound operands (ubOperands[i] are used by 'ubs[i]').
        -:   89:  std::vector<SmallVector<Value, 4>> ubOperands;
        -:   90:  // Slice loop nest insertion point in target loop nest.
        -:   91:  Block::iterator insertPoint;
        -:   92:  // Adds to 'cst' with constraints which represent the slice bounds on 'ivs'
        -:   93:  // in 'this'. Specifically, the values in 'ivs' are added to 'cst' as dim
        -:   94:  // variables and the values in 'lb/ubOperands' are added as symbols.
        -:   95:  // Constraints are added for all loop IV bounds (dim or symbol), and
        -:   96:  // constraints are added for slice bounds in 'lbs'/'ubs'.
        -:   97:  // Returns failure if we cannot add loop bounds because of unsupported cases.
        -:   98:  LogicalResult getAsConstraints(FlatAffineValueConstraints *cst);
        -:   99:
        -:  100:  /// Adds to 'cst' constraints which represent the original loop bounds on
        -:  101:  /// 'ivs' in 'this'. This corresponds to the original domain of the loop nest
        -:  102:  /// from which the slice is being computed. Returns failure if we cannot add
        -:  103:  /// loop bounds because of unsupported cases.
        -:  104:  LogicalResult getSourceAsConstraints(FlatAffineValueConstraints &cst);
        -:  105:
        -:  106:  // Clears all bounds and operands in slice state.
        -:  107:  void clearBounds();
        -:  108:
        -:  109:  /// Returns true if the computation slice is empty.
        -:  110:  bool isEmpty() const { return ivs.empty(); }
        -:  111:
        -:  112:  /// Returns true if the computation slice encloses all the iterations of the
        -:  113:  /// sliced loop nest. Returns false if it does not. Returns llvm::None if it
        -:  114:  /// cannot determine if the slice is maximal or not.
        -:  115:  // TODO: Cache 'isMaximal' so that we don't recompute it when the slice
        -:  116:  // information hasn't changed.
        -:  117:  Optional<bool> isMaximal() const;
        -:  118:
        -:  119:  /// Checks the validity of the slice computed. This is done using the
        -:  120:  /// following steps:
        -:  121:  /// 1. Get the new domain of the slice that would be created if fusion
        -:  122:  /// succeeds. This domain gets constructed with source loop IVS and
        -:  123:  /// destination loop IVS as dimensions.
        -:  124:  /// 2. Project out the dimensions of the destination loop from the domain
        -:  125:  /// above calculated in step(1) to express it purely in terms of the source
        -:  126:  /// loop IVs.
        -:  127:  /// 3. Calculate a set difference between the iterations of the new domain and
        -:  128:  /// the original domain of the source loop.
        -:  129:  /// If this difference is empty, the slice is declared to be valid. Otherwise,
        -:  130:  /// return false as it implies that the effective fusion results in at least
        -:  131:  /// one iteration of the slice that was not originally in the source's domain.
        -:  132:  /// If the validity cannot be determined, returns llvm:None.
        -:  133:  Optional<bool> isSliceValid();
        -:  134:
        -:  135:  void dump() const;
        -:  136:
        -:  137:private:
        -:  138:  /// Fast check to determine if the computation slice is maximal. Returns true
        -:  139:  /// if each slice dimension maps to an existing dst dimension and both the src
        -:  140:  /// and the dst loops for those dimensions have the same bounds. Returns false
        -:  141:  /// if both the src and the dst loops don't have the same bounds. Returns
        -:  142:  /// llvm::None if none of the above can be proven.
        -:  143:  Optional<bool> isSliceMaximalFastCheck() const;
        -:  144:};
        -:  145:
        -:  146:/// Computes the computation slice loop bounds for one loop nest as affine maps
        -:  147:/// of the other loop nest's IVs and symbols, using 'dependenceConstraints'
        -:  148:/// computed between 'depSourceAccess' and 'depSinkAccess'.
        -:  149:/// If 'isBackwardSlice' is true, a backwards slice is computed in which the
        -:  150:/// slice bounds of loop nest surrounding 'depSourceAccess' are computed in
        -:  151:/// terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess'
        -:  152:/// at 'loopDepth'.
        -:  153:/// If 'isBackwardSlice' is false, a forward slice is computed in which the
        -:  154:/// slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms
        -:  155:/// of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at
        -:  156:/// 'loopDepth'.
        -:  157:/// The slice loop bounds and associated operands are returned in 'sliceState'.
        -:  158://
        -:  159://  Backward slice example:
        -:  160://
        -:  161://    affine.for %i0 = 0 to 10 {
        -:  162://      affine.store %cst, %0[%i0] : memref<100xf32>  // 'depSourceAccess'
        -:  163://    }
        -:  164://    affine.for %i1 = 0 to 10 {
        -:  165://      %v = affine.load %0[%i1] : memref<100xf32>    // 'depSinkAccess'
        -:  166://    }
        -:  167://
        -:  168://    // Backward computation slice of loop nest '%i0'.
        -:  169://    affine.for %i0 = (d0) -> (d0)(%i1) to (d0) -> (d0 + 1)(%i1) {
        -:  170://      affine.store %cst, %0[%i0] : memref<100xf32>  // 'depSourceAccess'
        -:  171://    }
        -:  172://
        -:  173://  Forward slice example:
        -:  174://
        -:  175://    affine.for %i0 = 0 to 10 {
        -:  176://      affine.store %cst, %0[%i0] : memref<100xf32>  // 'depSourceAccess'
        -:  177://    }
        -:  178://    affine.for %i1 = 0 to 10 {
        -:  179://      %v = affine.load %0[%i1] : memref<100xf32>    // 'depSinkAccess'
        -:  180://    }
        -:  181://
        -:  182://    // Forward computation slice of loop nest '%i1'.
        -:  183://    affine.for %i1 = (d0) -> (d0)(%i0) to (d0) -> (d0 + 1)(%i0) {
        -:  184://      %v = affine.load %0[%i1] : memref<100xf32>    // 'depSinkAccess'
        -:  185://    }
        -:  186://
        -:  187:void getComputationSliceState(Operation *depSourceOp, Operation *depSinkOp,
        -:  188:                              FlatAffineValueConstraints *dependenceConstraints,
        -:  189:                              unsigned loopDepth, bool isBackwardSlice,
        -:  190:                              ComputationSliceState *sliceState);
        -:  191:
        -:  192:/// Return the number of iterations for the `slicetripCountMap` provided.
        -:  193:uint64_t getSliceIterationCount(
        -:  194:    const llvm::SmallDenseMap<Operation *, uint64_t, 8> &sliceTripCountMap);
        -:  195:
        -:  196:/// Builds a map 'tripCountMap' from AffineForOp to constant trip count for
        -:  197:/// loop nest surrounding represented by slice loop bounds in 'slice'. Returns
        -:  198:/// true on success, false otherwise (if a non-constant trip count was
        -:  199:/// encountered).
        -:  200:bool buildSliceTripCountMap(
        -:  201:    const ComputationSliceState &slice,
        -:  202:    llvm::SmallDenseMap<Operation *, uint64_t, 8> *tripCountMap);
        -:  203:
        -:  204:/// Computes in 'sliceUnion' the union of all slice bounds computed at
        -:  205:/// 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and
        -:  206:/// then verifies if it is valid. The parameter 'numCommonLoops' is the number
        -:  207:/// of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice'
        -:  208:/// is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a
        -:  209:/// function of IVs and symbols of loop nest surrounding ops in 'opsB' at
        -:  210:/// 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop
        -:  211:/// nest surrounding ops in 'opsB', as a function of IVs and symbols of loop
        -:  212:/// nest surrounding ops in 'opsA' at 'loopDepth'. Returns
        -:  213:/// 'SliceComputationResult::Success' if union was computed correctly, an
        -:  214:/// appropriate 'failure' otherwise.
        -:  215:// TODO: Change this API to take 'forOpA'/'forOpB'.
        -:  216:SliceComputationResult
        -:  217:computeSliceUnion(ArrayRef<Operation *> opsA, ArrayRef<Operation *> opsB,
        -:  218:                  unsigned loopDepth, unsigned numCommonLoops,
        -:  219:                  bool isBackwardSlice, ComputationSliceState *sliceUnion);
        -:  220:
        -:  221:/// Creates a clone of the computation contained in the loop nest surrounding
        -:  222:/// 'srcOpInst', slices the iteration space of src loop based on slice bounds
        -:  223:/// in 'sliceState', and inserts the computation slice at the beginning of the
        -:  224:/// operation block of the loop at 'dstLoopDepth' in the loop nest surrounding
        -:  225:/// 'dstOpInst'. Returns the top-level loop of the computation slice on
        -:  226:/// success, returns nullptr otherwise.
        -:  227:// Loop depth is a crucial optimization choice that determines where to
        -:  228:// materialize the results of the backward slice - presenting a trade-off b/w
        -:  229:// storage and redundant computation in several cases.
        -:  230:// TODO: Support computation slices with common surrounding loops.
        -:  231:AffineForOp insertBackwardComputationSlice(Operation *srcOpInst,
        -:  232:                                           Operation *dstOpInst,
        -:  233:                                           unsigned dstLoopDepth,
        -:  234:                                           ComputationSliceState *sliceState);
        -:  235:
        -:  236:/// A region of a memref's data space; this is typically constructed by
        -:  237:/// analyzing load/store op's on this memref and the index space of loops
        -:  238:/// surrounding such op's.
        -:  239:// For example, the memref region for a load operation at loop depth = 1:
        -:  240://
        -:  241://    affine.for %i = 0 to 32 {
        -:  242://      affine.for %ii = %i to (d0) -> (d0 + 8) (%i) {
        -:  243://        affine.load %A[%ii]
        -:  244://      }
        -:  245://    }
        -:  246://
        -:  247:// Region:  {memref = %A, write = false, {%i <= m0 <= %i + 7} }
        -:  248:// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.
        -:  249://
     8524:  250:struct MemRefRegion {
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir12MemRefRegionC2ENS_8LocationE called 8524 returned 100% blocks executed 100%
     8524:  251:  explicit MemRefRegion(Location loc) : loc(loc) {}
call    0 returned 100%
        -:  252:
        -:  253:  /// Computes the memory region accessed by this memref with the region
        -:  254:  /// represented as constraints symbolic/parametric in 'loopDepth' loops
        -:  255:  /// surrounding opInst. The computed region's 'cst' field has exactly as many
        -:  256:  /// dimensional variables as the rank of the memref, and *potentially*
        -:  257:  /// additional symbolic variables which could include any of the loop IVs
        -:  258:  /// surrounding opInst up until 'loopDepth' and another additional Function
        -:  259:  /// symbols involved with the access (for eg., those appear in affine.apply's,
        -:  260:  /// loop bounds, etc.). If 'sliceState' is non-null, operands from
        -:  261:  /// 'sliceState' are added as symbols, and the following constraints are added
        -:  262:  /// to the system:
        -:  263:  /// *) Inequality constraints which represent loop bounds for 'sliceState'
        -:  264:  ///    operands which are loop IVS (these represent the destination loop IVs
        -:  265:  ///    of the slice, and are added as symbols to MemRefRegion's constraint
        -:  266:  ///    system).
        -:  267:  /// *) Inequality constraints for the slice bounds in 'sliceState', which
        -:  268:  ///    represent the bounds on the loop IVs in this constraint system w.r.t
        -:  269:  ///    to slice operands (which correspond to symbols).
        -:  270:  /// If 'addMemRefDimBounds' is true, constant upper/lower bounds
        -:  271:  /// [0, memref.getDimSize(i)) are added for each MemRef dimension 'i'.
        -:  272:  ///
        -:  273:  ///  For example, the memref region for this operation at loopDepth = 1 will
        -:  274:  ///  be:
        -:  275:  ///
        -:  276:  ///    affine.for %i = 0 to 32 {
        -:  277:  ///      affine.for %ii = %i to (d0) -> (d0 + 8) (%i) {
        -:  278:  ///        load %A[%ii]
        -:  279:  ///      }
        -:  280:  ///    }
        -:  281:  ///
        -:  282:  ///   {memref = %A, write = false, {%i <= m0 <= %i + 7} }
        -:  283:  /// The last field is a 2-d FlatAffineValueConstraints symbolic in %i.
        -:  284:  ///
        -:  285:  LogicalResult compute(Operation *op, unsigned loopDepth,
        -:  286:                        const ComputationSliceState *sliceState = nullptr,
        -:  287:                        bool addMemRefDimBounds = true);
        -:  288:
   33320*:  289:  FlatAffineValueConstraints *getConstraints() { return &cst; }
call    0 never executed
call    1 returned 100%
call    2 returned 100%
call    3 never executed
call    4 returned 100%
call    5 returned 100%
     7318:  290:  const FlatAffineValueConstraints *getConstraints() const { return &cst; }
call    0 returned 100%
        -:  291:  bool isWrite() const { return write; }
        -:  292:  void setWrite(bool flag) { write = flag; }
        -:  293:
        -:  294:  /// Returns a constant upper bound on the number of elements in this region if
        -:  295:  /// bounded by a known constant (always possible for static shapes), None
        -:  296:  /// otherwise. Note that the symbols of the region are treated specially,
        -:  297:  /// i.e., the returned bounding constant holds for *any given* value of the
        -:  298:  /// symbol variables. The 'shape' vector is set to the corresponding
        -:  299:  /// dimension-wise bounds major to minor. The number of elements and all the
        -:  300:  /// dimension-wise bounds are guaranteed to be non-negative. We use int64_t
        -:  301:  /// instead of uint64_t since index types can be at most int64_t. `lbs` are
        -:  302:  /// set to the lower bounds for each of the rank dimensions, and lbDivisors
        -:  303:  /// contains the corresponding denominators for floorDivs.
        -:  304:  Optional<int64_t> getConstantBoundingSizeAndShape(
        -:  305:      SmallVectorImpl<int64_t> *shape = nullptr,
        -:  306:      std::vector<SmallVector<int64_t, 4>> *lbs = nullptr,
        -:  307:      SmallVectorImpl<int64_t> *lbDivisors = nullptr) const;
        -:  308:
        -:  309:  /// Gets the lower and upper bound map for the dimensional variable at
        -:  310:  /// `pos`.
        -:  311:  void getLowerAndUpperBound(unsigned pos, AffineMap &lbMap,
        -:  312:                             AffineMap &ubMap) const;
        -:  313:
        -:  314:  /// A wrapper around FlatAffineValueConstraints::getConstantBoundOnDimSize().
        -:  315:  /// 'pos' corresponds to the position of the memref shape's dimension (major
        -:  316:  /// to minor) which matches 1:1 with the dimensional variable positions in
        -:  317:  /// 'cst'.
        -:  318:  Optional<int64_t>
        -:  319:  getConstantBoundOnDimSize(unsigned pos,
        -:  320:                            SmallVectorImpl<int64_t> *lb = nullptr,
        -:  321:                            int64_t *lbFloorDivisor = nullptr) const {
        -:  322:    assert(pos < getRank() && "invalid position");
        -:  323:    return cst.getConstantBoundOnDimSize64(pos, lb);
        -:  324:  }
        -:  325:
        -:  326:  /// Returns the size of this MemRefRegion in bytes.
        -:  327:  Optional<int64_t> getRegionSize();
        -:  328:
        -:  329:  // Wrapper around FlatAffineValueConstraints::unionBoundingBox.
        -:  330:  LogicalResult unionBoundingBox(const MemRefRegion &other);
        -:  331:
        -:  332:  /// Returns the rank of the memref that this region corresponds to.
        -:  333:  unsigned getRank() const;
        -:  334:
        -:  335:  /// Memref that this region corresponds to.
        -:  336:  Value memref;
        -:  337:
        -:  338:  /// Read or write.
        -:  339:  bool write = false;
        -:  340:
        -:  341:  /// If there is more than one load/store op associated with the region, the
        -:  342:  /// location information would correspond to one of those op's.
        -:  343:  Location loc;
        -:  344:
        -:  345:  /// Region (data space) of the memref accessed. This set will thus have at
        -:  346:  /// least as many dimensional variables as the shape dimensionality of the
        -:  347:  /// memref, and these are the leading dimensions of the set appearing in that
        -:  348:  /// order (major to minor / outermost to innermost). There may be additional
        -:  349:  /// variables since getMemRefRegion() is called with a specific loop depth,
        -:  350:  /// and thus the region is symbolic in the outer surrounding loops at that
        -:  351:  /// depth.
        -:  352:  // TODO: Replace this to exploit HyperRectangularSet.
        -:  353:  FlatAffineValueConstraints cst;
        -:  354:};
        -:  355:
        -:  356:/// Returns the size of memref data in bytes if it's statically shaped, None
        -:  357:/// otherwise.
        -:  358:Optional<uint64_t> getMemRefSizeInBytes(MemRefType memRefType);
        -:  359:
        -:  360:/// Checks a load or store op for an out of bound access; returns failure if the
        -:  361:/// access is out of bounds along any of the dimensions, success otherwise.
        -:  362:/// Emits a diagnostic error (with location information) if emitError is true.
        -:  363:template <typename LoadOrStoreOpPointer>
        -:  364:LogicalResult boundCheckLoadOrStoreOp(LoadOrStoreOpPointer loadOrStoreOp,
        -:  365:                                      bool emitError = true);
        -:  366:
        -:  367:/// Returns the number of surrounding loops common to both A and B.
        -:  368:unsigned getNumCommonSurroundingLoops(Operation &a, Operation &b);
        -:  369:
        -:  370:/// Gets the memory footprint of all data touched in the specified memory space
        -:  371:/// in bytes; if the memory space is unspecified, considers all memory spaces.
        -:  372:Optional<int64_t> getMemoryFootprintBytes(AffineForOp forOp,
        -:  373:                                          int memorySpace = -1);
        -:  374:
        -:  375:/// Simplify the integer set by simplifying the underlying affine expressions by
        -:  376:/// flattening and some simple inference. Also, drop any duplicate constraints.
        -:  377:/// Returns the simplified integer set. This method runs in time linear in the
        -:  378:/// number of constraints.
        -:  379:IntegerSet simplifyIntegerSet(IntegerSet set);
        -:  380:
        -:  381:/// Returns the innermost common loop depth for the set of operations in 'ops'.
        -:  382:unsigned getInnermostCommonLoopDepth(
        -:  383:    ArrayRef<Operation *> ops,
        -:  384:    SmallVectorImpl<AffineForOp> *surroundingLoops = nullptr);
        -:  385:
        -:  386:} // namespace mlir
        -:  387:
        -:  388:#endif // MLIR_DIALECT_AFFINE_ANALYSIS_UTILS_H
