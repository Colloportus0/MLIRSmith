        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/MemRef/Transforms/SimplifyExtractStridedMetadata.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/MemRef/Transforms/CMakeFiles/obj.MLIRMemRefTransforms.dir/SimplifyExtractStridedMetadata.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/MemRef/Transforms/CMakeFiles/obj.MLIRMemRefTransforms.dir/SimplifyExtractStridedMetadata.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- SimplifyExtractStridedMetadata.cpp - Simplify this operation -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:/// This pass simplifies extract_strided_metadata(other_op(memref) to
        -:   10:/// extract_strided_metadata(memref) when it is possible to express the effect
        -:   11:// of other_op using affine apply on the results of
        -:   12:// extract_strided_metadata(memref).
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   16:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   17:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   18:#include "mlir/Dialect/MemRef/Transforms/Passes.h"
        -:   19:#include "mlir/IR/BuiltinTypes.h"
        -:   20:#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/SmallBitVector.h"
        -:   23:
        -:   24:namespace mlir {
        -:   25:namespace memref {
        -:   26:#define GEN_PASS_DEF_SIMPLIFYEXTRACTSTRIDEDMETADATA
        -:   27:#include "mlir/Dialect/MemRef/Transforms/Passes.h.inc"
        -:   28:} // namespace memref
        -:   29:} // namespace mlir
        -:   30:using namespace mlir;
        -:   31:
        -:   32:namespace {
        -:   33:/// Replace `baseBuffer, offset, sizes, strides =
        -:   34:///              extract_strided_metadata(subview(memref, subOffset,
        -:   35:///                                               subSizes, subStrides))`
        -:   36:/// With
        -:   37:///
        -:   38:/// \verbatim
        -:   39:/// baseBuffer, baseOffset, baseSizes, baseStrides =
        -:   40:///     extract_strided_metadata(memref)
        -:   41:/// strides#i = baseStrides#i * subSizes#i
        -:   42:/// offset = baseOffset + sum(subOffset#i * baseStrides#i)
        -:   43:/// sizes = subSizes
        -:   44:/// \endverbatim
        -:   45:///
        -:   46:/// In other words, get rid of the subview in that expression and canonicalize
        -:   47:/// on its effects on the offset, the sizes, and the strides using affine.apply.
        -:   48:struct ExtractStridedMetadataOpSubviewFolder
        -:   49:    : public OpRewritePattern<memref::ExtractStridedMetadataOp> {
        -:   50:public:
        -:   51:  using OpRewritePattern<memref::ExtractStridedMetadataOp>::OpRewritePattern;
        -:   52:
function _ZNK12_GLOBAL__N_137ExtractStridedMetadataOpSubviewFolder15matchAndRewriteEN4mlir6memref24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   53:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:   54:                                PatternRewriter &rewriter) const override {
    #####:   55:    auto subview = op.getSource().getDefiningOp<memref::SubViewOp>();
call    0 never executed
call    1 never executed
    #####:   56:    if (!subview)
branch  0 never executed
branch  1 never executed
    #####:   57:      return failure();
        -:   58:
        -:   59:    // Build a plain extract_strided_metadata(memref) from
        -:   60:    // extract_strided_metadata(subview(memref)).
    #####:   61:    Location origLoc = op.getLoc();
call    0 never executed
    #####:   62:    Value source = subview.getSource();
call    0 never executed
    #####:   63:    auto sourceType = source.getType().cast<MemRefType>();
call    0 never executed
    #####:   64:    unsigned sourceRank = sourceType.getRank();
call    0 never executed
        -:   65:
    #####:   66:    auto newExtractStridedMetadata =
    #####:   67:        rewriter.create<memref::ExtractStridedMetadataOp>(origLoc, source);
call    0 never executed
        -:   68:
    #####:   69:    SmallVector<int64_t> sourceStrides;
call    0 never executed
    #####:   70:    int64_t sourceOffset;
        -:   71:
    #####:   72:    bool hasKnownStridesAndOffset =
    #####:   73:        succeeded(getStridesAndOffset(sourceType, sourceStrides, sourceOffset));
call    0 never executed
    #####:   74:    (void)hasKnownStridesAndOffset;
    #####:   75:    assert(hasKnownStridesAndOffset &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   76:           "getStridesAndOffset must work on valid subviews");
        -:   77:
        -:   78:    // Compute the new strides and offset from the base strides and offset:
        -:   79:    // newStride#i = baseStride#i * subStride#i
        -:   80:    // offset = baseOffset + sum(subOffsets#i * newStrides#i)
    #####:   81:    SmallVector<OpFoldResult> strides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   82:    SmallVector<OpFoldResult> subStrides = subview.getMixedStrides();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   83:    auto origStrides = newExtractStridedMetadata.getStrides();
call    0 never executed
        -:   84:
        -:   85:    // Hold the affine symbols and values for the computation of the offset.
    #####:   86:    SmallVector<OpFoldResult> values(2 * sourceRank + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   87:    SmallVector<AffineExpr> symbols(2 * sourceRank + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   88:
    #####:   89:    detail::bindSymbolsList(rewriter.getContext(), symbols);
call    0 never executed
    #####:   90:    AffineExpr expr = symbols.front();
branch  0 never executed
branch  1 never executed
    #####:   91:    values[0] = ShapedType::isDynamicStrideOrOffset(sourceOffset)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   92:                    ? getAsOpFoldResult(newExtractStridedMetadata.getOffset())
call    0 never executed
call    1 never executed
    #####:   93:                    : rewriter.getIndexAttr(sourceOffset);
call    0 never executed
call    1 never executed
    #####:   94:    SmallVector<OpFoldResult> subOffsets = subview.getMixedOffsets();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:   95:
    #####:   96:    AffineExpr s0 = rewriter.getAffineSymbolExpr(0);
call    0 never executed
    #####:   97:    AffineExpr s1 = rewriter.getAffineSymbolExpr(1);
    #####:   98:    for (unsigned i = 0; i < sourceRank; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   99:      // Compute the stride.
    #####:  100:      OpFoldResult origStride =
    #####:  101:          ShapedType::isDynamicStrideOrOffset(sourceStrides[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  102:              ? origStrides[i]
call    0 never executed
call    1 never executed
    #####:  103:              : OpFoldResult(rewriter.getIndexAttr(sourceStrides[i]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  104:      strides.push_back(makeComposedFoldedAffineApply(
call    0 never executed
call    1 never executed
    #####:  105:          rewriter, origLoc, s0 * s1, {subStrides[i], origStride}));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  106:
        -:  107:      // Build up the computation of the offset.
    #####:  108:      unsigned baseIdxForDim = 1 + 2 * i;
    #####:  109:      unsigned subOffsetForDim = baseIdxForDim;
    #####:  110:      unsigned origStrideForDim = baseIdxForDim + 1;
    #####:  111:      expr = expr + symbols[subOffsetForDim] * symbols[origStrideForDim];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  112:      values[subOffsetForDim] = subOffsets[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  113:      values[origStrideForDim] = origStride;
branch  0 never executed
branch  1 never executed
        -:  114:    }
        -:  115:
        -:  116:    // Compute the offset.
    #####:  117:    OpFoldResult finalOffset =
call    0 never executed
    #####:  118:        makeComposedFoldedAffineApply(rewriter, origLoc, expr, values);
call    0 never executed
        -:  119:
    #####:  120:    SmallVector<Value> results;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  121:    // The final result is  <baseBuffer, offset, sizes, strides>.
        -:  122:    // Thus we need 1 + 1 + subview.getRank() + subview.getRank(), to hold all
        -:  123:    // the values.
    #####:  124:    auto subType = subview.getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  125:    unsigned subRank = subType.getRank();
call    0 never executed
        -:  126:    // Properly size the array so that we can do random insertions
        -:  127:    // at the right indices.
        -:  128:    // We do that to populate the non-dropped sizes and strides in one go.
    #####:  129:    results.resize_for_overwrite(subRank * 2 + 2);
call    0 never executed
        -:  130:
    #####:  131:    results[0] = newExtractStridedMetadata.getBaseBuffer();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  132:    results[1] =
    #####:  133:        getValueOrCreateConstantIndexOp(rewriter, origLoc, finalOffset);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  134:
        -:  135:    // The sizes of the final type are defined directly by the input sizes of
        -:  136:    // the subview.
        -:  137:    // Moreover subviews can drop some dimensions, some strides and sizes may
        -:  138:    // not end up in the final <base, offset, sizes, strides> value that we are
        -:  139:    // replacing.
        -:  140:    // Do the filtering here.
    #####:  141:    SmallVector<OpFoldResult> subSizes = subview.getMixedSizes();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  142:    const unsigned sizeStartIdx = 2;
    #####:  143:    const unsigned strideStartIdx = sizeStartIdx + subRank;
    #####:  144:    unsigned insertedDims = 0;
    #####:  145:    llvm::SmallBitVector droppedDims = subview.getDroppedDims();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  146:    for (unsigned i = 0; i < sourceRank; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  147:      if (droppedDims.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  148:        continue;
        -:  149:
    #####:  150:      results[sizeStartIdx + insertedDims] =
branch  0 never executed
branch  1 never executed
    #####:  151:          getValueOrCreateConstantIndexOp(rewriter, origLoc, subSizes[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  152:      results[strideStartIdx + insertedDims] =
branch  0 never executed
branch  1 never executed
    #####:  153:          getValueOrCreateConstantIndexOp(rewriter, origLoc, strides[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  154:      ++insertedDims;
        -:  155:    }
    #####:  156:    assert(insertedDims == subRank &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  157:           "Should have populated all the values at this point");
        -:  158:
    #####:  159:    rewriter.replaceOp(op, results);
call    0 never executed
call    1 never executed
    #####:  160:    return success();
call    0 never executed
        -:  161:  }
        -:  162:};
        -:  163:
        -:  164:/// Compute the expanded sizes of the given \p expandShape for the
        -:  165:/// \p groupId-th reassociation group.
        -:  166:/// \p origSizes hold the sizes of the source shape as values.
        -:  167:/// This is used to compute the new sizes in cases of dynamic shapes.
        -:  168:///
        -:  169:/// sizes#i =
        -:  170:///     baseSizes#groupId / product(expandShapeSizes#j,
        -:  171:///                                  for j in group excluding reassIdx#i)
        -:  172:/// Where reassIdx#i is the reassociation index at index i in \p groupId.
        -:  173:///
        -:  174:/// \post result.size() == expandShape.getReassociationIndices()[groupId].size()
        -:  175:///
        -:  176:/// TODO: Move this utility function directly within ExpandShapeOp. For now,
        -:  177:/// this is not possible because this function uses the Affine dialect and the
        -:  178:/// MemRef dialect cannot depend on the Affine dialect.
        -:  179:static SmallVector<OpFoldResult>
function _ZN12_GLOBAL__N_1L16getExpandedSizesEN4mlir6memref13ExpandShapeOpERNS0_9OpBuilderEN4llvm8ArrayRefINS0_12OpFoldResultEEEj called 0 returned 0% blocks executed 0%
    #####:  180:getExpandedSizes(memref::ExpandShapeOp expandShape, OpBuilder &builder,
        -:  181:                 ArrayRef<OpFoldResult> origSizes, unsigned groupId) {
    #####:  182:  SmallVector<int64_t, 2> reassocGroup =
    #####:  183:      expandShape.getReassociationIndices()[groupId];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  184:  assert(!reassocGroup.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  185:         "Reassociation group should have at least one dimension");
        -:  186:
    #####:  187:  unsigned groupSize = reassocGroup.size();
call    0 never executed
    #####:  188:  SmallVector<OpFoldResult> expandedSizes(groupSize);
call    0 never executed
        -:  189:
    #####:  190:  uint64_t productOfAllStaticSizes = 1;
    #####:  191:  Optional<unsigned> dynSizeIdx;
    #####:  192:  MemRefType expandShapeType = expandShape.getResultType();
        -:  193:
        -:  194:  // Fill up all the statically known sizes.
    #####:  195:  for (unsigned i = 0; i < groupSize; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  196:    uint64_t dimSize = expandShapeType.getDimSize(reassocGroup[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  197:    if (ShapedType::isDynamic(dimSize)) {
branch  0 never executed
branch  1 never executed
    #####:  198:      assert(!dynSizeIdx && "There must be at most one dynamic size per group");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  199:      dynSizeIdx = i;
    #####:  200:      continue;
        -:  201:    }
    #####:  202:    productOfAllStaticSizes *= dimSize;
    #####:  203:    expandedSizes[i] = builder.getIndexAttr(dimSize);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  204:  }
        -:  205:
        -:  206:  // Compute the dynamic size using the original size and all the other known
        -:  207:  // static sizes:
        -:  208:  // expandSize = origSize / productOfAllStaticSizes.
    #####:  209:  if (dynSizeIdx) {
branch  0 never executed
branch  1 never executed
    #####:  210:    AffineExpr s0 = builder.getAffineSymbolExpr(0);
call    0 never executed
    #####:  211:    expandedSizes[*dynSizeIdx] = makeComposedFoldedAffineApply(
branch  0 never executed
branch  1 never executed
        -:  212:        builder, expandShape.getLoc(), s0.floorDiv(productOfAllStaticSizes),
    #####:  213:        origSizes[groupId]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  214:  }
        -:  215:
    #####:  216:  return expandedSizes;
branch  0 never executed
branch  1 never executed
        -:  217:}
        -:  218:
        -:  219:/// Compute the expanded strides of the given \p expandShape for the
        -:  220:/// \p groupId-th reassociation group.
        -:  221:/// \p origStrides and \p origSizes hold respectively the strides and sizes
        -:  222:/// of the source shape as values.
        -:  223:/// This is used to compute the strides in cases of dynamic shapes and/or
        -:  224:/// dynamic stride for this reassociation group.
        -:  225:///
        -:  226:/// strides#i =
        -:  227:///     origStrides#reassDim * product(expandShapeSizes#j, for j in
        -:  228:///                                    reassIdx#i+1..reassIdx#i+group.size-1)
        -:  229:///
        -:  230:/// Where reassIdx#i is the reassociation index for at index i in \p groupId
        -:  231:/// and expandShapeSizes#j is either:
        -:  232:/// - The constant size at dimension j, derived directly from the result type of
        -:  233:///   the expand_shape op, or
        -:  234:/// - An affine expression: baseSizes#reassDim / product of all constant sizes
        -:  235:///   in expandShapeSizes. (Remember expandShapeSizes has at most one dynamic
        -:  236:///   element.)
        -:  237:///
        -:  238:/// \post result.size() == expandShape.getReassociationIndices()[groupId].size()
        -:  239:///
        -:  240:/// TODO: Move this utility function directly within ExpandShapeOp. For now,
        -:  241:/// this is not possible because this function uses the Affine dialect and the
        -:  242:/// MemRef dialect cannot depend on the Affine dialect.
function _ZN12_GLOBAL__N_118getExpandedStridesEN4mlir6memref13ExpandShapeOpERNS0_9OpBuilderEN4llvm8ArrayRefINS0_12OpFoldResultEEES8_j called 0 returned 0% blocks executed 0%
    #####:  243:SmallVector<OpFoldResult> getExpandedStrides(memref::ExpandShapeOp expandShape,
        -:  244:                                             OpBuilder &builder,
        -:  245:                                             ArrayRef<OpFoldResult> origSizes,
        -:  246:                                             ArrayRef<OpFoldResult> origStrides,
        -:  247:                                             unsigned groupId) {
    #####:  248:  SmallVector<int64_t, 2> reassocGroup =
    #####:  249:      expandShape.getReassociationIndices()[groupId];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  250:  assert(!reassocGroup.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  251:         "Reassociation group should have at least one dimension");
        -:  252:
    #####:  253:  unsigned groupSize = reassocGroup.size();
call    0 never executed
    #####:  254:  MemRefType expandShapeType = expandShape.getResultType();
call    0 never executed
        -:  255:
    #####:  256:  Optional<int64_t> dynSizeIdx;
        -:  257:
        -:  258:  // Fill up the expanded strides, with the information we can deduce from the
        -:  259:  // resulting shape.
    #####:  260:  uint64_t currentStride = 1;
    #####:  261:  SmallVector<OpFoldResult> expandedStrides(groupSize);
call    0 never executed
    #####:  262:  for (int i = groupSize - 1; i >= 0; --i) {
branch  0 never executed
branch  1 never executed
    #####:  263:    expandedStrides[i] = builder.getIndexAttr(currentStride);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  264:    uint64_t dimSize = expandShapeType.getDimSize(reassocGroup[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  265:    if (ShapedType::isDynamic(dimSize)) {
branch  0 never executed
branch  1 never executed
    #####:  266:      assert(!dynSizeIdx && "There must be at most one dynamic size per group");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  267:      dynSizeIdx = i;
    #####:  268:      continue;
        -:  269:    }
        -:  270:
    #####:  271:    currentStride *= dimSize;
        -:  272:  }
        -:  273:
        -:  274:  // Collect the statically known information about the original stride.
    #####:  275:  Value source = expandShape.getSrc();
call    0 never executed
    #####:  276:  auto sourceType = source.getType().cast<MemRefType>();
call    0 never executed
    #####:  277:  SmallVector<int64_t> strides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  278:  int64_t offset;
    #####:  279:  bool hasKnownStridesAndOffset =
    #####:  280:      succeeded(getStridesAndOffset(sourceType, strides, offset));
call    0 never executed
    #####:  281:  (void)hasKnownStridesAndOffset;
    #####:  282:  assert(hasKnownStridesAndOffset &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  283:         "getStridesAndOffset must work on valid expand_shape");
        -:  284:
    #####:  285:  OpFoldResult origStride =
    #####:  286:      ShapedType::isDynamicStrideOrOffset(strides[groupId])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  287:          ? origStrides[groupId]
branch  0 never executed
branch  1 never executed
    #####:  288:          : builder.getIndexAttr(strides[groupId]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  289:
        -:  290:  // Apply the original stride to all the strides.
    #####:  291:  int64_t doneStrideIdx = 0;
        -:  292:  // If we saw a dynamic dimension, we need to fix-up all the strides up to
        -:  293:  // that dimension with the dynamic size.
    #####:  294:  if (dynSizeIdx) {
branch  0 never executed
branch  1 never executed
    #####:  295:    int64_t productOfAllStaticSizes = currentStride;
    #####:  296:    assert(ShapedType::isDynamic(sourceType.getDimSize(groupId)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  297:           "We shouldn't be able to change dynamicity");
    #####:  298:    OpFoldResult origSize = origSizes[groupId];
branch  0 never executed
branch  1 never executed
        -:  299:
    #####:  300:    AffineExpr s0 = builder.getAffineSymbolExpr(0);
call    0 never executed
    #####:  301:    AffineExpr s1 = builder.getAffineSymbolExpr(1);
call    0 never executed
    #####:  302:    for (; doneStrideIdx < *dynSizeIdx; ++doneStrideIdx) {
branch  0 never executed
branch  1 never executed
    #####:  303:      int64_t baseExpandedStride = expandedStrides[doneStrideIdx]
branch  0 never executed
branch  1 never executed
    #####:  304:                                       .get<Attribute>()
call    0 never executed
call    1 never executed
    #####:  305:                                       .cast<IntegerAttr>()
    #####:  306:                                       .getInt();
call    0 never executed
    #####:  307:      expandedStrides[doneStrideIdx] = makeComposedFoldedAffineApply(
branch  0 never executed
branch  1 never executed
        -:  308:          builder, expandShape.getLoc(),
    #####:  309:          (s0 * baseExpandedStride).floorDiv(productOfAllStaticSizes) * s1,
call    0 never executed
call    1 never executed
    #####:  310:          {origSize, origStride});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  311:    }
        -:  312:  }
        -:  313:
        -:  314:  // Now apply the origStride to the remaining dimensions.
    #####:  315:  AffineExpr s0 = builder.getAffineSymbolExpr(0);
call    0 never executed
    #####:  316:  for (; doneStrideIdx < groupSize; ++doneStrideIdx) {
branch  0 never executed
branch  1 never executed
    #####:  317:    int64_t baseExpandedStride = expandedStrides[doneStrideIdx]
branch  0 never executed
branch  1 never executed
    #####:  318:                                     .get<Attribute>()
call    0 never executed
call    1 never executed
    #####:  319:                                     .cast<IntegerAttr>()
    #####:  320:                                     .getInt();
call    0 never executed
    #####:  321:    expandedStrides[doneStrideIdx] = makeComposedFoldedAffineApply(
branch  0 never executed
branch  1 never executed
    #####:  322:        builder, expandShape.getLoc(), s0 * baseExpandedStride, {origStride});
call    0 never executed
call    1 never executed
        -:  323:  }
        -:  324:
    #####:  325:  return expandedStrides;
branch  0 never executed
branch  1 never executed
        -:  326:}
        -:  327:
        -:  328:/// Produce an OpFoldResult object with \p builder at \p loc representing
        -:  329:/// `prod(valueOrConstant#i, for i in {indices})`,
        -:  330:/// where valueOrConstant#i is maybeConstant[i] when \p isDymamic is false,
        -:  331:/// values[i] otherwise.
        -:  332:///
        -:  333:/// \pre for all index in indices: index < values.size()
        -:  334:/// \pre for all index in indices: index < maybeConstants.size()
        -:  335:static OpFoldResult
function _ZN12_GLOBAL__N_1L18getProductOfValuesEN4llvm8ArrayRefIlEERN4mlir9OpBuilderENS3_8LocationES2_NS1_INS3_12OpFoldResultEEENS0_12function_refIFblEEE called 0 returned 0% blocks executed 0%
    #####:  336:getProductOfValues(ArrayRef<int64_t> indices, OpBuilder &builder, Location loc,
        -:  337:                   ArrayRef<int64_t> maybeConstants,
        -:  338:                   ArrayRef<OpFoldResult> values,
        -:  339:                   llvm::function_ref<bool(int64_t)> isDynamic) {
    #####:  340:  AffineExpr productOfValues = builder.getAffineConstantExpr(1);
call    0 never executed
    #####:  341:  SmallVector<OpFoldResult> inputValues;
    #####:  342:  unsigned numberOfSymbols = 0;
    #####:  343:  unsigned groupSize = indices.size();
    #####:  344:  for (unsigned i = 0; i < groupSize; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  345:    productOfValues =
    #####:  346:        productOfValues * builder.getAffineSymbolExpr(numberOfSymbols++);
call    0 never executed
call    1 never executed
    #####:  347:    unsigned srcIdx = indices[i];
branch  0 never executed
branch  1 never executed
    #####:  348:    int64_t maybeConstant = maybeConstants[srcIdx];
branch  0 never executed
branch  1 never executed
        -:  349:
    #####:  350:    inputValues.push_back(isDynamic(maybeConstant)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  351:                              ? values[srcIdx]
branch  0 never executed
branch  1 never executed
    #####:  352:                              : builder.getIndexAttr(maybeConstant));
call    0 never executed
call    1 never executed
        -:  353:  }
        -:  354:
    #####:  355:  return makeComposedFoldedAffineApply(builder, loc, productOfValues,
call    0 never executed
    #####:  356:                                       inputValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  357:}
        -:  358:
        -:  359:/// Compute the collapsed size of the given \p collpaseShape for the
        -:  360:/// \p groupId-th reassociation group.
        -:  361:/// \p origSizes hold the sizes of the source shape as values.
        -:  362:/// This is used to compute the new sizes in cases of dynamic shapes.
        -:  363:///
        -:  364:/// Conceptually this helper function computes:
        -:  365:/// `prod(origSizes#i, for i in {ressociationGroup[groupId]})`.
        -:  366:///
        -:  367:/// \post result.size() == 1, in other words, each group collapse to one
        -:  368:/// dimension.
        -:  369:///
        -:  370:/// TODO: Move this utility function directly within CollapseShapeOp. For now,
        -:  371:/// this is not possible because this function uses the Affine dialect and the
        -:  372:/// MemRef dialect cannot depend on the Affine dialect.
        -:  373:static SmallVector<OpFoldResult>
function _ZN12_GLOBAL__N_1L16getCollapsedSizeEN4mlir6memref15CollapseShapeOpERNS0_9OpBuilderEN4llvm8ArrayRefINS0_12OpFoldResultEEEj called 0 returned 0% blocks executed 0%
    #####:  374:getCollapsedSize(memref::CollapseShapeOp collapseShape, OpBuilder &builder,
        -:  375:                 ArrayRef<OpFoldResult> origSizes, unsigned groupId) {
    #####:  376:  SmallVector<OpFoldResult> collapsedSize;
call    0 never executed
        -:  377:
    #####:  378:  MemRefType collapseShapeType = collapseShape.getResultType();
call    0 never executed
        -:  379:
    #####:  380:  uint64_t size = collapseShapeType.getDimSize(groupId);
call    0 never executed
    #####:  381:  if (!ShapedType::isDynamic(size)) {
branch  0 never executed
branch  1 never executed
    #####:  382:    collapsedSize.push_back(builder.getIndexAttr(size));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  383:    return collapsedSize;
        -:  384:  }
        -:  385:
        -:  386:  // We are dealing with a dynamic size.
        -:  387:  // Build the affine expr of the product of the original sizes involved in that
        -:  388:  // group.
    #####:  389:  Value source = collapseShape.getSrc();
call    0 never executed
    #####:  390:  auto sourceType = source.getType().cast<MemRefType>();
call    0 never executed
        -:  391:
    #####:  392:  SmallVector<int64_t, 2> reassocGroup =
    #####:  393:      collapseShape.getReassociationIndices()[groupId];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  394:
    #####:  395:  collapsedSize.push_back(getProductOfValues(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  396:      reassocGroup, builder, collapseShape.getLoc(), sourceType.getShape(),
        -:  397:      origSizes, ShapedType::isDynamic));
        -:  398:
    #####:  399:  return collapsedSize;
branch  0 never executed
branch  1 never executed
        -:  400:}
        -:  401:
        -:  402:/// Compute the collapsed stride of the given \p collpaseShape for the
        -:  403:/// \p groupId-th reassociation group.
        -:  404:/// \p origStrides and \p origSizes hold respectively the strides and sizes
        -:  405:/// of the source shape as values.
        -:  406:/// This is used to compute the strides in cases of dynamic shapes and/or
        -:  407:/// dynamic stride for this reassociation group.
        -:  408:///
        -:  409:/// Conceptually this helper function returns the stride of the inner most
        -:  410:/// dimension of that group in the original shape.
        -:  411:///
        -:  412:/// \post result.size() == 1, in other words, each group collapse to one
        -:  413:/// dimension.
        -:  414:static SmallVector<OpFoldResult>
        -:  415:getCollapsedStride(memref::CollapseShapeOp collapseShape, OpBuilder &builder,
        -:  416:                   ArrayRef<OpFoldResult> origSizes,
        -:  417:                   ArrayRef<OpFoldResult> origStrides, unsigned groupId) {
        -:  418:  SmallVector<int64_t, 2> reassocGroup =
        -:  419:      collapseShape.getReassociationIndices()[groupId];
        -:  420:  assert(!reassocGroup.empty() &&
        -:  421:         "Reassociation group should have at least one dimension");
        -:  422:
        -:  423:  Value source = collapseShape.getSrc();
        -:  424:  auto sourceType = source.getType().cast<MemRefType>();
        -:  425:
        -:  426:  SmallVector<int64_t> strides;
        -:  427:  int64_t offset;
        -:  428:  bool hasKnownStridesAndOffset =
        -:  429:      succeeded(getStridesAndOffset(sourceType, strides, offset));
        -:  430:  (void)hasKnownStridesAndOffset;
        -:  431:  assert(hasKnownStridesAndOffset &&
        -:  432:         "getStridesAndOffset must work on valid collapse_shape");
        -:  433:
        -:  434:  SmallVector<OpFoldResult> collapsedStride;
        -:  435:  int64_t innerMostDimForGroup = reassocGroup.back();
        -:  436:  int64_t innerMostStrideForGroup = strides[innerMostDimForGroup];
        -:  437:  collapsedStride.push_back(
        -:  438:      ShapedType::isDynamicStrideOrOffset(innerMostStrideForGroup)
        -:  439:          ? origStrides[innerMostDimForGroup]
        -:  440:          : builder.getIndexAttr(innerMostStrideForGroup));
        -:  441:
        -:  442:  return collapsedStride;
        -:  443:}
        -:  444:/// Replace `baseBuffer, offset, sizes, strides =
        -:  445:///              extract_strided_metadata(reshapeLike(memref))`
        -:  446:/// With
        -:  447:///
        -:  448:/// \verbatim
        -:  449:/// baseBuffer, offset, baseSizes, baseStrides =
        -:  450:///     extract_strided_metadata(memref)
        -:  451:/// sizes = getReshapedSizes(reshapeLike)
        -:  452:/// strides = getReshapedStrides(reshapeLike)
        -:  453:/// \endverbatim
        -:  454:///
        -:  455:///
        -:  456:/// Notice that `baseBuffer` and `offset` are unchanged.
        -:  457:///
        -:  458:/// In other words, get rid of the expand_shape in that expression and
        -:  459:/// materialize its effects on the sizes and the strides using affine apply.
        -:  460:template <typename ReassociativeReshapeLikeOp,
        -:  461:          SmallVector<OpFoldResult> (*getReshapedSizes)(
        -:  462:              ReassociativeReshapeLikeOp, OpBuilder &,
        -:  463:              ArrayRef<OpFoldResult> /*origSizes*/, unsigned /*groupId*/),
        -:  464:          SmallVector<OpFoldResult> (*getReshapedStrides)(
        -:  465:              ReassociativeReshapeLikeOp, OpBuilder &,
        -:  466:              ArrayRef<OpFoldResult> /*origSizes*/,
        -:  467:              ArrayRef<OpFoldResult> /*origStrides*/, unsigned /*groupId*/)>
        -:  468:struct ExtractStridedMetadataOpReshapeFolder
        -:  469:    : public OpRewritePattern<memref::ExtractStridedMetadataOp> {
        -:  470:public:
        -:  471:  using OpRewritePattern<memref::ExtractStridedMetadataOp>::OpRewritePattern;
        -:  472:
    #####:  473:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  474:                                PatternRewriter &rewriter) const override {
    #####:  475:    auto reshape = op.getSource().getDefiningOp<ReassociativeReshapeLikeOp>();
    #####:  476:    if (!reshape)
    #####:  477:      return failure();
        -:  478:
        -:  479:    // Build a plain extract_strided_metadata(memref) from
        -:  480:    // extract_strided_metadata(reassociative_reshape_like(memref)).
    #####:  481:    Location origLoc = op.getLoc();
    #####:  482:    Value source = reshape.getSrc();
    #####:  483:    auto sourceType = source.getType().cast<MemRefType>();
    #####:  484:    unsigned sourceRank = sourceType.getRank();
        -:  485:
        -:  486:    auto newExtractStridedMetadata =
    #####:  487:        rewriter.create<memref::ExtractStridedMetadataOp>(origLoc, source);
        -:  488:
        -:  489:    // Collect statically known information.
    #####:  490:    SmallVector<int64_t> strides;
        -:  491:    int64_t offset;
        -:  492:    bool hasKnownStridesAndOffset =
    #####:  493:        succeeded(getStridesAndOffset(sourceType, strides, offset));
        -:  494:    (void)hasKnownStridesAndOffset;
    #####:  495:    assert(hasKnownStridesAndOffset &&
        -:  496:           "getStridesAndOffset must work on valid reassociative_reshape_like");
    #####:  497:    MemRefType reshapeType = reshape.getResultType();
    #####:  498:    unsigned reshapeRank = reshapeType.getRank();
        -:  499:
        -:  500:    // The result value will start with the base_buffer and offset.
    #####:  501:    unsigned baseIdxInResult = 2;
    #####:  502:    SmallVector<OpFoldResult> results(baseIdxInResult + reshapeRank * 2);
    #####:  503:    results[0] = newExtractStridedMetadata.getBaseBuffer();
    #####:  504:    results[1] = ShapedType::isDynamicStrideOrOffset(offset)
    #####:  505:                     ? getAsOpFoldResult(newExtractStridedMetadata.getOffset())
    #####:  506:                     : rewriter.getIndexAttr(offset);
        -:  507:
        -:  508:    // Get the special case of 0-D out of the way.
    #####:  509:    if (sourceRank == 0) {
    #####:  510:      Value constantOne = getValueOrCreateConstantIndexOp(
    #####:  511:          rewriter, origLoc, rewriter.getIndexAttr(1));
    #####:  512:      SmallVector<Value> resultValues(baseIdxInResult + reshapeRank * 2,
        -:  513:                                      constantOne);
    #####:  514:      for (unsigned i = 0; i < baseIdxInResult; ++i)
    #####:  515:        resultValues[i] =
    #####:  516:            getValueOrCreateConstantIndexOp(rewriter, origLoc, results[i]);
    #####:  517:      rewriter.replaceOp(op, resultValues);
    #####:  518:      return success();
        -:  519:    }
        -:  520:
        -:  521:    // Compute the reshaped strides and sizes from the base strides and sizes.
    #####:  522:    SmallVector<OpFoldResult> origSizes =
        -:  523:        getAsOpFoldResult(newExtractStridedMetadata.getSizes());
    #####:  524:    SmallVector<OpFoldResult> origStrides =
        -:  525:        getAsOpFoldResult(newExtractStridedMetadata.getStrides());
    #####:  526:    unsigned idx = 0, endIdx = reshape.getReassociationIndices().size();
    #####:  527:    for (; idx != endIdx; ++idx) {
    #####:  528:      SmallVector<OpFoldResult> reshapedSizes =
        -:  529:          getReshapedSizes(reshape, rewriter, origSizes, /*groupId=*/idx);
    #####:  530:      SmallVector<OpFoldResult> reshapedStrides = getReshapedStrides(
        -:  531:          reshape, rewriter, origSizes, origStrides, /*groupId=*/idx);
        -:  532:
    #####:  533:      unsigned groupSize = reshapedSizes.size();
    #####:  534:      const unsigned sizeStartIdx = baseIdxInResult;
    #####:  535:      const unsigned strideStartIdx = sizeStartIdx + reshapeRank;
    #####:  536:      for (unsigned i = 0; i < groupSize; ++i) {
    #####:  537:        results[sizeStartIdx + i] = reshapedSizes[i];
    #####:  538:        results[strideStartIdx + i] = reshapedStrides[i];
        -:  539:      }
    #####:  540:      baseIdxInResult += groupSize;
        -:  541:    }
    #####:  542:    assert(((isa<memref::ExpandShapeOp>(reshape) && idx == sourceRank) ||
        -:  543:            (isa<memref::CollapseShapeOp>(reshape) && idx == reshapeRank)) &&
        -:  544:           "We should have visited all the input dimensions");
    #####:  545:    assert(baseIdxInResult == reshapeRank + 2 &&
        -:  546:           "We should have populated all the values");
    #####:  547:    rewriter.replaceOp(
        -:  548:        op, getValueOrCreateConstantIndexOp(rewriter, origLoc, results));
    #####:  549:    return success();
        -:  550:  }
------------------
_ZNK12_GLOBAL__N_137ExtractStridedMetadataOpReshapeFolderIN4mlir6memref13ExpandShapeOpEXadL_ZNS_L16getExpandedSizesES3_RNS1_9OpBuilderEN4llvm8ArrayRefINS1_12OpFoldResultEEEjEEXadL_ZNS_18getExpandedStridesES3_S5_S9_S9_jEEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_137ExtractStridedMetadataOpReshapeFolderIN4mlir6memref13ExpandShapeOpEXadL_ZNS_L16getExpandedSizesES3_RNS1_9OpBuilderEN4llvm8ArrayRefINS1_12OpFoldResultEEEjEEXadL_ZNS_18getExpandedStridesES3_S5_S9_S9_jEEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  473:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  474:                                PatternRewriter &rewriter) const override {
    #####:  475:    auto reshape = op.getSource().getDefiningOp<ReassociativeReshapeLikeOp>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  476:    if (!reshape)
branch  0 never executed
branch  1 never executed
    #####:  477:      return failure();
        -:  478:
        -:  479:    // Build a plain extract_strided_metadata(memref) from
        -:  480:    // extract_strided_metadata(reassociative_reshape_like(memref)).
    #####:  481:    Location origLoc = op.getLoc();
call    0 never executed
    #####:  482:    Value source = reshape.getSrc();
call    0 never executed
    #####:  483:    auto sourceType = source.getType().cast<MemRefType>();
call    0 never executed
    #####:  484:    unsigned sourceRank = sourceType.getRank();
call    0 never executed
        -:  485:
        -:  486:    auto newExtractStridedMetadata =
    #####:  487:        rewriter.create<memref::ExtractStridedMetadataOp>(origLoc, source);
call    0 never executed
call    1 never executed
        -:  488:
        -:  489:    // Collect statically known information.
    #####:  490:    SmallVector<int64_t> strides;
        -:  491:    int64_t offset;
        -:  492:    bool hasKnownStridesAndOffset =
    #####:  493:        succeeded(getStridesAndOffset(sourceType, strides, offset));
call    0 never executed
        -:  494:    (void)hasKnownStridesAndOffset;
    #####:  495:    assert(hasKnownStridesAndOffset &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  496:           "getStridesAndOffset must work on valid reassociative_reshape_like");
    #####:  497:    MemRefType reshapeType = reshape.getResultType();
call    0 never executed
    #####:  498:    unsigned reshapeRank = reshapeType.getRank();
call    0 never executed
        -:  499:
        -:  500:    // The result value will start with the base_buffer and offset.
    #####:  501:    unsigned baseIdxInResult = 2;
    #####:  502:    SmallVector<OpFoldResult> results(baseIdxInResult + reshapeRank * 2);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  503:    results[0] = newExtractStridedMetadata.getBaseBuffer();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  504:    results[1] = ShapedType::isDynamicStrideOrOffset(offset)
branch  0 never executed
branch  1 never executed
    #####:  505:                     ? getAsOpFoldResult(newExtractStridedMetadata.getOffset())
call    0 never executed
call    1 never executed
    #####:  506:                     : rewriter.getIndexAttr(offset);
call    0 never executed
call    1 never executed
        -:  507:
        -:  508:    // Get the special case of 0-D out of the way.
    #####:  509:    if (sourceRank == 0) {
branch  0 never executed
branch  1 never executed
    #####:  510:      Value constantOne = getValueOrCreateConstantIndexOp(
call    0 never executed
    #####:  511:          rewriter, origLoc, rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
    #####:  512:      SmallVector<Value> resultValues(baseIdxInResult + reshapeRank * 2,
call    0 never executed
        -:  513:                                      constantOne);
    #####:  514:      for (unsigned i = 0; i < baseIdxInResult; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  515:        resultValues[i] =
branch  0 never executed
branch  1 never executed
    #####:  516:            getValueOrCreateConstantIndexOp(rewriter, origLoc, results[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  517:      rewriter.replaceOp(op, resultValues);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  518:      return success();
branch  0 never executed
branch  1 never executed
        -:  519:    }
        -:  520:
        -:  521:    // Compute the reshaped strides and sizes from the base strides and sizes.
    #####:  522:    SmallVector<OpFoldResult> origSizes =
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  523:        getAsOpFoldResult(newExtractStridedMetadata.getSizes());
    #####:  524:    SmallVector<OpFoldResult> origStrides =
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  525:        getAsOpFoldResult(newExtractStridedMetadata.getStrides());
    #####:  526:    unsigned idx = 0, endIdx = reshape.getReassociationIndices().size();
call    0 never executed
call    1 never executed
    #####:  527:    for (; idx != endIdx; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  528:      SmallVector<OpFoldResult> reshapedSizes =
call    0 never executed
call    1 never executed
        -:  529:          getReshapedSizes(reshape, rewriter, origSizes, /*groupId=*/idx);
    #####:  530:      SmallVector<OpFoldResult> reshapedStrides = getReshapedStrides(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  531:          reshape, rewriter, origSizes, origStrides, /*groupId=*/idx);
        -:  532:
    #####:  533:      unsigned groupSize = reshapedSizes.size();
    #####:  534:      const unsigned sizeStartIdx = baseIdxInResult;
    #####:  535:      const unsigned strideStartIdx = sizeStartIdx + reshapeRank;
    #####:  536:      for (unsigned i = 0; i < groupSize; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  537:        results[sizeStartIdx + i] = reshapedSizes[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  538:        results[strideStartIdx + i] = reshapedStrides[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  539:      }
    #####:  540:      baseIdxInResult += groupSize;
branch  0 never executed
branch  1 never executed
        -:  541:    }
    #####:  542:    assert(((isa<memref::ExpandShapeOp>(reshape) && idx == sourceRank) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  543:            (isa<memref::CollapseShapeOp>(reshape) && idx == reshapeRank)) &&
        -:  544:           "We should have visited all the input dimensions");
    #####:  545:    assert(baseIdxInResult == reshapeRank + 2 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  546:           "We should have populated all the values");
    #####:  547:    rewriter.replaceOp(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  548:        op, getValueOrCreateConstantIndexOp(rewriter, origLoc, results));
    #####:  549:    return success();
branch  0 never executed
branch  1 never executed
        -:  550:  }
------------------
_ZNK12_GLOBAL__N_137ExtractStridedMetadataOpReshapeFolderIN4mlir6memref15CollapseShapeOpEXadL_ZNS_L16getCollapsedSizeES3_RNS1_9OpBuilderEN4llvm8ArrayRefINS1_12OpFoldResultEEEjEEXadL_ZNS_L18getCollapsedStrideES3_S5_S9_S9_jEEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_137ExtractStridedMetadataOpReshapeFolderIN4mlir6memref15CollapseShapeOpEXadL_ZNS_L16getCollapsedSizeES3_RNS1_9OpBuilderEN4llvm8ArrayRefINS1_12OpFoldResultEEEjEEXadL_ZNS_L18getCollapsedStrideES3_S5_S9_S9_jEEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  473:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  474:                                PatternRewriter &rewriter) const override {
    #####:  475:    auto reshape = op.getSource().getDefiningOp<ReassociativeReshapeLikeOp>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  476:    if (!reshape)
branch  0 never executed
branch  1 never executed
    #####:  477:      return failure();
        -:  478:
        -:  479:    // Build a plain extract_strided_metadata(memref) from
        -:  480:    // extract_strided_metadata(reassociative_reshape_like(memref)).
    #####:  481:    Location origLoc = op.getLoc();
call    0 never executed
    #####:  482:    Value source = reshape.getSrc();
call    0 never executed
    #####:  483:    auto sourceType = source.getType().cast<MemRefType>();
call    0 never executed
    #####:  484:    unsigned sourceRank = sourceType.getRank();
call    0 never executed
        -:  485:
        -:  486:    auto newExtractStridedMetadata =
    #####:  487:        rewriter.create<memref::ExtractStridedMetadataOp>(origLoc, source);
call    0 never executed
call    1 never executed
        -:  488:
        -:  489:    // Collect statically known information.
    #####:  490:    SmallVector<int64_t> strides;
        -:  491:    int64_t offset;
        -:  492:    bool hasKnownStridesAndOffset =
    #####:  493:        succeeded(getStridesAndOffset(sourceType, strides, offset));
call    0 never executed
        -:  494:    (void)hasKnownStridesAndOffset;
    #####:  495:    assert(hasKnownStridesAndOffset &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  496:           "getStridesAndOffset must work on valid reassociative_reshape_like");
    #####:  497:    MemRefType reshapeType = reshape.getResultType();
call    0 never executed
    #####:  498:    unsigned reshapeRank = reshapeType.getRank();
call    0 never executed
        -:  499:
        -:  500:    // The result value will start with the base_buffer and offset.
    #####:  501:    unsigned baseIdxInResult = 2;
    #####:  502:    SmallVector<OpFoldResult> results(baseIdxInResult + reshapeRank * 2);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  503:    results[0] = newExtractStridedMetadata.getBaseBuffer();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  504:    results[1] = ShapedType::isDynamicStrideOrOffset(offset)
branch  0 never executed
branch  1 never executed
    #####:  505:                     ? getAsOpFoldResult(newExtractStridedMetadata.getOffset())
call    0 never executed
call    1 never executed
    #####:  506:                     : rewriter.getIndexAttr(offset);
call    0 never executed
call    1 never executed
        -:  507:
        -:  508:    // Get the special case of 0-D out of the way.
    #####:  509:    if (sourceRank == 0) {
branch  0 never executed
branch  1 never executed
    #####:  510:      Value constantOne = getValueOrCreateConstantIndexOp(
call    0 never executed
    #####:  511:          rewriter, origLoc, rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
    #####:  512:      SmallVector<Value> resultValues(baseIdxInResult + reshapeRank * 2,
call    0 never executed
        -:  513:                                      constantOne);
    #####:  514:      for (unsigned i = 0; i < baseIdxInResult; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  515:        resultValues[i] =
branch  0 never executed
branch  1 never executed
    #####:  516:            getValueOrCreateConstantIndexOp(rewriter, origLoc, results[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  517:      rewriter.replaceOp(op, resultValues);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  518:      return success();
branch  0 never executed
branch  1 never executed
        -:  519:    }
        -:  520:
        -:  521:    // Compute the reshaped strides and sizes from the base strides and sizes.
    #####:  522:    SmallVector<OpFoldResult> origSizes =
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  523:        getAsOpFoldResult(newExtractStridedMetadata.getSizes());
    #####:  524:    SmallVector<OpFoldResult> origStrides =
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  525:        getAsOpFoldResult(newExtractStridedMetadata.getStrides());
    #####:  526:    unsigned idx = 0, endIdx = reshape.getReassociationIndices().size();
call    0 never executed
call    1 never executed
    #####:  527:    for (; idx != endIdx; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  528:      SmallVector<OpFoldResult> reshapedSizes =
call    0 never executed
call    1 never executed
        -:  529:          getReshapedSizes(reshape, rewriter, origSizes, /*groupId=*/idx);
    #####:  530:      SmallVector<OpFoldResult> reshapedStrides = getReshapedStrides(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  531:          reshape, rewriter, origSizes, origStrides, /*groupId=*/idx);
        -:  532:
    #####:  533:      unsigned groupSize = reshapedSizes.size();
    #####:  534:      const unsigned sizeStartIdx = baseIdxInResult;
    #####:  535:      const unsigned strideStartIdx = sizeStartIdx + reshapeRank;
    #####:  536:      for (unsigned i = 0; i < groupSize; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  537:        results[sizeStartIdx + i] = reshapedSizes[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  538:        results[strideStartIdx + i] = reshapedStrides[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  539:      }
    #####:  540:      baseIdxInResult += groupSize;
branch  0 never executed
branch  1 never executed
        -:  541:    }
    #####:  542:    assert(((isa<memref::ExpandShapeOp>(reshape) && idx == sourceRank) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  543:            (isa<memref::CollapseShapeOp>(reshape) && idx == reshapeRank)) &&
        -:  544:           "We should have visited all the input dimensions");
    #####:  545:    assert(baseIdxInResult == reshapeRank + 2 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  546:           "We should have populated all the values");
    #####:  547:    rewriter.replaceOp(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  548:        op, getValueOrCreateConstantIndexOp(rewriter, origLoc, results));
    #####:  549:    return success();
branch  0 never executed
branch  1 never executed
        -:  550:  }
------------------
        -:  551:};
        -:  552:
        -:  553:/// Replace `base, offset, sizes, strides =
        -:  554:///              extract_strided_metadata(allocLikeOp)`
        -:  555:///
        -:  556:/// With
        -:  557:///
        -:  558:/// ```
        -:  559:/// base = reinterpret_cast allocLikeOp(allocSizes) to a flat memref<eltTy>
        -:  560:/// offset = 0
        -:  561:/// sizes = allocSizes
        -:  562:/// strides#i = prod(allocSizes#j, for j in {i+1..rank-1})
        -:  563:/// ```
        -:  564:///
        -:  565:/// The transformation only applies if the allocLikeOp has been normalized.
        -:  566:/// In other words, the affine_map must be an identity.
        -:  567:template <typename AllocLikeOp>
        -:  568:struct ExtractStridedMetadataOpAllocFolder
        -:  569:    : public OpRewritePattern<memref::ExtractStridedMetadataOp> {
        -:  570:public:
        -:  571:  using OpRewritePattern<memref::ExtractStridedMetadataOp>::OpRewritePattern;
        -:  572:
    #####:  573:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  574:                                PatternRewriter &rewriter) const override {
    #####:  575:    auto allocLikeOp = op.getSource().getDefiningOp<AllocLikeOp>();
    #####:  576:    if (!allocLikeOp)
    #####:  577:      return failure();
        -:  578:
    #####:  579:    auto memRefType =
    #####:  580:        allocLikeOp.getResult().getType().template cast<MemRefType>();
    #####:  581:    if (!memRefType.getLayout().isIdentity())
        -:  582:      return rewriter.notifyMatchFailure(
    #####:  583:          allocLikeOp, "alloc-like operations should have been normalized");
        -:  584:
    #####:  585:    Location loc = op.getLoc();
    #####:  586:    int rank = memRefType.getRank();
        -:  587:
        -:  588:    // Collect the sizes.
    #####:  589:    ValueRange dynamic = allocLikeOp.getDynamicSizes();
    #####:  590:    SmallVector<OpFoldResult> sizes;
    #####:  591:    sizes.reserve(rank);
    #####:  592:    unsigned dynamicPos = 0;
    #####:  593:    for (int64_t size : memRefType.getShape()) {
    #####:  594:      if (ShapedType::isDynamic(size))
    #####:  595:        sizes.push_back(dynamic[dynamicPos++]);
        -:  596:      else
    #####:  597:        sizes.push_back(rewriter.getIndexAttr(size));
        -:  598:    }
        -:  599:
        -:  600:    // Strides (just creates identity strides).
    #####:  601:    SmallVector<OpFoldResult> strides(rank, rewriter.getIndexAttr(1));
    #####:  602:    AffineExpr expr = rewriter.getAffineConstantExpr(1);
    #####:  603:    unsigned symbolNumber = 0;
    #####:  604:    for (int i = rank - 2; i >= 0; --i) {
    #####:  605:      expr = expr * rewriter.getAffineSymbolExpr(symbolNumber++);
    #####:  606:      assert(i + 1 + symbolNumber == sizes.size() &&
        -:  607:             "The ArrayRef should encompass the last #symbolNumber sizes");
    #####:  608:      ArrayRef<OpFoldResult> sizesInvolvedInStride(&sizes[i + 1], symbolNumber);
    #####:  609:      strides[i] = makeComposedFoldedAffineApply(rewriter, loc, expr,
        -:  610:                                                 sizesInvolvedInStride);
        -:  611:    }
        -:  612:
        -:  613:    // Put all the values together to replace the results.
    #####:  614:    SmallVector<Value> results;
    #####:  615:    results.reserve(rank * 2 + 2);
        -:  616:
    #####:  617:    auto baseBufferType = op.getBaseBuffer().getType().cast<MemRefType>();
    #####:  618:    int64_t offset = 0;
    #####:  619:    if (allocLikeOp.getType() == baseBufferType)
    #####:  620:      results.push_back(allocLikeOp);
        -:  621:    else
    #####:  622:      results.push_back(rewriter.create<memref::ReinterpretCastOp>(
        -:  623:          loc, baseBufferType, allocLikeOp, offset,
        -:  624:          /*sizes=*/ArrayRef<int64_t>(),
        -:  625:          /*strides=*/ArrayRef<int64_t>()));
        -:  626:
        -:  627:    // Offset.
    #####:  628:    results.push_back(rewriter.create<arith::ConstantIndexOp>(loc, offset));
        -:  629:
    #####:  630:    for (OpFoldResult size : sizes)
    #####:  631:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, size));
        -:  632:
    #####:  633:    for (OpFoldResult stride : strides)
    #####:  634:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, stride));
        -:  635:
    #####:  636:    rewriter.replaceOp(op, results);
    #####:  637:    return success();
        -:  638:  }
------------------
_ZNK12_GLOBAL__N_135ExtractStridedMetadataOpAllocFolderIN4mlir6memref7AllocOpEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_135ExtractStridedMetadataOpAllocFolderIN4mlir6memref7AllocOpEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  573:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  574:                                PatternRewriter &rewriter) const override {
    #####:  575:    auto allocLikeOp = op.getSource().getDefiningOp<AllocLikeOp>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  576:    if (!allocLikeOp)
branch  0 never executed
branch  1 never executed
    #####:  577:      return failure();
        -:  578:
    #####:  579:    auto memRefType =
    #####:  580:        allocLikeOp.getResult().getType().template cast<MemRefType>();
call    0 never executed
    #####:  581:    if (!memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  582:      return rewriter.notifyMatchFailure(
    #####:  583:          allocLikeOp, "alloc-like operations should have been normalized");
call    0 never executed
        -:  584:
    #####:  585:    Location loc = op.getLoc();
call    0 never executed
    #####:  586:    int rank = memRefType.getRank();
call    0 never executed
        -:  587:
        -:  588:    // Collect the sizes.
    #####:  589:    ValueRange dynamic = allocLikeOp.getDynamicSizes();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  590:    SmallVector<OpFoldResult> sizes;
    #####:  591:    sizes.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  592:    unsigned dynamicPos = 0;
    #####:  593:    for (int64_t size : memRefType.getShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  594:      if (ShapedType::isDynamic(size))
branch  0 never executed
branch  1 never executed
    #####:  595:        sizes.push_back(dynamic[dynamicPos++]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  596:      else
    #####:  597:        sizes.push_back(rewriter.getIndexAttr(size));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  598:    }
        -:  599:
        -:  600:    // Strides (just creates identity strides).
    #####:  601:    SmallVector<OpFoldResult> strides(rank, rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  602:    AffineExpr expr = rewriter.getAffineConstantExpr(1);
call    0 never executed
    #####:  603:    unsigned symbolNumber = 0;
    #####:  604:    for (int i = rank - 2; i >= 0; --i) {
branch  0 never executed
branch  1 never executed
    #####:  605:      expr = expr * rewriter.getAffineSymbolExpr(symbolNumber++);
call    0 never executed
call    1 never executed
    #####:  606:      assert(i + 1 + symbolNumber == sizes.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  607:             "The ArrayRef should encompass the last #symbolNumber sizes");
    #####:  608:      ArrayRef<OpFoldResult> sizesInvolvedInStride(&sizes[i + 1], symbolNumber);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  609:      strides[i] = makeComposedFoldedAffineApply(rewriter, loc, expr,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  610:                                                 sizesInvolvedInStride);
        -:  611:    }
        -:  612:
        -:  613:    // Put all the values together to replace the results.
    #####:  614:    SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
    #####:  615:    results.reserve(rank * 2 + 2);
branch  0 never executed
branch  1 never executed
        -:  616:
    #####:  617:    auto baseBufferType = op.getBaseBuffer().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  618:    int64_t offset = 0;
call    0 never executed
    #####:  619:    if (allocLikeOp.getType() == baseBufferType)
branch  0 never executed
branch  1 never executed
    #####:  620:      results.push_back(allocLikeOp);
call    0 never executed
        -:  621:    else
    #####:  622:      results.push_back(rewriter.create<memref::ReinterpretCastOp>(
call    0 never executed
call    1 never executed
        -:  623:          loc, baseBufferType, allocLikeOp, offset,
        -:  624:          /*sizes=*/ArrayRef<int64_t>(),
        -:  625:          /*strides=*/ArrayRef<int64_t>()));
        -:  626:
        -:  627:    // Offset.
    #####:  628:    results.push_back(rewriter.create<arith::ConstantIndexOp>(loc, offset));
call    0 never executed
call    1 never executed
        -:  629:
    #####:  630:    for (OpFoldResult size : sizes)
branch  0 never executed
branch  1 never executed
    #####:  631:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, size));
call    0 never executed
call    1 never executed
        -:  632:
    #####:  633:    for (OpFoldResult stride : strides)
branch  0 never executed
branch  1 never executed
    #####:  634:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, stride));
call    0 never executed
call    1 never executed
        -:  635:
    #####:  636:    rewriter.replaceOp(op, results);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  637:    return success();
branch  0 never executed
branch  1 never executed
        -:  638:  }
------------------
_ZNK12_GLOBAL__N_135ExtractStridedMetadataOpAllocFolderIN4mlir6memref8AllocaOpEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_135ExtractStridedMetadataOpAllocFolderIN4mlir6memref8AllocaOpEE15matchAndRewriteENS2_24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  573:  LogicalResult matchAndRewrite(memref::ExtractStridedMetadataOp op,
        -:  574:                                PatternRewriter &rewriter) const override {
    #####:  575:    auto allocLikeOp = op.getSource().getDefiningOp<AllocLikeOp>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  576:    if (!allocLikeOp)
branch  0 never executed
branch  1 never executed
    #####:  577:      return failure();
        -:  578:
    #####:  579:    auto memRefType =
    #####:  580:        allocLikeOp.getResult().getType().template cast<MemRefType>();
call    0 never executed
    #####:  581:    if (!memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  582:      return rewriter.notifyMatchFailure(
    #####:  583:          allocLikeOp, "alloc-like operations should have been normalized");
call    0 never executed
        -:  584:
    #####:  585:    Location loc = op.getLoc();
call    0 never executed
    #####:  586:    int rank = memRefType.getRank();
call    0 never executed
        -:  587:
        -:  588:    // Collect the sizes.
    #####:  589:    ValueRange dynamic = allocLikeOp.getDynamicSizes();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  590:    SmallVector<OpFoldResult> sizes;
    #####:  591:    sizes.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  592:    unsigned dynamicPos = 0;
    #####:  593:    for (int64_t size : memRefType.getShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  594:      if (ShapedType::isDynamic(size))
branch  0 never executed
branch  1 never executed
    #####:  595:        sizes.push_back(dynamic[dynamicPos++]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  596:      else
    #####:  597:        sizes.push_back(rewriter.getIndexAttr(size));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  598:    }
        -:  599:
        -:  600:    // Strides (just creates identity strides).
    #####:  601:    SmallVector<OpFoldResult> strides(rank, rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  602:    AffineExpr expr = rewriter.getAffineConstantExpr(1);
call    0 never executed
    #####:  603:    unsigned symbolNumber = 0;
    #####:  604:    for (int i = rank - 2; i >= 0; --i) {
branch  0 never executed
branch  1 never executed
    #####:  605:      expr = expr * rewriter.getAffineSymbolExpr(symbolNumber++);
call    0 never executed
call    1 never executed
    #####:  606:      assert(i + 1 + symbolNumber == sizes.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  607:             "The ArrayRef should encompass the last #symbolNumber sizes");
    #####:  608:      ArrayRef<OpFoldResult> sizesInvolvedInStride(&sizes[i + 1], symbolNumber);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  609:      strides[i] = makeComposedFoldedAffineApply(rewriter, loc, expr,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  610:                                                 sizesInvolvedInStride);
        -:  611:    }
        -:  612:
        -:  613:    // Put all the values together to replace the results.
    #####:  614:    SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
    #####:  615:    results.reserve(rank * 2 + 2);
branch  0 never executed
branch  1 never executed
        -:  616:
    #####:  617:    auto baseBufferType = op.getBaseBuffer().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  618:    int64_t offset = 0;
call    0 never executed
    #####:  619:    if (allocLikeOp.getType() == baseBufferType)
branch  0 never executed
branch  1 never executed
    #####:  620:      results.push_back(allocLikeOp);
call    0 never executed
        -:  621:    else
    #####:  622:      results.push_back(rewriter.create<memref::ReinterpretCastOp>(
call    0 never executed
call    1 never executed
        -:  623:          loc, baseBufferType, allocLikeOp, offset,
        -:  624:          /*sizes=*/ArrayRef<int64_t>(),
        -:  625:          /*strides=*/ArrayRef<int64_t>()));
        -:  626:
        -:  627:    // Offset.
    #####:  628:    results.push_back(rewriter.create<arith::ConstantIndexOp>(loc, offset));
call    0 never executed
call    1 never executed
        -:  629:
    #####:  630:    for (OpFoldResult size : sizes)
branch  0 never executed
branch  1 never executed
    #####:  631:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, size));
call    0 never executed
call    1 never executed
        -:  632:
    #####:  633:    for (OpFoldResult stride : strides)
branch  0 never executed
branch  1 never executed
    #####:  634:      results.push_back(getValueOrCreateConstantIndexOp(rewriter, loc, stride));
call    0 never executed
call    1 never executed
        -:  635:
    #####:  636:    rewriter.replaceOp(op, results);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  637:    return success();
branch  0 never executed
branch  1 never executed
        -:  638:  }
------------------
        -:  639:};
        -:  640:
        -:  641:/// Rewrite memref.extract_aligned_pointer_as_index of a ViewLikeOp to the
        -:  642:/// source of the ViewLikeOp.
        -:  643:class RewriteExtractAlignedPointerAsIndexOfViewLikeOp
        -:  644:    : public OpRewritePattern<memref::ExtractAlignedPointerAsIndexOp> {
        -:  645:  using OpRewritePattern::OpRewritePattern;
        -:  646:
        -:  647:  LogicalResult
function _ZNK12_GLOBAL__N_147RewriteExtractAlignedPointerAsIndexOfViewLikeOp15matchAndRewriteEN4mlir6memref30ExtractAlignedPointerAsIndexOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  648:  matchAndRewrite(memref::ExtractAlignedPointerAsIndexOp extractOp,
        -:  649:                  PatternRewriter &rewriter) const override {
    #####:  650:    auto viewLikeOp =
    #####:  651:        extractOp.getSource().getDefiningOp<ViewLikeOpInterface>();
call    0 never executed
call    1 never executed
    #####:  652:    if (!viewLikeOp)
branch  0 never executed
branch  1 never executed
    #####:  653:      return rewriter.notifyMatchFailure(extractOp, "not a ViewLike source");
call    0 never executed
function _ZZNK12_GLOBAL__N_147RewriteExtractAlignedPointerAsIndexOfViewLikeOp15matchAndRewriteEN4mlir6memref30ExtractAlignedPointerAsIndexOpERNS1_15PatternRewriterEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  654:    rewriter.updateRootInPlace(extractOp, [&]() {
call    0 never executed
    #####:  655:      extractOp.getSourceMutable().assign(viewLikeOp.getViewSource());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  656:    });
    #####:  657:    return success();
        -:  658:  }
        -:  659:};
        -:  660:
        -:  661:/// Replace `base, offset =
        -:  662:///            extract_strided_metadata(extract_strided_metadata(src)#0)`
        -:  663:/// With
        -:  664:/// ```
        -:  665:/// base, ... = extract_strided_metadata(src)
        -:  666:/// offset = 0
        -:  667:/// ```
        -:  668:class ExtractStridedMetadataOpExtractStridedMetadataFolder
        -:  669:    : public OpRewritePattern<memref::ExtractStridedMetadataOp> {
        -:  670:  using OpRewritePattern::OpRewritePattern;
        -:  671:
        -:  672:  LogicalResult
function _ZNK12_GLOBAL__N_152ExtractStridedMetadataOpExtractStridedMetadataFolder15matchAndRewriteEN4mlir6memref24ExtractStridedMetadataOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  673:  matchAndRewrite(memref::ExtractStridedMetadataOp extractStridedMetadataOp,
        -:  674:                  PatternRewriter &rewriter) const override {
    #####:  675:    auto sourceExtractStridedMetadataOp =
    #####:  676:        extractStridedMetadataOp.getSource()
call    0 never executed
    #####:  677:            .getDefiningOp<memref::ExtractStridedMetadataOp>();
call    0 never executed
    #####:  678:    if (!sourceExtractStridedMetadataOp)
branch  0 never executed
branch  1 never executed
    #####:  679:      return failure();
    #####:  680:    Location loc = extractStridedMetadataOp.getLoc();
call    0 never executed
    #####:  681:    rewriter.replaceOp(extractStridedMetadataOp,
call    0 never executed
call    1 never executed
    #####:  682:                       {sourceExtractStridedMetadataOp.getBaseBuffer(),
        -:  683:                        getValueOrCreateConstantIndexOp(
    #####:  684:                            rewriter, loc, rewriter.getIndexAttr(0))});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  685:    return success();
        -:  686:  }
        -:  687:};
        -:  688:} // namespace
        -:  689:
function _ZN4mlir6memref48populateSimplifyExtractStridedMetadataOpPatternsERNS_17RewritePatternSetE called 0 returned 0% blocks executed 0%
    #####:  690:void memref::populateSimplifyExtractStridedMetadataOpPatterns(
        -:  691:    RewritePatternSet &patterns) {
    #####:  692:  patterns
        -:  693:      .add<ExtractStridedMetadataOpSubviewFolder,
        -:  694:           ExtractStridedMetadataOpReshapeFolder<
        -:  695:               memref::ExpandShapeOp, getExpandedSizes, getExpandedStrides>,
        -:  696:           ExtractStridedMetadataOpReshapeFolder<
        -:  697:               memref::CollapseShapeOp, getCollapsedSize, getCollapsedStride>,
        -:  698:           ExtractStridedMetadataOpAllocFolder<memref::AllocOp>,
        -:  699:           ExtractStridedMetadataOpAllocFolder<memref::AllocaOp>,
        -:  700:           RewriteExtractAlignedPointerAsIndexOfViewLikeOp,
        -:  701:           ExtractStridedMetadataOpExtractStridedMetadataFolder>(
    #####:  702:          patterns.getContext());
call    0 never executed
    #####:  703:}
        -:  704:
        -:  705://===----------------------------------------------------------------------===//
        -:  706:// Pass registration
        -:  707://===----------------------------------------------------------------------===//
        -:  708:
        -:  709:namespace {
        -:  710:
  116161*:  711:struct SimplifyExtractStridedMetadataPass final
call    0 never executed
call    1 returned 100%
        -:  712:    : public memref::impl::SimplifyExtractStridedMetadataBase<
        -:  713:          SimplifyExtractStridedMetadataPass> {
        -:  714:  void runOnOperation() override;
        -:  715:};
        -:  716:
        -:  717:} // namespace
        -:  718:
function _ZN12_GLOBAL__N_134SimplifyExtractStridedMetadataPass14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  719:void SimplifyExtractStridedMetadataPass::runOnOperation() {
    #####:  720:  RewritePatternSet patterns(&getContext());
call    0 never executed
call    1 never executed
    #####:  721:  memref::populateSimplifyExtractStridedMetadataOpPatterns(patterns);
call    0 never executed
    #####:  722:  (void)applyPatternsAndFoldGreedily(getOperation()->getRegions(),
    #####:  723:                                     std::move(patterns));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  724:}
        -:  725:
function _ZN4mlir6memref40createSimplifyExtractStridedMetadataPassEv called 116161 returned 100% blocks executed 100%
   116161:  726:std::unique_ptr<Pass> memref::createSimplifyExtractStridedMetadataPass() {
   116161:  727:  return std::make_unique<SimplifyExtractStridedMetadataPass>();
call    0 returned 100%
        -:  728:}
