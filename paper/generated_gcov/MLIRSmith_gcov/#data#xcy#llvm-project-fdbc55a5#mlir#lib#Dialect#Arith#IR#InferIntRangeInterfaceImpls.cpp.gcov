        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/Arith/IR/InferIntRangeInterfaceImpls.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/InferIntRangeInterfaceImpls.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/InferIntRangeInterfaceImpls.cpp.gcda
        -:    0:Runs:116157
        -:    1://===- InferIntRangeInterfaceImpls.cpp - Integer range impls for arith -===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   10:#include "mlir/Interfaces/InferIntRangeInterface.h"
        -:   11:
        -:   12:#include "llvm/Support/Debug.h"
        -:   13:
        -:   14:#define DEBUG_TYPE "int-range-analysis"
        -:   15:
        -:   16:using namespace mlir;
        -:   17:using namespace mlir::arith;
        -:   18:
        -:   19:/// Function that evaluates the result of doing something on arithmetic
        -:   20:/// constants and returns None on overflow.
        -:   21:using ConstArithFn =
        -:   22:    function_ref<Optional<APInt>(const APInt &, const APInt &)>;
        -:   23:
        -:   24:/// Return the maxmially wide signed or unsigned range for a given bitwidth.
        -:   25:
        -:   26:/// Compute op(minLeft, minRight) and op(maxLeft, maxRight) if possible,
        -:   27:/// If either computation overflows, make the result unbounded.
function _ZL15computeBoundsByN4llvm12function_refIFNS_8OptionalINS_5APIntEEERKS2_S5_EEES5_S5_S5_S5_b called 9040 returned 100% blocks executed 100%
     9040:   28:static ConstantIntRanges computeBoundsBy(ConstArithFn op, const APInt &minLeft,
        -:   29:                                         const APInt &minRight,
        -:   30:                                         const APInt &maxLeft,
        -:   31:                                         const APInt &maxRight, bool isSigned) {
     9040:   32:  Optional<APInt> maybeMin = op(minLeft, minRight);
call    0 returned 100%
    18080:   33:  Optional<APInt> maybeMax = op(maxLeft, maxRight);
call    0 returned 100%
call    1 returned 100%
     9040:   34:  if (maybeMin && maybeMax)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
     6594:   35:    return ConstantIntRanges::range(*maybeMin, *maybeMax, isSigned);
call    0 returned 100%
     2446:   36:  return ConstantIntRanges::maxRange(minLeft.getBitWidth());
call    0 returned 100%
        -:   37:}
        -:   38:
        -:   39:/// Compute the minimum and maximum of `(op(l, r) for l in lhs for r in rhs)`,
        -:   40:/// ignoring unbounded values. Returns the maximal range if `op` overflows.
function _ZL8minMaxByN4llvm12function_refIFNS_8OptionalINS_5APIntEEERKS2_S5_EEENS_8ArrayRefIS2_EES9_b called 26663 returned 100% blocks executed 79%
    26663:   41:static ConstantIntRanges minMaxBy(ConstArithFn op, ArrayRef<APInt> lhs,
        -:   42:                                  ArrayRef<APInt> rhs, bool isSigned) {
    26663:   43:  unsigned width = lhs[0].getBitWidth();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 45% (fallthrough)
branch  3 taken 55%
    26663:   44:  APInt min =
    26663:   45:      isSigned ? APInt::getSignedMaxValue(width) : APInt::getMaxValue(width);
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
    26663:   46:  APInt max =
    53326:   47:      isSigned ? APInt::getSignedMinValue(width) : APInt::getZero(width);
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    59579:   48:  for (const APInt &left : lhs) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
   110652:   49:    for (const APInt &right : rhs) {
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
   145130:   50:      Optional<APInt> maybeThisResult = op(left, right);
call    0 returned 100%
    77736:   51:      if (!maybeThisResult)
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
    10342:   52:        return ConstantIntRanges::maxRange(width);
call    0 returned 100%
call    1 returned 100%
   134788:   53:      APInt result = std::move(*maybeThisResult);
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
call    2 returned 100%
    67394:   54:      min = (isSigned ? result.slt(min) : result.ult(min)) ? result : min;
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
branch  2 taken 76% (fallthrough)
branch  3 taken 24%
   134788:   55:      max = (isSigned ? result.sgt(max) : result.ugt(max)) ? result : max;
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:   56:    }
        -:   57:  }
    16321:   58:  return ConstantIntRanges::range(min, max, isSigned);
call    0 returned 100%
        -:   59:}
        -:   60:
        -:   61://===----------------------------------------------------------------------===//
        -:   62:// ConstantOp
        -:   63://===----------------------------------------------------------------------===//
        -:   64:
function _ZN4mlir5arith10ConstantOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 14735 returned 100% blocks executed 87%
    14735:   65:void arith::ConstantOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:   66:                                          SetIntRangeFn setResultRange) {
    14735:   67:  auto constAttr = getValue().dyn_cast_or_null<IntegerAttr>();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    14735:   68:  if (constAttr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    29470:   69:    const APInt &value = constAttr.getValue();
call    0 returned 100%
    14735:   70:    setResultRange(getResult(), ConstantIntRanges::constant(value));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:   71:  }
    14735:   72:}
        -:   73:
        -:   74://===----------------------------------------------------------------------===//
        -:   75:// AddIOp
        -:   76://===----------------------------------------------------------------------===//
        -:   77:
function _ZN4mlir5arith6AddIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2253 returned 100% blocks executed 90%
     2253:   78:void arith::AddIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:   79:                                      SetIntRangeFn setResultRange) {
     2253:   80:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
function _ZZN4mlir5arith6AddIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 4506 returned 100% blocks executed 75%
     4506:   81:  ConstArithFn uadd = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     4506:   82:    bool overflowed = false;
     4506:   83:    APInt result = a.uadd_ov(b, overflowed);
call    0 returned 100%
     8004:   84:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2253:   85:  };
call    0 returned 100%
function _ZZN4mlir5arith6AddIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E0_clESE_SE_.isra.0 called 4506 returned 100% blocks executed 75%
     4506:   86:  ConstArithFn sadd = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     4506:   87:    bool overflowed = false;
     4506:   88:    APInt result = a.sadd_ov(b, overflowed);
call    0 returned 100%
     8063:   89:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2253:   90:  };
        -:   91:
     2253:   92:  ConstantIntRanges urange = computeBoundsBy(
     4506:   93:      uadd, lhs.umin(), rhs.umin(), lhs.umax(), rhs.umax(), /*isSigned=*/false);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
     2253:   94:  ConstantIntRanges srange = computeBoundsBy(
     2253:   95:      sadd, lhs.smin(), rhs.smin(), lhs.smax(), rhs.smax(), /*isSigned=*/true);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2253:   96:  setResultRange(getResult(), urange.intersection(srange));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2253:   97:}
        -:   98:
        -:   99://===----------------------------------------------------------------------===//
        -:  100:// SubIOp
        -:  101://===----------------------------------------------------------------------===//
        -:  102:
function _ZN4mlir5arith6SubIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2267 returned 100% blocks executed 90%
     2267:  103:void arith::SubIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  104:                                      SetIntRangeFn setResultRange) {
     2267:  105:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  106:
function _ZZN4mlir5arith6SubIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 4534 returned 100% blocks executed 75%
     4534:  107:  ConstArithFn usub = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     4534:  108:    bool overflowed = false;
     4534:  109:    APInt result = a.usub_ov(b, overflowed);
call    0 returned 100%
     7888:  110:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2267:  111:  };
call    0 returned 100%
function _ZZN4mlir5arith6SubIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E0_clESE_SE_.isra.0 called 4534 returned 100% blocks executed 75%
     4534:  112:  ConstArithFn ssub = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     4534:  113:    bool overflowed = false;
     4534:  114:    APInt result = a.ssub_ov(b, overflowed);
call    0 returned 100%
     8511:  115:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2267:  116:  };
     2267:  117:  ConstantIntRanges urange = computeBoundsBy(
     4534:  118:      usub, lhs.umin(), rhs.umax(), lhs.umax(), rhs.umin(), /*isSigned=*/false);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
     2267:  119:  ConstantIntRanges srange = computeBoundsBy(
     2267:  120:      ssub, lhs.smin(), rhs.smax(), lhs.smax(), rhs.smin(), /*isSigned=*/true);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2267:  121:  setResultRange(getResult(), urange.intersection(srange));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2267:  122:}
        -:  123:
        -:  124://===----------------------------------------------------------------------===//
        -:  125:// MulIOp
        -:  126://===----------------------------------------------------------------------===//
        -:  127:
function _ZN4mlir5arith6MulIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2194 returned 100% blocks executed 74%
     2194:  128:void arith::MulIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  129:                                      SetIntRangeFn setResultRange) {
     2194:  130:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  131:
function _ZZN4mlir5arith6MulIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 6785 returned 100% blocks executed 75%
     6785:  132:  ConstArithFn umul = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     6785:  133:    bool overflowed = false;
     6785:  134:    APInt result = a.umul_ov(b, overflowed);
call    0 returned 100%
    12685:  135:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2194:  136:  };
call    0 returned 100%
function _ZZN4mlir5arith6MulIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E0_clESE_SE_.isra.0 called 5380 returned 100% blocks executed 75%
     5380:  137:  ConstArithFn smul = [](const APInt &a, const APInt &b) -> Optional<APInt> {
     5380:  138:    bool overflowed = false;
     5380:  139:    APInt result = a.smul_ov(b, overflowed);
call    0 returned 100%
     9628:  140:    return overflowed ? Optional<APInt>() : result;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2194:  141:  };
        -:  142:
     2194:  143:  ConstantIntRanges urange =
        -:  144:      minMaxBy(umul, {lhs.umin(), lhs.umax()}, {rhs.umin(), rhs.umax()},
    21940:  145:               /*isSigned=*/false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
branch 15 taken 67% (fallthrough)
branch 16 taken 33%
call   17 returned 100%
     2194:  146:  ConstantIntRanges srange =
        -:  147:      minMaxBy(smul, {lhs.smin(), lhs.smax()}, {rhs.smin(), rhs.smax()},
    19746:  148:               /*isSigned=*/true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
branch 15 taken 67% (fallthrough)
branch 16 taken 33%
        -:  149:
     2194:  150:  setResultRange(getResult(), urange.intersection(srange));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2194:  151:}
        -:  152:
        -:  153://===----------------------------------------------------------------------===//
        -:  154:// DivUIOp
        -:  155://===----------------------------------------------------------------------===//
        -:  156:
        -:  157:/// Fix up division results (ex. for ceiling and floor), returning an APInt
        -:  158:/// if there has been no overflow
        -:  159:using DivisionFixupFn = function_ref<Optional<APInt>(
        -:  160:    const APInt &lhs, const APInt &rhs, const APInt &result)>;
        -:  161:
function _ZL15inferDivUIRangeRKN4mlir17ConstantIntRangesES2_N4llvm12function_refIFNS3_8OptionalINS3_5APIntEEERKS6_S9_S9_EEE called 1899 returned 100% blocks executed 75%
     1899:  162:static ConstantIntRanges inferDivUIRange(const ConstantIntRanges &lhs,
        -:  163:                                         const ConstantIntRanges &rhs,
        -:  164:                                         DivisionFixupFn fixup) {
     1899:  165:  const APInt &lhsMin = lhs.umin(), &lhsMax = lhs.umax(), &rhsMin = rhs.umin(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1899:  166:              &rhsMax = rhs.umax();
call    0 returned 100%
        -:  167:
     3798:  168:  if (!rhsMin.isZero()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 66% (fallthrough)
branch  3 taken 34%
function _ZZL15inferDivUIRangeRKN4mlir17ConstantIntRangesES2_N4llvm12function_refIFNS3_8OptionalINS3_5APIntEEERKS6_S9_S9_EEEENKUlS9_S9_E_clES9_S9_.isra.0 called 4992 returned 100% blocks executed 71%
     4992:  169:    auto udiv = [&fixup](const APInt &a, const APInt &b) -> Optional<APInt> {
     4992:  170:      return fixup(a, b, a.udiv(b));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1248:  171:    };
     1248:  172:    return minMaxBy(udiv, {lhsMin, lhsMax}, {rhsMin, rhsMax},
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     9984:  173:                    /*isSigned=*/false);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 67% (fallthrough)
branch  8 taken 33%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
branch 11 taken 67% (fallthrough)
branch 12 taken 33%
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
        -:  174:  }
        -:  175:  // Otherwise, it's possible we might divide by 0.
      651:  176:  return ConstantIntRanges::maxRange(rhsMin.getBitWidth());
call    0 returned 100%
        -:  177:}
        -:  178:
function _ZN4mlir5arith7DivUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 1899 returned 100% blocks executed 86%
     1899:  179:void arith::DivUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  180:                                       SetIntRangeFn setResultRange) {
     1899:  181:  setResultRange(getResult(),
call    0 returned 100%
call    1 returned 100%
     3798:  182:                 inferDivUIRange(argRanges[0], argRanges[1],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
     4992:  183:                                 [](const APInt &lhs, const APInt &rhs,
     4992:  184:                                    const APInt &result) { return result; }));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1899:  185:}
        -:  186:
        -:  187://===----------------------------------------------------------------------===//
        -:  188:// DivSIOp
        -:  189://===----------------------------------------------------------------------===//
        -:  190:
function _ZL15inferDivSIRangeRKN4mlir17ConstantIntRangesES2_N4llvm12function_refIFNS3_8OptionalINS3_5APIntEEERKS6_S9_S9_EEE called 6734 returned 100% blocks executed 78%
     6734:  191:static ConstantIntRanges inferDivSIRange(const ConstantIntRanges &lhs,
        -:  192:                                         const ConstantIntRanges &rhs,
        -:  193:                                         DivisionFixupFn fixup) {
     6734:  194:  const APInt &lhsMin = lhs.smin(), &lhsMax = lhs.smax(), &rhsMin = rhs.smin(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     6734:  195:              &rhsMax = rhs.smax();
call    0 returned 100%
    10477:  196:  bool canDivide = rhsMin.isStrictlyPositive() || rhsMax.isNegative();
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
branch  3 taken 32% (fallthrough)
branch  4 taken 68%
        -:  197:
     6734:  198:  if (canDivide) {
function _ZZL15inferDivSIRangeRKN4mlir17ConstantIntRangesES2_N4llvm12function_refIFNS3_8OptionalINS3_5APIntEEERKS6_S9_S9_EEEENKUlS9_S9_E_clES9_S9_.isra.0 called 15687 returned 100% blocks executed 78%
    15687:  199:    auto sdiv = [&fixup](const APInt &a, const APInt &b) -> Optional<APInt> {
    15687:  200:      bool overflowed = false;
    15687:  201:      APInt result = a.sdiv_ov(b, overflowed);
call    0 returned 100%
    15687:  202:      return overflowed ? Optional<APInt>() : fixup(a, b, result);
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     4173:  203:    };
     4173:  204:    return minMaxBy(sdiv, {lhsMin, lhsMax}, {rhsMin, rhsMax},
branch  0 taken 100%
branch  1 taken 0%
    33384:  205:                    /*isSigned=*/true);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 67% (fallthrough)
branch  8 taken 33%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
branch 11 taken 67% (fallthrough)
branch 12 taken 33%
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
        -:  206:  }
     2561:  207:  return ConstantIntRanges::maxRange(rhsMin.getBitWidth());
call    0 returned 100%
        -:  208:}
        -:  209:
function _ZN4mlir5arith7DivSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2074 returned 100% blocks executed 86%
     2074:  210:void arith::DivSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  211:                                       SetIntRangeFn setResultRange) {
     2074:  212:  setResultRange(getResult(),
call    0 returned 100%
call    1 returned 100%
     4148:  213:                 inferDivSIRange(argRanges[0], argRanges[1],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
     4772:  214:                                 [](const APInt &lhs, const APInt &rhs,
     4772:  215:                                    const APInt &result) { return result; }));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2074:  216:}
        -:  217:
        -:  218://===----------------------------------------------------------------------===//
        -:  219:// CeilDivUIOp
        -:  220://===----------------------------------------------------------------------===//
        -:  221:
function _ZN4mlir5arith11CeilDivUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  222:void arith::CeilDivUIOp::inferResultRanges(
        -:  223:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRange) {
    #####:  224:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  225:
function _ZZN4mlir5arith11CeilDivUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_SE_E_clESE_SE_SE_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  226:  DivisionFixupFn ceilDivUIFix = [](const APInt &lhs, const APInt &rhs,
        -:  227:                                    const APInt &result) -> Optional<APInt> {
    #####:  228:    if (!lhs.urem(rhs).isZero()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  229:      bool overflowed = false;
    #####:  230:      APInt corrected =
    #####:  231:          result.uadd_ov(APInt(result.getBitWidth(), 1), overflowed);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  232:      return overflowed ? Optional<APInt>() : corrected;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  233:    }
    #####:  234:    return result;
branch  0 never executed
branch  1 never executed
    #####:  235:  };
call    0 never executed
    #####:  236:  setResultRange(getResult(), inferDivUIRange(lhs, rhs, ceilDivUIFix));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  237:}
        -:  238:
        -:  239://===----------------------------------------------------------------------===//
        -:  240:// CeilDivSIOp
        -:  241://===----------------------------------------------------------------------===//
        -:  242:
function _ZN4mlir5arith11CeilDivSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2603 returned 100% blocks executed 78%
     2603:  243:void arith::CeilDivSIOp::inferResultRanges(
        -:  244:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRange) {
     2603:  245:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  246:
function _ZZN4mlir5arith11CeilDivSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_SE_E_clESE_SE_SE_.isra.0 called 5652 returned 100% blocks executed 69%
     8255:  247:  DivisionFixupFn ceilDivSIFix = [](const APInt &lhs, const APInt &rhs,
        -:  248:                                    const APInt &result) -> Optional<APInt> {
    19776:  249:    if (!lhs.srem(rhs).isZero() && lhs.isNonNegative() == rhs.isNonNegative()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
branch  6 taken 36% (fallthrough)
branch  7 taken 64%
branch  8 taken 32% (fallthrough)
branch  9 taken 68%
     1812:  250:      bool overflowed = false;
     1812:  251:      APInt corrected =
     5436:  252:          result.sadd_ov(APInt(result.getBitWidth(), 1), overflowed);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    3624*:  253:      return overflowed ? Optional<APInt>() : corrected;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  254:    }
     3840:  255:    return result;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2603:  256:  };
call    0 returned 100%
     2603:  257:  setResultRange(getResult(), inferDivSIRange(lhs, rhs, ceilDivSIFix));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2603:  258:}
        -:  259:
        -:  260://===----------------------------------------------------------------------===//
        -:  261:// FloorDivSIOp
        -:  262://===----------------------------------------------------------------------===//
        -:  263:
function _ZN4mlir5arith12FloorDivSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2057 returned 100% blocks executed 78%
     2057:  264:void arith::FloorDivSIOp::inferResultRanges(
        -:  265:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRange) {
     2057:  266:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  267:
function _ZZN4mlir5arith12FloorDivSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_SE_E_clESE_SE_SE_.isra.0 called 4928 returned 100% blocks executed 69%
     6985:  268:  DivisionFixupFn floorDivSIFix = [](const APInt &lhs, const APInt &rhs,
        -:  269:                                     const APInt &result) -> Optional<APInt> {
    17680:  270:    if (!lhs.srem(rhs).isZero() && lhs.isNonNegative() != rhs.isNonNegative()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 59% (fallthrough)
branch  4 taken 41%
call    5 returned 100%
branch  6 taken 82% (fallthrough)
branch  7 taken 18%
branch  8 taken 11% (fallthrough)
branch  9 taken 89%
      528:  271:      bool overflowed = false;
      528:  272:      APInt corrected =
     1584:  273:          result.ssub_ov(APInt(result.getBitWidth(), 1), overflowed);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    1056*:  274:      return overflowed ? Optional<APInt>() : corrected;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  275:    }
     4400:  276:    return result;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2057:  277:  };
call    0 returned 100%
     2057:  278:  setResultRange(getResult(), inferDivSIRange(lhs, rhs, floorDivSIFix));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2057:  279:}
        -:  280:
        -:  281://===----------------------------------------------------------------------===//
        -:  282:// RemUIOp
        -:  283://===----------------------------------------------------------------------===//
        -:  284:
function _ZN4mlir5arith7RemUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2617 returned 100% blocks executed 64%
     2617:  285:void arith::RemUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  286:                                       SetIntRangeFn setResultRange) {
     2617:  287:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2617:  288:  const APInt &rhsMin = rhs.umin(), &rhsMax = rhs.umax();
call    0 returned 100%
call    1 returned 100%
        -:  289:
     2617:  290:  unsigned width = rhsMin.getBitWidth();
call    0 returned 100%
     2617:  291:  APInt umin = APInt::getZero(width);
call    0 returned 100%
     5234:  292:  APInt umax = APInt::getMaxValue(width);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  293:
     5234:  294:  if (!rhsMin.isZero()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
     3710:  295:    umax = rhsMax - 1;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -:  296:    // Special case: sweeping out a contiguous range in N/[modulus]
     1855:  297:    if (rhsMin == rhsMax) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1855:  298:      const APInt &lhsMin = lhs.umin(), &lhsMax = lhs.umax();
call    0 returned 100%
call    1 returned 100%
     3710:  299:      if ((lhsMax - lhsMin).ult(rhsMax)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 92% (fallthrough)
branch  8 taken 8%
     3400:  300:        APInt minRem = lhsMin.urem(rhsMax);
call    0 returned 100%
     3400:  301:        APInt maxRem = lhsMax.urem(rhsMax);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1700:  302:        if (minRem.ule(maxRem)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1700:  303:          umin = minRem;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3400:  304:          umax = maxRem;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  305:        }
        -:  306:      }
        -:  307:    }
        -:  308:  }
     2617:  309:  setResultRange(getResult(), ConstantIntRanges::fromUnsigned(umin, umax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     2617:  310:}
        -:  311:
        -:  312://===----------------------------------------------------------------------===//
        -:  313:// RemSIOp
        -:  314://===----------------------------------------------------------------------===//
        -:  315:
function _ZN4mlir5arith7RemSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2116 returned 100% blocks executed 65%
     2116:  316:void arith::RemSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  317:                                       SetIntRangeFn setResultRange) {
     2116:  318:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     2116:  319:  const APInt &lhsMin = lhs.smin(), &lhsMax = lhs.smax(), &rhsMin = rhs.smin(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2116:  320:              &rhsMax = rhs.smax();
call    0 returned 100%
        -:  321:
     2116:  322:  unsigned width = rhsMax.getBitWidth();
call    0 returned 100%
     2116:  323:  APInt smin = APInt::getSignedMinValue(width);
call    0 returned 100%
     4232:  324:  APInt smax = APInt::getSignedMaxValue(width);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  325:  // No bounds if zero could be a divisor.
     3160:  326:  bool canBound = (rhsMin.isStrictlyPositive() || rhsMax.isNegative());
call    0 returned 100%
branch  1 taken 49% (fallthrough)
branch  2 taken 51%
branch  3 taken 37% (fallthrough)
branch  4 taken 63%
     1463:  327:  if (canBound) {
     2926:  328:    APInt maxDivisor = rhsMin.isStrictlyPositive() ? rhsMax : rhsMin.abs();
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
call    2 returned 100%
     1463:  329:    bool canNegativeDividend = lhsMin.isNegative();
call    0 returned 100%
     1463:  330:    bool canPositiveDividend = lhsMax.isStrictlyPositive();
call    0 returned 100%
     2926:  331:    APInt zero = APInt::getZero(maxDivisor.getBitWidth());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     4389:  332:    APInt maxPositiveResult = maxDivisor - 1;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     4389:  333:    APInt minNegativeResult = -maxPositiveResult;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     1463:  334:    smin = canNegativeDividend ? minNegativeResult : zero;
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
     1463:  335:    smax = canPositiveDividend ? maxPositiveResult : zero;
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  336:    // Special case: sweeping out a contiguous range in N/[modulus].
     1463:  337:    if (rhsMin == rhsMax) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
     2918:  338:      if ((lhsMax - lhsMin).ult(maxDivisor)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 82% (fallthrough)
branch  8 taken 18%
     2402:  339:        APInt minRem = lhsMin.srem(maxDivisor);
call    0 returned 100%
     2402:  340:        APInt maxRem = lhsMax.srem(maxDivisor);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1201:  341:        if (minRem.sle(maxRem)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1201:  342:          smin = minRem;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2402:  343:          smax = maxRem;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  344:        }
        -:  345:      }
        -:  346:    }
        -:  347:  }
     2116:  348:  setResultRange(getResult(), ConstantIntRanges::fromSigned(smin, smax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     2116:  349:}
        -:  350:
        -:  351://===----------------------------------------------------------------------===//
        -:  352:// AndIOp
        -:  353://===----------------------------------------------------------------------===//
        -:  354:
        -:  355:/// "Widen" bounds - if 0bvvvvv??? <= a <= 0bvvvvv???,
        -:  356:/// relax the bounds to 0bvvvvv000 <= a <= 0bvvvvv111, where vvvvv are the bits
        -:  357:/// that both bonuds have in common. This gives us a consertive approximation
        -:  358:/// for what values can be passed to bitwise operations.
        -:  359:static std::tuple<APInt, APInt>
function _ZL18widenBitwiseBoundsRKN4mlir17ConstantIntRangesE called 13812 returned 100% blocks executed 61%
    13812:  360:widenBitwiseBounds(const ConstantIntRanges &bound) {
    41436:  361:  APInt leftVal = bound.umin(), rightVal = bound.umax();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    13812:  362:  unsigned bitwidth = leftVal.getBitWidth();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    27624:  363:  unsigned differingBits = bitwidth - (leftVal ^ rightVal).countLeadingZeros();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    13812:  364:  leftVal.clearLowBits(differingBits);
call    0 returned 100%
    13812:  365:  rightVal.setLowBits(differingBits);
call    0 returned 100%
    13812:  366:  return std::make_tuple(std::move(leftVal), std::move(rightVal));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  367:}
        -:  368:
function _ZN4mlir5arith6AndIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2207 returned 100% blocks executed 73%
     2207:  369:void arith::AndIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  370:                                      SetIntRangeFn setResultRange) {
     2207:  371:  auto [lhsZeros, lhsOnes] = widenBitwiseBounds(argRanges[0]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     4414:  372:  auto [rhsZeros, rhsOnes] = widenBitwiseBounds(argRanges[1]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
function _ZZN4mlir5arith6AndIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 8828 returned 100% blocks executed 62%
    11035:  373:  auto andi = [](const APInt &a, const APInt &b) -> Optional<APInt> {
    17656:  374:    return a & b;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  375:  };
     4414:  376:  setResultRange(getResult(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
    24277:  377:                 minMaxBy(andi, {lhsZeros, lhsOnes}, {rhsZeros, rhsOnes},
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 returned 100%
    13242:  378:                          /*isSigned=*/false));
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     2207:  379:}
        -:  380:
        -:  381://===----------------------------------------------------------------------===//
        -:  382:// OrIOp
        -:  383://===----------------------------------------------------------------------===//
        -:  384:
function _ZN4mlir5arith5OrIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2723 returned 100% blocks executed 73%
     2723:  385:void arith::OrIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  386:                                     SetIntRangeFn setResultRange) {
     2723:  387:  auto [lhsZeros, lhsOnes] = widenBitwiseBounds(argRanges[0]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     5446:  388:  auto [rhsZeros, rhsOnes] = widenBitwiseBounds(argRanges[1]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
function _ZZN4mlir5arith5OrIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 10892 returned 100% blocks executed 62%
    13615:  389:  auto ori = [](const APInt &a, const APInt &b) -> Optional<APInt> {
    21784:  390:    return a | b;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  391:  };
     5446:  392:  setResultRange(getResult(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
    29953:  393:                 minMaxBy(ori, {lhsZeros, lhsOnes}, {rhsZeros, rhsOnes},
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 returned 100%
    16338:  394:                          /*isSigned=*/false));
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     2723:  395:}
        -:  396:
        -:  397://===----------------------------------------------------------------------===//
        -:  398:// XOrIOp
        -:  399://===----------------------------------------------------------------------===//
        -:  400:
function _ZN4mlir5arith6XOrIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 1976 returned 100% blocks executed 73%
     1976:  401:void arith::XOrIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  402:                                      SetIntRangeFn setResultRange) {
     1976:  403:  auto [lhsZeros, lhsOnes] = widenBitwiseBounds(argRanges[0]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     3952:  404:  auto [rhsZeros, rhsOnes] = widenBitwiseBounds(argRanges[1]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
function _ZZN4mlir5arith6XOrIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 7904 returned 100% blocks executed 62%
     9880:  405:  auto xori = [](const APInt &a, const APInt &b) -> Optional<APInt> {
    15808:  406:    return a ^ b;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  407:  };
     3952:  408:  setResultRange(getResult(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
    21736:  409:                 minMaxBy(xori, {lhsZeros, lhsOnes}, {rhsZeros, rhsOnes},
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
call   12 returned 100%
    11856:  410:                          /*isSigned=*/false));
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     1976:  411:}
        -:  412:
        -:  413://===----------------------------------------------------------------------===//
        -:  414:// MaxSIOp
        -:  415://===----------------------------------------------------------------------===//
        -:  416:
function _ZN4mlir5arith7MaxSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2563 returned 100% blocks executed 89%
     2563:  417:void arith::MaxSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  418:                                       SetIntRangeFn setResultRange) {
     2563:  419:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  420:
     2563:  421:  const APInt &smin = lhs.smin().sgt(rhs.smin()) ? lhs.smin() : rhs.smin();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 31% (fallthrough)
branch  3 taken 69%
call    4 returned 100%
call    5 returned 100%
     2563:  422:  const APInt &smax = lhs.smax().sgt(rhs.smax()) ? lhs.smax() : rhs.smax();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 35% (fallthrough)
branch  3 taken 65%
call    4 returned 100%
call    5 returned 100%
     2563:  423:  setResultRange(getResult(), ConstantIntRanges::fromSigned(smin, smax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2563:  424:}
        -:  425:
        -:  426://===----------------------------------------------------------------------===//
        -:  427:// MaxUIOp
        -:  428://===----------------------------------------------------------------------===//
        -:  429:
function _ZN4mlir5arith7MaxUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2512 returned 100% blocks executed 89%
     2512:  430:void arith::MaxUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  431:                                       SetIntRangeFn setResultRange) {
     2512:  432:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  433:
     2512:  434:  const APInt &umin = lhs.umin().ugt(rhs.umin()) ? lhs.umin() : rhs.umin();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 32% (fallthrough)
branch  3 taken 68%
call    4 returned 100%
call    5 returned 100%
     2512:  435:  const APInt &umax = lhs.umax().ugt(rhs.umax()) ? lhs.umax() : rhs.umax();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 28% (fallthrough)
branch  3 taken 72%
call    4 returned 100%
call    5 returned 100%
     2512:  436:  setResultRange(getResult(), ConstantIntRanges::fromUnsigned(umin, umax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2512:  437:}
        -:  438:
        -:  439://===----------------------------------------------------------------------===//
        -:  440:// MinSIOp
        -:  441://===----------------------------------------------------------------------===//
        -:  442:
function _ZN4mlir5arith7MinSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2288 returned 100% blocks executed 89%
     2288:  443:void arith::MinSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  444:                                       SetIntRangeFn setResultRange) {
     2288:  445:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  446:
     2288:  447:  const APInt &smin = lhs.smin().slt(rhs.smin()) ? lhs.smin() : rhs.smin();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
call    4 returned 100%
call    5 returned 100%
     2288:  448:  const APInt &smax = lhs.smax().slt(rhs.smax()) ? lhs.smax() : rhs.smax();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 31% (fallthrough)
branch  3 taken 69%
call    4 returned 100%
call    5 returned 100%
     2288:  449:  setResultRange(getResult(), ConstantIntRanges::fromSigned(smin, smax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     2288:  450:}
        -:  451:
        -:  452://===----------------------------------------------------------------------===//
        -:  453:// MinUIOp
        -:  454://===----------------------------------------------------------------------===//
        -:  455:
function _ZN4mlir5arith7MinUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 1742 returned 100% blocks executed 89%
     1742:  456:void arith::MinUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  457:                                       SetIntRangeFn setResultRange) {
     1742:  458:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  459:
     1742:  460:  const APInt &umin = lhs.umin().ult(rhs.umin()) ? lhs.umin() : rhs.umin();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 28% (fallthrough)
branch  3 taken 72%
call    4 returned 100%
call    5 returned 100%
     1742:  461:  const APInt &umax = lhs.umax().ult(rhs.umax()) ? lhs.umax() : rhs.umax();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
call    4 returned 100%
call    5 returned 100%
     1742:  462:  setResultRange(getResult(), ConstantIntRanges::fromUnsigned(umin, umax));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1742:  463:}
        -:  464:
        -:  465://===----------------------------------------------------------------------===//
        -:  466:// ExtUIOp
        -:  467://===----------------------------------------------------------------------===//
        -:  468:
function _ZL10extUIRangeRKN4mlir17ConstantIntRangesENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  469:static ConstantIntRanges extUIRange(const ConstantIntRanges &range,
        -:  470:                                    Type destType) {
    #####:  471:  unsigned destWidth = ConstantIntRanges::getStorageBitwidth(destType);
call    0 never executed
    #####:  472:  APInt smin = range.umin().zext(destWidth);
call    0 never executed
call    1 never executed
    #####:  473:  APInt smax = range.umax().zext(destWidth);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  474:  return ConstantIntRanges::fromSigned(smin, smax);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  475:}
        -:  476:
function _ZN4mlir5arith7ExtUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  477:void arith::ExtUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  478:                                       SetIntRangeFn setResultRange) {
    #####:  479:  Type destType = getResult().getType();
branch  0 never executed
branch  1 never executed
    #####:  480:  setResultRange(getResult(), extUIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  481:}
        -:  482:
        -:  483://===----------------------------------------------------------------------===//
        -:  484:// ExtSIOp
        -:  485://===----------------------------------------------------------------------===//
        -:  486:
function _ZL10extSIRangeRKN4mlir17ConstantIntRangesENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  487:static ConstantIntRanges extSIRange(const ConstantIntRanges &range,
        -:  488:                                    Type destType) {
    #####:  489:  unsigned destWidth = ConstantIntRanges::getStorageBitwidth(destType);
call    0 never executed
    #####:  490:  APInt smin = range.smin().sext(destWidth);
call    0 never executed
call    1 never executed
    #####:  491:  APInt smax = range.smax().sext(destWidth);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  492:  return ConstantIntRanges::fromSigned(smin, smax);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  493:}
        -:  494:
function _ZN4mlir5arith7ExtSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  495:void arith::ExtSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  496:                                       SetIntRangeFn setResultRange) {
    #####:  497:  Type destType = getResult().getType();
branch  0 never executed
branch  1 never executed
    #####:  498:  setResultRange(getResult(), extSIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  499:}
        -:  500:
        -:  501://===----------------------------------------------------------------------===//
        -:  502:// TruncIOp
        -:  503://===----------------------------------------------------------------------===//
        -:  504:
function _ZL11truncIRangeRKN4mlir17ConstantIntRangesENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  505:static ConstantIntRanges truncIRange(const ConstantIntRanges &range,
        -:  506:                                     Type destType) {
    #####:  507:  unsigned destWidth = ConstantIntRanges::getStorageBitwidth(destType);
call    0 never executed
        -:  508:  // If you truncate the first four bytes in [0xaaaabbbb, 0xccccbbbb],
        -:  509:  // the range of the resulting value is not contiguous ind includes 0.
        -:  510:  // Ex. If you truncate [256, 258] from i16 to i8, you validly get [0, 2],
        -:  511:  // but you can't truncate [255, 257] similarly.
    #####:  512:  bool hasUnsignedRollover =
    #####:  513:      range.umin().lshr(destWidth) != range.umax().lshr(destWidth);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  514:  APInt umin = hasUnsignedRollover ? APInt::getZero(destWidth)
    #####:  515:                                   : range.umin().trunc(destWidth);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  516:  APInt umax = hasUnsignedRollover ? APInt::getMaxValue(destWidth)
    #####:  517:                                   : range.umax().trunc(destWidth);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  518:
        -:  519:  // Signed post-truncation rollover will not occur when either:
        -:  520:  // - The high parts of the min and max, plus the sign bit, are the same
        -:  521:  // - The high halves + sign bit of the min and max are either all 1s or all 0s
        -:  522:  //  and you won't create a [positive, negative] range by truncating.
        -:  523:  // For example, you can truncate the ranges [256, 258]_i16 to [0, 2]_i8
        -:  524:  // but not [255, 257]_i16 to a range of i8s. You can also truncate
        -:  525:  // [-256, -256]_i16 to [-2, 0]_i8, but not [-257, -255]_i16.
        -:  526:  // You can also truncate [-130, 0]_i16 to i8 because -130_i16 (0xff7e)
        -:  527:  // will truncate to 0x7e, which is greater than 0
    #####:  528:  APInt sminHighPart = range.smin().ashr(destWidth - 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  529:  APInt smaxHighPart = range.smax().ashr(destWidth - 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  530:  bool hasSignedOverflow =
call    0 never executed
    #####:  531:      (sminHighPart != smaxHighPart) &&
    #####:  532:      !(sminHighPart.isAllOnes() &&
branch  0 never executed
branch  1 never executed
    #####:  533:        (smaxHighPart.isAllOnes() || smaxHighPart.isZero())) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  534:      !(sminHighPart.isZero() && smaxHighPart.isZero());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  535:  APInt smin = hasSignedOverflow ? APInt::getSignedMinValue(destWidth)
    #####:  536:                                 : range.smin().trunc(destWidth);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  537:  APInt smax = hasSignedOverflow ? APInt::getSignedMaxValue(destWidth)
    #####:  538:                                 : range.smax().trunc(destWidth);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  539:  return {umin, umax, smin, smax};
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  540:}
        -:  541:
function _ZN4mlir5arith8TruncIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  542:void arith::TruncIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  543:                                        SetIntRangeFn setResultRange) {
    #####:  544:  Type destType = getResult().getType();
branch  0 never executed
branch  1 never executed
    #####:  545:  setResultRange(getResult(), truncIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  546:}
        -:  547:
        -:  548://===----------------------------------------------------------------------===//
        -:  549:// IndexCastOp
        -:  550://===----------------------------------------------------------------------===//
        -:  551:
function _ZN4mlir5arith11IndexCastOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  552:void arith::IndexCastOp::inferResultRanges(
        -:  553:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRange) {
    #####:  554:  Type sourceType = getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  555:  Type destType = getResult().getType();
call    0 never executed
    #####:  556:  unsigned srcWidth = ConstantIntRanges::getStorageBitwidth(sourceType);
call    0 never executed
    #####:  557:  unsigned destWidth = ConstantIntRanges::getStorageBitwidth(destType);
call    0 never executed
        -:  558:
    #####:  559:  if (srcWidth < destWidth)
branch  0 never executed
branch  1 never executed
    #####:  560:    setResultRange(getResult(), extSIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  561:  else if (srcWidth > destWidth)
branch  0 never executed
branch  1 never executed
    #####:  562:    setResultRange(getResult(), truncIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  563:  else
    #####:  564:    setResultRange(getResult(), argRanges[0]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  565:}
        -:  566:
        -:  567://===----------------------------------------------------------------------===//
        -:  568:// IndexCastUIOp
        -:  569://===----------------------------------------------------------------------===//
        -:  570:
function _ZN4mlir5arith13IndexCastUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  571:void arith::IndexCastUIOp::inferResultRanges(
        -:  572:    ArrayRef<ConstantIntRanges> argRanges, SetIntRangeFn setResultRange) {
    #####:  573:  Type sourceType = getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  574:  Type destType = getResult().getType();
call    0 never executed
    #####:  575:  unsigned srcWidth = ConstantIntRanges::getStorageBitwidth(sourceType);
call    0 never executed
    #####:  576:  unsigned destWidth = ConstantIntRanges::getStorageBitwidth(destType);
call    0 never executed
        -:  577:
    #####:  578:  if (srcWidth < destWidth)
branch  0 never executed
branch  1 never executed
    #####:  579:    setResultRange(getResult(), extUIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  580:  else if (srcWidth > destWidth)
branch  0 never executed
branch  1 never executed
    #####:  581:    setResultRange(getResult(), truncIRange(argRanges[0], destType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  582:  else
    #####:  583:    setResultRange(getResult(), argRanges[0]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  584:}
        -:  585:
        -:  586://===----------------------------------------------------------------------===//
        -:  587:// CmpIOp
        -:  588://===----------------------------------------------------------------------===//
        -:  589:
function _Z16isStaticallyTrueN4mlir5arith13CmpIPredicateERKNS_17ConstantIntRangesES4_ called 5513 returned 100% blocks executed 100%
     5513:  590:bool isStaticallyTrue(arith::CmpIPredicate pred, const ConstantIntRanges &lhs,
        -:  591:                      const ConstantIntRanges &rhs) {
     5513:  592:  switch (pred) {
branch  0 taken 19%
branch  1 taken 22%
branch  2 taken 20%
branch  3 taken 23%
branch  4 taken 8%
branch  5 taken 7%
branch  6 taken 0%
     1062:  593:  case arith::CmpIPredicate::sle:
     1062:  594:  case arith::CmpIPredicate::slt:
     1062:  595:    return (applyCmpPredicate(pred, lhs.smax(), rhs.smin()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1236:  596:  case arith::CmpIPredicate::ule:
     1236:  597:  case arith::CmpIPredicate::ult:
     1236:  598:    return applyCmpPredicate(pred, lhs.umax(), rhs.umin());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1121:  599:  case arith::CmpIPredicate::sge:
     1121:  600:  case arith::CmpIPredicate::sgt:
     1121:  601:    return applyCmpPredicate(pred, lhs.smin(), rhs.smax());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1254:  602:  case arith::CmpIPredicate::uge:
     1254:  603:  case arith::CmpIPredicate::ugt:
     1254:  604:    return applyCmpPredicate(pred, lhs.umin(), rhs.umax());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      439:  605:  case arith::CmpIPredicate::eq: {
      878:  606:    Optional<APInt> lhsConst = lhs.getConstantValue();
call    0 returned 100%
      878:  607:    Optional<APInt> rhsConst = rhs.getConstantValue();
call    0 returned 100%
call    1 returned 100%
      764:  608:    return lhsConst && rhsConst && lhsConst == rhsConst;
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
branch  2 taken 89% (fallthrough)
branch  3 taken 11%
branch  4 taken 15% (fallthrough)
branch  5 taken 85%
call    6 returned 100%
        -:  609:  }
      401:  610:  case arith::CmpIPredicate::ne: {
        -:  611:    // While equality requires that there is an interpration of the preceeding
        -:  612:    // computations that produces equal constants, whether that be signed or
        -:  613:    // unsigned, statically determining inequality requires that neither
        -:  614:    // interpretation produce potentially overlapping ranges.
      762:  615:    bool sne = isStaticallyTrue(CmpIPredicate::slt, lhs, rhs) ||
call    0 returned 100%
branch  1 taken 90% (fallthrough)
branch  2 taken 10%
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
      361:  616:               isStaticallyTrue(CmpIPredicate::sgt, lhs, rhs);
call    0 returned 100%
      762:  617:    bool une = isStaticallyTrue(CmpIPredicate::ult, lhs, rhs) ||
call    0 returned 100%
branch  1 taken 90% (fallthrough)
branch  2 taken 10%
branch  3 taken 14% (fallthrough)
branch  4 taken 86%
      361:  618:               isStaticallyTrue(CmpIPredicate::ugt, lhs, rhs);
call    0 returned 100%
      401:  619:    return sne && une;
        -:  620:  }
        -:  621:  }
        -:  622:  return false;
        -:  623:}
        -:  624:
function _ZN4mlir5arith6CmpIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2471 returned 100% blocks executed 70%
     2471:  625:void arith::CmpIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  626:                                      SetIntRangeFn setResultRange) {
     2471:  627:  arith::CmpIPredicate pred = getPredicate();
call    0 returned 100%
     2471:  628:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  629:
     2471:  630:  APInt min = APInt::getZero(1);
call    0 returned 100%
     4942:  631:  APInt max = APInt::getAllOnesValue(1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2471:  632:  if (isStaticallyTrue(pred, lhs, rhs))
call    0 returned 100%
branch  1 taken 39% (fallthrough)
branch  2 taken 61%
      953:  633:    min = max;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1518:  634:  else if (isStaticallyTrue(invertPredicate(pred), lhs, rhs))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 51% (fallthrough)
branch  3 taken 49%
      772:  635:    max = min;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  636:
     2471:  637:  setResultRange(getResult(), ConstantIntRanges::fromUnsigned(min, max));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     2471:  638:}
        -:  639:
        -:  640://===----------------------------------------------------------------------===//
        -:  641:// SelectOp
        -:  642://===----------------------------------------------------------------------===//
        -:  643:
function _ZN4mlir5arith8SelectOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 0 returned 0% blocks executed 0%
    #####:  644:void arith::SelectOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  645:                                        SetIntRangeFn setResultRange) {
    #####:  646:  Optional<APInt> mbCondVal = argRanges[0].getConstantValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  647:
    #####:  648:  if (mbCondVal) {
branch  0 never executed
branch  1 never executed
    #####:  649:    if (mbCondVal->isZero())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  650:      setResultRange(getResult(), argRanges[2]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  651:    else
    #####:  652:      setResultRange(getResult(), argRanges[1]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  653:    return;
call    0 never executed
        -:  654:  }
    #####:  655:  setResultRange(getResult(), argRanges[1].rangeUnion(argRanges[2]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  656:}
        -:  657:
        -:  658://===----------------------------------------------------------------------===//
        -:  659:// ShLIOp
        -:  660://===----------------------------------------------------------------------===//
        -:  661:
function _ZN4mlir5arith6ShLIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2399 returned 100% blocks executed 74%
     2399:  662:void arith::ShLIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  663:                                      SetIntRangeFn setResultRange) {
     2399:  664:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
function _ZZN4mlir5arith6ShLIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 7714 returned 100% blocks executed 100%
    10113:  665:  ConstArithFn shl = [](const APInt &l, const APInt &r) -> Optional<APInt> {
     7714:  666:    return r.uge(r.getBitWidth()) ? Optional<APInt>() : l.shl(r);
call    0 returned 100%
branch  1 taken 53% (fallthrough)
branch  2 taken 47%
call    3 returned 100%
     2399:  667:  };
call    0 returned 100%
     2399:  668:  ConstantIntRanges urange =
        -:  669:      minMaxBy(shl, {lhs.umin(), lhs.umax()}, {rhs.umin(), rhs.umax()},
    23990:  670:               /*isSigned=*/false);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
branch 15 taken 67% (fallthrough)
branch 16 taken 33%
call   17 returned 100%
     2399:  671:  ConstantIntRanges srange =
        -:  672:      minMaxBy(shl, {lhs.smin(), lhs.smax()}, {rhs.umin(), rhs.umax()},
    21591:  673:               /*isSigned=*/true);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
branch 13 taken 67% (fallthrough)
branch 14 taken 33%
branch 15 taken 67% (fallthrough)
branch 16 taken 33%
     2399:  674:  setResultRange(getResult(), urange.intersection(srange));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     2399:  675:}
        -:  676:
        -:  677://===----------------------------------------------------------------------===//
        -:  678:// ShRUIOp
        -:  679://===----------------------------------------------------------------------===//
        -:  680:
function _ZN4mlir5arith7ShRUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 2037 returned 100% blocks executed 73%
     2037:  681:void arith::ShRUIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  682:                                       SetIntRangeFn setResultRange) {
     2037:  683:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  684:
function _ZZN4mlir5arith7ShRUIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 3888 returned 100% blocks executed 100%
     5925:  685:  ConstArithFn lshr = [](const APInt &l, const APInt &r) -> Optional<APInt> {
     3888:  686:    return r.uge(r.getBitWidth()) ? Optional<APInt>() : l.lshr(r);
call    0 returned 100%
branch  1 taken 39% (fallthrough)
branch  2 taken 61%
call    3 returned 100%
     2037:  687:  };
call    0 returned 100%
    20370:  688:  setResultRange(getResult(), minMaxBy(lshr, {lhs.umin(), lhs.umax()},
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
branch 18 taken 0% (fallthrough)
branch 19 taken 100%
        -:  689:                                       {rhs.umin(), rhs.umax()},
    12222:  690:                                       /*isSigned=*/false));
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     2037:  691:}
        -:  692:
        -:  693://===----------------------------------------------------------------------===//
        -:  694:// ShRSIOp
        -:  695://===----------------------------------------------------------------------===//
        -:  696:
function _ZN4mlir5arith7ShRSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEE called 3113 returned 100% blocks executed 73%
     3113:  697:void arith::ShRSIOp::inferResultRanges(ArrayRef<ConstantIntRanges> argRanges,
        -:  698:                                       SetIntRangeFn setResultRange) {
     3113:  699:  const ConstantIntRanges &lhs = argRanges[0], &rhs = argRanges[1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  700:
function _ZZN4mlir5arith7ShRSIOp17inferResultRangesEN4llvm8ArrayRefINS_17ConstantIntRangesEEENS2_12function_refIFvNS_5ValueERKS4_EEEENKUlRKNS2_5APIntESE_E_clESE_SE_.isra.0 called 5666 returned 100% blocks executed 100%
     8779:  701:  ConstArithFn ashr = [](const APInt &l, const APInt &r) -> Optional<APInt> {
     5666:  702:    return r.uge(r.getBitWidth()) ? Optional<APInt>() : l.ashr(r);
call    0 returned 100%
branch  1 taken 42% (fallthrough)
branch  2 taken 58%
call    3 returned 100%
     3113:  703:  };
call    0 returned 100%
        -:  704:
     3113:  705:  setResultRange(getResult(),
call    0 returned 100%
call    1 returned 100%
    34243:  706:                 minMaxBy(ashr, {lhs.smin(), lhs.smax()},
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
call    9 returned 100%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
call   12 returned 100%
call   13 returned 100%
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
branch 16 taken 0% (fallthrough)
branch 17 taken 100%
    18678:  707:                          {rhs.umin(), rhs.umax()}, /*isSigned=*/true));
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     3113:  708:}
