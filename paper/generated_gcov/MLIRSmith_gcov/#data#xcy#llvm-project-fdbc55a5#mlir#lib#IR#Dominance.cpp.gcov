        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/Dominance.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Dominance.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Dominance.cpp.gcda
        -:    0:Runs:116164
        -:    1://===- Dominance.cpp - Dominator analysis for CFGs ------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Implementation of dominance related classes and instantiations of extern
        -:   10:// templates.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/Dominance.h"
        -:   15:#include "mlir/IR/Operation.h"
        -:   16:#include "mlir/IR/RegionKindInterface.h"
        -:   17:#include "llvm/ADT/DenseMap.h"
        -:   18:#include "llvm/Support/GenericDomTreeConstruction.h"
        -:   19:
        -:   20:using namespace mlir;
        -:   21:using namespace mlir::detail;
        -:   22:
        -:   23:template class llvm::DominatorTreeBase<Block, /*IsPostDom=*/false>;
        -:   24:template class llvm::DominatorTreeBase<Block, /*IsPostDom=*/true>;
        -:   25:template class llvm::DomTreeNodeBase<Block>;
        -:   26:
        -:   27://===----------------------------------------------------------------------===//
        -:   28:// DominanceInfoBase
        -:   29://===----------------------------------------------------------------------===//
        -:   30:
        -:   31:template <bool IsPostDom>
  4054025:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
358790848:   33:  for (auto entry : dominanceInfos)
350683335:   34:    delete entry.second.getPointer();
  4053642:   35:}
------------------
_ZN4mlir6detail17DominanceInfoBaseILb0EED2Ev:
function _ZN4mlir6detail17DominanceInfoBaseILb0EED2Ev called 4038205 returned 100% blocks executed 100%
  4038205:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
358745649:   33:  for (auto entry : dominanceInfos)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
call    5 returned 100%
call    6 returned 100%
350669773:   34:    delete entry.second.getPointer();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
  4037825:   35:}
call    0 returned 100%
------------------
_ZN4mlir6detail17DominanceInfoBaseILb1EED2Ev:
function _ZN4mlir6detail17DominanceInfoBaseILb1EED2Ev called 15820 returned 100% blocks executed 100%
    15820:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
    45199:   33:  for (auto entry : dominanceInfos)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 46% (fallthrough)
branch  4 taken 54%
call    5 returned 100%
call    6 returned 100%
    13562:   34:    delete entry.second.getPointer();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
    15817:   35:}
call    0 returned 100%
------------------
        -:   36:
        -:   37:/// Return the dom tree and "hasSSADominance" bit for the given region.  The
        -:   38:/// DomTree will be null for single-block regions.  This lazily constructs the
        -:   39:/// DomTree on demand when needsDomTree=true.
        -:   40:template <bool IsPostDom>
22566696942:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
22566696942:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
22566697777:   46:  auto &entry = itAndInserted.first->second;
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
22566698447:   51:  if (!itAndInserted.second) {
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
22216015129*:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
    #####:   55:      auto *domTree = new DomTree();
    #####:   56:      domTree->recalculate(*region);
    #####:   57:      entry.setPointer(domTree);
        -:   58:    }
22216015129:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
350683318:   64:  if (!region->hasOneBlock()) {
     2994:   65:    auto *domTree = new DomTree();
     2992:   66:    domTree->recalculate(*region);
     2992:   67:    entry.setPointer(domTree);
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
     2992:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
350680324:   73:  if (Operation *parentOp = region->getParentOp()) {
350680324:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
350680301:   75:      entry.setInt(false);
350680324:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
350680301*:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
        -:   80:    }
        -:   81:  }
        -:   82:
350680301:   83:  return entry;
        -:   84:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE16getDominanceInfoEPNS_6RegionEb:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE16getDominanceInfoEPNS_6RegionEb called 22566653646 returned 100% blocks executed 77%
22566653646:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
22566653646:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
call    0 returned 100%
call    1 returned 100%
22566654481:   46:  auto &entry = itAndInserted.first->second;
call    0 returned 100%
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
22566655151:   51:  if (!itAndInserted.second) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
22215985395*:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   55:      auto *domTree = new DomTree();
call    0 never executed
call    1 never executed
    #####:   56:      domTree->recalculate(*region);
call    0 never executed
    #####:   57:      entry.setPointer(domTree);
call    0 never executed
        -:   58:    }
22215985395:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
350669756:   64:  if (!region->hasOneBlock()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     2988:   65:    auto *domTree = new DomTree();
call    0 returned 100%
call    1 returned 100%
     2986:   66:    domTree->recalculate(*region);
call    0 returned 100%
     2986:   67:    entry.setPointer(domTree);
call    0 returned 100%
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
     2986:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
350666768:   73:  if (Operation *parentOp = region->getParentOp()) {
branch  0 taken 100%
branch  1 taken 0%
350666768:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
350666745:   75:      entry.setInt(false);
350666768:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
350666745:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
call    0 returned 100%
call    1 returned 100%
        -:   80:    }
        -:   81:  }
        -:   82:
350666745:   83:  return entry;
        -:   84:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE16getDominanceInfoEPNS_6RegionEb:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE16getDominanceInfoEPNS_6RegionEb called 43296 returned 100% blocks executed 68%
    43296:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
    43296:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
call    0 returned 100%
call    1 returned 100%
    43296:   46:  auto &entry = itAndInserted.first->second;
call    0 returned 100%
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
    43296:   51:  if (!itAndInserted.second) {
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
   29734*:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   55:      auto *domTree = new DomTree();
call    0 never executed
call    1 never executed
    #####:   56:      domTree->recalculate(*region);
call    0 never executed
    #####:   57:      entry.setPointer(domTree);
call    0 never executed
        -:   58:    }
    29734:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
    13562:   64:  if (!region->hasOneBlock()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:   65:    auto *domTree = new DomTree();
call    0 returned 100%
call    1 returned 100%
        6:   66:    domTree->recalculate(*region);
call    0 returned 100%
        6:   67:    entry.setPointer(domTree);
call    0 returned 100%
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
        6:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
    13556:   73:  if (Operation *parentOp = region->getParentOp()) {
branch  0 taken 100%
branch  1 taken 0%
    13556:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    13556:   75:      entry.setInt(false);
    13556:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
   13556*:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
call    0 never executed
call    1 never executed
        -:   80:    }
        -:   81:  }
        -:   82:
    13556:   83:  return entry;
        -:   84:}
------------------
        -:   85:
        -:   86:/// Return the ancestor block enclosing the specified block.  This returns null
        -:   87:/// if we reach the top of the hierarchy.
  776934*:   88:static Block *getAncestorBlock(Block *block) {
  776934*:   89:  if (Operation *ancestorOp = block->getParentOp())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 never executed
branch  5 never executed
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
  776934*:   90:    return ancestorOp->getBlock();
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
        -:   91:  return nullptr;
        -:   92:}
        -:   93:
        -:   94:/// Walks up the list of containers of the given block and calls the
        -:   95:/// user-defined traversal function for every pair of a region and block that
        -:   96:/// could be found during traversal. If the user-defined function returns true
        -:   97:/// for a given pair, traverseAncestors will return the current block. Nullptr
        -:   98:/// otherwise.
        -:   99:template <typename FuncT>
   425343:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
   774823:  101:  do {
        -:  102:    // Invoke the user-defined traversal function for each block.
  1975998:  103:    if (func(block))
   213176:  104:      return block;
   774823:  105:  } while ((block = getAncestorBlock(block)));
        -:  106:  return nullptr;
        -:  107:}
------------------
_Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E0_ES2_S2_RKT_:
function _Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E0_ES2_S2_RKT_ called 211410 returned 100% blocks executed 100%
   211410:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
   348402:  101:  do {
call    0 returned 100%
        -:  102:    // Invoke the user-defined traversal function for each block.
  1118110:  103:    if (func(block))
   210653:  104:      return block;
   348402:  105:  } while ((block = getAncestorBlock(block)));
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
        -:  106:  return nullptr;
        -:  107:}
------------------
_Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E_ES2_S2_RKT_:
function _Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E_ES2_S2_RKT_ called 213933 returned 100% blocks executed 100%
   213933:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
   426421:  101:  do {
call    0 returned 100%
        -:  102:    // Invoke the user-defined traversal function for each block.
   857888:  103:    if (func(block))
     2523:  104:      return block;
   426421:  105:  } while ((block = getAncestorBlock(block)));
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  106:  return nullptr;
        -:  107:}
------------------
        -:  108:
        -:  109:/// Tries to update the given block references to live in the same region by
        -:  110:/// exploring the relationship of both blocks with respect to their regions.
function _ZL24tryGetBlocksInSameRegionRPN4mlir5BlockES2_ called 213933 returned 100% blocks executed 88%
   213933:  111:static bool tryGetBlocksInSameRegion(Block *&a, Block *&b) {
        -:  112:  // If both block do not live in the same region, we will have to check their
        -:  113:  // parent operations.
   213933:  114:  Region *aRegion = a->getParent();
call    0 returned 100%
   213933:  115:  Region *bRegion = b->getParent();
call    0 returned 100%
   213933:  116:  if (aRegion == bRegion)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  117:    return true;
        -:  118:
        -:  119:  // Iterate over all ancestors of `a`, counting the depth of `a`. If one of
        -:  120:  // `a`s ancestors are in the same region as `b`, then we stop early because we
        -:  121:  // found our NCA.
   213933:  122:  size_t aRegionDepth = 0;
   213933:  123:  if (Block *aResult = traverseAncestors(a, [&](Block *block) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
   428944:  124:        ++aRegionDepth;
   428944:  125:        return block->getParent() == bRegion;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        -:  126:      })) {
     2523:  127:    a = aResult;
     2523:  128:    return true;
        -:  129:  }
        -:  130:
        -:  131:  // Iterate over all ancestors of `b`, counting the depth of `b`. If one of
        -:  132:  // `b`s ancestors are in the same region as `a`, then we stop early because
        -:  133:  // we found our NCA.
   211410:  134:  size_t bRegionDepth = 0;
   211410:  135:  if (Block *bResult = traverseAncestors(b, [&](Block *block) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   559055:  136:        ++bRegionDepth;
   559055:  137:        return block->getParent() == aRegion;
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
        -:  138:      })) {
   210653:  139:    b = bResult;
   210653:  140:    return true;
        -:  141:  }
        -:  142:
        -:  143:  // Otherwise we found two blocks that are siblings at some level.  Walk the
        -:  144:  // deepest one up until we reach the top or find an NCA.
     1354:  145:  while (true) {
     1354:  146:    if (aRegionDepth > bRegionDepth) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  147:      a = getAncestorBlock(a);
call    0 never executed
    #####:  148:      --aRegionDepth;
     1354:  149:    } else if (aRegionDepth < bRegionDepth) {
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
      597:  150:      b = getAncestorBlock(b);
call    0 returned 100%
      597:  151:      --bRegionDepth;
        -:  152:    } else {
        -:  153:      break;
        -:  154:    }
        -:  155:  }
        -:  156:
        -:  157:  // If we found something with the same level, then we can march both up at the
        -:  158:  // same time from here on out.
     1514:  159:  while (a) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  160:    // If they are at the same level, and have the same parent region then we
        -:  161:    // succeeded.
     1514:  162:    if (a->getParent() == b->getParent())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  163:      return true;
        -:  164:
      757:  165:    a = getAncestorBlock(a);
call    0 returned 100%
     1514:  166:    b = getAncestorBlock(b);
call    0 returned 100%
        -:  167:  }
        -:  168:
        -:  169:  // They don't share an NCA, perhaps they are in different modules or
        -:  170:  // something.
        -:  171:  return false;
        -:  172:}
        -:  173:
        -:  174:template <bool IsPostDom>
        -:  175:Block *
   385179:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
   385179:  179:  if (!a || !b)
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
   385179:  183:  if (a == b)
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
   213933:  187:  if (!tryGetBlocksInSameRegion(a, b))
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
   213933:  192:  if (a == b)
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
        -:  198:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE26findNearestCommonDominatorEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE26findNearestCommonDominatorEPNS_5BlockES4_ called 247217 returned 100% blocks executed 70%
   247217:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
   247217:  179:  if (!a || !b)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
   247217:  183:  if (a == b)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
   139309:  187:  if (!tryGetBlocksInSameRegion(a, b))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
   139309:  192:  if (a == b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  198:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE26findNearestCommonDominatorEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE26findNearestCommonDominatorEPNS_5BlockES4_ called 137962 returned 100% blocks executed 70%
   137962:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
   137962:  179:  if (!a || !b)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
   137962:  183:  if (a == b)
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
    74624:  187:  if (!tryGetBlocksInSameRegion(a, b))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
    74624:  192:  if (a == b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  198:}
------------------
        -:  199:
        -:  200:/// Return true if the specified block A properly dominates block B.
        -:  201:template <bool IsPostDom>
185615320*:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
185615320*:  203:  assert(a && b && "null blocks not allowed");
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
185615320*:  206:  if (a == b)
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
185592375*:  212:  Region *regionA = a->getParent();
185592367*:  213:  if (regionA != b->getParent()) {
185588402*:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
185588400*:  216:    if (b == nullptr)
  519945*:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
185068455*:  221:    if (a == b)
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
    4523*:  226:  return getDomTree(regionA).properlyDominates(a, b);
        -:  227:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE17properlyDominatesEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE17properlyDominatesEPNS_5BlockES4_ called 185615320 returned 100% blocks executed 93%
185615320:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
185615320*:  203:  assert(a && b && "null blocks not allowed");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
185615320:  206:  if (a == b)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
185592375:  212:  Region *regionA = a->getParent();
call    0 returned 100%
185592367:  213:  if (regionA != b->getParent()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
185588402:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
185588400:  216:    if (b == nullptr)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
   519945:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
185068455:  221:    if (a == b)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
     4523:  226:  return getDomTree(regionA).properlyDominates(a, b);
call    0 returned 100%
call    1 returned 100%
        -:  227:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE17properlyDominatesEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE17properlyDominatesEPNS_5BlockES4_ called 0 returned 0% blocks executed 0%
    #####:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
    #####:  203:  assert(a && b && "null blocks not allowed");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
    #####:  206:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
    #####:  212:  Region *regionA = a->getParent();
call    0 never executed
    #####:  213:  if (regionA != b->getParent()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
    #####:  216:    if (b == nullptr)
branch  0 never executed
branch  1 never executed
    #####:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
    #####:  221:    if (a == b)
branch  0 never executed
branch  1 never executed
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
    #####:  226:  return getDomTree(regionA).properlyDominates(a, b);
call    0 never executed
call    1 never executed
        -:  227:}
------------------
        -:  228:
        -:  229:/// Return true if the specified block is reachable from the entry block of
        -:  230:/// its region.
        -:  231:template <bool IsPostDom>
455485559*:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
455485559*:  234:  Region *region = a->getParent();
455485563*:  235:  if (&region->front() == a)
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
   12589*:  239:  return getDomTree(region).isReachableFromEntry(a);
        -:  240:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE20isReachableFromEntryEPNS_5BlockE:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE20isReachableFromEntryEPNS_5BlockE called 455485559 returned 100% blocks executed 100%
455485559:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
455485559:  234:  Region *region = a->getParent();
call    0 returned 100%
call    1 returned 100%
455485563:  235:  if (&region->front() == a)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
    12589:  239:  return getDomTree(region).isReachableFromEntry(a);
call    0 returned 100%
call    1 returned 100%
        -:  240:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE20isReachableFromEntryEPNS_5BlockE:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE20isReachableFromEntryEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
    #####:  234:  Region *region = a->getParent();
call    0 never executed
call    1 never executed
    #####:  235:  if (&region->front() == a)
branch  0 never executed
branch  1 never executed
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
    #####:  239:  return getDomTree(region).isReachableFromEntry(a);
call    0 never executed
        -:  240:}
------------------
        -:  241:
        -:  242:template class detail::DominanceInfoBase</*IsPostDom=*/true>;
        -:  243:template class detail::DominanceInfoBase</*IsPostDom=*/false>;
        -:  244:
        -:  245://===----------------------------------------------------------------------===//
        -:  246:// DominanceInfo
        -:  247://===----------------------------------------------------------------------===//
        -:  248:
        -:  249:/// Return true if operation `a` properly dominates operation `b`.  The
        -:  250:/// 'enclosingOpOk' flag says whether we should return true if the `b` op is
        -:  251:/// enclosed by a region on 'a'.
function _ZNK4mlir13DominanceInfo21properlyDominatesImplEPNS_9OperationES2_b called 22566610728 returned 100% blocks executed 91%
22566610728:  252:bool DominanceInfo::properlyDominatesImpl(Operation *a, Operation *b,
        -:  253:                                          bool enclosingOpOk) const {
22566610728:  254:  Block *aBlock = a->getBlock(), *bBlock = b->getBlock();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
22566610728*:  255:  assert(aBlock && bBlock && "operations must be in a block");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  256:
        -:  257:  // An instruction dominates, but does not properlyDominate, itself unless this
        -:  258:  // is a graph region.
22566610728:  259:  if (a == b)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      180:  260:    return !hasSSADominance(aBlock);
call    0 returned 100%
        -:  261:
        -:  262:  // If these ops are in different regions, then normalize one into the other.
22566610548:  263:  Region *aRegion = aBlock->getParent();
call    0 returned 100%
22566610477:  264:  if (aRegion != bBlock->getParent()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
        -:  265:    // Scoot up b's region tree until we find an operation in A's region that
        -:  266:    // encloses it.  If this fails, then we know there is no post-dom relation.
16631880679:  267:    b = aRegion ? aRegion->findAncestorOpInRegion(*b) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
16631880674:  268:    if (!b)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     1898:  269:      return false;
16631878776:  270:    bBlock = b->getBlock();
call    0 returned 100%
16631878776*:  271:    assert(bBlock->getParent() == aRegion);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  272:
        -:  273:    // If 'a' encloses 'b', then we consider it to dominate.
16631878768:  274:    if (a == b && enclosingOpOk)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  275:      return true;
        -:  276:  }
        -:  277:
        -:  278:  // Ok, they are in the same region now.
22566608425:  279:  if (aBlock == bBlock) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  280:    // Dominance changes based on the region type. In a region with SSA
        -:  281:    // dominance, uses inside the same block must follow defs. In other
        -:  282:    // regions kinds, uses and defs can come in any order inside a block.
22563499790:  283:    if (hasSSADominance(aBlock)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken -0%
        -:  284:      // If the blocks are the same, then check if b is before a in the block.
22563500667:  285:      return a->isBeforeInBlock(b);
call    0 returned 100%
        -:  286:    }
        -:  287:    return true;
        -:  288:  }
        -:  289:
        -:  290:  // If the blocks are different, use DomTree to resolve the query.
  3108635:  291:  return getDomTree(aRegion).properlyDominates(aBlock, bBlock);
call    0 returned 100%
call    1 returned 100%
        -:  292:}
        -:  293:
        -:  294:/// Return true if the `a` value properly dominates operation `b`, i.e if the
        -:  295:/// operation that defines `a` properlyDominates `b` and the operation that
        -:  296:/// defines `a` does not contain `b`.
function _ZNK4mlir13DominanceInfo17properlyDominatesENS_5ValueEPNS_9OperationE called 23195755390 returned 100% blocks executed 100%
23195755390:  297:bool DominanceInfo::properlyDominates(Value a, Operation *b) const {
        -:  298:  // block arguments properly dominate all operations in their own block, so
        -:  299:  // we use a dominates check here, not a properlyDominates check.
23195755390:  300:  if (auto blockArg = dyn_cast<BlockArgument>(a))
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
629210480:  301:    return dominates(blockArg.getOwner(), b->getBlock());
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        -:  302:
        -:  303:  // `a` properlyDominates `b` if the operation defining `a` properlyDominates
        -:  304:  // `b`, but `a` does not itself enclose `b` in one of its regions.
22566551346:  305:  return properlyDominatesImpl(a.getDefiningOp(), b, /*enclosingOpOk=*/false);
call    0 returned 100%
call    1 returned 100%
        -:  306:}
        -:  307:
        -:  308://===----------------------------------------------------------------------===//
        -:  309:// PostDominanceInfo
        -:  310://===----------------------------------------------------------------------===//
        -:  311:
        -:  312:/// Returns true if statement 'a' properly postdominates statement b.
function _ZN4mlir17PostDominanceInfo21properlyPostDominatesEPNS_9OperationES2_ called 43444 returned 100% blocks executed 78%
    43444:  313:bool PostDominanceInfo::properlyPostDominates(Operation *a, Operation *b) {
    43444:  314:  auto *aBlock = a->getBlock(), *bBlock = b->getBlock();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   43444*:  315:  assert(aBlock && bBlock && "operations must be in a block");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  316:
        -:  317:  // An instruction postDominates, but does not properlyPostDominate, itself
        -:  318:  // unless this is a graph region.
    43444:  319:  if (a == b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  320:    return !hasSSADominance(aBlock);
call    0 never executed
        -:  321:
        -:  322:  // If these ops are in different regions, then normalize one into the other.
    43444:  323:  Region *aRegion = aBlock->getParent();
call    0 returned 100%
    43444:  324:  if (aRegion != bBlock->getParent()) {
call    0 returned 100%
branch  1 taken 69% (fallthrough)
branch  2 taken 31%
        -:  325:    // Scoot up b's region tree until we find an operation in A's region that
        -:  326:    // encloses it.  If this fails, then we know there is no post-dom relation.
   29932*:  327:    b = aRegion ? aRegion->findAncestorOpInRegion(*b) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
    29932:  328:    if (!b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  329:      return false;
    29932:  330:    bBlock = b->getBlock();
call    0 returned 100%
   29932*:  331:    assert(bBlock->getParent() == aRegion);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  332:
        -:  333:    // If 'a' encloses 'b', then we consider it to postdominate.
    29932:  334:    if (a == b)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  335:      return true;
        -:  336:  }
        -:  337:
        -:  338:  // Ok, they are in the same region.  If they are in the same block, check if b
        -:  339:  // is before a in the block.
    43296:  340:  if (aBlock == bBlock) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  341:    // Dominance changes based on the region type.
    43288:  342:    if (hasSSADominance(aBlock)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  343:      // If the blocks are the same, then check if b is before a in the block.
    43288:  344:      return b->isBeforeInBlock(a);
call    0 returned 100%
        -:  345:    }
        -:  346:    return true;
        -:  347:  }
        -:  348:
        -:  349:  // If the blocks are different, check if a's block post dominates b's.
        8:  350:  return getDomTree(aRegion).properlyDominates(aBlock, bBlock);
call    0 returned 100%
call    1 returned 100%
        -:  351:}
