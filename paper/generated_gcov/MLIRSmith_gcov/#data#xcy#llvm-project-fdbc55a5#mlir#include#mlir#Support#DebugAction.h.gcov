        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Support/DebugAction.h
        -:    0:Graph:../tools/mlir/lib/Tools/mlir-opt/CMakeFiles/obj.MLIROptLib.dir/MlirOptMain.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Tools/mlir-opt/CMakeFiles/obj.MLIROptLib.dir/MlirOptMain.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- DebugAction.h - Debug Action Support ---------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains definitions for the debug action framework. This framework
        -:   10:// allows for external entities to control certain actions taken by the compiler
        -:   11:// by registering handler functions. A debug action handler provides the
        -:   12:// internal implementation for the various queries on a debug action, such as
        -:   13:// whether it should execute or not.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef MLIR_SUPPORT_DEBUGACTION_H
        -:   18:#define MLIR_SUPPORT_DEBUGACTION_H
        -:   19:
        -:   20:#include "mlir/Support/LogicalResult.h"
        -:   21:#include "mlir/Support/TypeID.h"
        -:   22:#include "llvm/ADT/ArrayRef.h"
        -:   23:#include "llvm/ADT/Sequence.h"
        -:   24:#include "llvm/ADT/StringMap.h"
        -:   25:#include "llvm/Support/TypeName.h"
        -:   26:#include "llvm/Support/raw_ostream.h"
        -:   27:#include <functional>
        -:   28:#include <type_traits>
        -:   29:
        -:   30:namespace mlir {
        -:   31:
        -:   32://===----------------------------------------------------------------------===//
        -:   33:// DebugActionManager
        -:   34://===----------------------------------------------------------------------===//
        -:   35:
        -:   36:/// This class represents manages debug actions, and orchestrates the
        -:   37:/// communication between action queries and action handlers. An action handler
        -:   38:/// is either an action specific handler, i.e. a derived class of
        -:   39:/// `MyActionType::Handler`, or a generic handler, i.e. a derived class of
        -:   40:/// `DebugActionManager::GenericHandler`. For more details on action specific
        -:   41:/// handlers, see the definition of `DebugAction::Handler` below. For more
        -:   42:/// details on generic handlers, see `DebugActionManager::GenericHandler` below.
        -:   43:class DebugActionManager {
        -:   44:public:
        -:   45:  //===--------------------------------------------------------------------===//
        -:   46:  // Handlers
        -:   47:  //===--------------------------------------------------------------------===//
        -:   48:
        -:   49:  /// This class represents the base class of a debug action handler.
        -:   50:  class HandlerBase {
        -:   51:  public:
    #####:   52:    virtual ~HandlerBase() = default;
------------------
_ZN4mlir18DebugActionManager11HandlerBaseD0Ev:
function _ZN4mlir18DebugActionManager11HandlerBaseD0Ev called 0 returned 0% blocks executed 0%
    #####:   52:    virtual ~HandlerBase() = default;
call    0 never executed
------------------
_ZN4mlir18DebugActionManager11HandlerBaseD2Ev:
function _ZN4mlir18DebugActionManager11HandlerBaseD2Ev called 0 returned 0% blocks executed 0%
    #####:   52:    virtual ~HandlerBase() = default;
------------------
        -:   53:
        -:   54:    /// Return the unique handler id of this handler, use for casting
        -:   55:    /// functionality.
        -:   56:    TypeID getHandlerID() const { return handlerID; }
        -:   57:
        -:   58:  protected:
        -:   59:    HandlerBase(TypeID handlerID) : handlerID(handlerID) {}
        -:   60:
        -:   61:    /// The type of the derived handler class. This allows for detecting if a
        -:   62:    /// handler can handle a given action type.
        -:   63:    TypeID handlerID;
        -:   64:  };
        -:   65:
        -:   66:  /// This class represents a generic action handler. A generic handler allows
        -:   67:  /// for handling any action type. Handlers of this type are useful for
        -:   68:  /// implementing general functionality that doesn't necessarily need to
        -:   69:  /// interpret the exact action parameters, or can rely on an external
        -:   70:  /// interpreter (such as the user). Given that these handlers are generic,
        -:   71:  /// they take a set of opaque parameters that try to map the context of the
        -:   72:  /// action type in a generic way.
        -:   73:  class GenericHandler : public HandlerBase {
        -:   74:  public:
        -:   75:    GenericHandler() : HandlerBase(TypeID::get<GenericHandler>()) {}
        -:   76:
        -:   77:    /// This hook allows for controlling whether an action should execute or
        -:   78:    /// not. It should return failure if the handler could not process the
        -:   79:    /// action, passing it to the next registered handler.
        -:   80:    virtual FailureOr<bool> shouldExecute(StringRef actionTag,
        -:   81:                                          StringRef description) {
        -:   82:      return failure();
        -:   83:    }
        -:   84:
        -:   85:    /// Provide classof to allow casting between handler types.
        -:   86:    static bool classof(const DebugActionManager::HandlerBase *handler) {
        -:   87:      return handler->getHandlerID() == TypeID::get<GenericHandler>();
        -:   88:    }
        -:   89:  };
        -:   90:
        -:   91:  /// Register the given action handler with the manager.
    94572:   92:  void registerActionHandler(std::unique_ptr<HandlerBase> handler) {
        -:   93:    // The manager is always disabled if built without debug.
        -:   94:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
    94572:   95:    actionHandlers.emplace_back(std::move(handler));
call    0 returned 100%
        -:   96:#endif
        -:   97:  }
        -:   98:  template <typename T>
function _ZN4mlir18DebugActionManager21registerActionHandlerINS_12DebugCounterEEEvv called 94572 returned 100% blocks executed 71%
    94572:   99:  void registerActionHandler() {
call    0 returned 100%
    94572:  100:    registerActionHandler(std::make_unique<T>());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    94572:  101:  }
        -:  102:
        -:  103:  //===--------------------------------------------------------------------===//
        -:  104:  // Action Queries
        -:  105:  //===--------------------------------------------------------------------===//
        -:  106:
        -:  107:  /// Returns true if the given action type should be executed, false otherwise.
        -:  108:  /// `Args` are a set of parameters used by handlers of `ActionType` to
        -:  109:  /// determine if the action should be executed.
        -:  110:  template <typename ActionType, typename... Args>
        -:  111:  bool shouldExecute(Args &&...args) {
        -:  112:    // The manager is always disabled if built without debug.
        -:  113:#if !LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  114:    return true;
        -:  115:#else
        -:  116:    // Invoke the `shouldExecute` method on the provided handler.
        -:  117:    auto shouldExecuteFn = [&](auto *handler, auto &&...handlerParams) {
        -:  118:      return handler->shouldExecute(
        -:  119:          std::forward<decltype(handlerParams)>(handlerParams)...);
        -:  120:    };
        -:  121:    FailureOr<bool> result = dispatchToHandler<ActionType, bool>(
        -:  122:        shouldExecuteFn, std::forward<Args>(args)...);
        -:  123:
        -:  124:    // If the action wasn't handled, execute the action by default.
        -:  125:    return succeeded(result) ? *result : true;
        -:  126:#endif
        -:  127:  }
        -:  128:
        -:  129:private:
        -:  130:// The manager is always disabled if built without debug.
        -:  131:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  132:  //===--------------------------------------------------------------------===//
        -:  133:  // Query to Handler Dispatch
        -:  134:  //===--------------------------------------------------------------------===//
        -:  135:
        -:  136:  /// Dispath a given callback on any handlers that are able to process queries
        -:  137:  /// on the given action type. This method returns failure if no handlers could
        -:  138:  /// process the action, or success(with a result) if a handler processed the
        -:  139:  /// action.
        -:  140:  template <typename ActionType, typename ResultT, typename HandlerCallbackT,
        -:  141:            typename... Args>
        -:  142:  FailureOr<ResultT> dispatchToHandler(HandlerCallbackT &&handlerCallback,
        -:  143:                                       Args &&...args) {
        -:  144:    static_assert(ActionType::template canHandleWith<Args...>(),
        -:  145:                  "cannot execute action with the given set of parameters");
        -:  146:
        -:  147:    // Process any generic or action specific handlers.
        -:  148:    // TODO: We currently just pick the first handler that gives us a result,
        -:  149:    // but in the future we may want to employ a reduction over all of the
        -:  150:    // values returned.
        -:  151:    for (std::unique_ptr<HandlerBase> &it : llvm::reverse(actionHandlers)) {
        -:  152:      FailureOr<ResultT> result = failure();
        -:  153:      if (auto *handler = dyn_cast<typename ActionType::Handler>(&*it)) {
        -:  154:        result = handlerCallback(handler, std::forward<Args>(args)...);
        -:  155:      } else if (auto *genericHandler = dyn_cast<GenericHandler>(&*it)) {
        -:  156:        result = handlerCallback(genericHandler, ActionType::getTag(),
        -:  157:                                 ActionType::getDescription());
        -:  158:      }
        -:  159:
        -:  160:      // If the handler succeeded, return the result. Otherwise, try a new
        -:  161:      // handler.
        -:  162:      if (succeeded(result))
        -:  163:        return result;
        -:  164:    }
        -:  165:    return failure();
        -:  166:  }
        -:  167:
        -:  168:  /// The set of action handlers that have been registered with the manager.
        -:  169:  SmallVector<std::unique_ptr<HandlerBase>> actionHandlers;
        -:  170:#endif
        -:  171:};
        -:  172:
        -:  173://===----------------------------------------------------------------------===//
        -:  174:// DebugAction
        -:  175://===----------------------------------------------------------------------===//
        -:  176:
        -:  177:/// A debug action is a specific action that is to be taken by the compiler,
        -:  178:/// that can be toggled and controlled by an external user. There are no
        -:  179:/// constraints on the granularity of an action, it could be as simple as
        -:  180:/// "perform this fold" and as complex as "run this pass pipeline". Via template
        -:  181:/// parameters `ParameterTs`, a user may provide the set of argument types that
        -:  182:/// are provided when handling a query on this action. Derived classes are
        -:  183:/// expected to provide the following:
        -:  184:///   * static llvm::StringRef getTag()
        -:  185:///     - This method returns a unique string identifier, similar to a command
        -:  186:///       line flag or DEBUG_TYPE.
        -:  187:///   * static llvm::StringRef getDescription()
        -:  188:///     - This method returns a short description of what the action represents.
        -:  189:///
        -:  190:/// This class provides a handler class that can be derived from to handle
        -:  191:/// instances of this action. The parameters to its query methods map 1-1 to the
        -:  192:/// types on the action type.
        -:  193:template <typename Derived, typename... ParameterTs>
        -:  194:class DebugAction {
        -:  195:public:
        -:  196:  class Handler : public DebugActionManager::HandlerBase {
        -:  197:  public:
        -:  198:    Handler() : HandlerBase(TypeID::get<Derived>()) {}
        -:  199:
        -:  200:    /// This hook allows for controlling whether an action should execute or
        -:  201:    /// not. `parameters` correspond to the set of values provided by the
        -:  202:    /// action as context. It should return failure if the handler could not
        -:  203:    /// process the action, passing it to the next registered handler.
        -:  204:    virtual FailureOr<bool> shouldExecute(ParameterTs... parameters) {
        -:  205:      return failure();
        -:  206:    }
        -:  207:
        -:  208:    /// Provide classof to allow casting between handler types.
        -:  209:    static bool classof(const DebugActionManager::HandlerBase *handler) {
        -:  210:      return handler->getHandlerID() == TypeID::get<Derived>();
        -:  211:    }
        -:  212:  };
        -:  213:
        -:  214:private:
        -:  215:  /// Returns true if the action can be handled within the given set of
        -:  216:  /// parameter types.
        -:  217:  template <typename... CallerParameterTs>
        -:  218:  static constexpr bool canHandleWith() {
        -:  219:    return std::is_invocable_v<function_ref<void(ParameterTs...)>,
        -:  220:                               CallerParameterTs...>;
        -:  221:  }
        -:  222:
        -:  223:  /// Allow access to `canHandleWith`.
        -:  224:  friend class DebugActionManager;
        -:  225:};
        -:  226:
        -:  227:} // namespace mlir
        -:  228:
        -:  229:#endif // MLIR_SUPPORT_DEBUGACTION_H
