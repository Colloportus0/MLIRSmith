        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Analysis/Presburger/PresburgerRelation.cpp
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/PresburgerRelation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/PresburgerRelation.cpp.gcda
        -:    0:Runs:116175
        -:    1://===- PresburgerRelation.cpp - MLIR PresburgerRelation Class -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Analysis/Presburger/PresburgerRelation.h"
        -:   10:#include "mlir/Analysis/Presburger/Simplex.h"
        -:   11:#include "mlir/Analysis/Presburger/Utils.h"
        -:   12:#include "llvm/ADT/STLExtras.h"
        -:   13:#include "llvm/ADT/ScopeExit.h"
        -:   14:#include "llvm/ADT/SmallBitVector.h"
        -:   15:
        -:   16:using namespace mlir;
        -:   17:using namespace presburger;
        -:   18:
function _ZN4mlir10presburger18PresburgerRelationC2ERKNS0_15IntegerRelationE called 0 returned 0% blocks executed 0%
    #####:   19:PresburgerRelation::PresburgerRelation(const IntegerRelation &disjunct)
call    0 never executed
    #####:   20:    : space(disjunct.getSpaceWithoutLocals()) {
call    0 never executed
    #####:   21:  unionInPlace(disjunct);
call    0 never executed
    #####:   22:}
        -:   23:
function _ZN4mlir10presburger18PresburgerRelation8setSpaceERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   24:void PresburgerRelation::setSpace(const PresburgerSpace &oSpace) {
    #####:   25:  assert(space.getNumLocalVars() == 0 && "no locals should be present");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   26:  space = oSpace;
call    0 never executed
    #####:   27:  for (IntegerRelation &disjunct : disjuncts)
branch  0 never executed
branch  1 never executed
    #####:   28:    disjunct.setSpaceExceptLocals(space);
call    0 never executed
    #####:   29:}
        -:   30:
function _ZNK4mlir10presburger18PresburgerRelation15getNumDisjunctsEv called 0 returned 0% blocks executed 0%
    #####:   31:unsigned PresburgerRelation::getNumDisjuncts() const {
    #####:   32:  return disjuncts.size();
        -:   33:}
        -:   34:
function _ZNK4mlir10presburger18PresburgerRelation15getAllDisjunctsEv called 0 returned 0% blocks executed 0%
    #####:   35:ArrayRef<IntegerRelation> PresburgerRelation::getAllDisjuncts() const {
    #####:   36:  return disjuncts;
        -:   37:}
        -:   38:
function _ZNK4mlir10presburger18PresburgerRelation11getDisjunctEj called 0 returned 0% blocks executed 0%
    #####:   39:const IntegerRelation &PresburgerRelation::getDisjunct(unsigned index) const {
    #####:   40:  assert(index < disjuncts.size() && "index out of bounds!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   41:  return disjuncts[index];
branch  0 never executed
branch  1 never executed
        -:   42:}
        -:   43:
        -:   44:/// Mutate this set, turning it into the union of this set and the given
        -:   45:/// IntegerRelation.
function _ZN4mlir10presburger18PresburgerRelation12unionInPlaceERKNS0_15IntegerRelationE called 0 returned 0% blocks executed 0%
    #####:   46:void PresburgerRelation::unionInPlace(const IntegerRelation &disjunct) {
    #####:   47:  assert(space.isCompatible(disjunct.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   48:  disjuncts.push_back(disjunct);
call    0 never executed
    #####:   49:}
        -:   50:
        -:   51:/// Mutate this set, turning it into the union of this set and the given set.
        -:   52:///
        -:   53:/// This is accomplished by simply adding all the disjuncts of the given set
        -:   54:/// to this set.
function _ZN4mlir10presburger18PresburgerRelation12unionInPlaceERKS1_ called 0 returned 0% blocks executed 0%
    #####:   55:void PresburgerRelation::unionInPlace(const PresburgerRelation &set) {
    #####:   56:  assert(space.isCompatible(set.getSpace()) && "Spaces should match");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   57:  for (const IntegerRelation &disjunct : set.disjuncts)
branch  0 never executed
branch  1 never executed
    #####:   58:    unionInPlace(disjunct);
call    0 never executed
    #####:   59:}
        -:   60:
        -:   61:/// Return the union of this set and the given set.
        -:   62:PresburgerRelation
function _ZNK4mlir10presburger18PresburgerRelation8unionSetERKS1_ called 0 returned 0% blocks executed 0%
    #####:   63:PresburgerRelation::unionSet(const PresburgerRelation &set) const {
    #####:   64:  assert(space.isCompatible(set.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   65:  PresburgerRelation result = *this;
call    0 never executed
    #####:   66:  result.unionInPlace(set);
call    0 never executed
    #####:   67:  return result;
        -:   68:}
        -:   69:
        -:   70:/// A point is contained in the union iff any of the parts contain the point.
function _ZNK4mlir10presburger18PresburgerRelation13containsPointEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:   71:bool PresburgerRelation::containsPoint(ArrayRef<MPInt> point) const {
    #####:   72:  return llvm::any_of(disjuncts, [&](const IntegerRelation &disjunct) {
call    0 never executed
    #####:   73:    return (disjunct.containsPointNoLocal(point));
call    0 never executed
    #####:   74:  });
        -:   75:}
        -:   76:
        -:   77:PresburgerRelation
function _ZN4mlir10presburger18PresburgerRelation11getUniverseERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   78:PresburgerRelation::getUniverse(const PresburgerSpace &space) {
    #####:   79:  PresburgerRelation result(space);
call    0 never executed
    #####:   80:  result.unionInPlace(IntegerRelation::getUniverse(space));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   81:  return result;
        -:   82:}
        -:   83:
function _ZN4mlir10presburger18PresburgerRelation8getEmptyERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   84:PresburgerRelation PresburgerRelation::getEmpty(const PresburgerSpace &space) {
    #####:   85:  return PresburgerRelation(space);
call    0 never executed
call    1 never executed
        -:   86:}
        -:   87:
        -:   88:// Return the intersection of this set with the given set.
        -:   89://
        -:   90:// We directly compute (S_1 or S_2 ...) and (T_1 or T_2 ...)
        -:   91:// as (S_1 and T_1) or (S_1 and T_2) or ...
        -:   92://
        -:   93:// If S_i or T_j have local variables, then S_i and T_j contains the local
        -:   94:// variables of both.
        -:   95:PresburgerRelation
function _ZNK4mlir10presburger18PresburgerRelation9intersectERKS1_ called 0 returned 0% blocks executed 0%
    #####:   96:PresburgerRelation::intersect(const PresburgerRelation &set) const {
    #####:   97:  assert(space.isCompatible(set.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   98:
    #####:   99:  PresburgerRelation result(getSpace());
call    0 never executed
    #####:  100:  for (const IntegerRelation &csA : disjuncts) {
branch  0 never executed
branch  1 never executed
    #####:  101:    for (const IntegerRelation &csB : set.disjuncts) {
branch  0 never executed
branch  1 never executed
    #####:  102:      IntegerRelation intersection = csA.intersect(csB);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  103:      if (!intersection.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  104:        result.unionInPlace(intersection);
call    0 never executed
        -:  105:    }
        -:  106:  }
    #####:  107:  return result;
        -:  108:}
        -:  109:
        -:  110:/// Return the coefficients of the ineq in `rel` specified by  `idx`.
        -:  111:/// `idx` can refer not only to an actual inequality of `rel`, but also
        -:  112:/// to either of the inequalities that make up an equality in `rel`.
        -:  113:///
        -:  114:/// When 0 <= idx < rel.getNumInequalities(), this returns the coeffs of the
        -:  115:/// idx-th inequality of `rel`.
        -:  116:///
        -:  117:/// Otherwise, it is then considered to index into the ineqs corresponding to
        -:  118:/// eqs of `rel`, and it must hold that
        -:  119:///
        -:  120:/// 0 <= idx - rel.getNumInequalities() < 2*getNumEqualities().
        -:  121:///
        -:  122:/// For every eq `coeffs == 0` there are two possible ineqs to index into.
        -:  123:/// The first is coeffs >= 0 and the second is coeffs <= 0.
function _ZL20getIneqCoeffsFromIdxRKN4mlir10presburger15IntegerRelationEj called 0 returned 0% blocks executed 0%
    #####:  124:static SmallVector<MPInt, 8> getIneqCoeffsFromIdx(const IntegerRelation &rel,
        -:  125:                                                  unsigned idx) {
    #####:  126:  assert(idx < rel.getNumInequalities() + 2 * rel.getNumEqualities() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  127:         "idx out of bounds!");
    #####:  128:  if (idx < rel.getNumInequalities())
branch  0 never executed
branch  1 never executed
    #####:  129:    return llvm::to_vector<8>(rel.getInequality(idx));
call    0 never executed
call    1 never executed
        -:  130:
    #####:  131:  idx -= rel.getNumInequalities();
call    0 never executed
    #####:  132:  ArrayRef<MPInt> eqCoeffs = rel.getEquality(idx / 2);
call    0 never executed
        -:  133:
    #####:  134:  if (idx % 2 == 0)
branch  0 never executed
branch  1 never executed
    #####:  135:    return llvm::to_vector<8>(eqCoeffs);
call    0 never executed
    #####:  136:  return getNegatedCoeffs(eqCoeffs);
call    0 never executed
        -:  137:}
        -:  138:
function _ZNK4mlir10presburger18PresburgerRelation28computeReprWithOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####:  139:PresburgerRelation PresburgerRelation::computeReprWithOnlyDivLocals() const {
    #####:  140:  if (hasOnlyDivLocals())
    #####:  141:    return *this;
call    0 never executed
        -:  142:
        -:  143:  // The result is just the union of the reprs of the disjuncts.
    #####:  144:  PresburgerRelation result(getSpace());
call    0 never executed
call    1 never executed
    #####:  145:  for (const IntegerRelation &disjunct : disjuncts)
branch  0 never executed
branch  1 never executed
    #####:  146:    result.unionInPlace(disjunct.computeReprWithOnlyDivLocals());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  147:  return result;
call    0 never executed
        -:  148:}
        -:  149:
        -:  150:/// Return the set difference b \ s.
        -:  151:///
        -:  152:/// In the following, U denotes union, /\ denotes intersection, \ denotes set
        -:  153:/// difference and ~ denotes complement.
        -:  154:///
        -:  155:/// Let s = (U_i s_i). We want  b \ (U_i s_i).
        -:  156:///
        -:  157:/// Let s_i = /\_j s_ij, where each s_ij is a single inequality. To compute
        -:  158:/// b \ s_i = b /\ ~s_i, we partition s_i based on the first violated
        -:  159:/// inequality: ~s_i = (~s_i1) U (s_i1 /\ ~s_i2) U (s_i1 /\ s_i2 /\ ~s_i3) U ...
        -:  160:/// And the required result is (b /\ ~s_i1) U (b /\ s_i1 /\ ~s_i2) U ...
        -:  161:/// We recurse by subtracting U_{j > i} S_j from each of these parts and
        -:  162:/// returning the union of the results. Each equality is handled as a
        -:  163:/// conjunction of two inequalities.
        -:  164:///
        -:  165:/// Note that the same approach works even if an inequality involves a floor
        -:  166:/// division. For example, the complement of x <= 7*floor(x/7) is still
        -:  167:/// x > 7*floor(x/7). Since b \ s_i contains the inequalities of both b and s_i
        -:  168:/// (or the complements of those inequalities), b \ s_i may contain the
        -:  169:/// divisions present in both b and s_i. Therefore, we need to add the local
        -:  170:/// division variables of both b and s_i to each part in the result. This means
        -:  171:/// adding the local variables of both b and s_i, as well as the corresponding
        -:  172:/// division inequalities to each part. Since the division inequalities are
        -:  173:/// added to each part, we can skip the parts where the complement of any
        -:  174:/// division inequality is added, as these parts will become empty anyway.
        -:  175:///
        -:  176:/// As a heuristic, we try adding all the constraints and check if simplex
        -:  177:/// says that the intersection is empty. If it is, then subtracting this
        -:  178:/// disjuncts is a no-op and we just skip it. Also, in the process we find out
        -:  179:/// that some constraints are redundant. These redundant constraints are
        -:  180:/// ignored.
        -:  181:///
function _ZL16getSetDifferenceN4mlir10presburger15IntegerRelationERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  182:static PresburgerRelation getSetDifference(IntegerRelation b,
        -:  183:                                           const PresburgerRelation &s) {
    #####:  184:  assert(b.getSpace().isCompatible(s.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  185:  if (b.isEmptyByGCDTest())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:    return PresburgerRelation::getEmpty(b.getSpaceWithoutLocals());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  187:
    #####:  188:  if (!s.hasOnlyDivLocals())
    #####:  189:    return getSetDifference(b, s.computeReprWithOnlyDivLocals());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  190:
        -:  191:  // Remove duplicate divs up front here to avoid existing
        -:  192:  // divs disappearing in the call to mergeLocalVars below.
    #####:  193:  b.removeDuplicateDivs();
call    0 never executed
        -:  194:
    #####:  195:  PresburgerRelation result =
call    0 never executed
    #####:  196:      PresburgerRelation::getEmpty(b.getSpaceWithoutLocals());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  197:  Simplex simplex(b);
call    0 never executed
call    1 never executed
        -:  198:
        -:  199:  // This algorithm is more naturally expressed recursively, but we implement
        -:  200:  // it iteratively here to avoid issues with stack sizes.
        -:  201:  //
        -:  202:  // Each level of the recursion has five stack variables.
    #####:  203:  struct Frame {
        -:  204:    // A snapshot of the simplex state to rollback to.
        -:  205:    unsigned simplexSnapshot;
        -:  206:    // A CountsSnapshot of `b` to rollback to.
        -:  207:    IntegerRelation::CountsSnapshot bCounts;
        -:  208:    // The IntegerRelation currently being operated on.
        -:  209:    IntegerRelation sI;
        -:  210:    // A list of indexes (see getIneqCoeffsFromIdx) of inequalities to be
        -:  211:    // processed.
        -:  212:    SmallVector<unsigned, 8> ineqsToProcess;
        -:  213:    // The index of the last inequality that was processed at this level.
        -:  214:    // This is empty when we are coming to this level for the first time.
        -:  215:    Optional<unsigned> lastIneqProcessed;
        -:  216:  };
    #####:  217:  SmallVector<Frame, 2> frames;
call    0 never executed
call    1 never executed
        -:  218:
        -:  219:  // When we "recurse", we ensure the current frame is stored in `frames` and
        -:  220:  // increment `level`. When we return, we decrement `level`.
    #####:  221:  unsigned level = 1;
    #####:  222:  while (level > 0) {
branch  0 never executed
branch  1 never executed
    #####:  223:    if (level - 1 >= s.getNumDisjuncts()) {
branch  0 never executed
branch  1 never executed
        -:  224:      // No more parts to subtract; add to the result and return.
    #####:  225:      result.unionInPlace(b);
call    0 never executed
    #####:  226:      level = frames.size();
    #####:  227:      continue;
        -:  228:    }
        -:  229:
    #####:  230:    if (level > frames.size()) {
branch  0 never executed
branch  1 never executed
        -:  231:      // No frame for this level yet, so we have just recursed into this level.
    #####:  232:      IntegerRelation sI = s.getDisjunct(level - 1);
call    0 never executed
call    1 never executed
        -:  233:      // Remove the duplicate divs up front to avoid them possibly disappearing
        -:  234:      // in the call to mergeLocalVars below.
    #####:  235:      sI.removeDuplicateDivs();
call    0 never executed
        -:  236:
        -:  237:      // Below, we append some additional constraints and ids to b. We want to
        -:  238:      // rollback b to its initial state before returning, which we will do by
        -:  239:      // removing all constraints beyond the original number of inequalities
        -:  240:      // and equalities, so we store these counts first.
    #####:  241:      IntegerRelation::CountsSnapshot initBCounts = b.getCounts();
call    0 never executed
call    1 never executed
        -:  242:      // Similarly, we also want to rollback simplex to its original state.
    #####:  243:      unsigned initialSnapshot = simplex.getSnapshot();
call    0 never executed
        -:  244:
        -:  245:      // Add sI's locals to b, after b's locals. Only those locals of sI which
        -:  246:      // do not already exist in b will be added. (i.e., duplicate divisions
        -:  247:      // will not be added.) Also add b's locals to sI, in such a way that both
        -:  248:      // have the same locals in the same order in the end.
    #####:  249:      b.mergeLocalVars(sI);
call    0 never executed
        -:  250:
        -:  251:      // Find out which inequalities of sI correspond to division inequalities
        -:  252:      // for the local variables of sI.
        -:  253:      //
        -:  254:      // Careful! This has to be done after the merge above; otherwise, the
        -:  255:      // dividends won't contain the new ids inserted during the merge.
    #####:  256:      std::vector<MaybeLocalRepr> repr(sI.getNumLocalVars());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  257:      DivisionRepr divs = sI.getLocalReprs(&repr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  258:
        -:  259:      // Mark which inequalities of sI are division inequalities and add all
        -:  260:      // such inequalities to b.
    #####:  261:      llvm::SmallBitVector canIgnoreIneq(sI.getNumInequalities() +
call    0 never executed
    #####:  262:                                         2 * sI.getNumEqualities());
call    0 never executed
call    1 never executed
    #####:  263:      for (unsigned i = initBCounts.getSpace().getNumLocalVars(),
    #####:  264:                    e = sI.getNumLocalVars();
    #####:  265:           i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  266:        assert(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  267:            repr[i] &&
        -:  268:            "Subtraction is not supported when a representation of the local "
        -:  269:            "variables of the subtrahend cannot be found!");
        -:  270:
    #####:  271:        if (repr[i].kind == ReprKind::Inequality) {
branch  0 never executed
branch  1 never executed
    #####:  272:          unsigned lb = repr[i].repr.inequalityPair.lowerBoundIdx;
call    0 never executed
    #####:  273:          unsigned ub = repr[i].repr.inequalityPair.upperBoundIdx;
        -:  274:
    #####:  275:          b.addInequality(sI.getInequality(lb));
call    0 never executed
call    1 never executed
    #####:  276:          b.addInequality(sI.getInequality(ub));
call    0 never executed
call    1 never executed
        -:  277:
    #####:  278:          assert(lb != ub &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  279:                 "Upper and lower bounds must be different inequalities!");
    #####:  280:          canIgnoreIneq[lb] = true;
call    0 never executed
call    1 never executed
    #####:  281:          canIgnoreIneq[ub] = true;
call    0 never executed
call    1 never executed
        -:  282:        } else {
    #####:  283:          assert(repr[i].kind == ReprKind::Equality &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  284:                 "ReprKind isn't inequality so should be equality");
        -:  285:
        -:  286:          // Consider the case (x) : (x = 3e + 1), where e is a local.
        -:  287:          // Its complement is (x) : (x = 3e) or (x = 3e + 2).
        -:  288:          //
        -:  289:          // This can be computed by considering the set to be
        -:  290:          // (x) : (x = 3*(x floordiv 3) + 1).
        -:  291:          //
        -:  292:          // Now there are no equalities defining divisions; the division is
        -:  293:          // defined by the standard division equalities for e = x floordiv 3,
        -:  294:          // i.e., 0 <= x - 3*e <= 2.
        -:  295:          // So now as before, we add these division inequalities to b. The
        -:  296:          // equality is now just an ordinary constraint that must be considered
        -:  297:          // in the remainder of the algorithm. The division inequalities must
        -:  298:          // need not be considered, same as above, and they automatically will
        -:  299:          // not be because they were never a part of sI; we just infer them
        -:  300:          // from the equality and add them only to b.
    #####:  301:          b.addInequality(
call    0 never executed
call    1 never executed
    #####:  302:              getDivLowerBound(divs.getDividend(i), divs.getDenom(i),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  303:                               sI.getVarKindOffset(VarKind::Local) + i));
branch  0 never executed
branch  1 never executed
    #####:  304:          b.addInequality(
call    0 never executed
call    1 never executed
    #####:  305:              getDivUpperBound(divs.getDividend(i), divs.getDenom(i),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  306:                               sI.getVarKindOffset(VarKind::Local) + i));
branch  0 never executed
branch  1 never executed
        -:  307:        }
        -:  308:      }
        -:  309:
    #####:  310:      unsigned offset = simplex.getNumConstraints();
call    0 never executed
    #####:  311:      unsigned numLocalsAdded =
call    0 never executed
    #####:  312:          b.getNumLocalVars() - initBCounts.getSpace().getNumLocalVars();
call    0 never executed
    #####:  313:      simplex.appendVariable(numLocalsAdded);
call    0 never executed
        -:  314:
    #####:  315:      unsigned snapshotBeforeIntersect = simplex.getSnapshot();
call    0 never executed
    #####:  316:      simplex.intersectIntegerRelation(sI);
call    0 never executed
        -:  317:
    #####:  318:      if (simplex.isEmpty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  319:        // b /\ s_i is empty, so b \ s_i = b. We move directly to i + 1.
        -:  320:        // We are ignoring level i completely, so we restore the state
        -:  321:        // *before* going to the next level.
    #####:  322:        b.truncate(initBCounts);
call    0 never executed
    #####:  323:        simplex.rollback(initialSnapshot);
call    0 never executed
        -:  324:        // Recurse. We haven't processed any inequalities and
        -:  325:        // we don't need to process anything when we return.
        -:  326:        //
        -:  327:        // TODO: consider supporting tail recursion directly if this becomes
        -:  328:        // relevant for performance.
    #####:  329:        frames.push_back(Frame{initialSnapshot, initBCounts, sI,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  330:                               /*ineqsToProcess=*/{},
        -:  331:                               /*lastIneqProcessed=*/{}});
    #####:  332:        ++level;
    #####:  333:        continue;
call    0 never executed
        -:  334:      }
        -:  335:
        -:  336:      // Equalities are added to simplex as a pair of inequalities.
    #####:  337:      unsigned totalNewSimplexInequalities =
call    0 never executed
    #####:  338:          2 * sI.getNumEqualities() + sI.getNumInequalities();
call    0 never executed
        -:  339:      // Look for redundant constraints among the constraints of sI. We don't
        -:  340:      // care about redundant constraints in `b` at this point.
        -:  341:      //
        -:  342:      // When there are two copies of a constraint in `simplex`, i.e., among the
        -:  343:      // constraints of `b` and `sI`, only one of them can be marked redundant.
        -:  344:      // (Assuming no other constraint makes these redundant.)
        -:  345:      //
        -:  346:      // In a case where there is one copy in `b` and one in `sI`, we want the
        -:  347:      // one in `sI` to be marked, not the one in `b`. Therefore, it's not
        -:  348:      // enough to ignore the constraints of `b` when checking which
        -:  349:      // constraints `detectRedundant` has marked redundant; we explicitly tell
        -:  350:      // `detectRedundant` to only mark constraints from `sI` as being
        -:  351:      // redundant.
    #####:  352:      simplex.detectRedundant(offset, totalNewSimplexInequalities);
    #####:  353:      for (unsigned j = 0; j < totalNewSimplexInequalities; j++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  354:        canIgnoreIneq[j] = simplex.isMarkedRedundant(offset + j);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  355:      simplex.rollback(snapshotBeforeIntersect);
call    0 never executed
        -:  356:
    #####:  357:      SmallVector<unsigned, 8> ineqsToProcess;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  358:      ineqsToProcess.reserve(totalNewSimplexInequalities);
branch  0 never executed
branch  1 never executed
    #####:  359:      for (unsigned i = 0; i < totalNewSimplexInequalities; ++i)
branch  0 never executed
branch  1 never executed
    #####:  360:        if (!canIgnoreIneq[i])
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  361:          ineqsToProcess.push_back(i);
call    0 never executed
        -:  362:
    #####:  363:      if (ineqsToProcess.empty()) {
branch  0 never executed
branch  1 never executed
        -:  364:        // Nothing to process; return. (we have no frame to pop.)
    #####:  365:        level = frames.size();
branch  0 never executed
branch  1 never executed
    #####:  366:        continue;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  367:      }
        -:  368:
    #####:  369:      unsigned simplexSnapshot = simplex.getSnapshot();
call    0 never executed
    #####:  370:      IntegerRelation::CountsSnapshot bCounts = b.getCounts();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:      frames.push_back(Frame{simplexSnapshot, bCounts, sI, ineqsToProcess,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
        -:  372:                             /*lastIneqProcessed=*/llvm::None});
        -:  373:      // We have completed the initial setup for this level.
        -:  374:      // Fallthrough to the main recursive part below.
        -:  375:    }
        -:  376:
        -:  377:    // For each inequality ineq, we first recurse with the part where ineq
        -:  378:    // is not satisfied, and then add ineq to b and simplex because
        -:  379:    // ineq must be satisfied by all later parts.
    #####:  380:    if (level == frames.size()) {
branch  0 never executed
branch  1 never executed
    #####:  381:      Frame &frame = frames.back();
call    0 never executed
    #####:  382:      if (frame.lastIneqProcessed) {
branch  0 never executed
branch  1 never executed
        -:  383:        // Let the current value of b be b' and
        -:  384:        // let the initial value of b when we first came to this level be b.
        -:  385:        //
        -:  386:        // b' is equal to b /\ s_i1 /\ s_i2 /\ ... /\ s_i{j-1} /\ ~s_ij.
        -:  387:        // We had previously recursed with the part where s_ij was not
        -:  388:        // satisfied; all further parts satisfy s_ij, so we rollback to the
        -:  389:        // state before adding this complement constraint, and add s_ij to b.
    #####:  390:        simplex.rollback(frame.simplexSnapshot);
call    0 never executed
    #####:  391:        b.truncate(frame.bCounts);
call    0 never executed
    #####:  392:        SmallVector<MPInt, 8> ineq =
    #####:  393:            getIneqCoeffsFromIdx(frame.sI, *frame.lastIneqProcessed);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  394:        b.addInequality(ineq);
call    0 never executed
    #####:  395:        simplex.addInequality(ineq);
call    0 never executed
call    1 never executed
        -:  396:      }
        -:  397:
    #####:  398:      if (frame.ineqsToProcess.empty()) {
branch  0 never executed
branch  1 never executed
        -:  399:        // No ineqs left to process; pop this level's frame and return.
    #####:  400:        frames.pop_back();
call    0 never executed
    #####:  401:        level = frames.size();
    #####:  402:        continue;
        -:  403:      }
        -:  404:
        -:  405:      // "Recurse" with the part where the ineq is not satisfied.
    #####:  406:      frame.bCounts = b.getCounts();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  407:      frame.simplexSnapshot = simplex.getSnapshot();
call    0 never executed
        -:  408:
    #####:  409:      unsigned idx = frame.ineqsToProcess.back();
call    0 never executed
    #####:  410:      SmallVector<MPInt, 8> ineq =
    #####:  411:          getComplementIneq(getIneqCoeffsFromIdx(frame.sI, idx));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  412:      b.addInequality(ineq);
call    0 never executed
    #####:  413:      simplex.addInequality(ineq);
call    0 never executed
        -:  414:
    #####:  415:      frame.ineqsToProcess.pop_back();
call    0 never executed
    #####:  416:      frame.lastIneqProcessed = idx;
branch  0 never executed
branch  1 never executed
    #####:  417:      ++level;
    #####:  418:      continue;
call    0 never executed
        -:  419:    }
        -:  420:  }
        -:  421:
    #####:  422:  return result;
call    0 never executed
        -:  423:}
        -:  424:
        -:  425:/// Return the complement of this set.
function _ZNK4mlir10presburger18PresburgerRelation10complementEv called 0 returned 0% blocks executed 0%
    #####:  426:PresburgerRelation PresburgerRelation::complement() const {
    #####:  427:  return getSetDifference(IntegerRelation::getUniverse(getSpace()), *this);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  428:}
        -:  429:
        -:  430:/// Return the result of subtract the given set from this set, i.e.,
        -:  431:/// return `this \ set`.
        -:  432:PresburgerRelation
function _ZNK4mlir10presburger18PresburgerRelation8subtractERKS1_ called 0 returned 0% blocks executed 0%
    #####:  433:PresburgerRelation::subtract(const PresburgerRelation &set) const {
    #####:  434:  assert(space.isCompatible(set.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  435:  PresburgerRelation result(getSpace());
call    0 never executed
        -:  436:  // We compute (U_i t_i) \ (U_i set_i) as U_i (t_i \ V_i set_i).
    #####:  437:  for (const IntegerRelation &disjunct : disjuncts)
branch  0 never executed
branch  1 never executed
    #####:  438:    result.unionInPlace(getSetDifference(disjunct, set));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  439:  return result;
        -:  440:}
        -:  441:
        -:  442:/// T is a subset of S iff T \ S is empty, since if T \ S contains a
        -:  443:/// point then this is a point that is contained in T but not S, and
        -:  444:/// if T contains a point that is not in S, this also lies in T \ S.
function _ZNK4mlir10presburger18PresburgerRelation10isSubsetOfERKS1_ called 0 returned 0% blocks executed 0%
    #####:  445:bool PresburgerRelation::isSubsetOf(const PresburgerRelation &set) const {
    #####:  446:  return this->subtract(set).isIntegerEmpty();
call    0 never executed
call    1 never executed
        -:  447:}
        -:  448:
        -:  449:/// Two sets are equal iff they are subsets of each other.
function _ZNK4mlir10presburger18PresburgerRelation7isEqualERKS1_ called 0 returned 0% blocks executed 0%
    #####:  450:bool PresburgerRelation::isEqual(const PresburgerRelation &set) const {
    #####:  451:  assert(space.isCompatible(set.getSpace()) && "Spaces should match");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  452:  return this->isSubsetOf(set) && set.isSubsetOf(*this);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  453:}
        -:  454:
        -:  455:/// Return true if all the sets in the union are known to be integer empty,
        -:  456:/// false otherwise.
function _ZNK4mlir10presburger18PresburgerRelation14isIntegerEmptyEv called 0 returned 0% blocks executed 0%
    #####:  457:bool PresburgerRelation::isIntegerEmpty() const {
        -:  458:  // The set is empty iff all of the disjuncts are empty.
    #####:  459:  return llvm::all_of(disjuncts, std::mem_fn(&IntegerRelation::isIntegerEmpty));
call    0 never executed
call    1 never executed
        -:  460:}
        -:  461:
function _ZN4mlir10presburger18PresburgerRelation17findIntegerSampleERN4llvm15SmallVectorImplINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  462:bool PresburgerRelation::findIntegerSample(SmallVectorImpl<MPInt> &sample) {
        -:  463:  // A sample exists iff any of the disjuncts contains a sample.
    #####:  464:  for (const IntegerRelation &disjunct : disjuncts) {
branch  0 never executed
branch  1 never executed
    #####:  465:    if (Optional<SmallVector<MPInt, 8>> opt = disjunct.findIntegerSample()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  466:      sample = std::move(*opt);
call    0 never executed
    #####:  467:      return true;
branch  0 never executed
branch  1 never executed
        -:  468:    }
        -:  469:  }
        -:  470:  return false;
        -:  471:}
        -:  472:
function _ZNK4mlir10presburger18PresburgerRelation13computeVolumeEv called 0 returned 0% blocks executed 0%
    #####:  473:Optional<MPInt> PresburgerRelation::computeVolume() const {
    #####:  474:  assert(getNumSymbolVars() == 0 && "Symbols are not yet supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  475:  // The sum of the volumes of the disjuncts is a valid overapproximation of the
        -:  476:  // volume of their union, even if they overlap.
    #####:  477:  MPInt result(0);
    #####:  478:  for (const IntegerRelation &disjunct : disjuncts) {
branch  0 never executed
branch  1 never executed
    #####:  479:    Optional<MPInt> volume = disjunct.computeVolume();
call    0 never executed
    #####:  480:    if (!volume)
branch  0 never executed
branch  1 never executed
    #####:  481:      return {};
call    0 never executed
    #####:  482:    result += *volume;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  483:  }
    #####:  484:  return result;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  485:}
        -:  486:
        -:  487:/// The SetCoalescer class contains all functionality concerning the coalesce
        -:  488:/// heuristic. It is built from a `PresburgerRelation` and has the `coalesce()`
        -:  489:/// function as its main API. The coalesce heuristic simplifies the
        -:  490:/// representation of a PresburgerRelation. In particular, it removes all
        -:  491:/// disjuncts which are subsets of other disjuncts in the union and it combines
        -:  492:/// sets that overlap and can be combined in a convex way.
        -:  493:class presburger::SetCoalescer {
        -:  494:
        -:  495:public:
        -:  496:  /// Simplifies the representation of a PresburgerSet.
        -:  497:  PresburgerRelation coalesce();
        -:  498:
        -:  499:  /// Construct a SetCoalescer from a PresburgerSet.
        -:  500:  SetCoalescer(const PresburgerRelation &s);
        -:  501:
        -:  502:private:
        -:  503:  /// The space of the set the SetCoalescer is coalescing.
        -:  504:  PresburgerSpace space;
        -:  505:
        -:  506:  /// The current list of `IntegerRelation`s that the currently coalesced set is
        -:  507:  /// the union of.
        -:  508:  SmallVector<IntegerRelation, 2> disjuncts;
        -:  509:  /// The list of `Simplex`s constructed from the elements of `disjuncts`.
        -:  510:  SmallVector<Simplex, 2> simplices;
        -:  511:
        -:  512:  /// The list of all inversed equalities during typing. This ensures that
        -:  513:  /// the constraints exist even after the typing function has concluded.
        -:  514:  SmallVector<SmallVector<MPInt, 2>, 2> negEqs;
        -:  515:
        -:  516:  /// `redundantIneqsA` is the inequalities of `a` that are redundant for `b`
        -:  517:  /// (similarly for `cuttingIneqsA`, `redundantIneqsB`, and `cuttingIneqsB`).
        -:  518:  SmallVector<ArrayRef<MPInt>, 2> redundantIneqsA;
        -:  519:  SmallVector<ArrayRef<MPInt>, 2> cuttingIneqsA;
        -:  520:
        -:  521:  SmallVector<ArrayRef<MPInt>, 2> redundantIneqsB;
        -:  522:  SmallVector<ArrayRef<MPInt>, 2> cuttingIneqsB;
        -:  523:
        -:  524:  /// Given a Simplex `simp` and one of its inequalities `ineq`, check
        -:  525:  /// that the facet of `simp` where `ineq` holds as an equality is contained
        -:  526:  /// within `a`.
        -:  527:  bool isFacetContained(ArrayRef<MPInt> ineq, Simplex &simp);
        -:  528:
        -:  529:  /// Removes redundant constraints from `disjunct`, adds it to `disjuncts` and
        -:  530:  /// removes the disjuncts at position `i` and `j`. Updates `simplices` to
        -:  531:  /// reflect the changes. `i` and `j` cannot be equal.
        -:  532:  void addCoalescedDisjunct(unsigned i, unsigned j,
        -:  533:                            const IntegerRelation &disjunct);
        -:  534:
        -:  535:  /// Checks whether `a` and `b` can be combined in a convex sense, if there
        -:  536:  /// exist cutting inequalities.
        -:  537:  ///
        -:  538:  /// An example of this case:
        -:  539:  ///    ___________        ___________
        -:  540:  ///   /   /  |   /       /          /
        -:  541:  ///   \   \  |  /   ==>  \         /
        -:  542:  ///    \   \ | /          \       /
        -:  543:  ///     \___\|/            \_____/
        -:  544:  ///
        -:  545:  ///
        -:  546:  LogicalResult coalescePairCutCase(unsigned i, unsigned j);
        -:  547:
        -:  548:  /// Types the inequality `ineq` according to its `IneqType` for `simp` into
        -:  549:  /// `redundantIneqsB` and `cuttingIneqsB`. Returns success, if no separate
        -:  550:  /// inequalities were encountered. Otherwise, returns failure.
        -:  551:  LogicalResult typeInequality(ArrayRef<MPInt> ineq, Simplex &simp);
        -:  552:
        -:  553:  /// Types the equality `eq`, i.e. for `eq` == 0, types both `eq` >= 0 and
        -:  554:  /// -`eq` >= 0 according to their `IneqType` for `simp` into
        -:  555:  /// `redundantIneqsB` and `cuttingIneqsB`. Returns success, if no separate
        -:  556:  /// inequalities were encountered. Otherwise, returns failure.
        -:  557:  LogicalResult typeEquality(ArrayRef<MPInt> eq, Simplex &simp);
        -:  558:
        -:  559:  /// Replaces the element at position `i` with the last element and erases
        -:  560:  /// the last element for both `disjuncts` and `simplices`.
        -:  561:  void eraseDisjunct(unsigned i);
        -:  562:
        -:  563:  /// Attempts to coalesce the two IntegerRelations at position `i` and `j`
        -:  564:  /// in `disjuncts` in-place. Returns whether the disjuncts were
        -:  565:  /// successfully coalesced. The simplices in `simplices` need to be the ones
        -:  566:  /// constructed from `disjuncts`. At this point, there are no empty
        -:  567:  /// disjuncts in `disjuncts` left.
        -:  568:  LogicalResult coalescePair(unsigned i, unsigned j);
        -:  569:};
        -:  570:
        -:  571:/// Constructs a `SetCoalescer` from a `PresburgerRelation`. Only adds non-empty
        -:  572:/// `IntegerRelation`s to the `disjuncts` vector.
function _ZN4mlir10presburger12SetCoalescerC2ERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  573:SetCoalescer::SetCoalescer(const PresburgerRelation &s) : space(s.getSpace()) {
call    0 never executed
call    1 never executed
        -:  574:
    #####:  575:  disjuncts = s.disjuncts;
call    0 never executed
        -:  576:
    #####:  577:  simplices.reserve(s.getNumDisjuncts());
branch  0 never executed
branch  1 never executed
        -:  578:  // Note that disjuncts.size() changes during the loop.
    #####:  579:  for (unsigned i = 0; i < disjuncts.size();) {
branch  0 never executed
branch  1 never executed
    #####:  580:    disjuncts[i].removeRedundantConstraints();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  581:    Simplex simp(disjuncts[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  582:    if (simp.isEmpty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  583:      disjuncts[i] = disjuncts[disjuncts.size() - 1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  584:      disjuncts.pop_back();
call    0 never executed
    #####:  585:      continue;
call    0 never executed
        -:  586:    }
    #####:  587:    ++i;
    #####:  588:    simplices.push_back(simp);
call    0 never executed
call    1 never executed
        -:  589:  }
    #####:  590:}
        -:  591:
        -:  592:/// Simplifies the representation of a PresburgerSet.
function _ZN4mlir10presburger12SetCoalescer8coalesceEv called 0 returned 0% blocks executed 0%
    #####:  593:PresburgerRelation SetCoalescer::coalesce() {
        -:  594:  // For all tuples of IntegerRelations, check whether they can be
        -:  595:  // coalesced. When coalescing is successful, the contained IntegerRelation
        -:  596:  // is swapped with the last element of `disjuncts` and subsequently erased
        -:  597:  // and similarly for simplices.
    #####:  598:  for (unsigned i = 0; i < disjuncts.size();) {
branch  0 never executed
branch  1 never executed
        -:  599:
        -:  600:    // TODO: This does some comparisons two times (index 0 with 1 and index 1
        -:  601:    // with 0).
    #####:  602:    bool broken = false;
    #####:  603:    for (unsigned j = 0, e = disjuncts.size(); j < e; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  604:      negEqs.clear();
    #####:  605:      redundantIneqsA.clear();
branch  0 never executed
branch  1 never executed
    #####:  606:      redundantIneqsB.clear();
    #####:  607:      cuttingIneqsA.clear();
    #####:  608:      cuttingIneqsB.clear();
    #####:  609:      if (i == j)
branch  0 never executed
branch  1 never executed
    #####:  610:        continue;
    #####:  611:      if (coalescePair(i, j).succeeded()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  612:        broken = true;
        -:  613:        break;
        -:  614:      }
        -:  615:    }
        -:  616:
        -:  617:    // Only if the inner loop was not broken, i is incremented. This is
        -:  618:    // required as otherwise, if a coalescing occurs, the IntegerRelation
        -:  619:    // now at position i is not compared.
    #####:  620:    if (!broken)
branch  0 never executed
branch  1 never executed
    #####:  621:      ++i;
        -:  622:  }
        -:  623:
    #####:  624:  PresburgerRelation newSet = PresburgerRelation::getEmpty(space);
call    0 never executed
    #####:  625:  for (unsigned i = 0, e = disjuncts.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  626:    newSet.unionInPlace(disjuncts[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  627:
    #####:  628:  return newSet;
        -:  629:}
        -:  630:
        -:  631:/// Given a Simplex `simp` and one of its inequalities `ineq`, check
        -:  632:/// that all inequalities of `cuttingIneqsB` are redundant for the facet of
        -:  633:/// `simp` where `ineq` holds as an equality is contained within `a`.
function _ZN4mlir10presburger12SetCoalescer16isFacetContainedEN4llvm8ArrayRefINS0_5MPIntEEERNS0_7SimplexE called 0 returned 0% blocks executed 0%
    #####:  634:bool SetCoalescer::isFacetContained(ArrayRef<MPInt> ineq, Simplex &simp) {
    #####:  635:  SimplexRollbackScopeExit scopeExit(simp);
call    0 never executed
    #####:  636:  simp.addEquality(ineq);
call    0 never executed
    #####:  637:  return llvm::all_of(cuttingIneqsB, [&simp](ArrayRef<MPInt> curr) {
call    0 never executed
call    1 never executed
        -:  638:    return simp.isRedundantInequality(curr);
    #####:  639:  });
        -:  640:}
        -:  641:
function _ZN4mlir10presburger12SetCoalescer20addCoalescedDisjunctEjjRKNS0_15IntegerRelationE called 0 returned 0% blocks executed 0%
    #####:  642:void SetCoalescer::addCoalescedDisjunct(unsigned i, unsigned j,
        -:  643:                                        const IntegerRelation &disjunct) {
    #####:  644:  assert(i != j && "The indices must refer to different disjuncts");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  645:  unsigned n = disjuncts.size();
branch  0 never executed
branch  1 never executed
    #####:  646:  if (j == n - 1) {
branch  0 never executed
branch  1 never executed
        -:  647:    // This case needs special handling since position `n` - 1 is removed
        -:  648:    // from the vector, hence the `IntegerRelation` at position `n` - 2 is
        -:  649:    // lost otherwise.
    #####:  650:    disjuncts[i] = disjuncts[n - 2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  651:    disjuncts.pop_back();
call    0 never executed
    #####:  652:    disjuncts[n - 2] = disjunct;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  653:    disjuncts[n - 2].removeRedundantConstraints();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  654:
    #####:  655:    simplices[i] = simplices[n - 2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  656:    simplices.pop_back();
call    0 never executed
    #####:  657:    simplices[n - 2] = Simplex(disjuncts[n - 2]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  658:
        -:  659:  } else {
        -:  660:    // Other possible edge cases are correct since for `j` or `i` == `n` -
        -:  661:    // 2, the `IntegerRelation` at position `n` - 2 should be lost. The
        -:  662:    // case `i` == `n` - 1 makes the first following statement a noop.
        -:  663:    // Hence, in this case the same thing is done as above, but with `j`
        -:  664:    // rather than `i`.
    #####:  665:    disjuncts[i] = disjuncts[n - 1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  666:    disjuncts[j] = disjuncts[n - 2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  667:    disjuncts.pop_back();
call    0 never executed
    #####:  668:    disjuncts[n - 2] = disjunct;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  669:    disjuncts[n - 2].removeRedundantConstraints();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  670:
    #####:  671:    simplices[i] = simplices[n - 1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  672:    simplices[j] = simplices[n - 2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  673:    simplices.pop_back();
call    0 never executed
    #####:  674:    simplices[n - 2] = Simplex(disjuncts[n - 2]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  675:  }
    #####:  676:}
        -:  677:
        -:  678:/// Given two polyhedra `a` and `b` at positions `i` and `j` in
        -:  679:/// `disjuncts` and `redundantIneqsA` being the inequalities of `a` that
        -:  680:/// are redundant for `b` (similarly for `cuttingIneqsA`, `redundantIneqsB`,
        -:  681:/// and `cuttingIneqsB`), Checks whether the facets of all cutting
        -:  682:/// inequalites of `a` are contained in `b`. If so, a new polyhedron
        -:  683:/// consisting of all redundant inequalites of `a` and `b` and all
        -:  684:/// equalities of both is created.
        -:  685:///
        -:  686:/// An example of this case:
        -:  687:///    ___________        ___________
        -:  688:///   /   /  |   /       /          /
        -:  689:///   \   \  |  /   ==>  \         /
        -:  690:///    \   \ | /          \       /
        -:  691:///     \___\|/            \_____/
        -:  692:///
        -:  693:///
function _ZN4mlir10presburger12SetCoalescer19coalescePairCutCaseEjj called 0 returned 0% blocks executed 0%
    #####:  694:LogicalResult SetCoalescer::coalescePairCutCase(unsigned i, unsigned j) {
        -:  695:  /// All inequalities of `b` need to be redundant. We already know that the
        -:  696:  /// redundant ones are, so only the cutting ones remain to be checked.
    #####:  697:  Simplex &simp = simplices[i];
branch  0 never executed
branch  1 never executed
    #####:  698:  IntegerRelation &disjunct = disjuncts[i];
branch  0 never executed
branch  1 never executed
    #####:  699:  if (llvm::any_of(cuttingIneqsA, [this, &simp](ArrayRef<MPInt> curr) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  700:        return !isFacetContained(curr, simp);
        -:  701:      }))
    #####:  702:    return failure();
    #####:  703:  IntegerRelation newSet(disjunct.getSpace());
call    0 never executed
call    1 never executed
        -:  704:
    #####:  705:  for (ArrayRef<MPInt> curr : redundantIneqsA)
branch  0 never executed
branch  1 never executed
    #####:  706:    newSet.addInequality(curr);
call    0 never executed
        -:  707:
    #####:  708:  for (ArrayRef<MPInt> curr : redundantIneqsB)
branch  0 never executed
branch  1 never executed
    #####:  709:    newSet.addInequality(curr);
call    0 never executed
        -:  710:
    #####:  711:  addCoalescedDisjunct(i, j, newSet);
call    0 never executed
    #####:  712:  return success();
call    0 never executed
        -:  713:}
        -:  714:
function _ZN4mlir10presburger12SetCoalescer14typeInequalityEN4llvm8ArrayRefINS0_5MPIntEEERNS0_7SimplexE called 0 returned 0% blocks executed 0%
    #####:  715:LogicalResult SetCoalescer::typeInequality(ArrayRef<MPInt> ineq,
        -:  716:                                           Simplex &simp) {
    #####:  717:  Simplex::IneqType type = simp.findIneqType(ineq);
call    0 never executed
    #####:  718:  if (type == Simplex::IneqType::Redundant)
branch  0 never executed
branch  1 never executed
    #####:  719:    redundantIneqsB.push_back(ineq);
call    0 never executed
    #####:  720:  else if (type == Simplex::IneqType::Cut)
branch  0 never executed
branch  1 never executed
    #####:  721:    cuttingIneqsB.push_back(ineq);
call    0 never executed
        -:  722:  else
    #####:  723:    return failure();
    #####:  724:  return success();
        -:  725:}
        -:  726:
function _ZN4mlir10presburger12SetCoalescer12typeEqualityEN4llvm8ArrayRefINS0_5MPIntEEERNS0_7SimplexE called 0 returned 0% blocks executed 0%
    #####:  727:LogicalResult SetCoalescer::typeEquality(ArrayRef<MPInt> eq, Simplex &simp) {
    #####:  728:  if (typeInequality(eq, simp).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  729:    return failure();
    #####:  730:  negEqs.push_back(getNegatedCoeffs(eq));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  731:  ArrayRef<MPInt> inv(negEqs.back());
call    0 never executed
call    1 never executed
    #####:  732:  if (typeInequality(inv, simp).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  733:    return failure();
    #####:  734:  return success();
        -:  735:}
        -:  736:
function _ZN4mlir10presburger12SetCoalescer13eraseDisjunctEj called 0 returned 0% blocks executed 0%
    #####:  737:void SetCoalescer::eraseDisjunct(unsigned i) {
    #####:  738:  assert(simplices.size() == disjuncts.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  739:         "simplices and disjuncts must be equally as long");
    #####:  740:  disjuncts[i] = disjuncts.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  741:  disjuncts.pop_back();
call    0 never executed
    #####:  742:  simplices[i] = simplices.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  743:  simplices.pop_back();
call    0 never executed
    #####:  744:}
        -:  745:
function _ZN4mlir10presburger12SetCoalescer12coalescePairEjj called 0 returned 0% blocks executed 0%
    #####:  746:LogicalResult SetCoalescer::coalescePair(unsigned i, unsigned j) {
        -:  747:
    #####:  748:  IntegerRelation &a = disjuncts[i];
branch  0 never executed
branch  1 never executed
    #####:  749:  IntegerRelation &b = disjuncts[j];
branch  0 never executed
branch  1 never executed
        -:  750:  /// Handling of local ids is not yet implemented, so these cases are
        -:  751:  /// skipped.
        -:  752:  /// TODO: implement local id support.
    #####:  753:  if (a.getNumLocalVars() != 0 || b.getNumLocalVars() != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  754:    return failure();
    #####:  755:  Simplex &simpA = simplices[i];
branch  0 never executed
branch  1 never executed
    #####:  756:  Simplex &simpB = simplices[j];
branch  0 never executed
branch  1 never executed
        -:  757:
        -:  758:  // Organize all inequalities and equalities of `a` according to their type
        -:  759:  // for `b` into `redundantIneqsA` and `cuttingIneqsA` (and vice versa for
        -:  760:  // all inequalities of `b` according to their type in `a`). If a separate
        -:  761:  // inequality is encountered during typing, the two IntegerRelations
        -:  762:  // cannot be coalesced.
    #####:  763:  for (int k = 0, e = a.getNumInequalities(); k < e; ++k)
branch  0 never executed
branch  1 never executed
    #####:  764:    if (typeInequality(a.getInequality(k), simpB).failed())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  765:      return failure();
        -:  766:
    #####:  767:  for (int k = 0, e = a.getNumEqualities(); k < e; ++k)
branch  0 never executed
branch  1 never executed
    #####:  768:    if (typeEquality(a.getEquality(k), simpB).failed())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  769:      return failure();
        -:  770:
    #####:  771:  std::swap(redundantIneqsA, redundantIneqsB);
call    0 never executed
    #####:  772:  std::swap(cuttingIneqsA, cuttingIneqsB);
call    0 never executed
        -:  773:
    #####:  774:  for (int k = 0, e = b.getNumInequalities(); k < e; ++k)
branch  0 never executed
branch  1 never executed
    #####:  775:    if (typeInequality(b.getInequality(k), simpA).failed())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  776:      return failure();
        -:  777:
    #####:  778:  for (int k = 0, e = b.getNumEqualities(); k < e; ++k)
branch  0 never executed
branch  1 never executed
    #####:  779:    if (typeEquality(b.getEquality(k), simpA).failed())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  780:      return failure();
        -:  781:
        -:  782:  // If there are no cutting inequalities of `a`, `b` is contained
        -:  783:  // within `a`.
    #####:  784:  if (cuttingIneqsA.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  785:    eraseDisjunct(j);
call    0 never executed
    #####:  786:    return success();
        -:  787:  }
        -:  788:
        -:  789:  // Try to apply the cut case
    #####:  790:  if (coalescePairCutCase(i, j).succeeded())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  791:    return success();
        -:  792:
        -:  793:  // Swap the vectors to compare the pair (j,i) instead of (i,j).
    #####:  794:  std::swap(redundantIneqsA, redundantIneqsB);
call    0 never executed
    #####:  795:  std::swap(cuttingIneqsA, cuttingIneqsB);
call    0 never executed
        -:  796:
        -:  797:  // If there are no cutting inequalities of `a`, `b` is contained
        -:  798:  // within `a`.
    #####:  799:  if (cuttingIneqsA.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  800:    eraseDisjunct(i);
call    0 never executed
    #####:  801:    return success();
        -:  802:  }
        -:  803:
        -:  804:  // Try to apply the cut case
    #####:  805:  if (coalescePairCutCase(j, i).succeeded())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  806:    return success();
        -:  807:
    #####:  808:  return failure();
        -:  809:}
        -:  810:
function _ZNK4mlir10presburger18PresburgerRelation8coalesceEv called 0 returned 0% blocks executed 0%
    #####:  811:PresburgerRelation PresburgerRelation::coalesce() const {
    #####:  812:  return SetCoalescer(*this).coalesce();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  813:}
        -:  814:
function _ZNK4mlir10presburger18PresburgerRelation16hasOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####:  815:bool PresburgerRelation::hasOnlyDivLocals() const {
    #####:  816:  return llvm::all_of(disjuncts, [](const IntegerRelation &rel) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  817:    return rel.hasOnlyDivLocals();
    #####:  818:  });
        -:  819:}
        -:  820:
function _ZNK4mlir10presburger18PresburgerRelation5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  821:void PresburgerRelation::print(raw_ostream &os) const {
    #####:  822:  os << "Number of Disjuncts: " << getNumDisjuncts() << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  823:  for (const IntegerRelation &disjunct : disjuncts) {
branch  0 never executed
branch  1 never executed
    #####:  824:    disjunct.print(os);
call    0 never executed
    #####:  825:    os << '\n';
branch  0 never executed
branch  1 never executed
        -:  826:  }
    #####:  827:}
        -:  828:
function _ZNK4mlir10presburger18PresburgerRelation4dumpEv called 0 returned 0% blocks executed 0%
    #####:  829:void PresburgerRelation::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -:  830:
function _ZN4mlir10presburger13PresburgerSet11getUniverseERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:  831:PresburgerSet PresburgerSet::getUniverse(const PresburgerSpace &space) {
    #####:  832:  PresburgerSet result(space);
call    0 never executed
    #####:  833:  result.unionInPlace(IntegerPolyhedron::getUniverse(space));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  834:  return result;
        -:  835:}
        -:  836:
function _ZN4mlir10presburger13PresburgerSet8getEmptyERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:  837:PresburgerSet PresburgerSet::getEmpty(const PresburgerSpace &space) {
    #####:  838:  return PresburgerSet(space);
call    0 never executed
        -:  839:}
        -:  840:
function _ZN4mlir10presburger13PresburgerSetC2ERKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####:  841:PresburgerSet::PresburgerSet(const IntegerPolyhedron &disjunct)
    #####:  842:    : PresburgerRelation(disjunct) {}
call    0 never executed
        -:  843:
function _ZN4mlir10presburger13PresburgerSetC2ERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  844:PresburgerSet::PresburgerSet(const PresburgerRelation &set)
    #####:  845:    : PresburgerRelation(set) {}
call    0 never executed
        -:  846:
function _ZNK4mlir10presburger13PresburgerSet8unionSetERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  847:PresburgerSet PresburgerSet::unionSet(const PresburgerRelation &set) const {
    #####:  848:  return PresburgerSet(PresburgerRelation::unionSet(set));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  849:}
        -:  850:
function _ZNK4mlir10presburger13PresburgerSet9intersectERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  851:PresburgerSet PresburgerSet::intersect(const PresburgerRelation &set) const {
    #####:  852:  return PresburgerSet(PresburgerRelation::intersect(set));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  853:}
        -:  854:
function _ZNK4mlir10presburger13PresburgerSet10complementEv called 0 returned 0% blocks executed 0%
    #####:  855:PresburgerSet PresburgerSet::complement() const {
    #####:  856:  return PresburgerSet(PresburgerRelation::complement());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  857:}
        -:  858:
function _ZNK4mlir10presburger13PresburgerSet8subtractERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  859:PresburgerSet PresburgerSet::subtract(const PresburgerRelation &set) const {
    #####:  860:  return PresburgerSet(PresburgerRelation::subtract(set));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  861:}
        -:  862:
function _ZNK4mlir10presburger13PresburgerSet8coalesceEv called 0 returned 0% blocks executed 0%
    #####:  863:PresburgerSet PresburgerSet::coalesce() const {
    #####:  864:  return PresburgerSet(PresburgerRelation::coalesce());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  865:}
