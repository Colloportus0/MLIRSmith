        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/llvm/include/llvm/Support/CommandLine.h
        -:    0:Graph:../tools/mlir/lib/Tools/mlir-opt/CMakeFiles/obj.MLIROptLib.dir/MlirOptMain.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Tools/mlir-opt/CMakeFiles/obj.MLIROptLib.dir/MlirOptMain.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This class implements a command line argument processor that is useful when
        -:   10:// creating a tool.  It provides a simple, minimalistic interface that is easily
        -:   11:// extensible and supports nonlocal (library) command line options.
        -:   12://
        -:   13:// Note that rather than trying to figure out what this code does, you should
        -:   14:// read the library documentation located in docs/CommandLine.html or looks at
        -:   15:// the many example usages in tools/*/*.cpp
        -:   16://
        -:   17://===----------------------------------------------------------------------===//
        -:   18:
        -:   19:#ifndef LLVM_SUPPORT_COMMANDLINE_H
        -:   20:#define LLVM_SUPPORT_COMMANDLINE_H
        -:   21:
        -:   22:#include "llvm/ADT/ArrayRef.h"
        -:   23:#include "llvm/ADT/None.h"
        -:   24:#include "llvm/ADT/Optional.h"
        -:   25:#include "llvm/ADT/STLExtras.h"
        -:   26:#include "llvm/ADT/SmallPtrSet.h"
        -:   27:#include "llvm/ADT/SmallVector.h"
        -:   28:#include "llvm/ADT/StringMap.h"
        -:   29:#include "llvm/ADT/StringRef.h"
        -:   30:#include "llvm/ADT/Twine.h"
        -:   31:#include "llvm/ADT/iterator_range.h"
        -:   32:#include "llvm/Support/ErrorHandling.h"
        -:   33:#include "llvm/Support/ManagedStatic.h"
        -:   34:#include "llvm/Support/StringSaver.h"
        -:   35:#include "llvm/Support/raw_ostream.h"
        -:   36:#include <cassert>
        -:   37:#include <climits>
        -:   38:#include <cstddef>
        -:   39:#include <functional>
        -:   40:#include <initializer_list>
        -:   41:#include <string>
        -:   42:#include <type_traits>
        -:   43:#include <vector>
        -:   44:
        -:   45:namespace llvm {
        -:   46:
        -:   47:namespace vfs {
        -:   48:class FileSystem;
        -:   49:}
        -:   50:
        -:   51:class StringSaver;
        -:   52:
        -:   53:/// This namespace contains all of the command line option processing machinery.
        -:   54:/// It is intentionally a short name to make qualified usage concise.
        -:   55:namespace cl {
        -:   56:
        -:   57://===----------------------------------------------------------------------===//
        -:   58:// Command line option processing entry point.
        -:   59://
        -:   60:// Returns true on success. Otherwise, this will print the error message to
        -:   61:// stderr and exit if \p Errs is not set (nullptr by default), or print the
        -:   62:// error message to \p Errs and return false if \p Errs is provided.
        -:   63://
        -:   64:// If EnvVar is not nullptr, command-line options are also parsed from the
        -:   65:// environment variable named by EnvVar.  Precedence is given to occurrences
        -:   66:// from argv.  This precedence is currently implemented by parsing argv after
        -:   67:// the environment variable, so it is only implemented correctly for options
        -:   68:// that give precedence to later occurrences.  If your program supports options
        -:   69:// that give precedence to earlier occurrences, you will need to extend this
        -:   70:// function to support it correctly.
        -:   71:bool ParseCommandLineOptions(int argc, const char *const *argv,
        -:   72:                             StringRef Overview = "",
        -:   73:                             raw_ostream *Errs = nullptr,
        -:   74:                             const char *EnvVar = nullptr,
        -:   75:                             bool LongOptionsUseDoubleDash = false);
        -:   76:
        -:   77:// Function pointer type for printing version information.
        -:   78:using VersionPrinterTy = std::function<void(raw_ostream &)>;
        -:   79:
        -:   80:///===---------------------------------------------------------------------===//
        -:   81:/// Override the default (LLVM specific) version printer used to print out the
        -:   82:/// version when --version is given on the command line. This allows other
        -:   83:/// systems using the CommandLine utilities to print their own version string.
        -:   84:void SetVersionPrinter(VersionPrinterTy func);
        -:   85:
        -:   86:///===---------------------------------------------------------------------===//
        -:   87:/// Add an extra printer to use in addition to the default one. This can be
        -:   88:/// called multiple times, and each time it adds a new function to the list
        -:   89:/// which will be called after the basic LLVM version printing is complete.
        -:   90:/// Each can then add additional information specific to the tool.
        -:   91:void AddExtraVersionPrinter(VersionPrinterTy func);
        -:   92:
        -:   93:// Print option values.
        -:   94:// With -print-options print the difference between option values and defaults.
        -:   95:// With -print-all-options print all option values.
        -:   96:// (Currently not perfect, but best-effort.)
        -:   97:void PrintOptionValues();
        -:   98:
        -:   99:// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.
        -:  100:class Option;
        -:  101:
        -:  102:/// Adds a new option for parsing and provides the option it refers to.
        -:  103:///
        -:  104:/// \param O pointer to the option
        -:  105:/// \param Name the string name for the option to handle during parsing
        -:  106:///
        -:  107:/// Literal options are used by some parsers to register special option values.
        -:  108:/// This is how the PassNameParser registers pass names for opt.
        -:  109:void AddLiteralOption(Option &O, StringRef Name);
        -:  110:
        -:  111://===----------------------------------------------------------------------===//
        -:  112:// Flags permitted to be passed to command line arguments
        -:  113://
        -:  114:
        -:  115:enum NumOccurrencesFlag { // Flags for the number of occurrences allowed
        -:  116:  Optional = 0x00,        // Zero or One occurrence
        -:  117:  ZeroOrMore = 0x01,      // Zero or more occurrences allowed
        -:  118:  Required = 0x02,        // One occurrence required
        -:  119:  OneOrMore = 0x03,       // One or more occurrences required
        -:  120:
        -:  121:  // Indicates that this option is fed anything that follows the last positional
        -:  122:  // argument required by the application (it is an error if there are zero
        -:  123:  // positional arguments, and a ConsumeAfter option is used).
        -:  124:  // Thus, for example, all arguments to LLI are processed until a filename is
        -:  125:  // found.  Once a filename is found, all of the succeeding arguments are
        -:  126:  // passed, unprocessed, to the ConsumeAfter option.
        -:  127:  //
        -:  128:  ConsumeAfter = 0x04
        -:  129:};
        -:  130:
        -:  131:enum ValueExpected { // Is a value required for the option?
        -:  132:  // zero reserved for the unspecified value
        -:  133:  ValueOptional = 0x01,  // The value can appear... or not
        -:  134:  ValueRequired = 0x02,  // The value is required to appear!
        -:  135:  ValueDisallowed = 0x03 // A value may not be specified (for flags)
        -:  136:};
        -:  137:
        -:  138:enum OptionHidden {   // Control whether -help shows this option
        -:  139:  NotHidden = 0x00,   // Option included in -help & -help-hidden
        -:  140:  Hidden = 0x01,      // -help doesn't, but -help-hidden does
        -:  141:  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg
        -:  142:};
        -:  143:
        -:  144:// This controls special features that the option might have that cause it to be
        -:  145:// parsed differently...
        -:  146://
        -:  147:// Prefix - This option allows arguments that are otherwise unrecognized to be
        -:  148:// matched by options that are a prefix of the actual value.  This is useful for
        -:  149:// cases like a linker, where options are typically of the form '-lfoo' or
        -:  150:// '-L../../include' where -l or -L are the actual flags.  When prefix is
        -:  151:// enabled, and used, the value for the flag comes from the suffix of the
        -:  152:// argument.
        -:  153://
        -:  154:// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject
        -:  155:// the Option=Value form.
        -:  156://
        -:  157:
        -:  158:enum FormattingFlags {
        -:  159:  NormalFormatting = 0x00, // Nothing special
        -:  160:  Positional = 0x01,       // Is a positional argument, no '-' required
        -:  161:  Prefix = 0x02,           // Can this option directly prefix its value?
        -:  162:  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?
        -:  163:};
        -:  164:
        -:  165:enum MiscFlags {             // Miscellaneous flags to adjust argument
        -:  166:  CommaSeparated = 0x01,     // Should this cl::list split between commas?
        -:  167:  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?
        -:  168:  Sink = 0x04,               // Should this cl::list eat all unknown options?
        -:  169:
        -:  170:  // Can this option group with other options?
        -:  171:  // If this is enabled, multiple letter options are allowed to bunch together
        -:  172:  // with only a single hyphen for the whole group.  This allows emulation
        -:  173:  // of the behavior that ls uses for example: ls -la === ls -l -a
        -:  174:  Grouping = 0x08,
        -:  175:
        -:  176:  // Default option
        -:  177:  DefaultOption = 0x10
        -:  178:};
        -:  179:
        -:  180://===----------------------------------------------------------------------===//
        -:  181://
        -:  182:class OptionCategory {
        -:  183:private:
        -:  184:  StringRef const Name;
        -:  185:  StringRef const Description;
        -:  186:
        -:  187:  void registerCategory();
        -:  188:
        -:  189:public:
        -:  190:  OptionCategory(StringRef const Name,
        -:  191:                 StringRef const Description = "")
        -:  192:      : Name(Name), Description(Description) {
        -:  193:    registerCategory();
        -:  194:  }
        -:  195:
        -:  196:  StringRef getName() const { return Name; }
        -:  197:  StringRef getDescription() const { return Description; }
        -:  198:};
        -:  199:
        -:  200:// The general Option Category (used as default category).
        -:  201:OptionCategory &getGeneralCategory();
        -:  202:
        -:  203://===----------------------------------------------------------------------===//
        -:  204://
        -:  205:class SubCommand {
        -:  206:private:
        -:  207:  StringRef Name;
        -:  208:  StringRef Description;
        -:  209:
        -:  210:protected:
        -:  211:  void registerSubCommand();
        -:  212:  void unregisterSubCommand();
        -:  213:
        -:  214:public:
        -:  215:  SubCommand(StringRef Name, StringRef Description = "")
        -:  216:      : Name(Name), Description(Description) {
        -:  217:        registerSubCommand();
        -:  218:  }
        -:  219:  SubCommand() = default;
        -:  220:
        -:  221:  // Get the special subcommand representing no subcommand.
        -:  222:  static SubCommand &getTopLevel();
        -:  223:
        -:  224:  // Get the special subcommand that can be used to put an option into all
        -:  225:  // subcomands.
        -:  226:  static SubCommand &getAll();
        -:  227:
        -:  228:  void reset();
        -:  229:
        -:  230:  explicit operator bool() const;
        -:  231:
        -:  232:  StringRef getName() const { return Name; }
        -:  233:  StringRef getDescription() const { return Description; }
        -:  234:
        -:  235:  SmallVector<Option *, 4> PositionalOpts;
        -:  236:  SmallVector<Option *, 4> SinkOpts;
        -:  237:  StringMap<Option *> OptionsMap;
        -:  238:
        -:  239:  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.
        -:  240:};
        -:  241:
        -:  242:// A special subcommand representing no subcommand
        -:  243:extern ManagedStatic<SubCommand> TopLevelSubCommand;
        -:  244:
        -:  245:// A special subcommand that can be used to put an option into all subcommands.
        -:  246:extern ManagedStatic<SubCommand> AllSubCommands;
        -:  247:
        -:  248://===----------------------------------------------------------------------===//
        -:  249://
        -:  250:class Option {
        -:  251:  friend class alias;
        -:  252:
        -:  253:  // Overriden by subclasses to handle the value passed into an argument. Should
        -:  254:  // return true if there was an error processing the argument and the program
        -:  255:  // should exit.
        -:  256:  //
        -:  257:  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,
        -:  258:                                StringRef Arg) = 0;
        -:  259:
        -:  260:  virtual enum ValueExpected getValueExpectedFlagDefault() const {
        -:  261:    return ValueOptional;
        -:  262:  }
        -:  263:
        -:  264:  // Out of line virtual function to provide home for the class.
        -:  265:  virtual void anchor();
        -:  266:
        -:  267:  uint16_t NumOccurrences; // The number of times specified
        -:  268:  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid
        -:  269:  // problems with signed enums in bitfields.
        -:  270:  uint16_t Occurrences : 3; // enum NumOccurrencesFlag
        -:  271:  // not using the enum type for 'Value' because zero is an implementation
        -:  272:  // detail representing the non-value
        -:  273:  uint16_t Value : 2;
        -:  274:  uint16_t HiddenFlag : 2; // enum OptionHidden
        -:  275:  uint16_t Formatting : 2; // enum FormattingFlags
        -:  276:  uint16_t Misc : 5;
        -:  277:  uint16_t FullyInitialized : 1; // Has addArgument been called?
        -:  278:  uint16_t Position;             // Position of last occurrence of the option
        -:  279:  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.
        -:  280:
        -:  281:public:
        -:  282:  StringRef ArgStr;   // The argument string itself (ex: "help", "o")
        -:  283:  StringRef HelpStr;  // The descriptive text message for -help
        -:  284:  StringRef ValueStr; // String describing what the value of this option is
        -:  285:  SmallVector<OptionCategory *, 1>
        -:  286:      Categories;                    // The Categories this option belongs to
        -:  287:  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.
        -:  288:
        -:  289:  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {
        -:  290:    return (enum NumOccurrencesFlag)Occurrences;
        -:  291:  }
        -:  292:
        -:  293:  inline enum ValueExpected getValueExpectedFlag() const {
        -:  294:    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();
        -:  295:  }
        -:  296:
        -:  297:  inline enum OptionHidden getOptionHiddenFlag() const {
        -:  298:    return (enum OptionHidden)HiddenFlag;
        -:  299:  }
        -:  300:
        -:  301:  inline enum FormattingFlags getFormattingFlag() const {
        -:  302:    return (enum FormattingFlags)Formatting;
        -:  303:  }
        -:  304:
        -:  305:  inline unsigned getMiscFlags() const { return Misc; }
        -:  306:  inline unsigned getPosition() const { return Position; }
        -:  307:  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }
        -:  308:
        -:  309:  // Return true if the argstr != ""
        -:  310:  bool hasArgStr() const { return !ArgStr.empty(); }
        -:  311:  bool isPositional() const { return getFormattingFlag() == cl::Positional; }
        -:  312:  bool isSink() const { return getMiscFlags() & cl::Sink; }
        -:  313:  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }
        -:  314:
        -:  315:  bool isConsumeAfter() const {
        -:  316:    return getNumOccurrencesFlag() == cl::ConsumeAfter;
        -:  317:  }
        -:  318:
        -:  319:  bool isInAllSubCommands() const {
        -:  320:    return llvm::is_contained(Subs, &SubCommand::getAll());
        -:  321:  }
        -:  322:
        -:  323:  //-------------------------------------------------------------------------===
        -:  324:  // Accessor functions set by OptionModifiers
        -:  325:  //
        -:  326:  void setArgStr(StringRef S);
  1161630:  327:  void setDescription(StringRef S) { HelpStr = S; }
   116163:  328:  void setValueStr(StringRef S) { ValueStr = S; }
        -:  329:  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }
        -:  330:  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }
        -:  331:  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }
   116163:  332:  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }
        -:  333:  void setMiscFlag(enum MiscFlags M) { Misc |= M; }
        -:  334:  void setPosition(unsigned pos) { Position = pos; }
        -:  335:  void addCategory(OptionCategory &C);
        -:  336:  void addSubCommand(SubCommand &S) { Subs.insert(&S); }
        -:  337:
        -:  338:protected:
function _ZN4llvm2cl6OptionC2ENS0_18NumOccurrencesFlagENS0_12OptionHiddenE called 1161630 returned 100% blocks executed 100%
  1161630:  339:  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,
        -:  340:                  enum OptionHidden Hidden)
  1161630:  341:      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),
        -:  342:        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),
  1161630:  343:        FullyInitialized(false), Position(0), AdditionalVals(0) {
call    0 returned 100%
  1161630:  344:    Categories.push_back(&getGeneralCategory());
call    0 returned 100%
call    1 returned 100%
  1161630:  345:  }
        -:  346:
        -:  347:  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }
        -:  348:
        -:  349:public:
    #####:  350:  virtual ~Option() = default;
------------------
_ZN4llvm2cl6OptionD0Ev:
function _ZN4llvm2cl6OptionD0Ev called 0 returned 0% blocks executed 0%
    #####:  350:  virtual ~Option() = default;
call    0 never executed
call    1 never executed
------------------
_ZN4llvm2cl6OptionD2Ev:
function _ZN4llvm2cl6OptionD2Ev called 0 returned 0% blocks executed 0%
    #####:  350:  virtual ~Option() = default;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
------------------
        -:  351:
        -:  352:  // Register this argument with the commandline system.
        -:  353:  //
        -:  354:  void addArgument();
        -:  355:
        -:  356:  /// Unregisters this option from the CommandLine system.
        -:  357:  ///
        -:  358:  /// This option must have been the last option registered.
        -:  359:  /// For testing purposes only.
        -:  360:  void removeArgument();
        -:  361:
        -:  362:  // Return the width of the option tag for printing...
        -:  363:  virtual size_t getOptionWidth() const = 0;
        -:  364:
        -:  365:  // Print out information about this option. The to-be-maintained width is
        -:  366:  // specified.
        -:  367:  //
        -:  368:  virtual void printOptionInfo(size_t GlobalWidth) const = 0;
        -:  369:
        -:  370:  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;
        -:  371:
        -:  372:  virtual void setDefault() = 0;
        -:  373:
        -:  374:  // Prints the help string for an option.
        -:  375:  //
        -:  376:  // This maintains the Indent for multi-line descriptions.
        -:  377:  // FirstLineIndentedBy is the count of chars of the first line
        -:  378:  //      i.e. the one containing the --<option name>.
        -:  379:  static void printHelpStr(StringRef HelpStr, size_t Indent,
        -:  380:                           size_t FirstLineIndentedBy);
        -:  381:
        -:  382:  // Prints the help string for an enum value.
        -:  383:  //
        -:  384:  // This maintains the Indent for multi-line descriptions.
        -:  385:  // FirstLineIndentedBy is the count of chars of the first line
        -:  386:  //      i.e. the one containing the =<value>.
        -:  387:  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,
        -:  388:                                  size_t FirstLineIndentedBy);
        -:  389:
        -:  390:  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}
        -:  391:
        -:  392:  // Wrapper around handleOccurrence that enforces Flags.
        -:  393:  //
        -:  394:  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,
        -:  395:                             bool MultiArg = false);
        -:  396:
        -:  397:  // Prints option name followed by message.  Always returns true.
        -:  398:  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());
        -:  399:  bool error(const Twine &Message, raw_ostream &Errs) {
        -:  400:    return error(Message, StringRef(), Errs);
        -:  401:  }
        -:  402:
        -:  403:  inline int getNumOccurrences() const { return NumOccurrences; }
        -:  404:  void reset();
        -:  405:};
        -:  406:
        -:  407://===----------------------------------------------------------------------===//
        -:  408:// Command line option modifiers that can be used to modify the behavior of
        -:  409:// command line option parsers...
        -:  410://
        -:  411:
        -:  412:// Modifier to set the description shown in the -help output...
        -:  413:struct desc {
        -:  414:  StringRef Desc;
        -:  415:
   929304:  416:  desc(StringRef Str) : Desc(Str) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
        -:  417:
  1161630:  418:  void apply(Option &O) const { O.setDescription(Desc); }
        -:  419:};
        -:  420:
        -:  421:// Modifier to set the value description shown in the -help output...
        -:  422:struct value_desc {
        -:  423:  StringRef Desc;
        -:  424:
   116163:  425:  value_desc(StringRef Str) : Desc(Str) {}
call    0 returned 100%
        -:  426:
   116163:  427:  void apply(Option &O) const { O.setValueStr(Desc); }
        -:  428:};
        -:  429:
        -:  430:// Specify a default (initial) value for the command line argument, if the
        -:  431:// default constructor for the argument type does not give you what you want.
        -:  432:// This is only valid on "opt" arguments, not on "list" arguments.
        -:  433:template <class Ty> struct initializer {
        -:  434:  const Ty &Init;
  1161630:  435:  initializer(const Ty &Val) : Init(Val) {}
        -:  436:
   929304:  437:  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }
        -:  438:};
        -:  439:
        -:  440:template <class Ty> struct list_initializer {
        -:  441:  ArrayRef<Ty> Inits;
        -:  442:  list_initializer(ArrayRef<Ty> Vals) : Inits(Vals) {}
        -:  443:
        -:  444:  template <class Opt> void apply(Opt &O) const { O.setInitialValues(Inits); }
        -:  445:};
        -:  446:
  1161630:  447:template <class Ty> initializer<Ty> init(const Ty &Val) {
  1161630:  448:  return initializer<Ty>(Val);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
        -:  449:}
        -:  450:
        -:  451:template <class Ty>
        -:  452:list_initializer<Ty> list_init(ArrayRef<Ty> Vals) {
        -:  453:  return list_initializer<Ty>(Vals);
        -:  454:}
        -:  455:
        -:  456:// Allow the user to specify which external variable they want to store the
        -:  457:// results of the command line argument processing into, if they don't want to
        -:  458:// store it in the option itself.
        -:  459:template <class Ty> struct LocationClass {
        -:  460:  Ty &Loc;
        -:  461:
        -:  462:  LocationClass(Ty &L) : Loc(L) {}
        -:  463:
        -:  464:  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }
        -:  465:};
        -:  466:
        -:  467:template <class Ty> LocationClass<Ty> location(Ty &L) {
        -:  468:  return LocationClass<Ty>(L);
        -:  469:}
        -:  470:
        -:  471:// Specify the Option category for the command line argument to belong to.
        -:  472:struct cat {
        -:  473:  OptionCategory &Category;
        -:  474:
        -:  475:  cat(OptionCategory &c) : Category(c) {}
        -:  476:
        -:  477:  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }
        -:  478:};
        -:  479:
        -:  480:// Specify the subcommand that this option belongs to.
        -:  481:struct sub {
        -:  482:  SubCommand &Sub;
        -:  483:
        -:  484:  sub(SubCommand &S) : Sub(S) {}
        -:  485:
        -:  486:  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }
        -:  487:};
        -:  488:
        -:  489:// Specify a callback function to be called when an option is seen.
        -:  490:// Can be used to set other options automatically.
        -:  491:template <typename R, typename Ty> struct cb {
        -:  492:  std::function<R(Ty)> CB;
        -:  493:
        -:  494:  cb(std::function<R(Ty)> CB) : CB(CB) {}
        -:  495:
        -:  496:  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }
        -:  497:};
        -:  498:
        -:  499:namespace detail {
        -:  500:template <typename F>
        -:  501:struct callback_traits : public callback_traits<decltype(&F::operator())> {};
        -:  502:
        -:  503:template <typename R, typename C, typename... Args>
        -:  504:struct callback_traits<R (C::*)(Args...) const> {
        -:  505:  using result_type = R;
        -:  506:  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;
        -:  507:  static_assert(sizeof...(Args) == 1, "callback function must have one and only one parameter");
        -:  508:  static_assert(std::is_same<result_type, void>::value,
        -:  509:                "callback return type must be void");
        -:  510:  static_assert(std::is_lvalue_reference<arg_type>::value &&
        -:  511:                    std::is_const<std::remove_reference_t<arg_type>>::value,
        -:  512:                "callback arg_type must be a const lvalue reference");
        -:  513:};
        -:  514:} // namespace detail
        -:  515:
        -:  516:template <typename F>
        -:  517:cb<typename detail::callback_traits<F>::result_type,
        -:  518:   typename detail::callback_traits<F>::arg_type>
        -:  519:callback(F CB) {
        -:  520:  using result_type = typename detail::callback_traits<F>::result_type;
        -:  521:  using arg_type = typename detail::callback_traits<F>::arg_type;
        -:  522:  return cb<result_type, arg_type>(CB);
        -:  523:}
        -:  524:
        -:  525://===----------------------------------------------------------------------===//
        -:  526:
        -:  527:// Support value comparison outside the template.
        -:  528:struct GenericOptionValue {
        -:  529:  virtual bool compare(const GenericOptionValue &V) const = 0;
        -:  530:
        -:  531:protected:
  1161630:  532:  GenericOptionValue() = default;
        -:  533:  GenericOptionValue(const GenericOptionValue&) = default;
        -:  534:  GenericOptionValue &operator=(const GenericOptionValue &) = default;
        -:  535:  ~GenericOptionValue() = default;
        -:  536:
        -:  537:private:
        -:  538:  virtual void anchor();
        -:  539:};
        -:  540:
        -:  541:template <class DataType> struct OptionValue;
        -:  542:
        -:  543:// The default value safely does nothing. Option value printing is only
        -:  544:// best-effort.
        -:  545:template <class DataType, bool isClass>
        -:  546:struct OptionValueBase : public GenericOptionValue {
        -:  547:  // Temporary storage for argument passing.
        -:  548:  using WrapperType = OptionValue<DataType>;
        -:  549:
        -:  550:  bool hasValue() const { return false; }
        -:  551:
        -:  552:  const DataType &getValue() const { llvm_unreachable("no default value"); }
        -:  553:
        -:  554:  // Some options may take their value from a different data type.
        -:  555:  template <class DT> void setValue(const DT & /*V*/) {}
        -:  556:
        -:  557:  bool compare(const DataType & /*V*/) const { return false; }
        -:  558:
        -:  559:  bool compare(const GenericOptionValue & /*V*/) const override {
        -:  560:    return false;
        -:  561:  }
        -:  562:
        -:  563:protected:
        -:  564:  ~OptionValueBase() = default;
        -:  565:};
        -:  566:
        -:  567:// Simple copy of the option value.
        -:  568:template <class DataType> class OptionValueCopy : public GenericOptionValue {
        -:  569:  DataType Value;
        -:  570:  bool Valid = false;
        -:  571:
        -:  572:protected:
        -:  573:  OptionValueCopy(const OptionValueCopy&) = default;
        -:  574:  OptionValueCopy &operator=(const OptionValueCopy &) = default;
        -:  575:  ~OptionValueCopy() = default;
        -:  576:
        -:  577:public:
  1161630:  578:  OptionValueCopy() = default;
        -:  579:
    #####:  580:  bool hasValue() const { return Valid; }
        -:  581:
    #####:  582:  const DataType &getValue() const {
        -:  583:    assert(Valid && "invalid option value");
    #####:  584:    return Value;
        -:  585:  }
        -:  586:
   929304:  587:  void setValue(const DataType &V) {
   929304:  588:    Valid = true;
   929304:  589:    Value = V;
        -:  590:  }
        -:  591:
    #####:  592:  bool compare(const DataType &V) const { return Valid && (Value != V); }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  593:
    #####:  594:  bool compare(const GenericOptionValue &V) const override {
    #####:  595:    const OptionValueCopy<DataType> &VC =
        -:  596:        static_cast<const OptionValueCopy<DataType> &>(V);
    #####:  597:    if (!VC.hasValue())
        -:  598:      return false;
    #####:  599:    return compare(VC.getValue());
        -:  600:  }
------------------
_ZNK4llvm2cl15OptionValueCopyINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE7compareERKNS0_18GenericOptionValueE:
function _ZNK4llvm2cl15OptionValueCopyINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE7compareERKNS0_18GenericOptionValueE called 0 returned 0% blocks executed 0%
    #####:  594:  bool compare(const GenericOptionValue &V) const override {
    #####:  595:    const OptionValueCopy<DataType> &VC =
        -:  596:        static_cast<const OptionValueCopy<DataType> &>(V);
    #####:  597:    if (!VC.hasValue())
branch  0 never executed
branch  1 never executed
        -:  598:      return false;
    #####:  599:    return compare(VC.getValue());
branch  0 never executed
branch  1 never executed
        -:  600:  }
------------------
_ZNK4llvm2cl15OptionValueCopyIbE7compareERKNS0_18GenericOptionValueE:
function _ZNK4llvm2cl15OptionValueCopyIbE7compareERKNS0_18GenericOptionValueE called 0 returned 0% blocks executed 0%
    #####:  594:  bool compare(const GenericOptionValue &V) const override {
    #####:  595:    const OptionValueCopy<DataType> &VC =
        -:  596:        static_cast<const OptionValueCopy<DataType> &>(V);
    #####:  597:    if (!VC.hasValue())
branch  0 never executed
branch  1 never executed
        -:  598:      return false;
    #####:  599:    return compare(VC.getValue());
branch  0 never executed
branch  1 never executed
        -:  600:  }
------------------
        -:  601:};
        -:  602:
        -:  603:// Non-class option values.
        -:  604:template <class DataType>
        -:  605:struct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {
        -:  606:  using WrapperType = DataType;
        -:  607:
        -:  608:protected:
   929304:  609:  OptionValueBase() = default;
        -:  610:  OptionValueBase(const OptionValueBase&) = default;
        -:  611:  OptionValueBase &operator=(const OptionValueBase &) = default;
        -:  612:  ~OptionValueBase() = default;
        -:  613:};
        -:  614:
        -:  615:// Top-level option class.
        -:  616:template <class DataType>
        -:  617:struct OptionValue final
        -:  618:    : OptionValueBase<DataType, std::is_class<DataType>::value> {
   929304:  619:  OptionValue() = default;
        -:  620:
        -:  621:  OptionValue(const DataType &V) { this->setValue(V); }
        -:  622:
        -:  623:  // Some options may take their value from a different data type.
   929304:  624:  template <class DT> OptionValue<DataType> &operator=(const DT &V) {
   929304:  625:    this->setValue(V);
        -:  626:    return *this;
        -:  627:  }
        -:  628:};
        -:  629:
        -:  630:// Other safe-to-copy-by-value common option types.
        -:  631:enum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };
        -:  632:template <>
        -:  633:struct OptionValue<cl::boolOrDefault> final
        -:  634:    : OptionValueCopy<cl::boolOrDefault> {
        -:  635:  using WrapperType = cl::boolOrDefault;
        -:  636:
        -:  637:  OptionValue() = default;
        -:  638:
        -:  639:  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }
        -:  640:
        -:  641:  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {
        -:  642:    setValue(V);
        -:  643:    return *this;
        -:  644:  }
        -:  645:
        -:  646:private:
        -:  647:  void anchor() override;
        -:  648:};
        -:  649:
        -:  650:template <>
        -:  651:struct OptionValue<std::string> final : OptionValueCopy<std::string> {
        -:  652:  using WrapperType = StringRef;
        -:  653:
   232326:  654:  OptionValue() = default;
        -:  655:
        -:  656:  OptionValue(const std::string &V) { this->setValue(V); }
        -:  657:
        -:  658:  OptionValue<std::string> &operator=(const std::string &V) {
        -:  659:    setValue(V);
        -:  660:    return *this;
        -:  661:  }
        -:  662:
        -:  663:private:
        -:  664:  void anchor() override;
        -:  665:};
        -:  666:
        -:  667://===----------------------------------------------------------------------===//
        -:  668:// Enum valued command line option
        -:  669://
        -:  670:
        -:  671:// This represents a single enum value, using "int" as the underlying type.
        -:  672:struct OptionEnumValue {
        -:  673:  StringRef Name;
        -:  674:  int Value;
        -:  675:  StringRef Description;
        -:  676:};
        -:  677:
        -:  678:#define clEnumVal(ENUMVAL, DESC)                                               \
        -:  679:  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }
        -:  680:#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \
        -:  681:  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }
        -:  682:
        -:  683:// For custom data types, allow specifying a group of values together as the
        -:  684:// values that go into the mapping that the option handler uses.
        -:  685://
        -:  686:class ValuesClass {
        -:  687:  // Use a vector instead of a map, because the lists should be short,
        -:  688:  // the overhead is less, and most importantly, it keeps them in the order
        -:  689:  // inserted so we can print our option out nicely.
        -:  690:  SmallVector<OptionEnumValue, 4> Values;
        -:  691:
        -:  692:public:
        -:  693:  ValuesClass(std::initializer_list<OptionEnumValue> Options)
        -:  694:      : Values(Options) {}
        -:  695:
        -:  696:  template <class Opt> void apply(Opt &O) const {
        -:  697:    for (const auto &Value : Values)
        -:  698:      O.getParser().addLiteralOption(Value.Name, Value.Value,
        -:  699:                                     Value.Description);
        -:  700:  }
        -:  701:};
        -:  702:
        -:  703:/// Helper to build a ValuesClass by forwarding a variable number of arguments
        -:  704:/// as an initializer list to the ValuesClass constructor.
        -:  705:template <typename... OptsTy> ValuesClass values(OptsTy... Options) {
        -:  706:  return ValuesClass({Options...});
        -:  707:}
        -:  708:
        -:  709://===----------------------------------------------------------------------===//
        -:  710:// Parameterizable parser for different data types. By default, known data types
        -:  711:// (string, int, bool) have specialized parsers, that do what you would expect.
        -:  712:// The default parser, used for data types that are not built-in, uses a mapping
        -:  713:// table to map specific options to values, which is used, among other things,
        -:  714:// to handle enum types.
        -:  715:
        -:  716://--------------------------------------------------
        -:  717:// This class holds all the non-generic code that we do not need replicated for
        -:  718:// every instance of the generic parser.  This also allows us to put stuff into
        -:  719:// CommandLine.cpp
        -:  720://
        -:  721:class generic_parser_base {
        -:  722:protected:
        -:  723:  class GenericOptionInfo {
        -:  724:  public:
        -:  725:    GenericOptionInfo(StringRef name, StringRef helpStr)
        -:  726:        : Name(name), HelpStr(helpStr) {}
        -:  727:    StringRef Name;
        -:  728:    StringRef HelpStr;
        -:  729:  };
        -:  730:
        -:  731:public:
        -:  732:  generic_parser_base(Option &O) : Owner(O) {}
        -:  733:
        -:  734:  virtual ~generic_parser_base() = default;
        -:  735:  // Base class should have virtual-destructor
        -:  736:
        -:  737:  // Virtual function implemented by generic subclass to indicate how many
        -:  738:  // entries are in Values.
        -:  739:  //
        -:  740:  virtual unsigned getNumOptions() const = 0;
        -:  741:
        -:  742:  // Return option name N.
        -:  743:  virtual StringRef getOption(unsigned N) const = 0;
        -:  744:
        -:  745:  // Return description N
        -:  746:  virtual StringRef getDescription(unsigned N) const = 0;
        -:  747:
        -:  748:  // Return the width of the option tag for printing...
        -:  749:  virtual size_t getOptionWidth(const Option &O) const;
        -:  750:
        -:  751:  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;
        -:  752:
        -:  753:  // Print out information about this option. The to-be-maintained width is
        -:  754:  // specified.
        -:  755:  //
        -:  756:  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;
        -:  757:
        -:  758:  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,
        -:  759:                              const GenericOptionValue &Default,
        -:  760:                              size_t GlobalWidth) const;
        -:  761:
        -:  762:  // Print the value of an option and it's default.
        -:  763:  //
        -:  764:  // Template definition ensures that the option and default have the same
        -:  765:  // DataType (via the same AnyOptionValue).
        -:  766:  template <class AnyOptionValue>
        -:  767:  void printOptionDiff(const Option &O, const AnyOptionValue &V,
        -:  768:                       const AnyOptionValue &Default,
        -:  769:                       size_t GlobalWidth) const {
        -:  770:    printGenericOptionDiff(O, V, Default, GlobalWidth);
        -:  771:  }
        -:  772:
        -:  773:  void initialize() {}
        -:  774:
        -:  775:  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {
        -:  776:    // If there has been no argstr specified, that means that we need to add an
        -:  777:    // argument for every possible option.  This ensures that our options are
        -:  778:    // vectored to us.
        -:  779:    if (!Owner.hasArgStr())
        -:  780:      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)
        -:  781:        OptionNames.push_back(getOption(i));
        -:  782:  }
        -:  783:
        -:  784:  enum ValueExpected getValueExpectedFlagDefault() const {
        -:  785:    // If there is an ArgStr specified, then we are of the form:
        -:  786:    //
        -:  787:    //    -opt=O2   or   -opt O2  or  -optO2
        -:  788:    //
        -:  789:    // In which case, the value is required.  Otherwise if an arg str has not
        -:  790:    // been specified, we are of the form:
        -:  791:    //
        -:  792:    //    -O2 or O2 or -la (where -l and -a are separate options)
        -:  793:    //
        -:  794:    // If this is the case, we cannot allow a value.
        -:  795:    //
        -:  796:    if (Owner.hasArgStr())
        -:  797:      return ValueRequired;
        -:  798:    else
        -:  799:      return ValueDisallowed;
        -:  800:  }
        -:  801:
        -:  802:  // Return the option number corresponding to the specified
        -:  803:  // argument string.  If the option is not found, getNumOptions() is returned.
        -:  804:  //
        -:  805:  unsigned findOption(StringRef Name);
        -:  806:
        -:  807:protected:
        -:  808:  Option &Owner;
        -:  809:};
        -:  810:
        -:  811:// Default parser implementation - This implementation depends on having a
        -:  812:// mapping of recognized options to values of some sort.  In addition to this,
        -:  813:// each entry in the mapping also tracks a help message that is printed with the
        -:  814:// command line option for -help.  Because this is a simple mapping parser, the
        -:  815:// data type can be any unsupported type.
        -:  816://
        -:  817:template <class DataType> class parser : public generic_parser_base {
        -:  818:protected:
        -:  819:  class OptionInfo : public GenericOptionInfo {
        -:  820:  public:
        -:  821:    OptionInfo(StringRef name, DataType v, StringRef helpStr)
        -:  822:        : GenericOptionInfo(name, helpStr), V(v) {}
        -:  823:
        -:  824:    OptionValue<DataType> V;
        -:  825:  };
        -:  826:  SmallVector<OptionInfo, 8> Values;
        -:  827:
        -:  828:public:
        -:  829:  parser(Option &O) : generic_parser_base(O) {}
        -:  830:
        -:  831:  using parser_data_type = DataType;
        -:  832:
        -:  833:  // Implement virtual functions needed by generic_parser_base
        -:  834:  unsigned getNumOptions() const override { return unsigned(Values.size()); }
        -:  835:  StringRef getOption(unsigned N) const override { return Values[N].Name; }
        -:  836:  StringRef getDescription(unsigned N) const override {
        -:  837:    return Values[N].HelpStr;
        -:  838:  }
        -:  839:
        -:  840:  // Return the value of option name N.
        -:  841:  const GenericOptionValue &getOptionValue(unsigned N) const override {
        -:  842:    return Values[N].V;
        -:  843:  }
        -:  844:
        -:  845:  // Return true on error.
        -:  846:  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {
        -:  847:    StringRef ArgVal;
        -:  848:    if (Owner.hasArgStr())
        -:  849:      ArgVal = Arg;
        -:  850:    else
        -:  851:      ArgVal = ArgName;
        -:  852:
        -:  853:    for (size_t i = 0, e = Values.size(); i != e; ++i)
        -:  854:      if (Values[i].Name == ArgVal) {
        -:  855:        V = Values[i].V.getValue();
        -:  856:        return false;
        -:  857:      }
        -:  858:
        -:  859:    return O.error("Cannot find option named '" + ArgVal + "'!");
        -:  860:  }
        -:  861:
        -:  862:  /// Add an entry to the mapping table.
        -:  863:  ///
        -:  864:  template <class DT>
        -:  865:  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {
        -:  866:    assert(findOption(Name) == Values.size() && "Option already exists!");
        -:  867:    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);
        -:  868:    Values.push_back(X);
        -:  869:    AddLiteralOption(Owner, Name);
        -:  870:  }
        -:  871:
        -:  872:  /// Remove the specified option.
        -:  873:  ///
        -:  874:  void removeLiteralOption(StringRef Name) {
        -:  875:    unsigned N = findOption(Name);
        -:  876:    assert(N != Values.size() && "Option not found!");
        -:  877:    Values.erase(Values.begin() + N);
        -:  878:  }
        -:  879:};
        -:  880:
        -:  881://--------------------------------------------------
        -:  882:// Super class of parsers to provide boilerplate code
        -:  883://
        -:  884:class basic_parser_impl { // non-template implementation of basic_parser<t>
        -:  885:public:
  1161630:  886:  basic_parser_impl(Option &) {}
        -:  887:
        -:  888:  virtual ~basic_parser_impl() = default;
        -:  889:
        -:  890:  enum ValueExpected getValueExpectedFlagDefault() const {
        -:  891:    return ValueRequired;
        -:  892:  }
        -:  893:
        -:  894:  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}
        -:  895:
   232326:  896:  void initialize() {}
        -:  897:
        -:  898:  // Return the width of the option tag for printing...
        -:  899:  size_t getOptionWidth(const Option &O) const;
        -:  900:
        -:  901:  // Print out information about this option. The to-be-maintained width is
        -:  902:  // specified.
        -:  903:  //
        -:  904:  void printOptionInfo(const Option &O, size_t GlobalWidth) const;
        -:  905:
        -:  906:  // Print a placeholder for options that don't yet support printOptionDiff().
        -:  907:  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;
        -:  908:
        -:  909:  // Overload in subclass to provide a better default value.
        -:  910:  virtual StringRef getValueName() const { return "value"; }
        -:  911:
        -:  912:  // An out-of-line virtual method to provide a 'home' for this class.
        -:  913:  virtual void anchor();
        -:  914:
        -:  915:protected:
        -:  916:  // A helper for basic_parser::printOptionDiff.
        -:  917:  void printOptionName(const Option &O, size_t GlobalWidth) const;
        -:  918:};
        -:  919:
        -:  920:// The real basic parser is just a template wrapper that provides a typedef for
        -:  921:// the provided data type.
        -:  922://
        -:  923:template <class DataType> class basic_parser : public basic_parser_impl {
        -:  924:public:
        -:  925:  using parser_data_type = DataType;
        -:  926:  using OptVal = OptionValue<DataType>;
        -:  927:
  1161630:  928:  basic_parser(Option &O) : basic_parser_impl(O) {}
        -:  929:};
        -:  930:
        -:  931://--------------------------------------------------
        -:  932:
        -:  933:extern template class basic_parser<bool>;
        -:  934:
        -:  935:template <> class parser<bool> : public basic_parser<bool> {
        -:  936:public:
   929304:  937:  parser(Option &O) : basic_parser(O) {}
        -:  938:
        -:  939:  // Return true on error.
        -:  940:  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);
        -:  941:
   929304:  942:  void initialize() {}
        -:  943:
        -:  944:  enum ValueExpected getValueExpectedFlagDefault() const {
        -:  945:    return ValueOptional;
        -:  946:  }
        -:  947:
        -:  948:  // Do not print =<value> at all.
        -:  949:  StringRef getValueName() const override { return StringRef(); }
        -:  950:
        -:  951:  void printOptionDiff(const Option &O, bool V, OptVal Default,
        -:  952:                       size_t GlobalWidth) const;
        -:  953:
        -:  954:  // An out-of-line virtual method to provide a 'home' for this class.
        -:  955:  void anchor() override;
        -:  956:};
        -:  957:
        -:  958://--------------------------------------------------
        -:  959:
        -:  960:extern template class basic_parser<boolOrDefault>;
        -:  961:
        -:  962:template <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {
        -:  963:public:
        -:  964:  parser(Option &O) : basic_parser(O) {}
        -:  965:
        -:  966:  // Return true on error.
        -:  967:  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);
        -:  968:
        -:  969:  enum ValueExpected getValueExpectedFlagDefault() const {
        -:  970:    return ValueOptional;
        -:  971:  }
        -:  972:
        -:  973:  // Do not print =<value> at all.
        -:  974:  StringRef getValueName() const override { return StringRef(); }
        -:  975:
        -:  976:  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,
        -:  977:                       size_t GlobalWidth) const;
        -:  978:
        -:  979:  // An out-of-line virtual method to provide a 'home' for this class.
        -:  980:  void anchor() override;
        -:  981:};
        -:  982:
        -:  983://--------------------------------------------------
        -:  984:
        -:  985:extern template class basic_parser<int>;
        -:  986:
        -:  987:template <> class parser<int> : public basic_parser<int> {
        -:  988:public:
        -:  989:  parser(Option &O) : basic_parser(O) {}
        -:  990:
        -:  991:  // Return true on error.
        -:  992:  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);
        -:  993:
        -:  994:  // Overload in subclass to provide a better default value.
        -:  995:  StringRef getValueName() const override { return "int"; }
        -:  996:
        -:  997:  void printOptionDiff(const Option &O, int V, OptVal Default,
        -:  998:                       size_t GlobalWidth) const;
        -:  999:
        -: 1000:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1001:  void anchor() override;
        -: 1002:};
        -: 1003:
        -: 1004://--------------------------------------------------
        -: 1005:
        -: 1006:extern template class basic_parser<long>;
        -: 1007:
        -: 1008:template <> class parser<long> final : public basic_parser<long> {
        -: 1009:public:
        -: 1010:  parser(Option &O) : basic_parser(O) {}
        -: 1011:
        -: 1012:  // Return true on error.
        -: 1013:  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);
        -: 1014:
        -: 1015:  // Overload in subclass to provide a better default value.
        -: 1016:  StringRef getValueName() const override { return "long"; }
        -: 1017:
        -: 1018:  void printOptionDiff(const Option &O, long V, OptVal Default,
        -: 1019:                       size_t GlobalWidth) const;
        -: 1020:
        -: 1021:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1022:  void anchor() override;
        -: 1023:};
        -: 1024:
        -: 1025://--------------------------------------------------
        -: 1026:
        -: 1027:extern template class basic_parser<long long>;
        -: 1028:
        -: 1029:template <> class parser<long long> : public basic_parser<long long> {
        -: 1030:public:
        -: 1031:  parser(Option &O) : basic_parser(O) {}
        -: 1032:
        -: 1033:  // Return true on error.
        -: 1034:  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);
        -: 1035:
        -: 1036:  // Overload in subclass to provide a better default value.
        -: 1037:  StringRef getValueName() const override { return "long"; }
        -: 1038:
        -: 1039:  void printOptionDiff(const Option &O, long long V, OptVal Default,
        -: 1040:                       size_t GlobalWidth) const;
        -: 1041:
        -: 1042:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1043:  void anchor() override;
        -: 1044:};
        -: 1045:
        -: 1046://--------------------------------------------------
        -: 1047:
        -: 1048:extern template class basic_parser<unsigned>;
        -: 1049:
        -: 1050:template <> class parser<unsigned> : public basic_parser<unsigned> {
        -: 1051:public:
        -: 1052:  parser(Option &O) : basic_parser(O) {}
        -: 1053:
        -: 1054:  // Return true on error.
        -: 1055:  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);
        -: 1056:
        -: 1057:  // Overload in subclass to provide a better default value.
        -: 1058:  StringRef getValueName() const override { return "uint"; }
        -: 1059:
        -: 1060:  void printOptionDiff(const Option &O, unsigned V, OptVal Default,
        -: 1061:                       size_t GlobalWidth) const;
        -: 1062:
        -: 1063:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1064:  void anchor() override;
        -: 1065:};
        -: 1066:
        -: 1067://--------------------------------------------------
        -: 1068:
        -: 1069:extern template class basic_parser<unsigned long>;
        -: 1070:
        -: 1071:template <>
        -: 1072:class parser<unsigned long> final : public basic_parser<unsigned long> {
        -: 1073:public:
        -: 1074:  parser(Option &O) : basic_parser(O) {}
        -: 1075:
        -: 1076:  // Return true on error.
        -: 1077:  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);
        -: 1078:
        -: 1079:  // Overload in subclass to provide a better default value.
        -: 1080:  StringRef getValueName() const override { return "ulong"; }
        -: 1081:
        -: 1082:  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,
        -: 1083:                       size_t GlobalWidth) const;
        -: 1084:
        -: 1085:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1086:  void anchor() override;
        -: 1087:};
        -: 1088:
        -: 1089://--------------------------------------------------
        -: 1090:
        -: 1091:extern template class basic_parser<unsigned long long>;
        -: 1092:
        -: 1093:template <>
        -: 1094:class parser<unsigned long long> : public basic_parser<unsigned long long> {
        -: 1095:public:
        -: 1096:  parser(Option &O) : basic_parser(O) {}
        -: 1097:
        -: 1098:  // Return true on error.
        -: 1099:  bool parse(Option &O, StringRef ArgName, StringRef Arg,
        -: 1100:             unsigned long long &Val);
        -: 1101:
        -: 1102:  // Overload in subclass to provide a better default value.
        -: 1103:  StringRef getValueName() const override { return "ulong"; }
        -: 1104:
        -: 1105:  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,
        -: 1106:                       size_t GlobalWidth) const;
        -: 1107:
        -: 1108:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1109:  void anchor() override;
        -: 1110:};
        -: 1111:
        -: 1112://--------------------------------------------------
        -: 1113:
        -: 1114:extern template class basic_parser<double>;
        -: 1115:
        -: 1116:template <> class parser<double> : public basic_parser<double> {
        -: 1117:public:
        -: 1118:  parser(Option &O) : basic_parser(O) {}
        -: 1119:
        -: 1120:  // Return true on error.
        -: 1121:  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);
        -: 1122:
        -: 1123:  // Overload in subclass to provide a better default value.
        -: 1124:  StringRef getValueName() const override { return "number"; }
        -: 1125:
        -: 1126:  void printOptionDiff(const Option &O, double V, OptVal Default,
        -: 1127:                       size_t GlobalWidth) const;
        -: 1128:
        -: 1129:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1130:  void anchor() override;
        -: 1131:};
        -: 1132:
        -: 1133://--------------------------------------------------
        -: 1134:
        -: 1135:extern template class basic_parser<float>;
        -: 1136:
        -: 1137:template <> class parser<float> : public basic_parser<float> {
        -: 1138:public:
        -: 1139:  parser(Option &O) : basic_parser(O) {}
        -: 1140:
        -: 1141:  // Return true on error.
        -: 1142:  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);
        -: 1143:
        -: 1144:  // Overload in subclass to provide a better default value.
        -: 1145:  StringRef getValueName() const override { return "number"; }
        -: 1146:
        -: 1147:  void printOptionDiff(const Option &O, float V, OptVal Default,
        -: 1148:                       size_t GlobalWidth) const;
        -: 1149:
        -: 1150:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1151:  void anchor() override;
        -: 1152:};
        -: 1153:
        -: 1154://--------------------------------------------------
        -: 1155:
        -: 1156:extern template class basic_parser<std::string>;
        -: 1157:
        -: 1158:template <> class parser<std::string> : public basic_parser<std::string> {
        -: 1159:public:
   232326: 1160:  parser(Option &O) : basic_parser(O) {}
call    0 returned 100%
call    1 returned 100%
        -: 1161:
        -: 1162:  // Return true on error.
        -: 1163:  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {
        -: 1164:    Value = Arg.str();
        -: 1165:    return false;
        -: 1166:  }
        -: 1167:
        -: 1168:  // Overload in subclass to provide a better default value.
        -: 1169:  StringRef getValueName() const override { return "string"; }
        -: 1170:
        -: 1171:  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,
        -: 1172:                       size_t GlobalWidth) const;
        -: 1173:
        -: 1174:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1175:  void anchor() override;
        -: 1176:};
        -: 1177:
        -: 1178://--------------------------------------------------
        -: 1179:
        -: 1180:extern template class basic_parser<char>;
        -: 1181:
        -: 1182:template <> class parser<char> : public basic_parser<char> {
        -: 1183:public:
        -: 1184:  parser(Option &O) : basic_parser(O) {}
        -: 1185:
        -: 1186:  // Return true on error.
        -: 1187:  bool parse(Option &, StringRef, StringRef Arg, char &Value) {
        -: 1188:    Value = Arg[0];
        -: 1189:    return false;
        -: 1190:  }
        -: 1191:
        -: 1192:  // Overload in subclass to provide a better default value.
        -: 1193:  StringRef getValueName() const override { return "char"; }
        -: 1194:
        -: 1195:  void printOptionDiff(const Option &O, char V, OptVal Default,
        -: 1196:                       size_t GlobalWidth) const;
        -: 1197:
        -: 1198:  // An out-of-line virtual method to provide a 'home' for this class.
        -: 1199:  void anchor() override;
        -: 1200:};
        -: 1201:
        -: 1202://--------------------------------------------------
        -: 1203:// This collection of wrappers is the intermediary between class opt and class
        -: 1204:// parser to handle all the template nastiness.
        -: 1205:
        -: 1206:// This overloaded function is selected by the generic parser.
        -: 1207:template <class ParserClass, class DT>
        -: 1208:void printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,
        -: 1209:                     const OptionValue<DT> &Default, size_t GlobalWidth) {
        -: 1210:  OptionValue<DT> OV = V;
        -: 1211:  P.printOptionDiff(O, OV, Default, GlobalWidth);
        -: 1212:}
        -: 1213:
        -: 1214:// This is instantiated for basic parsers when the parsed value has a different
        -: 1215:// type than the option value. e.g. HelpPrinter.
        -: 1216:template <class ParserDT, class ValDT> struct OptionDiffPrinter {
        -: 1217:  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,
        -: 1218:             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {
        -: 1219:    P.printOptionNoValue(O, GlobalWidth);
        -: 1220:  }
        -: 1221:};
        -: 1222:
        -: 1223:// This is instantiated for basic parsers when the parsed value has the same
        -: 1224:// type as the option value.
        -: 1225:template <class DT> struct OptionDiffPrinter<DT, DT> {
        -: 1226:  void print(const Option &O, const parser<DT> &P, const DT &V,
        -: 1227:             const OptionValue<DT> &Default, size_t GlobalWidth) {
        -: 1228:    P.printOptionDiff(O, V, Default, GlobalWidth);
        -: 1229:  }
        -: 1230:};
        -: 1231:
        -: 1232:// This overloaded function is selected by the basic parser, which may parse a
        -: 1233:// different type than the option type.
        -: 1234:template <class ParserClass, class ValDT>
        -: 1235:void printOptionDiff(
        -: 1236:    const Option &O,
        -: 1237:    const basic_parser<typename ParserClass::parser_data_type> &P,
        -: 1238:    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {
        -: 1239:
        -: 1240:  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;
        -: 1241:  printer.print(O, static_cast<const ParserClass &>(P), V, Default,
        -: 1242:                GlobalWidth);
        -: 1243:}
        -: 1244:
        -: 1245://===----------------------------------------------------------------------===//
        -: 1246:// This class is used because we must use partial specialization to handle
        -: 1247:// literal string arguments specially (const char* does not correctly respond to
        -: 1248:// the apply method). Because the syntax to use this is a pain, we have the
        -: 1249:// 'apply' method below to handle the nastiness...
        -: 1250://
        -: 1251:template <class Mod> struct applicator {
  1161630: 1252:  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }
        -: 1253:};
        -: 1254:
        -: 1255:// Handle const char* as a special case...
        -: 1256:template <unsigned n> struct applicator<char[n]> {
  1045467: 1257:  template <class Opt> static void opt(StringRef Str, Opt &O) {
  1045467: 1258:    O.setArgStr(Str);
        -: 1259:  }
        -: 1260:};
        -: 1261:template <unsigned n> struct applicator<const char[n]> {
        -: 1262:  template <class Opt> static void opt(StringRef Str, Opt &O) {
        -: 1263:    O.setArgStr(Str);
        -: 1264:  }
        -: 1265:};
        -: 1266:template <> struct applicator<StringRef > {
        -: 1267:  template <class Opt> static void opt(StringRef Str, Opt &O) {
        -: 1268:    O.setArgStr(Str);
        -: 1269:  }
        -: 1270:};
        -: 1271:
        -: 1272:template <> struct applicator<NumOccurrencesFlag> {
        -: 1273:  static void opt(NumOccurrencesFlag N, Option &O) {
        -: 1274:    O.setNumOccurrencesFlag(N);
        -: 1275:  }
        -: 1276:};
        -: 1277:
        -: 1278:template <> struct applicator<ValueExpected> {
        -: 1279:  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }
        -: 1280:};
        -: 1281:
        -: 1282:template <> struct applicator<OptionHidden> {
        -: 1283:  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }
        -: 1284:};
        -: 1285:
        -: 1286:template <> struct applicator<FormattingFlags> {
   116163: 1287:  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }
        -: 1288:};
        -: 1289:
        -: 1290:template <> struct applicator<MiscFlags> {
        -: 1291:  static void opt(MiscFlags MF, Option &O) {
        -: 1292:    assert((MF != Grouping || O.ArgStr.size() == 1) &&
        -: 1293:           "cl::Grouping can only apply to single character Options.");
        -: 1294:    O.setMiscFlag(MF);
        -: 1295:  }
        -: 1296:};
        -: 1297:
        -: 1298:// Apply modifiers to an option in a type safe way.
        -: 1299:template <class Opt, class Mod, class... Mods>
  1161630: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
  1161630: 1301:  applicator<Mod>::opt(M, *O);
  1161630: 1302:  apply(O, Ms...);
  1045467: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA14_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA14_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_ called 232326 returned 100% blocks executed 100%
   232326: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   232326: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   232326: 1302:  apply(O, Ms...);
   232326: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA27_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA27_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_ called 116163 returned 100% blocks executed 100%
   116163: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   116163: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   116163: 1302:  apply(O, Ms...);
   116163: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA12_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA12_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_ called 116163 returned 100% blocks executed 100%
   116163: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   116163: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   116163: 1302:  apply(O, Ms...);
   116163: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA19_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA19_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_ called 348489 returned 100% blocks executed 100%
   348489: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   348489: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   348489: 1302:  apply(O, Ms...);
   348489: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA17_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optIbLb0ENS0_6parserIbEEEEA17_cJNS0_4descENS0_11initializerIbEEEEEvPT_RKT0_DpRKT1_ called 116163 returned 100% blocks executed 100%
   116163: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   116163: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   116163: 1302:  apply(O, Ms...);
   116163: 1303:}
------------------
_ZN4llvm2cl5applyINS0_3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS8_EEEEA2_cJNS0_4descENS0_10value_descENS0_11initializerISC_EEEEEvPT_RKT0_DpRKT1_:
function _ZN4llvm2cl5applyINS0_3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS8_EEEEA2_cJNS0_4descENS0_10value_descENS0_11initializerISC_EEEEEvPT_RKT0_DpRKT1_ called 116163 returned 100% blocks executed 100%
   116163: 1300:void apply(Opt *O, const Mod &M, const Mods &... Ms) {
call    0 returned 100%
   116163: 1301:  applicator<Mod>::opt(M, *O);
call    0 returned 100%
   116163: 1302:  apply(O, Ms...);
   116163: 1303:}
------------------
        -: 1304:
   116163: 1305:template <class Opt, class Mod> void apply(Opt *O, const Mod &M) {
call    0 returned 100%
  1161630: 1306:  applicator<Mod>::opt(M, *O);
        -: 1307:}
        -: 1308:
        -: 1309://===----------------------------------------------------------------------===//
        -: 1310:// Default storage class definition: external storage.  This implementation
        -: 1311:// assumes the user will specify a variable to store the data into with the
        -: 1312:// cl::location(x) modifier.
        -: 1313://
        -: 1314:template <class DataType, bool ExternalStorage, bool isClass>
        -: 1315:class opt_storage {
        -: 1316:  DataType *Location = nullptr; // Where to store the object...
        -: 1317:  OptionValue<DataType> Default;
        -: 1318:
        -: 1319:  void check_location() const {
        -: 1320:    assert(Location && "cl::location(...) not specified for a command "
        -: 1321:                       "line option with external storage, "
        -: 1322:                       "or cl::init specified before cl::location()!!");
        -: 1323:  }
        -: 1324:
        -: 1325:public:
        -: 1326:  opt_storage() = default;
        -: 1327:
        -: 1328:  bool setLocation(Option &O, DataType &L) {
        -: 1329:    if (Location)
        -: 1330:      return O.error("cl::location(x) specified more than once!");
        -: 1331:    Location = &L;
        -: 1332:    Default = L;
        -: 1333:    return false;
        -: 1334:  }
        -: 1335:
        -: 1336:  template <class T> void setValue(const T &V, bool initial = false) {
        -: 1337:    check_location();
        -: 1338:    *Location = V;
        -: 1339:    if (initial)
        -: 1340:      Default = V;
        -: 1341:  }
        -: 1342:
        -: 1343:  DataType &getValue() {
        -: 1344:    check_location();
        -: 1345:    return *Location;
        -: 1346:  }
        -: 1347:  const DataType &getValue() const {
        -: 1348:    check_location();
        -: 1349:    return *Location;
        -: 1350:  }
        -: 1351:
        -: 1352:  operator DataType() const { return this->getValue(); }
        -: 1353:
        -: 1354:  const OptionValue<DataType> &getDefault() const { return Default; }
        -: 1355:};
        -: 1356:
        -: 1357:// Define how to hold a class type object, such as a string.  Since we can
        -: 1358:// inherit from a class, we do so.  This makes us exactly compatible with the
        -: 1359:// object in all cases that it is used.
        -: 1360://
        -: 1361:template <class DataType>
   232326: 1362:class opt_storage<DataType, false, true> : public DataType {
        -: 1363:public:
        -: 1364:  OptionValue<DataType> Default;
        -: 1365:
        -: 1366:  template <class T> void setValue(const T &V, bool initial = false) {
        -: 1367:    DataType::operator=(V);
        -: 1368:    if (initial)
        -: 1369:      Default = V;
        -: 1370:  }
        -: 1371:
        -: 1372:  DataType &getValue() { return *this; }
        -: 1373:  const DataType &getValue() const { return *this; }
        -: 1374:
        -: 1375:  const OptionValue<DataType> &getDefault() const { return Default; }
        -: 1376:};
        -: 1377:
        -: 1378:// Define a partial specialization to handle things we cannot inherit from.  In
        -: 1379:// this case, we store an instance through containment, and overload operators
        -: 1380:// to get at the value.
        -: 1381://
        -: 1382:template <class DataType> class opt_storage<DataType, false, false> {
        -: 1383:public:
        -: 1384:  DataType Value;
        -: 1385:  OptionValue<DataType> Default;
        -: 1386:
        -: 1387:  // Make sure we initialize the value with the default constructor for the
        -: 1388:  // type.
   929304: 1389:  opt_storage() : Value(DataType()), Default() {}
        -: 1390:
   929304: 1391:  template <class T> void setValue(const T &V, bool initial = false) {
   929304: 1392:    Value = V;
        -: 1393:    if (initial)
   929304: 1394:      Default = V;
        -: 1395:  }
        -: 1396:  DataType &getValue() { return Value; }
   189647: 1397:  DataType getValue() const { return Value; }
        -: 1398:
        -: 1399:  const OptionValue<DataType> &getDefault() const { return Default; }
        -: 1400:
   189647: 1401:  operator DataType() const { return getValue(); }
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
        -: 1402:
        -: 1403:  // If the datatype is a pointer, support -> on it.
        -: 1404:  DataType operator->() const { return Value; }
        -: 1405:};
        -: 1406:
        -: 1407://===----------------------------------------------------------------------===//
        -: 1408:// A scalar command line option.
        -: 1409://
        -: 1410:template <class DataType, bool ExternalStorage = false,
        -: 1411:          class ParserClass = parser<DataType>>
        -: 1412:class opt : public Option,
        -: 1413:            public opt_storage<DataType, ExternalStorage,
        -: 1414:                               std::is_class<DataType>::value> {
        -: 1415:  ParserClass Parser;
        -: 1416:
        -: 1417:  bool handleOccurrence(unsigned pos, StringRef ArgName,
        -: 1418:                        StringRef Arg) override {
        -: 1419:    typename ParserClass::parser_data_type Val =
        -: 1420:        typename ParserClass::parser_data_type();
        -: 1421:    if (Parser.parse(*this, ArgName, Arg, Val))
        -: 1422:      return true; // Parse error!
        -: 1423:    this->setValue(Val);
        -: 1424:    this->setPosition(pos);
        -: 1425:    Callback(Val);
        -: 1426:    return false;
        -: 1427:  }
        -: 1428:
        -: 1429:  enum ValueExpected getValueExpectedFlagDefault() const override {
        -: 1430:    return Parser.getValueExpectedFlagDefault();
        -: 1431:  }
        -: 1432:
        -: 1433:  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {
        -: 1434:    return Parser.getExtraOptionNames(OptionNames);
        -: 1435:  }
        -: 1436:
        -: 1437:  // Forward printing stuff to the parser...
        -: 1438:  size_t getOptionWidth() const override {
        -: 1439:    return Parser.getOptionWidth(*this);
        -: 1440:  }
        -: 1441:
        -: 1442:  void printOptionInfo(size_t GlobalWidth) const override {
        -: 1443:    Parser.printOptionInfo(*this, GlobalWidth);
        -: 1444:  }
        -: 1445:
        -: 1446:  void printOptionValue(size_t GlobalWidth, bool Force) const override {
        -: 1447:    if (Force || this->getDefault().compare(this->getValue())) {
        -: 1448:      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),
        -: 1449:                                       this->getDefault(), GlobalWidth);
        -: 1450:    }
        -: 1451:  }
        -: 1452:
        -: 1453:  template <class T,
        -: 1454:            class = std::enable_if_t<std::is_assignable<T &, T>::value>>
        -: 1455:  void setDefaultImpl() {
        -: 1456:    const OptionValue<DataType> &V = this->getDefault();
        -: 1457:    if (V.hasValue())
        -: 1458:      this->setValue(V.getValue());
        -: 1459:    else
        -: 1460:      this->setValue(T());
        -: 1461:  }
        -: 1462:
        -: 1463:  template <class T,
        -: 1464:            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>
        -: 1465:  void setDefaultImpl(...) {}
        -: 1466:
        -: 1467:  void setDefault() override { setDefaultImpl<DataType>(); }
        -: 1468:
  1161630: 1469:  void done() {
  1161630: 1470:    addArgument();
  1161630: 1471:    Parser.initialize();
        -: 1472:  }
        -: 1473:
        -: 1474:public:
        -: 1475:  // Command line options should not be copyable
        -: 1476:  opt(const opt &) = delete;
        -: 1477:  opt &operator=(const opt &) = delete;
        -: 1478:
        -: 1479:  // setInitialValue - Used by the cl::init modifier...
   929304: 1480:  void setInitialValue(const DataType &V) { this->setValue(V, true); }
        -: 1481:
        -: 1482:  ParserClass &getParser() { return Parser; }
        -: 1483:
        -: 1484:  template <class T> DataType &operator=(const T &Val) {
        -: 1485:    this->setValue(Val);
        -: 1486:    Callback(Val);
        -: 1487:    return this->getValue();
        -: 1488:  }
        -: 1489:
        -: 1490:  template <class... Mods>
  1161630: 1491:  explicit opt(const Mods &... Ms)
  1161630: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
  1161630: 1493:    apply(this, Ms...);
  1161630: 1494:    done();
  1161630: 1495:  }
------------------
_ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA14_cNS0_4descENS0_11initializerIbEEEEEDpRKT_:
function _ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA14_cNS0_4descENS0_11initializerIbEEEEEDpRKT_ called 232326 returned 100% blocks executed 100%
   232326: 1491:  explicit opt(const Mods &... Ms)
   232326: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   232326: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   232326: 1494:    done();
   232326: 1495:  }
------------------
_ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA27_cNS0_4descENS0_11initializerIbEEEEEDpRKT_:
function _ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA27_cNS0_4descENS0_11initializerIbEEEEEDpRKT_ called 116163 returned 100% blocks executed 100%
   116163: 1491:  explicit opt(const Mods &... Ms)
   116163: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   116163: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   116163: 1494:    done();
   116163: 1495:  }
------------------
_ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA12_cNS0_4descENS0_11initializerIbEEEEEDpRKT_:
function _ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA12_cNS0_4descENS0_11initializerIbEEEEEDpRKT_ called 116163 returned 100% blocks executed 100%
   116163: 1491:  explicit opt(const Mods &... Ms)
   116163: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   116163: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   116163: 1494:    done();
   116163: 1495:  }
------------------
_ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA19_cNS0_4descENS0_11initializerIbEEEEEDpRKT_:
function _ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA19_cNS0_4descENS0_11initializerIbEEEEEDpRKT_ called 348489 returned 100% blocks executed 100%
   348489: 1491:  explicit opt(const Mods &... Ms)
   348489: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   348489: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   348489: 1494:    done();
   348489: 1495:  }
------------------
_ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA17_cNS0_4descENS0_11initializerIbEEEEEDpRKT_:
function _ZN4llvm2cl3optIbLb0ENS0_6parserIbEEEC2IJA17_cNS0_4descENS0_11initializerIbEEEEEDpRKT_ called 116163 returned 100% blocks executed 100%
   116163: 1491:  explicit opt(const Mods &... Ms)
   116163: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   116163: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   116163: 1494:    done();
   116163: 1495:  }
------------------
_ZN4llvm2cl3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS7_EEEC2IJA2_cNS0_4descENS0_10value_descENS0_11initializerISC_EEEEEDpRKT_:
function _ZN4llvm2cl3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS7_EEEC2IJA2_cNS0_4descENS0_10value_descENS0_11initializerISC_EEEEEDpRKT_ called 116163 returned 100% blocks executed 100%
   116163: 1491:  explicit opt(const Mods &... Ms)
   116163: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   116163: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   116163: 1494:    done();
   116163: 1495:  }
------------------
_ZN4llvm2cl3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS7_EEEC2IJNS0_15FormattingFlagsENS0_4descENS0_11initializerIA2_cEEEEEDpRKT_:
function _ZN4llvm2cl3optINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb0ENS0_6parserIS7_EEEC2IJNS0_15FormattingFlagsENS0_4descENS0_11initializerIA2_cEEEEEDpRKT_ called 116163 returned 100% blocks executed 100%
   116163: 1491:  explicit opt(const Mods &... Ms)
   116163: 1492:      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {
call    0 returned 100%
call    1 returned 100%
   116163: 1493:    apply(this, Ms...);
call    0 returned 100%
call    1 returned 100%
   116163: 1494:    done();
   116163: 1495:  }
------------------
        -: 1496:
        -: 1497:  void setCallback(
        -: 1498:      std::function<void(const typename ParserClass::parser_data_type &)> CB) {
        -: 1499:    Callback = CB;
        -: 1500:  }
        -: 1501:
        -: 1502:  std::function<void(const typename ParserClass::parser_data_type &)> Callback =
    #####: 1503:      [](const typename ParserClass::parser_data_type &) {};
        -: 1504:};
        -: 1505:
        -: 1506:extern template class opt<unsigned>;
        -: 1507:extern template class opt<int>;
        -: 1508:extern template class opt<std::string>;
        -: 1509:extern template class opt<char>;
        -: 1510:extern template class opt<bool>;
        -: 1511:
        -: 1512://===----------------------------------------------------------------------===//
        -: 1513:// Default storage class definition: external storage.  This implementation
        -: 1514:// assumes the user will specify a variable to store the data into with the
        -: 1515:// cl::location(x) modifier.
        -: 1516://
        -: 1517:template <class DataType, class StorageClass> class list_storage {
        -: 1518:  StorageClass *Location = nullptr; // Where to store the object...
        -: 1519:  std::vector<OptionValue<DataType>> Default =
        -: 1520:      std::vector<OptionValue<DataType>>();
        -: 1521:  bool DefaultAssigned = false;
        -: 1522:
        -: 1523:public:
        -: 1524:  list_storage() = default;
        -: 1525:
        -: 1526:  void clear() {}
        -: 1527:
        -: 1528:  bool setLocation(Option &O, StorageClass &L) {
        -: 1529:    if (Location)
        -: 1530:      return O.error("cl::location(x) specified more than once!");
        -: 1531:    Location = &L;
        -: 1532:    return false;
        -: 1533:  }
        -: 1534:
        -: 1535:  template <class T> void addValue(const T &V, bool initial = false) {
        -: 1536:    assert(Location != nullptr &&
        -: 1537:           "cl::location(...) not specified for a command "
        -: 1538:           "line option with external storage!");
        -: 1539:    Location->push_back(V);
        -: 1540:    if (initial)
        -: 1541:      Default.push_back(V);
        -: 1542:  }
        -: 1543:
        -: 1544:  const std::vector<OptionValue<DataType>> &getDefault() const {
        -: 1545:    return Default;
        -: 1546:  }
        -: 1547:
        -: 1548:  void assignDefault() { DefaultAssigned = true; }
        -: 1549:  void overwriteDefault() { DefaultAssigned = false; }
        -: 1550:  bool isDefaultAssigned() { return DefaultAssigned; }
        -: 1551:};
        -: 1552:
        -: 1553:// Define how to hold a class type object, such as a string.
        -: 1554:// Originally this code inherited from std::vector. In transitioning to a new
        -: 1555:// API for command line options we should change this. The new implementation
        -: 1556:// of this list_storage specialization implements the minimum subset of the
        -: 1557:// std::vector API required for all the current clients.
        -: 1558://
        -: 1559:// FIXME: Reduce this API to a more narrow subset of std::vector
        -: 1560://
        -: 1561:template <class DataType> class list_storage<DataType, bool> {
        -: 1562:  std::vector<DataType> Storage;
        -: 1563:  std::vector<OptionValue<DataType>> Default;
        -: 1564:  bool DefaultAssigned = false;
        -: 1565:
        -: 1566:public:
        -: 1567:  using iterator = typename std::vector<DataType>::iterator;
        -: 1568:
        -: 1569:  iterator begin() { return Storage.begin(); }
        -: 1570:  iterator end() { return Storage.end(); }
        -: 1571:
        -: 1572:  using const_iterator = typename std::vector<DataType>::const_iterator;
        -: 1573:
        -: 1574:  const_iterator begin() const { return Storage.begin(); }
        -: 1575:  const_iterator end() const { return Storage.end(); }
        -: 1576:
        -: 1577:  using size_type = typename std::vector<DataType>::size_type;
        -: 1578:
        -: 1579:  size_type size() const { return Storage.size(); }
        -: 1580:
        -: 1581:  bool empty() const { return Storage.empty(); }
        -: 1582:
        -: 1583:  void push_back(const DataType &value) { Storage.push_back(value); }
        -: 1584:  void push_back(DataType &&value) { Storage.push_back(value); }
        -: 1585:
        -: 1586:  using reference = typename std::vector<DataType>::reference;
        -: 1587:  using const_reference = typename std::vector<DataType>::const_reference;
        -: 1588:
        -: 1589:  reference operator[](size_type pos) { return Storage[pos]; }
        -: 1590:  const_reference operator[](size_type pos) const { return Storage[pos]; }
        -: 1591:
        -: 1592:  void clear() {
        -: 1593:    Storage.clear();
        -: 1594:  }
        -: 1595:
        -: 1596:  iterator erase(const_iterator pos) { return Storage.erase(pos); }
        -: 1597:  iterator erase(const_iterator first, const_iterator last) {
        -: 1598:    return Storage.erase(first, last);
        -: 1599:  }
        -: 1600:
        -: 1601:  iterator erase(iterator pos) { return Storage.erase(pos); }
        -: 1602:  iterator erase(iterator first, iterator last) {
        -: 1603:    return Storage.erase(first, last);
        -: 1604:  }
        -: 1605:
        -: 1606:  iterator insert(const_iterator pos, const DataType &value) {
        -: 1607:    return Storage.insert(pos, value);
        -: 1608:  }
        -: 1609:  iterator insert(const_iterator pos, DataType &&value) {
        -: 1610:    return Storage.insert(pos, value);
        -: 1611:  }
        -: 1612:
        -: 1613:  iterator insert(iterator pos, const DataType &value) {
        -: 1614:    return Storage.insert(pos, value);
        -: 1615:  }
        -: 1616:  iterator insert(iterator pos, DataType &&value) {
        -: 1617:    return Storage.insert(pos, value);
        -: 1618:  }
        -: 1619:
        -: 1620:  reference front() { return Storage.front(); }
        -: 1621:  const_reference front() const { return Storage.front(); }
        -: 1622:
        -: 1623:  operator std::vector<DataType> &() { return Storage; }
        -: 1624:  operator ArrayRef<DataType>() const { return Storage; }
        -: 1625:  std::vector<DataType> *operator&() { return &Storage; }
        -: 1626:  const std::vector<DataType> *operator&() const { return &Storage; }
        -: 1627:
        -: 1628:  template <class T> void addValue(const T &V, bool initial = false) {
        -: 1629:    Storage.push_back(V);
        -: 1630:    if (initial)
        -: 1631:      Default.push_back(OptionValue<DataType>(V));
        -: 1632:  }
        -: 1633:
        -: 1634:  const std::vector<OptionValue<DataType>> &getDefault() const {
        -: 1635:    return Default;
        -: 1636:  }
        -: 1637:
        -: 1638:  void assignDefault() { DefaultAssigned = true; }
        -: 1639:  void overwriteDefault() { DefaultAssigned = false; }
        -: 1640:  bool isDefaultAssigned() { return DefaultAssigned; }
        -: 1641:};
        -: 1642:
        -: 1643://===----------------------------------------------------------------------===//
        -: 1644:// A list of command line options.
        -: 1645://
        -: 1646:template <class DataType, class StorageClass = bool,
        -: 1647:          class ParserClass = parser<DataType>>
        -: 1648:class list : public Option, public list_storage<DataType, StorageClass> {
        -: 1649:  std::vector<unsigned> Positions;
        -: 1650:  ParserClass Parser;
        -: 1651:
        -: 1652:  enum ValueExpected getValueExpectedFlagDefault() const override {
        -: 1653:    return Parser.getValueExpectedFlagDefault();
        -: 1654:  }
        -: 1655:
        -: 1656:  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {
        -: 1657:    return Parser.getExtraOptionNames(OptionNames);
        -: 1658:  }
        -: 1659:
        -: 1660:  bool handleOccurrence(unsigned pos, StringRef ArgName,
        -: 1661:                        StringRef Arg) override {
        -: 1662:    typename ParserClass::parser_data_type Val =
        -: 1663:        typename ParserClass::parser_data_type();
        -: 1664:    if (list_storage<DataType, StorageClass>::isDefaultAssigned()) {
        -: 1665:      clear();
        -: 1666:      list_storage<DataType, StorageClass>::overwriteDefault();
        -: 1667:    }
        -: 1668:    if (Parser.parse(*this, ArgName, Arg, Val))
        -: 1669:      return true; // Parse Error!
        -: 1670:    list_storage<DataType, StorageClass>::addValue(Val);
        -: 1671:    setPosition(pos);
        -: 1672:    Positions.push_back(pos);
        -: 1673:    Callback(Val);
        -: 1674:    return false;
        -: 1675:  }
        -: 1676:
        -: 1677:  // Forward printing stuff to the parser...
        -: 1678:  size_t getOptionWidth() const override {
        -: 1679:    return Parser.getOptionWidth(*this);
        -: 1680:  }
        -: 1681:
        -: 1682:  void printOptionInfo(size_t GlobalWidth) const override {
        -: 1683:    Parser.printOptionInfo(*this, GlobalWidth);
        -: 1684:  }
        -: 1685:
        -: 1686:  // Unimplemented: list options don't currently store their default value.
        -: 1687:  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {
        -: 1688:  }
        -: 1689:
        -: 1690:  void setDefault() override {
        -: 1691:    Positions.clear();
        -: 1692:    list_storage<DataType, StorageClass>::clear();
        -: 1693:    for (auto &Val : list_storage<DataType, StorageClass>::getDefault())
        -: 1694:      list_storage<DataType, StorageClass>::addValue(Val.getValue());
        -: 1695:  }
        -: 1696:
        -: 1697:  void done() {
        -: 1698:    addArgument();
        -: 1699:    Parser.initialize();
        -: 1700:  }
        -: 1701:
        -: 1702:public:
        -: 1703:  // Command line options should not be copyable
        -: 1704:  list(const list &) = delete;
        -: 1705:  list &operator=(const list &) = delete;
        -: 1706:
        -: 1707:  ParserClass &getParser() { return Parser; }
        -: 1708:
        -: 1709:  unsigned getPosition(unsigned optnum) const {
        -: 1710:    assert(optnum < this->size() && "Invalid option index");
        -: 1711:    return Positions[optnum];
        -: 1712:  }
        -: 1713:
        -: 1714:  void clear() {
        -: 1715:    Positions.clear();
        -: 1716:    list_storage<DataType, StorageClass>::clear();
        -: 1717:  }
        -: 1718:
        -: 1719:  // setInitialValues - Used by the cl::list_init modifier...
        -: 1720:  void setInitialValues(ArrayRef<DataType> Vs) {
        -: 1721:    assert(!(list_storage<DataType, StorageClass>::isDefaultAssigned()) &&
        -: 1722:           "Cannot have two default values");
        -: 1723:    list_storage<DataType, StorageClass>::assignDefault();
        -: 1724:    for (auto &Val : Vs)
        -: 1725:      list_storage<DataType, StorageClass>::addValue(Val, true);
        -: 1726:  }
        -: 1727:
        -: 1728:  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }
        -: 1729:
        -: 1730:  template <class... Mods>
        -: 1731:  explicit list(const Mods &... Ms)
        -: 1732:      : Option(ZeroOrMore, NotHidden), Parser(*this) {
        -: 1733:    apply(this, Ms...);
        -: 1734:    done();
        -: 1735:  }
        -: 1736:
        -: 1737:  void setCallback(
        -: 1738:      std::function<void(const typename ParserClass::parser_data_type &)> CB) {
        -: 1739:    Callback = CB;
        -: 1740:  }
        -: 1741:
        -: 1742:  std::function<void(const typename ParserClass::parser_data_type &)> Callback =
        -: 1743:      [](const typename ParserClass::parser_data_type &) {};
        -: 1744:};
        -: 1745:
        -: 1746:// Modifier to set the number of additional values.
        -: 1747:struct multi_val {
        -: 1748:  unsigned AdditionalVals;
        -: 1749:  explicit multi_val(unsigned N) : AdditionalVals(N) {}
        -: 1750:
        -: 1751:  template <typename D, typename S, typename P>
        -: 1752:  void apply(list<D, S, P> &L) const {
        -: 1753:    L.setNumAdditionalVals(AdditionalVals);
        -: 1754:  }
        -: 1755:};
        -: 1756:
        -: 1757://===----------------------------------------------------------------------===//
        -: 1758:// Default storage class definition: external storage.  This implementation
        -: 1759:// assumes the user will specify a variable to store the data into with the
        -: 1760:// cl::location(x) modifier.
        -: 1761://
        -: 1762:template <class DataType, class StorageClass> class bits_storage {
        -: 1763:  unsigned *Location = nullptr; // Where to store the bits...
        -: 1764:
        -: 1765:  template <class T> static unsigned Bit(const T &V) {
        -: 1766:    unsigned BitPos = static_cast<unsigned>(V);
        -: 1767:    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&
        -: 1768:           "enum exceeds width of bit vector!");
        -: 1769:    return 1 << BitPos;
        -: 1770:  }
        -: 1771:
        -: 1772:public:
        -: 1773:  bits_storage() = default;
        -: 1774:
        -: 1775:  bool setLocation(Option &O, unsigned &L) {
        -: 1776:    if (Location)
        -: 1777:      return O.error("cl::location(x) specified more than once!");
        -: 1778:    Location = &L;
        -: 1779:    return false;
        -: 1780:  }
        -: 1781:
        -: 1782:  template <class T> void addValue(const T &V) {
        -: 1783:    assert(Location != nullptr &&
        -: 1784:           "cl::location(...) not specified for a command "
        -: 1785:           "line option with external storage!");
        -: 1786:    *Location |= Bit(V);
        -: 1787:  }
        -: 1788:
        -: 1789:  unsigned getBits() { return *Location; }
        -: 1790:
        -: 1791:  void clear() {
        -: 1792:    if (Location)
        -: 1793:      *Location = 0;
        -: 1794:  }
        -: 1795:
        -: 1796:  template <class T> bool isSet(const T &V) {
        -: 1797:    return (*Location & Bit(V)) != 0;
        -: 1798:  }
        -: 1799:};
        -: 1800:
        -: 1801:// Define how to hold bits.  Since we can inherit from a class, we do so.
        -: 1802:// This makes us exactly compatible with the bits in all cases that it is used.
        -: 1803://
        -: 1804:template <class DataType> class bits_storage<DataType, bool> {
        -: 1805:  unsigned Bits{0}; // Where to store the bits...
        -: 1806:
        -: 1807:  template <class T> static unsigned Bit(const T &V) {
        -: 1808:    unsigned BitPos = static_cast<unsigned>(V);
        -: 1809:    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&
        -: 1810:           "enum exceeds width of bit vector!");
        -: 1811:    return 1 << BitPos;
        -: 1812:  }
        -: 1813:
        -: 1814:public:
        -: 1815:  template <class T> void addValue(const T &V) { Bits |= Bit(V); }
        -: 1816:
        -: 1817:  unsigned getBits() { return Bits; }
        -: 1818:
        -: 1819:  void clear() { Bits = 0; }
        -: 1820:
        -: 1821:  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }
        -: 1822:};
        -: 1823:
        -: 1824://===----------------------------------------------------------------------===//
        -: 1825:// A bit vector of command options.
        -: 1826://
        -: 1827:template <class DataType, class Storage = bool,
        -: 1828:          class ParserClass = parser<DataType>>
        -: 1829:class bits : public Option, public bits_storage<DataType, Storage> {
        -: 1830:  std::vector<unsigned> Positions;
        -: 1831:  ParserClass Parser;
        -: 1832:
        -: 1833:  enum ValueExpected getValueExpectedFlagDefault() const override {
        -: 1834:    return Parser.getValueExpectedFlagDefault();
        -: 1835:  }
        -: 1836:
        -: 1837:  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {
        -: 1838:    return Parser.getExtraOptionNames(OptionNames);
        -: 1839:  }
        -: 1840:
        -: 1841:  bool handleOccurrence(unsigned pos, StringRef ArgName,
        -: 1842:                        StringRef Arg) override {
        -: 1843:    typename ParserClass::parser_data_type Val =
        -: 1844:        typename ParserClass::parser_data_type();
        -: 1845:    if (Parser.parse(*this, ArgName, Arg, Val))
        -: 1846:      return true; // Parse Error!
        -: 1847:    this->addValue(Val);
        -: 1848:    setPosition(pos);
        -: 1849:    Positions.push_back(pos);
        -: 1850:    Callback(Val);
        -: 1851:    return false;
        -: 1852:  }
        -: 1853:
        -: 1854:  // Forward printing stuff to the parser...
        -: 1855:  size_t getOptionWidth() const override {
        -: 1856:    return Parser.getOptionWidth(*this);
        -: 1857:  }
        -: 1858:
        -: 1859:  void printOptionInfo(size_t GlobalWidth) const override {
        -: 1860:    Parser.printOptionInfo(*this, GlobalWidth);
        -: 1861:  }
        -: 1862:
        -: 1863:  // Unimplemented: bits options don't currently store their default values.
        -: 1864:  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {
        -: 1865:  }
        -: 1866:
        -: 1867:  void setDefault() override { bits_storage<DataType, Storage>::clear(); }
        -: 1868:
        -: 1869:  void done() {
        -: 1870:    addArgument();
        -: 1871:    Parser.initialize();
        -: 1872:  }
        -: 1873:
        -: 1874:public:
        -: 1875:  // Command line options should not be copyable
        -: 1876:  bits(const bits &) = delete;
        -: 1877:  bits &operator=(const bits &) = delete;
        -: 1878:
        -: 1879:  ParserClass &getParser() { return Parser; }
        -: 1880:
        -: 1881:  unsigned getPosition(unsigned optnum) const {
        -: 1882:    assert(optnum < this->size() && "Invalid option index");
        -: 1883:    return Positions[optnum];
        -: 1884:  }
        -: 1885:
        -: 1886:  template <class... Mods>
        -: 1887:  explicit bits(const Mods &... Ms)
        -: 1888:      : Option(ZeroOrMore, NotHidden), Parser(*this) {
        -: 1889:    apply(this, Ms...);
        -: 1890:    done();
        -: 1891:  }
        -: 1892:
        -: 1893:  void setCallback(
        -: 1894:      std::function<void(const typename ParserClass::parser_data_type &)> CB) {
        -: 1895:    Callback = CB;
        -: 1896:  }
        -: 1897:
        -: 1898:  std::function<void(const typename ParserClass::parser_data_type &)> Callback =
        -: 1899:      [](const typename ParserClass::parser_data_type &) {};
        -: 1900:};
        -: 1901:
        -: 1902://===----------------------------------------------------------------------===//
        -: 1903:// Aliased command line option (alias this name to a preexisting name)
        -: 1904://
        -: 1905:
        -: 1906:class alias : public Option {
        -: 1907:  Option *AliasFor;
        -: 1908:
        -: 1909:  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,
        -: 1910:                        StringRef Arg) override {
        -: 1911:    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);
        -: 1912:  }
        -: 1913:
        -: 1914:  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,
        -: 1915:                     bool MultiArg = false) override {
        -: 1916:    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);
        -: 1917:  }
        -: 1918:
        -: 1919:  // Handle printing stuff...
        -: 1920:  size_t getOptionWidth() const override;
        -: 1921:  void printOptionInfo(size_t GlobalWidth) const override;
        -: 1922:
        -: 1923:  // Aliases do not need to print their values.
        -: 1924:  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {
        -: 1925:  }
        -: 1926:
        -: 1927:  void setDefault() override { AliasFor->setDefault(); }
        -: 1928:
        -: 1929:  ValueExpected getValueExpectedFlagDefault() const override {
        -: 1930:    return AliasFor->getValueExpectedFlag();
        -: 1931:  }
        -: 1932:
        -: 1933:  void done() {
        -: 1934:    if (!hasArgStr())
        -: 1935:      error("cl::alias must have argument name specified!");
        -: 1936:    if (!AliasFor)
        -: 1937:      error("cl::alias must have an cl::aliasopt(option) specified!");
        -: 1938:    if (!Subs.empty())
        -: 1939:      error("cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!");
        -: 1940:    Subs = AliasFor->Subs;
        -: 1941:    Categories = AliasFor->Categories;
        -: 1942:    addArgument();
        -: 1943:  }
        -: 1944:
        -: 1945:public:
        -: 1946:  // Command line options should not be copyable
        -: 1947:  alias(const alias &) = delete;
        -: 1948:  alias &operator=(const alias &) = delete;
        -: 1949:
        -: 1950:  void setAliasFor(Option &O) {
        -: 1951:    if (AliasFor)
        -: 1952:      error("cl::alias must only have one cl::aliasopt(...) specified!");
        -: 1953:    AliasFor = &O;
        -: 1954:  }
        -: 1955:
        -: 1956:  template <class... Mods>
        -: 1957:  explicit alias(const Mods &... Ms)
        -: 1958:      : Option(Optional, Hidden), AliasFor(nullptr) {
        -: 1959:    apply(this, Ms...);
        -: 1960:    done();
        -: 1961:  }
        -: 1962:};
        -: 1963:
        -: 1964:// Modifier to set the option an alias aliases.
        -: 1965:struct aliasopt {
        -: 1966:  Option &Opt;
        -: 1967:
        -: 1968:  explicit aliasopt(Option &O) : Opt(O) {}
        -: 1969:
        -: 1970:  void apply(alias &A) const { A.setAliasFor(Opt); }
        -: 1971:};
        -: 1972:
        -: 1973:// Provide additional help at the end of the normal help output. All occurrences
        -: 1974:// of cl::extrahelp will be accumulated and printed to stderr at the end of the
        -: 1975:// regular help, just before exit is called.
        -: 1976:struct extrahelp {
        -: 1977:  StringRef morehelp;
        -: 1978:
        -: 1979:  explicit extrahelp(StringRef help);
        -: 1980:};
        -: 1981:
        -: 1982:void PrintVersionMessage();
        -: 1983:
        -: 1984:/// This function just prints the help message, exactly the same way as if the
        -: 1985:/// -help or -help-hidden option had been given on the command line.
        -: 1986:///
        -: 1987:/// \param Hidden if true will print hidden options
        -: 1988:/// \param Categorized if true print options in categories
        -: 1989:void PrintHelpMessage(bool Hidden = false, bool Categorized = false);
        -: 1990:
        -: 1991://===----------------------------------------------------------------------===//
        -: 1992:// Public interface for accessing registered options.
        -: 1993://
        -: 1994:
        -: 1995:/// Use this to get a StringMap to all registered named options
        -: 1996:/// (e.g. -help).
        -: 1997:///
        -: 1998:/// \return A reference to the StringMap used by the cl APIs to parse options.
        -: 1999:///
        -: 2000:/// Access to unnamed arguments (i.e. positional) are not provided because
        -: 2001:/// it is expected that the client already has access to these.
        -: 2002:///
        -: 2003:/// Typical usage:
        -: 2004:/// \code
        -: 2005:/// main(int argc,char* argv[]) {
        -: 2006:/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();
        -: 2007:/// assert(opts.count("help") == 1)
        -: 2008:/// opts["help"]->setDescription("Show alphabetical help information")
        -: 2009:/// // More code
        -: 2010:/// llvm::cl::ParseCommandLineOptions(argc,argv);
        -: 2011:/// //More code
        -: 2012:/// }
        -: 2013:/// \endcode
        -: 2014:///
        -: 2015:/// This interface is useful for modifying options in libraries that are out of
        -: 2016:/// the control of the client. The options should be modified before calling
        -: 2017:/// llvm::cl::ParseCommandLineOptions().
        -: 2018:///
        -: 2019:/// Hopefully this API can be deprecated soon. Any situation where options need
        -: 2020:/// to be modified by tools or libraries should be handled by sane APIs rather
        -: 2021:/// than just handing around a global list.
        -: 2022:StringMap<Option *> &
        -: 2023:getRegisteredOptions(SubCommand &Sub = SubCommand::getTopLevel());
        -: 2024:
        -: 2025:/// Use this to get all registered SubCommands from the provided parser.
        -: 2026:///
        -: 2027:/// \return A range of all SubCommand pointers registered with the parser.
        -: 2028:///
        -: 2029:/// Typical usage:
        -: 2030:/// \code
        -: 2031:/// main(int argc, char* argv[]) {
        -: 2032:///   llvm::cl::ParseCommandLineOptions(argc, argv);
        -: 2033:///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {
        -: 2034:///     if (*S) {
        -: 2035:///       std::cout << "Executing subcommand: " << S->getName() << std::endl;
        -: 2036:///       // Execute some function based on the name...
        -: 2037:///     }
        -: 2038:///   }
        -: 2039:/// }
        -: 2040:/// \endcode
        -: 2041:///
        -: 2042:/// This interface is useful for defining subcommands in libraries and
        -: 2043:/// the dispatch from a single point (like in the main function).
        -: 2044:iterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>
        -: 2045:getRegisteredSubcommands();
        -: 2046:
        -: 2047://===----------------------------------------------------------------------===//
        -: 2048:// Standalone command line processing utilities.
        -: 2049://
        -: 2050:
        -: 2051:/// Tokenizes a command line that can contain escapes and quotes.
        -: 2052://
        -: 2053:/// The quoting rules match those used by GCC and other tools that use
        -: 2054:/// libiberty's buildargv() or expandargv() utilities, and do not match bash.
        -: 2055:/// They differ from buildargv() on treatment of backslashes that do not escape
        -: 2056:/// a special character to make it possible to accept most Windows file paths.
        -: 2057:///
        -: 2058:/// \param [in] Source The string to be split on whitespace with quotes.
        -: 2059:/// \param [in] Saver Delegates back to the caller for saving parsed strings.
        -: 2060:/// \param [in] MarkEOLs true if tokenizing a response file and you want end of
        -: 2061:/// lines and end of the response file to be marked with a nullptr string.
        -: 2062:/// \param [out] NewArgv All parsed strings are appended to NewArgv.
        -: 2063:void TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,
        -: 2064:                            SmallVectorImpl<const char *> &NewArgv,
        -: 2065:                            bool MarkEOLs = false);
        -: 2066:
        -: 2067:/// Tokenizes a string of Windows command line arguments, which may contain
        -: 2068:/// quotes and escaped quotes.
        -: 2069:///
        -: 2070:/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.
        -: 2071:/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx
        -: 2072:///
        -: 2073:/// For handling a full Windows command line including the executable name at
        -: 2074:/// the start, see TokenizeWindowsCommandLineFull below.
        -: 2075:///
        -: 2076:/// \param [in] Source The string to be split on whitespace with quotes.
        -: 2077:/// \param [in] Saver Delegates back to the caller for saving parsed strings.
        -: 2078:/// \param [in] MarkEOLs true if tokenizing a response file and you want end of
        -: 2079:/// lines and end of the response file to be marked with a nullptr string.
        -: 2080:/// \param [out] NewArgv All parsed strings are appended to NewArgv.
        -: 2081:void TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,
        -: 2082:                                SmallVectorImpl<const char *> &NewArgv,
        -: 2083:                                bool MarkEOLs = false);
        -: 2084:
        -: 2085:/// Tokenizes a Windows command line while attempting to avoid copies. If no
        -: 2086:/// quoting or escaping was used, this produces substrings of the original
        -: 2087:/// string. If a token requires unquoting, it will be allocated with the
        -: 2088:/// StringSaver.
        -: 2089:void TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,
        -: 2090:                                      SmallVectorImpl<StringRef> &NewArgv);
        -: 2091:
        -: 2092:/// Tokenizes a Windows full command line, including command name at the start.
        -: 2093:///
        -: 2094:/// This uses the same syntax rules as TokenizeWindowsCommandLine for all but
        -: 2095:/// the first token. But the first token is expected to be parsed as the
        -: 2096:/// executable file name in the way CreateProcess would do it, rather than the
        -: 2097:/// way the C library startup code would do it: CreateProcess does not consider
        -: 2098:/// that \ is ever an escape character (because " is not a valid filename char,
        -: 2099:/// hence there's never a need to escape it to be used literally).
        -: 2100:///
        -: 2101:/// Parameters are the same as for TokenizeWindowsCommandLine. In particular,
        -: 2102:/// if you set MarkEOLs = true, then the first word of every line will be
        -: 2103:/// parsed using the special rules for command names, making this function
        -: 2104:/// suitable for parsing a file full of commands to execute.
        -: 2105:void TokenizeWindowsCommandLineFull(StringRef Source, StringSaver &Saver,
        -: 2106:                                    SmallVectorImpl<const char *> &NewArgv,
        -: 2107:                                    bool MarkEOLs = false);
        -: 2108:
        -: 2109:/// String tokenization function type.  Should be compatible with either
        -: 2110:/// Windows or Unix command line tokenizers.
        -: 2111:using TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,
        -: 2112:                                   SmallVectorImpl<const char *> &NewArgv,
        -: 2113:                                   bool MarkEOLs);
        -: 2114:
        -: 2115:/// Tokenizes content of configuration file.
        -: 2116:///
        -: 2117:/// \param [in] Source The string representing content of config file.
        -: 2118:/// \param [in] Saver Delegates back to the caller for saving parsed strings.
        -: 2119:/// \param [out] NewArgv All parsed strings are appended to NewArgv.
        -: 2120:/// \param [in] MarkEOLs Added for compatibility with TokenizerCallback.
        -: 2121:///
        -: 2122:/// It works like TokenizeGNUCommandLine with ability to skip comment lines.
        -: 2123:///
        -: 2124:void tokenizeConfigFile(StringRef Source, StringSaver &Saver,
        -: 2125:                        SmallVectorImpl<const char *> &NewArgv,
        -: 2126:                        bool MarkEOLs = false);
        -: 2127:
        -: 2128:/// Contains options that control response file expansion.
        -: 2129:class ExpansionContext {
        -: 2130:  /// Provides persistent storage for parsed strings.
        -: 2131:  StringSaver Saver;
        -: 2132:
        -: 2133:  /// Tokenization strategy. Typically Unix or Windows.
        -: 2134:  TokenizerCallback Tokenizer;
        -: 2135:
        -: 2136:  /// File system used for all file access when running the expansion.
        -: 2137:  vfs::FileSystem *FS;
        -: 2138:
        -: 2139:  /// Path used to resolve relative rsp files. If empty, the file system
        -: 2140:  /// current directory is used instead.
        -: 2141:  StringRef CurrentDir;
        -: 2142:
        -: 2143:  /// Directories used for search of config files.
        -: 2144:  ArrayRef<StringRef> SearchDirs;
        -: 2145:
        -: 2146:  /// True if names of nested response files must be resolved relative to
        -: 2147:  /// including file.
        -: 2148:  bool RelativeNames = false;
        -: 2149:
        -: 2150:  /// If true, mark end of lines and the end of the response file with nullptrs
        -: 2151:  /// in the Argv vector.
        -: 2152:  bool MarkEOLs = false;
        -: 2153:
        -: 2154:  /// If true, body of config file is expanded.
        -: 2155:  bool InConfigFile = false;
        -: 2156:
        -: 2157:  llvm::Error expandResponseFile(StringRef FName,
        -: 2158:                                 SmallVectorImpl<const char *> &NewArgv);
        -: 2159:
        -: 2160:public:
        -: 2161:  ExpansionContext(BumpPtrAllocator &A, TokenizerCallback T);
        -: 2162:
        -: 2163:  ExpansionContext &setMarkEOLs(bool X) {
        -: 2164:    MarkEOLs = X;
        -: 2165:    return *this;
        -: 2166:  }
        -: 2167:
        -: 2168:  ExpansionContext &setRelativeNames(bool X) {
        -: 2169:    RelativeNames = X;
        -: 2170:    return *this;
        -: 2171:  }
        -: 2172:
        -: 2173:  ExpansionContext &setCurrentDir(StringRef X) {
        -: 2174:    CurrentDir = X;
        -: 2175:    return *this;
        -: 2176:  }
        -: 2177:
        -: 2178:  ExpansionContext &setSearchDirs(ArrayRef<StringRef> X) {
        -: 2179:    SearchDirs = X;
        -: 2180:    return *this;
        -: 2181:  }
        -: 2182:
        -: 2183:  ExpansionContext &setVFS(vfs::FileSystem *X) {
        -: 2184:    FS = X;
        -: 2185:    return *this;
        -: 2186:  }
        -: 2187:
        -: 2188:  /// Looks for the specified configuration file.
        -: 2189:  ///
        -: 2190:  /// \param[in]  FileName Name of the file to search for.
        -: 2191:  /// \param[out] FilePath File absolute path, if it was found.
        -: 2192:  /// \return True if file was found.
        -: 2193:  ///
        -: 2194:  /// If the specified file name contains a directory separator, it is searched
        -: 2195:  /// for by its absolute path. Otherwise looks for file sequentially in
        -: 2196:  /// directories specified by SearchDirs field.
        -: 2197:  bool findConfigFile(StringRef FileName, SmallVectorImpl<char> &FilePath);
        -: 2198:
        -: 2199:  /// Reads command line options from the given configuration file.
        -: 2200:  ///
        -: 2201:  /// \param [in] CfgFile Path to configuration file.
        -: 2202:  /// \param [out] Argv Array to which the read options are added.
        -: 2203:  /// \return true if the file was successfully read.
        -: 2204:  ///
        -: 2205:  /// It reads content of the specified file, tokenizes it and expands "@file"
        -: 2206:  /// commands resolving file names in them relative to the directory where
        -: 2207:  /// CfgFilename resides. It also expands "<CFGDIR>" to the base path of the
        -: 2208:  /// current config file.
        -: 2209:  Error readConfigFile(StringRef CfgFile, SmallVectorImpl<const char *> &Argv);
        -: 2210:
        -: 2211:  /// Expands constructs "@file" in the provided array of arguments recursively.
        -: 2212:  Error expandResponseFiles(SmallVectorImpl<const char *> &Argv);
        -: 2213:};
        -: 2214:
        -: 2215:/// A convenience helper which concatenates the options specified by the
        -: 2216:/// environment variable EnvVar and command line options, then expands
        -: 2217:/// response files recursively.
        -: 2218:/// \return true if all @files were expanded successfully or there were none.
        -: 2219:bool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,
        -: 2220:                         SmallVectorImpl<const char *> &NewArgv);
        -: 2221:
        -: 2222:/// A convenience helper which supports the typical use case of expansion
        -: 2223:/// function call.
        -: 2224:bool ExpandResponseFiles(StringSaver &Saver, TokenizerCallback Tokenizer,
        -: 2225:                         SmallVectorImpl<const char *> &Argv);
        -: 2226:
        -: 2227:/// A convenience helper which concatenates the options specified by the
        -: 2228:/// environment variable EnvVar and command line options, then expands response
        -: 2229:/// files recursively. The tokenizer is a predefined GNU or Windows one.
        -: 2230:/// \return true if all @files were expanded successfully or there were none.
        -: 2231:bool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,
        -: 2232:                         StringSaver &Saver,
        -: 2233:                         SmallVectorImpl<const char *> &NewArgv);
        -: 2234:
        -: 2235:/// Mark all options not part of this category as cl::ReallyHidden.
        -: 2236:///
        -: 2237:/// \param Category the category of options to keep displaying
        -: 2238:///
        -: 2239:/// Some tools (like clang-format) like to be able to hide all options that are
        -: 2240:/// not specific to the tool. This function allows a tool to specify a single
        -: 2241:/// option category to display in the -help output.
        -: 2242:void HideUnrelatedOptions(cl::OptionCategory &Category,
        -: 2243:                          SubCommand &Sub = SubCommand::getTopLevel());
        -: 2244:
        -: 2245:/// Mark all options not part of the categories as cl::ReallyHidden.
        -: 2246:///
        -: 2247:/// \param Categories the categories of options to keep displaying.
        -: 2248:///
        -: 2249:/// Some tools (like clang-format) like to be able to hide all options that are
        -: 2250:/// not specific to the tool. This function allows a tool to specify a single
        -: 2251:/// option category to display in the -help output.
        -: 2252:void HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,
        -: 2253:                          SubCommand &Sub = SubCommand::getTopLevel());
        -: 2254:
        -: 2255:/// Reset all command line options to a state that looks as if they have
        -: 2256:/// never appeared on the command line.  This is useful for being able to parse
        -: 2257:/// a command line multiple times (especially useful for writing tests).
        -: 2258:void ResetAllOptionOccurrences();
        -: 2259:
        -: 2260:/// Reset the command line parser back to its initial state.  This
        -: 2261:/// removes
        -: 2262:/// all options, categories, and subcommands and returns the parser to a state
        -: 2263:/// where no options are supported.
        -: 2264:void ResetCommandLineParser();
        -: 2265:
        -: 2266:/// Parses `Arg` into the option handler `Handler`.
        -: 2267:bool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);
        -: 2268:
        -: 2269:} // end namespace cl
        -: 2270:
        -: 2271:} // end namespace llvm
        -: 2272:
        -: 2273:#endif // LLVM_SUPPORT_COMMANDLINE_H
