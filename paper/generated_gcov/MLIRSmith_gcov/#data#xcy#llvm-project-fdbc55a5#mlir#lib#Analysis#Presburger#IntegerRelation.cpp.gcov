        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Analysis/Presburger/IntegerRelation.cpp
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcda
        -:    0:Runs:116175
        -:    1://===- IntegerRelation.cpp - MLIR IntegerRelation Class ---------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// A class to represent an relation over integer tuples. A relation is
        -:   10:// represented as a constraint system over a space of tuples of integer valued
        -:   11:// variables supporting symbolic variables and existential quantification.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#include "mlir/Analysis/Presburger/IntegerRelation.h"
        -:   16:#include "mlir/Analysis/Presburger/LinearTransform.h"
        -:   17:#include "mlir/Analysis/Presburger/PWMAFunction.h"
        -:   18:#include "mlir/Analysis/Presburger/PresburgerRelation.h"
        -:   19:#include "mlir/Analysis/Presburger/Simplex.h"
        -:   20:#include "mlir/Analysis/Presburger/Utils.h"
        -:   21:#include "llvm/ADT/DenseMap.h"
        -:   22:#include "llvm/ADT/DenseSet.h"
        -:   23:#include "llvm/Support/Debug.h"
        -:   24:#include <numeric>
        -:   25:
        -:   26:#define DEBUG_TYPE "presburger"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:using namespace presburger;
        -:   30:
        -:   31:using llvm::SmallDenseMap;
        -:   32:using llvm::SmallDenseSet;
        -:   33:
function _ZNK4mlir10presburger15IntegerRelation5cloneEv called 0 returned 0% blocks executed 0%
    #####:   34:std::unique_ptr<IntegerRelation> IntegerRelation::clone() const {
    #####:   35:  return std::make_unique<IntegerRelation>(*this);
call    0 never executed
        -:   36:}
        -:   37:
function _ZNK4mlir10presburger17IntegerPolyhedron5cloneEv called 0 returned 0% blocks executed 0%
    #####:   38:std::unique_ptr<IntegerPolyhedron> IntegerPolyhedron::clone() const {
    #####:   39:  return std::make_unique<IntegerPolyhedron>(*this);
call    0 never executed
        -:   40:}
        -:   41:
function _ZN4mlir10presburger15IntegerRelation8setSpaceERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   42:void IntegerRelation::setSpace(const PresburgerSpace &oSpace) {
    #####:   43:  assert(space.getNumVars() == oSpace.getNumVars() && "invalid space!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   44:  space = oSpace;
call    0 never executed
    #####:   45:}
        -:   46:
function _ZN4mlir10presburger15IntegerRelation20setSpaceExceptLocalsERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   47:void IntegerRelation::setSpaceExceptLocals(const PresburgerSpace &oSpace) {
    #####:   48:  assert(oSpace.getNumLocalVars() == 0 && "no locals should be present!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   49:  assert(oSpace.getNumVars() <= getNumVars() && "invalid space!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   50:  unsigned newNumLocals = getNumVars() - oSpace.getNumVars();
call    0 never executed
    #####:   51:  space = oSpace;
call    0 never executed
    #####:   52:  space.insertVar(VarKind::Local, 0, newNumLocals);
call    0 never executed
    #####:   53:}
        -:   54:
function _ZN4mlir10presburger15IntegerRelation6appendERKS1_ called 28219 returned 100% blocks executed 94%
    28219:   55:void IntegerRelation::append(const IntegerRelation &other) {
   28219*:   56:  assert(space.isEqual(other.getSpace()) && "Spaces must be equal.");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   57:
    28219:   58:  inequalities.reserveRows(inequalities.getNumRows() +
call    0 returned 100%
    28219:   59:                           other.getNumInequalities());
call    0 returned 100%
    28219:   60:  equalities.reserveRows(equalities.getNumRows() + other.getNumEqualities());
call    0 returned 100%
        -:   61:
    41737:   62:  for (unsigned r = 0, e = other.getNumInequalities(); r < e; r++) {
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
    13518:   63:    addInequality(other.getInequality(r));
call    0 returned 100%
call    1 returned 100%
        -:   64:  }
    35234:   65:  for (unsigned r = 0, e = other.getNumEqualities(); r < e; r++) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
     7015:   66:    addEquality(other.getEquality(r));
call    0 returned 100%
call    1 returned 100%
        -:   67:  }
    28219:   68:}
        -:   69:
function _ZNK4mlir10presburger15IntegerRelation9intersectES1_ called 0 returned 0% blocks executed 0%
    #####:   70:IntegerRelation IntegerRelation::intersect(IntegerRelation other) const {
    #####:   71:  IntegerRelation result = *this;
call    0 never executed
    #####:   72:  result.mergeLocalVars(other);
call    0 never executed
call    1 never executed
    #####:   73:  result.append(other);
call    0 never executed
call    1 never executed
    #####:   74:  return result;
        -:   75:}
        -:   76:
function _ZNK4mlir10presburger15IntegerRelation7isEqualERKS1_ called 0 returned 0% blocks executed 0%
    #####:   77:bool IntegerRelation::isEqual(const IntegerRelation &other) const {
    #####:   78:  assert(space.isCompatible(other.getSpace()) && "Spaces must be compatible.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   79:  return PresburgerRelation(*this).isEqual(PresburgerRelation(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   80:}
        -:   81:
function _ZNK4mlir10presburger15IntegerRelation10isSubsetOfERKS1_ called 0 returned 0% blocks executed 0%
    #####:   82:bool IntegerRelation::isSubsetOf(const IntegerRelation &other) const {
    #####:   83:  assert(space.isCompatible(other.getSpace()) && "Spaces must be compatible.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   84:  return PresburgerRelation(*this).isSubsetOf(PresburgerRelation(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   85:}
        -:   86:
        -:   87:MaybeOptimum<SmallVector<Fraction, 8>>
function _ZNK4mlir10presburger15IntegerRelation18findRationalLexMinEv called 0 returned 0% blocks executed 0%
    #####:   88:IntegerRelation::findRationalLexMin() const {
    #####:   89:  assert(getNumSymbolVars() == 0 && "Symbols are not supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   90:  MaybeOptimum<SmallVector<Fraction, 8>> maybeLexMin =
call    0 never executed
    #####:   91:      LexSimplex(*this).findRationalLexMin();
call    0 never executed
call    1 never executed
        -:   92:
    #####:   93:  if (!maybeLexMin.isBounded())
branch  0 never executed
branch  1 never executed
        -:   94:    return maybeLexMin;
        -:   95:
        -:   96:  // The Simplex returns the lexmin over all the variables including locals. But
        -:   97:  // locals are not actually part of the space and should not be returned in the
        -:   98:  // result. Since the locals are placed last in the list of variables, they
        -:   99:  // will be minimized last in the lexmin. So simply truncating out the locals
        -:  100:  // from the end of the answer gives the desired lexmin over the dimensions.
    #####:  101:  assert(maybeLexMin->size() == getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  102:         "Incorrect number of vars in lexMin!");
    #####:  103:  maybeLexMin->resize(getNumDimAndSymbolVars());
call    0 never executed
        -:  104:  return maybeLexMin;
        -:  105:}
        -:  106:
function _ZNK4mlir10presburger15IntegerRelation17findIntegerLexMinEv called 0 returned 0% blocks executed 0%
    #####:  107:MaybeOptimum<SmallVector<MPInt, 8>> IntegerRelation::findIntegerLexMin() const {
    #####:  108:  assert(getNumSymbolVars() == 0 && "Symbols are not supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  109:  MaybeOptimum<SmallVector<MPInt, 8>> maybeLexMin =
call    0 never executed
    #####:  110:      LexSimplex(*this).findIntegerLexMin();
call    0 never executed
call    1 never executed
        -:  111:
    #####:  112:  if (!maybeLexMin.isBounded())
branch  0 never executed
branch  1 never executed
    #####:  113:    return maybeLexMin.getKind();
        -:  114:
        -:  115:  // The Simplex returns the lexmin over all the variables including locals. But
        -:  116:  // locals are not actually part of the space and should not be returned in the
        -:  117:  // result. Since the locals are placed last in the list of variables, they
        -:  118:  // will be minimized last in the lexmin. So simply truncating out the locals
        -:  119:  // from the end of the answer gives the desired lexmin over the dimensions.
    #####:  120:  assert(maybeLexMin->size() == getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  121:         "Incorrect number of vars in lexMin!");
    #####:  122:  maybeLexMin->resize(getNumDimAndSymbolVars());
call    0 never executed
    #####:  123:  return maybeLexMin;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  124:}
        -:  125:
    #####:  126:static bool rangeIsZero(ArrayRef<MPInt> range) {
function _ZZL11rangeIsZeroN4llvm8ArrayRefIN4mlir10presburger5MPIntEEEENKUlRKS3_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  127:  return llvm::all_of(range, [](const MPInt &x) { return x == 0; });
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  128:}
        -:  129:
function _ZL34removeConstraintsInvolvingVarRangeRN4mlir10presburger15IntegerRelationEjj called 0 returned 0% blocks executed 0%
    #####:  130:static void removeConstraintsInvolvingVarRange(IntegerRelation &poly,
        -:  131:                                               unsigned begin, unsigned count) {
        -:  132:  // We loop until i > 0 and index into i - 1 to avoid sign issues.
        -:  133:  //
        -:  134:  // We iterate backwards so that whether we remove constraint i - 1 or not, the
        -:  135:  // next constraint to be tested is always i - 2.
    #####:  136:  for (unsigned i = poly.getNumEqualities(); i > 0; i--)
    #####:  137:    if (!rangeIsZero(poly.getEquality(i - 1).slice(begin, count)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  138:      poly.removeEquality(i - 1);
branch  0 never executed
branch  1 never executed
    #####:  139:  for (unsigned i = poly.getNumInequalities(); i > 0; i--)
    #####:  140:    if (!rangeIsZero(poly.getInequality(i - 1).slice(begin, count)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  141:      poly.removeInequality(i - 1);
branch  0 never executed
branch  1 never executed
    #####:  142:}
        -:  143:
function _ZNK4mlir10presburger15IntegerRelation9getCountsEv called 0 returned 0% blocks executed 0%
    #####:  144:IntegerRelation::CountsSnapshot IntegerRelation::getCounts() const {
    #####:  145:  return {getSpace(), getNumInequalities(), getNumEqualities()};
call    0 never executed
        -:  146:}
        -:  147:
function _ZN4mlir10presburger15IntegerRelation15truncateVarKindENS0_7VarKindEj called 0 returned 0% blocks executed 0%
    #####:  148:void IntegerRelation::truncateVarKind(VarKind kind, unsigned num) {
    #####:  149:  unsigned curNum = getNumVarKind(kind);
call    0 never executed
    #####:  150:  assert(num <= curNum && "Can't truncate to more vars!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  151:  removeVarRange(kind, num, curNum);
call    0 never executed
    #####:  152:}
        -:  153:
function _ZN4mlir10presburger15IntegerRelation15truncateVarKindENS0_7VarKindERKNS1_14CountsSnapshotE called 0 returned 0% blocks executed 0%
    #####:  154:void IntegerRelation::truncateVarKind(VarKind kind,
        -:  155:                                      const CountsSnapshot &counts) {
    #####:  156:  truncateVarKind(kind, counts.getSpace().getNumVarKind(kind));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  157:}
        -:  158:
function _ZN4mlir10presburger15IntegerRelation8truncateERKNS1_14CountsSnapshotE called 0 returned 0% blocks executed 0%
    #####:  159:void IntegerRelation::truncate(const CountsSnapshot &counts) {
    #####:  160:  truncateVarKind(VarKind::Domain, counts);
call    0 never executed
    #####:  161:  truncateVarKind(VarKind::Range, counts);
call    0 never executed
    #####:  162:  truncateVarKind(VarKind::Symbol, counts);
call    0 never executed
    #####:  163:  truncateVarKind(VarKind::Local, counts);
call    0 never executed
    #####:  164:  removeInequalityRange(counts.getNumIneqs(), getNumInequalities());
branch  0 never executed
branch  1 never executed
    #####:  165:  removeEqualityRange(counts.getNumEqs(), getNumEqualities());
branch  0 never executed
branch  1 never executed
    #####:  166:}
        -:  167:
function _ZNK4mlir10presburger15IntegerRelation28computeReprWithOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####:  168:PresburgerRelation IntegerRelation::computeReprWithOnlyDivLocals() const {
        -:  169:  // If there are no locals, we're done.
    #####:  170:  if (getNumLocalVars() == 0)
branch  0 never executed
branch  1 never executed
    #####:  171:    return PresburgerRelation(*this);
call    0 never executed
        -:  172:
        -:  173:  // Move all the non-div locals to the end, as the current API to
        -:  174:  // SymbolicLexMin requires these to form a contiguous range.
        -:  175:  //
        -:  176:  // Take a copy so we can perform mutations.
    #####:  177:  IntegerRelation copy = *this;
call    0 never executed
    #####:  178:  std::vector<MaybeLocalRepr> reprs(getNumLocalVars());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  179:  copy.getLocalReprs(&reprs);
call    0 never executed
call    1 never executed
        -:  180:
        -:  181:  // Iterate through all the locals. The last `numNonDivLocals` are the locals
        -:  182:  // that have been scanned already and do not have division representations.
    #####:  183:  unsigned numNonDivLocals = 0;
    #####:  184:  unsigned offset = copy.getVarKindOffset(VarKind::Local);
call    0 never executed
    #####:  185:  for (unsigned i = 0, e = copy.getNumLocalVars(); i < e - numNonDivLocals;) {
branch  0 never executed
branch  1 never executed
    #####:  186:    if (!reprs[i]) {
branch  0 never executed
branch  1 never executed
        -:  187:      // Whenever we come across a local that does not have a division
        -:  188:      // representation, we swap it to the `numNonDivLocals`-th last position
        -:  189:      // and increment `numNonDivLocal`s. `reprs` also needs to be swapped.
    #####:  190:      copy.swapVar(offset + i, offset + e - numNonDivLocals - 1);
call    0 never executed
    #####:  191:      std::swap(reprs[i], reprs[e - numNonDivLocals - 1]);
    #####:  192:      ++numNonDivLocals;
    #####:  193:      continue;
        -:  194:    }
    #####:  195:    ++i;
        -:  196:  }
        -:  197:
        -:  198:  // If there are no non-div locals, we're done.
    #####:  199:  if (numNonDivLocals == 0)
branch  0 never executed
branch  1 never executed
    #####:  200:    return PresburgerRelation(*this);
call    0 never executed
        -:  201:
        -:  202:  // We computeSymbolicIntegerLexMin by considering the non-div locals as
        -:  203:  // "non-symbols" and considering everything else as "symbols". This will
        -:  204:  // compute a function mapping assignments to "symbols" to the
        -:  205:  // lexicographically minimal valid assignment of "non-symbols", when a
        -:  206:  // satisfying assignment exists. It separately returns the set of assignments
        -:  207:  // to the "symbols" such that a satisfying assignment to the "non-symbols"
        -:  208:  // exists but the lexmin is unbounded. We basically want to find the set of
        -:  209:  // values of the "symbols" such that an assignment to the "non-symbols"
        -:  210:  // exists, which is the union of the domain of the returned lexmin function
        -:  211:  // and the returned set of assignments to the "symbols" that makes the lexmin
        -:  212:  // unbounded.
    #####:  213:  SymbolicLexMin lexminResult =
call    0 never executed
    #####:  214:      SymbolicLexSimplex(copy, /*symbolOffset*/ 0,
call    0 never executed
call    1 never executed
    #####:  215:                         IntegerPolyhedron(PresburgerSpace::getSetSpace(
branch  0 never executed
branch  1 never executed
    #####:  216:                             /*numDims=*/copy.getNumVars() - numNonDivLocals)))
call    0 never executed
    #####:  217:          .computeSymbolicIntegerLexMin();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:  PresburgerRelation result =
    #####:  219:      lexminResult.lexmin.getDomain().unionSet(lexminResult.unboundedDomain);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  220:
        -:  221:  // The result set might lie in the wrong space -- all its ids are dims.
        -:  222:  // Set it to the desired space and return.
    #####:  223:  PresburgerSpace space = getSpace();
call    0 never executed
call    1 never executed
    #####:  224:  space.removeVarRange(VarKind::Local, 0, getNumLocalVars());
call    0 never executed
    #####:  225:  result.setSpace(space);
call    0 never executed
    #####:  226:  return result;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  227:}
        -:  228:
function _ZNK4mlir10presburger15IntegerRelation25findSymbolicIntegerLexMinEv called 0 returned 0% blocks executed 0%
    #####:  229:SymbolicLexMin IntegerRelation::findSymbolicIntegerLexMin() const {
        -:  230:  // Symbol and Domain vars will be used as symbols for symbolic lexmin.
        -:  231:  // In other words, for every value of the symbols and domain, return the
        -:  232:  // lexmin value of the (range, locals).
    #####:  233:  llvm::SmallBitVector isSymbol(getNumVars(), false);
call    0 never executed
    #####:  234:  isSymbol.set(getVarKindOffset(VarKind::Symbol),
call    0 never executed
    #####:  235:               getVarKindEnd(VarKind::Symbol));
call    0 never executed
call    1 never executed
    #####:  236:  isSymbol.set(getVarKindOffset(VarKind::Domain),
call    0 never executed
    #####:  237:               getVarKindEnd(VarKind::Domain));
call    0 never executed
call    1 never executed
        -:  238:  // Compute the symbolic lexmin of the dims and locals, with the symbols being
        -:  239:  // the actual symbols of this set.
        -:  240:  // The resultant space of lexmin is the space of the relation itself.
    #####:  241:  SymbolicLexMin result =
call    0 never executed
    #####:  242:      SymbolicLexSimplex(*this,
call    0 never executed
call    1 never executed
    #####:  243:                         IntegerPolyhedron(PresburgerSpace::getSetSpace(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  244:                             /*numDims=*/getNumDomainVars(),
        -:  245:                             /*numSymbols=*/getNumSymbolVars())),
        -:  246:                         isSymbol)
    #####:  247:          .computeSymbolicIntegerLexMin();
call    0 never executed
        -:  248:
        -:  249:  // We want to return only the lexmin over the dims, so strip the locals from
        -:  250:  // the computed lexmin.
    #####:  251:  result.lexmin.removeOutputs(result.lexmin.getNumOutputs() - getNumLocalVars(),
call    0 never executed
        -:  252:                              result.lexmin.getNumOutputs());
    #####:  253:  return result;
call    0 never executed
        -:  254:}
        -:  255:
        -:  256:PresburgerRelation
function _ZNK4mlir10presburger15IntegerRelation8subtractERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  257:IntegerRelation::subtract(const PresburgerRelation &set) const {
    #####:  258:  return PresburgerRelation(*this).subtract(set);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  259:}
        -:  260:
function _ZN4mlir10presburger15IntegerRelation9insertVarENS0_7VarKindEjj called 134150 returned 100% blocks executed 86%
   134150:  261:unsigned IntegerRelation::insertVar(VarKind kind, unsigned pos, unsigned num) {
  134150*:  262:  assert(pos <= getNumVarKind(kind));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  263:
   134150:  264:  unsigned insertPos = space.insertVar(kind, pos, num);
call    0 returned 100%
   134150:  265:  inequalities.insertColumns(insertPos, num);
call    0 returned 100%
   134150:  266:  equalities.insertColumns(insertPos, num);
call    0 returned 100%
   134150:  267:  return insertPos;
        -:  268:}
        -:  269:
function _ZN4mlir10presburger15IntegerRelation9appendVarENS0_7VarKindEj called 20378 returned 100% blocks executed 100%
    20378:  270:unsigned IntegerRelation::appendVar(VarKind kind, unsigned num) {
    20378:  271:  unsigned pos = getNumVarKind(kind);
call    0 returned 100%
    20378:  272:  return insertVar(kind, pos, num);
call    0 returned 100%
        -:  273:}
        -:  274:
function _ZN4mlir10presburger15IntegerRelation11addEqualityEN4llvm8ArrayRefINS0_5MPIntEEE called 99866 returned 100% blocks executed 41%
    99866:  275:void IntegerRelation::addEquality(ArrayRef<MPInt> eq) {
   99866*:  276:  assert(eq.size() == getNumCols());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    99866:  277:  unsigned row = equalities.appendExtraRow();
call    0 returned 100%
   443298:  278:  for (unsigned i = 0, e = eq.size(); i < e; ++i)
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
   686866:  279:    equalities(row, i) = eq[i];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    99865:  280:}
        -:  281:
function _ZN4mlir10presburger15IntegerRelation13addInequalityEN4llvm8ArrayRefINS0_5MPIntEEE called 94169 returned 100% blocks executed 41%
    94169:  282:void IntegerRelation::addInequality(ArrayRef<MPInt> inEq) {
   94169*:  283:  assert(inEq.size() == getNumCols());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    94169:  284:  unsigned row = inequalities.appendExtraRow();
call    0 returned 100%
   486236:  285:  for (unsigned i = 0, e = inEq.size(); i < e; ++i)
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
   784134:  286:    inequalities(row, i) = inEq[i];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    94169:  287:}
        -:  288:
function _ZN4mlir10presburger15IntegerRelation9removeVarENS0_7VarKindEj called 0 returned 0% blocks executed 0%
    #####:  289:void IntegerRelation::removeVar(VarKind kind, unsigned pos) {
    #####:  290:  removeVarRange(kind, pos, pos + 1);
call    0 never executed
    #####:  291:}
        -:  292:
function _ZN4mlir10presburger15IntegerRelation9removeVarEj called 0 returned 0% blocks executed 0%
    #####:  293:void IntegerRelation::removeVar(unsigned pos) { removeVarRange(pos, pos + 1); }
call    0 never executed
        -:  294:
function _ZN4mlir10presburger15IntegerRelation14removeVarRangeENS0_7VarKindEjj called 134254 returned 100% blocks executed 89%
   134254:  295:void IntegerRelation::removeVarRange(VarKind kind, unsigned varStart,
        -:  296:                                     unsigned varLimit) {
  134254*:  297:  assert(varLimit <= getNumVarKind(kind));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  298:
   134254:  299:  if (varStart >= varLimit)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  300:    return;
        -:  301:
        -:  302:  // Remove eliminated variables from the constraints.
    76100:  303:  unsigned offset = getVarKindOffset(kind);
call    0 returned 100%
    76100:  304:  equalities.removeColumns(offset + varStart, varLimit - varStart);
call    0 returned 100%
    76100:  305:  inequalities.removeColumns(offset + varStart, varLimit - varStart);
call    0 returned 100%
        -:  306:
        -:  307:  // Remove eliminated variables from the space.
    76100:  308:  space.removeVarRange(kind, varStart, varLimit);
call    0 returned 100%
        -:  309:}
        -:  310:
function _ZN4mlir10presburger15IntegerRelation14removeVarRangeEjj called 64714 returned 100% blocks executed 90%
    64714:  311:void IntegerRelation::removeVarRange(unsigned varStart, unsigned varLimit) {
   64714*:  312:  assert(varLimit <= getNumVars());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  313:
    64714:  314:  if (varStart >= varLimit)
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
    11601:  315:    return;
        -:  316:
        -:  317:  // Helper function to remove vars of the specified kind in the given range
        -:  318:  // [start, limit), The range is absolute (i.e. it is not relative to the kind
        -:  319:  // of variable). Also updates `limit` to reflect the deleted variables.
function _ZZN4mlir10presburger15IntegerRelation14removeVarRangeEjjENKUlNS0_7VarKindERjS3_E_clES2_S3_S3_.isra.0 called 212452 returned 100% blocks executed 100%
   265565:  320:  auto removeVarKindInRange = [this](VarKind kind, unsigned &start,
   387969:  321:                                     unsigned &limit) {
   212452:  322:    if (start >= limit)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
    83129:  323:      return;
        -:  324:
   129323:  325:    unsigned offset = getVarKindOffset(kind);
call    0 returned 100%
   129323:  326:    unsigned num = getNumVarKind(kind);
call    0 returned 100%
        -:  327:
        -:  328:    // Get `start`, `limit` relative to the specified kind.
   129323:  329:    unsigned relativeStart =
   140394:  330:        start <= offset ? 0 : std::min(num, start - offset);
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
branch  2 taken 35% (fallthrough)
branch  3 taken 65%
   129323:  331:    unsigned relativeLimit =
   137291:  332:        limit <= offset ? 0 : std::min(num, limit - offset);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
        -:  333:
        -:  334:    // Remove vars of the specified kind in the relative range.
   129323:  335:    removeVarRange(kind, relativeStart, relativeLimit);
call    0 returned 100%
        -:  336:
        -:  337:    // Update `limit` to reflect deleted variables.
        -:  338:    // `start` does not need to be updated because any variables that are
        -:  339:    // deleted are after position `start`.
   129323:  340:    limit -= relativeLimit - relativeStart;
    53113:  341:  };
        -:  342:
    53113:  343:  removeVarKindInRange(VarKind::Domain, varStart, varLimit);
call    0 returned 100%
    53113:  344:  removeVarKindInRange(VarKind::Range, varStart, varLimit);
call    0 returned 100%
    53113:  345:  removeVarKindInRange(VarKind::Symbol, varStart, varLimit);
call    0 returned 100%
    53113:  346:  removeVarKindInRange(VarKind::Local, varStart, varLimit);
call    0 returned 100%
        -:  347:}
        -:  348:
function _ZN4mlir10presburger15IntegerRelation14removeEqualityEj called 0 returned 0% blocks executed 0%
   84069*:  349:void IntegerRelation::removeEquality(unsigned pos) {
    #####:  350:  equalities.removeRow(pos);
call    0 never executed
call    1 never executed
    5437*:  351:}
        -:  352:
function _ZN4mlir10presburger15IntegerRelation16removeInequalityEj called 0 returned 0% blocks executed 0%
    #####:  353:void IntegerRelation::removeInequality(unsigned pos) {
    #####:  354:  inequalities.removeRow(pos);
call    0 never executed
call    1 never executed
    #####:  355:}
        -:  356:
function _ZN4mlir10presburger15IntegerRelation19removeEqualityRangeEjj called 0 returned 0% blocks executed 0%
    #####:  357:void IntegerRelation::removeEqualityRange(unsigned start, unsigned end) {
    #####:  358:  if (start >= end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  359:    return;
    #####:  360:  equalities.removeRows(start, end - start);
call    0 never executed
call    1 never executed
        -:  361:}
        -:  362:
function _ZN4mlir10presburger15IntegerRelation21removeInequalityRangeEjj called 0 returned 0% blocks executed 0%
    #####:  363:void IntegerRelation::removeInequalityRange(unsigned start, unsigned end) {
    #####:  364:  if (start >= end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  365:    return;
    #####:  366:  inequalities.removeRows(start, end - start);
call    0 never executed
call    1 never executed
        -:  367:}
        -:  368:
function _ZN4mlir10presburger15IntegerRelation7swapVarEjj called 40305 returned 100% blocks executed 75%
    40305:  369:void IntegerRelation::swapVar(unsigned posA, unsigned posB) {
   40305*:  370:  assert(posA < getNumVars() && "invalid position A");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   40305*:  371:  assert(posB < getNumVars() && "invalid position B");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  372:
    40305:  373:  if (posA == posB)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  374:    return;
        -:  375:
    40304:  376:  inequalities.swapColumns(posA, posB);
call    0 returned 100%
    40304:  377:  equalities.swapColumns(posA, posB);
call    0 returned 100%
        -:  378:}
        -:  379:
function _ZN4mlir10presburger15IntegerRelation16clearConstraintsEv called 0 returned 0% blocks executed 0%
    7316*:  380:void IntegerRelation::clearConstraints() {
    #####:  381:  equalities.resizeVertically(0);
call    0 never executed
    7316*:  382:  inequalities.resizeVertically(0);
call    0 returned 100%
call    1 never executed
    #####:  383:}
        -:  384:
        -:  385:/// Gather all lower and upper bounds of the variable at `pos`, and
        -:  386:/// optionally any equalities on it. In addition, the bounds are to be
        -:  387:/// independent of variables in position range [`offset`, `offset` + `num`).
function _ZNK4mlir10presburger15IntegerRelation28getLowerAndUpperBoundIndicesEjPN4llvm15SmallVectorImplIjEES5_S5_jj called 50110 returned 100% blocks executed 59%
    50110:  388:void IntegerRelation::getLowerAndUpperBoundIndices(
        -:  389:    unsigned pos, SmallVectorImpl<unsigned> *lbIndices,
        -:  390:    SmallVectorImpl<unsigned> *ubIndices, SmallVectorImpl<unsigned> *eqIndices,
        -:  391:    unsigned offset, unsigned num) const {
   50110*:  392:  assert(pos < getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   50110*:  393:  assert(offset + num < getNumCols() && "invalid range");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  394:
        -:  395:  // Checks for a constraint that has a non-zero coeff for the variables in
        -:  396:  // the position range [offset, offset + num) while ignoring `pos`.
function _ZZNK4mlir10presburger15IntegerRelation28getLowerAndUpperBoundIndicesEjPN4llvm15SmallVectorImplIjEES5_S5_jjENKUljbE_clEjb called 212623 returned 100% blocks executed 76%
   262733:  397:  auto containsConstraintDependentOnRange = [&](unsigned r, bool isEq) {
   212623:  398:    unsigned c, f;
   212623:  399:    auto cst = isEq ? getEquality(r) : getInequality(r);
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
call    2 returned 100%
call    3 returned 100%
   496572:  400:    for (c = offset, f = offset + num; c < f; ++c) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
   377365:  401:      if (c == pos)
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
   141346:  402:        continue;
   472038:  403:      if (cst[c] != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 60% (fallthrough)
branch  5 taken 40%
        -:  404:        break;
        -:  405:    }
   212623:  406:    return c < f;
    50110:  407:  };
        -:  408:
        -:  409:  // Gather all lower bounds and upper bounds of the variable. Since the
        -:  410:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -:  411:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
   242793:  412:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -:  413:    // The bounds are to be independent of [offset, offset + num) columns.
   192683:  414:    if (containsConstraintDependentOnRange(r, /*isEq=*/false))
call    0 returned 100%
branch  1 taken 48% (fallthrough)
branch  2 taken 52%
    93416:  415:      continue;
   198534:  416:    if (atIneq(r, pos) >= 1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 45% (fallthrough)
branch  6 taken 55%
        -:  417:      // Lower bound.
    44440:  418:      lbIndices->push_back(r);
call    0 returned 100%
   109654:  419:    } else if (atIneq(r, pos) <= -1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 81% (fallthrough)
branch  6 taken 19%
        -:  420:      // Upper bound.
    44307:  421:      ubIndices->push_back(r);
call    0 returned 100%
        -:  422:    }
        -:  423:  }
        -:  424:
        -:  425:  // An equality is both a lower and upper bound. Record any equalities
        -:  426:  // involving the pos^th variable.
    50110:  427:  if (!eqIndices)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
    19552:  428:    return;
        -:  429:
    76508:  430:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
    91900:  431:    if (atEq(r, pos) == 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 57% (fallthrough)
branch  6 taken 43%
    26010:  432:      continue;
   19940*:  433:    if (containsConstraintDependentOnRange(r, /*isEq=*/true))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  434:      continue;
    19940:  435:    eqIndices->push_back(r);
call    0 returned 100%
        -:  436:  }
        -:  437:}
        -:  438:
function _ZNK4mlir10presburger15IntegerRelation18hasConsistentStateEv called 297545 returned 100% blocks executed 83%
   297545:  439:bool IntegerRelation::hasConsistentState() const {
   297545:  440:  if (!inequalities.hasConsistentState())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  441:    return false;
   297545:  442:  if (!equalities.hasConsistentState())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  443:    return false;
        -:  444:  return true;
        -:  445:}
        -:  446:
function _ZN4mlir10presburger15IntegerRelation15setAndEliminateEjN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  447:void IntegerRelation::setAndEliminate(unsigned pos, ArrayRef<MPInt> values) {
    #####:  448:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  449:    return;
    #####:  450:  assert(pos + values.size() <= getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  451:         "invalid position or too many values");
        -:  452:  // Setting x_j = p in sum_i a_i x_i + c is equivalent to adding p*a_j to the
        -:  453:  // constant term and removing the var x_j. We do this for all the vars
        -:  454:  // pos, pos + 1, ... pos + values.size() - 1.
    #####:  455:  unsigned constantColPos = getNumCols() - 1;
    #####:  456:  for (unsigned i = 0, numVals = values.size(); i < numVals; ++i)
branch  0 never executed
branch  1 never executed
    #####:  457:    inequalities.addToColumn(i + pos, constantColPos, values[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  458:  for (unsigned i = 0, numVals = values.size(); i < numVals; ++i)
branch  0 never executed
branch  1 never executed
    #####:  459:    equalities.addToColumn(i + pos, constantColPos, values[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  460:  removeVarRange(pos, pos + values.size());
call    0 never executed
        -:  461:}
        -:  462:
function _ZN4mlir10presburger15IntegerRelation16clearAndCopyFromERKS1_ called 16103 returned 100% blocks executed 100%
    16103:  463:void IntegerRelation::clearAndCopyFrom(const IntegerRelation &other) {
    16103:  464:  *this = other;
call    0 returned 100%
    16103:  465:}
        -:  466:
        -:  467:// Searches for a constraint with a non-zero coefficient at `colIdx` in
        -:  468:// equality (isEq=true) or inequality (isEq=false) constraints.
        -:  469:// Returns true and sets row found in search in `rowIdx`, false otherwise.
function _ZNK4mlir10presburger15IntegerRelation27findConstraintWithNonZeroAtEjbPj called 202228 returned 100% blocks executed 61%
   202228:  470:bool IntegerRelation::findConstraintWithNonZeroAt(unsigned colIdx, bool isEq,
        -:  471:                                                  unsigned *rowIdx) const {
  202228*:  472:  assert(colIdx < getNumCols() && "position out of bounds");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
function _ZZNK4mlir10presburger15IntegerRelation27findConstraintWithNonZeroAtEjbPjENKUljE_clEj called 284944 returned 100% blocks executed 100%
   487172:  473:  auto at = [&](unsigned rowIdx) -> MPInt {
   284944:  474:    return isEq ? atEq(rowIdx, colIdx) : atIneq(rowIdx, colIdx);
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
call    2 returned 100%
call    3 returned 100%
   202228:  475:  };
   202228:  476:  unsigned e = isEq ? getNumEqualities() : getNumInequalities();
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
   373010:  477:  for (*rowIdx = 0; *rowIdx < e; ++(*rowIdx)) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
   569888:  478:    if (at(*rowIdx) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 60% (fallthrough)
branch  6 taken 40%
        -:  479:      return true;
        -:  480:    }
        -:  481:  }
        -:  482:  return false;
        -:  483:}
        -:  484:
function _ZN4mlir10presburger15IntegerRelation25normalizeConstraintsByGCDEv called 75117 returned 100% blocks executed 58%
    75117:  485:void IntegerRelation::normalizeConstraintsByGCD() {
   134842:  486:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i)
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
    59725:  487:    equalities.normalizeRow(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   190193:  488:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i)
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
   115076:  489:    inequalities.normalizeRow(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    75117:  490:}
        -:  491:
function _ZNK4mlir10presburger15IntegerRelation20hasInvalidConstraintEv called 128330 returned 100% blocks executed 86%
   128330:  492:bool IntegerRelation::hasInvalidConstraint() const {
  128330*:  493:  assert(hasConsistentState());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
function _ZZNK4mlir10presburger15IntegerRelation20hasInvalidConstraintEvENKUlbE_clEb called 254232 returned 100% blocks executed 60%
   382562:  494:  auto check = [&](bool isEq) -> bool {
   816069:  495:    unsigned numCols = getNumCols();
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
   254232:  496:    unsigned numRows = isEq ? getNumEqualities() : getNumInequalities();
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   574808:  497:    for (unsigned i = 0, e = numRows; i < e; ++i) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -:  498:      unsigned j;
   601645:  499:      for (j = 0; j < numCols - 1; ++j) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
   815490:  500:        MPInt v = isEq ? atEq(i, j) : atIneq(i, j);
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:  501:        // Skip rows with non-zero variable coefficients.
  1123674:  502:        if (v != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 45% (fallthrough)
branch  3 taken 55%
        -:  503:          break;
        -:  504:      }
   347992:  505:      if (j < numCols - 1) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
   308184:  506:        continue;
        -:  507:      }
        -:  508:      // Check validity of constant term at 'numCols - 1' w.r.t 'isEq'.
        -:  509:      // Example invalid constraints include: '1 == 0' or '-1 >= 0'
    52200:  510:      MPInt v = isEq ? atEq(i, numCols - 1) : atIneq(i, numCols - 1);
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
call    2 returned 100%
call    3 returned 100%
    79616:  511:      if ((isEq && v != 0) || (!isEq && v < 0)) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
branch  4 taken 97% (fallthrough)
branch  5 taken 3%
branch  6 taken 69% (fallthrough)
branch  7 taken 31%
    27416:  512:        return true;
branch  0 taken 0%
branch  1 taken 100%
        -:  513:      }
        -:  514:    }
        -:  515:    return false;
   128330:  516:  };
   128330:  517:  if (check(/*isEq=*/true))
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
        -:  518:    return true;
   125902:  519:  return check(/*isEq=*/false);
call    0 returned 100%
        -:  520:}
        -:  521:
        -:  522:/// Eliminate variable from constraint at `rowIdx` based on coefficient at
        -:  523:/// pivotRow, pivotCol. Columns in range [elimColStart, pivotCol) will not be
        -:  524:/// updated as they have already been eliminated.
function _ZL23eliminateFromConstraintPN4mlir10presburger15IntegerRelationEjjjjb called 239966 returned 100% blocks executed 23%
   239966:  525:static void eliminateFromConstraint(IntegerRelation *constraints,
        -:  526:                                    unsigned rowIdx, unsigned pivotRow,
        -:  527:                                    unsigned pivotCol, unsigned elimColStart,
        -:  528:                                    bool isEq) {
        -:  529:  // Skip if equality 'rowIdx' if same as 'pivotRow'.
   239966:  530:  if (isEq && rowIdx == pivotRow)
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
branch  2 taken 43% (fallthrough)
branch  3 taken 57%
   197203:  531:    return;
function _ZZL23eliminateFromConstraintPN4mlir10presburger15IntegerRelationEjjjjbENKUljjE_clEjj.isra.0 called 289945 returned 100% blocks executed 56%
   445842:  532:  auto at = [&](unsigned i, unsigned j) -> MPInt {
   289945:  533:    return isEq ? constraints->atEq(i, j) : constraints->atIneq(i, j);
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
call    2 returned 100%
call    3 returned 100%
   155897:  534:  };
   198660:  535:  MPInt leadCoeff = at(rowIdx, pivotCol);
call    0 returned 100%
        -:  536:  // Skip if leading coefficient at 'rowIdx' is already zero.
   311794:  537:  if (leadCoeff == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 73% (fallthrough)
branch  3 taken 27%
   310337:  538:    return;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    85526:  539:  MPInt pivotCoeff = constraints->atEq(pivotRow, pivotCol);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   147206:  540:  int sign = (leadCoeff * pivotCoeff > 0) ? -1 : 1;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 44% (fallthrough)
branch  5 taken 56%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    85526:  541:  MPInt lcm = presburger::lcm(pivotCoeff, leadCoeff);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   213815:  542:  MPInt pivotMultiplier = sign * (lcm / abs(pivotCoeff));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
   171052:  543:  MPInt rowMultiplier = lcm / abs(leadCoeff);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -:  544:
    42763:  545:  unsigned numCols = constraints->getNumCols();
   199347:  546:  for (unsigned j = 0; j < numCols; ++j) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -:  547:    // Skip updating column 'j' if it was just eliminated.
   156584:  548:    if (j >= elimColStart && j < pivotCol)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
    22536:  549:      continue;
   402144:  550:    MPInt v = pivotMultiplier * constraints->atEq(pivotRow, j) +
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   670240:  551:              rowMultiplier * at(rowIdx, j);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
   134048:  552:    isEq ? constraints->atEq(rowIdx, j) = v
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   253299:  553:         : constraints->atIneq(rowIdx, j) = v;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  554:  }
        -:  555:}
        -:  556:
        -:  557:/// Returns the position of the variable that has the minimum <number of lower
        -:  558:/// bounds> times <number of upper bounds> from the specified range of
        -:  559:/// variables [start, end). It is often best to eliminate in the increasing
        -:  560:/// order of these counts when doing Fourier-Motzkin elimination since FM adds
        -:  561:/// that many new constraints.
function _ZL21getBestVarToEliminateRKN4mlir10presburger15IntegerRelationEjj called 18900 returned 100% blocks executed 91%
    18900:  562:static unsigned getBestVarToEliminate(const IntegerRelation &cst,
        -:  563:                                      unsigned start, unsigned end) {
   18900*:  564:  assert(start < cst.getNumVars() && end < cst.getNumVars() + 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  565:
function _ZZL21getBestVarToEliminateRKN4mlir10presburger15IntegerRelationEjjENKUljE_clEj.isra.0 called 36968 returned 100% blocks executed 53%
    55868:  566:  auto getProductOfNumLowerUpperBounds = [&](unsigned pos) {
    36968:  567:    unsigned numLb = 0;
    36968:  568:    unsigned numUb = 0;
   193723:  569:    for (unsigned r = 0, e = cst.getNumInequalities(); r < e; r++) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
   313510:  570:      if (cst.atIneq(r, pos) > 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 27% (fallthrough)
branch  6 taken 73%
    42346:  571:        ++numLb;
   228818:  572:      } else if (cst.atIneq(r, pos) < 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 38% (fallthrough)
branch  6 taken 62%
    42919:  573:        ++numUb;
        -:  574:      }
        -:  575:    }
    36968:  576:    return numLb * numUb;
    18900:  577:  };
        -:  578:
    18900:  579:  unsigned minLoc = start;
    18900:  580:  unsigned min = getProductOfNumLowerUpperBounds(start);
call    0 returned 100%
    36968:  581:  for (unsigned c = start + 1; c < end; c++) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
    18068:  582:    unsigned numLbUbProduct = getProductOfNumLowerUpperBounds(c);
call    0 returned 100%
    18068:  583:    if (numLbUbProduct < min) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
     4582:  584:      min = numLbUbProduct;
     4582:  585:      minLoc = c;
        -:  586:    }
        -:  587:  }
    18900:  588:  return minLoc;
        -:  589:}
        -:  590:
        -:  591:// Checks for emptiness of the set by eliminating variables successively and
        -:  592:// using the GCD test (on all equality constraints) and checking for trivially
        -:  593:// invalid constraints. Returns 'true' if the constraint system is found to be
        -:  594:// empty; false otherwise.
function _ZNK4mlir10presburger15IntegerRelation7isEmptyEv called 39436 returned 100% blocks executed 83%
    39436:  595:bool IntegerRelation::isEmpty() const {
    39436:  596:  if (isEmptyByGCDTest() || hasInvalidConstraint())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
branch  4 taken 6% (fallthrough)
branch  5 taken 94%
     2462:  597:    return true;
        -:  598:
    73948:  599:  IntegerRelation tmpCst(*this);
call    0 returned 100%
call    1 returned 100%
        -:  600:
        -:  601:  // First, eliminate as many local variables as possible using equalities.
    36974:  602:  tmpCst.removeRedundantLocalVars();
call    0 returned 100%
    36974:  603:  if (tmpCst.isEmptyByGCDTest() || tmpCst.hasInvalidConstraint())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
        6:  604:    return true;
        -:  605:
        -:  606:  // Eliminate as many variables as possible using Gaussian elimination.
        -:  607:  unsigned currentPos = 0;
    55510:  608:  while (currentPos < tmpCst.getNumVars()) {
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
    43174:  609:    tmpCst.gaussianEliminateVars(currentPos, tmpCst.getNumVars());
call    0 returned 100%
    43174:  610:    ++currentPos;
        -:  611:    // We check emptiness through trivial checks after eliminating each ID to
        -:  612:    // detect emptiness early. Since the checks isEmptyByGCDTest() and
        -:  613:    // hasInvalidConstraint() are linear time and single sweep on the constraint
        -:  614:    // buffer, this appears reasonable - but can optimize in the future.
    43174:  615:    if (tmpCst.hasInvalidConstraint() || tmpCst.isEmptyByGCDTest())
call    0 returned 100%
branch  1 taken 43% (fallthrough)
branch  2 taken 57%
call    3 returned 100%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
    24632:  616:      return true;
        -:  617:  }
        -:  618:
        -:  619:  // Eliminate the remaining using FM.
    20766:  620:  for (unsigned i = 0, e = tmpCst.getNumVars(); i < e; i++) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
     8780:  621:    tmpCst.fourierMotzkinEliminate(
call    0 returned 100%
call    1 returned 100%
        -:  622:        getBestVarToEliminate(tmpCst, 0, tmpCst.getNumVars()));
        -:  623:    // Check for a constraint explosion. This rarely happens in practice, but
        -:  624:    // this check exists as a safeguard against improperly constructed
        -:  625:    // constraint systems or artificially created arbitrarily complex systems
        -:  626:    // that aren't the intended use case for IntegerRelation. This is
        -:  627:    // needed since FM has a worst case exponential complexity in theory.
     8780:  628:    if (tmpCst.getNumConstraints() >= kExplosionFactor * getNumVars()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  629:      LLVM_DEBUG(llvm::dbgs() << "FM constraint explosion detected\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  630:      return false;
        -:  631:    }
        -:  632:
        -:  633:    // FM wouldn't have modified the equalities in any way. So no need to again
        -:  634:    // run GCD test. Check for trivial invalid constraints.
     8780:  635:    if (tmpCst.hasInvalidConstraint())
call    0 returned 100%
branch  1 taken 96% (fallthrough)
branch  2 taken 4%
        -:  636:      return true;
        -:  637:  }
        -:  638:  return false;
        -:  639:}
        -:  640:
        -:  641:// Runs the GCD test on all equality constraints. Returns 'true' if this test
        -:  642:// fails on any equality. Returns 'false' otherwise.
        -:  643:// This test can be used to disprove the existence of a solution. If it returns
        -:  644:// true, no integer solution to the equality constraints can exist.
        -:  645://
        -:  646:// GCD test definition:
        -:  647://
        -:  648:// The equality constraint:
        -:  649://
        -:  650://  c_1*x_1 + c_2*x_2 + ... + c_n*x_n = c_0
        -:  651://
        -:  652:// has an integer solution iff:
        -:  653://
        -:  654://  GCD of c_1, c_2, ..., c_n divides c_0.
function _ZNK4mlir10presburger15IntegerRelation16isEmptyByGCDTestEv called 94952 returned 100% blocks executed 30%
    94952:  655:bool IntegerRelation::isEmptyByGCDTest() const {
   94952*:  656:  assert(hasConsistentState());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    94952:  657:  unsigned numCols = getNumCols();
   260442:  658:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
   496538:  659:    MPInt gcd = abs(atEq(i, 0));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   455248:  660:    for (unsigned j = 1; j < numCols - 1; ++j) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
  1158896:  661:      gcd = presburger::gcd(gcd, abs(atEq(i, j)));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
        -:  662:    }
   496538:  663:    MPInt v = abs(atEq(i, numCols - 1));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
   823300:  664:    if (gcd > 0 && (v % gcd != 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 1%
branch  8 taken 99% (fallthrough)
branch  9 taken 1%
branch 10 taken 1% (fallthrough)
branch 11 taken 100%
       34:  665:      return true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  666:    }
        -:  667:  }
        -:  668:  return false;
        -:  669:}
        -:  670:
        -:  671:// Returns a matrix where each row is a vector along which the polytope is
        -:  672:// bounded. The span of the returned vectors is guaranteed to contain all
        -:  673:// such vectors. The returned vectors are NOT guaranteed to be linearly
        -:  674:// independent. This function should not be called on empty sets.
        -:  675://
        -:  676:// It is sufficient to check the perpendiculars of the constraints, as the set
        -:  677:// of perpendiculars which are bounded must span all bounded directions.
function _ZNK4mlir10presburger15IntegerRelation20getBoundedDirectionsEv called 0 returned 0% blocks executed 0%
    #####:  678:Matrix IntegerRelation::getBoundedDirections() const {
        -:  679:  // Note that it is necessary to add the equalities too (which the constructor
        -:  680:  // does) even though we don't need to check if they are bounded; whether an
        -:  681:  // inequality is bounded or not depends on what other constraints, including
        -:  682:  // equalities, are present.
    #####:  683:  Simplex simplex(*this);
call    0 never executed
        -:  684:
    #####:  685:  assert(!simplex.isEmpty() && "It is not meaningful to ask whether a "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  686:                               "direction is bounded in an empty set.");
        -:  687:
    #####:  688:  SmallVector<unsigned, 8> boundedIneqs;
call    0 never executed
        -:  689:  // The constructor adds the inequalities to the simplex first, so this
        -:  690:  // processes all the inequalities.
    #####:  691:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  692:    if (simplex.isBoundedAlongConstraint(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  693:      boundedIneqs.push_back(i);
call    0 never executed
        -:  694:  }
        -:  695:
        -:  696:  // The direction vector is given by the coefficients and does not include the
        -:  697:  // constant term, so the matrix has one fewer column.
    #####:  698:  unsigned dirsNumCols = getNumCols() - 1;
call    0 never executed
    #####:  699:  Matrix dirs(boundedIneqs.size() + getNumEqualities(), dirsNumCols);
call    0 never executed
        -:  700:
        -:  701:  // Copy the bounded inequalities.
    #####:  702:  unsigned row = 0;
    #####:  703:  for (unsigned i : boundedIneqs) {
branch  0 never executed
branch  1 never executed
    #####:  704:    for (unsigned col = 0; col < dirsNumCols; ++col)
branch  0 never executed
branch  1 never executed
    #####:  705:      dirs(row, col) = atIneq(i, col);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  706:    ++row;
        -:  707:  }
        -:  708:
        -:  709:  // Copy the equalities. All the equalities' perpendiculars are bounded.
    #####:  710:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  711:    for (unsigned col = 0; col < dirsNumCols; ++col)
branch  0 never executed
branch  1 never executed
    #####:  712:      dirs(row, col) = atEq(i, col);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  713:    ++row;
        -:  714:  }
        -:  715:
    #####:  716:  return dirs;
branch  0 never executed
branch  1 never executed
        -:  717:}
        -:  718:
function _ZNK4mlir10presburger15IntegerRelation14isIntegerEmptyEv called 0 returned 0% blocks executed 0%
    #####:  719:bool IntegerRelation::isIntegerEmpty() const { return !findIntegerSample(); }
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  720:
        -:  721:/// Let this set be S. If S is bounded then we directly call into the GBR
        -:  722:/// sampling algorithm. Otherwise, there are some unbounded directions, i.e.,
        -:  723:/// vectors v such that S extends to infinity along v or -v. In this case we
        -:  724:/// use an algorithm described in the integer set library (isl) manual and used
        -:  725:/// by the isl_set_sample function in that library. The algorithm is:
        -:  726:///
        -:  727:/// 1) Apply a unimodular transform T to S to obtain S*T, such that all
        -:  728:/// dimensions in which S*T is bounded lie in the linear span of a prefix of the
        -:  729:/// dimensions.
        -:  730:///
        -:  731:/// 2) Construct a set B by removing all constraints that involve
        -:  732:/// the unbounded dimensions and then deleting the unbounded dimensions. Note
        -:  733:/// that B is a Bounded set.
        -:  734:///
        -:  735:/// 3) Try to obtain a sample from B using the GBR sampling
        -:  736:/// algorithm. If no sample is found, return that S is empty.
        -:  737:///
        -:  738:/// 4) Otherwise, substitute the obtained sample into S*T to obtain a set
        -:  739:/// C. C is a full-dimensional Cone and always contains a sample.
        -:  740:///
        -:  741:/// 5) Obtain an integer sample from C.
        -:  742:///
        -:  743:/// 6) Return T*v, where v is the concatenation of the samples from B and C.
        -:  744:///
        -:  745:/// The following is a sketch of a proof that
        -:  746:/// a) If the algorithm returns empty, then S is empty.
        -:  747:/// b) If the algorithm returns a sample, it is a valid sample in S.
        -:  748:///
        -:  749:/// The algorithm returns empty only if B is empty, in which case S*T is
        -:  750:/// certainly empty since B was obtained by removing constraints and then
        -:  751:/// deleting unconstrained dimensions from S*T. Since T is unimodular, a vector
        -:  752:/// v is in S*T iff T*v is in S. So in this case, since
        -:  753:/// S*T is empty, S is empty too.
        -:  754:///
        -:  755:/// Otherwise, the algorithm substitutes the sample from B into S*T. All the
        -:  756:/// constraints of S*T that did not involve unbounded dimensions are satisfied
        -:  757:/// by this substitution. All dimensions in the linear span of the dimensions
        -:  758:/// outside the prefix are unbounded in S*T (step 1). Substituting values for
        -:  759:/// the bounded dimensions cannot make these dimensions bounded, and these are
        -:  760:/// the only remaining dimensions in C, so C is unbounded along every vector (in
        -:  761:/// the positive or negative direction, or both). C is hence a full-dimensional
        -:  762:/// cone and therefore always contains an integer point.
        -:  763:///
        -:  764:/// Concatenating the samples from B and C gives a sample v in S*T, so the
        -:  765:/// returned sample T*v is a sample in S.
function _ZNK4mlir10presburger15IntegerRelation17findIntegerSampleEv called 0 returned 0% blocks executed 0%
    #####:  766:Optional<SmallVector<MPInt, 8>> IntegerRelation::findIntegerSample() const {
        -:  767:  // First, try the GCD test heuristic.
    #####:  768:  if (isEmptyByGCDTest())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    return {};
        -:  770:
    #####:  771:  Simplex simplex(*this);
call    0 never executed
    #####:  772:  if (simplex.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  773:    return {};
        -:  774:
        -:  775:  // For a bounded set, we directly call into the GBR sampling algorithm.
    #####:  776:  if (!simplex.isUnbounded())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  777:    return simplex.findIntegerSample();
call    0 never executed
        -:  778:
        -:  779:  // The set is unbounded. We cannot directly use the GBR algorithm.
        -:  780:  //
        -:  781:  // m is a matrix containing, in each row, a vector in which S is
        -:  782:  // bounded, such that the linear span of all these dimensions contains all
        -:  783:  // bounded dimensions in S.
    #####:  784:  Matrix m = getBoundedDirections();
call    0 never executed
call    1 never executed
        -:  785:  // In column echelon form, each row of m occupies only the first rank(m)
        -:  786:  // columns and has zeros on the other columns. The transform T that brings S
        -:  787:  // to column echelon form is unimodular as well, so this is a suitable
        -:  788:  // transform to use in step 1 of the algorithm.
    #####:  789:  std::pair<unsigned, LinearTransform> result =
    #####:  790:      LinearTransform::makeTransformToColumnEchelon(m);
call    0 never executed
call    1 never executed
    #####:  791:  const LinearTransform &transform = result.second;
        -:  792:  // 1) Apply T to S to obtain S*T.
    #####:  793:  IntegerRelation transformedSet = transform.applyTo(*this);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  794:
        -:  795:  // 2) Remove the unbounded dimensions and constraints involving them to
        -:  796:  // obtain a bounded set.
    #####:  797:  IntegerRelation boundedSet(transformedSet);
call    0 never executed
    #####:  798:  unsigned numBoundedDims = result.first;
    #####:  799:  unsigned numUnboundedDims = getNumVars() - numBoundedDims;
call    0 never executed
    #####:  800:  removeConstraintsInvolvingVarRange(boundedSet, numBoundedDims,
call    0 never executed
        -:  801:                                     numUnboundedDims);
    #####:  802:  boundedSet.removeVarRange(numBoundedDims, boundedSet.getNumVars());
call    0 never executed
        -:  803:
        -:  804:  // 3) Try to obtain a sample from the bounded set.
    #####:  805:  Optional<SmallVector<MPInt, 8>> boundedSample =
    #####:  806:      Simplex(boundedSet).findIntegerSample();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  807:  if (!boundedSample)
branch  0 never executed
branch  1 never executed
    #####:  808:    return {};
    #####:  809:  assert(boundedSet.containsPoint(*boundedSample) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  810:         "Simplex returned an invalid sample!");
        -:  811:
        -:  812:  // 4) Substitute the values of the bounded dimensions into S*T to obtain a
        -:  813:  // full-dimensional cone, which necessarily contains an integer sample.
    #####:  814:  transformedSet.setAndEliminate(0, *boundedSample);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  815:  IntegerRelation &cone = transformedSet;
        -:  816:
        -:  817:  // 5) Obtain an integer sample from the cone.
        -:  818:  //
        -:  819:  // We shrink the cone such that for any rational point in the shrunken cone,
        -:  820:  // rounding up each of the point's coordinates produces a point that still
        -:  821:  // lies in the original cone.
        -:  822:  //
        -:  823:  // Rounding up a point x adds a number e_i in [0, 1) to each coordinate x_i.
        -:  824:  // For each inequality sum_i a_i x_i + c >= 0 in the original cone, the
        -:  825:  // shrunken cone will have the inequality tightened by some amount s, such
        -:  826:  // that if x satisfies the shrunken cone's tightened inequality, then x + e
        -:  827:  // satisfies the original inequality, i.e.,
        -:  828:  //
        -:  829:  // sum_i a_i x_i + c + s >= 0 implies sum_i a_i (x_i + e_i) + c >= 0
        -:  830:  //
        -:  831:  // for any e_i values in [0, 1). In fact, we will handle the slightly more
        -:  832:  // general case where e_i can be in [0, 1]. For example, consider the
        -:  833:  // inequality 2x_1 - 3x_2 - 7x_3 - 6 >= 0, and let x = (3, 0, 0). How low
        -:  834:  // could the LHS go if we added a number in [0, 1] to each coordinate? The LHS
        -:  835:  // is minimized when we add 1 to the x_i with negative coefficient a_i and
        -:  836:  // keep the other x_i the same. In the example, we would get x = (3, 1, 1),
        -:  837:  // changing the value of the LHS by -3 + -7 = -10.
        -:  838:  //
        -:  839:  // In general, the value of the LHS can change by at most the sum of the
        -:  840:  // negative a_i, so we accomodate this by shifting the inequality by this
        -:  841:  // amount for the shrunken cone.
    #####:  842:  for (unsigned i = 0, e = cone.getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  843:    for (unsigned j = 0; j < cone.getNumVars(); ++j) {
branch  0 never executed
branch  1 never executed
    #####:  844:      MPInt coeff = cone.atIneq(i, j);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:      if (coeff < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  846:        cone.atIneq(i, cone.getNumVars()) += coeff;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  847:    }
        -:  848:  }
        -:  849:
        -:  850:  // Obtain an integer sample in the cone by rounding up a rational point from
        -:  851:  // the shrunken cone. Shrinking the cone amounts to shifting its apex
        -:  852:  // "inwards" without changing its "shape"; the shrunken cone is still a
        -:  853:  // full-dimensional cone and is hence non-empty.
    #####:  854:  Simplex shrunkenConeSimplex(cone);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  855:  assert(!shrunkenConeSimplex.isEmpty() && "Shrunken cone cannot be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  856:
        -:  857:  // The sample will always exist since the shrunken cone is non-empty.
    #####:  858:  SmallVector<Fraction, 8> shrunkenConeSample =
    #####:  859:      *shrunkenConeSimplex.getRationalSample();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
        -:  860:
    #####:  861:  SmallVector<MPInt, 8> coneSample(llvm::map_range(shrunkenConeSample, ceil));
call    0 never executed
        -:  862:
        -:  863:  // 6) Return transform * concat(boundedSample, coneSample).
    #####:  864:  SmallVector<MPInt, 8> &sample = *boundedSample;
branch  0 never executed
branch  1 never executed
    #####:  865:  sample.append(coneSample.begin(), coneSample.end());
call    0 never executed
    #####:  866:  return transform.postMultiplyWithColumn(sample);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  867:}
        -:  868:
        -:  869:/// Helper to evaluate an affine expression at a point.
        -:  870:/// The expression is a list of coefficients for the dimensions followed by the
        -:  871:/// constant term.
function _ZL7valueAtN4llvm8ArrayRefIN4mlir10presburger5MPIntEEES4_ called 0 returned 0% blocks executed 0%
    #####:  872:static MPInt valueAt(ArrayRef<MPInt> expr, ArrayRef<MPInt> point) {
    #####:  873:  assert(expr.size() == 1 + point.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  874:         "Dimensionalities of point and expression don't match!");
    #####:  875:  MPInt value = expr.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  876:  for (unsigned i = 0; i < point.size(); ++i)
branch  0 never executed
branch  1 never executed
    #####:  877:    value += expr[i] * point[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  878:  return value;
        -:  879:}
        -:  880:
        -:  881:/// A point satisfies an equality iff the value of the equality at the
        -:  882:/// expression is zero, and it satisfies an inequality iff the value of the
        -:  883:/// inequality at that point is non-negative.
function _ZNK4mlir10presburger15IntegerRelation13containsPointEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  884:bool IntegerRelation::containsPoint(ArrayRef<MPInt> point) const {
    #####:  885:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  886:    if (valueAt(getEquality(i), point) != 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  887:      return false;
        -:  888:  }
    #####:  889:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  890:    if (valueAt(getInequality(i), point) < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  891:      return false;
        -:  892:  }
        -:  893:  return true;
        -:  894:}
        -:  895:
        -:  896:/// Just substitute the values given and check if an integer sample exists for
        -:  897:/// the local vars.
        -:  898:///
        -:  899:/// TODO: this could be made more efficient by handling divisions separately.
        -:  900:/// Instead of finding an integer sample over all the locals, we can first
        -:  901:/// compute the values of the locals that have division representations and
        -:  902:/// only use the integer emptiness check for the locals that don't have this.
        -:  903:/// Handling this correctly requires ordering the divs, though.
        -:  904:Optional<SmallVector<MPInt, 8>>
function _ZNK4mlir10presburger15IntegerRelation20containsPointNoLocalEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  905:IntegerRelation::containsPointNoLocal(ArrayRef<MPInt> point) const {
    #####:  906:  assert(point.size() == getNumVars() - getNumLocalVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  907:         "Point should contain all vars except locals!");
    #####:  908:  assert(getVarKindOffset(VarKind::Local) == getNumVars() - getNumLocalVars() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  909:         "This function depends on locals being stored last!");
    #####:  910:  IntegerRelation copy = *this;
call    0 never executed
call    1 never executed
    #####:  911:  copy.setAndEliminate(0, point);
call    0 never executed
    #####:  912:  return copy.findIntegerSample();
call    0 never executed
        -:  913:}
        -:  914:
        -:  915:DivisionRepr
function _ZNK4mlir10presburger15IntegerRelation13getLocalReprsEPSt6vectorINS0_14MaybeLocalReprESaIS3_EE called 35728 returned 100% blocks executed 84%
    35728:  916:IntegerRelation::getLocalReprs(std::vector<MaybeLocalRepr> *repr) const {
    35728:  917:  SmallVector<bool, 8> foundRepr(getNumVars(), false);
call    0 returned 100%
   113220:  918:  for (unsigned i = 0, e = getNumDimAndSymbolVars(); i < e; ++i)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
    77492:  919:    foundRepr[i] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  920:
    35728:  921:  unsigned localOffset = getVarKindOffset(VarKind::Local);
call    0 returned 100%
    35728:  922:  DivisionRepr divs(getNumVars(), getNumLocalVars());
call    0 returned 100%
    36714:  923:  bool changed;
    36714:  924:  do {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  925:    // Each time changed is true, at end of this iteration, one or more local
        -:  926:    // vars have been detected as floor divs.
    36714:  927:    changed = false;
    40694:  928:    for (unsigned i = 0, e = getNumLocalVars(); i < e; ++i) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
     3980:  929:      if (!foundRepr[i + localOffset]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
     2674:  930:        MaybeLocalRepr res =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  931:            computeSingleVarRepr(*this, foundRepr, localOffset + i,
     2674:  932:                                 divs.getDividend(i), divs.getDenom(i));
call    0 returned 100%
call    1 returned 100%
     2674:  933:        if (!res) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:  934:          // No representation was found, so clear the representation and
        -:  935:          // continue.
     1368:  936:          divs.clearRepr(i);
call    0 returned 100%
     1368:  937:          continue;
        -:  938:        }
     1306:  939:        foundRepr[localOffset + i] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1306:  940:        if (repr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  941:          (*repr)[i] = res;
     1306:  942:        changed = true;
        -:  943:      }
        -:  944:    }
        -:  945:  } while (changed);
        -:  946:
    35728:  947:  return divs;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  948:}
        -:  949:
        -:  950:/// Tightens inequalities given that we are dealing with integer spaces. This is
        -:  951:/// analogous to the GCD test but applied to inequalities. The constant term can
        -:  952:/// be reduced to the preceding multiple of the GCD of the coefficients, i.e.,
        -:  953:///  64*i - 100 >= 0  =>  64*i - 128 >= 0 (since 'i' is an integer). This is a
        -:  954:/// fast method - linear in the number of coefficients.
        -:  955:// Example on how this affects practical cases: consider the scenario:
        -:  956:// 64*i >= 100, j = 64*i; without a tightening, elimination of i would yield
        -:  957:// j >= 100 instead of the tighter (exact) j >= 128.
function _ZN4mlir10presburger15IntegerRelation22gcdTightenInequalitiesEv called 226314 returned 100% blocks executed 29%
   226314:  958:void IntegerRelation::gcdTightenInequalities() {
   226314:  959:  unsigned numCols = getNumCols();
   620994:  960:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
        -:  961:    // Normalize the constraint and tighten the constant term by the GCD.
   789360:  962:    MPInt gcd = inequalities.normalizeRow(i, getNumCols() - 1);
call    0 returned 100%
   789360:  963:    if (gcd > 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
     6066:  964:      atIneq(i, numCols - 1) = floorDiv(atIneq(i, numCols - 1), gcd);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -:  965:  }
   226314:  966:}
        -:  967:
        -:  968:// Eliminates all variable variables in column range [posStart, posLimit).
        -:  969:// Returns the number of variables eliminated.
function _ZN4mlir10presburger15IntegerRelation21gaussianEliminateVarsEjj called 55363 returned 100% blocks executed 76%
    55363:  970:unsigned IntegerRelation::gaussianEliminateVars(unsigned posStart,
        -:  971:                                                unsigned posLimit) {
        -:  972:  // Return if variable positions to eliminate are out of range.
   55363*:  973:  assert(posLimit <= getNumVars());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   55363*:  974:  assert(hasConsistentState());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  975:
    55363:  976:  if (posStart >= posLimit)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  977:    return 0;
        -:  978:
    54271:  979:  gcdTightenInequalities();
        -:  980:
    54271:  981:  unsigned pivotCol = 0;
   163947:  982:  for (pivotCol = posStart; pivotCol < posLimit; ++pivotCol) {
call    0 returned 100%
branch  1 taken 79% (fallthrough)
branch  2 taken 21%
        -:  983:    // Find a row which has a non-zero coefficient in column 'j'.
   129102:  984:    unsigned pivotRow;
   129102:  985:    if (!findConstraintWithNonZeroAt(pivotCol, /*isEq=*/true, &pivotRow)) {
call    0 returned 100%
branch  1 taken 39% (fallthrough)
branch  2 taken 61%
        -:  986:      // No pivot row in equalities with non-zero at 'pivotCol'.
    50470:  987:      if (!findConstraintWithNonZeroAt(pivotCol, /*isEq=*/false, &pivotRow)) {
call    0 returned 100%
branch  1 taken 62% (fallthrough)
branch  2 taken 38%
        -:  988:        // If inequalities are also non-zero in 'pivotCol', it can be
        -:  989:        // eliminated.
    31044:  990:        continue;
        -:  991:      }
    19426:  992:      break;
        -:  993:    }
        -:  994:
        -:  995:    // Eliminate variable at 'pivotCol' from each equality row.
   214729:  996:    for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
   136097:  997:      eliminateFromConstraint(this, i, pivotRow, pivotCol, posStart,
call    0 returned 100%
        -:  998:                              /*isEq=*/true);
   136097:  999:      equalities.normalizeRow(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1000:    }
        -: 1001:
        -: 1002:    // Eliminate variable at 'pivotCol' from each inequality row.
   166224: 1003:    for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
    87592: 1004:      eliminateFromConstraint(this, i, pivotRow, pivotCol, posStart,
call    0 returned 100%
        -: 1005:                              /*isEq=*/false);
    87592: 1006:      inequalities.normalizeRow(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1007:    }
    78632: 1008:    removeEquality(pivotRow);
call    0 returned 100%
    78632: 1009:    gcdTightenInequalities();
call    0 returned 100%
        -: 1010:  }
        -: 1011:  // Update position limit based on number eliminated.
    54271: 1012:  posLimit = pivotCol;
        -: 1013:  // Remove eliminated columns from all constraints.
    54271: 1014:  removeVarRange(posStart, posLimit);
call    0 returned 100%
    54271: 1015:  return posLimit - posStart;
        -: 1016:}
        -: 1017:
        -: 1018:// A more complex check to eliminate redundant inequalities. Uses FourierMotzkin
        -: 1019:// to check if a constraint is redundant.
function _ZN4mlir10presburger15IntegerRelation27removeRedundantInequalitiesEv called 252 returned 100% blocks executed 29%
      252: 1020:void IntegerRelation::removeRedundantInequalities() {
      252: 1021:  SmallVector<bool, 32> redun(getNumInequalities(), false);
call    0 returned 100%
        -: 1022:  // To check if an inequality is redundant, we replace the inequality by its
        -: 1023:  // complement (for eg., i - 1 >= 0 by i <= 0), and check if the resulting
        -: 1024:  // system is empty. If it is, the inequality is redundant.
      504: 1025:  IntegerRelation tmpCst(*this);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1070: 1026:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -: 1027:    // Change the inequality to its complement.
      818: 1028:    tmpCst.inequalities.negateRow(r);
call    0 returned 100%
      818: 1029:    --tmpCst.atIneq(r, tmpCst.getNumCols() - 1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      818: 1030:    if (tmpCst.isEmpty()) {
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
      250: 1031:      redun[r] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1032:      // Zero fill the redundant inequality.
      250: 1033:      inequalities.fillRow(r, /*value=*/0);
call    0 returned 100%
      250: 1034:      tmpCst.inequalities.fillRow(r, /*value=*/0);
call    0 returned 100%
        -: 1035:    } else {
        -: 1036:      // Reverse the change (to avoid recreating tmpCst each time).
      568: 1037:      ++tmpCst.atIneq(r, tmpCst.getNumCols() - 1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      568: 1038:      tmpCst.inequalities.negateRow(r);
call    0 returned 100%
        -: 1039:    }
        -: 1040:  }
        -: 1041:
      252: 1042:  unsigned pos = 0;
     1070: 1043:  for (unsigned r = 0, e = getNumInequalities(); r < e; ++r) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
      818: 1044:    if (!redun[r])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 69% (fallthrough)
branch  3 taken 31%
      568: 1045:      inequalities.copyRow(r, pos++);
call    0 returned 100%
        -: 1046:  }
      252: 1047:  inequalities.resizeVertically(pos);
call    0 returned 100%
      252: 1048:}
        -: 1049:
        -: 1050:// A more complex check to eliminate redundant inequalities and equalities. Uses
        -: 1051:// Simplex to check if a constraint is redundant.
function _ZN4mlir10presburger15IntegerRelation26removeRedundantConstraintsEv called 0 returned 0% blocks executed 0%
    #####: 1052:void IntegerRelation::removeRedundantConstraints() {
        -: 1053:  // First, we run gcdTightenInequalities. This allows us to catch some
        -: 1054:  // constraints which are not redundant when considering rational solutions
        -: 1055:  // but are redundant in terms of integer solutions.
    #####: 1056:  gcdTightenInequalities();
call    0 never executed
    #####: 1057:  Simplex simplex(*this);
call    0 never executed
    #####: 1058:  simplex.detectRedundant();
call    0 never executed
        -: 1059:
    #####: 1060:  unsigned pos = 0;
    #####: 1061:  unsigned numIneqs = getNumInequalities();
        -: 1062:  // Scan to get rid of all inequalities marked redundant, in-place. In Simplex,
        -: 1063:  // the first constraints added are the inequalities.
    #####: 1064:  for (unsigned r = 0; r < numIneqs; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1065:    if (!simplex.isMarkedRedundant(r))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1066:      inequalities.copyRow(r, pos++);
call    0 never executed
        -: 1067:  }
    #####: 1068:  inequalities.resizeVertically(pos);
call    0 never executed
        -: 1069:
        -: 1070:  // Scan to get rid of all equalities marked redundant, in-place. In Simplex,
        -: 1071:  // after the inequalities, a pair of constraints for each equality is added.
        -: 1072:  // An equality is redundant if both the inequalities in its pair are
        -: 1073:  // redundant.
    #####: 1074:  pos = 0;
    #####: 1075:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1076:    if (!(simplex.isMarkedRedundant(numIneqs + 2 * r) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1077:          simplex.isMarkedRedundant(numIneqs + 2 * r + 1)))
call    0 never executed
    #####: 1078:      equalities.copyRow(r, pos++);
call    0 never executed
        -: 1079:  }
    #####: 1080:  equalities.resizeVertically(pos);
call    0 never executed
call    1 never executed
    #####: 1081:}
        -: 1082:
function _ZNK4mlir10presburger15IntegerRelation13computeVolumeEv called 0 returned 0% blocks executed 0%
    #####: 1083:Optional<MPInt> IntegerRelation::computeVolume() const {
    #####: 1084:  assert(getNumSymbolVars() == 0 && "Symbols are not yet supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1085:
    #####: 1086:  Simplex simplex(*this);
call    0 never executed
        -: 1087:  // If the polytope is rationally empty, there are certainly no integer
        -: 1088:  // points.
    #####: 1089:  if (simplex.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1090:    return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1091:
        -: 1092:  // Just find the maximum and minimum integer value of each non-local var
        -: 1093:  // separately, thus finding the number of integer values each such var can
        -: 1094:  // take. Multiplying these together gives a valid overapproximation of the
        -: 1095:  // number of integer points in the relation. The result this gives is
        -: 1096:  // equivalent to projecting (rationally) the relation onto its non-local vars
        -: 1097:  // and returning the number of integer points in a minimal axis-parallel
        -: 1098:  // hyperrectangular overapproximation of that.
        -: 1099:  //
        -: 1100:  // We also handle the special case where one dimension is unbounded and
        -: 1101:  // another dimension can take no integer values. In this case, the volume is
        -: 1102:  // zero.
        -: 1103:  //
        -: 1104:  // If there is no such empty dimension, if any dimension is unbounded we
        -: 1105:  // just return the result as unbounded.
    #####: 1106:  MPInt count(1);
call    0 never executed
call    1 never executed
    #####: 1107:  SmallVector<MPInt, 8> dim(getNumVars() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1108:  bool hasUnboundedVar = false;
    #####: 1109:  for (unsigned i = 0, e = getNumDimAndSymbolVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1110:    dim[i] = 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1111:    auto [min, max] = simplex.computeIntegerBounds(dim);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1112:    dim[i] = 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1113:
    #####: 1114:    assert((!min.isEmpty() && !max.isEmpty()) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1115:           "Polytope should be rationally non-empty!");
        -: 1116:
        -: 1117:    // One of the dimensions is unbounded. Note this fact. We will return
        -: 1118:    // unbounded if none of the other dimensions makes the volume zero.
    #####: 1119:    if (min.isUnbounded() || max.isUnbounded()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1120:      hasUnboundedVar = true;
    #####: 1121:      continue;
call    0 never executed
        -: 1122:    }
        -: 1123:
        -: 1124:    // In this case there are no valid integer points and the volume is
        -: 1125:    // definitely zero.
    #####: 1126:    if (min.getBoundedOptimum() > max.getBoundedOptimum())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1127:      return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1128:
    #####: 1129:    count *= (*max - *min + 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
        -: 1130:  }
        -: 1131:
    #####: 1132:  if (count == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1133:    return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1134:  if (hasUnboundedVar)
branch  0 never executed
branch  1 never executed
    #####: 1135:    return {};
    #####: 1136:  return count;
call    0 never executed
call    1 never executed
        -: 1137:}
        -: 1138:
function _ZN4mlir10presburger15IntegerRelation26eliminateRedundantLocalVarEjj called 0 returned 0% blocks executed 0%
    #####: 1139:void IntegerRelation::eliminateRedundantLocalVar(unsigned posA, unsigned posB) {
    #####: 1140:  assert(posA < getNumLocalVars() && "Invalid local var position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1141:  assert(posB < getNumLocalVars() && "Invalid local var position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1142:
    #####: 1143:  unsigned localOffset = getVarKindOffset(VarKind::Local);
call    0 never executed
    #####: 1144:  posA += localOffset;
    #####: 1145:  posB += localOffset;
    #####: 1146:  inequalities.addToColumn(posB, posA, 1);
call    0 never executed
    #####: 1147:  equalities.addToColumn(posB, posA, 1);
call    0 never executed
    #####: 1148:  removeVar(posB);
call    0 never executed
    #####: 1149:}
        -: 1150:
        -: 1151:/// Adds additional local ids to the sets such that they both have the union
        -: 1152:/// of the local ids in each set, without changing the set of points that
        -: 1153:/// lie in `this` and `other`.
        -: 1154:///
        -: 1155:/// To detect local ids that always take the same value, each local id is
        -: 1156:/// represented as a floordiv with constant denominator in terms of other ids.
        -: 1157:/// After extracting these divisions, local ids in `other` with the same
        -: 1158:/// division representation as some other local id in any set are considered
        -: 1159:/// duplicate and are merged.
        -: 1160:///
        -: 1161:/// It is possible that division representation for some local id cannot be
        -: 1162:/// obtained, and thus these local ids are not considered for detecting
        -: 1163:/// duplicates.
function _ZN4mlir10presburger15IntegerRelation14mergeLocalVarsERS1_ called 17864 returned 100% blocks executed 100%
    17864: 1164:unsigned IntegerRelation::mergeLocalVars(IntegerRelation &other) {
    17864: 1165:  IntegerRelation &relA = *this;
    17864: 1166:  IntegerRelation &relB = other;
        -: 1167:
    17864: 1168:  unsigned oldALocals = relA.getNumLocalVars();
call    0 returned 100%
        -: 1169:
        -: 1170:  // Merge function that merges the local variables in both sets by treating
        -: 1171:  // them as the same variable.
function _ZZN4mlir10presburger15IntegerRelation14mergeLocalVarsERS1_ENKUljjE_clEjj called 0 returned 0% blocks executed 0%
   17864*: 1172:  auto merge = [&relA, &relB, oldALocals](unsigned i, unsigned j) -> bool {
        -: 1173:    // We only merge from local at pos j to local at pos i, where j > i.
    #####: 1174:    if (i >= j)
branch  0 never executed
branch  1 never executed
        -: 1175:      return false;
        -: 1176:
        -: 1177:    // If i < oldALocals, we are trying to merge duplicate divs. Since we do not
        -: 1178:    // want to merge duplicates in A, we ignore this call.
    #####: 1179:    if (j < oldALocals)
branch  0 never executed
branch  1 never executed
        -: 1180:      return false;
        -: 1181:
        -: 1182:    // Merge local at pos j into local at position i.
    #####: 1183:    relA.eliminateRedundantLocalVar(i, j);
call    0 never executed
    #####: 1184:    relB.eliminateRedundantLocalVar(i, j);
    #####: 1185:    return true;
call    0 never executed
    17864: 1186:  };
        -: 1187:
    17864: 1188:  presburger::mergeLocalVars(*this, other, merge);
call    0 returned 100%
        -: 1189:
        -: 1190:  // Since we do not remove duplicate divisions in relA, this is guranteed to be
        -: 1191:  // non-negative.
    17864: 1192:  return relA.getNumLocalVars() - oldALocals;
        -: 1193:}
        -: 1194:
function _ZNK4mlir10presburger15IntegerRelation16hasOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####: 1195:bool IntegerRelation::hasOnlyDivLocals() const {
    #####: 1196:  return getLocalReprs().hasAllReprs();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1197:}
        -: 1198:
function _ZN4mlir10presburger15IntegerRelation19removeDuplicateDivsEv called 0 returned 0% blocks executed 0%
    #####: 1199:void IntegerRelation::removeDuplicateDivs() {
    #####: 1200:  DivisionRepr divs = getLocalReprs();
call    0 never executed
    #####: 1201:  auto merge = [this](unsigned i, unsigned j) -> bool {
    #####: 1202:    eliminateRedundantLocalVar(i, j);
call    0 never executed
    #####: 1203:    return true;
    #####: 1204:  };
    #####: 1205:  divs.removeDuplicateDivs(merge);
call    0 never executed
call    1 never executed
    #####: 1206:}
        -: 1207:
        -: 1208:/// Removes local variables using equalities. Each equality is checked if it
        -: 1209:/// can be reduced to the form: `e = affine-expr`, where `e` is a local
        -: 1210:/// variable and `affine-expr` is an affine expression not containing `e`.
        -: 1211:/// If an equality satisfies this form, the local variable is replaced in
        -: 1212:/// each constraint and then removed. The equality used to replace this local
        -: 1213:/// variable is also removed.
function _ZN4mlir10presburger15IntegerRelation24removeRedundantLocalVarsEv called 39184 returned 100% blocks executed 48%
    39184: 1214:void IntegerRelation::removeRedundantLocalVars() {
        -: 1215:  // Normalize the equality constraints to reduce coefficients of local
        -: 1216:  // variables to 1 wherever possible.
   128286: 1217:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i)
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
    89102: 1218:    equalities.normalizeRow(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1219:
    44621: 1220:  while (true) {
    44621: 1221:    unsigned i, e, j, f;
   128628: 1222:    for (i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -: 1223:      // Find a local variable to eliminate using ith equality.
    93337: 1224:      for (j = getNumDimAndSymbolVars(), f = getNumVars(); j < f; ++j)
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
    27990: 1225:        if (abs(atEq(i, j)) == 1)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 42% (fallthrough)
branch  8 taken 58%
        -: 1226:          break;
        -: 1227:
        -: 1228:      // Local variable can be eliminated using ith equality.
    89444: 1229:      if (j < f)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -: 1230:        break;
        -: 1231:    }
        -: 1232:
        -: 1233:    // No equality can be used to eliminate a local variable.
    44621: 1234:    if (i == e)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -: 1235:      break;
        -: 1236:
        -: 1237:    // Use the ith equality to simplify other equalities. If any changes
        -: 1238:    // are made to an equality constraint, it is normalized by GCD.
    26471: 1239:    for (unsigned k = 0, t = getNumEqualities(); k < t; ++k) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
    42068: 1240:      if (atEq(k, j) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 48% (fallthrough)
branch  4 taken 52%
    10157: 1241:        eliminateFromConstraint(this, k, i, j, j, /*isEq=*/true);
call    0 returned 100%
    10157: 1242:        equalities.normalizeRow(k);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1243:      }
        -: 1244:    }
        -: 1245:
        -: 1246:    // Use the ith equality to simplify inequalities.
    11557: 1247:    for (unsigned k = 0, t = getNumInequalities(); k < t; ++k)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
     6120: 1248:      eliminateFromConstraint(this, k, i, j, j, /*isEq=*/false);
call    0 returned 100%
        -: 1249:
        -: 1250:    // Remove the ith equality and the found local variable.
     5437: 1251:    removeVar(j);
call    0 returned 100%
    50058: 1252:    removeEquality(i);
call    0 returned 100%
        -: 1253:  }
    39184: 1254:}
        -: 1255:
function _ZN4mlir10presburger15IntegerRelation14convertVarKindENS0_7VarKindEjjS2_j called 19340 returned 100% blocks executed 91%
    19340: 1256:void IntegerRelation::convertVarKind(VarKind srcKind, unsigned varStart,
        -: 1257:                                     unsigned varLimit, VarKind dstKind,
        -: 1258:                                     unsigned pos) {
   19340*: 1259:  assert(varLimit <= getNumVarKind(srcKind) && "Invalid id range");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1260:
    19340: 1261:  if (varStart >= varLimit)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 1262:    return;
        -: 1263:
        -: 1264:  // Append new local variables corresponding to the dimensions to be converted.
    19182: 1265:  unsigned convertCount = varLimit - varStart;
    19182: 1266:  unsigned newVarsBegin = insertVar(dstKind, pos, convertCount);
call    0 returned 100%
        -: 1267:
        -: 1268:  // Swap the new local variables with dimensions.
        -: 1269:  //
        -: 1270:  // Essentially, this moves the information corresponding to the specified ids
        -: 1271:  // of kind `srcKind` to the `convertCount` newly created ids of kind
        -: 1272:  // `dstKind`. In particular, this moves the columns in the constraint
        -: 1273:  // matrices, and zeros out the initially occupied columns (because the newly
        -: 1274:  // created ids we're swapping with were zero-initialized).
    19182: 1275:  unsigned offset = getVarKindOffset(srcKind);
call    0 returned 100%
    59220: 1276:  for (unsigned i = 0; i < convertCount; ++i)
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
    40038: 1277:    swapVar(offset + varStart + i, newVarsBegin + i);
call    0 returned 100%
        -: 1278:
        -: 1279:  // Complete the move by deleting the initially occupied columns.
    19182: 1280:  removeVarRange(srcKind, varStart, varLimit);
call    0 returned 100%
        -: 1281:}
        -: 1282:
function _ZN4mlir10presburger15IntegerRelation8addBoundENS1_9BoundTypeEjRKNS0_5MPIntE called 96148 returned 100% blocks executed 15%
    96148: 1283:void IntegerRelation::addBound(BoundType type, unsigned pos,
        -: 1284:                               const MPInt &value) {
   96148*: 1285:  assert(pos < getNumCols());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    96148: 1286:  if (type == BoundType::EQ) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1287:    unsigned row = equalities.appendExtraRow();
call    0 never executed
    #####: 1288:    equalities(row, pos) = 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1289:    equalities(row, getNumCols() - 1) = -value;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1290:  } else {
    96148: 1291:    unsigned row = inequalities.appendExtraRow();
call    0 returned 100%
   144222: 1292:    inequalities(row, pos) = type == BoundType::LB ? 1 : -1;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    96148: 1293:    inequalities(row, getNumCols() - 1) =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   288444: 1294:        type == BoundType::LB ? -value : value;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1295:  }
    96148: 1296:}
        -: 1297:
function _ZN4mlir10presburger15IntegerRelation8addBoundENS1_9BoundTypeEN4llvm8ArrayRefINS0_5MPIntEEERKS5_ called 0 returned 0% blocks executed 0%
    #####: 1298:void IntegerRelation::addBound(BoundType type, ArrayRef<MPInt> expr,
        -: 1299:                               const MPInt &value) {
    #####: 1300:  assert(type != BoundType::EQ && "EQ not implemented");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1301:  assert(expr.size() == getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1302:  unsigned row = inequalities.appendExtraRow();
call    0 never executed
    #####: 1303:  for (unsigned i = 0, e = expr.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1304:    inequalities(row, i) = type == BoundType::LB ? expr[i] : -expr[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1305:  inequalities(inequalities.getNumRows() - 1, getNumCols() - 1) +=
branch  0 never executed
branch  1 never executed
    #####: 1306:      type == BoundType::LB ? -value : value;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1307:}
        -: 1308:
        -: 1309:/// Adds a new local variable as the floordiv of an affine function of other
        -: 1310:/// variables, the coefficients of which are provided in 'dividend' and with
        -: 1311:/// respect to a positive constant 'divisor'. Two constraints are added to the
        -: 1312:/// system to capture equivalence with the floordiv.
        -: 1313:///      q = expr floordiv c    <=>   c*q <= expr <= c*q + c - 1.
function _ZN4mlir10presburger15IntegerRelation16addLocalFloorDivEN4llvm8ArrayRefINS0_5MPIntEEERKS4_ called 3092 returned 100% blocks executed 63%
     3092: 1314:void IntegerRelation::addLocalFloorDiv(ArrayRef<MPInt> dividend,
        -: 1315:                                       const MPInt &divisor) {
    3092*: 1316:  assert(dividend.size() == getNumCols() && "incorrect dividend size");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    6184*: 1317:  assert(divisor > 0 && "positive divisor expected");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1318:
     3092: 1319:  appendVar(VarKind::Local);
call    0 returned 100%
        -: 1320:
     3092: 1321:  SmallVector<MPInt, 8> dividendCopy(dividend.begin(), dividend.end());
call    0 returned 100%
     3092: 1322:  dividendCopy.insert(dividendCopy.end() - 1, MPInt(0));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3092: 1323:  addInequality(
call    0 returned 100%
     3092: 1324:      getDivLowerBound(dividendCopy, divisor, dividendCopy.size() - 2));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3092: 1325:  addInequality(
call    0 returned 100%
     3092: 1326:      getDivUpperBound(dividendCopy, divisor, dividendCopy.size() - 2));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     3092: 1327:}
        -: 1328:
        -: 1329:/// Finds an equality that equates the specified variable to a constant.
        -: 1330:/// Returns the position of the equality row. If 'symbolic' is set to true,
        -: 1331:/// symbols are also treated like a constant, i.e., an affine function of the
        -: 1332:/// symbols is also treated like a constant. Returns -1 if such an equality
        -: 1333:/// could not be found.
function _ZL22findEqualityToConstantRKN4mlir10presburger15IntegerRelationEjb called 65562 returned 100% blocks executed 36%
    65562: 1334:static int findEqualityToConstant(const IntegerRelation &cst, unsigned pos,
        -: 1335:                                  bool symbolic = false) {
   65562*: 1336:  assert(pos < cst.getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    93121: 1337:  for (unsigned r = 0, e = cst.getNumEqualities(); r < e; r++) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
    69688: 1338:    MPInt v = cst.atEq(r, pos);
call    0 returned 100%
   206670: 1339:    if (v * v != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 39% (fallthrough)
branch  7 taken 61%
    26761: 1340:      continue;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    42129: 1341:    unsigned c;
    42129: 1342:    unsigned f = symbolic ? cst.getNumDimVars() : cst.getNumVars();
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -: 1343:    // This checks for zeros in all positions other than 'pos' in [0, f)
   134440: 1344:    for (c = 0; c < f; c++) {
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
    93109: 1345:      if (c == pos)
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
    41331: 1346:        continue;
   103556: 1347:      if (cst.atEq(r, c) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 98% (fallthrough)
branch  6 taken 2%
        -: 1348:        // Dependent on another variable.
        -: 1349:        break;
        -: 1350:      }
        -: 1351:    }
    42129: 1352:    if (c == f)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -: 1353:      // Equality is free of other variables.
    41331: 1354:      return r;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1355:  }
        -: 1356:  return -1;
        -: 1357:}
        -: 1358:
function _ZN4mlir10presburger15IntegerRelation15constantFoldVarEj called 801 returned 100% blocks executed 3%
      801: 1359:LogicalResult IntegerRelation::constantFoldVar(unsigned pos) {
     801*: 1360:  assert(pos < getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      801: 1361:  int rowIdx;
      801: 1362:  if ((rowIdx = findEqualityToConstant(*this, pos)) == -1)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      801: 1363:    return failure();
        -: 1364:
        -: 1365:  // atEq(rowIdx, pos) is either -1 or 1.
    #####: 1366:  assert(atEq(rowIdx, pos) * atEq(rowIdx, pos) == 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####: 1367:  MPInt constVal = -atEq(rowIdx, getNumCols() - 1) / atEq(rowIdx, pos);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1368:  setAndEliminate(pos, constVal);
call    0 never executed
    #####: 1369:  return success();
branch  0 never executed
branch  1 never executed
        -: 1370:}
        -: 1371:
function _ZN4mlir10presburger15IntegerRelation20constantFoldVarRangeEjj called 29553 returned 100% blocks executed 100%
    29553: 1372:void IntegerRelation::constantFoldVarRange(unsigned pos, unsigned num) {
    30354: 1373:  for (unsigned s = pos, t = pos, e = pos + num; s < e; s++) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
      801: 1374:    if (failed(constantFoldVar(t)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      801: 1375:      t++;
        -: 1376:  }
    29553: 1377:}
        -: 1378:
        -: 1379:/// Returns a non-negative constant bound on the extent (upper bound - lower
        -: 1380:/// bound) of the specified variable if it is found to be a constant; returns
        -: 1381:/// None if it's not a constant. This methods treats symbolic variables
        -: 1382:/// specially, i.e., it looks for constant differences between affine
        -: 1383:/// expressions involving only the symbolic variables. See comments at
        -: 1384:/// function definition for example. 'lb', if provided, is set to the lower
        -: 1385:/// bound associated with the constant difference. Note that 'lb' is purely
        -: 1386:/// symbolic and thus will contain the coefficients of the symbolic variables
        -: 1387:/// and the constant coefficient.
        -: 1388://  Egs: 0 <= i <= 15, return 16.
        -: 1389://       s0 + 2 <= i <= s0 + 17, returns 16. (s0 has to be a symbol)
        -: 1390://       s0 + s1 + 16 <= d0 <= s0 + s1 + 31, returns 16.
        -: 1391://       s0 - 7 <= 8*j <= s0 returns 1 with lb = s0, lbDivisor = 8 (since lb =
        -: 1392://       ceil(s0 - 7 / 8) = floor(s0 / 8)).
function _ZNK4mlir10presburger15IntegerRelation25getConstantBoundOnDimSizeEjPN4llvm15SmallVectorImplINS0_5MPIntEEEPS4_S6_PjS8_ called 60883 returned 100% blocks executed 24%
    60883: 1393:Optional<MPInt> IntegerRelation::getConstantBoundOnDimSize(
        -: 1394:    unsigned pos, SmallVectorImpl<MPInt> *lb, MPInt *boundFloorDivisor,
        -: 1395:    SmallVectorImpl<MPInt> *ub, unsigned *minLbPos, unsigned *minUbPos) const {
   60883*: 1396:  assert(pos < getNumDimVars() && "Invalid variable position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1397:
        -: 1398:  // Find an equality for 'pos'^th variable that equates it to some function
        -: 1399:  // of the symbolic variables (+ constant).
    60883: 1400:  int eqPos = findEqualityToConstant(*this, pos, /*symbolic=*/true);
call    0 returned 100%
    60883: 1401:  if (eqPos != -1) {
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
    41331: 1402:    auto eq = getEquality(eqPos);
call    0 returned 100%
        -: 1403:    // If the equality involves a local var, punt for now.
        -: 1404:    // TODO: this can be handled in the future by using the explicit
        -: 1405:    // representation of the local vars.
    41331: 1406:    if (!std::all_of(eq.begin() + getNumDimAndSymbolVars(), eq.end() - 1,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
function _ZZNK4mlir10presburger15IntegerRelation25getConstantBoundOnDimSizeEjPN4llvm15SmallVectorImplINS0_5MPIntEEEPS4_S6_PjS8_ENKUlRKS4_E_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1407:                     [](const MPInt &coeff) { return coeff == 0; }))
branch  0 never executed
branch  1 never executed
    #####: 1408:      return None;
        -: 1409:
        -: 1410:    // This variable can only take a single value.
    41331: 1411:    if (lb) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1412:      // Set lb to that symbolic value.
    41331: 1413:      lb->resize(getNumSymbolVars() + 1);
call    0 returned 100%
    41331: 1414:      if (ub)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    41331: 1415:        ub->resize(getNumSymbolVars() + 1);
call    0 returned 100%
    82697: 1416:      for (unsigned c = 0, f = getNumSymbolVars() + 1; c < f; c++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    82732: 1417:        MPInt v = atEq(eqPos, pos);
call    0 returned 100%
        -: 1418:        // atEq(eqRow, pos) is either -1 or 1.
  124098*: 1419:        assert(v * v == 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
  165464*: 1420:        (*lb)[c] = v < 0 ? atEq(eqPos, getNumDimVars() + c) / -v
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
   206830: 1421:                         : -atEq(eqPos, getNumDimVars() + c) / v;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
        -: 1422:        // Since this is an equality, ub = lb.
    41366: 1423:        if (ub)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    82732: 1424:          (*ub)[c] = (*lb)[c];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -: 1425:      }
   41331*: 1426:      assert(boundFloorDivisor &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1427:             "both lb and divisor or none should be provided");
    41331: 1428:      *boundFloorDivisor = 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1429:    }
    41331: 1430:    if (minLbPos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1431:      *minLbPos = eqPos;
    41331: 1432:    if (minUbPos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1433:      *minUbPos = eqPos;
    41331: 1434:    return MPInt(1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1435:  }
        -: 1436:
        -: 1437:  // Check if the variable appears at all in any of the inequalities.
    19552: 1438:  unsigned r, e;
    44790: 1439:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    89580: 1440:    if (atIneq(r, pos) != 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 56% (fallthrough)
branch  6 taken 44%
        -: 1441:      break;
        -: 1442:  }
    19552: 1443:  if (r == e)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1444:    // If it doesn't, there isn't a bound on it.
    #####: 1445:    return None;
        -: 1446:
        -: 1447:  // Positions of constraints that are lower/upper bounds on the variable.
    39104: 1448:  SmallVector<unsigned, 4> lbIndices, ubIndices;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1449:
        -: 1450:  // Gather all symbolic lower bounds and upper bounds of the variable, i.e.,
        -: 1451:  // the bounds can only involve symbolic (and local) variables. Since the
        -: 1452:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -: 1453:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
    19552: 1454:  getLowerAndUpperBoundIndices(pos, &lbIndices, &ubIndices,
call    0 returned 100%
        -: 1455:                               /*eqIndices=*/nullptr, /*offset=*/0,
        -: 1456:                               /*num=*/getNumDimVars());
        -: 1457:
    19552: 1458:  Optional<MPInt> minDiff;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    19552: 1459:  unsigned minLbPosition = 0, minUbPosition = 0;
    51282: 1460:  for (auto ubPos : ubIndices) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
    87816: 1461:    for (auto lbPos : lbIndices) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
        -: 1462:      // Look for a lower bound and an upper bound that only differ by a
        -: 1463:      // constant, i.e., pairs of the form  0 <= c_pos - f(c_i's) <= diffConst.
        -: 1464:      // For example, if ii is the pos^th variable, we are looking for
        -: 1465:      // constraints like ii >= i, ii <= ii + 50, 50 being the difference. The
        -: 1466:      // minimum among all such constant differences is kept since that's the
        -: 1467:      // constant bounding the extent of the pos^th variable.
    56086: 1468:      unsigned j, e;
   183672: 1469:      for (j = 0, e = getNumCols() - 1; j < e; j++)
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
   382758: 1470:        if (atIneq(ubPos, j) != -atIneq(lbPos, j)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        -: 1471:          break;
        -: 1472:        }
   56086*: 1473:      if (j < getNumCols() - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1474:        continue;
   224344: 1475:      MPInt diff = ceilDiv(atIneq(ubPos, getNumCols() - 1) +
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
   224344: 1476:                               atIneq(lbPos, getNumCols() - 1) + 1,
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
   168258: 1477:                           atIneq(lbPos, pos));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1478:      // This bound is non-negative by definition.
   112172: 1479:      diff = std::max<MPInt>(diff, MPInt(0));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    56086: 1480:      if (minDiff == None || diff < minDiff) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
call    2 returned 100%
branch  3 taken 23% (fallthrough)
branch  4 taken 77%
    27784: 1481:        minDiff = diff;
call    0 returned 100%
    27784: 1482:        minLbPosition = lbPos;
    27784: 1483:        minUbPosition = ubPos;
call    0 returned 100%
        -: 1484:      }
        -: 1485:    }
        -: 1486:  }
    19552: 1487:  if (lb && minDiff) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1488:    // Set lb to the symbolic lower bound.
    19552: 1489:    lb->resize(getNumSymbolVars() + 1);
call    0 returned 100%
    19552: 1490:    if (ub)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    19552: 1491:      ub->resize(getNumSymbolVars() + 1);
call    0 returned 100%
        -: 1492:    // The lower bound is the ceildiv of the lb constraint over the coefficient
        -: 1493:    // of the variable at 'pos'. We express the ceildiv equivalently as a floor
        -: 1494:    // for uniformity. For eg., if the lower bound constraint was: 32*d0 - N +
        -: 1495:    // 31 >= 0, the lower bound for d0 is ceil(N - 31, 32), i.e., floor(N, 32).
    39104: 1496:    *boundFloorDivisor = atIneq(minLbPosition, pos);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   78208*: 1497:    assert(*boundFloorDivisor == -atIneq(minUbPosition, pos));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
    39104: 1498:    for (unsigned c = 0, e = getNumSymbolVars() + 1; c < e; c++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    58656: 1499:      (*lb)[c] = -atIneq(minLbPosition, getNumDimVars() + c);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
        -: 1500:    }
    19552: 1501:    if (ub) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    39104: 1502:      for (unsigned c = 0, e = getNumSymbolVars() + 1; c < e; c++)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    39104: 1503:        (*ub)[c] = atIneq(minUbPosition, getNumDimVars() + c);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -: 1504:    }
        -: 1505:    // The lower bound leads to a ceildiv while the upper bound is a floordiv
        -: 1506:    // whenever the coefficient at pos != 1. ceildiv (val / d) = floordiv (val +
        -: 1507:    // d - 1 / d); hence, the addition of 'atIneq(minLbPosition, pos) - 1' to
        -: 1508:    // the constant term for the lower bound.
    58656: 1509:    (*lb)[getNumSymbolVars()] += atIneq(minLbPosition, pos) - 1;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
        -: 1510:  }
    19552: 1511:  if (minLbPos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1512:    *minLbPos = minLbPosition;
    19552: 1513:  if (minUbPos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1514:    *minUbPos = minUbPosition;
    39104: 1515:  return minDiff;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 1516:}
        -: 1517:
        -: 1518:template <bool isLower>
        -: 1519:Optional<MPInt>
     3878: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
    3878*: 1521:  assert(pos < getNumVars() && "invalid position");
        -: 1522:  // Project to 'pos'.
     3878: 1523:  projectOut(0, pos);
     3878: 1524:  projectOut(1, getNumVars() - 1);
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
     3878: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
     3878: 1527:  if (eqRowIdx != -1)
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    3878*: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
     3610: 1534:    if (atIneq(r, 0) != 0)
        -: 1535:      break;
        -: 1536:  }
     3878: 1537:  if (r == e)
        -: 1538:    // If it doesn't, there isn't a bound on it.
     3878: 1539:    return None;
        -: 1540:
     5683: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
     3618: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
        -: 1546:    if (isLower) {
     1778: 1547:      if (atIneq(r, 0) <= 0)
        -: 1548:        // Not a lower bound.
      807: 1549:        continue;
     1848: 1550:    } else if (atIneq(r, 0) >= 0) {
        -: 1551:      // Not an upper bound.
      431: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
     2012: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
    1006*: 1556:      if (c != 0 && atIneq(r, c) != 0)
        -: 1557:        break;
    1006*: 1558:    if (c < getNumCols() - 1)
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
     3018: 1562:    MPInt boundConst =
      513: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
      986: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
        -: 1565:    if (isLower) {
     513*: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
      513: 1567:        minOrMaxConst = boundConst;
        -: 1568:    } else {
     493*: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
      493: 1570:        minOrMaxConst = boundConst;
        -: 1571:    }
        -: 1572:  }
     1805: 1573:  return minOrMaxConst;
        -: 1574:}
------------------
_ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb0EEEN4llvm8OptionalINS0_5MPIntEEEj:
function _ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb0EEEN4llvm8OptionalINS0_5MPIntEEEj called 1967 returned 100% blocks executed 24%
     1967: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    1967*: 1521:  assert(pos < getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1522:  // Project to 'pos'.
     1967: 1523:  projectOut(0, pos);
call    0 returned 100%
call    1 returned 100%
     1967: 1524:  projectOut(1, getNumVars() - 1);
call    0 returned 100%
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
     1967: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
call    0 returned 100%
     1967: 1527:  if (eqRowIdx != -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    1967*: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
     1840: 1534:    if (atIneq(r, 0) != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1535:      break;
        -: 1536:  }
     1967: 1537:  if (r == e)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -: 1538:    // If it doesn't, there isn't a bound on it.
     1967: 1539:    return None;
        -: 1540:
     2887: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
     1844: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1546:    if (isLower) {
        -: 1547:      if (atIneq(r, 0) <= 0)
        -: 1548:        // Not a lower bound.
      431: 1549:        continue;
     1848: 1550:    } else if (atIneq(r, 0) >= 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 47% (fallthrough)
branch  3 taken 53%
        -: 1551:      // Not an upper bound.
      431: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
      986: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     493*: 1556:      if (c != 0 && atIneq(r, c) != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1557:        break;
     493*: 1558:    if (c < getNumCols() - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
     1479: 1562:    MPInt boundConst =
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
      986: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -: 1565:    if (isLower) {
        -: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
        -: 1567:        minOrMaxConst = boundConst;
        -: 1568:    } else {
     493*: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
      493: 1570:        minOrMaxConst = boundConst;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1571:    }
        -: 1572:  }
      920: 1573:  return minOrMaxConst;
call    0 returned 100%
        -: 1574:}
------------------
_ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb1EEEN4llvm8OptionalINS0_5MPIntEEEj:
function _ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb1EEEN4llvm8OptionalINS0_5MPIntEEEj called 1911 returned 100% blocks executed 24%
     1911: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    1911*: 1521:  assert(pos < getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1522:  // Project to 'pos'.
     1911: 1523:  projectOut(0, pos);
call    0 returned 100%
call    1 returned 100%
     1911: 1524:  projectOut(1, getNumVars() - 1);
call    0 returned 100%
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
     1911: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
call    0 returned 100%
     1911: 1527:  if (eqRowIdx != -1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    1911*: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
     1770: 1534:    if (atIneq(r, 0) != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1535:      break;
        -: 1536:  }
     1911: 1537:  if (r == e)
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
        -: 1538:    // If it doesn't, there isn't a bound on it.
     1911: 1539:    return None;
        -: 1540:
     2796: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
     1774: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1546:    if (isLower) {
     1778: 1547:      if (atIneq(r, 0) <= 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 42% (fallthrough)
branch  3 taken 58%
        -: 1548:        // Not a lower bound.
      376: 1549:        continue;
        -: 1550:    } else if (atIneq(r, 0) >= 0) {
        -: 1551:      // Not an upper bound.
        -: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
     1026: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     513*: 1556:      if (c != 0 && atIneq(r, c) != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1557:        break;
     513*: 1558:    if (c < getNumCols() - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
     1539: 1562:    MPInt boundConst =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      513: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
        -: 1565:    if (isLower) {
     513*: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
      513: 1567:        minOrMaxConst = boundConst;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1568:    } else {
        -: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
        -: 1570:        minOrMaxConst = boundConst;
        -: 1571:    }
        -: 1572:  }
      885: 1573:  return minOrMaxConst;
call    0 returned 100%
        -: 1574:}
------------------
        -: 1575:
function _ZNK4mlir10presburger15IntegerRelation16getConstantBoundENS1_9BoundTypeEj called 3837 returned 100% blocks executed 50%
     3837: 1576:Optional<MPInt> IntegerRelation::getConstantBound(BoundType type,
        -: 1577:                                                  unsigned pos) const {
     3837: 1578:  if (type == BoundType::LB)
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
     3740: 1579:    return IntegerRelation(*this)
call    0 returned 100%
call    1 returned 100%
     1870: 1580:        .computeConstantLowerOrUpperBound</*isLower=*/true>(pos);
call    0 returned 100%
     1967: 1581:  if (type == BoundType::UB)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
     3852: 1582:    return IntegerRelation(*this)
call    0 returned 100%
call    1 returned 100%
     1926: 1583:        .computeConstantLowerOrUpperBound</*isLower=*/false>(pos);
call    0 returned 100%
        -: 1584:
      41*: 1585:  assert(type == BoundType::EQ && "expected EQ");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       41: 1586:  Optional<MPInt> lb =
       41: 1587:      IntegerRelation(*this).computeConstantLowerOrUpperBound</*isLower=*/true>(
call    0 returned 100%
       41: 1588:          pos);
call    0 returned 100%
       41: 1589:  Optional<MPInt> ub =
       41: 1590:      IntegerRelation(*this)
call    0 returned 100%
       82: 1591:          .computeConstantLowerOrUpperBound</*isLower=*/false>(pos);
call    0 returned 100%
call    1 returned 100%
      82*: 1592:  return (lb && ub && *lb == *ub) ? Optional<MPInt>(*ub) : None;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 returned 100%
        -: 1593:}
        -: 1594:
        -: 1595:// A simple (naive and conservative) check for hyper-rectangularity.
function _ZNK4mlir10presburger15IntegerRelation18isHyperRectangularEjj called 0 returned 0% blocks executed 0%
    #####: 1596:bool IntegerRelation::isHyperRectangular(unsigned pos, unsigned num) const {
    #####: 1597:  assert(pos < getNumCols() - 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1598:  // Check for two non-zero coefficients in the range [pos, pos + sum).
    #####: 1599:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1600:    unsigned sum = 0;
    #####: 1601:    for (unsigned c = pos; c < pos + num; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1602:      if (atIneq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1603:        sum++;
        -: 1604:    }
    #####: 1605:    if (sum > 1)
branch  0 never executed
branch  1 never executed
        -: 1606:      return false;
        -: 1607:  }
    #####: 1608:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1609:    unsigned sum = 0;
    #####: 1610:    for (unsigned c = pos; c < pos + num; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1611:      if (atEq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1612:        sum++;
        -: 1613:    }
    #####: 1614:    if (sum > 1)
branch  0 never executed
branch  1 never executed
        -: 1615:      return false;
        -: 1616:  }
        -: 1617:  return true;
        -: 1618:}
        -: 1619:
        -: 1620:/// Removes duplicate constraints, trivially true constraints, and constraints
        -: 1621:/// that can be detected as redundant as a result of differing only in their
        -: 1622:/// constant term part. A constraint of the form <non-negative constant> >= 0 is
        -: 1623:/// considered trivially true.
        -: 1624://  Uses a DenseSet to hash and detect duplicates followed by a linear scan to
        -: 1625://  remove duplicates in place.
function _ZN4mlir10presburger15IntegerRelation23removeTrivialRedundancyEv called 54247 returned 100% blocks executed 68%
    54247: 1626:void IntegerRelation::removeTrivialRedundancy() {
    54247: 1627:  gcdTightenInequalities();
call    0 returned 100%
    54247: 1628:  normalizeConstraintsByGCD();
call    0 returned 100%
        -: 1629:
        -: 1630:  // A map used to detect redundancy stemming from constraints that only differ
        -: 1631:  // in their constant term. The value stored is <row position, const term>
        -: 1632:  // for a given row.
    54247: 1633:  SmallDenseMap<ArrayRef<MPInt>, std::pair<unsigned, MPInt>>
call    0 returned 100%
   108494: 1634:      rowsWithoutConstTerm;
        -: 1635:  // To unique rows.
   108494: 1636:  SmallDenseSet<ArrayRef<MPInt>, 8> rowSet;
call    0 returned 100%
call    1 returned 100%
        -: 1637:
        -: 1638:  // Check if constraint is of the form <non-negative-constant> >= 0.
function _ZZN4mlir10presburger15IntegerRelation23removeTrivialRedundancyEvENKUljE_clEj.isra.0 called 73783 returned 100% blocks executed 62%
   128030: 1639:  auto isTriviallyValid = [&](unsigned r) -> bool {
   126014: 1640:    for (unsigned c = 0, e = getNumCols() - 1; c < e; c++) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
   234638: 1641:      if (atIneq(r, c) != 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 45% (fallthrough)
branch  4 taken 55%
        -: 1642:        return false;
        -: 1643:    }
     8695: 1644:    return atIneq(r, getNumCols() - 1) >= 0;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    54247: 1645:  };
        -: 1646:
        -: 1647:  // Detect and mark redundant constraints.
   108494: 1648:  SmallVector<bool, 256> redunIneq(getNumInequalities(), false);
call    0 returned 100%
call    1 returned 100%
   128030: 1649:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    73783: 1650:    MPInt *rowStart = &inequalities(r, 0);
call    0 returned 100%
    73783: 1651:    auto row = ArrayRef<MPInt>(rowStart, getNumCols());
call    0 returned 100%
   139227: 1652:    if (isTriviallyValid(r) || !rowSet.insert(row).second) {
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
branch  3 taken 6% (fallthrough)
branch  4 taken 94%
    12372: 1653:      redunIneq[r] = true;
branch  0 taken 0%
branch  1 taken 100%
    12372: 1654:      continue;
        -: 1655:    }
        -: 1656:
        -: 1657:    // Among constraints that only differ in the constant term part, mark
        -: 1658:    // everything other than the one with the smallest constant term redundant.
        -: 1659:    // (eg: among i - 16j - 5 >= 0, i - 16j - 1 >=0, i - 16j - 7 >= 0, the
        -: 1660:    // former two are redundant).
   122822: 1661:    MPInt constTerm = atIneq(r, getNumCols() - 1);
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    61411: 1662:    auto rowWithoutConstTerm = ArrayRef<MPInt>(rowStart, getNumCols() - 1);
call    0 returned 100%
    61411: 1663:    const auto &ret =
    61411: 1664:        rowsWithoutConstTerm.insert({rowWithoutConstTerm, {r, constTerm}});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
    61411: 1665:    if (!ret.second) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -: 1666:      // Check if the other constraint has a higher constant term.
     1543: 1667:      auto &val = ret.first->second;
call    0 returned 100%
     3086: 1668:      if (val.second > constTerm) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 35% (fallthrough)
branch  3 taken 65%
        -: 1669:        // The stored row is redundant. Mark it so, and update with this one.
      546: 1670:        redunIneq[val.first] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      546: 1671:        val = {r, constTerm};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1672:      } else {
        -: 1673:        // The one stored makes this one redundant.
      997: 1674:        redunIneq[r] = true;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1675:      }
        -: 1676:    }
        -: 1677:  }
        -: 1678:
        -: 1679:  // Scan to get rid of all rows marked redundant, in-place.
    54247: 1680:  unsigned pos = 0;
   128030: 1681:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    73783: 1682:    if (!redunIneq[r])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 81% (fallthrough)
branch  3 taken 19%
    59868: 1683:      inequalities.copyRow(r, pos++);
call    0 returned 100%
        -: 1684:
    54247: 1685:  inequalities.resizeVertically(pos);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1686:
        -: 1687:  // TODO: consider doing this for equalities as well, but probably not worth
        -: 1688:  // the savings.
    54247: 1689:}
        -: 1690:
        -: 1691:#undef DEBUG_TYPE
        -: 1692:#define DEBUG_TYPE "fm"
        -: 1693:
        -: 1694:/// Eliminates variable at the specified position using Fourier-Motzkin
        -: 1695:/// variable elimination. This technique is exact for rational spaces but
        -: 1696:/// conservative (in "rare" cases) for integer spaces. The operation corresponds
        -: 1697:/// to a projection operation yielding the (convex) set of integer points
        -: 1698:/// contained in the rational shadow of the set. An emptiness test that relies
        -: 1699:/// on this method will guarantee emptiness, i.e., it disproves the existence of
        -: 1700:/// a solution if it says it's empty.
        -: 1701:/// If a non-null isResultIntegerExact is passed, it is set to true if the
        -: 1702:/// result is also integer exact. If it's set to false, the obtained solution
        -: 1703:/// *may* not be exact, i.e., it may contain integer points that do not have an
        -: 1704:/// integer pre-image in the original set.
        -: 1705:///
        -: 1706:/// Eg:
        -: 1707:/// j >= 0, j <= i + 1
        -: 1708:/// i >= 0, i <= N + 1
        -: 1709:/// Eliminating i yields,
        -: 1710:///   j >= 0, 0 <= N + 1, j - 1 <= N + 1
        -: 1711:///
        -: 1712:/// If darkShadow = true, this method computes the dark shadow on elimination;
        -: 1713:/// the dark shadow is a convex integer subset of the exact integer shadow. A
        -: 1714:/// non-empty dark shadow proves the existence of an integer solution. The
        -: 1715:/// elimination in such a case could however be an under-approximation, and thus
        -: 1716:/// should not be used for scanning sets or used by itself for dependence
        -: 1717:/// checking.
        -: 1718:///
        -: 1719:/// Eg: 2-d set, * represents grid points, 'o' represents a point in the set.
        -: 1720:///            ^
        -: 1721:///            |
        -: 1722:///            | * * * * o o
        -: 1723:///         i  | * * o o o o
        -: 1724:///            | o * * * * *
        -: 1725:///            --------------->
        -: 1726:///                 j ->
        -: 1727:///
        -: 1728:/// Eliminating i from this system (projecting on the j dimension):
        -: 1729:/// rational shadow / integer light shadow:  1 <= j <= 6
        -: 1730:/// dark shadow:                             3 <= j <= 6
        -: 1731:/// exact integer shadow:                    j = 1 \union  3 <= j <= 6
        -: 1732:/// holes/splinters:                         j = 2
        -: 1733:///
        -: 1734:/// darkShadow = false, isResultIntegerExact = nullptr are default values.
        -: 1735:// TODO: a slight modification to yield dark shadow version of FM (tightened),
        -: 1736:// which can prove the existence of a solution if there is one.
function _ZN4mlir10presburger15IntegerRelation23fourierMotzkinEliminateEjbPb called 18900 returned 100% blocks executed 23%
    18900: 1737:void IntegerRelation::fourierMotzkinEliminate(unsigned pos, bool darkShadow,
        -: 1738:                                              bool *isResultIntegerExact) {
   18900*: 1739:  LLVM_DEBUG(llvm::dbgs() << "FM input (eliminate pos " << pos << "):\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
   18900*: 1740:  LLVM_DEBUG(dump());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
   18900*: 1741:  assert(pos < getNumVars() && "invalid position");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   18900*: 1742:  assert(hasConsistentState());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1743:
        -: 1744:  // Check if this variable can be eliminated through a substitution.
    19124: 1745:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      448: 1746:    if (atEq(r, pos) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1747:      // Use Gaussian elimination here (since we have an equality).
    #####: 1748:      LogicalResult ret = gaussianEliminateVar(pos);
call    0 never executed
    #####: 1749:      (void)ret;
    #####: 1750:      assert(succeeded(ret) && "Gaussian elimination guaranteed to succeed");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1751:      LLVM_DEBUG(llvm::dbgs() << "FM output (through Gaussian elimination):\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####: 1752:      LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1753:      return;
        -: 1754:    }
        -: 1755:  }
        -: 1756:
        -: 1757:  // A fast linear time tightening.
    18900: 1758:  gcdTightenInequalities();
call    0 returned 100%
        -: 1759:
        -: 1760:  // Check if the variable appears at all in any of the inequalities.
    18900: 1761:  if (isColZero(pos)) {
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -: 1762:    // If it doesn't appear, just remove the column and return.
        -: 1763:    // TODO: refactor removeColumns to use it from here.
     2796: 1764:    removeVar(pos);
call    0 returned 100%
    2796*: 1765:    LLVM_DEBUG(llvm::dbgs() << "FM output:\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    2796*: 1766:    LLVM_DEBUG(dump());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
     2796: 1767:    return;
        -: 1768:  }
        -: 1769:
        -: 1770:  // Positions of constraints that are lower bounds on the variable.
    32208: 1771:  SmallVector<unsigned, 4> lbIndices;
call    0 returned 100%
call    1 returned 100%
        -: 1772:  // Positions of constraints that are lower bounds on the variable.
    16104: 1773:  SmallVector<unsigned, 4> ubIndices;
call    0 returned 100%
        -: 1774:  // Positions of constraints that do not involve the variable.
    32208: 1775:  std::vector<unsigned> nbIndices;
call    0 returned 100%
call    1 returned 100%
    16104: 1776:  nbIndices.reserve(getNumInequalities());
call    0 returned 100%
        -: 1777:
        -: 1778:  // Gather all lower bounds and upper bounds of the variable. Since the
        -: 1779:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -: 1780:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
    72029: 1781:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
   111850: 1782:    if (atIneq(r, pos) == 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 47% (fallthrough)
branch  4 taken 53%
        -: 1783:      // Var does not appear in bound.
    26329: 1784:      nbIndices.push_back(r);
call    0 returned 100%
    59192: 1785:    } else if (atIneq(r, pos) >= 1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 49% (fallthrough)
branch  4 taken 51%
        -: 1786:      // Lower bound.
    14580: 1787:      lbIndices.push_back(r);
call    0 returned 100%
        -: 1788:    } else {
        -: 1789:      // Upper bound.
    15016: 1790:      ubIndices.push_back(r);
call    0 returned 100%
        -: 1791:    }
        -: 1792:  }
        -: 1793:
    32208: 1794:  PresburgerSpace newSpace = getSpace();
call    0 returned 100%
call    1 returned 100%
    16104: 1795:  VarKind idKindRemove = newSpace.getVarKindAt(pos);
call    0 returned 100%
    16104: 1796:  unsigned relativePos = pos - newSpace.getVarKindOffset(idKindRemove);
call    0 returned 100%
    16104: 1797:  newSpace.removeVarRange(idKindRemove, relativePos, relativePos + 1);
call    0 returned 100%
        -: 1798:
        -: 1799:  /// Create the new system which has one variable less.
    16104: 1800:  IntegerRelation newRel(lbIndices.size() * ubIndices.size() + nbIndices.size(),
call    0 returned 100%
    32208: 1801:                         getNumEqualities(), getNumCols() - 1, newSpace);
call    0 returned 100%
call    1 returned 100%
        -: 1802:
        -: 1803:  // This will be used to check if the elimination was integer exact.
    16104: 1804:  bool allLCMsAreOne = true;
        -: 1805:
        -: 1806:  // Let x be the variable we are eliminating.
        -: 1807:  // For each lower bound, lb <= c_l*x, and each upper bound c_u*x <= ub, (note
        -: 1808:  // that c_l, c_u >= 1) we have:
        -: 1809:  // lb*lcm(c_l, c_u)/c_l <= lcm(c_l, c_u)*x <= ub*lcm(c_l, c_u)/c_u
        -: 1810:  // We thus generate a constraint:
        -: 1811:  // lcm(c_l, c_u)/c_l*lb <= lcm(c_l, c_u)/c_u*ub.
        -: 1812:  // Note if c_l = c_u = 1, all integer points captured by the resulting
        -: 1813:  // constraint correspond to integer points in the original system (i.e., they
        -: 1814:  // have integer pre-images). Hence, if the lcm's are all 1, the elimination is
        -: 1815:  // integer exact.
    31120: 1816:  for (auto ubPos : ubIndices) {
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
    25145: 1817:    for (auto lbPos : lbIndices) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
    10129: 1818:      SmallVector<MPInt, 4> ineq;
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
    10129: 1819:      ineq.reserve(newRel.getNumCols());
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
    20258: 1820:      MPInt lbCoeff = atIneq(lbPos, pos);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -: 1821:      // Note that in the comments above, ubCoeff is the negation of the
        -: 1822:      // coefficient in the canonical form as the view taken here is that of the
        -: 1823:      // term being moved to the other size of '>='.
    20258: 1824:      MPInt ubCoeff = -atIneq(ubPos, pos);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1825:      // TODO: refactor this loop to avoid all branches inside.
    51724: 1826:      for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
    41595: 1827:        if (l == pos)
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
    10129: 1828:          continue;
   94398*: 1829:        assert(lbCoeff >= 1 && ubCoeff >= 1 && "bounds wrongly identified");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
    62932: 1830:        MPInt lcm = presburger::lcm(lbCoeff, ubCoeff);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   125864: 1831:        ineq.push_back(atIneq(ubPos, l) * (lcm / ubCoeff) +
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
call    7 returned 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
    94398: 1832:                       atIneq(lbPos, l) * (lcm / lbCoeff));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
   62932*: 1833:        assert(lcm > 0 && "lcm should be positive!");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
    62932: 1834:        if (lcm != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 36% (fallthrough)
branch  3 taken 64%
    11289: 1835:          allLCMsAreOne = false;
        -: 1836:      }
    10129: 1837:      if (darkShadow) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1838:        // The dark shadow is a convex subset of the exact integer shadow. If
        -: 1839:        // there is a point here, it proves the existence of a solution.
    #####: 1840:        ineq[ineq.size() - 1] += lbCoeff * ubCoeff - lbCoeff - ubCoeff + 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
        -: 1841:      }
        -: 1842:      // TODO: we need to have a way to add inequalities in-place in
        -: 1843:      // IntegerRelation instead of creating and copying over.
    10129: 1844:      newRel.addInequality(ineq);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1845:    }
        -: 1846:  }
        -: 1847:
   16104*: 1848:  LLVM_DEBUG(llvm::dbgs() << "FM isResultIntegerExact: " << allLCMsAreOne
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -: 1849:                          << "\n");
    16104: 1850:  if (allLCMsAreOne && isResultIntegerExact)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1851:    *isResultIntegerExact = true;
        -: 1852:
        -: 1853:  // Copy over the constraints not involving this variable.
    42433: 1854:  for (auto nbPos : nbIndices) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
branch  2 taken 30% (fallthrough)
branch  3 taken 70%
    26329: 1855:    SmallVector<MPInt, 4> ineq;
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
    26329: 1856:    ineq.reserve(getNumCols() - 1);
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
   158729: 1857:    for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
   132400: 1858:      if (l == pos)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
    26329: 1859:        continue;
   106071: 1860:      ineq.push_back(atIneq(nbPos, l));
call    0 returned 100%
call    1 returned 100%
        -: 1861:    }
    26329: 1862:    newRel.addInequality(ineq);
call    0 returned 100%
call    1 returned 100%
        -: 1863:  }
        -: 1864:
   16104*: 1865:  assert(newRel.getNumConstraints() ==
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1866:         lbIndices.size() * ubIndices.size() + nbIndices.size());
        -: 1867:
        -: 1868:  // Copy over the equalities.
    16319: 1869:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      215: 1870:    SmallVector<MPInt, 4> eq;
call    0 returned 100%
      215: 1871:    eq.reserve(newRel.getNumCols());
call    0 returned 100%
      798: 1872:    for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
      583: 1873:      if (l == pos)
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
      215: 1874:        continue;
      368: 1875:      eq.push_back(atEq(r, l));
call    0 returned 100%
call    1 returned 100%
        -: 1876:    }
      215: 1877:    newRel.addEquality(eq);
call    0 returned 100%
call    1 returned 100%
        -: 1878:  }
        -: 1879:
        -: 1880:  // GCD tightening and normalization allows detection of more trivially
        -: 1881:  // redundant constraints.
    16104: 1882:  newRel.gcdTightenInequalities();
call    0 returned 100%
    16104: 1883:  newRel.normalizeConstraintsByGCD();
call    0 returned 100%
    16104: 1884:  newRel.removeTrivialRedundancy();
call    0 returned 100%
    16104: 1885:  clearAndCopyFrom(newRel);
call    0 returned 100%
   16104*: 1886:  LLVM_DEBUG(llvm::dbgs() << "FM output:\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
   16104*: 1887:  LLVM_DEBUG(dump());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1888:}
        -: 1889:
        -: 1890:#undef DEBUG_TYPE
        -: 1891:#define DEBUG_TYPE "presburger"
        -: 1892:
function _ZN4mlir10presburger15IntegerRelation10projectOutEjj called 37309 returned 100% blocks executed 88%
    37309: 1893:void IntegerRelation::projectOut(unsigned pos, unsigned num) {
    37309: 1894:  if (num == 0)
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -: 1895:    return;
        -: 1896:
        -: 1897:  // 'pos' can be at most getNumCols() - 2 if num > 0.
    4160*: 1898:  assert((getNumCols() < 2 || pos <= getNumCols() - 2) && "invalid position");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
    4160*: 1899:  assert(pos + num < getNumCols() && "invalid range");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1900:
        -: 1901:  // Eliminate as many variables as possible using Gaussian elimination.
        -: 1902:  unsigned currentPos = pos;
        -: 1903:  unsigned numToEliminate = num;
        -: 1904:  unsigned numGaussianEliminated = 0;
        -: 1905:
    16349: 1906:  while (currentPos < getNumVars()) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
    12189: 1907:    unsigned curNumEliminated =
    12189: 1908:        gaussianEliminateVars(currentPos, currentPos + numToEliminate);
call    0 returned 100%
    12189: 1909:    ++currentPos;
    12189: 1910:    numToEliminate -= curNumEliminated + 1;
    12189: 1911:    numGaussianEliminated += curNumEliminated;
        -: 1912:  }
        -: 1913:
        -: 1914:  // Eliminate the remaining using Fourier-Motzkin.
    14280: 1915:  for (unsigned i = 0; i < num - numGaussianEliminated; i++) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
    10120: 1916:    unsigned numToEliminate = num - numGaussianEliminated - i;
    10120: 1917:    fourierMotzkinEliminate(
call    0 returned 100%
    10120: 1918:        getBestVarToEliminate(*this, pos, pos + numToEliminate));
call    0 returned 100%
        -: 1919:  }
        -: 1920:
        -: 1921:  // Fast/trivial simplifications.
     4160: 1922:  gcdTightenInequalities();
call    0 returned 100%
        -: 1923:  // Normalize constraints after tightening since the latter impacts this, but
        -: 1924:  // not the other way round.
     4160: 1925:  normalizeConstraintsByGCD();
call    0 returned 100%
        -: 1926:}
        -: 1927:
        -: 1928:namespace {
        -: 1929:
        -: 1930:enum BoundCmpResult { Greater, Less, Equal, Unknown };
        -: 1931:
        -: 1932:/// Compares two affine bounds whose coefficients are provided in 'first' and
        -: 1933:/// 'second'. The last coefficient is the constant term.
function _ZN12_GLOBAL__N_1L13compareBoundsEN4llvm8ArrayRefIN4mlir10presburger5MPIntEEES5_ called 29620 returned 100% blocks executed 46%
    29620: 1934:static BoundCmpResult compareBounds(ArrayRef<MPInt> a, ArrayRef<MPInt> b) {
   29620*: 1935:  assert(a.size() == b.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1936:
        -: 1937:  // For the bounds to be comparable, their corresponding variable
        -: 1938:  // coefficients should be equal; the constant terms are then compared to
        -: 1939:  // determine less/greater/equal.
        -: 1940:
    29620: 1941:  if (!std::equal(a.begin(), a.end() - 1, b.begin()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -: 1942:    return Unknown;
        -: 1943:
    59236: 1944:  if (a.back() == b.back())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 84% (fallthrough)
branch  5 taken 16%
        -: 1945:    return Equal;
        -: 1946:
    49814: 1947:  return a.back() < b.back() ? Less : Greater;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
        -: 1948:}
        -: 1949:} // namespace
        -: 1950:
        -: 1951:// Returns constraints that are common to both A & B.
function _ZL20getCommonConstraintsRKN4mlir10presburger15IntegerRelationES3_RS1_ called 7318 returned 100% blocks executed 100%
     7318: 1952:static void getCommonConstraints(const IntegerRelation &a,
        -: 1953:                                 const IntegerRelation &b, IntegerRelation &c) {
     7318: 1954:  c = IntegerRelation(a.getSpace());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1955:  // a naive O(n^2) check should be enough here given the input sizes.
    18602: 1956:  for (unsigned r = 0, e = a.getNumInequalities(); r < e; ++r) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
    21616: 1957:    for (unsigned s = 0, f = b.getNumInequalities(); s < f; ++s) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
    26504: 1958:      if (a.getInequality(r) == b.getInequality(s)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 22% (fallthrough)
branch  5 taken 78%
     2920: 1959:        c.addInequality(a.getInequality(r));
call    0 returned 100%
     2920: 1960:        break;
call    0 returned 100%
        -: 1961:      }
        -: 1962:    }
        -: 1963:  }
    16741: 1964:  for (unsigned r = 0, e = a.getNumEqualities(); r < e; ++r) {
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
    29500: 1965:    for (unsigned s = 0, f = b.getNumEqualities(); s < f; ++s) {
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
    41480: 1966:      if (a.getEquality(r) == b.getEquality(s)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 3% (fallthrough)
branch  5 taken 97%
      663: 1967:        c.addEquality(a.getEquality(r));
call    0 returned 100%
      663: 1968:        break;
call    0 returned 100%
        -: 1969:      }
        -: 1970:    }
        -: 1971:  }
     7318: 1972:}
        -: 1973:
        -: 1974:// Computes the bounding box with respect to 'other' by finding the min of the
        -: 1975:// lower bounds and the max of the upper bounds along each of the dimensions.
        -: 1976:LogicalResult
function _ZN4mlir10presburger15IntegerRelation16unionBoundingBoxERKS1_ called 7318 returned 100% blocks executed 26%
     7318: 1977:IntegerRelation::unionBoundingBox(const IntegerRelation &otherCst) {
    7318*: 1978:  assert(space.isEqual(otherCst.getSpace()) && "Spaces should match.");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    7318*: 1979:  assert(getNumLocalVars() == 0 && "local ids not supported yet here");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1980:
        -: 1981:  // Get the constraints common to both systems; these will be added as is to
        -: 1982:  // the union.
    14636: 1983:  IntegerRelation commonCst(PresburgerSpace::getRelationSpace());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
     7318: 1984:  getCommonConstraints(*this, otherCst, commonCst);
call    0 returned 100%
        -: 1985:
    14636: 1986:  std::vector<SmallVector<MPInt, 8>> boundingLbs;
call    0 returned 100%
call    1 returned 100%
     7318: 1987:  std::vector<SmallVector<MPInt, 8>> boundingUbs;
call    0 returned 100%
     7318: 1988:  boundingLbs.reserve(2 * getNumDimVars());
call    0 returned 100%
     7318: 1989:  boundingUbs.reserve(2 * getNumDimVars());
call    0 returned 100%
        -: 1990:
        -: 1991:  // To hold lower and upper bounds for each dimension.
    14636: 1992:  SmallVector<MPInt, 4> lb, otherLb, ub, otherUb;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 1993:  // To compute min of lower bounds and max of upper bounds for each dimension.
    14636: 1994:  SmallVector<MPInt, 4> minLb(getNumSymbolVars() + 1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
    14636: 1995:  SmallVector<MPInt, 4> maxUb(getNumSymbolVars() + 1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -: 1996:  // To compute final new lower and upper bounds for the union.
    14636: 1997:  SmallVector<MPInt, 8> newLb(getNumCols()), newUb(getNumCols());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 returned 100%
        -: 1998:
    14636: 1999:  MPInt lbFloorDivisor, otherLbFloorDivisor;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
    22127: 2000:  for (unsigned d = 0, e = getNumDimVars(); d < e; ++d) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
    29620: 2001:    auto extent = getConstantBoundOnDimSize(d, &lb, &lbFloorDivisor, &ub);
call    0 returned 100%
    14811: 2002:    if (!extent.has_value())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2003:      // TODO: symbolic extents when necessary.
        -: 2004:      // TODO: handle union if a dimension is unbounded.
       2*: 2005:      return failure();
        -: 2006:
    14811: 2007:    auto otherExtent = otherCst.getConstantBoundOnDimSize(
    29620: 2008:        d, &otherLb, &otherLbFloorDivisor, &otherUb);
call    0 returned 100%
call    1 returned 100%
    29622: 2009:    if (!otherExtent.has_value() || lbFloorDivisor != otherLbFloorDivisor)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2010:      // TODO: symbolic extents when necessary.
       4*: 2011:      return failure();
call    0 returned 100%
call    1 returned 100%
        -: 2012:
   29622*: 2013:    assert(lbFloorDivisor > 0 && "divisor always expected to be positive");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 2014:
    14811: 2015:    auto res = compareBounds(lb, otherLb);
call    0 returned 100%
        -: 2016:    // Identify min.
    14811: 2017:    if (res == BoundCmpResult::Less || res == BoundCmpResult::Equal) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
     9045: 2018:      minLb = lb;
call    0 returned 100%
        -: 2019:      // Since the divisor is for a floordiv, we need to convert to ceildiv,
        -: 2020:      // i.e., i >= expr floordiv div <=> i >= (expr - div + 1) ceildiv div <=>
        -: 2021:      // div * i >= expr - div + 1.
    27135: 2022:      minLb.back() -= lbFloorDivisor - 1;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     5766: 2023:    } else if (res == BoundCmpResult::Greater) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     5764: 2024:      minLb = otherLb;
call    0 returned 100%
    17292: 2025:      minLb.back() -= otherLbFloorDivisor - 1;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -: 2026:    } else {
        -: 2027:      // Uncomparable - check for constant lower/upper bounds.
       2*: 2028:      auto constLb = getConstantBound(BoundType::LB, d);
call    0 returned 100%
       2*: 2029:      auto constOtherLb = otherCst.getConstantBound(BoundType::LB, d);
call    0 returned 100%
call    1 never executed
       2*: 2030:      if (!constLb.has_value() || !constOtherLb.has_value())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        2: 2031:        return failure();
call    0 returned 100%
call    1 returned 100%
    #####: 2032:      std::fill(minLb.begin(), minLb.end(), 0);
call    0 never executed
    #####: 2033:      minLb.back() = std::min(constLb.value(), constOtherLb.value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2034:    }
        -: 2035:
        -: 2036:    // Do the same for ub's but max of upper bounds. Identify max.
    14809: 2037:    auto uRes = compareBounds(ub, otherUb);
call    0 returned 100%
    14809: 2038:    if (uRes == BoundCmpResult::Greater || uRes == BoundCmpResult::Equal) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
     9007: 2039:      maxUb = ub;
call    0 returned 100%
     5802: 2040:    } else if (uRes == BoundCmpResult::Less) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     5802: 2041:      maxUb = otherUb;
call    0 returned 100%
        -: 2042:    } else {
        -: 2043:      // Uncomparable - check for constant lower/upper bounds.
    #####: 2044:      auto constUb = getConstantBound(BoundType::UB, d);
call    0 never executed
    #####: 2045:      auto constOtherUb = otherCst.getConstantBound(BoundType::UB, d);
call    0 never executed
call    1 never executed
    #####: 2046:      if (!constUb.has_value() || !constOtherUb.has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2047:        return failure();
call    0 never executed
call    1 never executed
    #####: 2048:      std::fill(maxUb.begin(), maxUb.end(), 0);
call    0 never executed
    #####: 2049:      maxUb.back() = std::max(constUb.value(), constOtherUb.value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2050:    }
        -: 2051:
    14809: 2052:    std::fill(newLb.begin(), newLb.end(), 0);
call    0 returned 100%
    14809: 2053:    std::fill(newUb.begin(), newUb.end(), 0);
call    0 returned 100%
        -: 2054:
        -: 2055:    // The divisor for lb, ub, otherLb, otherUb at this point is lbDivisor,
        -: 2056:    // and so it's the divisor for newLb and newUb as well.
    14809: 2057:    newLb[d] = lbFloorDivisor;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    44427: 2058:    newUb[d] = -lbFloorDivisor;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -: 2059:    // Copy over the symbolic part + constant term.
    14809: 2060:    std::copy(minLb.begin(), minLb.end(), newLb.begin() + getNumDimVars());
call    0 returned 100%
    14809: 2061:    std::transform(newLb.begin() + getNumDimVars(), newLb.end(),
    14809: 2062:                   newLb.begin() + getNumDimVars(), std::negate<MPInt>());
call    0 returned 100%
    14809: 2063:    std::copy(maxUb.begin(), maxUb.end(), newUb.begin() + getNumDimVars());
call    0 returned 100%
        -: 2064:
    14809: 2065:    boundingLbs.push_back(newLb);
call    0 returned 100%
    14809: 2066:    boundingUbs.push_back(newUb);
call    0 returned 100%
call    1 returned 100%
        -: 2067:  }
        -: 2068:
        -: 2069:  // Clear all constraints and add the lower/upper bounds for the bounding box.
     7316: 2070:  clearConstraints();
call    0 returned 100%
    22125: 2071:  for (unsigned d = 0, e = getNumDimVars(); d < e; ++d) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
    14809: 2072:    addInequality(boundingLbs[d]);
call    0 returned 100%
    14809: 2073:    addInequality(boundingUbs[d]);
call    0 returned 100%
        -: 2074:  }
        -: 2075:
        -: 2076:  // Add the constraints that were common to both systems.
     7316: 2077:  append(commonCst);
call    0 returned 100%
     7316: 2078:  removeTrivialRedundancy();
call    0 returned 100%
        -: 2079:
        -: 2080:  // TODO: copy over pure symbolic constraints from this and 'other' over to the
        -: 2081:  // union (since the above are just the union along dimensions); we shouldn't
        -: 2082:  // be discarding any other constraints on the symbols.
        -: 2083:
     7318: 2084:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2085:}
        -: 2086:
function _ZNK4mlir10presburger15IntegerRelation9isColZeroEj called 18900 returned 100% blocks executed 83%
    18900: 2087:bool IntegerRelation::isColZero(unsigned pos) const {
    18900: 2088:  unsigned rowPos;
    21696: 2089:  return !findConstraintWithNonZeroAt(pos, /*isEq=*/false, &rowPos) &&
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     2796: 2090:         !findConstraintWithNonZeroAt(pos, /*isEq=*/true, &rowPos);
call    0 returned 100%
        -: 2091:}
        -: 2092:
        -: 2093:/// Find positions of inequalities and equalities that do not have a coefficient
        -: 2094:/// for [pos, pos + num) variables.
function _ZL25getIndependentConstraintsRKN4mlir10presburger15IntegerRelationEjjRN4llvm15SmallVectorImplIjEES7_ called 0 returned 0% blocks executed 0%
    #####: 2095:static void getIndependentConstraints(const IntegerRelation &cst, unsigned pos,
        -: 2096:                                      unsigned num,
        -: 2097:                                      SmallVectorImpl<unsigned> &nbIneqIndices,
        -: 2098:                                      SmallVectorImpl<unsigned> &nbEqIndices) {
    #####: 2099:  assert(pos < cst.getNumVars() && "invalid start position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2100:  assert(pos + num <= cst.getNumVars() && "invalid limit");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2101:
    #####: 2102:  for (unsigned r = 0, e = cst.getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 2103:    // The bounds are to be independent of [offset, offset + num) columns.
        -: 2104:    unsigned c;
    #####: 2105:    for (c = pos; c < pos + num; ++c) {
branch  0 never executed
branch  1 never executed
    #####: 2106:      if (cst.atIneq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2107:        break;
        -: 2108:    }
    #####: 2109:    if (c == pos + num)
branch  0 never executed
branch  1 never executed
    #####: 2110:      nbIneqIndices.push_back(r);
call    0 never executed
        -: 2111:  }
        -: 2112:
    #####: 2113:  for (unsigned r = 0, e = cst.getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 2114:    // The bounds are to be independent of [offset, offset + num) columns.
        -: 2115:    unsigned c;
    #####: 2116:    for (c = pos; c < pos + num; ++c) {
branch  0 never executed
branch  1 never executed
    #####: 2117:      if (cst.atEq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2118:        break;
        -: 2119:    }
    #####: 2120:    if (c == pos + num)
branch  0 never executed
branch  1 never executed
    #####: 2121:      nbEqIndices.push_back(r);
call    0 never executed
        -: 2122:  }
    #####: 2123:}
        -: 2124:
function _ZN4mlir10presburger15IntegerRelation28removeIndependentConstraintsEjj called 0 returned 0% blocks executed 0%
    #####: 2125:void IntegerRelation::removeIndependentConstraints(unsigned pos, unsigned num) {
    #####: 2126:  assert(pos + num <= getNumVars() && "invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2127:
        -: 2128:  // Remove constraints that are independent of these variables.
    #####: 2129:  SmallVector<unsigned, 4> nbIneqIndices, nbEqIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2130:  getIndependentConstraints(*this, /*pos=*/0, num, nbIneqIndices, nbEqIndices);
call    0 never executed
        -: 2131:
        -: 2132:  // Iterate in reverse so that indices don't have to be updated.
        -: 2133:  // TODO: This method can be made more efficient (because removal of each
        -: 2134:  // inequality leads to much shifting/copying in the underlying buffer).
    #####: 2135:  for (auto nbIndex : llvm::reverse(nbIneqIndices))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2136:    removeInequality(nbIndex);
call    0 never executed
    #####: 2137:  for (auto nbIndex : llvm::reverse(nbEqIndices))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2138:    removeEquality(nbIndex);
call    0 never executed
    #####: 2139:}
        -: 2140:
function _ZNK4mlir10presburger15IntegerRelation12getDomainSetEv called 0 returned 0% blocks executed 0%
    #####: 2141:IntegerPolyhedron IntegerRelation::getDomainSet() const {
    #####: 2142:  IntegerRelation copyRel = *this;
call    0 never executed
call    1 never executed
        -: 2143:
        -: 2144:  // Convert Range variables to Local variables.
    #####: 2145:  copyRel.convertVarKind(VarKind::Range, 0, getNumVarKind(VarKind::Range),
call    0 never executed
call    1 never executed
        -: 2146:                         VarKind::Local);
        -: 2147:
        -: 2148:  // Convert Domain variables to SetDim(Range) variables.
    #####: 2149:  copyRel.convertVarKind(VarKind::Domain, 0, getNumVarKind(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2150:                         VarKind::SetDim);
        -: 2151:
    #####: 2152:  return IntegerPolyhedron(std::move(copyRel));
call    0 never executed
        -: 2153:}
        -: 2154:
function _ZNK4mlir10presburger15IntegerRelation11getRangeSetEv called 0 returned 0% blocks executed 0%
    #####: 2155:IntegerPolyhedron IntegerRelation::getRangeSet() const {
    #####: 2156:  IntegerRelation copyRel = *this;
call    0 never executed
call    1 never executed
        -: 2157:
        -: 2158:  // Convert Domain variables to Local variables.
    #####: 2159:  copyRel.convertVarKind(VarKind::Domain, 0, getNumVarKind(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2160:                         VarKind::Local);
        -: 2161:
        -: 2162:  // We do not need to do anything to Range variables since they are already in
        -: 2163:  // SetDim position.
        -: 2164:
    #####: 2165:  return IntegerPolyhedron(std::move(copyRel));
call    0 never executed
        -: 2166:}
        -: 2167:
function _ZN4mlir10presburger15IntegerRelation15intersectDomainERKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####: 2168:void IntegerRelation::intersectDomain(const IntegerPolyhedron &poly) {
    #####: 2169:  assert(getDomainSet().getSpace().isCompatible(poly.getSpace()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2170:         "Domain set is not compatible with poly");
        -: 2171:
        -: 2172:  // Treating the poly as a relation, convert it from `0 -> R` to `R -> 0`.
    #####: 2173:  IntegerRelation rel = poly;
call    0 never executed
call    1 never executed
    #####: 2174:  rel.inverse();
call    0 never executed
        -: 2175:
        -: 2176:  // Append dummy range variables to make the spaces compatible.
    #####: 2177:  rel.appendVar(VarKind::Range, getNumRangeVars());
call    0 never executed
        -: 2178:
        -: 2179:  // Intersect in place.
    #####: 2180:  mergeLocalVars(rel);
call    0 never executed
    #####: 2181:  append(rel);
call    0 never executed
    #####: 2182:}
        -: 2183:
function _ZN4mlir10presburger15IntegerRelation14intersectRangeERKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####: 2184:void IntegerRelation::intersectRange(const IntegerPolyhedron &poly) {
    #####: 2185:  assert(getRangeSet().getSpace().isCompatible(poly.getSpace()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2186:         "Range set is not compatible with poly");
        -: 2187:
    #####: 2188:  IntegerRelation rel = poly;
call    0 never executed
call    1 never executed
        -: 2189:
        -: 2190:  // Append dummy domain variables to make the spaces compatible.
    #####: 2191:  rel.appendVar(VarKind::Domain, getNumDomainVars());
call    0 never executed
        -: 2192:
    #####: 2193:  mergeLocalVars(rel);
call    0 never executed
    #####: 2194:  append(rel);
call    0 never executed
    #####: 2195:}
        -: 2196:
function _ZN4mlir10presburger15IntegerRelation7inverseEv called 0 returned 0% blocks executed 0%
    #####: 2197:void IntegerRelation::inverse() {
    #####: 2198:  unsigned numRangeVars = getNumVarKind(VarKind::Range);
call    0 never executed
    #####: 2199:  convertVarKind(VarKind::Domain, 0, getVarKindEnd(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2200:                 VarKind::Range);
    #####: 2201:  convertVarKind(VarKind::Range, 0, numRangeVars, VarKind::Domain);
call    0 never executed
    #####: 2202:}
        -: 2203:
function _ZN4mlir10presburger15IntegerRelation7composeERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2204:void IntegerRelation::compose(const IntegerRelation &rel) {
    #####: 2205:  assert(getRangeSet().getSpace().isCompatible(rel.getDomainSet().getSpace()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 2206:         "Range of `this` should be compatible with Domain of `rel`");
        -: 2207:
    #####: 2208:  IntegerRelation copyRel = rel;
call    0 never executed
call    1 never executed
        -: 2209:
        -: 2210:  // Let relation `this` be R1: A -> B, and `rel` be R2: B -> C.
        -: 2211:  // We convert R1 to A -> (B X C), and R2 to B X C then intersect the range of
        -: 2212:  // R1 with R2. After this, we get R1: A -> C, by projecting out B.
        -: 2213:  // TODO: Using nested spaces here would help, since we could directly
        -: 2214:  // intersect the range with another relation.
    #####: 2215:  unsigned numBVars = getNumRangeVars();
call    0 never executed
        -: 2216:
        -: 2217:  // Convert R1 from A -> B to A -> (B X C).
    #####: 2218:  appendVar(VarKind::Range, copyRel.getNumRangeVars());
call    0 never executed
        -: 2219:
        -: 2220:  // Convert R2 to B X C.
    #####: 2221:  copyRel.convertVarKind(VarKind::Domain, 0, numBVars, VarKind::Range, 0);
call    0 never executed
        -: 2222:
        -: 2223:  // Intersect R2 to range of R1.
    #####: 2224:  intersectRange(IntegerPolyhedron(copyRel));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2225:
        -: 2226:  // Project out B in R1.
    #####: 2227:  convertVarKind(VarKind::Range, 0, numBVars, VarKind::Local);
call    0 never executed
    #####: 2228:}
        -: 2229:
function _ZN4mlir10presburger15IntegerRelation11applyDomainERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2230:void IntegerRelation::applyDomain(const IntegerRelation &rel) {
    #####: 2231:  inverse();
call    0 never executed
    #####: 2232:  compose(rel);
call    0 never executed
    #####: 2233:  inverse();
call    0 never executed
    #####: 2234:}
        -: 2235:
function _ZN4mlir10presburger15IntegerRelation10applyRangeERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2236:void IntegerRelation::applyRange(const IntegerRelation &rel) { compose(rel); }
call    0 never executed
        -: 2237:
function _ZNK4mlir10presburger15IntegerRelation10printSpaceERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 2238:void IntegerRelation::printSpace(raw_ostream &os) const {
    #####: 2239:  space.print(os);
call    0 never executed
    #####: 2240:  os << getNumConstraints() << " constraints\n";
call    0 never executed
call    1 never executed
    #####: 2241:}
        -: 2242:
function _ZNK4mlir10presburger15IntegerRelation5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 2243:void IntegerRelation::print(raw_ostream &os) const {
    #####: 2244:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2245:  printSpace(os);
call    0 never executed
    #####: 2246:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2247:    for (unsigned j = 0, f = getNumCols(); j < f; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 2248:      os << atEq(i, j) << " ";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2249:    }
    #####: 2250:    os << "= 0\n";
call    0 never executed
        -: 2251:  }
    #####: 2252:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2253:    for (unsigned j = 0, f = getNumCols(); j < f; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 2254:      os << atIneq(i, j) << " ";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2255:    }
    #####: 2256:    os << ">= 0\n";
call    0 never executed
        -: 2257:  }
    #####: 2258:  os << '\n';
branch  0 never executed
branch  1 never executed
    #####: 2259:}
        -: 2260:
function _ZNK4mlir10presburger15IntegerRelation4dumpEv called 0 returned 0% blocks executed 0%
    #####: 2261:void IntegerRelation::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 2262:
function _ZN4mlir10presburger17IntegerPolyhedron9insertVarENS0_7VarKindEjj called 134150 returned 100% blocks executed 75%
   134150: 2263:unsigned IntegerPolyhedron::insertVar(VarKind kind, unsigned pos,
        -: 2264:                                      unsigned num) {
  134150*: 2265:  assert((kind != VarKind::Domain || num == 0) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 2266:         "Domain has to be zero in a set");
   134150: 2267:  return IntegerRelation::insertVar(kind, pos, num);
call    0 returned 100%
        -: 2268:}
        -: 2269:IntegerPolyhedron
function _ZNK4mlir10presburger17IntegerPolyhedron9intersectERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2270:IntegerPolyhedron::intersect(const IntegerPolyhedron &other) const {
    #####: 2271:  return IntegerPolyhedron(IntegerRelation::intersect(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2272:}
        -: 2273:
function _ZNK4mlir10presburger17IntegerPolyhedron8subtractERKNS0_13PresburgerSetE called 0 returned 0% blocks executed 0%
    #####: 2274:PresburgerSet IntegerPolyhedron::subtract(const PresburgerSet &other) const {
    #####: 2275:  return PresburgerSet(IntegerRelation::subtract(other));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2276:}
