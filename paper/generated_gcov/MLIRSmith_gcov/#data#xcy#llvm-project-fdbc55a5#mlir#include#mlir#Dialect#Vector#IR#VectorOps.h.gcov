        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Dialect/Vector/IR/VectorOps.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorDropLeadUnitDim.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Vector/Transforms/CMakeFiles/obj.MLIRVectorTransforms.dir/VectorDropLeadUnitDim.cpp.gcda
        -:    0:Runs:116175
        -:    1://===- VectorOps.h - MLIR Vector Dialect Operations -------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the Vector dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef MLIR_DIALECT_VECTOR_IR_VECTOROPS_H
        -:   14:#define MLIR_DIALECT_VECTOR_IR_VECTOROPS_H
        -:   15:
        -:   16:#include "mlir/Dialect/Vector/Interfaces/MaskableOpInterface.h"
        -:   17:#include "mlir/Dialect/Vector/Interfaces/MaskingOpInterface.h"
        -:   18:#include "mlir/IR/AffineMap.h"
        -:   19:#include "mlir/IR/Attributes.h"
        -:   20:#include "mlir/IR/BuiltinTypes.h"
        -:   21:#include "mlir/IR/Dialect.h"
        -:   22:#include "mlir/IR/OpDefinition.h"
        -:   23:#include "mlir/IR/PatternMatch.h"
        -:   24:#include "mlir/Interfaces/ControlFlowInterfaces.h"
        -:   25:#include "mlir/Interfaces/DestinationStyleOpInterface.h"
        -:   26:#include "mlir/Interfaces/InferTypeOpInterface.h"
        -:   27:#include "mlir/Interfaces/SideEffectInterfaces.h"
        -:   28:#include "mlir/Interfaces/VectorInterfaces.h"
        -:   29:#include "mlir/Interfaces/ViewLikeInterface.h"
        -:   30:#include "llvm/ADT/StringExtras.h"
        -:   31:
        -:   32:// Pull in all enum type definitions and utility function declarations.
        -:   33:#include "mlir/Dialect/Vector/IR/VectorOpsEnums.h.inc"
        -:   34:
        -:   35:#define GET_ATTRDEF_CLASSES
        -:   36:#include "mlir/Dialect/Vector/IR/VectorOpsAttrDefs.h.inc"
        -:   37:
        -:   38:namespace mlir {
        -:   39:class MLIRContext;
        -:   40:class RewritePatternSet;
        -:   41:
        -:   42:namespace arith {
        -:   43:enum class AtomicRMWKind : uint64_t;
        -:   44:} // namespace arith
        -:   45:
        -:   46:namespace vector {
        -:   47:class TransferReadOp;
        -:   48:class TransferWriteOp;
        -:   49:class VectorDialect;
        -:   50:
        -:   51:namespace detail {
        -:   52:struct BitmaskEnumStorage;
        -:   53:} // namespace detail
        -:   54:
        -:   55:/// Default callback to build a region with a 'vector.yield' terminator with no
        -:   56:/// arguments.
        -:   57:void buildTerminatedBody(OpBuilder &builder, Location loc);
        -:   58:
        -:   59:/// Return whether `srcType` can be broadcast to `dstVectorType` under the
        -:   60:/// semantics of the `vector.broadcast` op.
        -:   61:enum class BroadcastableToResult {
        -:   62:  Success = 0,
        -:   63:  SourceRankHigher = 1,
        -:   64:  DimensionMismatch = 2,
        -:   65:  SourceTypeNotAVector = 3
        -:   66:};
        -:   67:BroadcastableToResult
        -:   68:isBroadcastableTo(Type srcType, VectorType dstVectorType,
        -:   69:                  std::pair<int, int> *mismatchingDims = nullptr);
        -:   70:
        -:   71:/// Collect a set of vector-to-vector canonicalization patterns.
        -:   72:void populateVectorToVectorCanonicalizationPatterns(RewritePatternSet &patterns,
        -:   73:                                                    PatternBenefit benefit = 1);
        -:   74:
        -:   75:/// Collect a set of vector.shape_cast folding patterns.
        -:   76:void populateShapeCastFoldingPatterns(RewritePatternSet &patterns,
        -:   77:                                      PatternBenefit benefit = 1);
        -:   78:
        -:   79:/// Collect a set of leading one dimension removal patterns.
        -:   80:///
        -:   81:/// These patterns insert vector.shape_cast to remove leading one dimensions
        -:   82:/// to expose more canonical forms of read/write/insert/extract operations.
        -:   83:/// With them, there are more chances that we can cancel out extract-insert
        -:   84:/// pairs or forward write-read pairs.
        -:   85:void populateCastAwayVectorLeadingOneDimPatterns(RewritePatternSet &patterns,
        -:   86:                                                 PatternBenefit benefit = 1);
        -:   87:
        -:   88:/// Collect a set of one dimension removal patterns.
        -:   89:///
        -:   90:/// These patterns insert rank-reducing memref.subview ops to remove one
        -:   91:/// dimensions. With them, there are more chances that we can avoid
        -:   92:/// potentially exensive vector.shape_cast operations.
        -:   93:void populateVectorTransferDropUnitDimsPatterns(RewritePatternSet &patterns,
        -:   94:                                                PatternBenefit benefit = 1);
        -:   95:
        -:   96:/// Collect a set of patterns to flatten n-D vector transfers on contiguous
        -:   97:/// memref.
        -:   98:///
        -:   99:/// These patterns insert memref.collapse_shape + vector.shape_cast patterns
        -:  100:/// to transform multiple small n-D transfers into a larger 1-D transfer where
        -:  101:/// the memref contiguity properties allow it.
        -:  102:void populateFlattenVectorTransferPatterns(RewritePatternSet &patterns,
        -:  103:                                           PatternBenefit benefit = 1);
        -:  104:
        -:  105:/// Collect a set of patterns that bubble up/down bitcast ops.
        -:  106:///
        -:  107:/// These patterns move vector.bitcast ops to be before insert ops or after
        -:  108:/// extract ops where suitable. With them, bitcast will happen on smaller
        -:  109:/// vectors and there are more chances to share extract/insert ops.
        -:  110:void populateBubbleVectorBitCastOpPatterns(RewritePatternSet &patterns,
        -:  111:                                           PatternBenefit benefit = 1);
        -:  112:
        -:  113:/// Collect a set of transfer read/write lowering patterns.
        -:  114:///
        -:  115:/// These patterns lower transfer ops to simpler ops like `vector.load`,
        -:  116:/// `vector.store` and `vector.broadcast`. Only transfers with a transfer rank
        -:  117:/// of a most `maxTransferRank` are lowered. This is useful when combined with
        -:  118:/// VectorToSCF, which reduces the rank of vector transfer ops.
        -:  119:void populateVectorTransferLoweringPatterns(
        -:  120:    RewritePatternSet &patterns,
        -:  121:    llvm::Optional<unsigned> maxTransferRank = llvm::None,
        -:  122:    PatternBenefit benefit = 1);
        -:  123:
        -:  124:/// These patterns materialize masks for various vector ops such as transfers.
        -:  125:void populateVectorMaskMaterializationPatterns(RewritePatternSet &patterns,
        -:  126:                                               bool force32BitVectorIndices,
        -:  127:                                               PatternBenefit benefit = 1);
        -:  128:
        -:  129:/// Collects patterns to progressively lower vector.broadcast ops on high-D
        -:  130:/// vectors to low-D vector ops.
        -:  131:void populateVectorBroadcastLoweringPatterns(RewritePatternSet &patterns,
        -:  132:                                             PatternBenefit benefit = 1);
        -:  133:
        -:  134:/// Collects patterns to progressively lower vector mask ops into elementary
        -:  135:/// selection and insertion ops.
        -:  136:void populateVectorMaskOpLoweringPatterns(RewritePatternSet &patterns,
        -:  137:                                          PatternBenefit benefit = 1);
        -:  138:
        -:  139:/// Collects patterns to progressively lower vector.shape_cast ops on high-D
        -:  140:/// vectors into 1-D/2-D vector ops by generating data movement extract/insert
        -:  141:/// ops.
        -:  142:void populateVectorShapeCastLoweringPatterns(RewritePatternSet &patterns,
        -:  143:                                             PatternBenefit benefit = 1);
        -:  144:
        -:  145:/// Returns the integer type required for subscripts in the vector dialect.
        -:  146:IntegerType getVectorSubscriptType(Builder &builder);
        -:  147:
        -:  148:/// Returns an integer array attribute containing the given values using
        -:  149:/// the integer type required for subscripts in the vector dialect.
        -:  150:ArrayAttr getVectorSubscriptAttr(Builder &b, ArrayRef<int64_t> values);
        -:  151:
        -:  152:/// Returns the value obtained by reducing the vector into a scalar using the
        -:  153:/// operation kind associated with a binary AtomicRMWKind op.
        -:  154:Value getVectorReductionOp(arith::AtomicRMWKind op, OpBuilder &builder,
        -:  155:                           Location loc, Value vector);
        -:  156:
        -:  157:/// Return true if the last dimension of the MemRefType has unit stride. Also
        -:  158:/// return true for memrefs with no strides.
        -:  159:bool isLastMemrefDimUnitStride(MemRefType type);
        -:  160:
        -:  161:/// Build the default minor identity map suitable for a vector transfer. This
        -:  162:/// also handles the case memref<... x vector<...>> -> vector<...> in which the
        -:  163:/// rank of the identity map must take the vector element type into account.
        -:  164:AffineMap getTransferMinorIdentityMap(ShapedType shapedType,
        -:  165:                                      VectorType vectorType);
        -:  166:
        -:  167:/// Return true if the transfer_write fully writes the data accessed by the
        -:  168:/// transfer_read.
        -:  169:bool checkSameValueRAW(TransferWriteOp defWrite, TransferReadOp read);
        -:  170:
        -:  171:/// Return true if the write op fully over-write the priorWrite transfer_write
        -:  172:/// op.
        -:  173:bool checkSameValueWAW(TransferWriteOp write, TransferWriteOp priorWrite);
        -:  174:
        -:  175:/// Same behavior as `isDisjointTransferSet` but doesn't require the operations
        -:  176:/// to have the same tensor/memref. This allows comparing operations accessing
        -:  177:/// different tensors.
        -:  178:bool isDisjointTransferIndices(VectorTransferOpInterface transferA,
        -:  179:                               VectorTransferOpInterface transferB);
        -:  180:
        -:  181:/// Return true if we can prove that the transfer operations access disjoint
        -:  182:/// memory.
        -:  183:bool isDisjointTransferSet(VectorTransferOpInterface transferA,
        -:  184:                           VectorTransferOpInterface transferB);
        -:  185:
        -:  186:/// Return the result value of reducing two scalar/vector values with the
        -:  187:/// corresponding arith operation.
        -:  188:Value makeArithReduction(OpBuilder &b, Location loc, CombiningKind kind,
        -:  189:                         Value v1, Value v2);
        -:  190:
        -:  191:/// Returns true if `attr` has "parallel" iterator type semantics.
function _ZN4mlir6vector18isParallelIteratorENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  192:inline bool isParallelIterator(Attribute attr) {
    #####:  193:  return attr.cast<IteratorTypeAttr>().getValue() == IteratorType::parallel;
call    0 never executed
call    1 never executed
        -:  194:}
        -:  195:
        -:  196:/// Returns true if `attr` has "reduction" iterator type semantics.
        -:  197:inline bool isReductionIterator(Attribute attr) {
        -:  198:  return attr.cast<IteratorTypeAttr>().getValue() == IteratorType::reduction;
        -:  199:}
        -:  200:
        -:  201:} // namespace vector
        -:  202:} // namespace mlir
        -:  203:
        -:  204:#define GET_OP_CLASSES
        -:  205:#include "mlir/Dialect/Vector/IR/VectorOps.h.inc"
        -:  206:#include "mlir/Dialect/Vector/IR/VectorOpsDialect.h.inc"
        -:  207:
        -:  208:#endif // MLIR_DIALECT_VECTOR_IR_VECTOROPS_H
