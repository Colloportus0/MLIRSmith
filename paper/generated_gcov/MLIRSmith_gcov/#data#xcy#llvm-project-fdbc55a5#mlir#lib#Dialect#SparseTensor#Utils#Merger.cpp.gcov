        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/SparseTensor/Utils/Merger.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SparseTensor/Utils/CMakeFiles/obj.MLIRSparseTensorUtils.dir/Merger.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SparseTensor/Utils/CMakeFiles/obj.MLIRSparseTensorUtils.dir/Merger.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- Merger.cpp - Implementation of iteration lattices ------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/SparseTensor/Utils/Merger.h"
        -:   10:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   11:#include "mlir/Dialect/Complex/IR/Complex.h"
        -:   12:#include "mlir/Dialect/Math/IR/Math.h"
        -:   13:#include "mlir/Dialect/SparseTensor/IR/SparseTensor.h"
        -:   14:
        -:   15:#include "mlir/IR/Operation.h"
        -:   16:#include "llvm/Support/Debug.h"
        -:   17:
        -:   18:namespace mlir {
        -:   19:namespace sparse_tensor {
        -:   20:
        -:   21://===----------------------------------------------------------------------===//
        -:   22:// Constructors.
        -:   23://===----------------------------------------------------------------------===//
        -:   24:
function _ZN4mlir13sparse_tensor9TensorExpC2ENS0_4KindEjjNS_5ValueEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:   25:TensorExp::TensorExp(Kind k, unsigned x, unsigned y, Value v, Operation *o)
    #####:   26:    : kind(k), val(v), op(o) {
    #####:   27:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:   28:  // Leaf.
    #####:   29:  case kTensor:
    #####:   30:    assert(x != -1u && y == -1u && !v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   31:    tensor = x;
    #####:   32:    break;
    #####:   33:  case kInvariant:
    #####:   34:    assert(x == -1u && y == -1u && v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:   35:    break;
    #####:   36:  case kIndex:
    #####:   37:    assert(x != -1u && y == -1u && !v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   38:    index = x;
    #####:   39:    break;
        -:   40:  // Unary operations.
    #####:   41:  case kAbsF:
    #####:   42:  case kAbsC:
    #####:   43:  case kAbsI:
    #####:   44:  case kCeilF:
    #####:   45:  case kFloorF:
    #####:   46:  case kSqrtF:
    #####:   47:  case kSqrtC:
    #####:   48:  case kExpm1F:
    #####:   49:  case kExpm1C:
    #####:   50:  case kLog1pF:
    #####:   51:  case kLog1pC:
    #####:   52:  case kSinF:
    #####:   53:  case kSinC:
    #####:   54:  case kTanhF:
    #####:   55:  case kTanhC:
    #####:   56:  case kNegF:
    #####:   57:  case kNegC:
    #####:   58:  case kNegI:
    #####:   59:  case kCIm:
    #####:   60:  case kCRe:
    #####:   61:    assert(x != -1u && y == -1u && !v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   62:    children.e0 = x;
    #####:   63:    children.e1 = y;
    #####:   64:    break;
    #####:   65:  case kTruncF:
    #####:   66:  case kExtF:
    #####:   67:  case kCastFS:
    #####:   68:  case kCastFU:
    #####:   69:  case kCastSF:
    #####:   70:  case kCastUF:
    #####:   71:  case kCastS:
    #####:   72:  case kCastU:
    #####:   73:  case kCastIdx:
    #####:   74:  case kTruncI:
    #####:   75:  case kBitCast:
    #####:   76:    assert(x != -1u && y == -1u && v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   77:    children.e0 = x;
    #####:   78:    children.e1 = y;
    #####:   79:    break;
    #####:   80:  case kBinaryBranch:
    #####:   81:  case kSelect:
    #####:   82:    assert(x != -1u && y == -1u && !v && o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   83:    children.e0 = x;
    #####:   84:    children.e1 = y;
    #####:   85:    break;
    #####:   86:  case kUnary:
        -:   87:    // No assertion on y can be made, as the branching paths involve both
        -:   88:    // a unary (mapSet) and binary (takeDisj) pathway.
    #####:   89:    assert(x != -1u && !v && o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:   90:    children.e0 = x;
    #####:   91:    children.e1 = y;
    #####:   92:    break;
        -:   93:  // Binary operations.
    #####:   94:  case kMulF:
    #####:   95:  case kMulC:
    #####:   96:  case kMulI:
    #####:   97:  case kDivF:
    #####:   98:  case kDivC:
    #####:   99:  case kDivS:
    #####:  100:  case kDivU:
    #####:  101:  case kAddF:
    #####:  102:  case kAddC:
    #####:  103:  case kAddI:
    #####:  104:  case kSubF:
    #####:  105:  case kSubC:
    #####:  106:  case kSubI:
    #####:  107:  case kAndI:
    #####:  108:  case kOrI:
    #####:  109:  case kXorI:
    #####:  110:  case kShrS:
    #####:  111:  case kShrU:
    #####:  112:  case kShlI:
    #####:  113:    assert(x != -1u && y != -1u && !v && !o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  114:    children.e0 = x;
    #####:  115:    children.e1 = y;
    #####:  116:    break;
    #####:  117:  case kBinary:
    #####:  118:  case kReduce:
    #####:  119:    assert(x != -1u && y != -1u && !v && o);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  120:    children.e0 = x;
    #####:  121:    children.e1 = y;
    #####:  122:    break;
        -:  123:  }
    #####:  124:}
        -:  125:
function _ZN4mlir13sparse_tensor8LatPointC2Ejjj called 0 returned 0% blocks executed 0%
    #####:  126:LatPoint::LatPoint(unsigned n, unsigned e, unsigned b)
    #####:  127:    : bits(n, false), exp(e) {
call    0 never executed
call    1 never executed
    #####:  128:  bits.set(b);
call    0 never executed
    #####:  129:}
        -:  130:
function _ZN4mlir13sparse_tensor8LatPointC2ERKN4llvm9BitVectorEj called 0 returned 0% blocks executed 0%
    #####:  131:LatPoint::LatPoint(const BitVector &b, unsigned e) : bits(b), exp(e) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  132:
        -:  133://===----------------------------------------------------------------------===//
        -:  134:// Lattice methods.
        -:  135://===----------------------------------------------------------------------===//
        -:  136:
function _ZN4mlir13sparse_tensor6Merger6addExpENS0_4KindEjjNS_5ValueEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  137:unsigned Merger::addExp(Kind k, unsigned e0, unsigned e1, Value v,
        -:  138:                        Operation *op) {
    #####:  139:  unsigned e = tensorExps.size();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
    #####:  140:  tensorExps.push_back(TensorExp(k, e0, e1, v, op));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
    #####:  141:  return e;
        -:  142:}
        -:  143:
function _ZN4mlir13sparse_tensor6Merger6addLatEjjj called 0 returned 0% blocks executed 0%
    #####:  144:unsigned Merger::addLat(unsigned t, unsigned i, unsigned e) {
    #####:  145:  assert(t < numTensors && i < numLoops);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  146:  unsigned p = latPoints.size();
call    0 never executed
    #####:  147:  latPoints.push_back(LatPoint(numLoops * numTensors, e, numTensors * i + t));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  148:  return p;
        -:  149:}
        -:  150:
function _ZN4mlir13sparse_tensor6Merger6addSetEv called 0 returned 0% blocks executed 0%
    #####:  151:unsigned Merger::addSet() {
    #####:  152:  unsigned s = latSets.size();
call    0 never executed
    #####:  153:  latSets.emplace_back(SmallVector<unsigned, 16>());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  154:  return s;
        -:  155:}
        -:  156:
function _ZN4mlir13sparse_tensor6Merger12conjLatPointENS0_4KindEjjPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  157:unsigned Merger::conjLatPoint(Kind kind, unsigned p0, unsigned p1,
        -:  158:                              Operation *op) {
    #####:  159:  unsigned p = latPoints.size();
branch  0 never executed
branch  1 never executed
    #####:  160:  BitVector nb = BitVector(latPoints[p0].bits);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  161:  nb |= latPoints[p1].bits;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  162:  unsigned e = addExp(kind, latPoints[p0].exp, latPoints[p1].exp, Value(), op);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  163:  latPoints.push_back(LatPoint(nb, e));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  164:  return p;
branch  0 never executed
branch  1 never executed
        -:  165:}
        -:  166:
function _ZN4mlir13sparse_tensor6Merger8takeConjENS0_4KindEjjPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  167:unsigned Merger::takeConj(Kind kind, unsigned s0, unsigned s1, Operation *op) {
    #####:  168:  unsigned s = addSet();
call    0 never executed
    #####:  169:  for (unsigned p0 : latSets[s0])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  170:    for (unsigned p1 : latSets[s1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  171:      latSets[s].push_back(conjLatPoint(kind, p0, p1, op));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  172:  return s;
        -:  173:}
        -:  174:
function _ZN4mlir13sparse_tensor6Merger8takeDisjENS0_4KindEjjPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  175:unsigned Merger::takeDisj(Kind kind, unsigned s0, unsigned s1, Operation *op) {
    #####:  176:  unsigned s = takeConj(kind, s0, s1, op);
call    0 never executed
        -:  177:  // Followed by all in s0.
    #####:  178:  for (unsigned p : latSets[s0])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  179:    latSets[s].push_back(p);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  180:  // Map binary 0-y to unary -y.
        -:  181:  // TODO: move this if-else logic into buildLattices
    #####:  182:  if (kind == kSubF)
branch  0 never executed
branch  1 never executed
    #####:  183:    s1 = mapSet(kNegF, s1);
call    0 never executed
    #####:  184:  else if (kind == kSubC)
branch  0 never executed
branch  1 never executed
    #####:  185:    s1 = mapSet(kNegC, s1);
call    0 never executed
    #####:  186:  else if (kind == kSubI)
branch  0 never executed
branch  1 never executed
    #####:  187:    s1 = mapSet(kNegI, s1);
call    0 never executed
        -:  188:  // Followed by all in s1.
    #####:  189:  for (unsigned p : latSets[s1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  190:    latSets[s].push_back(p);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  191:  return s;
        -:  192:}
        -:  193:
function _ZN4mlir13sparse_tensor6Merger9takeCombiENS0_4KindEjjPNS_9OperationEbS2_S4_bS2_S4_ called 0 returned 0% blocks executed 0%
    #####:  194:unsigned Merger::takeCombi(Kind kind, unsigned s0, unsigned s1, Operation *orig,
        -:  195:                           bool includeLeft, Kind ltrans, Operation *opleft,
        -:  196:                           bool includeRight, Kind rtrans, Operation *opright) {
    #####:  197:  unsigned s = takeConj(kind, s0, s1, orig);
call    0 never executed
        -:  198:  // Left Region.
    #####:  199:  if (includeLeft) {
branch  0 never executed
branch  1 never executed
    #####:  200:    if (opleft)
branch  0 never executed
branch  1 never executed
    #####:  201:      s0 = mapSet(ltrans, s0, Value(), opleft);
call    0 never executed
    #####:  202:    for (unsigned p : latSets[s0])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  203:      latSets[s].push_back(p);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  204:  }
        -:  205:  // Right Region.
    #####:  206:  if (includeRight) {
branch  0 never executed
branch  1 never executed
    #####:  207:    if (opright)
branch  0 never executed
branch  1 never executed
    #####:  208:      s1 = mapSet(rtrans, s1, Value(), opright);
call    0 never executed
    #####:  209:    for (unsigned p : latSets[s1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  210:      latSets[s].push_back(p);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  211:  }
    #####:  212:  return s;
        -:  213:}
        -:  214:
function _ZN4mlir13sparse_tensor6Merger6mapSetENS0_4KindEjNS_5ValueEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  215:unsigned Merger::mapSet(Kind kind, unsigned s0, Value v, Operation *op) {
    #####:  216:  assert(kAbsF <= kind && kind <= kSelect);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  217:  unsigned s = addSet();
call    0 never executed
    #####:  218:  for (unsigned p : latSets[s0]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  219:    unsigned e = addExp(kind, latPoints[p].exp, v, op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  220:    latPoints.push_back(LatPoint(latPoints[p].bits, e));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  221:    latSets[s].push_back(latPoints.size() - 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  222:  }
    #####:  223:  return s;
        -:  224:}
        -:  225:
function _ZN4mlir13sparse_tensor6Merger11optimizeSetEj called 0 returned 0% blocks executed 0%
    #####:  226:unsigned Merger::optimizeSet(unsigned s0) {
    #####:  227:  unsigned s = addSet();
call    0 never executed
    #####:  228:  assert(!latSets[s0].empty());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  229:  unsigned p0 = latSets[s0][0];
    #####:  230:  for (unsigned p1 : latSets[s0]) {
branch  0 never executed
branch  1 never executed
    #####:  231:    bool add = true;
    #####:  232:    if (p0 != p1) {
branch  0 never executed
branch  1 never executed
        -:  233:      // Is this a straightforward copy?
    #####:  234:      unsigned e = latPoints[p1].exp;
branch  0 never executed
branch  1 never executed
    #####:  235:      if (tensorExps[e].kind == kTensor && tensorExps[e].tensor == outTensor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  236:        continue;
        -:  237:      // Conjunction already covered?
    #####:  238:      for (unsigned p2 : latSets[s]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  239:        assert(!latGT(p1, p2)); // Lj => Li would be bad
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  240:        if (onlyDenseDiff(p2, p1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  241:          add = false;
        -:  242:          break;
        -:  243:        }
        -:  244:      }
    #####:  245:      assert(!add || latGT(p0, p1));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  246:    }
    #####:  247:    if (add)
branch  0 never executed
branch  1 never executed
    #####:  248:      latSets[s].push_back(p1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  249:  }
    #####:  250:  for (unsigned p : latSets[s])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  251:    latPoints[p].simple = simplifyCond(s, p);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  252:  return s;
        -:  253:}
        -:  254:
function _ZN4mlir13sparse_tensor6Merger12simplifyCondEjj called 0 returned 0% blocks executed 0%
    #####:  255:BitVector Merger::simplifyCond(unsigned s0, unsigned p0) {
        -:  256:  // First determine if this lattice point is a *singleton*, i.e.,
        -:  257:  // the last point in a lattice, no other is less than this one.
    #####:  258:  bool isSingleton = true;
    #####:  259:  for (unsigned p1 : latSets[s0]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  260:    if (p0 != p1 && latGT(p0, p1)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  261:      isSingleton = false;
        -:  262:      break;
        -:  263:    }
        -:  264:  }
        -:  265:
    #####:  266:  BitVector simple = latPoints[p0].bits;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  267:  bool reset = isSingleton && hasAnySparse(simple);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  268:  unsigned be = simple.size();
branch  0 never executed
branch  1 never executed
    #####:  269:  unsigned offset = 0; // relative to the end
    #####:  270:  if (!reset)
branch  0 never executed
branch  1 never executed
        -:  271:    // Starts resetting from a dense dimension, so that the first bit (if kept)
        -:  272:    // is not undefined dimension type.
    #####:  273:    for (unsigned b = 0; b < be; b++) {
branch  0 never executed
branch  1 never executed
    #####:  274:      if (simple[b] && isDenseDLT(getDimLevelType(b))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  275:        offset = be - b - 1; // relative to the end
    #####:  276:        break;
        -:  277:      }
        -:  278:    }
        -:  279:
        -:  280:  // Now apply the two basic rules. We also iterate the bits reversely to always
        -:  281:  // keep the rightmost bit (which could possibly be a synthetic tensor).
    #####:  282:  for (unsigned b = be - 1 - offset, i = 0; i < be;
branch  0 never executed
branch  1 never executed
    #####:  283:       b = b == 0 ? be - 1 : b - 1, i++) {
branch  0 never executed
branch  1 never executed
    #####:  284:    if (simple[b] && (!isCompressedDLT(getDimLevelType(b)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  285:                      !isSingletonDLT(getDimLevelType(b)))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  286:      if (reset)
branch  0 never executed
branch  1 never executed
    #####:  287:        simple.reset(b);
call    0 never executed
        -:  288:      reset = true;
        -:  289:    }
        -:  290:  }
    #####:  291:  return simple;
        -:  292:}
        -:  293:
function _ZNK4mlir13sparse_tensor6Merger5latGTEjj called 0 returned 0% blocks executed 0%
    #####:  294:bool Merger::latGT(unsigned i, unsigned j) const {
    #####:  295:  const BitVector &bitsi = latPoints[i].bits;
branch  0 never executed
branch  1 never executed
    #####:  296:  const BitVector &bitsj = latPoints[j].bits;
branch  0 never executed
branch  1 never executed
    #####:  297:  assert(bitsi.size() == bitsj.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  298:  if (bitsi.count() > bitsj.count()) {
branch  0 never executed
branch  1 never executed
    #####:  299:    for (unsigned b = 0, be = bitsj.size(); b < be; b++)
branch  0 never executed
branch  1 never executed
    #####:  300:      if (bitsj[b] && !bitsi[b])
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  301:        return false;
        -:  302:    return true;
        -:  303:  }
        -:  304:  return false;
        -:  305:}
        -:  306:
function _ZN4mlir13sparse_tensor6Merger13onlyDenseDiffEjj called 0 returned 0% blocks executed 0%
    #####:  307:bool Merger::onlyDenseDiff(unsigned i, unsigned j) {
    #####:  308:  BitVector tmp = latPoints[j].bits;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  309:  tmp ^= latPoints[i].bits;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  310:  return !hasAnySparse(tmp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  311:}
        -:  312:
function _ZNK4mlir13sparse_tensor6Merger17isSingleConditionEjj called 0 returned 0% blocks executed 0%
    #####:  313:bool Merger::isSingleCondition(unsigned t, unsigned e) const {
    #####:  314:  switch (tensorExps[e].kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  315:  // Leaf.
    #####:  316:  case kTensor:
    #####:  317:    return tensorExps[e].tensor == t;
        -:  318:  case kInvariant:
        -:  319:  case kIndex:
        -:  320:    return false;
        -:  321:  // Unary operations.
    #####:  322:  case kAbsF:
    #####:  323:  case kAbsC:
    #####:  324:  case kAbsI:
    #####:  325:  case kCeilF:
    #####:  326:  case kFloorF:
    #####:  327:  case kSqrtF:
    #####:  328:  case kSqrtC:
    #####:  329:  case kExpm1F:
    #####:  330:  case kExpm1C:
    #####:  331:  case kLog1pF:
    #####:  332:  case kLog1pC:
    #####:  333:  case kSinF:
    #####:  334:  case kSinC:
    #####:  335:  case kTanhF:
    #####:  336:  case kTanhC:
    #####:  337:  case kNegF:
    #####:  338:  case kNegC:
    #####:  339:  case kNegI:
    #####:  340:  case kTruncF:
    #####:  341:  case kExtF:
    #####:  342:  case kCastFS:
    #####:  343:  case kCastFU:
    #####:  344:  case kCastSF:
    #####:  345:  case kCastUF:
    #####:  346:  case kCastS:
    #####:  347:  case kCastU:
    #####:  348:  case kCastIdx:
    #####:  349:  case kTruncI:
    #####:  350:  case kCIm:
    #####:  351:  case kCRe:
    #####:  352:  case kBitCast:
    #####:  353:    return isSingleCondition(t, tensorExps[e].children.e0);
        -:  354:  case kBinaryBranch:
        -:  355:  case kUnary:
        -:  356:  case kSelect:
        -:  357:    return false;
        -:  358:  // Binary operations.
    #####:  359:  case kDivF: // note: x / c only
    #####:  360:  case kDivC:
    #####:  361:  case kDivS:
    #####:  362:  case kDivU:
    #####:  363:    assert(!maybeZero(tensorExps[e].children.e1));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  364:    return isSingleCondition(t, tensorExps[e].children.e0);
branch  0 never executed
branch  1 never executed
    #####:  365:  case kShrS: // note: x >> inv only
    #####:  366:  case kShrU:
    #####:  367:  case kShlI:
    #####:  368:    assert(isInvariant(tensorExps[e].children.e1));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  369:    return isSingleCondition(t, tensorExps[e].children.e0);
    #####:  370:  case kMulF:
    #####:  371:  case kMulC:
    #####:  372:  case kMulI:
    #####:  373:  case kAndI:
    #####:  374:    if (isSingleCondition(t, tensorExps[e].children.e0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  375:      return isSingleCondition(t, tensorExps[e].children.e1) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  376:             isInvariant(tensorExps[e].children.e1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  377:    if (isSingleCondition(t, tensorExps[e].children.e1))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  378:      return isInvariant(tensorExps[e].children.e0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  379:    return false;
    #####:  380:  case kAddF:
    #####:  381:  case kAddC:
    #####:  382:  case kAddI:
    #####:  383:    return isSingleCondition(t, tensorExps[e].children.e0) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  384:           isSingleCondition(t, tensorExps[e].children.e1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  385:  case kSubF:
        -:  386:  case kSubC:
        -:  387:  case kSubI:
        -:  388:  case kOrI:
        -:  389:  case kXorI:
        -:  390:  case kBinary:
        -:  391:  case kReduce:
        -:  392:    return false;
        -:  393:  }
    #####:  394:  llvm_unreachable("unexpected kind");
call    0 never executed
        -:  395:}
        -:  396:
function _ZNK4mlir13sparse_tensor6Merger12hasAnySparseERKN4llvm9BitVectorE called 0 returned 0% blocks executed 0%
    #####:  397:bool Merger::hasAnySparse(const BitVector &bits) const {
    #####:  398:  for (unsigned b = 0, be = bits.size(); b < be; b++)
branch  0 never executed
branch  1 never executed
    #####:  399:    if (bits[b] && (isCompressedDLT(getDimLevelType(b)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  400:                    isSingletonDLT(getDimLevelType(b))))
branch  0 never executed
branch  1 never executed
        -:  401:      return true;
        -:  402:  return false;
        -:  403:}
        -:  404:
        -:  405:#ifndef NDEBUG
        -:  406:
        -:  407://===----------------------------------------------------------------------===//
        -:  408:// Print methods (for debugging).
        -:  409://===----------------------------------------------------------------------===//
        -:  410:
function _ZN4mlir13sparse_tensorL14kindToOpSymbolENS0_4KindE called 0 returned 0% blocks executed 0%
    #####:  411:static const char *kindToOpSymbol(Kind kind) {
    #####:  412:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
        -:  413:  // Leaf.
        -:  414:  case kTensor:
        -:  415:    return "tensor";
    #####:  416:  case kInvariant:
    #####:  417:    return "invariant";
    #####:  418:  case kIndex:
    #####:  419:    return "index";
        -:  420:  // Unary operations.
    #####:  421:  case kAbsF:
    #####:  422:  case kAbsC:
    #####:  423:  case kAbsI:
    #####:  424:    return "abs";
    #####:  425:  case kCeilF:
    #####:  426:    return "ceil";
    #####:  427:  case kFloorF:
    #####:  428:    return "floor";
    #####:  429:  case kSqrtF:
    #####:  430:  case kSqrtC:
    #####:  431:    return "sqrt";
    #####:  432:  case kExpm1F:
    #####:  433:  case kExpm1C:
    #####:  434:    return "expm1";
    #####:  435:  case kLog1pF:
    #####:  436:  case kLog1pC:
    #####:  437:    return "log1p";
    #####:  438:  case kSinF:
    #####:  439:  case kSinC:
    #####:  440:    return "sin";
    #####:  441:  case kTanhF:
    #####:  442:  case kTanhC:
    #####:  443:    return "tanh";
    #####:  444:  case kNegF:
    #####:  445:  case kNegC:
    #####:  446:  case kNegI:
    #####:  447:    return "-";
    #####:  448:  case kTruncF:
    #####:  449:  case kExtF:
    #####:  450:  case kCastFS:
    #####:  451:  case kCastFU:
    #####:  452:  case kCastSF:
    #####:  453:  case kCastUF:
    #####:  454:  case kCastS:
    #####:  455:  case kCastU:
    #####:  456:  case kCastIdx:
    #####:  457:  case kTruncI:
    #####:  458:  case kCIm:
    #####:  459:    return "complex.im";
    #####:  460:  case kCRe:
    #####:  461:    return "complex.re";
    #####:  462:  case kBitCast:
    #####:  463:    return "cast";
    #####:  464:  case kBinaryBranch:
    #####:  465:    return "binary_branch";
    #####:  466:  case kUnary:
    #####:  467:    return "unary";
    #####:  468:  case kSelect:
    #####:  469:    return "select";
        -:  470:  // Binary operations.
    #####:  471:  case kMulF:
    #####:  472:  case kMulC:
    #####:  473:  case kMulI:
    #####:  474:    return "*";
    #####:  475:  case kDivF:
    #####:  476:  case kDivC:
    #####:  477:  case kDivS:
    #####:  478:  case kDivU:
    #####:  479:    return "/";
    #####:  480:  case kAddF:
    #####:  481:  case kAddC:
    #####:  482:  case kAddI:
    #####:  483:    return "+";
    #####:  484:  case kSubF:
    #####:  485:  case kSubC:
    #####:  486:  case kSubI:
    #####:  487:    return "-";
    #####:  488:  case kAndI:
    #####:  489:    return "&";
    #####:  490:  case kOrI:
    #####:  491:    return "|";
    #####:  492:  case kXorI:
    #####:  493:    return "^";
    #####:  494:  case kShrS:
    #####:  495:    return "a>>";
    #####:  496:  case kShrU:
    #####:  497:    return ">>";
    #####:  498:  case kShlI:
    #####:  499:    return "<<";
    #####:  500:  case kBinary:
    #####:  501:    return "binary";
    #####:  502:  case kReduce:
    #####:  503:    return "reduce";
        -:  504:  }
    #####:  505:  llvm_unreachable("unexpected kind for symbol");
call    0 never executed
        -:  506:}
        -:  507:
function _ZNK4mlir13sparse_tensor6Merger7dumpExpEj called 0 returned 0% blocks executed 0%
    #####:  508:void Merger::dumpExp(unsigned e) const {
    #####:  509:  switch (tensorExps[e].kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  510:  // Leaf.
    #####:  511:  case kTensor:
    #####:  512:    if (tensorExps[e].tensor == syntheticTensor)
branch  0 never executed
branch  1 never executed
    #####:  513:      llvm::dbgs() << "synthetic_";
call    0 never executed
call    1 never executed
    #####:  514:    else if (tensorExps[e].tensor == outTensor)
branch  0 never executed
branch  1 never executed
    #####:  515:      llvm::dbgs() << "output_";
call    0 never executed
call    1 never executed
    #####:  516:    llvm::dbgs() << "tensor_" << tensorExps[e].tensor;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  517:    break;
    #####:  518:  case kInvariant:
    #####:  519:    llvm::dbgs() << "invariant";
call    0 never executed
    #####:  520:    break;
call    0 never executed
    #####:  521:  case kIndex:
    #####:  522:    llvm::dbgs() << "index_" << tensorExps[e].index;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  523:    break;
        -:  524:  // Unary operations.
    #####:  525:  case kAbsF:
    #####:  526:  case kAbsC:
    #####:  527:  case kAbsI:
    #####:  528:  case kCeilF:
    #####:  529:  case kFloorF:
    #####:  530:  case kSqrtF:
    #####:  531:  case kSqrtC:
    #####:  532:  case kExpm1F:
    #####:  533:  case kExpm1C:
    #####:  534:  case kLog1pF:
    #####:  535:  case kLog1pC:
    #####:  536:  case kSinF:
    #####:  537:  case kSinC:
    #####:  538:  case kTanhF:
    #####:  539:  case kTanhC:
    #####:  540:  case kNegF:
    #####:  541:  case kNegC:
    #####:  542:  case kNegI:
    #####:  543:  case kTruncF:
    #####:  544:  case kExtF:
    #####:  545:  case kCastFS:
    #####:  546:  case kCastFU:
    #####:  547:  case kCastSF:
    #####:  548:  case kCastUF:
    #####:  549:  case kCastS:
    #####:  550:  case kCastU:
    #####:  551:  case kCastIdx:
    #####:  552:  case kTruncI:
    #####:  553:  case kCIm:
    #####:  554:  case kCRe:
    #####:  555:  case kBitCast:
    #####:  556:  case kBinaryBranch:
    #####:  557:  case kUnary:
    #####:  558:  case kSelect:
    #####:  559:    llvm::dbgs() << kindToOpSymbol(tensorExps[e].kind) << " ";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  560:    dumpExp(tensorExps[e].children.e0);
branch  0 never executed
branch  1 never executed
    #####:  561:    break;
        -:  562:  // Binary operations.
    #####:  563:  case kMulF:
    #####:  564:  case kMulC:
    #####:  565:  case kMulI:
    #####:  566:  case kDivF:
    #####:  567:  case kDivC:
    #####:  568:  case kDivS:
    #####:  569:  case kDivU:
    #####:  570:  case kAddF:
    #####:  571:  case kAddC:
    #####:  572:  case kAddI:
    #####:  573:  case kSubF:
    #####:  574:  case kSubC:
    #####:  575:  case kSubI:
    #####:  576:  case kAndI:
    #####:  577:  case kOrI:
    #####:  578:  case kXorI:
    #####:  579:  case kShrS:
    #####:  580:  case kShrU:
    #####:  581:  case kShlI:
    #####:  582:  case kBinary:
    #####:  583:  case kReduce:
    #####:  584:    llvm::dbgs() << "(";
call    0 never executed
call    1 never executed
    #####:  585:    dumpExp(tensorExps[e].children.e0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  586:    llvm::dbgs() << " " << kindToOpSymbol(tensorExps[e].kind) << " ";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  587:    dumpExp(tensorExps[e].children.e1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  588:    llvm::dbgs() << ")";
call    0 never executed
call    1 never executed
        -:  589:  }
    #####:  590:}
        -:  591:
function _ZNK4mlir13sparse_tensor6Merger7dumpLatEj called 0 returned 0% blocks executed 0%
    #####:  592:void Merger::dumpLat(unsigned p) const {
    #####:  593:  llvm::dbgs() << "lat(";
call    0 never executed
call    1 never executed
    #####:  594:  dumpBits(latPoints[p].bits);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  595:  llvm::dbgs() << " :";
call    0 never executed
call    1 never executed
    #####:  596:  dumpBits(latPoints[p].simple);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  597:  llvm::dbgs() << " : ";
call    0 never executed
call    1 never executed
    #####:  598:  dumpExp(latPoints[p].exp);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  599:  llvm::dbgs() << " )\n";
call    0 never executed
call    1 never executed
    #####:  600:}
        -:  601:
function _ZNK4mlir13sparse_tensor6Merger7dumpSetEj called 0 returned 0% blocks executed 0%
    #####:  602:void Merger::dumpSet(unsigned s) const {
    #####:  603:  llvm::dbgs() << "{ #" << latSets[s].size() << "\n";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  604:  for (unsigned p : latSets[s]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  605:    llvm::dbgs() << "  ";
call    0 never executed
call    1 never executed
    #####:  606:    dumpLat(p);
call    0 never executed
        -:  607:  }
    #####:  608:  llvm::dbgs() << "}\n";
call    0 never executed
call    1 never executed
    #####:  609:}
        -:  610:
function _ZNK4mlir13sparse_tensor6Merger8dumpBitsERKN4llvm9BitVectorE called 0 returned 0% blocks executed 0%
    #####:  611:void Merger::dumpBits(const BitVector &bits) const {
    #####:  612:  for (unsigned b = 0, be = bits.size(); b < be; b++) {
branch  0 never executed
branch  1 never executed
    #####:  613:    if (bits[b]) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  614:      unsigned t = tensor(b);
call    0 never executed
    #####:  615:      unsigned i = index(b);
call    0 never executed
    #####:  616:      DimLevelType dlt = dimTypes[t][i];
call    0 never executed
    #####:  617:      llvm::dbgs() << " i_" << t << "_" << i << "_";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  618:      if (isDenseDLT(dlt))
branch  0 never executed
branch  1 never executed
    #####:  619:        llvm::dbgs() << "D";
call    0 never executed
call    1 never executed
    #####:  620:      else if (isCompressedDLT(dlt))
branch  0 never executed
branch  1 never executed
    #####:  621:        llvm::dbgs() << "C";
call    0 never executed
call    1 never executed
    #####:  622:      else if (isSingletonDLT(dlt))
branch  0 never executed
branch  1 never executed
    #####:  623:        llvm::dbgs() << "S";
call    0 never executed
call    1 never executed
    #####:  624:      else if (isUndefDLT(dlt))
branch  0 never executed
branch  1 never executed
    #####:  625:        llvm::dbgs() << "U";
call    0 never executed
call    1 never executed
    #####:  626:      llvm::dbgs() << "[O=" << isOrderedDLT(dlt) << ",U=" << isUniqueDLT(dlt)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  627:                   << "]";
call    0 never executed
        -:  628:    }
        -:  629:  }
    #####:  630:}
        -:  631:
        -:  632:#endif // NDEBUG
        -:  633:
        -:  634://===----------------------------------------------------------------------===//
        -:  635:// Builder methods.
        -:  636://===----------------------------------------------------------------------===//
        -:  637:
function _ZN4mlir13sparse_tensor6Merger13buildLatticesEjj called 0 returned 0% blocks executed 0%
    #####:  638:unsigned Merger::buildLattices(unsigned e, unsigned i) {
    #####:  639:  Kind kind = tensorExps[e].kind;
branch  0 never executed
branch  1 never executed
    #####:  640:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -:  641:  // Leaf.
    #####:  642:  case kTensor:
    #####:  643:  case kInvariant:
    #####:  644:  case kIndex: {
        -:  645:    // Either the index is really used in the tensor expression, or it is
        -:  646:    // set to the undefined index in that dimension. An invariant expression,
        -:  647:    // a proper index value, and a truly dynamic sparse output tensor are set
        -:  648:    // to a synthetic tensor with undefined indices only to ensure the
        -:  649:    // iteration space is not skipped as a result of their contents.
    #####:  650:    unsigned s = addSet();
call    0 never executed
    #####:  651:    unsigned t = syntheticTensor;
    #####:  652:    if (kind == kTensor) {
branch  0 never executed
branch  1 never executed
    #####:  653:      t = tensorExps[e].tensor;
branch  0 never executed
branch  1 never executed
    #####:  654:      if (hasSparseOut && t == outTensor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  655:        t = syntheticTensor;
        -:  656:    }
    #####:  657:    latSets[s].push_back(addLat(t, i, e));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  658:    return s;
call    0 never executed
        -:  659:  }
        -:  660:  // Unary operations.
    #####:  661:  case kAbsF:
    #####:  662:  case kAbsC:
    #####:  663:  case kAbsI:
    #####:  664:  case kCeilF:
    #####:  665:  case kFloorF:
    #####:  666:  case kSqrtF:
    #####:  667:  case kSqrtC:
    #####:  668:  case kExpm1F:
    #####:  669:  case kExpm1C:
    #####:  670:  case kLog1pF:
    #####:  671:  case kLog1pC:
    #####:  672:  case kSinF:
    #####:  673:  case kSinC:
    #####:  674:  case kTanhF:
    #####:  675:  case kTanhC:
    #####:  676:  case kNegF:
    #####:  677:  case kNegC:
    #####:  678:  case kNegI:
    #####:  679:  case kTruncF:
    #####:  680:  case kExtF:
    #####:  681:  case kCastFS:
    #####:  682:  case kCastFU:
    #####:  683:  case kCastSF:
    #####:  684:  case kCastUF:
    #####:  685:  case kCastS:
    #####:  686:  case kCastU:
    #####:  687:  case kCastIdx:
    #####:  688:  case kTruncI:
    #####:  689:  case kCIm:
    #####:  690:  case kCRe:
    #####:  691:  case kBitCast:
        -:  692:    // A zero preserving operation (viz. f(0) = 0, [Bik96,Ch5]) maps the
        -:  693:    // lattice set of the operand through the operator into a new set.
        -:  694:    //
        -:  695:    //  -y|!y | y |
        -:  696:    //  --+---+---+
        -:  697:    //    | 0 |-y |
    #####:  698:    return mapSet(kind, buildLattices(tensorExps[e].children.e0, i),
call    0 never executed
    #####:  699:                  tensorExps[e].val);
call    0 never executed
    #####:  700:  case kBinaryBranch:
    #####:  701:  case kSelect:
        -:  702:    // The left or right half of a binary operation which has already
        -:  703:    // been split into separate operations for each region.
    #####:  704:    return mapSet(kind, buildLattices(tensorExps[e].children.e0, i), Value(),
call    0 never executed
    #####:  705:                  tensorExps[e].op);
call    0 never executed
    #####:  706:  case kUnary:
        -:  707:    // A custom unary operation.
        -:  708:    //
        -:  709:    //  op y|    !y    |     y      |
        -:  710:    //  ----+----------+------------+
        -:  711:    //      | absent() | present(y) |
    #####:  712:    {
    #####:  713:      unsigned child0 = buildLattices(tensorExps[e].children.e0, i);
call    0 never executed
    #####:  714:      UnaryOp unop = cast<UnaryOp>(tensorExps[e].op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  715:      Region &absentRegion = unop.getAbsentRegion();
call    0 never executed
        -:  716:
    #####:  717:      if (absentRegion.empty()) {
branch  0 never executed
branch  1 never executed
        -:  718:        // Simple mapping over existing values.
    #####:  719:        return mapSet(kind, child0, Value(), unop);
call    0 never executed
        -:  720:      } // Use a disjunction with `unop` on the left and the absent value as an
        -:  721:      // invariant on the right.
    #####:  722:      Block &absentBlock = absentRegion.front();
call    0 never executed
    #####:  723:      YieldOp absentYield = cast<YieldOp>(absentBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####:  724:      Value absentVal = absentYield.getResult();
call    0 never executed
    #####:  725:      unsigned rhs = addExp(kInvariant, absentVal);
call    0 never executed
    #####:  726:      return takeDisj(kind, child0, buildLattices(rhs, i), unop);
call    0 never executed
call    1 never executed
        -:  727:    }
        -:  728:  // Binary operations.
    #####:  729:  case kMulF:
    #####:  730:  case kMulC:
    #####:  731:  case kMulI:
    #####:  732:  case kAndI:
        -:  733:    // A multiplicative operation only needs to be performed
        -:  734:    // for the conjunction of sparse iteration spaces.
        -:  735:    //
        -:  736:    //  x*y|!y | y |
        -:  737:    //  ---+---+---+
        -:  738:    //  !x | 0 | 0 |
        -:  739:    //   x | 0 |x*y|
        -:  740:    //
        -:  741:    // Note even here, 0*NaN=NaN and 0*Inf=NaN, but that is ignored.
    #####:  742:    return takeConj(kind, // take binary conjunction
call    0 never executed
    #####:  743:                    buildLattices(tensorExps[e].children.e0, i),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  744:                    buildLattices(tensorExps[e].children.e1, i));
call    0 never executed
    #####:  745:  case kDivF:
    #####:  746:  case kDivC:
    #####:  747:  case kDivS:
    #####:  748:  case kDivU:
        -:  749:    // A division is tricky, since 0/0, 0/c, c/0 all have
        -:  750:    // specific outcomes for floating-point and integers.
        -:  751:    // Thus, we need to traverse the full iteration space.
        -:  752:    //
        -:  753:    //  x/y|!y | y |
        -:  754:    //  ---+---+---+
        -:  755:    //  !x |0/0|0/y|   FP: 0/0=NaN,c/0=Inf,0/c=0 with c true nonzero
        -:  756:    //   x |x/0|x/y|  INT: x/0=exception for any x
        -:  757:    //
        -:  758:    // TODO: for now we "fixed" this by only accepting x/c cases
        -:  759:    //       during expression building, so that the conjunction
        -:  760:    //       rules applies (viz. x/c = x*(1/c) as far as lattice
        -:  761:    //       construction is concerned).
    #####:  762:    assert(!maybeZero(tensorExps[e].children.e1));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  763:    return takeConj(kind, // take binary conjunction
call    0 never executed
    #####:  764:                    buildLattices(tensorExps[e].children.e0, i),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  765:                    buildLattices(tensorExps[e].children.e1, i));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  766:  case kAddF:
    #####:  767:  case kAddC:
    #####:  768:  case kAddI:
    #####:  769:  case kSubF:
    #####:  770:  case kSubC:
    #####:  771:  case kSubI:
    #####:  772:  case kOrI:
    #####:  773:  case kXorI:
        -:  774:    // An additive operation needs to be performed
        -:  775:    // for the disjunction of sparse iteration spaces.
        -:  776:    //
        -:  777:    //  x+y|!y | y |    x-y|!y | y |
        -:  778:    //  ---+---+---+    ---+---+---+
        -:  779:    //  !x | 0 | y |    !x | 0 |-y |
        -:  780:    //   x | x |x+y|     x | x |x-y|
    #####:  781:    return takeDisj(kind, // take binary disjunction
call    0 never executed
    #####:  782:                    buildLattices(tensorExps[e].children.e0, i),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  783:                    buildLattices(tensorExps[e].children.e1, i));
call    0 never executed
    #####:  784:  case kShrS:
    #####:  785:  case kShrU:
    #####:  786:  case kShlI:
        -:  787:    // A shift operation by an invariant amount (viz. tensor expressions
        -:  788:    // can only occur at the left-hand-side of the operator) can be handled
        -:  789:    // with the conjuction rule.
    #####:  790:    assert(isInvariant(tensorExps[e].children.e1));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  791:    return takeConj(kind, // take binary conjunction
call    0 never executed
    #####:  792:                    buildLattices(tensorExps[e].children.e0, i),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  793:                    buildLattices(tensorExps[e].children.e1, i));
call    0 never executed
    #####:  794:  case kBinary:
        -:  795:    // A custom binary operation.
        -:  796:    //
        -:  797:    //  x op y|   !y    |       y      |
        -:  798:    //  ------+---------+--------------+
        -:  799:    //    !x  |  empty  |   right(y)   |
        -:  800:    //     x  | left(x) | overlap(x,y) |
    #####:  801:    {
    #####:  802:      unsigned child0 = buildLattices(tensorExps[e].children.e0, i);
call    0 never executed
    #####:  803:      unsigned child1 = buildLattices(tensorExps[e].children.e1, i);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  804:      BinaryOp binop = cast<BinaryOp>(tensorExps[e].op);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  805:      Region &leftRegion = binop.getLeftRegion();
call    0 never executed
    #####:  806:      Region &rightRegion = binop.getRightRegion();
call    0 never executed
        -:  807:      // Left Region.
    #####:  808:      Operation *leftYield = nullptr;
    #####:  809:      if (!leftRegion.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  810:        Block &leftBlock = leftRegion.front();
call    0 never executed
    #####:  811:        leftYield = leftBlock.getTerminator();
call    0 never executed
        -:  812:      }
        -:  813:      // Right Region.
    #####:  814:      Operation *rightYield = nullptr;
    #####:  815:      if (!rightRegion.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  816:        Block &rightBlock = rightRegion.front();
call    0 never executed
    #####:  817:        rightYield = rightBlock.getTerminator();
call    0 never executed
        -:  818:      }
    #####:  819:      bool includeLeft = binop.getLeftIdentity() || !leftRegion.empty();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  820:      bool includeRight = binop.getRightIdentity() || !rightRegion.empty();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  821:      return takeCombi(kBinary, child0, child1, binop, includeLeft,
call    0 never executed
        -:  822:                       kBinaryBranch, leftYield, includeRight, kBinaryBranch,
        -:  823:                       rightYield);
        -:  824:    }
    #####:  825:  case kReduce:
        -:  826:    // A custom reduce operation.
    #####:  827:    return takeConj(kind, buildLattices(tensorExps[e].children.e0, i),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  828:                    buildLattices(tensorExps[e].children.e1, i),
call    0 never executed
    #####:  829:                    tensorExps[e].op);
call    0 never executed
        -:  830:  }
    #####:  831:  llvm_unreachable("unexpected expression kind");
call    0 never executed
        -:  832:}
        -:  833:
function _ZN4mlir13sparse_tensor6Merger24buildTensorExpFromLinalgENS_6linalg9GenericOpE called 0 returned 0% blocks executed 0%
    #####:  834:Optional<unsigned> Merger::buildTensorExpFromLinalg(linalg::GenericOp op) {
        -:  835:  // Build the linalg semantics backward from yield.
    #####:  836:  Operation *yield = op.getRegion().front().getTerminator();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  837:  assert(isa<linalg::YieldOp>(yield));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  838:  return buildTensorExp(op, yield->getOperand(0));
call    0 never executed
call    1 never executed
        -:  839:}
        -:  840:
        -:  841:/// Only returns false if we are certain this is a nonzero.
function _ZNK4mlir13sparse_tensor6Merger9maybeZeroEj called 0 returned 0% blocks executed 0%
    #####:  842:bool Merger::maybeZero(unsigned e) const {
    #####:  843:  if (tensorExps[e].kind == kInvariant) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  844:    if (auto c = tensorExps[e].val.getDefiningOp<complex::ConstantOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:      ArrayAttr arrayAttr = c.getValue();
call    0 never executed
    #####:  846:      return arrayAttr[0].cast<FloatAttr>().getValue().isZero() &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  847:             arrayAttr[1].cast<FloatAttr>().getValue().isZero();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -:  848:    }
    #####:  849:    if (auto c = tensorExps[e].val.getDefiningOp<arith::ConstantIntOp>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  850:      return c.value() == 0;
call    0 never executed
    #####:  851:    if (auto c = tensorExps[e].val.getDefiningOp<arith::ConstantFloatOp>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  852:      return c.value().isZero();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  853:  }
        -:  854:  return true;
        -:  855:}
        -:  856:
function _ZNK4mlir13sparse_tensor6Merger11isInvariantEj called 0 returned 0% blocks executed 0%
    #####:  857:bool Merger::isInvariant(unsigned e) const {
    #####:  858:  return tensorExps[e].kind == kInvariant;
branch  0 never executed
branch  1 never executed
        -:  859:}
        -:  860:
function _ZN4mlir13sparse_tensor6Merger9inferTypeEjNS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  861:Type Merger::inferType(unsigned e, Value src) {
        -:  862:  // Obtain the destination type from the cast node.
    #####:  863:  Type dtp = tensorExps[e].val.getType();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  864:  // Inspect source type. For vector types, apply the same
        -:  865:  // vectorization to the destination type.
    #####:  866:  if (auto vtp = src.getType().dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  867:    return VectorType::get(vtp.getNumElements(), dtp, vtp.getNumScalableDims());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  868:  return dtp;
        -:  869:}
        -:  870:
        -:  871:/// Ensures that sparse compiler can generate code for expression.
function _ZN4mlir13sparse_tensorL21isAdmissibleBranchExpEPNS_9OperationEPNS_5BlockENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  872:static bool isAdmissibleBranchExp(Operation *op, Block *block, Value v) {
        -:  873:  // Arguments are always admissible.
    #####:  874:  if (auto arg = v.dyn_cast<BlockArgument>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  875:    return true;
        -:  876:  // Accept index anywhere.
    #####:  877:  Operation *def = v.getDefiningOp();
call    0 never executed
    #####:  878:  if (isa<linalg::IndexOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  879:    return true;
        -:  880:  // Operation defined outside branch.
    #####:  881:  if (def->getBlock() != block)
branch  0 never executed
branch  1 never executed
    #####:  882:    return def->getBlock() != op->getBlock(); // invariant?
        -:  883:  // Operation defined within branch. Anything is accepted,
        -:  884:  // as long as all subexpressions are admissible.
    #####:  885:  for (unsigned i = 0, n = def->getNumOperands(); i < n; i++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  886:    if (!isAdmissibleBranchExp(op, block, def->getOperand(i)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  887:      return false;
        -:  888:  return true;
        -:  889:}
        -:  890:
        -:  891:/// Ensures that sparse compiler can generate code for branch.
function _ZN4mlir13sparse_tensorL18isAdmissibleBranchEPNS_9OperationERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  892:static bool isAdmissibleBranch(Operation *op, Region &region) {
    #####:  893:  if (region.empty())
branch  0 never executed
branch  1 never executed
        -:  894:    return true;
        -:  895:  // Build the semi-ring branch semantics backward from yield.
    #####:  896:  Operation *yield = region.front().getTerminator();
call    0 never executed
call    1 never executed
    #####:  897:  assert(isa<YieldOp>(yield));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  898:  return isAdmissibleBranchExp(op, &region.front(), yield->getOperand(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  899:}
        -:  900:
function _ZN4mlir13sparse_tensor6Merger14buildTensorExpENS_6linalg9GenericOpENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  901:Optional<unsigned> Merger::buildTensorExp(linalg::GenericOp op, Value v) {
    #####:  902:  if (auto arg = v.dyn_cast<BlockArgument>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  903:    unsigned argN = arg.getArgNumber();
call    0 never executed
        -:  904:    // Any argument of the generic op that is not marked as a scalar
        -:  905:    // argument is considered a tensor, indexed by the implicit loop
        -:  906:    // bounds. This includes rank-0 tensor arguments.
    #####:  907:    if (arg.getOwner()->getParentOp() == op) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  908:      OpOperand &t = op->getOpOperand(argN);
call    0 never executed
    #####:  909:      if (!op.isScalar(&t))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  910:        return addExp(kTensor, argN);
call    0 never executed
    #####:  911:      v = t.get(); // get scalar value
        -:  912:    }
        -:  913:    // Any other argument (marked as scalar argument for the generic op
        -:  914:    // or belonging to an enveloping op) is considered invariant.
    #####:  915:    return addExp(kInvariant, v);
call    0 never executed
        -:  916:  }
        -:  917:  // Something defined outside is invariant.
    #####:  918:  Operation *def = v.getDefiningOp();
call    0 never executed
    #####:  919:  if (def->getBlock() != &op.getRegion().front())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  920:    return addExp(kInvariant, v);
call    0 never executed
        -:  921:  // Construct index operations.
    #####:  922:  if (def->getNumOperands() == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  923:    if (auto indexOp = dyn_cast<linalg::IndexOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  924:      return addExp(kIndex, indexOp.getDim());
call    0 never executed
call    1 never executed
        -:  925:  }
        -:  926:  // Construct unary operations if subexpression can be built.
    #####:  927:  if (def->getNumOperands() == 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  928:    auto x = buildTensorExp(op, def->getOperand(0));
call    0 never executed
call    1 never executed
    #####:  929:    if (x.has_value()) {
branch  0 never executed
branch  1 never executed
    #####:  930:      unsigned e = x.value();
call    0 never executed
    #####:  931:      if (isa<math::AbsFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:        return addExp(kAbsF, e);
call    0 never executed
    #####:  933:      if (isa<complex::AbsOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  934:        return addExp(kAbsC, e);
call    0 never executed
    #####:  935:      if (isa<math::AbsIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  936:        return addExp(kAbsI, e);
call    0 never executed
    #####:  937:      if (isa<math::CeilOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:        return addExp(kCeilF, e);
call    0 never executed
    #####:  939:      if (isa<math::FloorOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:        return addExp(kFloorF, e);
call    0 never executed
    #####:  941:      if (isa<math::SqrtOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  942:        return addExp(kSqrtF, e);
call    0 never executed
    #####:  943:      if (isa<complex::SqrtOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  944:        return addExp(kSqrtC, e);
call    0 never executed
    #####:  945:      if (isa<math::ExpM1Op>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  946:        return addExp(kExpm1F, e);
call    0 never executed
    #####:  947:      if (isa<complex::Expm1Op>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  948:        return addExp(kExpm1C, e);
call    0 never executed
    #####:  949:      if (isa<math::Log1pOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  950:        return addExp(kLog1pF, e);
call    0 never executed
    #####:  951:      if (isa<complex::Log1pOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:        return addExp(kLog1pC, e);
call    0 never executed
    #####:  953:      if (isa<math::SinOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  954:        return addExp(kSinF, e);
call    0 never executed
    #####:  955:      if (isa<complex::SinOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  956:        return addExp(kSinC, e);
call    0 never executed
    #####:  957:      if (isa<math::TanhOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  958:        return addExp(kTanhF, e);
call    0 never executed
    #####:  959:      if (isa<complex::TanhOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  960:        return addExp(kTanhC, e);
call    0 never executed
    #####:  961:      if (isa<arith::NegFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  962:        return addExp(kNegF, e); // no negi in std
call    0 never executed
    #####:  963:      if (isa<complex::NegOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  964:        return addExp(kNegC, e);
call    0 never executed
    #####:  965:      if (isa<arith::TruncFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  966:        return addExp(kTruncF, e, v);
call    0 never executed
    #####:  967:      if (isa<arith::ExtFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  968:        return addExp(kExtF, e, v);
call    0 never executed
    #####:  969:      if (isa<arith::FPToSIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  970:        return addExp(kCastFS, e, v);
call    0 never executed
    #####:  971:      if (isa<arith::FPToUIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  972:        return addExp(kCastFU, e, v);
call    0 never executed
    #####:  973:      if (isa<arith::SIToFPOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  974:        return addExp(kCastSF, e, v);
call    0 never executed
    #####:  975:      if (isa<arith::UIToFPOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  976:        return addExp(kCastUF, e, v);
call    0 never executed
    #####:  977:      if (isa<arith::ExtSIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  978:        return addExp(kCastS, e, v);
call    0 never executed
    #####:  979:      if (isa<arith::ExtUIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  980:        return addExp(kCastU, e, v);
call    0 never executed
    #####:  981:      if (isa<arith::IndexCastOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  982:        return addExp(kCastIdx, e, v);
call    0 never executed
    #####:  983:      if (isa<arith::TruncIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  984:        return addExp(kTruncI, e, v);
call    0 never executed
    #####:  985:      if (isa<complex::ImOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  986:        return addExp(kCIm, e);
call    0 never executed
    #####:  987:      if (isa<complex::ReOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  988:        return addExp(kCRe, e);
call    0 never executed
    #####:  989:      if (isa<arith::BitcastOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  990:        return addExp(kBitCast, e, v);
call    0 never executed
    #####:  991:      if (auto unop = dyn_cast<sparse_tensor::UnaryOp>(def)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  992:        if (isAdmissibleBranch(unop, unop.getPresentRegion()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  993:            isAdmissibleBranch(unop, unop.getAbsentRegion()))
call    0 never executed
call    1 never executed
    #####:  994:          return addExp(kUnary, e, Value(), def);
call    0 never executed
        -:  995:      }
    #####:  996:      if (auto selop = dyn_cast<sparse_tensor::SelectOp>(def)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  997:        if (isAdmissibleBranch(selop, selop.getRegion()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  998:          return addExp(kSelect, e, Value(), def);
call    0 never executed
        -:  999:      }
        -: 1000:    }
        -: 1001:  }
        -: 1002:  // Construct binary operations if subexpressions can be built.
        -: 1003:  // See buildLattices() for an explanation of rejecting certain
        -: 1004:  // division and shift operations.
    #####: 1005:  if (def->getNumOperands() == 2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1006:    auto x = buildTensorExp(op, def->getOperand(0));
call    0 never executed
call    1 never executed
    #####: 1007:    auto y = buildTensorExp(op, def->getOperand(1));
call    0 never executed
call    1 never executed
    #####: 1008:    if (x.has_value() && y.has_value()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1009:      unsigned e0 = x.value();
call    0 never executed
    #####: 1010:      unsigned e1 = y.value();
    #####: 1011:      if (isa<arith::MulFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1012:        return addExp(kMulF, e0, e1);
call    0 never executed
    #####: 1013:      if (isa<complex::MulOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1014:        return addExp(kMulC, e0, e1);
call    0 never executed
    #####: 1015:      if (isa<arith::MulIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1016:        return addExp(kMulI, e0, e1);
call    0 never executed
    #####: 1017:      if (isa<arith::DivFOp>(def) && !maybeZero(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1018:        return addExp(kDivF, e0, e1);
call    0 never executed
    #####: 1019:      if (isa<complex::DivOp>(def) && !maybeZero(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1020:        return addExp(kDivC, e0, e1);
call    0 never executed
    #####: 1021:      if (isa<arith::DivSIOp>(def) && !maybeZero(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1022:        return addExp(kDivS, e0, e1);
call    0 never executed
    #####: 1023:      if (isa<arith::DivUIOp>(def) && !maybeZero(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1024:        return addExp(kDivU, e0, e1);
call    0 never executed
    #####: 1025:      if (isa<arith::AddFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1026:        return addExp(kAddF, e0, e1);
call    0 never executed
    #####: 1027:      if (isa<complex::AddOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1028:        return addExp(kAddC, e0, e1);
call    0 never executed
    #####: 1029:      if (isa<arith::AddIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1030:        return addExp(kAddI, e0, e1);
call    0 never executed
    #####: 1031:      if (isa<arith::SubFOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1032:        return addExp(kSubF, e0, e1);
call    0 never executed
    #####: 1033:      if (isa<complex::SubOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1034:        return addExp(kSubC, e0, e1);
call    0 never executed
    #####: 1035:      if (isa<arith::SubIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1036:        return addExp(kSubI, e0, e1);
call    0 never executed
    #####: 1037:      if (isa<arith::AndIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1038:        return addExp(kAndI, e0, e1);
call    0 never executed
    #####: 1039:      if (isa<arith::OrIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1040:        return addExp(kOrI, e0, e1);
call    0 never executed
    #####: 1041:      if (isa<arith::XOrIOp>(def))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1042:        return addExp(kXorI, e0, e1);
call    0 never executed
    #####: 1043:      if (isa<arith::ShRSIOp>(def) && isInvariant(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1044:        return addExp(kShrS, e0, e1);
call    0 never executed
    #####: 1045:      if (isa<arith::ShRUIOp>(def) && isInvariant(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1046:        return addExp(kShrU, e0, e1);
call    0 never executed
    #####: 1047:      if (isa<arith::ShLIOp>(def) && isInvariant(e1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1048:        return addExp(kShlI, e0, e1);
call    0 never executed
    #####: 1049:      if (auto binop = dyn_cast<sparse_tensor::BinaryOp>(def)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1050:        if (isAdmissibleBranch(binop, binop.getOverlapRegion()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1051:            (binop.getLeftIdentity() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1052:             isAdmissibleBranch(binop, binop.getLeftRegion())) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1053:            (binop.getRightIdentity() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1054:             isAdmissibleBranch(binop, binop.getRightRegion())))
call    0 never executed
call    1 never executed
    #####: 1055:          return addExp(kBinary, e0, e1, Value(), def);
call    0 never executed
        -: 1056:      }
        -: 1057:    }
        -: 1058:  }
        -: 1059:  // Construct ternary operations if subexpressions can be built.
    #####: 1060:  if (def->getNumOperands() == 3) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1061:    auto x = buildTensorExp(op, def->getOperand(0));
call    0 never executed
call    1 never executed
    #####: 1062:    auto y = buildTensorExp(op, def->getOperand(1));
call    0 never executed
call    1 never executed
    #####: 1063:    auto z = buildTensorExp(op, def->getOperand(2));
call    0 never executed
call    1 never executed
    #####: 1064:    if (x.has_value() && y.has_value() && z.has_value()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1065:      unsigned e0 = x.value();
call    0 never executed
    #####: 1066:      unsigned e1 = y.value();
    #####: 1067:      if (auto redop = dyn_cast<sparse_tensor::ReduceOp>(def)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1068:        if (isAdmissibleBranch(redop, redop.getRegion()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1069:          return addExp(kReduce, e0, e1, Value(), def);
call    0 never executed
        -: 1070:      }
        -: 1071:    }
        -: 1072:  }
        -: 1073:  // Cannot build.
    #####: 1074:  return None;
        -: 1075:}
        -: 1076:
function _ZN4mlir13sparse_tensorL13insertYieldOpERNS_12RewriterBaseENS_8LocationERNS_6RegionENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1077:static Value insertYieldOp(RewriterBase &rewriter, Location loc, Region &region,
        -: 1078:                           ValueRange vals) {
        -: 1079:  // Make a clone of overlap region.
    #####: 1080:  Region tmpRegion;
call    0 never executed
call    1 never executed
    #####: 1081:  BlockAndValueMapping mapper;
call    0 never executed
    #####: 1082:  region.cloneInto(&tmpRegion, tmpRegion.begin(), mapper);
call    0 never executed
    #####: 1083:  Block &clonedBlock = tmpRegion.front();
call    0 never executed
    #####: 1084:  YieldOp clonedYield = cast<YieldOp>(clonedBlock.getTerminator());
call    0 never executed
call    1 never executed
        -: 1085:  // Merge cloned block and return yield value.
    #####: 1086:  Operation *placeholder = rewriter.create<arith::ConstantIndexOp>(loc, 0);
call    0 never executed
call    1 never executed
    #####: 1087:  rewriter.mergeBlockBefore(&tmpRegion.front(), placeholder, vals);
call    0 never executed
call    1 never executed
    #####: 1088:  Value val = clonedYield.getResult();
call    0 never executed
    #####: 1089:  rewriter.eraseOp(clonedYield);
call    0 never executed
    #####: 1090:  rewriter.eraseOp(placeholder);
call    0 never executed
    #####: 1091:  return val;
call    0 never executed
        -: 1092:}
        -: 1093:
function _ZN4mlir13sparse_tensorL17buildUnaryPresentERNS_12RewriterBaseENS_8LocationEPNS_9OperationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 1094:static Value buildUnaryPresent(RewriterBase &rewriter, Location loc,
        -: 1095:                               Operation *op, Value v0) {
    #####: 1096:  if (!v0)
branch  0 never executed
branch  1 never executed
        -: 1097:    // Empty input value must be propagated.
    #####: 1098:    return Value();
    #####: 1099:  UnaryOp unop = cast<UnaryOp>(op);
call    0 never executed
    #####: 1100:  Region &presentRegion = unop.getPresentRegion();
call    0 never executed
    #####: 1101:  if (presentRegion.empty())
branch  0 never executed
branch  1 never executed
        -: 1102:    // Uninitialized Value() will be interpreted as missing data in the
        -: 1103:    // output.
    #####: 1104:    return Value();
    #####: 1105:  return insertYieldOp(rewriter, loc, presentRegion, {v0});
call    0 never executed
call    1 never executed
        -: 1106:}
        -: 1107:
function _ZN4mlir13sparse_tensorL18buildBinaryOverlapERNS_12RewriterBaseENS_8LocationEPNS_9OperationENS_5ValueES6_ called 0 returned 0% blocks executed 0%
    #####: 1108:static Value buildBinaryOverlap(RewriterBase &rewriter, Location loc,
        -: 1109:                                Operation *op, Value v0, Value v1) {
    #####: 1110:  if (!v0 || !v1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1111:    // Empty input values must be propagated.
    #####: 1112:    return Value();
    #####: 1113:  BinaryOp binop = cast<BinaryOp>(op);
call    0 never executed
    #####: 1114:  Region &overlapRegion = binop.getOverlapRegion();
call    0 never executed
    #####: 1115:  if (overlapRegion.empty())
branch  0 never executed
branch  1 never executed
        -: 1116:    // Uninitialized Value() will be interpreted as missing data in the
        -: 1117:    // output.
    #####: 1118:    return Value();
    #####: 1119:  return insertYieldOp(rewriter, loc, overlapRegion, {v0, v1});
call    0 never executed
call    1 never executed
        -: 1120:}
        -: 1121:
function _ZN4mlir13sparse_tensor6Merger8buildExpERNS_12RewriterBaseENS_8LocationEjNS_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####: 1122:Value Merger::buildExp(RewriterBase &rewriter, Location loc, unsigned e,
        -: 1123:                       Value v0, Value v1) {
    #####: 1124:  switch (tensorExps[e].kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
        -: 1125:  // Leaf.
    #####: 1126:  case kTensor:
    #####: 1127:  case kInvariant:
    #####: 1128:  case kIndex:
    #####: 1129:    llvm_unreachable("unexpected non-op");
call    0 never executed
        -: 1130:  // Unary operations.
    #####: 1131:  case kAbsF:
    #####: 1132:    return rewriter.create<math::AbsFOp>(loc, v0);
call    0 never executed
    #####: 1133:  case kAbsC: {
    #####: 1134:    auto type = v0.getType().cast<ComplexType>();
call    0 never executed
    #####: 1135:    auto eltType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1136:    return rewriter.create<complex::AbsOp>(loc, eltType, v0);
call    0 never executed
        -: 1137:  }
    #####: 1138:  case kAbsI:
    #####: 1139:    return rewriter.create<math::AbsIOp>(loc, v0);
call    0 never executed
    #####: 1140:  case kCeilF:
    #####: 1141:    return rewriter.create<math::CeilOp>(loc, v0);
call    0 never executed
    #####: 1142:  case kFloorF:
    #####: 1143:    return rewriter.create<math::FloorOp>(loc, v0);
call    0 never executed
    #####: 1144:  case kSqrtF:
    #####: 1145:    return rewriter.create<math::SqrtOp>(loc, v0);
call    0 never executed
    #####: 1146:  case kSqrtC:
    #####: 1147:    return rewriter.create<complex::SqrtOp>(loc, v0);
call    0 never executed
    #####: 1148:  case kExpm1F:
    #####: 1149:    return rewriter.create<math::ExpM1Op>(loc, v0);
call    0 never executed
    #####: 1150:  case kExpm1C:
    #####: 1151:    return rewriter.create<complex::Expm1Op>(loc, v0);
call    0 never executed
    #####: 1152:  case kLog1pF:
    #####: 1153:    return rewriter.create<math::Log1pOp>(loc, v0);
call    0 never executed
    #####: 1154:  case kLog1pC:
    #####: 1155:    return rewriter.create<complex::Log1pOp>(loc, v0);
call    0 never executed
    #####: 1156:  case kSinF:
    #####: 1157:    return rewriter.create<math::SinOp>(loc, v0);
call    0 never executed
    #####: 1158:  case kSinC:
    #####: 1159:    return rewriter.create<complex::SinOp>(loc, v0);
call    0 never executed
    #####: 1160:  case kTanhF:
    #####: 1161:    return rewriter.create<math::TanhOp>(loc, v0);
call    0 never executed
    #####: 1162:  case kTanhC:
    #####: 1163:    return rewriter.create<complex::TanhOp>(loc, v0);
call    0 never executed
    #####: 1164:  case kNegF:
    #####: 1165:    return rewriter.create<arith::NegFOp>(loc, v0);
call    0 never executed
    #####: 1166:  case kNegC:
    #####: 1167:    return rewriter.create<complex::NegOp>(loc, v0);
call    0 never executed
    #####: 1168:  case kNegI: // no negi in std
    #####: 1169:    return rewriter.create<arith::SubIOp>(
        -: 1170:        loc,
    #####: 1171:        rewriter.create<arith::ConstantOp>(loc, v0.getType(),
call    0 never executed
    #####: 1172:                                           rewriter.getZeroAttr(v0.getType())),
call    0 never executed
    #####: 1173:        v0);
call    0 never executed
call    1 never executed
    #####: 1174:  case kTruncF:
    #####: 1175:    return rewriter.create<arith::TruncFOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1176:  case kExtF:
    #####: 1177:    return rewriter.create<arith::ExtFOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1178:  case kCastFS:
    #####: 1179:    return rewriter.create<arith::FPToSIOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1180:  case kCastFU:
    #####: 1181:    return rewriter.create<arith::FPToUIOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1182:  case kCastSF:
    #####: 1183:    return rewriter.create<arith::SIToFPOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1184:  case kCastUF:
    #####: 1185:    return rewriter.create<arith::UIToFPOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1186:  case kCastS:
    #####: 1187:    return rewriter.create<arith::ExtSIOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1188:  case kCastU:
    #####: 1189:    return rewriter.create<arith::ExtUIOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1190:  case kCastIdx:
    #####: 1191:    return rewriter.create<arith::IndexCastOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1192:  case kTruncI:
    #####: 1193:    return rewriter.create<arith::TruncIOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
    #####: 1194:  case kCIm: {
    #####: 1195:    auto type = v0.getType().cast<ComplexType>();
call    0 never executed
    #####: 1196:    auto eltType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1197:    return rewriter.create<complex::ImOp>(loc, eltType, v0);
call    0 never executed
        -: 1198:  }
    #####: 1199:  case kCRe: {
    #####: 1200:    auto type = v0.getType().cast<ComplexType>();
call    0 never executed
    #####: 1201:    auto eltType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1202:    return rewriter.create<complex::ReOp>(loc, eltType, v0);
call    0 never executed
        -: 1203:  }
    #####: 1204:  case kBitCast:
    #####: 1205:    return rewriter.create<arith::BitcastOp>(loc, inferType(e, v0), v0);
call    0 never executed
call    1 never executed
        -: 1206:  // Binary operations.
    #####: 1207:  case kMulF:
    #####: 1208:    return rewriter.create<arith::MulFOp>(loc, v0, v1);
call    0 never executed
    #####: 1209:  case kMulC:
    #####: 1210:    return rewriter.create<complex::MulOp>(loc, v0, v1);
call    0 never executed
    #####: 1211:  case kMulI:
    #####: 1212:    return rewriter.create<arith::MulIOp>(loc, v0, v1);
call    0 never executed
    #####: 1213:  case kDivF:
    #####: 1214:    return rewriter.create<arith::DivFOp>(loc, v0, v1);
call    0 never executed
    #####: 1215:  case kDivC:
    #####: 1216:    return rewriter.create<complex::DivOp>(loc, v0, v1);
call    0 never executed
    #####: 1217:  case kDivS:
    #####: 1218:    return rewriter.create<arith::DivSIOp>(loc, v0, v1);
call    0 never executed
    #####: 1219:  case kDivU:
    #####: 1220:    return rewriter.create<arith::DivUIOp>(loc, v0, v1);
call    0 never executed
    #####: 1221:  case kAddF:
    #####: 1222:    return rewriter.create<arith::AddFOp>(loc, v0, v1);
call    0 never executed
    #####: 1223:  case kAddC:
    #####: 1224:    return rewriter.create<complex::AddOp>(loc, v0, v1);
call    0 never executed
    #####: 1225:  case kAddI:
    #####: 1226:    return rewriter.create<arith::AddIOp>(loc, v0, v1);
call    0 never executed
    #####: 1227:  case kSubF:
    #####: 1228:    return rewriter.create<arith::SubFOp>(loc, v0, v1);
call    0 never executed
    #####: 1229:  case kSubC:
    #####: 1230:    return rewriter.create<complex::SubOp>(loc, v0, v1);
call    0 never executed
    #####: 1231:  case kSubI:
    #####: 1232:    return rewriter.create<arith::SubIOp>(loc, v0, v1);
call    0 never executed
    #####: 1233:  case kAndI:
    #####: 1234:    return rewriter.create<arith::AndIOp>(loc, v0, v1);
call    0 never executed
    #####: 1235:  case kOrI:
    #####: 1236:    return rewriter.create<arith::OrIOp>(loc, v0, v1);
call    0 never executed
    #####: 1237:  case kXorI:
    #####: 1238:    return rewriter.create<arith::XOrIOp>(loc, v0, v1);
call    0 never executed
    #####: 1239:  case kShrS:
    #####: 1240:    return rewriter.create<arith::ShRSIOp>(loc, v0, v1);
call    0 never executed
    #####: 1241:  case kShrU:
    #####: 1242:    return rewriter.create<arith::ShRUIOp>(loc, v0, v1);
call    0 never executed
    #####: 1243:  case kShlI:
    #####: 1244:    return rewriter.create<arith::ShLIOp>(loc, v0, v1);
call    0 never executed
    #####: 1245:  case kBinaryBranch: // semi-ring ops with custom logic.
    #####: 1246:    return insertYieldOp(rewriter, loc,
    #####: 1247:                         *tensorExps[e].op->getBlock()->getParent(), {v0});
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####: 1248:  case kUnary:
    #####: 1249:    return buildUnaryPresent(rewriter, loc, tensorExps[e].op, v0);
call    0 never executed
    #####: 1250:  case kSelect:
    #####: 1251:    return insertYieldOp(rewriter, loc,
    #####: 1252:                         cast<SelectOp>(tensorExps[e].op).getRegion(), {v0});
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1253:  case kBinary:
    #####: 1254:    return buildBinaryOverlap(rewriter, loc, tensorExps[e].op, v0, v1);
call    0 never executed
    #####: 1255:  case kReduce: {
    #####: 1256:    ReduceOp redOp = cast<ReduceOp>(tensorExps[e].op);
call    0 never executed
    #####: 1257:    return insertYieldOp(rewriter, loc, redOp.getRegion(), {v0, v1});
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1258:  }
        -: 1259:  }
    #####: 1260:  llvm_unreachable("unexpected expression kind in build");
call    0 never executed
        -: 1261:}
        -: 1262:
        -: 1263:} // namespace sparse_tensor
        -: 1264:} // namespace mlir
