        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/PDL/IR/PDL.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/PDL/IR/CMakeFiles/obj.MLIRPDLDialect.dir/PDL.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/PDL/IR/CMakeFiles/obj.MLIRPDLDialect.dir/PDL.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- PDL.cpp - Pattern Descriptor Language Dialect ----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/PDL/IR/PDL.h"
        -:   10:#include "mlir/Dialect/PDL/IR/PDLOps.h"
        -:   11:#include "mlir/Dialect/PDL/IR/PDLTypes.h"
        -:   12:#include "mlir/IR/BuiltinTypes.h"
        -:   13:#include "mlir/Interfaces/InferTypeOpInterface.h"
        -:   14:#include "llvm/ADT/DenseSet.h"
        -:   15:#include "llvm/ADT/TypeSwitch.h"
        -:   16:
        -:   17:using namespace mlir;
        -:   18:using namespace mlir::pdl;
        -:   19:
        -:   20:#include "mlir/Dialect/PDL/IR/PDLOpsDialect.cpp.inc"
        -:   21:
        -:   22://===----------------------------------------------------------------------===//
        -:   23:// PDLDialect
        -:   24://===----------------------------------------------------------------------===//
        -:   25:
function _ZN4mlir3pdl10PDLDialect10initializeEv called 0 returned 0% blocks executed 0%
    1198*:   26:void PDLDialect::initialize() {
    1198*:   27:  addOperations<
        -:   28:#define GET_OP_LIST
        -:   29:#include "mlir/Dialect/PDL/IR/PDLOps.cpp.inc"
    1198*:   30:      >();
call    0 never executed
call    1 returned 100%
    1198*:   31:  registerTypes();
call    0 never executed
call    1 returned 100%
    #####:   32:}
        -:   33:
        -:   34://===----------------------------------------------------------------------===//
        -:   35:// PDL Operations
        -:   36://===----------------------------------------------------------------------===//
        -:   37:
        -:   38:/// Returns true if the given operation is used by a "binding" pdl operation.
function _ZL13hasBindingUsePN4mlir9OperationE called 936 returned 100% blocks executed 58%
      936:   39:static bool hasBindingUse(Operation *op) {
     936*:   40:  for (Operation *user : op->getUsers())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
        -:   41:    // A result by itself is not binding, it must also be bound.
     936*:   42:    if (!isa<ResultOp, ResultsOp>(user) || hasBindingUse(user))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
      936:   43:      return true;
    #####:   44:  return false;
        -:   45:}
        -:   46:
        -:   47:/// Returns success if the given operation is not in the main matcher body or
        -:   48:/// is used by a "binding" operation. On failure, emits an error.
function _ZL19verifyHasBindingUsePN4mlir9OperationE called 1248 returned 100% blocks executed 64%
     1248:   49:static LogicalResult verifyHasBindingUse(Operation *op) {
        -:   50:  // If the parent is not a pattern, there is nothing to do.
     2496:   51:  if (!isa<PatternOp>(op->getParentOp()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
      312:   52:    return success();
      936:   53:  if (hasBindingUse(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      936:   54:    return success();
    #####:   55:  return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:   56:      "expected a bindable user when defined in the matcher body of a "
    #####:   57:      "`pdl.pattern`");
call    0 never executed
        -:   58:}
        -:   59:
        -:   60:/// Visits all the pdl.operand(s), pdl.result(s), and pdl.operation(s)
        -:   61:/// connected to the given operation.
function _ZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEE called 1716 returned 100% blocks executed 100%
     1716:   62:static void visit(Operation *op, DenseSet<Operation *> &visited) {
        -:   63:  // If the parent is not a pattern, there is nothing to do.
     3432:   64:  if (!isa<PatternOp>(op->getParentOp()) || isa<RewriteOp>(op))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 82% (fallthrough)
branch  4 taken 18%
call    5 returned 100%
branch  6 taken 22% (fallthrough)
branch  7 taken 78%
      624:   65:    return;
        -:   66:
        -:   67:  // Ignore if already visited.
     1092:   68:  if (visited.contains(op))
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
        -:   69:    return;
        -:   70:
        -:   71:  // Mark as visited.
      780:   72:  visited.insert(op);
call    0 returned 100%
        -:   73:
        -:   74:  // Traverse the operands / parent.
      780:   75:  TypeSwitch<Operation *>(op)
call    0 returned 100%
function _ZZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEEENKUlT_E_clINS_3pdl11OperationOpEEEDaS8_.isra.0 called 312 returned 100% blocks executed 100%
      312:   76:      .Case<OperationOp>([&visited](auto operation) {
      624:   77:        for (Value operand : operation.getOperandValues())
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
      312:   78:          visit(operand.getDefiningOp(), visited);
call    0 returned 100%
call    1 returned 100%
     1092:   79:      })
call    0 returned 100%
    #####:   80:      .Case<ResultOp, ResultsOp>([&visited](auto result) {
    #####:   81:        visit(result.getParent().getDefiningOp(), visited);
     780*:   82:      });
call    0 returned 100%
------------------
_ZZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEEENKUlT_E0_clINS_3pdl9ResultsOpEEEDaS8_.isra.0:
function _ZZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEEENKUlT_E0_clINS_3pdl9ResultsOpEEEDaS8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   80:      .Case<ResultOp, ResultsOp>([&visited](auto result) {
    #####:   81:        visit(result.getParent().getDefiningOp(), visited);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:      });
------------------
_ZZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEEENKUlT_E0_clINS_3pdl8ResultOpEEEDaS8_.isra.0:
function _ZZL5visitPN4mlir9OperationERN4llvm8DenseSetIS1_NS2_12DenseMapInfoIS1_vEEEEENKUlT_E0_clINS_3pdl8ResultOpEEEDaS8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   80:      .Case<ResultOp, ResultsOp>([&visited](auto result) {
    #####:   81:        visit(result.getParent().getDefiningOp(), visited);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:      });
------------------
        -:   83:
        -:   84:  // Traverse the users.
     2964:   85:  for (Operation *user : op->getUsers())
call    0 returned 100%
branch  1 taken 58% (fallthrough)
branch  2 taken 42%
call    3 returned 100%
     1092:   86:    visit(user, visited);
call    0 returned 100%
        -:   87:}
        -:   88:
        -:   89://===----------------------------------------------------------------------===//
        -:   90:// pdl::ApplyNativeConstraintOp
        -:   91://===----------------------------------------------------------------------===//
        -:   92:
function _ZN4mlir3pdl23ApplyNativeConstraintOp6verifyEv called 156 returned 100% blocks executed 44%
      156:   93:LogicalResult ApplyNativeConstraintOp::verify() {
      156:   94:  if (getNumOperands() == 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   95:    return emitOpError("expected at least one argument");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      156:   96:  return success();
        -:   97:}
        -:   98:
        -:   99://===----------------------------------------------------------------------===//
        -:  100:// pdl::ApplyNativeRewriteOp
        -:  101://===----------------------------------------------------------------------===//
        -:  102:
function _ZN4mlir3pdl20ApplyNativeRewriteOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  103:LogicalResult ApplyNativeRewriteOp::verify() {
    #####:  104:  if (getNumOperands() == 0 && getNumResults() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  105:    return emitOpError("expected at least one argument or result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  106:  return success();
        -:  107:}
        -:  108:
        -:  109://===----------------------------------------------------------------------===//
        -:  110:// pdl::AttributeOp
        -:  111://===----------------------------------------------------------------------===//
        -:  112:
function _ZN4mlir3pdl11AttributeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  113:LogicalResult AttributeOp::verify() {
    #####:  114:  Value attrType = getValueType();
call    0 never executed
    #####:  115:  Optional<Attribute> attrValue = getValue();
call    0 never executed
        -:  116:
    #####:  117:  if (!attrValue) {
branch  0 never executed
branch  1 never executed
    #####:  118:    if (isa<RewriteOp>((*this)->getParentOp()))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  119:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  120:          "expected constant value when specified within a `pdl.rewrite`");
call    0 never executed
    #####:  121:    return verifyHasBindingUse(*this);
call    0 never executed
        -:  122:  }
    #####:  123:  if (attrType)
branch  0 never executed
branch  1 never executed
    #####:  124:    return emitOpError("expected only one of [`type`, `value`] to be set");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  125:  return success();
        -:  126:}
        -:  127:
        -:  128://===----------------------------------------------------------------------===//
        -:  129:// pdl::OperandOp
        -:  130://===----------------------------------------------------------------------===//
        -:  131:
function _ZN4mlir3pdl9OperandOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  132:LogicalResult OperandOp::verify() { return verifyHasBindingUse(*this); }
call    0 never executed
call    1 never executed
call    2 never executed
        -:  133:
        -:  134://===----------------------------------------------------------------------===//
        -:  135:// pdl::OperandsOp
        -:  136://===----------------------------------------------------------------------===//
        -:  137:
function _ZN4mlir3pdl10OperandsOp6verifyEv called 0 returned 0% blocks executed 0%
     312*:  138:LogicalResult OperandsOp::verify() { return verifyHasBindingUse(*this); }
call    0 returned 100%
call    1 never executed
call    2 never executed
        -:  139:
        -:  140://===----------------------------------------------------------------------===//
        -:  141:// pdl::OperationOp
        -:  142://===----------------------------------------------------------------------===//
        -:  143:
function _ZL26parseOperationOpAttributesRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS_9ArrayAttrE called 624 returned 100% blocks executed 50%
      624:  144:static ParseResult parseOperationOpAttributes(
        -:  145:    OpAsmParser &p,
        -:  146:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &attrOperands,
        -:  147:    ArrayAttr &attrNamesAttr) {
      624:  148:  Builder &builder = p.getBuilder();
call    0 returned 100%
      624:  149:  SmallVector<Attribute, 4> attrNames;
call    0 returned 100%
      624:  150:  if (succeeded(p.parseOptionalLBrace())) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
function _ZZL26parseOperationOpAttributesRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS_9ArrayAttrEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  151:    auto parseOperands = [&]() {
    #####:  152:      StringAttr nameAttr;
    #####:  153:      OpAsmParser::UnresolvedOperand operand;
call    0 never executed
    #####:  154:      if (p.parseAttribute(nameAttr) || p.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  155:          p.parseOperand(operand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  156:        return failure();
    #####:  157:      attrNames.push_back(nameAttr);
call    0 never executed
    #####:  158:      attrOperands.push_back(operand);
call    0 never executed
    #####:  159:      return success();
    #####:  160:    };
    #####:  161:    if (p.parseCommaSeparatedList(parseOperands) || p.parseRBrace())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  162:      return failure();
        -:  163:  }
      624:  164:  attrNamesAttr = builder.getArrayAttr(attrNames);
call    0 returned 100%
      624:  165:  return success();
        -:  166:}
        -:  167:
        -:  168:static void printOperationOpAttributes(OpAsmPrinter &p, OperationOp op,
        -:  169:                                       OperandRange attrArgs,
        -:  170:                                       ArrayAttr attrNames) {
        -:  171:  if (attrNames.empty())
        -:  172:    return;
        -:  173:  p << " {";
        -:  174:  interleaveComma(llvm::seq<int>(0, attrNames.size()), p,
function _ZZL26printOperationOpAttributesRN4mlir12OpAsmPrinterENS_3pdl11OperationOpENS_12OperandRangeENS_9ArrayAttrEENKUliE_clEi called 0 returned 0% blocks executed 0%
    #####:  175:                  [&](int i) { p << attrNames[i] << " = " << attrArgs[i]; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  176:  p << '}';
        -:  177:}
        -:  178:
        -:  179:/// Verifies that the result types of this operation, defined within a
        -:  180:/// `pdl.rewrite`, can be inferred.
function _ZL30verifyResultTypesAreInferrableN4mlir3pdl11OperationOpENS_12OperandRangeE called 0 returned 0% blocks executed 0%
    #####:  181:static LogicalResult verifyResultTypesAreInferrable(OperationOp op,
        -:  182:                                                    OperandRange resultTypes) {
        -:  183:  // Functor that returns if the given use can be used to infer a type.
    #####:  184:  Block *rewriterBlock = op->getBlock();
call    0 never executed
function _ZZL30verifyResultTypesAreInferrableN4mlir3pdl11OperationOpENS_12OperandRangeEENKUlRNS_9OpOperandEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  185:  auto canInferTypeFromUse = [&](OpOperand &use) {
        -:  186:    // If the use is within a ReplaceOp and isn't the operation being replaced
        -:  187:    // (i.e. is not the first operand of the replacement), we can infer a type.
    #####:  188:    ReplaceOp replOpUser = dyn_cast<ReplaceOp>(use.getOwner());
call    0 never executed
    #####:  189:    if (!replOpUser || use.getOperandNumber() == 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  190:      return false;
        -:  191:    // Make sure the replaced operation was defined before this one.
    #####:  192:    Operation *replacedOp = replOpUser.getOpValue().getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  193:    return replacedOp->getBlock() != rewriterBlock ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  194:           replacedOp->isBeforeInBlock(op);
call    0 never executed
    #####:  195:  };
        -:  196:
        -:  197:  // Check to see if the uses of the operation itself can be used to infer
        -:  198:  // types.
    #####:  199:  if (llvm::any_of(op.getOp().getUses(), canInferTypeFromUse))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  200:    return success();
        -:  201:
        -:  202:  // Handle the case where the operation has no explicit result types.
    #####:  203:  if (resultTypes.empty()) {
branch  0 never executed
branch  1 never executed
        -:  204:    // If we don't know the concrete operation, don't attempt any verification.
        -:  205:    // We can't make assumptions if we don't know the concrete operation.
    #####:  206:    Optional<StringRef> rawOpName = op.getOpName();
call    0 never executed
    #####:  207:    if (!rawOpName)
branch  0 never executed
branch  1 never executed
    #####:  208:      return success();
    #####:  209:    Optional<RegisteredOperationName> opName =
call    0 never executed
    #####:  210:        RegisteredOperationName::lookup(*rawOpName, op.getContext());
call    0 never executed
    #####:  211:    if (!opName)
branch  0 never executed
branch  1 never executed
    #####:  212:      return success();
        -:  213:
        -:  214:    // If no explicit result types were provided, check to see if the operation
        -:  215:    // expected at least one result. This doesn't cover all cases, but this
        -:  216:    // should cover many cases in which the user intended to infer the results
        -:  217:    // of an operation, but it isn't actually possible.
    #####:  218:    bool expectedAtLeastOneResult =
call    0 never executed
    #####:  219:        !opName->hasTrait<OpTrait::ZeroResults>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  220:        !opName->hasTrait<OpTrait::VariadicResults>();
call    0 never executed
    #####:  221:    if (expectedAtLeastOneResult) {
    #####:  222:      return op
    #####:  223:          .emitOpError("must have inferable or constrained result types when "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  224:                       "nested within `pdl.rewrite`")
    #####:  225:          .attachNote()
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  226:          .append("operation is created in a non-inferrable context, but '",
    #####:  227:                  *opName, "' does not implement InferTypeOpInterface");
call    0 never executed
call    1 never executed
        -:  228:    }
    #####:  229:    return success();
        -:  230:  }
        -:  231:
        -:  232:  // Otherwise, make sure each of the types can be inferred.
    #####:  233:  for (const auto &it : llvm::enumerate(resultTypes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  234:    Operation *resultTypeOp = it.value().getDefiningOp();
call    0 never executed
    #####:  235:    assert(resultTypeOp && "expected valid result type operation");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  236:
        -:  237:    // If the op was defined by a `apply_native_rewrite`, it is guaranteed to be
        -:  238:    // usable.
    #####:  239:    if (isa<ApplyNativeRewriteOp>(resultTypeOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  240:      continue;
call    0 never executed
        -:  241:
        -:  242:    // If the type operation was defined in the matcher and constrains an
        -:  243:    // operand or the result of an input operation, it can be used.
    #####:  244:    auto constrainsInput = [rewriterBlock](Operation *user) {
        -:  245:      return user->getBlock() != rewriterBlock &&
        -:  246:             isa<OperandOp, OperandsOp, OperationOp>(user);
    #####:  247:    };
    #####:  248:    if (TypeOp typeOp = dyn_cast<TypeOp>(resultTypeOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  249:      if (typeOp.getConstantType() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  250:          llvm::any_of(typeOp->getUsers(), constrainsInput))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  251:        continue;
    #####:  252:    } else if (TypesOp typeOp = dyn_cast<TypesOp>(resultTypeOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:      if (typeOp.getConstantTypes() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  254:          llvm::any_of(typeOp->getUsers(), constrainsInput))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  255:        continue;
        -:  256:    }
        -:  257:
    #####:  258:    return op
    #####:  259:        .emitOpError("must have inferable or constrained result types when "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  260:                     "nested within `pdl.rewrite`")
    #####:  261:        .attachNote()
call    0 never executed
    #####:  262:        .append("result type #", it.index(), " was not constrained");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  263:  }
    #####:  264:  return success();
        -:  265:}
        -:  266:
function _ZN4mlir3pdl11OperationOp6verifyEv called 624 returned 100% blocks executed 43%
      624:  267:LogicalResult OperationOp::verify() {
     1248:  268:  bool isWithinRewrite = isa<RewriteOp>((*this)->getParentOp());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     624*:  269:  if (isWithinRewrite && !getOpName())
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  270:    return emitOpError("must have an operation name when nested within "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  271:                       "a `pdl.rewrite`");
call    0 never executed
      624:  272:  ArrayAttr attributeNames = getAttributeValueNamesAttr();
call    0 returned 100%
      624:  273:  auto attributeValues = getAttributeValues();
call    0 returned 100%
      624:  274:  if (attributeNames.size() != attributeValues.size()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  275:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
        -:  276:           << "expected the same number of attribute values and attribute "
    #####:  277:              "names, got "
call    0 never executed
    #####:  278:           << attributeNames.size() << " names and " << attributeValues.size()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  279:           << " values";
call    0 never executed
        -:  280:  }
        -:  281:
        -:  282:  // If the operation is within a rewrite body and doesn't have type inference,
        -:  283:  // ensure that the result types can be resolved.
      624:  284:  if (isWithinRewrite && !mightHaveTypeInference()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  285:    if (failed(verifyResultTypesAreInferrable(*this, getTypeValues())))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  286:      return failure();
        -:  287:  }
        -:  288:
      624:  289:  return verifyHasBindingUse(*this);
call    0 returned 100%
        -:  290:}
        -:  291:
function _ZN4mlir3pdl11OperationOp16hasTypeInferenceEv called 312 returned 100% blocks executed 88%
      312:  292:bool OperationOp::hasTypeInference() {
      312:  293:  if (Optional<StringRef> rawOpName = getOpName()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      312:  294:    OperationName opName(*rawOpName, getContext());
call    0 returned 100%
call    1 returned 100%
      312:  295:    return opName.hasInterface<InferTypeOpInterface>();
call    0 returned 100%
        -:  296:  }
    #####:  297:  return false;
        -:  298:}
        -:  299:
function _ZN4mlir3pdl11OperationOp22mightHaveTypeInferenceEv called 312 returned 100% blocks executed 88%
      312:  300:bool OperationOp::mightHaveTypeInference() {
      312:  301:  if (Optional<StringRef> rawOpName = getOpName()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      312:  302:    OperationName opName(*rawOpName, getContext());
call    0 returned 100%
call    1 returned 100%
      312:  303:    return opName.mightHaveInterface<InferTypeOpInterface>();
call    0 returned 100%
        -:  304:  }
    #####:  305:  return false;
        -:  306:}
        -:  307:
        -:  308://===----------------------------------------------------------------------===//
        -:  309:// pdl::PatternOp
        -:  310://===----------------------------------------------------------------------===//
        -:  311:
function _ZN4mlir3pdl9PatternOp13verifyRegionsEv called 312 returned 100% blocks executed 63%
      312:  312:LogicalResult PatternOp::verifyRegions() {
      312:  313:  Region &body = getBodyRegion();
call    0 returned 100%
      312:  314:  Operation *term = body.front().getTerminator();
call    0 returned 100%
call    1 returned 100%
      312:  315:  auto rewriteOp = dyn_cast<RewriteOp>(term);
call    0 returned 100%
      312:  316:  if (!rewriteOp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  317:    return emitOpError("expected body to terminate with `pdl.rewrite`")
call    0 never executed
call    1 never executed
    #####:  318:        .attachNote(term->getLoc())
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  319:        .append("see terminator defined here");
call    0 never executed
        -:  320:  }
        -:  321:
        -:  322:  // Check that all values defined in the top-level pattern belong to the PDL
        -:  323:  // dialect.
function _ZZN4mlir3pdl9PatternOp13verifyRegionsEvENKUlPNS_9OperationEE_clES3_.isra.0 called 2028 returned 100% blocks executed 46%
     2028:  324:  WalkResult result = body.walk([&](Operation *op) -> WalkResult {
     2028:  325:    if (!isa_and_nonnull<PDLDialect>(op->getDialect())) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  326:      emitOpError("expected only `pdl` operations within the pattern body")
call    0 never executed
call    1 never executed
    #####:  327:          .attachNote(op->getLoc())
call    0 never executed
call    1 never executed
    #####:  328:          .append("see non-`pdl` operation defined here");
call    0 never executed
    #####:  329:      return WalkResult::interrupt();
        -:  330:    }
     2028:  331:    return WalkResult::advance();
      312:  332:  });
call    0 returned 100%
      312:  333:  if (result.wasInterrupted())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  334:    return failure();
        -:  335:
        -:  336:  // Check that there is at least one operation.
      312:  337:  if (body.front().getOps<OperationOp>().empty())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  338:    return emitOpError("the pattern must contain at least one `pdl.operation`");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  339:
        -:  340:  // Determine if the operations within the pdl.pattern form a connected
        -:  341:  // component. This is determined by starting the search from the first
        -:  342:  // operand/result/operation and visiting their users / parents / operands.
        -:  343:  // We limit our attention to operations that have a user in pdl.rewrite,
        -:  344:  // those that do not will be detected via other means (expected bindable
        -:  345:  // user).
      312:  346:  bool first = true;
      312:  347:  DenseSet<Operation *> visited;
call    0 returned 100%
     1716:  348:  for (Operation &op : body.front()) {
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
call    3 returned 100%
        -:  349:    // The following are the operations forming the connected component.
     1404:  350:    if (!isa<OperandOp, OperandsOp, ResultOp, ResultsOp, OperationOp>(op))
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
      780:  351:      continue;
        -:  352:
        -:  353:    // Determine if the operation has a user in `pdl.rewrite`.
      624:  354:    bool hasUserInRewrite = false;
     1248:  355:    for (Operation *user : op.getUsers()) {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
      624:  356:      Region *region = user->getParentRegion();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      624:  357:      if (isa<RewriteOp>(user) ||
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
      312:  358:          (region && isa<RewriteOp>(region->getParentOp()))) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  359:        hasUserInRewrite = true;
        -:  360:        break;
        -:  361:      }
        -:  362:    }
        -:  363:
        -:  364:    // If the operation does not have a user in `pdl.rewrite`, ignore it.
      624:  365:    if (!hasUserInRewrite)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      312:  366:      continue;
        -:  367:
      312:  368:    if (first) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  369:      // For the first operation, invoke visit.
      312:  370:      visit(&op, visited);
      312:  371:      first = false;
call    0 returned 100%
    #####:  372:    } else if (!visited.count(&op)) {
call    0 never executed
        -:  373:      // For the subsequent operations, check if already visited.
    #####:  374:      return emitOpError("the operations must form a connected component")
call    0 never executed
call    1 never executed
    #####:  375:          .attachNote(op.getLoc())
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  376:          .append("see a disconnected value / operation here");
call    0 never executed
        -:  377:    }
        -:  378:  }
        -:  379:
      312:  380:  return success();
call    0 returned 100%
        -:  381:}
        -:  382:
function _ZN4mlir3pdl9PatternOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm8OptionalItEENS7_INS6_9StringRefEEE called 0 returned 0% blocks executed 0%
    #####:  383:void PatternOp::build(OpBuilder &builder, OperationState &state,
        -:  384:                      Optional<uint16_t> benefit, Optional<StringRef> name) {
    #####:  385:  build(builder, state, builder.getI16IntegerAttr(benefit ? *benefit : 0),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  386:        name ? builder.getStringAttr(*name) : StringAttr());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  387:  state.regions[0]->emplaceBlock();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  388:}
        -:  389:
        -:  390:/// Returns the rewrite operation of this pattern.
function _ZN4mlir3pdl9PatternOp11getRewriterEv called 1248 returned 100% blocks executed 100%
     1248:  391:RewriteOp PatternOp::getRewriter() {
     1248:  392:  return cast<RewriteOp>(getBodyRegion().front().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  393:}
        -:  394:
        -:  395:/// The default dialect is `pdl`.
function _ZN4mlir3pdl9PatternOp17getDefaultDialectEv called 0 returned 0% blocks executed 0%
     624*:  396:StringRef PatternOp::getDefaultDialect() {
     624*:  397:  return PDLDialect::getDialectNamespace();
        -:  398:}
        -:  399:
        -:  400://===----------------------------------------------------------------------===//
        -:  401:// pdl::ReplaceOp
        -:  402://===----------------------------------------------------------------------===//
        -:  403:
function _ZN4mlir3pdl9ReplaceOp6verifyEv called 312 returned 100% blocks executed 50%
      312:  404:LogicalResult ReplaceOp::verify() {
     624*:  405:  if (getReplOperation() && !getReplValues().empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  406:    return emitOpError() << "expected no replacement values to be provided"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  407:                            " when the replacement operation is present";
call    0 never executed
      312:  408:  return success();
        -:  409:}
        -:  410:
        -:  411://===----------------------------------------------------------------------===//
        -:  412:// pdl::ResultsOp
        -:  413://===----------------------------------------------------------------------===//
        -:  414:
function _ZL21parseResultsValueTypeRN4mlir11OpAsmParserENS_11IntegerAttrERNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  415:static ParseResult parseResultsValueType(OpAsmParser &p, IntegerAttr index,
        -:  416:                                         Type &resultType) {
    #####:  417:  if (!index) {
branch  0 never executed
branch  1 never executed
    #####:  418:    resultType = RangeType::get(p.getBuilder().getType<ValueType>());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  419:    return success();
        -:  420:  }
    #####:  421:  if (p.parseArrow() || p.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  422:    return failure();
    #####:  423:  return success();
        -:  424:}
        -:  425:
        -:  426:static void printResultsValueType(OpAsmPrinter &p, ResultsOp op,
        -:  427:                                  IntegerAttr index, Type resultType) {
        -:  428:  if (index)
        -:  429:    p << " -> " << resultType;
        -:  430:}
        -:  431:
function _ZN4mlir3pdl9ResultsOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  432:LogicalResult ResultsOp::verify() {
    #####:  433:  if (!getIndex() && getType().isa<pdl::ValueType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  434:    return emitOpError() << "expected `pdl.range<value>` result type when "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  435:                            "no index is specified, but got: "
call    0 never executed
    #####:  436:                         << getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  437:  }
    #####:  438:  return success();
        -:  439:}
        -:  440:
        -:  441://===----------------------------------------------------------------------===//
        -:  442:// pdl::RewriteOp
        -:  443://===----------------------------------------------------------------------===//
        -:  444:
function _ZN4mlir3pdl9RewriteOp13verifyRegionsEv called 312 returned 100% blocks executed 29%
      312:  445:LogicalResult RewriteOp::verifyRegions() {
      312:  446:  Region &rewriteRegion = getBodyRegion();
call    0 returned 100%
        -:  447:
        -:  448:  // Handle the case where the rewrite is external.
      312:  449:  if (getName()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  450:    if (!rewriteRegion.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  451:      return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  452:             << "expected rewrite region to be empty when rewrite is external";
call    0 never executed
        -:  453:    }
    #####:  454:    return success();
        -:  455:  }
        -:  456:
        -:  457:  // Otherwise, check that the rewrite region only contains a single block.
      312:  458:  if (rewriteRegion.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  459:    return emitOpError() << "expected rewrite region to be non-empty if "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  460:                            "external name is not specified";
call    0 never executed
        -:  461:  }
        -:  462:
        -:  463:  // Check that no additional arguments were provided.
      312:  464:  if (!getExternalArgs().empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  465:    return emitOpError() << "expected no external arguments when the "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  466:                            "rewrite is specified inline";
call    0 never executed
        -:  467:  }
        -:  468:
      312:  469:  return success();
        -:  470:}
        -:  471:
        -:  472:/// The default dialect is `pdl`.
function _ZN4mlir3pdl9RewriteOp17getDefaultDialectEv called 0 returned 0% blocks executed 0%
     624*:  473:StringRef RewriteOp::getDefaultDialect() {
     624*:  474:  return PDLDialect::getDialectNamespace();
        -:  475:}
        -:  476:
        -:  477://===----------------------------------------------------------------------===//
        -:  478:// pdl::TypeOp
        -:  479://===----------------------------------------------------------------------===//
        -:  480:
function _ZN4mlir3pdl6TypeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  481:LogicalResult TypeOp::verify() {
    #####:  482:  if (!getConstantTypeAttr())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  483:    return verifyHasBindingUse(*this);
call    0 never executed
    #####:  484:  return success();
        -:  485:}
        -:  486:
        -:  487://===----------------------------------------------------------------------===//
        -:  488:// pdl::TypesOp
        -:  489://===----------------------------------------------------------------------===//
        -:  490:
function _ZN4mlir3pdl7TypesOp6verifyEv called 312 returned 100% blocks executed 80%
      312:  491:LogicalResult TypesOp::verify() {
      312:  492:  if (!getConstantTypesAttr())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      312:  493:    return verifyHasBindingUse(*this);
call    0 returned 100%
    #####:  494:  return success();
        -:  495:}
        -:  496:
        -:  497://===----------------------------------------------------------------------===//
        -:  498:// TableGen'd op method definitions
        -:  499://===----------------------------------------------------------------------===//
        -:  500:
        -:  501:#define GET_OP_CLASSES
        -:  502:#include "mlir/Dialect/PDL/IR/PDLOps.cpp.inc"
