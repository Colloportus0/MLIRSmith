        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVConversion.dir/SPIRVConversion.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVConversion.dir/SPIRVConversion.cpp.gcda
        -:    0:Runs:116171
        -:    1://===- SPIRVConversion.cpp - SPIR-V Conversion Utilities ------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements utilities used to lower to SPIR-V dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
        -:   14:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   15:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVEnums.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   18:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   19:#include "mlir/Transforms/DialectConversion.h"
        -:   20:#include "llvm/ADT/Sequence.h"
        -:   21:#include "llvm/ADT/StringExtras.h"
        -:   22:#include "llvm/Support/Debug.h"
        -:   23:
        -:   24:#include <functional>
        -:   25:
        -:   26:#define DEBUG_TYPE "mlir-spirv-conversion"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:
        -:   30://===----------------------------------------------------------------------===//
        -:   31:// Utility functions
        -:   32://===----------------------------------------------------------------------===//
        -:   33:
        -:   34:/// Checks that `candidates` extension requirements are possible to be satisfied
        -:   35:/// with the given `targetEnv`.
        -:   36:///
        -:   37:///  `candidates` is a vector of vector for extension requirements following
        -:   38:/// ((Extension::A OR Extension::B) AND (Extension::C OR Extension::D))
        -:   39:/// convention.
        -:   40:template <typename LabelT>
    42323:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
   42323*:   44:  for (const auto &ors : candidates) {
      23*:   45:    if (targetEnv.allows(ors))
        -:   46:      continue;
        -:   47:
      23*:   48:    LLVM_DEBUG({
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
    42323:   57:    return failure();
        -:   58:  }
    42323:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE called 40450 returned 100% blocks executed 29%
    40450:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
   40450*:   44:  for (const auto &ors : candidates) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      23*:   45:    if (targetEnv.allows(ors))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   46:      continue;
        -:   47:
      23*:   48:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
    40450:   57:    return failure();
        -:   58:  }
    40450:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE called 60 returned 100% blocks executed 14%
       60:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
      60*:   44:  for (const auto &ors : candidates) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
       60:   57:    return failure();
        -:   58:  }
       60:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_9ExtensionEEEEE called 1813 returned 100% blocks executed 14%
     1813:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
    1813*:   44:  for (const auto &ors : candidates) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
     1813:   57:    return failure();
        -:   58:  }
     1813:   59:  return success();
        -:   60:}
------------------
        -:   61:
        -:   62:/// Checks that `candidates`capability requirements are possible to be satisfied
        -:   63:/// with the given `isAllowedFn`.
        -:   64:///
        -:   65:///  `candidates` is a vector of vector for capability requirements following
        -:   66:/// ((Capability::A OR Capability::B) AND (Capability::C OR Capability::D))
        -:   67:/// convention.
        -:   68:template <typename LabelT>
    44360:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
   44613*:   72:  for (const auto &ors : candidates) {
    2668*:   73:    if (targetEnv.allows(ors))
        -:   74:      continue;
        -:   75:
    2415*:   76:    LLVM_DEBUG({
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
    44360:   85:    return failure();
        -:   86:  }
    44360:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE called 40427 returned 100% blocks executed 32%
    40427:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    40680:   72:  for (const auto &ors : candidates) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      608:   73:    if (targetEnv.allows(ors))
call    0 returned 100%
branch  1 taken 42% (fallthrough)
branch  2 taken 58%
        -:   74:      continue;
        -:   75:
     355*:   76:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
    40427:   85:    return failure();
        -:   86:  }
    40427:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE called 209 returned 100% blocks executed 29%
      209:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
     209*:   72:  for (const auto &ors : candidates) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
     149*:   73:    if (targetEnv.allows(ors))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   74:      continue;
        -:   75:
     149*:   76:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
      209:   85:    return failure();
        -:   86:  }
      209:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_10CapabilityEEEEE called 3724 returned 100% blocks executed 29%
     3724:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    3724*:   72:  for (const auto &ors : candidates) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    1911*:   73:    if (targetEnv.allows(ors))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   74:      continue;
        -:   75:
    1911*:   76:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
     3724:   85:    return failure();
        -:   86:  }
     3724:   87:  return success();
        -:   88:}
------------------
        -:   89:
        -:   90:/// Returns true if the given `storageClass` needs explicit layout when used in
        -:   91:/// Shader environments.
      20*:   92:static bool needsExplicitLayout(spirv::StorageClass storageClass) {
      20*:   93:  switch (storageClass) {
        -:   94:  case spirv::StorageClass::PhysicalStorageBuffer:
        -:   95:  case spirv::StorageClass::PushConstant:
        -:   96:  case spirv::StorageClass::StorageBuffer:
        -:   97:  case spirv::StorageClass::Uniform:
        -:   98:    return true;
    #####:   99:  default:
    #####:  100:    return false;
        -:  101:  }
        -:  102:}
        -:  103:
        -:  104:/// Wraps the given `elementType` in a struct and gets the pointer to the
        -:  105:/// struct. This is used to satisfy Vulkan interface requirements.
        -:  106:static spirv::PointerType
function _ZL25wrapInStructAndGetPointerN4mlir4TypeENS_5spirv12StorageClassE called 10 returned 100% blocks executed 80%
       10:  107:wrapInStructAndGetPointer(Type elementType, spirv::StorageClass storageClass) {
      10*:  108:  auto structType = needsExplicitLayout(storageClass)
branch  0 taken 100%
branch  1 taken 0%
       10:  109:                        ? spirv::StructType::get(elementType, /*offsetInfo=*/0)
call    0 returned 100%
    #####:  110:                        : spirv::StructType::get(elementType);
call    0 never executed
       10:  111:  return spirv::PointerType::get(structType, storageClass);
call    0 returned 100%
        -:  112:}
        -:  113:
        -:  114://===----------------------------------------------------------------------===//
        -:  115:// Type Conversion
        -:  116://===----------------------------------------------------------------------===//
        -:  117:
function _ZNK4mlir18SPIRVTypeConverter12getIndexTypeEv called 332 returned 100% blocks executed 100%
      332:  118:Type SPIRVTypeConverter::getIndexType() const {
      332:  119:  return IntegerType::get(getContext(), options.use64bitIndex ? 64 : 32);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:}
        -:  121:
function _ZNK4mlir18SPIRVTypeConverter10getContextEv called 0 returned 0% blocks executed 0%
     332*:  122:MLIRContext *SPIRVTypeConverter::getContext() const {
     332*:  123:  return targetEnv.getAttr().getContext();
call    0 never executed
call    1 returned 100%
call    2 returned 100%
        -:  124:}
        -:  125:
function _ZN4mlir18SPIRVTypeConverter6allowsENS_5spirv10CapabilityE called 13 returned 100% blocks executed 100%
       30:  126:bool SPIRVTypeConverter::allows(spirv::Capability capability) {
       13:  127:  return targetEnv.allows(capability);
call    0 returned 100%
        -:  128:}
        -:  129:
        -:  130:// TODO: This is a utility function that should probably be exposed by the
        -:  131:// SPIR-V dialect. Keeping it local till the use case arises.
function _ZL15getTypeNumBytesRKN4mlir22SPIRVConversionOptionsENS_4TypeE called 1742 returned 100% blocks executed 76%
     1742:  132:static Optional<int64_t> getTypeNumBytes(const SPIRVConversionOptions &options,
        -:  133:                                         Type type) {
     1742:  134:  if (type.isa<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
     1283:  135:    auto bitWidth = type.getIntOrFloatBitWidth();
call    0 returned 100%
        -:  136:    // According to the SPIR-V spec:
        -:  137:    // "There is no physical size or bit pattern defined for values with boolean
        -:  138:    // type. If they are stored (in conjunction with OpVariable), they can only
        -:  139:    // be used with logical addressing operations, not physical, and only with
        -:  140:    // non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup,
        -:  141:    // Private, Function, Input, and Output."
     1283:  142:    if (bitWidth == 1)
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
      176:  143:      return llvm::None;
     1107:  144:    return bitWidth / 8;
        -:  145:  }
        -:  146:
      459:  147:  if (auto vecType = type.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  148:    auto elementSize = getTypeNumBytes(options, vecType.getElementType());
call    0 never executed
call    1 never executed
    #####:  149:    if (!elementSize)
branch  0 never executed
branch  1 never executed
    #####:  150:      return llvm::None;
    #####:  151:    return vecType.getNumElements() * *elementSize;
call    0 never executed
        -:  152:  }
        -:  153:
      459:  154:  if (auto memRefType = type.dyn_cast<MemRefType>()) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        -:  155:    // TODO: Layout should also be controlled by the ABI attributes. For now
        -:  156:    // using the layout from MemRef.
        8:  157:    int64_t offset;
       16:  158:    SmallVector<int64_t, 4> strides;
call    0 returned 100%
        8:  159:    if (!memRefType.hasStaticShape() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        8:  160:        failed(getStridesAndOffset(memRefType, strides, offset)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  161:      return llvm::None;
        -:  162:
        -:  163:    // To get the size of the memref object in memory, the total size is the
        -:  164:    // max(stride * dimension-size) computed for all dimensions times the size
        -:  165:    // of the element.
        8:  166:    auto elementSize = getTypeNumBytes(options, memRefType.getElementType());
call    0 returned 100%
call    1 returned 100%
        8:  167:    if (!elementSize)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  168:      return llvm::None;
        -:  169:
        8:  170:    if (memRefType.getRank() == 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  171:      return elementSize;
        -:  172:
        8:  173:    auto dims = memRefType.getShape();
call    0 returned 100%
        8:  174:    if (llvm::is_contained(dims, ShapedType::kDynamicSize) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  175:        offset == MemRefType::getDynamicStrideOrOffset() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       8*:  176:        llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  177:      return llvm::None;
        -:  178:
        8:  179:    int64_t memrefSize = -1;
       26:  180:    for (const auto &shape : enumerate(dims))
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
       26:  181:      memrefSize = std::max(memrefSize, shape.value() * strides[shape.index()]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 44% (fallthrough)
branch  3 taken 56%
call    4 returned 100%
        -:  182:
        8:  183:    return (offset + memrefSize) * *elementSize;
        -:  184:  }
        -:  185:
      451:  186:  if (auto tensorType = type.dyn_cast<TensorType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      451:  187:    if (!tensorType.hasStaticShape())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  188:      return llvm::None;
        -:  189:
      451:  190:    auto elementSize = getTypeNumBytes(options, tensorType.getElementType());
call    0 returned 100%
call    1 returned 100%
      451:  191:    if (!elementSize)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
       88:  192:      return llvm::None;
        -:  193:
      363:  194:    int64_t size = *elementSize;
call    0 returned 100%
     1091:  195:    for (auto shape : tensorType.getShape())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
      728:  196:      size *= shape;
        -:  197:
      363:  198:    return size;
        -:  199:  }
        -:  200:
        -:  201:  // TODO: Add size computation for other types.
    #####:  202:  return llvm::None;
        -:  203:}
        -:  204:
        -:  205:/// Converts a scalar `type` to a suitable type under the given `targetEnv`.
        -:  206:static Type convertScalarType(const spirv::TargetEnv &targetEnv,
        -:  207:                              const SPIRVConversionOptions &options,
        -:  208:                              spirv::ScalarType type,
        -:  209:                              Optional<spirv::StorageClass> storageClass = {}) {
        -:  210:  // Get extension and capability requirements for the given type.
        -:  211:  SmallVector<ArrayRef<spirv::Extension>, 1> extensions;
        -:  212:  SmallVector<ArrayRef<spirv::Capability>, 2> capabilities;
        -:  213:  type.getExtensions(extensions, storageClass);
        -:  214:  type.getCapabilities(capabilities, storageClass);
        -:  215:
        -:  216:  // If all requirements are met, then we can accept this type as-is.
        -:  217:  if (succeeded(checkCapabilityRequirements(type, targetEnv, capabilities)) &&
        -:  218:      succeeded(checkExtensionRequirements(type, targetEnv, extensions)))
        -:  219:    return type;
        -:  220:
        -:  221:  // Otherwise we need to adjust the type, which really means adjusting the
        -:  222:  // bitwidth given this is a scalar type.
        -:  223:
        -:  224:  if (!options.emulateNon32BitScalarTypes)
        -:  225:    return nullptr;
        -:  226:
        -:  227:  if (auto floatType = type.dyn_cast<FloatType>()) {
        -:  228:    LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
        -:  229:    return Builder(targetEnv.getContext()).getF32Type();
        -:  230:  }
        -:  231:
        -:  232:  auto intType = type.cast<IntegerType>();
        -:  233:  LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
        -:  234:  return IntegerType::get(targetEnv.getContext(), /*width=*/32,
        -:  235:                          intType.getSignedness());
        -:  236:}
        -:  237:
        -:  238:/// Converts a vector `type` to a suitable type under the given `targetEnv`.
function _ZL17convertVectorTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10VectorTypeEN4llvm8OptionalINS0_12StorageClassEEE called 1993 returned 100% blocks executed 78%
     1993:  239:static Type convertVectorType(const spirv::TargetEnv &targetEnv,
        -:  240:                              const SPIRVConversionOptions &options,
        -:  241:                              VectorType type,
        -:  242:                              Optional<spirv::StorageClass> storageClass = {}) {
     1993:  243:  auto scalarType = type.getElementType().cast<spirv::ScalarType>();
call    0 returned 100%
call    1 returned 100%
     1993:  244:  if (type.getRank() <= 1 && type.getNumElements() == 1)
call    0 returned 100%
branch  1 taken 36% (fallthrough)
branch  2 taken 64%
call    3 returned 100%
branch  4 taken 2% (fallthrough)
branch  5 taken 98%
       12:  245:    return convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 returned 100%
        -:  246:
     1981:  247:  if (!spirv::CompositeType::isValid(type)) {
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
        -:  248:    // TODO: Vector types with more than four elements can be translated into
        -:  249:    // array types.
    1772*:  250:    LLVM_DEBUG(llvm::dbgs() << type << " illegal: > 4-element unimplemented\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
     1772:  251:    return nullptr;
        -:  252:  }
        -:  253:
        -:  254:  // Get extension and capability requirements for the given type.
      209:  255:  SmallVector<ArrayRef<spirv::Extension>, 1> extensions;
call    0 returned 100%
      209:  256:  SmallVector<ArrayRef<spirv::Capability>, 2> capabilities;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      209:  257:  type.cast<spirv::CompositeType>().getExtensions(extensions, storageClass);
call    0 returned 100%
call    1 returned 100%
      209:  258:  type.cast<spirv::CompositeType>().getCapabilities(capabilities, storageClass);
call    0 returned 100%
call    1 returned 100%
        -:  259:
        -:  260:  // If all requirements are met, then we can accept this type as-is.
      209:  261:  if (succeeded(checkCapabilityRequirements(type, targetEnv, capabilities)) &&
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
       60:  262:      succeeded(checkExtensionRequirements(type, targetEnv, extensions)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       60:  263:    return type;
        -:  264:
      149:  265:  auto elementType =
      149:  266:      convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 returned 100%
      149:  267:  if (elementType)
branch  0 taken 100%
branch  1 taken 0%
      149:  268:    return VectorType::get(type.getShape(), elementType);
call    0 returned 100%
call    1 returned 100%
    #####:  269:  return nullptr;
        -:  270:}
        -:  271:
        -:  272:/// Converts a tensor `type` to a suitable type under the given `targetEnv`.
        -:  273:///
        -:  274:/// Note that this is mainly for lowering constant tensors. In SPIR-V one can
        -:  275:/// create composite constants with OpConstantComposite to embed relative large
        -:  276:/// constant values and use OpCompositeExtract and OpCompositeInsert to
        -:  277:/// manipulate, like what we do for vectors.
function _ZL17convertTensorTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10TensorTypeE called 454 returned 100% blocks executed 44%
      454:  278:static Type convertTensorType(const spirv::TargetEnv &targetEnv,
        -:  279:                              const SPIRVConversionOptions &options,
        -:  280:                              TensorType type) {
        -:  281:  // TODO: Handle dynamic shapes.
      454:  282:  if (!type.hasStaticShape()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
       3*:  283:    LLVM_DEBUG(llvm::dbgs()
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  284:               << type << " illegal: dynamic shape unimplemented\n");
        3:  285:    return nullptr;
        -:  286:  }
        -:  287:
      451:  288:  auto scalarType = type.getElementType().dyn_cast<spirv::ScalarType>();
call    0 returned 100%
call    1 returned 100%
      451:  289:  if (!scalarType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  290:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  291:               << type << " illegal: cannot convert non-scalar element type\n");
    #####:  292:    return nullptr;
        -:  293:  }
        -:  294:
      451:  295:  Optional<int64_t> scalarSize = getTypeNumBytes(options, scalarType);
call    0 returned 100%
      451:  296:  Optional<int64_t> tensorSize = getTypeNumBytes(options, type);
call    0 returned 100%
      451:  297:  if (!scalarSize || !tensorSize) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      88*:  298:    LLVM_DEBUG(llvm::dbgs()
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  299:               << type << " illegal: cannot deduce element count\n");
       88:  300:    return nullptr;
        -:  301:  }
        -:  302:
      363:  303:  auto arrayElemCount = *tensorSize / *scalarSize;
call    0 returned 100%
      363:  304:  auto arrayElemType = convertScalarType(targetEnv, options, scalarType);
call    0 returned 100%
      363:  305:  if (!arrayElemType)
branch  0 taken 0%
branch  1 taken 100%
    #####:  306:    return nullptr;
      363:  307:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 returned 100%
      363:  308:  if (!arrayElemSize) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  309:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  310:               << type << " illegal: cannot deduce converted element size\n");
    #####:  311:    return nullptr;
        -:  312:  }
        -:  313:
      363:  314:  return spirv::ArrayType::get(arrayElemType, arrayElemCount);
call    0 returned 100%
        -:  315:}
        -:  316:
function _ZL21convertBoolMemrefTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10MemRefTypeENS0_12StorageClassE called 2 returned 100% blocks executed 44%
        2:  317:static Type convertBoolMemrefType(const spirv::TargetEnv &targetEnv,
        -:  318:                                  const SPIRVConversionOptions &options,
        -:  319:                                  MemRefType type,
        -:  320:                                  spirv::StorageClass storageClass) {
        2:  321:  unsigned numBoolBits = options.boolNumBits;
        2:  322:  if (numBoolBits != 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  323:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  324:               << "using non-8-bit storage for bool types unimplemented");
    #####:  325:    return nullptr;
        -:  326:  }
        2:  327:  auto elementType = IntegerType::get(type.getContext(), numBoolBits)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2:  328:                         .dyn_cast<spirv::ScalarType>();
        2:  329:  if (!elementType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  330:    return nullptr;
        2:  331:  Type arrayElemType =
call    0 returned 100%
        2:  332:      convertScalarType(targetEnv, options, elementType, storageClass);
call    0 returned 100%
        2:  333:  if (!arrayElemType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  334:    return nullptr;
        2:  335:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 returned 100%
        2:  336:  if (!arrayElemSize) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  337:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  338:               << type << " illegal: cannot deduce converted element size\n");
    #####:  339:    return nullptr;
        -:  340:  }
        -:  341:
        -:  342:
        2:  343:  if (!type.hasStaticShape()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  344:    // For OpenCL Kernel, dynamic shaped memrefs convert into a pointer pointing
        -:  345:    // to the element.
    #####:  346:    if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:      return spirv::PointerType::get(arrayElemType, storageClass);
call    0 never executed
    #####:  348:    int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  349:    auto arrayType = spirv::RuntimeArrayType::get(arrayElemType, stride);
call    0 never executed
        -:  350:    // For Vulkan we need extra wrapping struct and array to satisfy interface
        -:  351:    // needs.
    #####:  352:    return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  353:  }
        -:  354:
        2:  355:  int64_t memrefSize = (type.getNumElements() * numBoolBits + 7) / 8;
call    0 returned 100%
        2:  356:  auto arrayElemCount = llvm::divideCeil(memrefSize, *arrayElemSize);
call    0 returned 100%
        2:  357:  int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 taken 100%
branch  1 taken 0%
        2:  358:  auto arrayType = spirv::ArrayType::get(arrayElemType, arrayElemCount, stride);
call    0 returned 100%
        2:  359:  if (targetEnv.allows(spirv::Capability::Kernel))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  360:    return spirv::PointerType::get(arrayType, storageClass);
call    0 never executed
        2:  361:  return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 returned 100%
        -:  362:}
        -:  363:
function _ZL17convertMemrefTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10MemRefTypeE called 4195 returned 100% blocks executed 48%
     4195:  364:static Type convertMemrefType(const spirv::TargetEnv &targetEnv,
        -:  365:                              const SPIRVConversionOptions &options,
        -:  366:                              MemRefType type) {
     4195:  367:  auto attr = type.getMemorySpace().dyn_cast_or_null<spirv::StorageClassAttr>();
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
     4195:  368:  if (!attr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    4185*:  369:    LLVM_DEBUG(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  370:        llvm::dbgs()
        -:  371:        << type
        -:  372:        << " illegal: expected memory space to be a SPIR-V storage class "
        -:  373:           "attribute; please use MemorySpaceToStorageClassConverter to map "
        -:  374:           "numeric memory spaces beforehand\n");
     4185:  375:    return nullptr;
        -:  376:  }
       10:  377:  spirv::StorageClass storageClass = attr.getValue();
call    0 returned 100%
        -:  378:
       10:  379:  if (type.getElementType().isa<IntegerType>() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        5:  380:      type.getElementTypeBitWidth() == 1) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        2:  381:    return convertBoolMemrefType(targetEnv, options, type, storageClass);
call    0 returned 100%
        -:  382:  }
        -:  383:
        8:  384:  Type arrayElemType;
        8:  385:  Type elementType = type.getElementType();
call    0 returned 100%
        8:  386:  if (auto vecType = elementType.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  387:    arrayElemType =
call    0 never executed
    #####:  388:        convertVectorType(targetEnv, options, vecType, storageClass);
call    0 never executed
        8:  389:  } else if (auto scalarType = elementType.dyn_cast<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        8:  390:    arrayElemType =
call    0 returned 100%
        8:  391:        convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 returned 100%
        -:  392:  } else {
    #####:  393:    LLVM_DEBUG(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  394:        llvm::dbgs()
        -:  395:        << type
        -:  396:        << " unhandled: can only convert scalar or vector element type\n");
    #####:  397:    return nullptr;
        -:  398:  }
        8:  399:  if (!arrayElemType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  400:    return nullptr;
        -:  401:
        8:  402:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 returned 100%
        8:  403:  if (!arrayElemSize) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  404:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  405:               << type << " illegal: cannot deduce converted element size\n");
    #####:  406:    return nullptr;
        -:  407:  }
        -:  408:
        -:  409:
        8:  410:  if (!type.hasStaticShape()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  411:    // For OpenCL Kernel, dynamic shaped memrefs convert into a pointer pointing
        -:  412:    // to the element.
    #####:  413:    if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  414:      return spirv::PointerType::get(arrayElemType, storageClass);
call    0 never executed
    #####:  415:    int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  416:    auto arrayType = spirv::RuntimeArrayType::get(arrayElemType, stride);
call    0 never executed
        -:  417:    // For Vulkan we need extra wrapping struct and array to satisfy interface
        -:  418:    // needs.
    #####:  419:    return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  420:  }
        -:  421:
        8:  422:  Optional<int64_t> memrefSize = getTypeNumBytes(options, type);
call    0 returned 100%
        8:  423:  if (!memrefSize) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  424:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  425:               << type << " illegal: cannot deduce element count\n");
    #####:  426:    return nullptr;
        -:  427:  }
        -:  428:
        8:  429:  auto arrayElemCount = llvm::divideCeil(*memrefSize, *arrayElemSize);
call    0 returned 100%
        8:  430:  int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 taken 100%
branch  1 taken 0%
        8:  431:  auto arrayType = spirv::ArrayType::get(arrayElemType, arrayElemCount, stride);
call    0 returned 100%
        8:  432:  if (targetEnv.allows(spirv::Capability::Kernel))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  433:    return spirv::PointerType::get(arrayType, storageClass);
call    0 never executed
        8:  434:  return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 returned 100%
        -:  435:}
        -:  436:
function _ZN4mlir18SPIRVTypeConverterC2ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsE called 1514 returned 100% blocks executed 100%
     1514:  437:SPIRVTypeConverter::SPIRVTypeConverter(spirv::TargetEnvAttr targetAttr,
     1514:  438:                                       const SPIRVConversionOptions &options)
     1514:  439:    : targetEnv(targetAttr), options(options) {
call    0 returned 100%
call    1 returned 100%
        -:  440:  // Add conversions. The order matters here: later ones will be tried earlier.
        -:  441:
        -:  442:  // Allow all SPIR-V dialect specific types. This assumes all builtin types
        -:  443:  // adopted in the SPIR-V dialect (i.e., IntegerType, FloatType, VectorType)
        -:  444:  // were tried before.
        -:  445:  //
        -:  446:  // TODO: this assumes that the SPIR-V types are valid to use in
        -:  447:  // the given target environment, which should be the case if the whole
        -:  448:  // pipeline is driven by the same target environment. Still, we probably still
        -:  449:  // want to validate and convert to be safe.
     1516:  450:  addConversion([](spirv::SPIRVType type) { return type; });
call    0 returned 100%
call    1 returned 100%
        -:  451:
     1829:  452:  addConversion([this](IndexType /*indexType*/) { return getIndexType(); });
call    0 returned 100%
call    1 returned 100%
        -:  453:
function _ZZN4mlir18SPIRVTypeConverterC4ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsEENKUlNS_11IntegerTypeEE1_clES6_.isra.0 called 2123 returned 100% blocks executed 86%
     5760:  454:  addConversion([this](IntegerType intType) -> Optional<Type> {
call    0 returned 100%
call    1 returned 100%
     2123:  455:    if (auto scalarType = intType.dyn_cast<spirv::ScalarType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     2123:  456:      return convertScalarType(this->targetEnv, this->options, scalarType);
call    0 returned 100%
    #####:  457:    return Type();
        -:  458:  });
        -:  459:
function _ZZN4mlir18SPIRVTypeConverterC4ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsEENKUlNS_9FloatTypeEE2_clES6_.isra.0 called 1067 returned 100% blocks executed 86%
     3648:  460:  addConversion([this](FloatType floatType) -> Optional<Type> {
call    0 returned 100%
call    1 returned 100%
     1067:  461:    if (auto scalarType = floatType.dyn_cast<spirv::ScalarType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1067:  462:      return convertScalarType(this->targetEnv, this->options, scalarType);
call    0 returned 100%
    #####:  463:    return Type();
        -:  464:  });
        -:  465:
     1514:  466:  addConversion([this](VectorType vectorType) {
call    0 returned 100%
     1993:  467:    return convertVectorType(this->targetEnv, this->options, vectorType);
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
        -:  468:  });
        -:  469:
     1514:  470:  addConversion([this](TensorType tensorType) {
call    0 returned 100%
      454:  471:    return convertTensorType(this->targetEnv, this->options, tensorType);
call    0 returned 100%
        -:  472:  });
        -:  473:
     1514:  474:  addConversion([this](MemRefType memRefType) {
call    0 returned 100%
     4195:  475:    return convertMemrefType(this->targetEnv, this->options, memRefType);
call    0 returned 100%
        -:  476:  });
     1514:  477:}
        -:  478:
        -:  479://===----------------------------------------------------------------------===//
        -:  480:// func::FuncOp Conversion Patterns
        -:  481://===----------------------------------------------------------------------===//
        -:  482:
        -:  483:namespace {
        -:  484:/// A pattern for rewriting function signature to convert arguments of functions
        -:  485:/// to be of valid SPIR-V types.
        -:  486:class FuncOpConversion final : public OpConversionPattern<func::FuncOp> {
        -:  487:public:
        -:  488:  using OpConversionPattern<func::FuncOp>::OpConversionPattern;
        -:  489:
        -:  490:  LogicalResult
        -:  491:  matchAndRewrite(func::FuncOp funcOp, OpAdaptor adaptor,
        -:  492:                  ConversionPatternRewriter &rewriter) const override;
        -:  493:};
        -:  494:} // namespace
        -:  495:
        -:  496:LogicalResult
function _ZNK12_GLOBAL__N_116FuncOpConversion15matchAndRewriteEN4mlir4func6FuncOpENS2_13FuncOpAdaptorERNS1_25ConversionPatternRewriterE called 544 returned 100% blocks executed 96%
      544:  497:FuncOpConversion::matchAndRewrite(func::FuncOp funcOp, OpAdaptor adaptor,
        -:  498:                                  ConversionPatternRewriter &rewriter) const {
      544:  499:  auto fnType = funcOp.getFunctionType();
call    0 returned 100%
      544:  500:  if (fnType.getNumResults() > 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  501:    return failure();
        -:  502:
      544:  503:  TypeConverter::SignatureConversion signatureConverter(fnType.getNumInputs());
call    0 returned 100%
call    1 returned 100%
      868:  504:  for (const auto &argType : enumerate(fnType.getInputs())) {
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
      586:  505:    auto convertedType = getTypeConverter()->convertType(argType.value());
call    0 returned 100%
      586:  506:    if (!convertedType)
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
      262:  507:      return failure();
      324:  508:    signatureConverter.addInputs(argType.index(), convertedType);
call    0 returned 100%
call    1 returned 100%
        -:  509:  }
        -:  510:
      282:  511:  Type resultType;
      282:  512:  if (fnType.getNumResults() == 1) {
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
      159:  513:    resultType = getTypeConverter()->convertType(fnType.getResult(0));
call    0 returned 100%
call    1 returned 100%
      159:  514:    if (!resultType)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
       96:  515:      return failure();
        -:  516:  }
        -:  517:
        -:  518:  // Create the converted spirv.func op.
      186:  519:  auto newFuncOp = rewriter.create<spirv::FuncOp>(
      186:  520:      funcOp.getLoc(), funcOp.getName(),
call    0 returned 100%
      186:  521:      rewriter.getFunctionType(signatureConverter.getConvertedTypes(),
        -:  522:                               resultType ? TypeRange(resultType)
      435:  523:                                          : TypeRange()));
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  524:
        -:  525:  // Copy over all attributes other than the function name and type.
      629:  526:  for (const auto &namedAttr : funcOp->getAttrs()) {
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
      886:  527:    if (namedAttr.getName() != FunctionOpInterface::getTypeAttrName() &&
call    0 returned 100%
branch  1 taken 58% (fallthrough)
branch  2 taken 42%
      514:  528:        namedAttr.getName() != SymbolTable::getSymbolAttrName())
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
       71:  529:      newFuncOp->setAttr(namedAttr.getName(), namedAttr.getValue());
call    0 returned 100%
call    1 returned 100%
        -:  530:  }
        -:  531:
      186:  532:  rewriter.inlineRegionBefore(funcOp.getBody(), newFuncOp.getBody(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  533:                              newFuncOp.end());
      186:  534:  if (failed(rewriter.convertRegionTypes(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      186:  535:          &newFuncOp.getBody(), *getTypeConverter(), &signatureConverter)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  536:    return failure();
      186:  537:  rewriter.eraseOp(funcOp);
call    0 returned 100%
      544:  538:  return success();
call    0 returned 100%
        -:  539:}
        -:  540:
function _ZN4mlir34populateBuiltinFuncToSPIRVPatternsERNS_18SPIRVTypeConverterERNS_17RewritePatternSetE called 453 returned 100% blocks executed 100%
      453:  541:void mlir::populateBuiltinFuncToSPIRVPatterns(SPIRVTypeConverter &typeConverter,
        -:  542:                                              RewritePatternSet &patterns) {
      453:  543:  patterns.add<FuncOpConversion>(typeConverter, patterns.getContext());
call    0 returned 100%
      453:  544:}
        -:  545:
        -:  546://===----------------------------------------------------------------------===//
        -:  547:// Builtin Variables
        -:  548://===----------------------------------------------------------------------===//
        -:  549:
function _ZL18getBuiltinVariableRN4mlir5BlockENS_5spirv7BuiltInE called 0 returned 0% blocks executed 0%
    #####:  550:static spirv::GlobalVariableOp getBuiltinVariable(Block &body,
        -:  551:                                                  spirv::BuiltIn builtin) {
        -:  552:  // Look through all global variables in the given `body` block and check if
        -:  553:  // there is a spirv.GlobalVariable that has the same `builtin` attribute.
    #####:  554:  for (auto varOp : body.getOps<spirv::GlobalVariableOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  555:    if (auto builtinAttr = varOp->getAttrOfType<StringAttr>(
branch  0 never executed
branch  1 never executed
    #####:  556:            spirv::SPIRVDialect::getAttributeName(
call    0 never executed
call    1 never executed
    #####:  557:                spirv::Decoration::BuiltIn))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  558:      auto varBuiltIn = spirv::symbolizeBuiltIn(builtinAttr.getValue());
call    0 never executed
call    1 never executed
    #####:  559:      if (varBuiltIn && *varBuiltIn == builtin) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:        return varOp;
        -:  561:      }
        -:  562:    }
        -:  563:  }
    #####:  564:  return nullptr;
        -:  565:}
        -:  566:
        -:  567:/// Gets name of global variable for a builtin.
function _ZL17getBuiltinVarNameN4mlir5spirv7BuiltInE called 0 returned 0% blocks executed 0%
    #####:  568:static std::string getBuiltinVarName(spirv::BuiltIn builtin) {
    #####:  569:  return std::string("__builtin_var_") + stringifyBuiltIn(builtin).str() + "__";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -:  570:}
        -:  571:
        -:  572:/// Gets or inserts a global variable for a builtin within `body` block.
        -:  573:static spirv::GlobalVariableOp
function _ZL26getOrInsertBuiltinVariableRN4mlir5BlockENS_8LocationENS_5spirv7BuiltInENS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  574:getOrInsertBuiltinVariable(Block &body, Location loc, spirv::BuiltIn builtin,
        -:  575:                           Type integerType, OpBuilder &builder) {
    #####:  576:  if (auto varOp = getBuiltinVariable(body, builtin))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  577:    return varOp;
        -:  578:
    #####:  579:  OpBuilder::InsertionGuard guard(builder);
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  580:  builder.setInsertionPointToStart(&body);
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  581:
    #####:  582:  spirv::GlobalVariableOp newVarOp;
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  583:  switch (builtin) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  584:  case spirv::BuiltIn::NumWorkgroups:
    #####:  585:  case spirv::BuiltIn::WorkgroupSize:
    #####:  586:  case spirv::BuiltIn::WorkgroupId:
    #####:  587:  case spirv::BuiltIn::LocalInvocationId:
    #####:  588:  case spirv::BuiltIn::GlobalInvocationId: {
    #####:  589:    auto ptrType = spirv::PointerType::get(VectorType::get({3}, integerType),
call    0 never executed
    #####:  590:                                           spirv::StorageClass::Input);
call    0 never executed
    #####:  591:    std::string name = getBuiltinVarName(builtin);
call    0 never executed
    #####:  592:    newVarOp =
    #####:  593:        builder.create<spirv::GlobalVariableOp>(loc, ptrType, name, builtin);
call    0 never executed
    #####:  594:    break;
branch  0 never executed
branch  1 never executed
        -:  595:  }
    #####:  596:  case spirv::BuiltIn::SubgroupId:
    #####:  597:  case spirv::BuiltIn::NumSubgroups:
    #####:  598:  case spirv::BuiltIn::SubgroupSize: {
    #####:  599:    auto ptrType =
    #####:  600:        spirv::PointerType::get(integerType, spirv::StorageClass::Input);
call    0 never executed
    #####:  601:    std::string name = getBuiltinVarName(builtin);
call    0 never executed
    #####:  602:    newVarOp =
    #####:  603:        builder.create<spirv::GlobalVariableOp>(loc, ptrType, name, builtin);
call    0 never executed
    #####:  604:    break;
branch  0 never executed
branch  1 never executed
        -:  605:  }
    #####:  606:  default:
    #####:  607:    emitError(loc, "unimplemented builtin variable generation for ")
call    0 never executed
call    1 never executed
    #####:  608:        << stringifyBuiltIn(builtin);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  609:  }
    #####:  610:  return newVarOp;
branch  0 never executed
branch  1 never executed
        -:  611:}
        -:  612:
function _ZN4mlir5spirv23getBuiltinVariableValueEPNS_9OperationENS0_7BuiltInENS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  613:Value mlir::spirv::getBuiltinVariableValue(Operation *op,
        -:  614:                                           spirv::BuiltIn builtin,
        -:  615:                                           Type integerType,
        -:  616:                                           OpBuilder &builder) {
    #####:  617:  Operation *parent = SymbolTable::getNearestSymbolTable(op->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  618:  if (!parent) {
branch  0 never executed
branch  1 never executed
    #####:  619:    op->emitError("expected operation to be within a module-like op");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  620:    return nullptr;
        -:  621:  }
        -:  622:
    #####:  623:  spirv::GlobalVariableOp varOp =
    #####:  624:      getOrInsertBuiltinVariable(*parent->getRegion(0).begin(), op->getLoc(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  625:                                 builtin, integerType, builder);
call    0 never executed
call    1 never executed
    #####:  626:  Value ptr = builder.create<spirv::AddressOfOp>(op->getLoc(), varOp);
call    0 never executed
call    1 never executed
    #####:  627:  return builder.create<spirv::LoadOp>(op->getLoc(), ptr);
call    0 never executed
        -:  628:}
        -:  629:
        -:  630://===----------------------------------------------------------------------===//
        -:  631:// Push constant storage
        -:  632://===----------------------------------------------------------------------===//
        -:  633:
        -:  634:/// Returns the pointer type for the push constant storage containing
        -:  635:/// `elementCount` 32-bit integer values.
        -:  636:static spirv::PointerType getPushConstantStorageType(unsigned elementCount,
        -:  637:                                                     Builder &builder,
        -:  638:                                                     Type indexType) {
        -:  639:  auto arrayType = spirv::ArrayType::get(indexType, elementCount,
        -:  640:                                         /*stride=*/4);
        -:  641:  auto structType = spirv::StructType::get({arrayType}, /*offsetInfo=*/0);
        -:  642:  return spirv::PointerType::get(structType, spirv::StorageClass::PushConstant);
        -:  643:}
        -:  644:
        -:  645:/// Returns the push constant varible containing `elementCount` 32-bit integer
        -:  646:/// values in `body`. Returns null op if such an op does not exit.
function _ZL23getPushConstantVariableRN4mlir5BlockEj called 0 returned 0% blocks executed 0%
    #####:  647:static spirv::GlobalVariableOp getPushConstantVariable(Block &body,
        -:  648:                                                       unsigned elementCount) {
    #####:  649:  for (auto varOp : body.getOps<spirv::GlobalVariableOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  650:    auto ptrType = varOp.getType().dyn_cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####:  651:    if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####:  652:      continue;
        -:  653:
        -:  654:    // Note that Vulkan requires "There must be no more than one push constant
        -:  655:    // block statically used per shader entry point." So we should always reuse
        -:  656:    // the existing one.
    #####:  657:    if (ptrType.getStorageClass() == spirv::StorageClass::PushConstant) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  658:      auto numElements = ptrType.getPointeeType()
call    0 never executed
call    1 never executed
    #####:  659:                             .cast<spirv::StructType>()
    #####:  660:                             .getElementType(0)
call    0 never executed
call    1 never executed
    #####:  661:                             .cast<spirv::ArrayType>()
    #####:  662:                             .getNumElements();
call    0 never executed
    #####:  663:      if (numElements == elementCount)
branch  0 never executed
branch  1 never executed
    #####:  664:        return varOp;
        -:  665:    }
        -:  666:  }
    #####:  667:  return nullptr;
        -:  668:}
        -:  669:
        -:  670:/// Gets or inserts a global variable for push constant storage containing
        -:  671:/// `elementCount` 32-bit integer values in `block`.
        -:  672:static spirv::GlobalVariableOp
function _ZL31getOrInsertPushConstantVariableN4mlir8LocationERNS_5BlockEjRNS_9OpBuilderENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  673:getOrInsertPushConstantVariable(Location loc, Block &block,
        -:  674:                                unsigned elementCount, OpBuilder &b,
        -:  675:                                Type indexType) {
    #####:  676:  if (auto varOp = getPushConstantVariable(block, elementCount))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  677:    return varOp;
        -:  678:
    #####:  679:  auto builder = OpBuilder::atBlockBegin(&block, b.getListener());
call    0 never executed
    #####:  680:  auto type = getPushConstantStorageType(elementCount, builder, indexType);
call    0 never executed
    #####:  681:  const char *name = "__push_constant_var__";
    #####:  682:  return builder.create<spirv::GlobalVariableOp>(loc, type, name,
    #####:  683:                                                 /*initializer=*/nullptr);
call    0 never executed
        -:  684:}
        -:  685:
function _ZN4mlir5spirv20getPushConstantValueEPNS_9OperationEjjNS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  686:Value spirv::getPushConstantValue(Operation *op, unsigned elementCount,
        -:  687:                                  unsigned offset, Type integerType,
        -:  688:                                  OpBuilder &builder) {
    #####:  689:  Location loc = op->getLoc();
branch  0 never executed
branch  1 never executed
    #####:  690:  Operation *parent = SymbolTable::getNearestSymbolTable(op->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  691:  if (!parent) {
branch  0 never executed
branch  1 never executed
    #####:  692:    op->emitError("expected operation to be within a module-like op");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  693:    return nullptr;
        -:  694:  }
        -:  695:
    #####:  696:  spirv::GlobalVariableOp varOp = getOrInsertPushConstantVariable(
    #####:  697:      loc, parent->getRegion(0).front(), elementCount, builder, integerType);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  698:
    #####:  699:  Value zeroOp = spirv::ConstantOp::getZero(integerType, loc, builder);
call    0 never executed
call    1 never executed
    #####:  700:  Value offsetOp = builder.create<spirv::ConstantOp>(
    #####:  701:      loc, integerType, builder.getI32IntegerAttr(offset));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  702:  auto addrOp = builder.create<spirv::AddressOfOp>(loc, varOp);
call    0 never executed
    #####:  703:  auto acOp = builder.create<spirv::AccessChainOp>(
    #####:  704:      loc, addrOp, llvm::makeArrayRef({zeroOp, offsetOp}));
call    0 never executed
    #####:  705:  return builder.create<spirv::LoadOp>(loc, acOp);
call    0 never executed
        -:  706:}
        -:  707:
        -:  708://===----------------------------------------------------------------------===//
        -:  709:// Index calculation
        -:  710://===----------------------------------------------------------------------===//
        -:  711:
function _ZN4mlir5spirv14linearizeIndexENS_10ValueRangeEN4llvm8ArrayRefIlEElNS_4TypeENS_8LocationERNS_9OpBuilderE called 17 returned 100% blocks executed 88%
       17:  712:Value mlir::spirv::linearizeIndex(ValueRange indices, ArrayRef<int64_t> strides,
        -:  713:                                  int64_t offset, Type integerType,
        -:  714:                                  Location loc, OpBuilder &builder) {
      17*:  715:  assert(indices.size() == strides.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  716:         "must provide indices for all dimensions");
        -:  717:
        -:  718:  // TODO: Consider moving to use affine.apply and patterns converting
        -:  719:  // affine.apply to standard ops. This needs converting to SPIR-V passes to be
        -:  720:  // broken down into progressive small steps so we can have intermediate steps
        -:  721:  // using other dialects. At the moment SPIR-V is the final sink.
        -:  722:
       34:  723:  Value linearizedIndex = builder.create<spirv::ConstantOp>(
       17:  724:      loc, integerType, IntegerAttr::get(integerType, offset));
call    0 returned 100%
call    1 returned 100%
       97:  725:  for (const auto &index : llvm::enumerate(indices)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
       80:  726:    Value strideVal = builder.create<spirv::ConstantOp>(
        -:  727:        loc, integerType,
       40:  728:        IntegerAttr::get(integerType, strides[index.index()]));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
       40:  729:    Value update = builder.create<spirv::IMulOp>(loc, strideVal, index.value());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       40:  730:    linearizedIndex =
       40:  731:        builder.create<spirv::IAddOp>(loc, linearizedIndex, update);
call    0 returned 100%
        -:  732:  }
       17:  733:  return linearizedIndex;
        -:  734:}
        -:  735:
function _ZN4mlir5spirv19getVulkanElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 17 returned 100% blocks executed 81%
       17:  736:Value mlir::spirv::getVulkanElementPtr(SPIRVTypeConverter &typeConverter,
        -:  737:                                       MemRefType baseType, Value basePtr,
        -:  738:                                       ValueRange indices, Location loc,
        -:  739:                                       OpBuilder &builder) {
        -:  740:  // Get base and offset of the MemRefType and verify they are static.
        -:  741:
       17:  742:  int64_t offset;
       17:  743:  SmallVector<int64_t, 4> strides;
call    0 returned 100%
       34:  744:  if (failed(getStridesAndOffset(baseType, strides, offset)) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      17*:  745:      llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       17:  746:      offset == MemRefType::getDynamicStrideOrOffset()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  747:    return nullptr;
        -:  748:  }
        -:  749:
       17:  750:  auto indexType = typeConverter.getIndexType();
call    0 returned 100%
        -:  751:
       34:  752:  SmallVector<Value, 2> linearizedIndices;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       17:  753:  auto zero = spirv::ConstantOp::getZero(indexType, loc, builder);
call    0 returned 100%
        -:  754:
        -:  755:  // Add a '0' at the start to index into the struct.
       17:  756:  linearizedIndices.push_back(zero);
call    0 returned 100%
        -:  757:
       17:  758:  if (baseType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  759:    linearizedIndices.push_back(zero);
call    0 never executed
        -:  760:  } else {
       17:  761:    linearizedIndices.push_back(
call    0 returned 100%
call    1 returned 100%
        -:  762:        linearizeIndex(indices, strides, offset, indexType, loc, builder));
        -:  763:  }
       17:  764:  return builder.create<spirv::AccessChainOp>(loc, basePtr, linearizedIndices);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  765:}
        -:  766:
function _ZN4mlir5spirv19getOpenCLElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  767:Value mlir::spirv::getOpenCLElementPtr(SPIRVTypeConverter &typeConverter,
        -:  768:                                       MemRefType baseType, Value basePtr,
        -:  769:                                       ValueRange indices, Location loc,
        -:  770:                                       OpBuilder &builder) {
        -:  771:  // Get base and offset of the MemRefType and verify they are static.
        -:  772:
    #####:  773:  int64_t offset;
    #####:  774:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  775:  if (failed(getStridesAndOffset(baseType, strides, offset)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  776:      llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  777:      offset == MemRefType::getDynamicStrideOrOffset()) {
branch  0 never executed
branch  1 never executed
    #####:  778:    return nullptr;
        -:  779:  }
        -:  780:
    #####:  781:  auto indexType = typeConverter.getIndexType();
call    0 never executed
        -:  782:
    #####:  783:  SmallVector<Value, 2> linearizedIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  784:  Value linearIndex;
    #####:  785:  if (baseType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  786:    linearIndex = spirv::ConstantOp::getZero(indexType, loc, builder);
call    0 never executed
        -:  787:  } else {
    #####:  788:    linearIndex =
    #####:  789:        linearizeIndex(indices, strides, offset, indexType, loc, builder);
call    0 never executed
        -:  790:  }
    #####:  791:  Type pointeeType =
    #####:  792:      basePtr.getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
    #####:  793:  if (pointeeType.isa<spirv::ArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  794:    linearizedIndices.push_back(linearIndex);
call    0 never executed
    #####:  795:    return builder.create<spirv::AccessChainOp>(loc, basePtr,
    #####:  796:                                                linearizedIndices);
call    0 never executed
        -:  797:  }
    #####:  798:  return builder.create<spirv::PtrAccessChainOp>(loc, basePtr, linearIndex,
    #####:  799:                                                 linearizedIndices);
call    0 never executed
        -:  800:}
        -:  801:
function _ZN4mlir5spirv13getElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 17 returned 100% blocks executed 80%
       17:  802:Value mlir::spirv::getElementPtr(SPIRVTypeConverter &typeConverter,
        -:  803:                                 MemRefType baseType, Value basePtr,
        -:  804:                                 ValueRange indices, Location loc,
        -:  805:                                 OpBuilder &builder) {
        -:  806:
       17:  807:  if (typeConverter.allows(spirv::Capability::Kernel)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  808:    return getOpenCLElementPtr(typeConverter, baseType, basePtr, indices, loc,
    #####:  809:                               builder);
call    0 never executed
        -:  810:  }
        -:  811:
       17:  812:  return getVulkanElementPtr(typeConverter, baseType, basePtr, indices, loc,
       17:  813:                             builder);
call    0 returned 100%
        -:  814:}
        -:  815:
        -:  816://===----------------------------------------------------------------------===//
        -:  817:// SPIR-V ConversionTarget
        -:  818://===----------------------------------------------------------------------===//
        -:  819:
        -:  820:std::unique_ptr<SPIRVConversionTarget>
function _ZN4mlir21SPIRVConversionTarget3getENS_5spirv13TargetEnvAttrE called 1514 returned 100% blocks executed 100%
     1514:  821:SPIRVConversionTarget::get(spirv::TargetEnvAttr targetAttr) {
     1514:  822:  std::unique_ptr<SPIRVConversionTarget> target(
        -:  823:      // std::make_unique does not work here because the constructor is private.
     1514:  824:      new SPIRVConversionTarget(targetAttr));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1514:  825:  SPIRVConversionTarget *targetPtr = target.get();
call    0 returned 100%
     1514:  826:  target->addDynamicallyLegalDialect<spirv::SPIRVDialect>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  827:      // We need to capture the raw pointer here because it is stable:
        -:  828:      // target will be destroyed once this function is returned.
    17625:  829:      [targetPtr](Operation *op) { return targetPtr->isLegalOp(op); });
call    0 returned 100%
     1514:  830:  return target;
        -:  831:}
        -:  832:
function _ZN4mlir21SPIRVConversionTargetC2ENS_5spirv13TargetEnvAttrE called 1514 returned 100% blocks executed 100%
     1514:  833:SPIRVConversionTarget::SPIRVConversionTarget(spirv::TargetEnvAttr targetAttr)
     1514:  834:    : ConversionTarget(*targetAttr.getContext()), targetEnv(targetAttr) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  835:
function _ZN4mlir21SPIRVConversionTarget9isLegalOpEPNS_9OperationE called 17625 returned 100% blocks executed 68%
    17625:  836:bool SPIRVConversionTarget::isLegalOp(Operation *op) {
        -:  837:  // Make sure this op is available at the given version. Ops not implementing
        -:  838:  // QueryMinVersionInterface/QueryMaxVersionInterface are available to all
        -:  839:  // SPIR-V versions.
    17625:  840:  if (auto minVersionIfx = dyn_cast<spirv::QueryMinVersionInterface>(op)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    17625:  841:    Optional<spirv::Version> minVersion = minVersionIfx.getMinVersion();
call    0 returned 100%
    17625:  842:    if (minVersion && *minVersion > this->targetEnv.getVersion()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  843:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  844:                 << op->getName() << " illegal: requiring min version "
        -:  845:                 << spirv::stringifyVersion(*minVersion) << "\n");
    #####:  846:      return false;
        -:  847:    }
        -:  848:  }
    17625:  849:  if (auto maxVersionIfx = dyn_cast<spirv::QueryMaxVersionInterface>(op)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    17625:  850:    Optional<spirv::Version> maxVersion = maxVersionIfx.getMaxVersion();
call    0 returned 100%
    17625:  851:    if (maxVersion && *maxVersion < this->targetEnv.getVersion()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####:  852:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  853:                 << op->getName() << " illegal: requiring max version "
        -:  854:                 << spirv::stringifyVersion(*maxVersion) << "\n");
    #####:  855:      return false;
        -:  856:    }
        -:  857:  }
        -:  858:
        -:  859:  // Make sure this op's required extensions are allowed to use. Ops not
        -:  860:  // implementing QueryExtensionInterface do not require extensions to be
        -:  861:  // available.
    17625:  862:  if (auto extensions = dyn_cast<spirv::QueryExtensionInterface>(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    17625:  863:    if (failed(checkExtensionRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    35250:  864:                                          extensions.getExtensions())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  865:      return false;
        -:  866:
        -:  867:  // Make sure this op's required extensions are allowed to use. Ops not
        -:  868:  // implementing QueryCapabilityInterface do not require capabilities to be
        -:  869:  // available.
    17625:  870:  if (auto capabilities = dyn_cast<spirv::QueryCapabilityInterface>(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    17625:  871:    if (failed(checkCapabilityRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    35250:  872:                                           capabilities.getCapabilities())))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
      197:  873:      return false;
        -:  874:
    17428:  875:  SmallVector<Type, 4> valueTypes;
call    0 returned 100%
    17428:  876:  valueTypes.append(op->operand_type_begin(), op->operand_type_end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    17428:  877:  valueTypes.append(op->result_type_begin(), op->result_type_end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  878:
        -:  879:  // Ensure that all types have been converted to SPIRV types.
    17428:  880:  if (llvm::any_of(valueTypes,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -:  881:                   [](Type t) { return !t.isa<spirv::SPIRVType>(); }))
        -:  882:    return false;
        -:  883:
        -:  884:  // Special treatment for global variables, whose type requirements are
        -:  885:  // conveyed by type attributes.
    17424:  886:  if (auto globalVar = dyn_cast<spirv::GlobalVariableOp>(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  887:    valueTypes.push_back(globalVar.getType());
call    0 never executed
call    1 never executed
        -:  888:
        -:  889:  // Make sure the op's operands/results use types that are allowed by the
        -:  890:  // target environment.
    34852:  891:  SmallVector<ArrayRef<spirv::Extension>, 4> typeExtensions;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    17424:  892:  SmallVector<ArrayRef<spirv::Capability>, 8> typeCapabilities;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    40068:  893:  for (Type valueType : valueTypes) {
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
    22825:  894:    typeExtensions.clear();
call    0 returned 100%
    22825:  895:    valueType.cast<spirv::SPIRVType>().getExtensions(typeExtensions);
call    0 returned 100%
call    1 returned 100%
    22825:  896:    if (failed(checkExtensionRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -:  897:                                          typeExtensions)))
      181:  898:      return false;
        -:  899:
    22802:  900:    typeCapabilities.clear();
call    0 returned 100%
    22802:  901:    valueType.cast<spirv::SPIRVType>().getCapabilities(typeCapabilities);
call    0 returned 100%
call    1 returned 100%
    22802:  902:    if (failed(checkCapabilityRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
        -:  903:                                           typeCapabilities)))
        -:  904:      return false;
        -:  905:  }
        -:  906:
    17243:  907:  return true;
        -:  908:}
