        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/MathToLibm/MathToLibm.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/MathToLibm/CMakeFiles/obj.MLIRMathToLibm.dir/MathToLibm.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/MathToLibm/CMakeFiles/obj.MLIRMathToLibm.dir/MathToLibm.cpp.gcda
        -:    0:Runs:116161
        -:    1://===-- MathToLibm.cpp - conversion from Math to libm calls ---------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/MathToLibm/MathToLibm.h"
        -:   10:
        -:   11:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   12:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   13:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   14:#include "mlir/Dialect/Math/IR/Math.h"
        -:   15:#include "mlir/Dialect/Utils/IndexingUtils.h"
        -:   16:#include "mlir/Dialect/Vector/IR/VectorOps.h"
        -:   17:#include "mlir/Dialect/Vector/Utils/VectorUtils.h"
        -:   18:#include "mlir/IR/BuiltinDialect.h"
        -:   19:#include "mlir/IR/PatternMatch.h"
        -:   20:#include "mlir/Pass/Pass.h"
        -:   21:
        -:   22:namespace mlir {
        -:   23:#define GEN_PASS_DEF_CONVERTMATHTOLIBM
        -:   24:#include "mlir/Conversion/Passes.h.inc"
        -:   25:} // namespace mlir
        -:   26:
        -:   27:using namespace mlir;
        -:   28:
        -:   29:namespace {
        -:   30:// Pattern to convert vector operations to scalar operations. This is needed as
        -:   31:// libm calls require scalars.
        -:   32:template <typename Op>
        -:   33:struct VecOpToScalarOp : public OpRewritePattern<Op> {
        -:   34:public:
        -:   35:  using OpRewritePattern<Op>::OpRewritePattern;
        -:   36:
        -:   37:  LogicalResult matchAndRewrite(Op op, PatternRewriter &rewriter) const final;
        -:   38:};
        -:   39:// Pattern to promote an op of a smaller floating point type to F32.
        -:   40:template <typename Op>
        -:   41:struct PromoteOpToF32 : public OpRewritePattern<Op> {
        -:   42:public:
        -:   43:  using OpRewritePattern<Op>::OpRewritePattern;
        -:   44:
        -:   45:  LogicalResult matchAndRewrite(Op op, PatternRewriter &rewriter) const final;
        -:   46:};
        -:   47:// Pattern to convert scalar math operations to calls to libm functions.
        -:   48:// Additionally the libm function signatures are declared.
        -:   49:template <typename Op>
        -:   50:struct ScalarOpToLibmCall : public OpRewritePattern<Op> {
        -:   51:public:
        -:   52:  using OpRewritePattern<Op>::OpRewritePattern;
     6132:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
     6132:   56:        doubleFunc(doubleFunc){};
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7TruncOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7TruncOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6CeilOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6CeilOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7FloorOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7FloorOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Log1pOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Log1pOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5SinOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5SinOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5CosOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5CosOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7RoundOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7RoundOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math11RoundEvenOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math11RoundEvenOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6TanhOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6TanhOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5TanOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5TanOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7ExpM1OpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7ExpM1OpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5ErfOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5ErfOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Atan2OpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Atan2OpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
_ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6AtanOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE:
function _ZN12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6AtanOpEEC2EPNS1_11MLIRContextEN4llvm9StringRefES8_NS1_14PatternBenefitE called 438 returned 100% blocks executed 100%
      438:   53:  ScalarOpToLibmCall<Op>(MLIRContext *context, StringRef floatFunc,
        -:   54:                         StringRef doubleFunc, PatternBenefit benefit)
        -:   55:      : OpRewritePattern<Op>(context, benefit), floatFunc(floatFunc),
      438:   56:        doubleFunc(doubleFunc){};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
------------------
        -:   57:
        -:   58:  LogicalResult matchAndRewrite(Op op, PatternRewriter &rewriter) const final;
        -:   59:
        -:   60:private:
        -:   61:  std::string floatFunc, doubleFunc;
        -:   62:};
        -:   63:} // namespace
        -:   64:
        -:   65:template <typename Op>
        -:   66:LogicalResult
     110*:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
     110*:   68:  auto opType = op.getType();
     110*:   69:  auto loc = op.getLoc();
     110*:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
     110*:   72:  if (!vecType)
     110*:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
     110*:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
    #####:   77:  int64_t numElements = vecType.getNumElements();
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
    #####:   80:      loc, DenseElementsAttr::get(
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
    #####:   86:    SmallVector<Value> operands;
    #####:   87:    for (auto input : op->getOperands())
    #####:   88:      operands.push_back(
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
    #####:   96:  return success();
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 15 returned 100% blocks executed 9%
       15:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       15:   68:  auto opType = op.getType();
       15:   69:  auto loc = op.getLoc();
call    0 returned 100%
       15:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
       15:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       15:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
       15:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 39 returned 100% blocks executed 9%
       39:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       39:   68:  auto opType = op.getType();
       39:   69:  auto loc = op.getLoc();
call    0 returned 100%
       39:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
       39:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       39:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
       39:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 6 returned 100% blocks executed 9%
        6:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        6:   68:  auto opType = op.getType();
        6:   69:  auto loc = op.getLoc();
call    0 returned 100%
        6:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
        6:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
        6:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 1 returned 100% blocks executed 9%
        1:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        1:   68:  auto opType = op.getType();
        1:   69:  auto loc = op.getLoc();
call    0 returned 100%
        1:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
        1:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
        1:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:   68:  auto opType = op.getType();
    #####:   69:  auto loc = op.getLoc();
call    0 never executed
    #####:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
    #####:   72:  if (!vecType)
branch  0 never executed
branch  1 never executed
    #####:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
    #####:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:   68:  auto opType = op.getType();
    #####:   69:  auto loc = op.getLoc();
call    0 never executed
    #####:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
    #####:   72:  if (!vecType)
branch  0 never executed
branch  1 never executed
    #####:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
    #####:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 9%
        8:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        8:   68:  auto opType = op.getType();
        8:   69:  auto loc = op.getLoc();
call    0 returned 100%
        8:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
        8:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
        8:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 21 returned 100% blocks executed 9%
       21:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       21:   68:  auto opType = op.getType();
       21:   69:  auto loc = op.getLoc();
call    0 returned 100%
       21:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
       21:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       21:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
       21:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 9%
        8:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        8:   68:  auto opType = op.getType();
        8:   69:  auto loc = op.getLoc();
call    0 returned 100%
        8:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
        8:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
        8:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 12 returned 100% blocks executed 9%
       12:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       12:   68:  auto opType = op.getType();
       12:   69:  auto loc = op.getLoc();
call    0 returned 100%
       12:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
       12:   72:  if (!vecType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
       12:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
_ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_115VecOpToScalarOpIN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   67:VecOpToScalarOp<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:   68:  auto opType = op.getType();
    #####:   69:  auto loc = op.getLoc();
call    0 never executed
    #####:   70:  auto vecType = opType.template dyn_cast<VectorType>();
        -:   71:
    #####:   72:  if (!vecType)
branch  0 never executed
branch  1 never executed
    #####:   73:    return failure();
    #####:   74:  if (!vecType.hasRank())
call    0 never executed
    #####:   75:    return failure();
    #####:   76:  auto shape = vecType.getShape();
call    0 never executed
    #####:   77:  int64_t numElements = vecType.getNumElements();
call    0 never executed
        -:   78:
    #####:   79:  Value result = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:   80:      loc, DenseElementsAttr::get(
call    0 never executed
call    1 never executed
    #####:   81:               vecType, FloatAttr::get(vecType.getElementType(), 0.0)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   82:  SmallVector<int64_t> ones(shape.size(), 1);
call    0 never executed
call    1 never executed
    #####:   83:  SmallVector<int64_t> strides = computeStrides(shape, ones);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   84:  for (auto linearIndex = 0; linearIndex < numElements; ++linearIndex) {
branch  0 never executed
branch  1 never executed
    #####:   85:    SmallVector<int64_t> positions = delinearize(strides, linearIndex);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:   86:    SmallVector<Value> operands;
branch  0 never executed
branch  1 never executed
    #####:   87:    for (auto input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   88:      operands.push_back(
call    0 never executed
call    1 never executed
        -:   89:          rewriter.create<vector::ExtractOp>(loc, input, positions));
    #####:   90:    Value scalarOp =
call    0 never executed
call    1 never executed
call    2 never executed
        -:   91:        rewriter.create<Op>(loc, vecType.getElementType(), operands);
    #####:   92:    result =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:        rewriter.create<vector::InsertOp>(loc, scalarOp, result, positions);
        -:   94:  }
    #####:   95:  rewriter.replaceOp(op, {result});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   96:  return success();
branch  0 never executed
branch  1 never executed
        -:   97:}
------------------
        -:   98:
        -:   99:template <typename Op>
        -:  100:LogicalResult
     135*:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
     135*:  102:  auto opType = op.getType();
     135*:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
     135*:  104:    return failure();
        -:  105:
      25*:  106:  auto loc = op.getLoc();
      25*:  107:  auto f32 = rewriter.getF32Type();
      25*:  108:  auto extendedOperands = llvm::to_vector(
      25*:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
      25*:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
      25*:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
      25*:  114:  return success();
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 16 returned 100% blocks executed 92%
       16:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       16:  102:  auto opType = op.getType();
call    0 returned 100%
       16:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  104:    return failure();
        -:  105:
        1:  106:  auto loc = op.getLoc();
call    0 returned 100%
        1:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        1:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        1:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        1:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        1:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 45 returned 100% blocks executed 92%
       45:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       45:  102:  auto opType = op.getType();
call    0 returned 100%
       45:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
       45:  104:    return failure();
        -:  105:
        6:  106:  auto loc = op.getLoc();
call    0 returned 100%
        6:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        6:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        6:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        6:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        6:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        6:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 92%
        8:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        8:  102:  auto opType = op.getType();
call    0 returned 100%
        8:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        8:  104:    return failure();
        -:  105:
        2:  106:  auto loc = op.getLoc();
call    0 returned 100%
        2:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        2:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        2:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        2:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        2:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        2:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 5 returned 100% blocks executed 92%
        5:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        5:  102:  auto opType = op.getType();
call    0 returned 100%
        5:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        5:  104:    return failure();
        -:  105:
        4:  106:  auto loc = op.getLoc();
call    0 returned 100%
        4:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        4:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        4:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        4:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        4:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        4:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:  102:  auto opType = op.getType();
call    0 never executed
    #####:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 never executed
branch  1 never executed
    #####:  104:    return failure();
        -:  105:
    #####:  106:  auto loc = op.getLoc();
call    0 never executed
    #####:  107:  auto f32 = rewriter.getF32Type();
call    0 never executed
    #####:  108:  auto extendedOperands = llvm::to_vector(
call    0 never executed
    #####:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 never executed
call    1 never executed
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
    #####:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 never executed
    #####:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  114:  return success();
branch  0 never executed
branch  1 never executed
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:  102:  auto opType = op.getType();
call    0 never executed
    #####:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 never executed
branch  1 never executed
    #####:  104:    return failure();
        -:  105:
    #####:  106:  auto loc = op.getLoc();
call    0 never executed
    #####:  107:  auto f32 = rewriter.getF32Type();
call    0 never executed
    #####:  108:  auto extendedOperands = llvm::to_vector(
call    0 never executed
    #####:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 never executed
call    1 never executed
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
    #####:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 never executed
    #####:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  114:  return success();
branch  0 never executed
branch  1 never executed
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 33%
        8:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
        8:  102:  auto opType = op.getType();
call    0 returned 100%
        8:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  104:    return failure();
        -:  105:
    #####:  106:  auto loc = op.getLoc();
call    0 never executed
    #####:  107:  auto f32 = rewriter.getF32Type();
call    0 never executed
    #####:  108:  auto extendedOperands = llvm::to_vector(
call    0 never executed
    #####:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 never executed
call    1 never executed
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
    #####:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 never executed
    #####:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  114:  return success();
branch  0 never executed
branch  1 never executed
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 24 returned 100% blocks executed 92%
       24:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       24:  102:  auto opType = op.getType();
call    0 returned 100%
       24:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       24:  104:    return failure();
        -:  105:
        3:  106:  auto loc = op.getLoc();
call    0 returned 100%
        3:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        3:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        3:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        3:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        3:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        3:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 11 returned 100% blocks executed 92%
       11:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       11:  102:  auto opType = op.getType();
call    0 returned 100%
       11:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
       11:  104:    return failure();
        -:  105:
        3:  106:  auto loc = op.getLoc();
call    0 returned 100%
        3:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        3:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        3:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        3:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        3:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        3:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 18 returned 100% blocks executed 92%
       18:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 returned 100%
       18:  102:  auto opType = op.getType();
call    0 returned 100%
       18:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       18:  104:    return failure();
        -:  105:
        6:  106:  auto loc = op.getLoc();
call    0 returned 100%
        6:  107:  auto f32 = rewriter.getF32Type();
call    0 returned 100%
        6:  108:  auto extendedOperands = llvm::to_vector(
call    0 returned 100%
        6:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 returned 100%
call    1 returned 100%
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
        6:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 returned 100%
        6:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        6:  114:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:}
------------------
_ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_114PromoteOpToF32IN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  101:PromoteOpToF32<Op>::matchAndRewrite(Op op, PatternRewriter &rewriter) const {
call    0 never executed
    #####:  102:  auto opType = op.getType();
call    0 never executed
    #####:  103:  if (!opType.template isa<Float16Type, BFloat16Type>())
branch  0 never executed
branch  1 never executed
    #####:  104:    return failure();
        -:  105:
    #####:  106:  auto loc = op.getLoc();
call    0 never executed
    #####:  107:  auto f32 = rewriter.getF32Type();
call    0 never executed
    #####:  108:  auto extendedOperands = llvm::to_vector(
call    0 never executed
    #####:  109:      llvm::map_range(op->getOperands(), [&](Value operand) -> Value {
call    0 never executed
call    1 never executed
        -:  110:        return rewriter.create<arith::ExtFOp>(loc, f32, operand);
        -:  111:      }));
    #####:  112:  auto newOp = rewriter.create<Op>(loc, f32, extendedOperands);
call    0 never executed
    #####:  113:  rewriter.replaceOpWithNewOp<arith::TruncFOp>(op, opType, newOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  114:  return success();
branch  0 never executed
branch  1 never executed
        -:  115:}
------------------
        -:  116:
        -:  117:template <typename Op>
        -:  118:LogicalResult
     186*:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
     186*:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
     186*:  122:  auto type = op.getType();
     186*:  123:  if (!type.template isa<Float32Type, Float64Type>())
     186*:  124:    return failure();
        -:  125:
      52*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
      26*:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
      26*:  130:  if (!opFunc) {
      52*:  131:    OpBuilder::InsertionGuard guard(rewriter);
      26*:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
      52*:  133:    auto opFunctionTy = FunctionType::get(
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
      26*:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
        -:  136:                                           opFunctionTy);
      26*:  137:    opFunc.setPrivate();
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
      26*:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
      52*:  145:                    UnitAttr::get(rewriter.getContext()));
        -:  146:  }
      26*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
        -:  148:
      26*:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
        -:  150:                                            op->getOperands());
        -:  151:
      26*:  152:  return success();
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6AtanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 14 returned 100% blocks executed 84%
       14:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       14:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       14:  122:  auto type = op.getType();
call    0 returned 100%
       14:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
       14:  124:    return failure();
        -:  125:
       6*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        3:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        3:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        3:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        6:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        3:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        3:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        3:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
        6:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       3*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        3:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        3:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Atan2OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 17 returned 100% blocks executed 84%
       17:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       17:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       17:  122:  auto type = op.getType();
call    0 returned 100%
       17:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  124:    return failure();
        -:  125:
       2*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        1:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        1:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        1:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        2:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        1:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        1:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        1:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
        2:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       1*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        1:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        1:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5ErfOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
    #####:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 never executed
call    1 never executed
    #####:  122:  auto type = op.getType();
call    0 never executed
    #####:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 never executed
branch  1 never executed
    #####:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7ExpM1OpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 51 returned 100% blocks executed 84%
       51:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       51:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       51:  122:  auto type = op.getType();
call    0 returned 100%
       51:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
       51:  124:    return failure();
        -:  125:
      12*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        6:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        6:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        6:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       12:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        6:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        6:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        6:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
       12:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       6*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        6:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        6:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5TanOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 25 returned 100% blocks executed 84%
       25:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       25:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       25:  122:  auto type = op.getType();
call    0 returned 100%
       25:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
       25:  124:    return failure();
        -:  125:
      14*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        7:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        7:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        7:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       14:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        7:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        7:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        7:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
       14:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       7*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        7:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        7:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6TanhOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 10 returned 100% blocks executed 84%
       10:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       10:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       10:  122:  auto type = op.getType();
call    0 returned 100%
       10:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       10:  124:    return failure();
        -:  125:
       4*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        2:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        2:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        2:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        4:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        2:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        2:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        2:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
        4:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       2*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        2:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        2:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math11RoundEvenOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 11%
        8:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
        8:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
        8:  122:  auto type = op.getType();
call    0 returned 100%
        8:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7RoundOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 27 returned 100% blocks executed 84%
       27:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       27:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       27:  122:  auto type = op.getType();
call    0 returned 100%
       27:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       27:  124:    return failure();
        -:  125:
       6*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        3:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        3:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        3:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        6:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        3:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        3:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        3:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
        6:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       3*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        3:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        3:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5CosOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 9 returned 100% blocks executed 84%
        9:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
        9:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
        9:  122:  auto type = op.getType();
call    0 returned 100%
        9:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        9:  124:    return failure();
        -:  125:
       8*:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        4:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
        4:  130:  if (!opFunc) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 returned 100%
        4:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        8:  133:    auto opFunctionTy = FunctionType::get(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
        4:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  136:                                           opFunctionTy);
        4:  137:    opFunc.setPrivate();
call    0 returned 100%
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
        4:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 returned 100%
call    1 returned 100%
        8:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  146:  }
       4*:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  148:
        4:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  150:                                            op->getOperands());
        -:  151:
        4:  152:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math5SinOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
    #####:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 never executed
call    1 never executed
    #####:  122:  auto type = op.getType();
call    0 never executed
    #####:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 never executed
branch  1 never executed
    #####:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Log1pOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7Log1pOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 6 returned 100% blocks executed 11%
        6:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
        6:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
        6:  122:  auto type = op.getType();
call    0 returned 100%
        6:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7FloorOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7FloorOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 11 returned 100% blocks executed 11%
       11:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
       11:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
       11:  122:  auto type = op.getType();
call    0 returned 100%
       11:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       11:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6CeilOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math6CeilOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 8 returned 100% blocks executed 11%
        8:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
        8:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 returned 100%
call    1 returned 100%
        8:  122:  auto type = op.getType();
call    0 returned 100%
        8:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
_ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_118ScalarOpToLibmCallIN4mlir4math7TruncOpEE15matchAndRewriteES3_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  119:ScalarOpToLibmCall<Op>::matchAndRewrite(Op op,
        -:  120:                                        PatternRewriter &rewriter) const {
    #####:  121:  auto module = SymbolTable::getNearestSymbolTable(op);
call    0 never executed
call    1 never executed
    #####:  122:  auto type = op.getType();
call    0 never executed
    #####:  123:  if (!type.template isa<Float32Type, Float64Type>())
branch  0 never executed
branch  1 never executed
    #####:  124:    return failure();
        -:  125:
    #####:  126:  auto name = type.getIntOrFloatBitWidth() == 64 ? doubleFunc : floatFunc;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  127:  auto opFunc = dyn_cast_or_null<SymbolOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  128:      SymbolTable::lookupSymbolIn(module, name));
        -:  129:  // Forward declare function if it hasn't already been
    #####:  130:  if (!opFunc) {
branch  0 never executed
branch  1 never executed
    #####:  131:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  132:    rewriter.setInsertionPointToStart(&module->getRegion(0).front());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  133:    auto opFunctionTy = FunctionType::get(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  134:        rewriter.getContext(), op->getOperandTypes(), op->getResultTypes());
    #####:  135:    opFunc = rewriter.create<func::FuncOp>(rewriter.getUnknownLoc(), name,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                                           opFunctionTy);
    #####:  137:    opFunc.setPrivate();
call    0 never executed
        -:  138:
        -:  139:    // By definition Math dialect operations imply LLVM's "readnone"
        -:  140:    // function attribute, so we can set it here to provide more
        -:  141:    // optimization opportunities (e.g. LICM) for backends targeting LLVM IR.
        -:  142:    // This will have to be changed, when strict FP behavior is supported
        -:  143:    // by Math dialect.
    #####:  144:    opFunc->setAttr(LLVM::LLVMDialect::getReadnoneAttrName(),
call    0 never executed
call    1 never executed
    #####:  145:                    UnitAttr::get(rewriter.getContext()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  146:  }
    #####:  147:  assert(isa<FunctionOpInterface>(SymbolTable::lookupSymbolIn(module, name)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  148:
    #####:  149:  rewriter.replaceOpWithNewOp<func::CallOp>(op, name, op.getType(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  150:                                            op->getOperands());
        -:  151:
    #####:  152:  return success();
branch  0 never executed
branch  1 never executed
        -:  153:}
------------------
        -:  154:
function _ZN4mlir36populateMathToLibmConversionPatternsERNS_17RewritePatternSetENS_14PatternBenefitEN4llvm8OptionalIS2_EE called 438 returned 100% blocks executed 95%
      438:  155:void mlir::populateMathToLibmConversionPatterns(
        -:  156:    RewritePatternSet &patterns, PatternBenefit benefit,
        -:  157:    llvm::Optional<PatternBenefit> log1pBenefit) {
      438:  158:  patterns.add<VecOpToScalarOp<math::Atan2Op>, VecOpToScalarOp<math::ExpM1Op>,
        -:  159:               VecOpToScalarOp<math::TanhOp>, VecOpToScalarOp<math::CosOp>,
        -:  160:               VecOpToScalarOp<math::SinOp>, VecOpToScalarOp<math::ErfOp>,
        -:  161:               VecOpToScalarOp<math::RoundEvenOp>,
        -:  162:               VecOpToScalarOp<math::RoundOp>, VecOpToScalarOp<math::AtanOp>,
        -:  163:               VecOpToScalarOp<math::TanOp>, VecOpToScalarOp<math::TruncOp>>(
      438:  164:      patterns.getContext(), benefit);
call    0 returned 100%
      438:  165:  patterns.add<PromoteOpToF32<math::Atan2Op>, PromoteOpToF32<math::ExpM1Op>,
        -:  166:               PromoteOpToF32<math::TanhOp>, PromoteOpToF32<math::CosOp>,
        -:  167:               PromoteOpToF32<math::SinOp>, PromoteOpToF32<math::ErfOp>,
        -:  168:               PromoteOpToF32<math::RoundEvenOp>, PromoteOpToF32<math::RoundOp>,
        -:  169:               PromoteOpToF32<math::AtanOp>, PromoteOpToF32<math::TanOp>,
      438:  170:               PromoteOpToF32<math::TruncOp>>(patterns.getContext(), benefit);
call    0 returned 100%
      438:  171:  patterns.add<ScalarOpToLibmCall<math::AtanOp>>(patterns.getContext(), "atanf",
call    0 returned 100%
      438:  172:                                                 "atan", benefit);
call    0 returned 100%
      438:  173:  patterns.add<ScalarOpToLibmCall<math::Atan2Op>>(patterns.getContext(),
call    0 returned 100%
      438:  174:                                                  "atan2f", "atan2", benefit);
call    0 returned 100%
      438:  175:  patterns.add<ScalarOpToLibmCall<math::ErfOp>>(patterns.getContext(), "erff",
call    0 returned 100%
      438:  176:                                                "erf", benefit);
call    0 returned 100%
      438:  177:  patterns.add<ScalarOpToLibmCall<math::ExpM1Op>>(patterns.getContext(),
call    0 returned 100%
      438:  178:                                                  "expm1f", "expm1", benefit);
call    0 returned 100%
      438:  179:  patterns.add<ScalarOpToLibmCall<math::TanOp>>(patterns.getContext(), "tanf",
call    0 returned 100%
      438:  180:                                                "tan", benefit);
call    0 returned 100%
      438:  181:  patterns.add<ScalarOpToLibmCall<math::TanhOp>>(patterns.getContext(), "tanhf",
call    0 returned 100%
      438:  182:                                                 "tanh", benefit);
call    0 returned 100%
      438:  183:  patterns.add<ScalarOpToLibmCall<math::RoundEvenOp>>(
      438:  184:      patterns.getContext(), "roundevenf", "roundeven", benefit);
call    0 returned 100%
      438:  185:  patterns.add<ScalarOpToLibmCall<math::RoundOp>>(patterns.getContext(),
call    0 returned 100%
      438:  186:                                                  "roundf", "round", benefit);
call    0 returned 100%
      438:  187:  patterns.add<ScalarOpToLibmCall<math::CosOp>>(patterns.getContext(), "cosf",
call    0 returned 100%
      438:  188:                                                "cos", benefit);
call    0 returned 100%
      438:  189:  patterns.add<ScalarOpToLibmCall<math::SinOp>>(patterns.getContext(), "sinf",
call    0 returned 100%
      438:  190:                                                "sin", benefit);
call    0 returned 100%
      438:  191:  patterns.add<ScalarOpToLibmCall<math::Log1pOp>>(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      438:  192:      patterns.getContext(), "log1pf", "log1p", log1pBenefit.value_or(benefit));
call    0 returned 100%
      438:  193:  patterns.add<ScalarOpToLibmCall<math::FloorOp>>(patterns.getContext(),
call    0 returned 100%
      438:  194:                                                  "floorf", "floor", benefit);
call    0 returned 100%
      438:  195:  patterns.add<ScalarOpToLibmCall<math::CeilOp>>(patterns.getContext(), "ceilf",
call    0 returned 100%
      438:  196:                                                 "ceil", benefit);
call    0 returned 100%
      438:  197:  patterns.add<ScalarOpToLibmCall<math::TruncOp>>(patterns.getContext(),
call    0 returned 100%
      438:  198:                                                  "truncf", "trunc", benefit);
call    0 returned 100%
      438:  199:}
        -:  200:
        -:  201:namespace {
  117119*:  202:struct ConvertMathToLibmPass
call    0 never executed
call    1 returned 100%
        -:  203:    : public impl::ConvertMathToLibmBase<ConvertMathToLibmPass> {
        -:  204:  void runOnOperation() override;
        -:  205:};
        -:  206:} // namespace
        -:  207:
function _ZN12_GLOBAL__N_121ConvertMathToLibmPass14runOnOperationEv called 438 returned 100% blocks executed 100%
      438:  208:void ConvertMathToLibmPass::runOnOperation() {
      438:  209:  auto module = getOperation();
call    0 returned 100%
        -:  210:
      438:  211:  RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      438:  212:  populateMathToLibmConversionPatterns(patterns, /*benefit=*/1);
call    0 returned 100%
call    1 returned 100%
        -:  213:
      876:  214:  ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      438:  215:  target.addLegalDialect<arith::ArithDialect, BuiltinDialect, func::FuncDialect,
      438:  216:                         vector::VectorDialect>();
call    0 returned 100%
      438:  217:  target.addIllegalDialect<math::MathDialect>();
call    0 returned 100%
      438:  218:  if (failed(applyPartialConversion(module, target, std::move(patterns))))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 85% (fallthrough)
branch  4 taken 15%
      371:  219:    signalPassFailure();
call    0 returned 100%
      438:  220:}
        -:  221:
function _ZN4mlir27createConvertMathToLibmPassEv called 117119 returned 100% blocks executed 100%
   117119:  222:std::unique_ptr<OperationPass<ModuleOp>> mlir::createConvertMathToLibmPass() {
   117119:  223:  return std::make_unique<ConvertMathToLibmPass>();
call    0 returned 100%
        -:  224:}
