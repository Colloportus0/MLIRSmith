        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/llvm/include/llvm/ADT/APSInt.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcda
        -:    0:Runs:116157
        -:    1://===-- llvm/ADT/APSInt.h - Arbitrary Precision Signed Int -----*- C++ -*--===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:///
        -:    9:/// \file
        -:   10:/// This file implements the APSInt class, which is a simple class that
        -:   11:/// represents an arbitrary sized integer that knows its signedness.
        -:   12:///
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef LLVM_ADT_APSINT_H
        -:   16:#define LLVM_ADT_APSINT_H
        -:   17:
        -:   18:#include "llvm/ADT/APInt.h"
        -:   19:
        -:   20:namespace llvm {
        -:   21:
        -:   22:/// An arbitrary precision integer that knows its signedness.
     413*:   23:class [[nodiscard]] APSInt : public APInt {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -:   24:  bool IsUnsigned = false;
        -:   25:
        -:   26:public:
        -:   27:  /// Default constructor that creates an uninitialized APInt.
        -:   28:  explicit APSInt() = default;
        -:   29:
        -:   30:  /// Create an APSInt with the specified width, default to unsigned.
function _ZN4llvm6APSIntC2Ejb called 413 returned 100% blocks executed 75%
      413:   31:  explicit APSInt(uint32_t BitWidth, bool isUnsigned = true)
      413:   32:   : APInt(BitWidth, 0), IsUnsigned(isUnsigned) {}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   33:
        -:   34:  explicit APSInt(APInt I, bool isUnsigned = true)
        -:   35:   : APInt(std::move(I)), IsUnsigned(isUnsigned) {}
        -:   36:
        -:   37:  /// Construct an APSInt from a string representation.
        -:   38:  ///
        -:   39:  /// This constructor interprets the string \p Str using the radix of 10.
        -:   40:  /// The interpretation stops at the end of the string. The bit width of the
        -:   41:  /// constructed APSInt is determined automatically.
        -:   42:  ///
        -:   43:  /// \param Str the string to be interpreted.
        -:   44:  explicit APSInt(StringRef Str);
        -:   45:
        -:   46:  /// Determine sign of this APSInt.
        -:   47:  ///
        -:   48:  /// \returns true if this APSInt is negative, false otherwise
        -:   49:  bool isNegative() const { return isSigned() && APInt::isNegative(); }
        -:   50:
        -:   51:  /// Determine if this APSInt Value is non-negative (>= 0)
        -:   52:  ///
        -:   53:  /// \returns true if this APSInt is non-negative, false otherwise
        -:   54:  bool isNonNegative() const { return !isNegative(); }
        -:   55:
        -:   56:  /// Determine if this APSInt Value is positive.
        -:   57:  ///
        -:   58:  /// This tests if the value of this APSInt is positive (> 0). Note
        -:   59:  /// that 0 is not a positive value.
        -:   60:  ///
        -:   61:  /// \returns true if this APSInt is positive.
        -:   62:  bool isStrictlyPositive() const { return isNonNegative() && !isZero(); }
        -:   63:
        -:   64:  APSInt &operator=(APInt RHS) {
        -:   65:    // Retain our current sign.
        -:   66:    APInt::operator=(std::move(RHS));
        -:   67:    return *this;
        -:   68:  }
        -:   69:
        -:   70:  APSInt &operator=(uint64_t RHS) {
        -:   71:    // Retain our current sign.
        -:   72:    APInt::operator=(RHS);
        -:   73:    return *this;
        -:   74:  }
        -:   75:
        -:   76:  // Query sign information.
        -:   77:  bool isSigned() const { return !IsUnsigned; }
        -:   78:  bool isUnsigned() const { return IsUnsigned; }
        -:   79:  void setIsUnsigned(bool Val) { IsUnsigned = Val; }
        -:   80:  void setIsSigned(bool Val) { IsUnsigned = !Val; }
        -:   81:
        -:   82:  /// Append this APSInt to the specified SmallString.
        -:   83:  void toString(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {
        -:   84:    APInt::toString(Str, Radix, isSigned());
        -:   85:  }
        -:   86:  using APInt::toString;
        -:   87:
        -:   88:  /// Get the correctly-extended \c int64_t value.
        -:   89:  int64_t getExtValue() const {
        -:   90:    assert(getMinSignedBits() <= 64 && "Too many bits for int64_t");
        -:   91:    return isSigned() ? getSExtValue() : getZExtValue();
        -:   92:  }
        -:   93:
        -:   94:  APSInt trunc(uint32_t width) const {
        -:   95:    return APSInt(APInt::trunc(width), IsUnsigned);
        -:   96:  }
        -:   97:
        -:   98:  APSInt extend(uint32_t width) const {
        -:   99:    if (IsUnsigned)
        -:  100:      return APSInt(zext(width), IsUnsigned);
        -:  101:    else
        -:  102:      return APSInt(sext(width), IsUnsigned);
        -:  103:  }
        -:  104:
        -:  105:  APSInt extOrTrunc(uint32_t width) const {
        -:  106:    if (IsUnsigned)
        -:  107:      return APSInt(zextOrTrunc(width), IsUnsigned);
        -:  108:    else
        -:  109:      return APSInt(sextOrTrunc(width), IsUnsigned);
        -:  110:  }
        -:  111:
        -:  112:  const APSInt &operator%=(const APSInt &RHS) {
        -:  113:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  114:    if (IsUnsigned)
        -:  115:      *this = urem(RHS);
        -:  116:    else
        -:  117:      *this = srem(RHS);
        -:  118:    return *this;
        -:  119:  }
        -:  120:  const APSInt &operator/=(const APSInt &RHS) {
        -:  121:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  122:    if (IsUnsigned)
        -:  123:      *this = udiv(RHS);
        -:  124:    else
        -:  125:      *this = sdiv(RHS);
        -:  126:    return *this;
        -:  127:  }
        -:  128:  APSInt operator%(const APSInt &RHS) const {
        -:  129:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  130:    return IsUnsigned ? APSInt(urem(RHS), true) : APSInt(srem(RHS), false);
        -:  131:  }
        -:  132:  APSInt operator/(const APSInt &RHS) const {
        -:  133:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  134:    return IsUnsigned ? APSInt(udiv(RHS), true) : APSInt(sdiv(RHS), false);
        -:  135:  }
        -:  136:
        -:  137:  APSInt operator>>(unsigned Amt) const {
        -:  138:    return IsUnsigned ? APSInt(lshr(Amt), true) : APSInt(ashr(Amt), false);
        -:  139:  }
        -:  140:  APSInt& operator>>=(unsigned Amt) {
        -:  141:    if (IsUnsigned)
        -:  142:      lshrInPlace(Amt);
        -:  143:    else
        -:  144:      ashrInPlace(Amt);
        -:  145:    return *this;
        -:  146:  }
        -:  147:  APSInt relativeShr(unsigned Amt) const {
        -:  148:    return IsUnsigned ? APSInt(relativeLShr(Amt), true)
        -:  149:                      : APSInt(relativeAShr(Amt), false);
        -:  150:  }
        -:  151:
        -:  152:  inline bool operator<(const APSInt& RHS) const {
        -:  153:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  154:    return IsUnsigned ? ult(RHS) : slt(RHS);
        -:  155:  }
        -:  156:  inline bool operator>(const APSInt& RHS) const {
        -:  157:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  158:    return IsUnsigned ? ugt(RHS) : sgt(RHS);
        -:  159:  }
        -:  160:  inline bool operator<=(const APSInt& RHS) const {
        -:  161:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  162:    return IsUnsigned ? ule(RHS) : sle(RHS);
        -:  163:  }
        -:  164:  inline bool operator>=(const APSInt& RHS) const {
        -:  165:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  166:    return IsUnsigned ? uge(RHS) : sge(RHS);
        -:  167:  }
        -:  168:  inline bool operator==(const APSInt& RHS) const {
        -:  169:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  170:    return eq(RHS);
        -:  171:  }
        -:  172:  inline bool operator!=(const APSInt& RHS) const {
        -:  173:    return !((*this) == RHS);
        -:  174:  }
        -:  175:
        -:  176:  bool operator==(int64_t RHS) const {
        -:  177:    return compareValues(*this, get(RHS)) == 0;
        -:  178:  }
        -:  179:  bool operator!=(int64_t RHS) const {
        -:  180:    return compareValues(*this, get(RHS)) != 0;
        -:  181:  }
        -:  182:  bool operator<=(int64_t RHS) const {
        -:  183:    return compareValues(*this, get(RHS)) <= 0;
        -:  184:  }
        -:  185:  bool operator>=(int64_t RHS) const {
        -:  186:    return compareValues(*this, get(RHS)) >= 0;
        -:  187:  }
        -:  188:  bool operator<(int64_t RHS) const {
        -:  189:    return compareValues(*this, get(RHS)) < 0;
        -:  190:  }
        -:  191:  bool operator>(int64_t RHS) const {
        -:  192:    return compareValues(*this, get(RHS)) > 0;
        -:  193:  }
        -:  194:
        -:  195:  // The remaining operators just wrap the logic of APInt, but retain the
        -:  196:  // signedness information.
        -:  197:
        -:  198:  APSInt operator<<(unsigned Bits) const {
        -:  199:    return APSInt(static_cast<const APInt&>(*this) << Bits, IsUnsigned);
        -:  200:  }
        -:  201:  APSInt& operator<<=(unsigned Amt) {
        -:  202:    static_cast<APInt&>(*this) <<= Amt;
        -:  203:    return *this;
        -:  204:  }
        -:  205:  APSInt relativeShl(unsigned Amt) const {
        -:  206:    return IsUnsigned ? APSInt(relativeLShl(Amt), true)
        -:  207:                      : APSInt(relativeAShl(Amt), false);
        -:  208:  }
        -:  209:
        -:  210:  APSInt& operator++() {
        -:  211:    ++(static_cast<APInt&>(*this));
        -:  212:    return *this;
        -:  213:  }
        -:  214:  APSInt& operator--() {
        -:  215:    --(static_cast<APInt&>(*this));
        -:  216:    return *this;
        -:  217:  }
        -:  218:  APSInt operator++(int) {
        -:  219:    return APSInt(++static_cast<APInt&>(*this), IsUnsigned);
        -:  220:  }
        -:  221:  APSInt operator--(int) {
        -:  222:    return APSInt(--static_cast<APInt&>(*this), IsUnsigned);
        -:  223:  }
        -:  224:  APSInt operator-() const {
        -:  225:    return APSInt(-static_cast<const APInt&>(*this), IsUnsigned);
        -:  226:  }
        -:  227:  APSInt& operator+=(const APSInt& RHS) {
        -:  228:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  229:    static_cast<APInt&>(*this) += RHS;
        -:  230:    return *this;
        -:  231:  }
        -:  232:  APSInt& operator-=(const APSInt& RHS) {
        -:  233:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  234:    static_cast<APInt&>(*this) -= RHS;
        -:  235:    return *this;
        -:  236:  }
        -:  237:  APSInt& operator*=(const APSInt& RHS) {
        -:  238:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  239:    static_cast<APInt&>(*this) *= RHS;
        -:  240:    return *this;
        -:  241:  }
        -:  242:  APSInt& operator&=(const APSInt& RHS) {
        -:  243:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  244:    static_cast<APInt&>(*this) &= RHS;
        -:  245:    return *this;
        -:  246:  }
        -:  247:  APSInt& operator|=(const APSInt& RHS) {
        -:  248:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  249:    static_cast<APInt&>(*this) |= RHS;
        -:  250:    return *this;
        -:  251:  }
        -:  252:  APSInt& operator^=(const APSInt& RHS) {
        -:  253:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  254:    static_cast<APInt&>(*this) ^= RHS;
        -:  255:    return *this;
        -:  256:  }
        -:  257:
        -:  258:  APSInt operator&(const APSInt& RHS) const {
        -:  259:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  260:    return APSInt(static_cast<const APInt&>(*this) & RHS, IsUnsigned);
        -:  261:  }
        -:  262:
        -:  263:  APSInt operator|(const APSInt& RHS) const {
        -:  264:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  265:    return APSInt(static_cast<const APInt&>(*this) | RHS, IsUnsigned);
        -:  266:  }
        -:  267:
        -:  268:  APSInt operator^(const APSInt &RHS) const {
        -:  269:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  270:    return APSInt(static_cast<const APInt&>(*this) ^ RHS, IsUnsigned);
        -:  271:  }
        -:  272:
        -:  273:  APSInt operator*(const APSInt& RHS) const {
        -:  274:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  275:    return APSInt(static_cast<const APInt&>(*this) * RHS, IsUnsigned);
        -:  276:  }
        -:  277:  APSInt operator+(const APSInt& RHS) const {
        -:  278:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  279:    return APSInt(static_cast<const APInt&>(*this) + RHS, IsUnsigned);
        -:  280:  }
        -:  281:  APSInt operator-(const APSInt& RHS) const {
        -:  282:    assert(IsUnsigned == RHS.IsUnsigned && "Signedness mismatch!");
        -:  283:    return APSInt(static_cast<const APInt&>(*this) - RHS, IsUnsigned);
        -:  284:  }
        -:  285:  APSInt operator~() const {
        -:  286:    return APSInt(~static_cast<const APInt&>(*this), IsUnsigned);
        -:  287:  }
        -:  288:
        -:  289:  /// Return the APSInt representing the maximum integer value with the given
        -:  290:  /// bit width and signedness.
        -:  291:  static APSInt getMaxValue(uint32_t numBits, bool Unsigned) {
        -:  292:    return APSInt(Unsigned ? APInt::getMaxValue(numBits)
        -:  293:                           : APInt::getSignedMaxValue(numBits), Unsigned);
        -:  294:  }
        -:  295:
        -:  296:  /// Return the APSInt representing the minimum integer value with the given
        -:  297:  /// bit width and signedness.
        -:  298:  static APSInt getMinValue(uint32_t numBits, bool Unsigned) {
        -:  299:    return APSInt(Unsigned ? APInt::getMinValue(numBits)
        -:  300:                           : APInt::getSignedMinValue(numBits), Unsigned);
        -:  301:  }
        -:  302:
        -:  303:  /// Determine if two APSInts have the same value, zero- or
        -:  304:  /// sign-extending as needed.
        -:  305:  static bool isSameValue(const APSInt &I1, const APSInt &I2) {
        -:  306:    return !compareValues(I1, I2);
        -:  307:  }
        -:  308:
        -:  309:  /// Compare underlying values of two numbers.
        -:  310:  static int compareValues(const APSInt &I1, const APSInt &I2) {
        -:  311:    if (I1.getBitWidth() == I2.getBitWidth() && I1.isSigned() == I2.isSigned())
        -:  312:      return I1.IsUnsigned ? I1.compare(I2) : I1.compareSigned(I2);
        -:  313:
        -:  314:    // Check for a bit-width mismatch.
        -:  315:    if (I1.getBitWidth() > I2.getBitWidth())
        -:  316:      return compareValues(I1, I2.extend(I1.getBitWidth()));
        -:  317:    if (I2.getBitWidth() > I1.getBitWidth())
        -:  318:      return compareValues(I1.extend(I2.getBitWidth()), I2);
        -:  319:
        -:  320:    // We have a signedness mismatch. Check for negative values and do an
        -:  321:    // unsigned compare if both are positive.
        -:  322:    if (I1.isSigned()) {
        -:  323:      assert(!I2.isSigned() && "Expected signed mismatch");
        -:  324:      if (I1.isNegative())
        -:  325:        return -1;
        -:  326:    } else {
        -:  327:      assert(I2.isSigned() && "Expected signed mismatch");
        -:  328:      if (I2.isNegative())
        -:  329:        return 1;
        -:  330:    }
        -:  331:
        -:  332:    return I1.compare(I2);
        -:  333:  }
        -:  334:
        -:  335:  static APSInt get(int64_t X) { return APSInt(APInt(64, X), false); }
        -:  336:  static APSInt getUnsigned(uint64_t X) { return APSInt(APInt(64, X), true); }
        -:  337:
        -:  338:  /// Used to insert APSInt objects, or objects that contain APSInt objects,
        -:  339:  /// into FoldingSets.
        -:  340:  void Profile(FoldingSetNodeID& ID) const;
        -:  341:};
        -:  342:
        -:  343:inline bool operator==(int64_t V1, const APSInt &V2) { return V2 == V1; }
        -:  344:inline bool operator!=(int64_t V1, const APSInt &V2) { return V2 != V1; }
        -:  345:inline bool operator<=(int64_t V1, const APSInt &V2) { return V2 >= V1; }
        -:  346:inline bool operator>=(int64_t V1, const APSInt &V2) { return V2 <= V1; }
        -:  347:inline bool operator<(int64_t V1, const APSInt &V2) { return V2 > V1; }
        -:  348:inline bool operator>(int64_t V1, const APSInt &V2) { return V2 < V1; }
        -:  349:
        -:  350:inline raw_ostream &operator<<(raw_ostream &OS, const APSInt &I) {
        -:  351:  I.print(OS, I.isSigned());
        -:  352:  return OS;
        -:  353:}
        -:  354:
        -:  355:/// Provide DenseMapInfo for APSInt, using the DenseMapInfo for APInt.
        -:  356:template <> struct DenseMapInfo<APSInt, void> {
        -:  357:  static inline APSInt getEmptyKey() {
        -:  358:    return APSInt(DenseMapInfo<APInt, void>::getEmptyKey());
        -:  359:  }
        -:  360:
        -:  361:  static inline APSInt getTombstoneKey() {
        -:  362:    return APSInt(DenseMapInfo<APInt, void>::getTombstoneKey());
        -:  363:  }
        -:  364:
        -:  365:  static unsigned getHashValue(const APSInt &Key) {
        -:  366:    return DenseMapInfo<APInt, void>::getHashValue(Key);
        -:  367:  }
        -:  368:
        -:  369:  static bool isEqual(const APSInt &LHS, const APSInt &RHS) {
        -:  370:    return LHS.getBitWidth() == RHS.getBitWidth() &&
        -:  371:           LHS.isUnsigned() == RHS.isUnsigned() && LHS == RHS;
        -:  372:  }
        -:  373:};
        -:  374:
        -:  375:} // end namespace llvm
        -:  376:
        -:  377:#endif
