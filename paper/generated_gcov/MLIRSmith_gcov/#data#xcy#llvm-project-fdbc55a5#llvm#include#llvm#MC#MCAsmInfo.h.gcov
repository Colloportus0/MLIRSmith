        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/llvm/include/llvm/MC/MCAsmInfo.h
        -:    0:Graph:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUTransforms.dir/Transforms/SerializeToHsaco.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUTransforms.dir/Transforms/SerializeToHsaco.cpp.gcda
        -:    0:Runs:116158
        -:    1://===-- llvm/MC/MCAsmInfo.h - Asm info --------------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains a class to be used as the basis for target specific
        -:   10:// asm writers.  This class primarily takes care of global printing constants,
        -:   11:// which are used in very similar ways across all targets.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef LLVM_MC_MCASMINFO_H
        -:   16:#define LLVM_MC_MCASMINFO_H
        -:   17:
        -:   18:#include "llvm/ADT/StringRef.h"
        -:   19:#include "llvm/MC/MCDirectives.h"
        -:   20:#include "llvm/MC/MCTargetOptions.h"
        -:   21:#include <vector>
        -:   22:
        -:   23:namespace llvm {
        -:   24:
        -:   25:class MCContext;
        -:   26:class MCCFIInstruction;
        -:   27:class MCExpr;
        -:   28:class MCSection;
        -:   29:class MCStreamer;
        -:   30:class MCSubtargetInfo;
        -:   31:class MCSymbol;
        -:   32:
        -:   33:namespace WinEH {
        -:   34:
        -:   35:enum class EncodingType {
        -:   36:  Invalid, /// Invalid
        -:   37:  Alpha,   /// Windows Alpha
        -:   38:  Alpha64, /// Windows AXP64
        -:   39:  ARM,     /// Windows NT (Windows on ARM)
        -:   40:  CE,      /// Windows CE ARM, PowerPC, SH3, SH4
        -:   41:  Itanium, /// Windows x64, Windows Itanium (IA-64)
        -:   42:  X86,     /// Windows x86, uses no CFI, just EH tables
        -:   43:  MIPS = Alpha,
        -:   44:};
        -:   45:
        -:   46:} // end namespace WinEH
        -:   47:
        -:   48:namespace LCOMM {
        -:   49:
        -:   50:enum LCOMMType { NoAlignment, ByteAlignment, Log2Alignment };
        -:   51:
        -:   52:} // end namespace LCOMM
        -:   53:
        -:   54:/// This class is intended to be used as a base class for asm
        -:   55:/// properties and features specific to the target.
        -:   56:class MCAsmInfo {
        -:   57:public:
        -:   58:  /// Assembly character literal syntax types.
        -:   59:  enum AsmCharLiteralSyntax {
        -:   60:    ACLS_Unknown, /// Unknown; character literals not used by LLVM for this
        -:   61:                  /// target.
        -:   62:    ACLS_SingleQuotePrefix, /// The desired character is prefixed by a single
        -:   63:                            /// quote, e.g., `'A`.
        -:   64:  };
        -:   65:
        -:   66:protected:
        -:   67:  //===------------------------------------------------------------------===//
        -:   68:  // Properties to be set by the target writer, used to configure asm printer.
        -:   69:  //
        -:   70:
        -:   71:  /// Code pointer size in bytes.  Default is 4.
        -:   72:  unsigned CodePointerSize = 4;
        -:   73:
        -:   74:  /// Size of the stack slot reserved for callee-saved registers, in bytes.
        -:   75:  /// Default is same as pointer size.
        -:   76:  unsigned CalleeSaveStackSlotSize = 4;
        -:   77:
        -:   78:  /// True if target is little endian.  Default is true.
        -:   79:  bool IsLittleEndian = true;
        -:   80:
        -:   81:  /// True if target stack grow up.  Default is false.
        -:   82:  bool StackGrowsUp = false;
        -:   83:
        -:   84:  /// True if this target has the MachO .subsections_via_symbols directive.
        -:   85:  /// Default is false.
        -:   86:  bool HasSubsectionsViaSymbols = false;
        -:   87:
        -:   88:  /// True if this is a MachO target that supports the macho-specific .zerofill
        -:   89:  /// directive for emitting BSS Symbols.  Default is false.
        -:   90:  bool HasMachoZeroFillDirective = false;
        -:   91:
        -:   92:  /// True if this is a MachO target that supports the macho-specific .tbss
        -:   93:  /// directive for emitting thread local BSS Symbols.  Default is false.
        -:   94:  bool HasMachoTBSSDirective = false;
        -:   95:
        -:   96:  /// True if this is a non-GNU COFF target. The COFF port of the GNU linker
        -:   97:  /// doesn't handle associative comdats in the way that we would like to use
        -:   98:  /// them.
        -:   99:  bool HasCOFFAssociativeComdats = false;
        -:  100:
        -:  101:  /// True if this is a non-GNU COFF target. For GNU targets, we don't generate
        -:  102:  /// constants into comdat sections.
        -:  103:  bool HasCOFFComdatConstants = false;
        -:  104:
        -:  105:  /// True if this is an XCOFF target that supports visibility attributes as
        -:  106:  /// part of .global, .weak, .extern, and .comm. Default is false.
        -:  107:  bool HasVisibilityOnlyWithLinkage = false;
        -:  108:
        -:  109:  /// This is the maximum possible length of an instruction, which is needed to
        -:  110:  /// compute the size of an inline asm.  Defaults to 4.
        -:  111:  unsigned MaxInstLength = 4;
        -:  112:
        -:  113:  /// Every possible instruction length is a multiple of this value.  Factored
        -:  114:  /// out in .debug_frame and .debug_line.  Defaults to 1.
        -:  115:  unsigned MinInstAlignment = 1;
        -:  116:
        -:  117:  /// The '$' token, when not referencing an identifier or constant, refers to
        -:  118:  /// the current PC.  Defaults to false.
        -:  119:  bool DollarIsPC = false;
        -:  120:
        -:  121:  /// Allow '.' token, when not referencing an identifier or constant, to refer
        -:  122:  /// to the current PC. Defaults to true.
        -:  123:  bool DotIsPC = true;
        -:  124:
        -:  125:  /// Whether the '*' token refers to the current PC. This is used for the
        -:  126:  /// HLASM dialect.
        -:  127:  bool StarIsPC = false;
        -:  128:
        -:  129:  /// This string, if specified, is used to separate instructions from each
        -:  130:  /// other when on the same line.  Defaults to ';'
        -:  131:  const char *SeparatorString;
        -:  132:
        -:  133:  /// This indicates the comment string used by the assembler.  Defaults to
        -:  134:  /// "#"
        -:  135:  StringRef CommentString;
        -:  136:
        -:  137:  /// This indicates whether the comment string is only accepted as a comment
        -:  138:  /// at the beginning of statements. Defaults to false.
        -:  139:  bool RestrictCommentStringToStartOfStatement = false;
        -:  140:
        -:  141:  /// This indicates whether to allow additional "comment strings" to be lexed
        -:  142:  /// as a comment. Setting this attribute to true, will ensure that C-style
        -:  143:  /// line comments (// ..), C-style block comments (/* .. */), and "#" are
        -:  144:  /// all treated as comments in addition to the string specified by the
        -:  145:  /// CommentString attribute.
        -:  146:  /// Default is true.
        -:  147:  bool AllowAdditionalComments = true;
        -:  148:
        -:  149:  /// Should we emit the '\t' as the starting indentation marker for GNU inline
        -:  150:  /// asm statements. Defaults to true.
        -:  151:  bool EmitGNUAsmStartIndentationMarker = true;
        -:  152:
        -:  153:  /// This is appended to emitted labels.  Defaults to ":"
        -:  154:  const char *LabelSuffix;
        -:  155:
        -:  156:  /// Emit labels in purely upper case. Defaults to false.
        -:  157:  bool EmitLabelsInUpperCase = false;
        -:  158:
        -:  159:  // Print the EH begin symbol with an assignment. Defaults to false.
        -:  160:  bool UseAssignmentForEHBegin = false;
        -:  161:
        -:  162:  // Do we need to create a local symbol for .size?
        -:  163:  bool NeedsLocalForSize = false;
        -:  164:
        -:  165:  /// This prefix is used for globals like constant pool entries that are
        -:  166:  /// completely private to the .s file and should not have names in the .o
        -:  167:  /// file.  Defaults to "L"
        -:  168:  StringRef PrivateGlobalPrefix;
        -:  169:
        -:  170:  /// This prefix is used for labels for basic blocks. Defaults to the same as
        -:  171:  /// PrivateGlobalPrefix.
        -:  172:  StringRef PrivateLabelPrefix;
        -:  173:
        -:  174:  /// This prefix is used for symbols that should be passed through the
        -:  175:  /// assembler but be removed by the linker.  This is 'l' on Darwin, currently
        -:  176:  /// used for some ObjC metadata.  The default of "" meast that for this system
        -:  177:  /// a plain private symbol should be used.  Defaults to "".
        -:  178:  StringRef LinkerPrivateGlobalPrefix;
        -:  179:
        -:  180:  /// If these are nonempty, they contain a directive to emit before and after
        -:  181:  /// an inline assembly statement.  Defaults to "#APP\n", "#NO_APP\n"
        -:  182:  const char *InlineAsmStart;
        -:  183:  const char *InlineAsmEnd;
        -:  184:
        -:  185:  /// These are assembly directives that tells the assembler to interpret the
        -:  186:  /// following instructions differently.  Defaults to ".code16", ".code32",
        -:  187:  /// ".code64".
        -:  188:  const char *Code16Directive;
        -:  189:  const char *Code32Directive;
        -:  190:  const char *Code64Directive;
        -:  191:
        -:  192:  /// Which dialect of an assembler variant to use.  Defaults to 0
        -:  193:  unsigned AssemblerDialect = 0;
        -:  194:
        -:  195:  /// This is true if the assembler allows @ characters in symbol names.
        -:  196:  /// Defaults to false.
        -:  197:  bool AllowAtInName = false;
        -:  198:
        -:  199:  /// This is true if the assembler allows the "?" character at the start of
        -:  200:  /// of a string to be lexed as an AsmToken::Identifier.
        -:  201:  /// If the AsmLexer determines that the string can be lexed as a possible
        -:  202:  /// comment, setting this option will have no effect, and the string will
        -:  203:  /// still be lexed as a comment.
        -:  204:  bool AllowQuestionAtStartOfIdentifier = false;
        -:  205:
        -:  206:  /// This is true if the assembler allows the "$" character at the start of
        -:  207:  /// of a string to be lexed as an AsmToken::Identifier.
        -:  208:  /// If the AsmLexer determines that the string can be lexed as a possible
        -:  209:  /// comment, setting this option will have no effect, and the string will
        -:  210:  /// still be lexed as a comment.
        -:  211:  bool AllowDollarAtStartOfIdentifier = false;
        -:  212:
        -:  213:  /// This is true if the assembler allows the "@" character at the start of
        -:  214:  /// a string to be lexed as an AsmToken::Identifier.
        -:  215:  /// If the AsmLexer determines that the string can be lexed as a possible
        -:  216:  /// comment, setting this option will have no effect, and the string will
        -:  217:  /// still be lexed as a comment.
        -:  218:  bool AllowAtAtStartOfIdentifier = false;
        -:  219:
        -:  220:  /// This is true if the assembler allows the "#" character at the start of
        -:  221:  /// a string to be lexed as an AsmToken::Identifier.
        -:  222:  /// If the AsmLexer determines that the string can be lexed as a possible
        -:  223:  /// comment, setting this option will have no effect, and the string will
        -:  224:  /// still be lexed as a comment.
        -:  225:  bool AllowHashAtStartOfIdentifier = false;
        -:  226:
        -:  227:  /// If this is true, symbol names with invalid characters will be printed in
        -:  228:  /// quotes.
        -:  229:  bool SupportsQuotedNames = true;
        -:  230:
        -:  231:  /// This is true if data region markers should be printed as
        -:  232:  /// ".data_region/.end_data_region" directives. If false, use "$d/$a" labels
        -:  233:  /// instead.
        -:  234:  bool UseDataRegionDirectives = false;
        -:  235:
        -:  236:  /// True if .align is to be used for alignment. Only power-of-two
        -:  237:  /// alignment is supported.
        -:  238:  bool UseDotAlignForAlignment = false;
        -:  239:
        -:  240:  /// True if the target supports LEB128 directives.
        -:  241:  bool HasLEB128Directives = true;
        -:  242:
        -:  243:  //===--- Data Emission Directives -------------------------------------===//
        -:  244:
        -:  245:  /// This should be set to the directive used to get some number of zero (and
        -:  246:  /// non-zero if supported by the directive) bytes emitted to the current
        -:  247:  /// section. Common cases are "\t.zero\t" and "\t.space\t". Defaults to
        -:  248:  /// "\t.zero\t"
        -:  249:  const char *ZeroDirective;
        -:  250:
        -:  251:  /// This should be set to true if the zero directive supports a value to emit
        -:  252:  /// other than zero. If this is set to false, the Data*bitsDirective's will be
        -:  253:  /// used to emit these bytes. Defaults to true.
        -:  254:  bool ZeroDirectiveSupportsNonZeroValue = true;
        -:  255:
        -:  256:  /// This directive allows emission of an ascii string with the standard C
        -:  257:  /// escape characters embedded into it.  If a target doesn't support this, it
        -:  258:  /// can be set to null. Defaults to "\t.ascii\t"
        -:  259:  const char *AsciiDirective;
        -:  260:
        -:  261:  /// If not null, this allows for special handling of zero terminated strings
        -:  262:  /// on this target.  This is commonly supported as ".asciz".  If a target
        -:  263:  /// doesn't support this, it can be set to null.  Defaults to "\t.asciz\t"
        -:  264:  const char *AscizDirective;
        -:  265:
        -:  266:  /// This directive accepts a comma-separated list of bytes for emission as a
        -:  267:  /// string of bytes.  For targets that do not support this, it shall be set to
        -:  268:  /// null.  Defaults to null.
        -:  269:  const char *ByteListDirective = nullptr;
        -:  270:
        -:  271:  /// This directive allows emission of a zero-terminated ascii string without
        -:  272:  /// the standard C escape characters embedded into it.  If a target doesn't
        -:  273:  /// support this, it can be set to null. Defaults to null.
        -:  274:  const char *PlainStringDirective = nullptr;
        -:  275:
        -:  276:  /// Form used for character literals in the assembly syntax.  Useful for
        -:  277:  /// producing strings as byte lists.  If a target does not use or support
        -:  278:  /// this, it shall be set to ACLS_Unknown.  Defaults to ACLS_Unknown.
        -:  279:  AsmCharLiteralSyntax CharacterLiteralSyntax = ACLS_Unknown;
        -:  280:
        -:  281:  /// These directives are used to output some unit of integer data to the
        -:  282:  /// current section.  If a data directive is set to null, smaller data
        -:  283:  /// directives will be used to emit the large sizes.  Defaults to "\t.byte\t",
        -:  284:  /// "\t.short\t", "\t.long\t", "\t.quad\t"
        -:  285:  const char *Data8bitsDirective;
        -:  286:  const char *Data16bitsDirective;
        -:  287:  const char *Data32bitsDirective;
        -:  288:  const char *Data64bitsDirective;
        -:  289:
        -:  290:  /// True if data directives support signed values
        -:  291:  bool SupportsSignedData = true;
        -:  292:
        -:  293:  /// If non-null, a directive that is used to emit a word which should be
        -:  294:  /// relocated as a 64-bit GP-relative offset, e.g. .gpdword on Mips.  Defaults
        -:  295:  /// to nullptr.
        -:  296:  const char *GPRel64Directive = nullptr;
        -:  297:
        -:  298:  /// If non-null, a directive that is used to emit a word which should be
        -:  299:  /// relocated as a 32-bit GP-relative offset, e.g. .gpword on Mips or .gprel32
        -:  300:  /// on Alpha.  Defaults to nullptr.
        -:  301:  const char *GPRel32Directive = nullptr;
        -:  302:
        -:  303:  /// If non-null, directives that are used to emit a word/dword which should
        -:  304:  /// be relocated as a 32/64-bit DTP/TP-relative offset, e.g. .dtprelword/
        -:  305:  /// .dtpreldword/.tprelword/.tpreldword on Mips.
        -:  306:  const char *DTPRel32Directive = nullptr;
        -:  307:  const char *DTPRel64Directive = nullptr;
        -:  308:  const char *TPRel32Directive = nullptr;
        -:  309:  const char *TPRel64Directive = nullptr;
        -:  310:
        -:  311:  /// This is true if this target uses "Sun Style" syntax for section switching
        -:  312:  /// ("#alloc,#write" etc) instead of the normal ELF syntax (,"a,w") in
        -:  313:  /// .section directives.  Defaults to false.
        -:  314:  bool SunStyleELFSectionSwitchSyntax = false;
        -:  315:
        -:  316:  /// This is true if this target uses ELF '.section' directive before the
        -:  317:  /// '.bss' one. It's used for PPC/Linux which doesn't support the '.bss'
        -:  318:  /// directive only.  Defaults to false.
        -:  319:  bool UsesELFSectionDirectiveForBSS = false;
        -:  320:
        -:  321:  bool NeedsDwarfSectionOffsetDirective = false;
        -:  322:
        -:  323:  //===--- Alignment Information ----------------------------------------===//
        -:  324:
        -:  325:  /// If this is true (the default) then the asmprinter emits ".align N"
        -:  326:  /// directives, where N is the number of bytes to align to.  Otherwise, it
        -:  327:  /// emits ".align log2(N)", e.g. 3 to align to an 8 byte boundary.  Defaults
        -:  328:  /// to true.
        -:  329:  bool AlignmentIsInBytes = true;
        -:  330:
        -:  331:  /// If non-zero, this is used to fill the executable space created as the
        -:  332:  /// result of a alignment directive.  Defaults to 0
        -:  333:  unsigned TextAlignFillValue = 0;
        -:  334:
        -:  335:  //===--- Global Variable Emission Directives --------------------------===//
        -:  336:
        -:  337:  /// This is the directive used to declare a global entity. Defaults to
        -:  338:  /// ".globl".
        -:  339:  const char *GlobalDirective;
        -:  340:
        -:  341:  /// True if the expression
        -:  342:  ///   .long f - g
        -:  343:  /// uses a relocation but it can be suppressed by writing
        -:  344:  ///   a = f - g
        -:  345:  ///   .long a
        -:  346:  bool SetDirectiveSuppressesReloc = false;
        -:  347:
        -:  348:  /// False if the assembler requires that we use
        -:  349:  /// \code
        -:  350:  ///   Lc = a - b
        -:  351:  ///   .long Lc
        -:  352:  /// \endcode
        -:  353:  //
        -:  354:  /// instead of
        -:  355:  //
        -:  356:  /// \code
        -:  357:  ///   .long a - b
        -:  358:  /// \endcode
        -:  359:  ///
        -:  360:  ///  Defaults to true.
        -:  361:  bool HasAggressiveSymbolFolding = true;
        -:  362:
        -:  363:  /// True is .comm's and .lcomms optional alignment is to be specified in bytes
        -:  364:  /// instead of log2(n).  Defaults to true.
        -:  365:  bool COMMDirectiveAlignmentIsInBytes = true;
        -:  366:
        -:  367:  /// Describes if the .lcomm directive for the target supports an alignment
        -:  368:  /// argument and how it is interpreted.  Defaults to NoAlignment.
        -:  369:  LCOMM::LCOMMType LCOMMDirectiveAlignmentType = LCOMM::NoAlignment;
        -:  370:
        -:  371:  /// True if the target only has basename for .file directive. False if the
        -:  372:  /// target also needs the directory along with the basename. Defaults to true.
        -:  373:  bool HasBasenameOnlyForFileDirective = true;
        -:  374:
        -:  375:  /// True if the target represents string constants as mostly raw characters in
        -:  376:  /// paired double quotation with paired double quotation marks as the escape
        -:  377:  /// mechanism to represent a double quotation mark within the string. Defaults
        -:  378:  /// to false.
        -:  379:  bool HasPairedDoubleQuoteStringConstants = false;
        -:  380:
        -:  381:  // True if the target allows .align directives on functions. This is true for
        -:  382:  // most targets, so defaults to true.
        -:  383:  bool HasFunctionAlignment = true;
        -:  384:
        -:  385:  /// True if the target has .type and .size directives, this is true for most
        -:  386:  /// ELF targets.  Defaults to true.
        -:  387:  bool HasDotTypeDotSizeDirective = true;
        -:  388:
        -:  389:  /// True if the target has a single parameter .file directive, this is true
        -:  390:  /// for ELF targets.  Defaults to true.
        -:  391:  bool HasSingleParameterDotFile = true;
        -:  392:
        -:  393:  /// True if the target has a four strings .file directive, strings seperated
        -:  394:  /// by comma. Defaults to false.
        -:  395:  bool HasFourStringsDotFile = false;
        -:  396:
        -:  397:  /// True if the target has a .ident directive, this is true for ELF targets.
        -:  398:  /// Defaults to false.
        -:  399:  bool HasIdentDirective = false;
        -:  400:
        -:  401:  /// True if this target supports the MachO .no_dead_strip directive.  Defaults
        -:  402:  /// to false.
        -:  403:  bool HasNoDeadStrip = false;
        -:  404:
        -:  405:  /// True if this target supports the MachO .alt_entry directive.  Defaults to
        -:  406:  /// false.
        -:  407:  bool HasAltEntry = false;
        -:  408:
        -:  409:  /// Used to declare a global as being a weak symbol. Defaults to ".weak".
        -:  410:  const char *WeakDirective;
        -:  411:
        -:  412:  /// This directive, if non-null, is used to declare a global as being a weak
        -:  413:  /// undefined symbol.  Defaults to nullptr.
        -:  414:  const char *WeakRefDirective = nullptr;
        -:  415:
        -:  416:  /// True if we have a directive to declare a global as being a weak defined
        -:  417:  /// symbol.  Defaults to false.
        -:  418:  bool HasWeakDefDirective = false;
        -:  419:
        -:  420:  /// True if we have a directive to declare a global as being a weak defined
        -:  421:  /// symbol that can be hidden (unexported).  Defaults to false.
        -:  422:  bool HasWeakDefCanBeHiddenDirective = false;
        -:  423:
        -:  424:  /// True if we should mark symbols as global instead of weak, for
        -:  425:  /// weak*/linkonce*, if the symbol has a comdat.
        -:  426:  /// Defaults to false.
        -:  427:  bool AvoidWeakIfComdat = false;
        -:  428:
        -:  429:  /// This attribute, if not MCSA_Invalid, is used to declare a symbol as having
        -:  430:  /// hidden visibility.  Defaults to MCSA_Hidden.
        -:  431:  MCSymbolAttr HiddenVisibilityAttr = MCSA_Hidden;
        -:  432:
        -:  433:  /// This attribute, if not MCSA_Invalid, is used to declare a symbol as having
        -:  434:  /// exported visibility.  Defaults to MCSA_Exported.
        -:  435:  MCSymbolAttr ExportedVisibilityAttr = MCSA_Exported;
        -:  436:
        -:  437:  /// This attribute, if not MCSA_Invalid, is used to declare an undefined
        -:  438:  /// symbol as having hidden visibility. Defaults to MCSA_Hidden.
        -:  439:  MCSymbolAttr HiddenDeclarationVisibilityAttr = MCSA_Hidden;
        -:  440:
        -:  441:  /// This attribute, if not MCSA_Invalid, is used to declare a symbol as having
        -:  442:  /// protected visibility.  Defaults to MCSA_Protected
        -:  443:  MCSymbolAttr ProtectedVisibilityAttr = MCSA_Protected;
        -:  444:
        -:  445:  //===--- Dwarf Emission Directives -----------------------------------===//
        -:  446:
        -:  447:  /// True if target supports emission of debugging information.  Defaults to
        -:  448:  /// false.
        -:  449:  bool SupportsDebugInformation = false;
        -:  450:
        -:  451:  /// Exception handling format for the target.  Defaults to None.
        -:  452:  ExceptionHandling ExceptionsType = ExceptionHandling::None;
        -:  453:
        -:  454:  /// True if target uses CFI unwind information for debugging purpose when
        -:  455:  /// `ExceptionsType == ExceptionHandling::None`.
        -:  456:  bool UsesCFIForDebug = false;
        -:  457:
        -:  458:  /// Windows exception handling data (.pdata) encoding.  Defaults to Invalid.
        -:  459:  WinEH::EncodingType WinEHEncodingType = WinEH::EncodingType::Invalid;
        -:  460:
        -:  461:  /// True if Dwarf2 output generally uses relocations for references to other
        -:  462:  /// .debug_* sections.
        -:  463:  bool DwarfUsesRelocationsAcrossSections = true;
        -:  464:
        -:  465:  /// True if DWARF FDE symbol reference relocations should be replaced by an
        -:  466:  /// absolute difference.
        -:  467:  bool DwarfFDESymbolsUseAbsDiff = false;
        -:  468:
        -:  469:  /// True if the target supports generating the DWARF line table through using
        -:  470:  /// the .loc/.file directives. Defaults to true.
        -:  471:  bool UsesDwarfFileAndLocDirectives = true;
        -:  472:
        -:  473:  /// True if DWARF `.file directory' directive syntax is used by
        -:  474:  /// default.
        -:  475:  bool EnableDwarfFileDirectoryDefault = true;
        -:  476:
        -:  477:  /// True if the target needs the DWARF section length in the header (if any)
        -:  478:  /// of the DWARF section in the assembly file. Defaults to true.
        -:  479:  bool DwarfSectionSizeRequired = true;
        -:  480:
        -:  481:  /// True if dwarf register numbers are printed instead of symbolic register
        -:  482:  /// names in .cfi_* directives.  Defaults to false.
        -:  483:  bool DwarfRegNumForCFI = false;
        -:  484:
        -:  485:  /// True if target uses parens to indicate the symbol variant instead of @.
        -:  486:  /// For example, foo(plt) instead of foo@plt.  Defaults to false.
        -:  487:  bool UseParensForSymbolVariant = false;
        -:  488:
        -:  489:  /// True if the target uses parens for symbol names starting with
        -:  490:  /// '$' character to distinguish them from absolute names.
        -:  491:  bool UseParensForDollarSignNames = true;
        -:  492:
        -:  493:  /// True if the target supports flags in ".loc" directive, false if only
        -:  494:  /// location is allowed.
        -:  495:  bool SupportsExtendedDwarfLocDirective = true;
        -:  496:
        -:  497:  //===--- Prologue State ----------------------------------------------===//
        -:  498:
        -:  499:  std::vector<MCCFIInstruction> InitialFrameState;
        -:  500:
        -:  501:  //===--- Integrated Assembler Information ----------------------------===//
        -:  502:
        -:  503:  // Generated object files can use all ELF features supported by GNU ld of
        -:  504:  // this binutils version and later. INT_MAX means all features can be used,
        -:  505:  // regardless of GNU ld support. The default value is referenced by
        -:  506:  // clang/Driver/Options.td.
        -:  507:  std::pair<int, int> BinutilsVersion = {2, 26};
        -:  508:
        -:  509:  /// Should we use the integrated assembler?
        -:  510:  /// The integrated assembler should be enabled by default (by the
        -:  511:  /// constructors) when failing to parse a valid piece of assembly (inline
        -:  512:  /// or otherwise) is considered a bug. It may then be overridden after
        -:  513:  /// construction (see LLVMTargetMachine::initAsmInfo()).
        -:  514:  bool UseIntegratedAssembler;
        -:  515:
        -:  516:  /// Use AsmParser to parse inlineAsm when UseIntegratedAssembler is not set.
        -:  517:  bool ParseInlineAsmUsingAsmParser;
        -:  518:
        -:  519:  /// Preserve Comments in assembly
        -:  520:  bool PreserveAsmComments;
        -:  521:
        -:  522:  /// Compress DWARF debug sections. Defaults to no compression.
        -:  523:  DebugCompressionType CompressDebugSections = DebugCompressionType::None;
        -:  524:
        -:  525:  /// True if the integrated assembler should interpret 'a >> b' constant
        -:  526:  /// expressions as logical rather than arithmetic.
        -:  527:  bool UseLogicalShr = true;
        -:  528:
        -:  529:  // If true, emit GOTPCRELX/REX_GOTPCRELX instead of GOTPCREL, on
        -:  530:  // X86_64 ELF.
        -:  531:  bool RelaxELFRelocations = true;
        -:  532:
        -:  533:  // If true, then the lexer and expression parser will support %neg(),
        -:  534:  // %hi(), and similar unary operators.
        -:  535:  bool HasMipsExpressions = false;
        -:  536:
        -:  537:  // If true, use Motorola-style integers in Assembly (ex. $0ac).
        -:  538:  bool UseMotorolaIntegers = false;
        -:  539:
        -:  540:  // If true, emit function descriptor symbol on AIX.
        -:  541:  bool NeedsFunctionDescriptors = false;
        -:  542:
        -:  543:public:
        -:  544:  explicit MCAsmInfo();
        -:  545:  virtual ~MCAsmInfo();
        -:  546:
        -:  547:  /// Get the code pointer size in bytes.
        -:  548:  unsigned getCodePointerSize() const { return CodePointerSize; }
        -:  549:
        -:  550:  /// Get the callee-saved register stack slot
        -:  551:  /// size in bytes.
        -:  552:  unsigned getCalleeSaveStackSlotSize() const {
        -:  553:    return CalleeSaveStackSlotSize;
        -:  554:  }
        -:  555:
        -:  556:  /// True if the target is little endian.
        -:  557:  bool isLittleEndian() const { return IsLittleEndian; }
        -:  558:
        -:  559:  /// True if target stack grow up.
        -:  560:  bool isStackGrowthDirectionUp() const { return StackGrowsUp; }
        -:  561:
        -:  562:  bool hasSubsectionsViaSymbols() const { return HasSubsectionsViaSymbols; }
        -:  563:
        -:  564:  // Data directive accessors.
        -:  565:
        -:  566:  const char *getData8bitsDirective() const { return Data8bitsDirective; }
        -:  567:  const char *getData16bitsDirective() const { return Data16bitsDirective; }
        -:  568:  const char *getData32bitsDirective() const { return Data32bitsDirective; }
        -:  569:  const char *getData64bitsDirective() const { return Data64bitsDirective; }
        -:  570:  bool supportsSignedData() const { return SupportsSignedData; }
        -:  571:  const char *getGPRel64Directive() const { return GPRel64Directive; }
        -:  572:  const char *getGPRel32Directive() const { return GPRel32Directive; }
        -:  573:  const char *getDTPRel64Directive() const { return DTPRel64Directive; }
        -:  574:  const char *getDTPRel32Directive() const { return DTPRel32Directive; }
        -:  575:  const char *getTPRel64Directive() const { return TPRel64Directive; }
        -:  576:  const char *getTPRel32Directive() const { return TPRel32Directive; }
        -:  577:
        -:  578:  /// Targets can implement this method to specify a section to switch to if the
        -:  579:  /// translation unit doesn't have any trampolines that require an executable
        -:  580:  /// stack.
        -:  581:  virtual MCSection *getNonexecutableStackSection(MCContext &Ctx) const {
        -:  582:    return nullptr;
        -:  583:  }
        -:  584:
        -:  585:  /// True if the section is atomized using the symbols in it.
        -:  586:  /// This is false if the section is not atomized at all (most ELF sections) or
        -:  587:  /// if it is atomized based on its contents (MachO' __TEXT,__cstring for
        -:  588:  /// example).
        -:  589:  virtual bool isSectionAtomizableBySymbols(const MCSection &Section) const;
        -:  590:
        -:  591:  virtual const MCExpr *getExprForPersonalitySymbol(const MCSymbol *Sym,
        -:  592:                                                    unsigned Encoding,
        -:  593:                                                    MCStreamer &Streamer) const;
        -:  594:
        -:  595:  virtual const MCExpr *getExprForFDESymbol(const MCSymbol *Sym,
        -:  596:                                            unsigned Encoding,
        -:  597:                                            MCStreamer &Streamer) const;
        -:  598:
        -:  599:  /// Return true if C is an acceptable character inside a symbol name.
        -:  600:  virtual bool isAcceptableChar(char C) const;
        -:  601:
        -:  602:  /// Return true if the identifier \p Name does not need quotes to be
        -:  603:  /// syntactically correct.
        -:  604:  virtual bool isValidUnquotedName(StringRef Name) const;
        -:  605:
        -:  606:  /// Return true if the .section directive should be omitted when
        -:  607:  /// emitting \p SectionName.  For example:
        -:  608:  ///
        -:  609:  /// shouldOmitSectionDirective(".text")
        -:  610:  ///
        -:  611:  /// returns false => .section .text,#alloc,#execinstr
        -:  612:  /// returns true  => .text
        -:  613:  virtual bool shouldOmitSectionDirective(StringRef SectionName) const;
        -:  614:
        -:  615:  bool usesSunStyleELFSectionSwitchSyntax() const {
        -:  616:    return SunStyleELFSectionSwitchSyntax;
        -:  617:  }
        -:  618:
        -:  619:  bool usesELFSectionDirectiveForBSS() const {
        -:  620:    return UsesELFSectionDirectiveForBSS;
        -:  621:  }
        -:  622:
        -:  623:  bool needsDwarfSectionOffsetDirective() const {
        -:  624:    return NeedsDwarfSectionOffsetDirective;
        -:  625:  }
        -:  626:
        -:  627:  // Accessors.
        -:  628:
        -:  629:  bool hasMachoZeroFillDirective() const { return HasMachoZeroFillDirective; }
        -:  630:  bool hasMachoTBSSDirective() const { return HasMachoTBSSDirective; }
        -:  631:  bool hasCOFFAssociativeComdats() const { return HasCOFFAssociativeComdats; }
        -:  632:  bool hasCOFFComdatConstants() const { return HasCOFFComdatConstants; }
        -:  633:  bool hasVisibilityOnlyWithLinkage() const {
        -:  634:    return HasVisibilityOnlyWithLinkage;
        -:  635:  }
        -:  636:
        -:  637:  /// Returns the maximum possible encoded instruction size in bytes. If \p STI
        -:  638:  /// is null, this should be the maximum size for any subtarget.
        -:  639:  virtual unsigned getMaxInstLength(const MCSubtargetInfo *STI = nullptr) const {
        -:  640:    return MaxInstLength;
        -:  641:  }
        -:  642:
        -:  643:  unsigned getMinInstAlignment() const { return MinInstAlignment; }
        -:  644:  bool getDollarIsPC() const { return DollarIsPC; }
        -:  645:  bool getDotIsPC() const { return DotIsPC; }
        -:  646:  bool getStarIsPC() const { return StarIsPC; }
        -:  647:  const char *getSeparatorString() const { return SeparatorString; }
        -:  648:
        -:  649:  /// This indicates the column (zero-based) at which asm comments should be
        -:  650:  /// printed.
        -:  651:  unsigned getCommentColumn() const { return 40; }
        -:  652:
        -:  653:  StringRef getCommentString() const { return CommentString; }
        -:  654:  bool getRestrictCommentStringToStartOfStatement() const {
        -:  655:    return RestrictCommentStringToStartOfStatement;
        -:  656:  }
        -:  657:  bool shouldAllowAdditionalComments() const { return AllowAdditionalComments; }
        -:  658:  bool getEmitGNUAsmStartIndentationMarker() const {
        -:  659:    return EmitGNUAsmStartIndentationMarker;
        -:  660:  }
        -:  661:  const char *getLabelSuffix() const { return LabelSuffix; }
        -:  662:  bool shouldEmitLabelsInUpperCase() const { return EmitLabelsInUpperCase; }
        -:  663:
        -:  664:  bool useAssignmentForEHBegin() const { return UseAssignmentForEHBegin; }
        -:  665:  bool needsLocalForSize() const { return NeedsLocalForSize; }
        -:  666:  StringRef getPrivateGlobalPrefix() const { return PrivateGlobalPrefix; }
        -:  667:  StringRef getPrivateLabelPrefix() const { return PrivateLabelPrefix; }
        -:  668:
        -:  669:  bool hasLinkerPrivateGlobalPrefix() const {
        -:  670:    return !LinkerPrivateGlobalPrefix.empty();
        -:  671:  }
        -:  672:
        -:  673:  StringRef getLinkerPrivateGlobalPrefix() const {
        -:  674:    if (hasLinkerPrivateGlobalPrefix())
        -:  675:      return LinkerPrivateGlobalPrefix;
        -:  676:    return getPrivateGlobalPrefix();
        -:  677:  }
        -:  678:
        -:  679:  const char *getInlineAsmStart() const { return InlineAsmStart; }
        -:  680:  const char *getInlineAsmEnd() const { return InlineAsmEnd; }
        -:  681:  const char *getCode16Directive() const { return Code16Directive; }
        -:  682:  const char *getCode32Directive() const { return Code32Directive; }
        -:  683:  const char *getCode64Directive() const { return Code64Directive; }
        -:  684:  unsigned getAssemblerDialect() const { return AssemblerDialect; }
        -:  685:  bool doesAllowAtInName() const { return AllowAtInName; }
        -:  686:  void setAllowAtInName(bool V) { AllowAtInName = V; }
        -:  687:  bool doesAllowQuestionAtStartOfIdentifier() const {
        -:  688:    return AllowQuestionAtStartOfIdentifier;
        -:  689:  }
        -:  690:  bool doesAllowAtAtStartOfIdentifier() const {
        -:  691:    return AllowAtAtStartOfIdentifier;
        -:  692:  }
        -:  693:  bool doesAllowDollarAtStartOfIdentifier() const {
        -:  694:    return AllowDollarAtStartOfIdentifier;
        -:  695:  }
        -:  696:  bool doesAllowHashAtStartOfIdentifier() const {
        -:  697:    return AllowHashAtStartOfIdentifier;
        -:  698:  }
        -:  699:  bool supportsNameQuoting() const { return SupportsQuotedNames; }
        -:  700:
        -:  701:  bool doesSupportDataRegionDirectives() const {
        -:  702:    return UseDataRegionDirectives;
        -:  703:  }
        -:  704:
        -:  705:  bool useDotAlignForAlignment() const {
        -:  706:    return UseDotAlignForAlignment;
        -:  707:  }
        -:  708:
        -:  709:  bool hasLEB128Directives() const { return HasLEB128Directives; }
        -:  710:
        -:  711:  const char *getZeroDirective() const { return ZeroDirective; }
        -:  712:  bool doesZeroDirectiveSupportNonZeroValue() const {
        -:  713:    return ZeroDirectiveSupportsNonZeroValue;
        -:  714:  }
        -:  715:  const char *getAsciiDirective() const { return AsciiDirective; }
        -:  716:  const char *getAscizDirective() const { return AscizDirective; }
        -:  717:  const char *getByteListDirective() const { return ByteListDirective; }
        -:  718:  const char *getPlainStringDirective() const { return PlainStringDirective; }
        -:  719:  AsmCharLiteralSyntax characterLiteralSyntax() const {
        -:  720:    return CharacterLiteralSyntax;
        -:  721:  }
        -:  722:  bool getAlignmentIsInBytes() const { return AlignmentIsInBytes; }
        -:  723:  unsigned getTextAlignFillValue() const { return TextAlignFillValue; }
        -:  724:  const char *getGlobalDirective() const { return GlobalDirective; }
        -:  725:
        -:  726:  bool doesSetDirectiveSuppressReloc() const {
        -:  727:    return SetDirectiveSuppressesReloc;
        -:  728:  }
        -:  729:
        -:  730:  bool hasAggressiveSymbolFolding() const { return HasAggressiveSymbolFolding; }
        -:  731:
        -:  732:  bool getCOMMDirectiveAlignmentIsInBytes() const {
        -:  733:    return COMMDirectiveAlignmentIsInBytes;
        -:  734:  }
        -:  735:
        -:  736:  LCOMM::LCOMMType getLCOMMDirectiveAlignmentType() const {
        -:  737:    return LCOMMDirectiveAlignmentType;
        -:  738:  }
        -:  739:
        -:  740:  bool hasBasenameOnlyForFileDirective() const {
        -:  741:    return HasBasenameOnlyForFileDirective;
        -:  742:  }
        -:  743:  bool hasPairedDoubleQuoteStringConstants() const {
        -:  744:    return HasPairedDoubleQuoteStringConstants;
        -:  745:  }
        -:  746:  bool hasFunctionAlignment() const { return HasFunctionAlignment; }
        -:  747:  bool hasDotTypeDotSizeDirective() const { return HasDotTypeDotSizeDirective; }
        -:  748:  bool hasSingleParameterDotFile() const { return HasSingleParameterDotFile; }
        -:  749:  bool hasFourStringsDotFile() const { return HasFourStringsDotFile; }
        -:  750:  bool hasIdentDirective() const { return HasIdentDirective; }
        -:  751:  bool hasNoDeadStrip() const { return HasNoDeadStrip; }
        -:  752:  bool hasAltEntry() const { return HasAltEntry; }
        -:  753:  const char *getWeakDirective() const { return WeakDirective; }
        -:  754:  const char *getWeakRefDirective() const { return WeakRefDirective; }
        -:  755:  bool hasWeakDefDirective() const { return HasWeakDefDirective; }
        -:  756:
        -:  757:  bool hasWeakDefCanBeHiddenDirective() const {
        -:  758:    return HasWeakDefCanBeHiddenDirective;
        -:  759:  }
        -:  760:
        -:  761:  bool avoidWeakIfComdat() const { return AvoidWeakIfComdat; }
        -:  762:
        -:  763:  MCSymbolAttr getHiddenVisibilityAttr() const { return HiddenVisibilityAttr; }
        -:  764:
        -:  765:  MCSymbolAttr getExportedVisibilityAttr() const { return ExportedVisibilityAttr; }
        -:  766:
        -:  767:  MCSymbolAttr getHiddenDeclarationVisibilityAttr() const {
        -:  768:    return HiddenDeclarationVisibilityAttr;
        -:  769:  }
        -:  770:
        -:  771:  MCSymbolAttr getProtectedVisibilityAttr() const {
        -:  772:    return ProtectedVisibilityAttr;
        -:  773:  }
        -:  774:
        -:  775:  bool doesSupportDebugInformation() const { return SupportsDebugInformation; }
        -:  776:
        -:  777:  ExceptionHandling getExceptionHandlingType() const { return ExceptionsType; }
        -:  778:  WinEH::EncodingType getWinEHEncodingType() const { return WinEHEncodingType; }
        -:  779:
        -:  780:  void setExceptionsType(ExceptionHandling EH) {
        -:  781:    ExceptionsType = EH;
        -:  782:  }
        -:  783:
        -:  784:  bool doesUseCFIForDebug() const { return UsesCFIForDebug; }
        -:  785:
        -:  786:  /// Returns true if the exception handling method for the platform uses call
        -:  787:  /// frame information to unwind.
        -:  788:  bool usesCFIForEH() const {
        -:  789:    return (ExceptionsType == ExceptionHandling::DwarfCFI ||
        -:  790:            ExceptionsType == ExceptionHandling::ARM || usesWindowsCFI());
        -:  791:  }
        -:  792:
        -:  793:  bool usesWindowsCFI() const {
        -:  794:    return ExceptionsType == ExceptionHandling::WinEH &&
        -:  795:           (WinEHEncodingType != WinEH::EncodingType::Invalid &&
        -:  796:            WinEHEncodingType != WinEH::EncodingType::X86);
        -:  797:  }
        -:  798:
        -:  799:  bool doesDwarfUseRelocationsAcrossSections() const {
        -:  800:    return DwarfUsesRelocationsAcrossSections;
        -:  801:  }
        -:  802:
        -:  803:  bool doDwarfFDESymbolsUseAbsDiff() const { return DwarfFDESymbolsUseAbsDiff; }
        -:  804:  bool useDwarfRegNumForCFI() const { return DwarfRegNumForCFI; }
        -:  805:  bool useParensForSymbolVariant() const { return UseParensForSymbolVariant; }
        -:  806:  bool useParensForDollarSignNames() const {
        -:  807:    return UseParensForDollarSignNames;
        -:  808:  }
        -:  809:  bool supportsExtendedDwarfLocDirective() const {
        -:  810:    return SupportsExtendedDwarfLocDirective;
        -:  811:  }
        -:  812:
        -:  813:  bool usesDwarfFileAndLocDirectives() const {
        -:  814:    return UsesDwarfFileAndLocDirectives;
        -:  815:  }
        -:  816:
        -:  817:  bool needsDwarfSectionSizeInHeader() const {
        -:  818:    return DwarfSectionSizeRequired;
        -:  819:  }
        -:  820:
        -:  821:  bool enableDwarfFileDirectoryDefault() const {
        -:  822:    return EnableDwarfFileDirectoryDefault;
        -:  823:  }
        -:  824:
        -:  825:  void addInitialFrameState(const MCCFIInstruction &Inst);
        -:  826:
        -:  827:  const std::vector<MCCFIInstruction> &getInitialFrameState() const {
        -:  828:    return InitialFrameState;
        -:  829:  }
        -:  830:
        -:  831:  void setBinutilsVersion(std::pair<int, int> Value) {
        -:  832:    BinutilsVersion = Value;
        -:  833:  }
        -:  834:
        -:  835:  /// Return true if assembly (inline or otherwise) should be parsed.
        -:  836:  bool useIntegratedAssembler() const { return UseIntegratedAssembler; }
        -:  837:
        -:  838:  /// Return true if target want to use AsmParser to parse inlineasm.
        -:  839:  bool parseInlineAsmUsingAsmParser() const {
        -:  840:    return ParseInlineAsmUsingAsmParser;
        -:  841:  }
        -:  842:
        -:  843:  bool binutilsIsAtLeast(int Major, int Minor) const {
        -:  844:    return BinutilsVersion >= std::make_pair(Major, Minor);
        -:  845:  }
        -:  846:
        -:  847:  /// Set whether assembly (inline or otherwise) should be parsed.
        -:  848:  virtual void setUseIntegratedAssembler(bool Value) {
        -:  849:    UseIntegratedAssembler = Value;
        -:  850:  }
        -:  851:
        -:  852:  /// Set whether target want to use AsmParser to parse inlineasm.
        -:  853:  virtual void setParseInlineAsmUsingAsmParser(bool Value) {
        -:  854:    ParseInlineAsmUsingAsmParser = Value;
        -:  855:  }
        -:  856:
        -:  857:  /// Return true if assembly (inline or otherwise) should be parsed.
        -:  858:  bool preserveAsmComments() const { return PreserveAsmComments; }
        -:  859:
        -:  860:  /// Set whether assembly (inline or otherwise) should be parsed.
        -:  861:  virtual void setPreserveAsmComments(bool Value) {
        -:  862:    PreserveAsmComments = Value;
        -:  863:  }
        -:  864:
        -:  865:  DebugCompressionType compressDebugSections() const {
        -:  866:    return CompressDebugSections;
        -:  867:  }
        -:  868:
        -:  869:  void setCompressDebugSections(DebugCompressionType CompressDebugSections) {
        -:  870:    this->CompressDebugSections = CompressDebugSections;
        -:  871:  }
        -:  872:
        -:  873:  bool shouldUseLogicalShr() const { return UseLogicalShr; }
        -:  874:
        -:  875:  bool canRelaxRelocations() const { return RelaxELFRelocations; }
    #####:  876:  void setRelaxELFRelocations(bool V) { RelaxELFRelocations = V; }
call    0 never executed
        -:  877:  bool hasMipsExpressions() const { return HasMipsExpressions; }
        -:  878:  bool needsFunctionDescriptors() const { return NeedsFunctionDescriptors; }
        -:  879:  bool shouldUseMotorolaIntegers() const { return UseMotorolaIntegers; }
        -:  880:};
        -:  881:
        -:  882:} // end namespace llvm
        -:  883:
        -:  884:#endif // LLVM_MC_MCASMINFO_H
