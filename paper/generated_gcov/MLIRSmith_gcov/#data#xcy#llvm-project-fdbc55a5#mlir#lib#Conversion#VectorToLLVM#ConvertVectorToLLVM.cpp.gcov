        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/VectorToLLVM/CMakeFiles/obj.MLIRVectorToLLVM.dir/ConvertVectorToLLVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/VectorToLLVM/CMakeFiles/obj.MLIRVectorToLLVM.dir/ConvertVectorToLLVM.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- VectorToLLVM.cpp - Conversion from Vector to the LLVM dialect ------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/VectorToLLVM/ConvertVectorToLLVM.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/VectorPattern.h"
        -:   12:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   13:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   14:#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
        -:   15:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   16:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   17:#include "mlir/Dialect/Vector/Transforms/VectorTransforms.h"
        -:   18:#include "mlir/IR/BuiltinTypes.h"
        -:   19:#include "mlir/IR/TypeUtilities.h"
        -:   20:#include "mlir/Support/MathExtras.h"
        -:   21:#include "mlir/Target/LLVMIR/TypeToLLVM.h"
        -:   22:#include "mlir/Transforms/DialectConversion.h"
        -:   23:
        -:   24:using namespace mlir;
        -:   25:using namespace mlir::vector;
        -:   26:
        -:   27:// Helper to reduce vector type by one rank at front.
function _ZL22reducedVectorTypeFrontN4mlir10VectorTypeE called 437425 returned 100% blocks executed 83%
   437425:   28:static VectorType reducedVectorTypeFront(VectorType tp) {
  437425*:   29:  assert((tp.getRank() > 1) && "unlowerable vector type");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
   437425:   30:  unsigned numScalableDims = tp.getNumScalableDims();
call    0 returned 100%
   437425:   31:  if (tp.getShape().size() == numScalableDims)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   32:    --numScalableDims;
   437425:   33:  return VectorType::get(tp.getShape().drop_front(), tp.getElementType(),
call    0 returned 100%
   874850:   34:                         numScalableDims);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   35:}
        -:   36:
        -:   37:// Helper to reduce vector type by *all* but one rank at back.
function _ZL21reducedVectorTypeBackN4mlir10VectorTypeE called 0 returned 0% blocks executed 0%
    #####:   38:static VectorType reducedVectorTypeBack(VectorType tp) {
    #####:   39:  assert((tp.getRank() > 1) && "unlowerable vector type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   40:  unsigned numScalableDims = tp.getNumScalableDims();
call    0 never executed
    #####:   41:  if (numScalableDims > 0)
branch  0 never executed
branch  1 never executed
    #####:   42:    --numScalableDims;
    #####:   43:  return VectorType::get(tp.getShape().take_back(), tp.getElementType(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   44:                         numScalableDims);
call    0 never executed
call    1 never executed
        -:   45:}
        -:   46:
        -:   47:// Helper that picks the proper sequence for inserting.
function _ZL9insertOneRN4mlir25ConversionPatternRewriterERNS_17LLVMTypeConverterENS_8LocationENS_5ValueES5_NS_4TypeEll called 31701 returned 100% blocks executed 92%
    31701:   48:static Value insertOne(ConversionPatternRewriter &rewriter,
        -:   49:                       LLVMTypeConverter &typeConverter, Location loc,
        -:   50:                       Value val1, Value val2, Type llvmType, int64_t rank,
        -:   51:                       int64_t pos) {
   31701*:   52:  assert(rank > 0 && "0-D vector corner case should have been handled already");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    31701:   53:  if (rank == 1) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
     5699:   54:    auto idxType = rewriter.getIndexType();
call    0 returned 100%
     5699:   55:    auto constant = rewriter.create<LLVM::ConstantOp>(
     5699:   56:        loc, typeConverter.convertType(idxType),
call    0 returned 100%
    11398:   57:        rewriter.getIntegerAttr(idxType, pos));
call    0 returned 100%
call    1 returned 100%
     5699:   58:    return rewriter.create<LLVM::InsertElementOp>(loc, llvmType, val1, val2,
     5699:   59:                                                  constant);
call    0 returned 100%
        -:   60:  }
    26002:   61:  return rewriter.create<LLVM::InsertValueOp>(loc, val1, val2, pos);
call    0 returned 100%
        -:   62:}
        -:   63:
        -:   64:// Helper that picks the proper sequence for extracting.
function _ZL10extractOneRN4mlir25ConversionPatternRewriterERNS_17LLVMTypeConverterENS_8LocationENS_5ValueENS_4TypeEll called 4189467 returned 100% blocks executed 100%
  4189467:   65:static Value extractOne(ConversionPatternRewriter &rewriter,
        -:   66:                        LLVMTypeConverter &typeConverter, Location loc,
        -:   67:                        Value val, Type llvmType, int64_t rank, int64_t pos) {
  4189467:   68:  if (rank <= 1) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
  3726040:   69:    auto idxType = rewriter.getIndexType();
call    0 returned 100%
  3726040:   70:    auto constant = rewriter.create<LLVM::ConstantOp>(
  3726040:   71:        loc, typeConverter.convertType(idxType),
call    0 returned 100%
  7452080:   72:        rewriter.getIntegerAttr(idxType, pos));
call    0 returned 100%
call    1 returned 100%
  3726040:   73:    return rewriter.create<LLVM::ExtractElementOp>(loc, llvmType, val,
  3726040:   74:                                                   constant);
call    0 returned 100%
        -:   75:  }
   463427:   76:  return rewriter.create<LLVM::ExtractValueOp>(loc, val, pos);
call    0 returned 100%
        -:   77:}
        -:   78:
        -:   79:// Helper that returns data layout alignment of a memref.
function _Z18getMemRefAlignmentRN4mlir17LLVMTypeConverterENS_10MemRefTypeERj called 15502 returned 100% blocks executed 90%
    15502:   80:LogicalResult getMemRefAlignment(LLVMTypeConverter &typeConverter,
        -:   81:                                 MemRefType memrefType, unsigned &align) {
    15502:   82:  Type elementTy = typeConverter.convertType(memrefType.getElementType());
call    0 returned 100%
call    1 returned 100%
    15502:   83:  if (!elementTy)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   84:    return failure();
        -:   85:
        -:   86:  // TODO: this should use the MLIR data layout when it becomes available and
        -:   87:  // stop depending on translation.
    31004:   88:  llvm::LLVMContext llvmContext;
call    0 returned 100%
call    1 returned 100%
    15502:   89:  align = LLVM::TypeToLLVMIRTranslator(llvmContext)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    15502:   90:              .getPreferredAlignment(elementTy, typeConverter.getDataLayout());
call    0 returned 100%
    15502:   91:  return success();
call    0 returned 100%
        -:   92:}
        -:   93:
        -:   94:// Check if the last stride is non-unit or the memory space is not zero.
function _ZL21isMemRefTypeSupportedN4mlir10MemRefTypeE called 74678 returned 100% blocks executed 82%
    74678:   95:static LogicalResult isMemRefTypeSupported(MemRefType memRefType) {
    74678:   96:  int64_t offset;
    74678:   97:  SmallVector<int64_t, 4> strides;
call    0 returned 100%
    74678:   98:  auto successStrides = getStridesAndOffset(memRefType, strides, offset);
call    0 returned 100%
   149356:   99:  if (failed(successStrides) || strides.back() != 1 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    74678:  100:      memRefType.getMemorySpaceAsInt() != 0)
call    0 returned 100%
    #####:  101:    return failure();
    74678:  102:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  103:}
        -:  104:
        -:  105:// Add an index vector component to a base pointer.
function _ZL14getIndexedPtrsRN4mlir25ConversionPatternRewriterENS_8LocationENS_10MemRefTypeENS_5ValueES4_S4_m called 66611 returned 100% blocks executed 88%
    66611:  106:static Value getIndexedPtrs(ConversionPatternRewriter &rewriter, Location loc,
        -:  107:                            MemRefType memRefType, Value llvmMemref, Value base,
        -:  108:                            Value index, uint64_t vLen) {
   66611*:  109:  assert(succeeded(isMemRefTypeSupported(memRefType)) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  110:         "unsupported memref type");
    66611:  111:  auto pType = MemRefDescriptor(llvmMemref).getElementPtrType();
call    0 returned 100%
call    1 returned 100%
    66611:  112:  auto ptrsType = LLVM::getFixedVectorType(pType, vLen);
call    0 returned 100%
    66611:  113:  return rewriter.create<LLVM::GEPOp>(loc, ptrsType, base, index);
call    0 returned 100%
        -:  114:}
        -:  115:
        -:  116:// Casts a strided element pointer to a vector pointer.  The vector pointer
        -:  117:// will be in the same address space as the incoming memref type.
function _ZL11castDataPtrRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueENS_10MemRefTypeENS_4TypeE called 7435 returned 100% blocks executed 100%
     7435:  118:static Value castDataPtr(ConversionPatternRewriter &rewriter, Location loc,
        -:  119:                         Value ptr, MemRefType memRefType, Type vt) {
     7435:  120:  auto pType = LLVM::LLVMPointerType::get(vt, memRefType.getMemorySpaceAsInt());
call    0 returned 100%
call    1 returned 100%
     7435:  121:  return rewriter.create<LLVM::BitcastOp>(loc, pType, ptr);
call    0 returned 100%
        -:  122:}
        -:  123:
        -:  124:namespace {
        -:  125:
        -:  126:/// Trivial Vector to LLVM conversions
        -:  127:using VectorScaleOpConversion =
        -:  128:    OneToOneConvertToLLVMPattern<vector::VectorScaleOp, LLVM::vscale>;
        -:  129:
        -:  130:/// Conversion pattern for a vector.bitcast.
        -:  131:class VectorBitCastOpConversion
        -:  132:    : public ConvertOpToLLVMPattern<vector::BitCastOp> {
        -:  133:public:
      763:  134:  using ConvertOpToLLVMPattern<vector::BitCastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  135:
        -:  136:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorBitCastOpConversion15matchAndRewriteEN4mlir6vector9BitCastOpENS2_16BitCastOpAdaptorERNS1_25ConversionPatternRewriterE called 542 returned 100% blocks executed 100%
      542:  137:  matchAndRewrite(vector::BitCastOp bitCastOp, OpAdaptor adaptor,
        -:  138:                  ConversionPatternRewriter &rewriter) const override {
        -:  139:    // Only 0-D and 1-D vectors can be lowered to LLVM.
      542:  140:    VectorType resultTy = bitCastOp.getResultVectorType();
call    0 returned 100%
      542:  141:    if (resultTy.getRank() > 1)
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
      247:  142:      return failure();
      295:  143:    Type newResultTy = typeConverter->convertType(resultTy);
call    0 returned 100%
      295:  144:    rewriter.replaceOpWithNewOp<LLVM::BitcastOp>(bitCastOp, newResultTy,
      295:  145:                                                 adaptor.getOperands()[0]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      295:  146:    return success();
        -:  147:  }
        -:  148:};
        -:  149:
        -:  150:/// Conversion pattern for a vector.matrix_multiply.
        -:  151:/// This is lowered directly to the proper llvm.intr.matrix.multiply.
        -:  152:class VectorMatmulOpConversion
        -:  153:    : public ConvertOpToLLVMPattern<vector::MatmulOp> {
        -:  154:public:
      766:  155:  using ConvertOpToLLVMPattern<vector::MatmulOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  156:
        -:  157:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorMatmulOpConversion15matchAndRewriteEN4mlir6vector8MatmulOpENS2_15MatmulOpAdaptorERNS1_25ConversionPatternRewriterE called 477 returned 100% blocks executed 100%
      477:  158:  matchAndRewrite(vector::MatmulOp matmulOp, OpAdaptor adaptor,
        -:  159:                  ConversionPatternRewriter &rewriter) const override {
      477:  160:    rewriter.replaceOpWithNewOp<LLVM::MatrixMultiplyOp>(
      477:  161:        matmulOp, typeConverter->convertType(matmulOp.getRes().getType()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      477:  162:        adaptor.getLhs(), adaptor.getRhs(), matmulOp.getLhsRows(),
call    0 returned 100%
call    1 returned 100%
      954:  163:        matmulOp.getLhsColumns(), matmulOp.getRhsColumns());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      477:  164:    return success();
        -:  165:  }
        -:  166:};
        -:  167:
        -:  168:/// Conversion pattern for a vector.flat_transpose.
        -:  169:/// This is lowered directly to the proper llvm.intr.matrix.transpose.
        -:  170:class VectorFlatTransposeOpConversion
        -:  171:    : public ConvertOpToLLVMPattern<vector::FlatTransposeOp> {
        -:  172:public:
      766:  173:  using ConvertOpToLLVMPattern<vector::FlatTransposeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  174:
        -:  175:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorFlatTransposeOpConversion15matchAndRewriteEN4mlir6vector15FlatTransposeOpENS2_22FlatTransposeOpAdaptorERNS1_25ConversionPatternRewriterE called 624 returned 100% blocks executed 100%
      624:  176:  matchAndRewrite(vector::FlatTransposeOp transOp, OpAdaptor adaptor,
        -:  177:                  ConversionPatternRewriter &rewriter) const override {
      624:  178:    rewriter.replaceOpWithNewOp<LLVM::MatrixTransposeOp>(
      624:  179:        transOp, typeConverter->convertType(transOp.getRes().getType()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1248:  180:        adaptor.getMatrix(), transOp.getRows(), transOp.getColumns());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      624:  181:    return success();
        -:  182:  }
        -:  183:};
        -:  184:
        -:  185:/// Overloaded utility that replaces a vector.load, vector.store,
        -:  186:/// vector.maskedload and vector.maskedstore with their respective LLVM
        -:  187:/// couterparts.
     3360:  188:static void replaceLoadOrStoreOp(vector::LoadOp loadOp,
        -:  189:                                 vector::LoadOpAdaptor adaptor,
        -:  190:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  191:                                 ConversionPatternRewriter &rewriter) {
     3360:  192:  rewriter.replaceOpWithNewOp<LLVM::LoadOp>(loadOp, ptr, align);
        -:  193:}
        -:  194:
function _ZN12_GLOBAL__N_1L20replaceLoadOrStoreOpEN4mlir6vector12MaskedLoadOpENS1_19MaskedLoadOpAdaptorENS0_10VectorTypeENS0_5ValueEjRNS0_25ConversionPatternRewriterE called 4068 returned 100% blocks executed 100%
     4068:  195:static void replaceLoadOrStoreOp(vector::MaskedLoadOp loadOp,
        -:  196:                                 vector::MaskedLoadOpAdaptor adaptor,
        -:  197:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  198:                                 ConversionPatternRewriter &rewriter) {
     4068:  199:  rewriter.replaceOpWithNewOp<LLVM::MaskedLoadOp>(
     4068:  200:      loadOp, vectorTy, ptr, adaptor.getMask(), adaptor.getPassThru(), align);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     4068:  201:}
        -:  202:
        7:  203:static void replaceLoadOrStoreOp(vector::StoreOp storeOp,
        -:  204:                                 vector::StoreOpAdaptor adaptor,
        -:  205:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  206:                                 ConversionPatternRewriter &rewriter) {
       14:  207:  rewriter.replaceOpWithNewOp<LLVM::StoreOp>(storeOp, adaptor.getValueToStore(),
        7:  208:                                             ptr, align);
call    0 returned 100%
        -:  209:}
        -:  210:
        -:  211:static void replaceLoadOrStoreOp(vector::MaskedStoreOp storeOp,
        -:  212:                                 vector::MaskedStoreOpAdaptor adaptor,
        -:  213:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  214:                                 ConversionPatternRewriter &rewriter) {
        -:  215:  rewriter.replaceOpWithNewOp<LLVM::MaskedStoreOp>(
        -:  216:      storeOp, adaptor.getValueToStore(), ptr, adaptor.getMask(), align);
        -:  217:}
        -:  218:
        -:  219:/// Conversion pattern for a vector.load, vector.store, vector.maskedload, and
        -:  220:/// vector.maskedstore.
        -:  221:template <class LoadOrStoreOp, class LoadOrStoreOpAdaptor>
        -:  222:class VectorLoadStoreConversion : public ConvertOpToLLVMPattern<LoadOrStoreOp> {
        -:  223:public:
     3052:  224:  using ConvertOpToLLVMPattern<LoadOrStoreOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  225:
        -:  226:  LogicalResult
   11207*:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
   11207*:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
   11207*:  232:    if (vectorTy.getRank() > 1)
   11207*:  233:      return failure();
        -:  234:
    7435*:  235:    auto loc = loadOrStoreOp->getLoc();
    7435*:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    7435*:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
   11207*:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
   14870*:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    7435*:  245:                     .template cast<VectorType>();
    7435*:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
        -:  247:                                               adaptor.getIndices(), rewriter);
    7435*:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
        -:  249:
    7442*:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
   11207*:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector6LoadOpENS2_13LoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector6LoadOpENS2_13LoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 7132 returned 100% blocks executed 95%
     7132:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
     7132:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 returned 100%
call    1 returned 100%
     7132:  232:    if (vectorTy.getRank() > 1)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
     7132:  233:      return failure();
        -:  234:
     3360:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 returned 100%
     3360:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 returned 100%
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
     3360:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     7132:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
     6720:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
     3360:  245:                     .template cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3360:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  247:                                               adaptor.getIndices(), rewriter);
     3360:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 returned 100%
        -:  249:
     3360:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 returned 100%
     7132:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector12MaskedLoadOpENS2_19MaskedLoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector12MaskedLoadOpENS2_19MaskedLoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 4068 returned 100% blocks executed 89%
     4068:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
     4068:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 returned 100%
call    1 returned 100%
     4068:  232:    if (vectorTy.getRank() > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     4068:  233:      return failure();
        -:  234:
     4068:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 returned 100%
     4068:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 returned 100%
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
     4068:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     4068:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
     8136:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
     4068:  245:                     .template cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     4068:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  247:                                               adaptor.getIndices(), rewriter);
     4068:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 returned 100%
        -:  249:
     4068:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 returned 100%
     4068:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector7StoreOpENS2_14StoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector7StoreOpENS2_14StoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 7 returned 100% blocks executed 90%
        7:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
        7:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 returned 100%
call    1 returned 100%
        7:  232:    if (vectorTy.getRank() > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        7:  233:      return failure();
        -:  234:
        7:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 returned 100%
        7:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 returned 100%
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
        7:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        7:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
       14:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
        7:  245:                     .template cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        7:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  247:                                               adaptor.getIndices(), rewriter);
        7:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 returned 100%
        -:  249:
       14:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 returned 100%
        7:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector13MaskedStoreOpENS2_20MaskedStoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector13MaskedStoreOpENS2_20MaskedStoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 never executed
call    1 never executed
    #####:  232:    if (vectorTy.getRank() > 1)
branch  0 never executed
branch  1 never executed
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 never executed
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 never executed
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 never executed
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 never executed
    #####:  251:    return success();
        -:  252:  }
------------------
        -:  253:};
        -:  254:
        -:  255:/// Conversion pattern for a vector.gather.
        -:  256:class VectorGatherOpConversion
        -:  257:    : public ConvertOpToLLVMPattern<vector::GatherOp> {
        -:  258:public:
      763:  259:  using ConvertOpToLLVMPattern<vector::GatherOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  260:
        -:  261:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorGatherOpConversion15matchAndRewriteEN4mlir6vector8GatherOpENS2_15GatherOpAdaptorERNS1_25ConversionPatternRewriterE called 2504 returned 100% blocks executed 90%
     2504:  262:  matchAndRewrite(vector::GatherOp gather, OpAdaptor adaptor,
        -:  263:                  ConversionPatternRewriter &rewriter) const override {
     2504:  264:    MemRefType memRefType = gather.getBaseType().dyn_cast<MemRefType>();
call    0 returned 100%
call    1 returned 100%
    2504*:  265:    assert(memRefType && "The base should be bufferized");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  266:
     2504:  267:    if (failed(isMemRefTypeSupported(memRefType)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  268:      return failure();
        -:  269:
     2504:  270:    auto loc = gather->getLoc();
call    0 returned 100%
        -:  271:
        -:  272:    // Resolve alignment.
     2504:  273:    unsigned align;
     2504:  274:    if (failed(getMemRefAlignment(*getTypeConverter(), memRefType, align)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  275:      return failure();
        -:  276:
     2504:  277:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
     2504:  278:                                     adaptor.getIndices(), rewriter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2504:  279:    Value base = adaptor.getBase();
call    0 returned 100%
        -:  280:
     2504:  281:    auto llvmNDVectorTy = adaptor.getIndexVec().getType();
call    0 returned 100%
call    1 returned 100%
        -:  282:    // Handle the simple case of 1-D vector.
     2504:  283:    if (!llvmNDVectorTy.isa<LLVM::LLVMArrayType>()) {
call    0 returned 100%
branch  1 taken 23% (fallthrough)
branch  2 taken 77%
      579:  284:      auto vType = gather.getVectorType();
call    0 returned 100%
        -:  285:      // Resolve address.
      579:  286:      Value ptrs = getIndexedPtrs(rewriter, loc, memRefType, base, ptr,
        -:  287:                                  adaptor.getIndexVec(),
      579:  288:                                  /*vLen=*/vType.getDimSize(0));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  289:      // Replace with the gather intrinsic.
      579:  290:      rewriter.replaceOpWithNewOp<LLVM::masked_gather>(
      579:  291:          gather, typeConverter->convertType(vType), ptrs, adaptor.getMask(),
call    0 returned 100%
call    1 returned 100%
     1158:  292:          adaptor.getPassThru(), rewriter.getI32IntegerAttr(align));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      579:  293:      return success();
        -:  294:    }
        -:  295:
function _ZZNK12_GLOBAL__N_124VectorGatherOpConversion15matchAndRewriteEN4mlir6vector8GatherOpENS2_15GatherOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_4TypeENS1_10ValueRangeEE_clES7_S8_ called 60469 returned 100% blocks executed 90%
    62394:  296:    auto callback = [align, memRefType, base, ptr, loc, &rewriter](
   120938:  297:                        Type llvm1DVectorTy, ValueRange vectorOperands) {
        -:  298:      // Resolve address.
    60469:  299:      Value ptrs = getIndexedPtrs(
        -:  300:          rewriter, loc, memRefType, base, ptr, /*index=*/vectorOperands[0],
    60469:  301:          LLVM::getVectorNumElements(llvm1DVectorTy).getFixedValue());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  302:      // Create the gather intrinsic.
    60469:  303:      return rewriter.create<LLVM::masked_gather>(
    60469:  304:          loc, llvm1DVectorTy, ptrs, /*mask=*/vectorOperands[1],
call    0 returned 100%
   120938:  305:          /*passThru=*/vectorOperands[2], rewriter.getI32IntegerAttr(align));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1925:  306:    };
     1925:  307:    SmallVector<Value> vectorOperands = {
     1925:  308:        adaptor.getIndexVec(), adaptor.getMask(), adaptor.getPassThru()};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1925:  309:    return LLVM::detail::handleMultidimensionalVectors(
call    0 returned 100%
     3850:  310:        gather, vectorOperands, *getTypeConverter(), callback, rewriter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  311:  }
        -:  312:};
        -:  313:
        -:  314:/// Conversion pattern for a vector.scatter.
        -:  315:class VectorScatterOpConversion
        -:  316:    : public ConvertOpToLLVMPattern<vector::ScatterOp> {
        -:  317:public:
      763:  318:  using ConvertOpToLLVMPattern<vector::ScatterOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  319:
        -:  320:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorScatterOpConversion15matchAndRewriteEN4mlir6vector9ScatterOpENS2_16ScatterOpAdaptorERNS1_25ConversionPatternRewriterE called 5563 returned 100% blocks executed 91%
     5563:  321:  matchAndRewrite(vector::ScatterOp scatter, OpAdaptor adaptor,
        -:  322:                  ConversionPatternRewriter &rewriter) const override {
     5563:  323:    auto loc = scatter->getLoc();
call    0 returned 100%
     5563:  324:    MemRefType memRefType = scatter.getMemRefType();
call    0 returned 100%
        -:  325:
     5563:  326:    if (failed(isMemRefTypeSupported(memRefType)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  327:      return failure();
        -:  328:
        -:  329:    // Resolve alignment.
     5563:  330:    unsigned align;
     5563:  331:    if (failed(getMemRefAlignment(*getTypeConverter(), memRefType, align)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  332:      return failure();
        -:  333:
        -:  334:    // Resolve address.
     5563:  335:    VectorType vType = scatter.getVectorType();
call    0 returned 100%
     5563:  336:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
     5563:  337:                                     adaptor.getIndices(), rewriter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     5563:  338:    Value ptrs =
        -:  339:        getIndexedPtrs(rewriter, loc, memRefType, adaptor.getBase(), ptr,
     5563:  340:                       adaptor.getIndexVec(), /*vLen=*/vType.getDimSize(0));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  341:
        -:  342:    // Replace with the scatter intrinsic.
     5563:  343:    rewriter.replaceOpWithNewOp<LLVM::masked_scatter>(
     5563:  344:        scatter, adaptor.getValueToStore(), ptrs, adaptor.getMask(),
call    0 returned 100%
call    1 returned 100%
    11126:  345:        rewriter.getI32IntegerAttr(align));
call    0 returned 100%
call    1 returned 100%
     5563:  346:    return success();
        -:  347:  }
        -:  348:};
        -:  349:
        -:  350:/// Conversion pattern for a vector.expandload.
        -:  351:class VectorExpandLoadOpConversion
        -:  352:    : public ConvertOpToLLVMPattern<vector::ExpandLoadOp> {
        -:  353:public:
      763:  354:  using ConvertOpToLLVMPattern<vector::ExpandLoadOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  355:
        -:  356:  LogicalResult
function _ZNK12_GLOBAL__N_128VectorExpandLoadOpConversion15matchAndRewriteEN4mlir6vector12ExpandLoadOpENS2_19ExpandLoadOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  357:  matchAndRewrite(vector::ExpandLoadOp expand, OpAdaptor adaptor,
        -:  358:                  ConversionPatternRewriter &rewriter) const override {
    #####:  359:    auto loc = expand->getLoc();
call    0 never executed
    #####:  360:    MemRefType memRefType = expand.getMemRefType();
call    0 never executed
        -:  361:
        -:  362:    // Resolve address.
    #####:  363:    auto vtype = typeConverter->convertType(expand.getVectorType());
call    0 never executed
call    1 never executed
    #####:  364:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  365:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  366:
    #####:  367:    rewriter.replaceOpWithNewOp<LLVM::masked_expandload>(
    #####:  368:        expand, vtype, ptr, adaptor.getMask(), adaptor.getPassThru());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  369:    return success();
        -:  370:  }
        -:  371:};
        -:  372:
        -:  373:/// Conversion pattern for a vector.compressstore.
        -:  374:class VectorCompressStoreOpConversion
        -:  375:    : public ConvertOpToLLVMPattern<vector::CompressStoreOp> {
        -:  376:public:
      763:  377:  using ConvertOpToLLVMPattern<vector::CompressStoreOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  378:
        -:  379:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorCompressStoreOpConversion15matchAndRewriteEN4mlir6vector15CompressStoreOpENS2_22CompressStoreOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  380:  matchAndRewrite(vector::CompressStoreOp compress, OpAdaptor adaptor,
        -:  381:                  ConversionPatternRewriter &rewriter) const override {
    #####:  382:    auto loc = compress->getLoc();
call    0 never executed
    #####:  383:    MemRefType memRefType = compress.getMemRefType();
call    0 never executed
        -:  384:
        -:  385:    // Resolve address.
    #####:  386:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  387:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  388:
    #####:  389:    rewriter.replaceOpWithNewOp<LLVM::masked_compressstore>(
    #####:  390:        compress, adaptor.getValueToStore(), ptr, adaptor.getMask());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  391:    return success();
        -:  392:  }
        -:  393:};
        -:  394:
        -:  395:/// Helper method to lower a `vector.reduction` op that performs an arithmetic
        -:  396:/// operation like add,mul, etc.. `VectorOp` is the LLVM vector intrinsic to use
        -:  397:/// and `ScalarOp` is the scalar operation used to add the accumulation value if
        -:  398:/// non-null.
        -:  399:template <class VectorOp, class ScalarOp>
     1980:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
     1980:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
     1980:  404:  if (accumulator)
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
     1980:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_xorENS2_5XOrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_xorENS2_5XOrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 326 returned 100% blocks executed 60%
      326:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
      326:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      326:  404:  if (accumulator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
      326:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM16vector_reduce_orENS2_4OrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM16vector_reduce_orENS2_4OrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 417 returned 100% blocks executed 60%
      417:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
      417:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      417:  404:  if (accumulator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
      417:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_andENS2_5AndOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_andENS2_5AndOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 376 returned 100% blocks executed 60%
      376:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
      376:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      376:  404:  if (accumulator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
      376:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_mulENS2_5MulOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_mulENS2_5MulOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 396 returned 100% blocks executed 60%
      396:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
      396:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      396:  404:  if (accumulator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
      396:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_addENS2_5AddOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_addENS2_5AddOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 465 returned 100% blocks executed 60%
      465:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
      465:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      465:  404:  if (accumulator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
      465:  406:  return result;
        -:  407:}
------------------
        -:  408:
        -:  409:/// Helper method to lower a `vector.reduction` operation that performs
        -:  410:/// a comparison operation like `min`/`max`. `VectorOp` is the LLVM vector
        -:  411:/// intrinsic to use and `predicate` is the predicate to use to compare+combine
        -:  412:/// the accumulator value if non-null.
        -:  413:template <class VectorOp>
     1784:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
     1784:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
     1784:  418:  if (accumulator) {
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
        -:  422:  }
     1784:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_smaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_smaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 463 returned 100% blocks executed 50%
      463:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
      463:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      463:  418:  if (accumulator) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
      463:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_umaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_umaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 341 returned 100% blocks executed 50%
      341:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
      341:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      341:  418:  if (accumulator) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
      341:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_sminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_sminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 335 returned 100% blocks executed 50%
      335:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
      335:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      335:  418:  if (accumulator) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
      335:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_uminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_uminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 645 returned 100% blocks executed 50%
      645:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
      645:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      645:  418:  if (accumulator) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
      645:  423:  return result;
        -:  424:}
------------------
        -:  425:
        -:  426:/// Create lowering of minf/maxf op. We cannot use llvm.maximum/llvm.minimum
        -:  427:/// with vector types.
function _ZN12_GLOBAL__N_1L13createMinMaxFERN4mlir9OpBuilderENS0_8LocationENS0_5ValueES4_b called 0 returned 0% blocks executed 0%
    #####:  428:static Value createMinMaxF(OpBuilder &builder, Location loc, Value lhs,
        -:  429:                           Value rhs, bool isMin) {
    #####:  430:  auto floatType = getElementTypeOrSelf(lhs.getType()).cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  431:  Type i1Type = builder.getI1Type();
call    0 never executed
    #####:  432:  if (auto vecType = lhs.getType().dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  433:    i1Type = VectorType::get(vecType.getShape(), i1Type);
call    0 never executed
call    1 never executed
    #####:  434:  Value cmp = builder.create<LLVM::FCmpOp>(
    #####:  435:      loc, i1Type, isMin ? LLVM::FCmpPredicate::olt : LLVM::FCmpPredicate::ogt,
branch  0 never executed
branch  1 never executed
    #####:  436:      lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  437:  Value sel = builder.create<LLVM::SelectOp>(loc, cmp, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  438:  Value isNan = builder.create<LLVM::FCmpOp>(
    #####:  439:      loc, i1Type, LLVM::FCmpPredicate::uno, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  440:  Value nan = builder.create<LLVM::ConstantOp>(
    #####:  441:      loc, lhs.getType(),
call    0 never executed
    #####:  442:      builder.getFloatAttr(floatType,
call    0 never executed
    #####:  443:                           APFloat::getQNaN(floatType.getFloatSemantics())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  444:  return builder.create<LLVM::SelectOp>(loc, isNan, nan, sel);
call    0 never executed
        -:  445:}
        -:  446:
        -:  447:/// Conversion pattern for all vector reductions.
        -:  448:class VectorReductionOpConversion
        -:  449:    : public ConvertOpToLLVMPattern<vector::ReductionOp> {
        -:  450:public:
        -:  451:  explicit VectorReductionOpConversion(LLVMTypeConverter &typeConv,
        -:  452:                                       bool reassociateFPRed)
        -:  453:      : ConvertOpToLLVMPattern<vector::ReductionOp>(typeConv),
        -:  454:        reassociateFPReductions(reassociateFPRed) {}
        -:  455:
        -:  456:  LogicalResult
function _ZNK12_GLOBAL__N_127VectorReductionOpConversion15matchAndRewriteEN4mlir6vector11ReductionOpENS2_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE called 4765 returned 100% blocks executed 88%
     4765:  457:  matchAndRewrite(vector::ReductionOp reductionOp, OpAdaptor adaptor,
        -:  458:                  ConversionPatternRewriter &rewriter) const override {
     4765:  459:    auto kind = reductionOp.getKind();
call    0 returned 100%
     4765:  460:    Type eltType = reductionOp.getDest().getType();
call    0 returned 100%
call    1 returned 100%
     4765:  461:    Type llvmType = typeConverter->convertType(eltType);
call    0 returned 100%
     4765:  462:    Value operand = adaptor.getVector();
call    0 returned 100%
     4765:  463:    Value acc = adaptor.getAcc();
call    0 returned 100%
     4765:  464:    Location loc = reductionOp.getLoc();
call    0 returned 100%
     4765:  465:    if (eltType.isIntOrIndex()) {
call    0 returned 100%
branch  1 taken 79% (fallthrough)
branch  2 taken 21%
        -:  466:      // Integer reductions: add/mul/min/max/and/or/xor.
     3764:  467:      Value result;
     3764:  468:      switch (kind) {
branch  0 taken 12%
branch  1 taken 11%
branch  2 taken 17%
branch  3 taken 9%
branch  4 taken 9%
branch  5 taken 12%
branch  6 taken 10%
branch  7 taken 11%
branch  8 taken 9%
branch  9 taken 0%
      465:  469:      case vector::CombiningKind::ADD:
      465:  470:        result =
        -:  471:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_add,
        -:  472:                                                       LLVM::AddOp>(
      465:  473:                rewriter, loc, llvmType, operand, acc);
      465:  474:        break;
call    0 returned 100%
      396:  475:      case vector::CombiningKind::MUL:
      396:  476:        result =
        -:  477:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_mul,
        -:  478:                                                       LLVM::MulOp>(
      396:  479:                rewriter, loc, llvmType, operand, acc);
      396:  480:        break;
call    0 returned 100%
      645:  481:      case vector::CombiningKind::MINUI:
      645:  482:        result = createIntegerReductionComparisonOpLowering<
        -:  483:            LLVM::vector_reduce_umin>(rewriter, loc, llvmType, operand, acc,
      645:  484:                                      LLVM::ICmpPredicate::ule);
      645:  485:        break;
call    0 returned 100%
      335:  486:      case vector::CombiningKind::MINSI:
      335:  487:        result = createIntegerReductionComparisonOpLowering<
        -:  488:            LLVM::vector_reduce_smin>(rewriter, loc, llvmType, operand, acc,
      335:  489:                                      LLVM::ICmpPredicate::sle);
      335:  490:        break;
call    0 returned 100%
      341:  491:      case vector::CombiningKind::MAXUI:
      341:  492:        result = createIntegerReductionComparisonOpLowering<
        -:  493:            LLVM::vector_reduce_umax>(rewriter, loc, llvmType, operand, acc,
      341:  494:                                      LLVM::ICmpPredicate::uge);
      341:  495:        break;
call    0 returned 100%
      463:  496:      case vector::CombiningKind::MAXSI:
      463:  497:        result = createIntegerReductionComparisonOpLowering<
        -:  498:            LLVM::vector_reduce_smax>(rewriter, loc, llvmType, operand, acc,
      463:  499:                                      LLVM::ICmpPredicate::sge);
      463:  500:        break;
call    0 returned 100%
      376:  501:      case vector::CombiningKind::AND:
      376:  502:        result =
        -:  503:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_and,
        -:  504:                                                       LLVM::AndOp>(
      376:  505:                rewriter, loc, llvmType, operand, acc);
      376:  506:        break;
call    0 returned 100%
      417:  507:      case vector::CombiningKind::OR:
      417:  508:        result =
        -:  509:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_or,
        -:  510:                                                       LLVM::OrOp>(
      417:  511:                rewriter, loc, llvmType, operand, acc);
      417:  512:        break;
call    0 returned 100%
      326:  513:      case vector::CombiningKind::XOR:
      326:  514:        result =
        -:  515:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_xor,
        -:  516:                                                       LLVM::XOrOp>(
      326:  517:                rewriter, loc, llvmType, operand, acc);
      326:  518:        break;
call    0 returned 100%
    #####:  519:      default:
    #####:  520:        return failure();
        -:  521:      }
     3764:  522:      rewriter.replaceOp(reductionOp, result);
call    0 returned 100%
call    1 returned 100%
        -:  523:
     3764:  524:      return success();
        -:  525:    }
        -:  526:
     1001:  527:    if (!eltType.isa<FloatType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  528:      return failure();
        -:  529:
        -:  530:    // Floating-point reductions: add/mul/min/max
     1001:  531:    if (kind == vector::CombiningKind::ADD) {
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        -:  532:      // Optional accumulator (or zero).
      233:  533:      Value acc = adaptor.getOperands().size() > 1
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  534:                      ? adaptor.getOperands()[1]
call    0 never executed
call    1 never executed
      233:  535:                      : rewriter.create<LLVM::ConstantOp>(
        -:  536:                            reductionOp->getLoc(), llvmType,
      233:  537:                            rewriter.getZeroAttr(eltType));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
      233:  538:      rewriter.replaceOpWithNewOp<LLVM::vector_reduce_fadd>(
        -:  539:          reductionOp, llvmType, acc, operand,
      233:  540:          rewriter.getBoolAttr(reassociateFPReductions));
call    0 returned 100%
call    1 returned 100%
      768:  541:    } else if (kind == vector::CombiningKind::MUL) {
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
        -:  542:      // Optional accumulator (or one).
      269:  543:      Value acc = adaptor.getOperands().size() > 1
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  544:                      ? adaptor.getOperands()[1]
call    0 never executed
call    1 never executed
      269:  545:                      : rewriter.create<LLVM::ConstantOp>(
        -:  546:                            reductionOp->getLoc(), llvmType,
      269:  547:                            rewriter.getFloatAttr(eltType, 1.0));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
      269:  548:      rewriter.replaceOpWithNewOp<LLVM::vector_reduce_fmul>(
        -:  549:          reductionOp, llvmType, acc, operand,
      269:  550:          rewriter.getBoolAttr(reassociateFPReductions));
call    0 returned 100%
call    1 returned 100%
      499:  551:    } else if (kind == vector::CombiningKind::MINF) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:  552:      // FIXME: MLIR's 'minf' and LLVM's 'vector_reduce_fmin' do not handle
        -:  553:      // NaNs/-0.0/+0.0 in the same way.
      254:  554:      Value result =
      254:  555:          rewriter.create<LLVM::vector_reduce_fmin>(loc, llvmType, operand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      254:  556:      if (acc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  557:        result = createMinMaxF(rewriter, loc, result, acc, /*isMin=*/true);
call    0 never executed
      254:  558:      rewriter.replaceOp(reductionOp, result);
call    0 returned 100%
call    1 returned 100%
      245:  559:    } else if (kind == vector::CombiningKind::MAXF) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  560:      // FIXME: MLIR's 'maxf' and LLVM's 'vector_reduce_fmax' do not handle
        -:  561:      // NaNs/-0.0/+0.0 in the same way.
      245:  562:      Value result =
      245:  563:          rewriter.create<LLVM::vector_reduce_fmax>(loc, llvmType, operand);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      245:  564:      if (acc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  565:        result = createMinMaxF(rewriter, loc, result, acc, /*isMin=*/false);
call    0 never executed
      245:  566:      rewriter.replaceOp(reductionOp, result);
call    0 returned 100%
call    1 returned 100%
        -:  567:    } else
    #####:  568:      return failure();
        -:  569:
     1001:  570:    return success();
        -:  571:  }
        -:  572:
        -:  573:private:
        -:  574:  const bool reassociateFPReductions;
        -:  575:};
        -:  576:
        -:  577:class VectorShuffleOpConversion
        -:  578:    : public ConvertOpToLLVMPattern<vector::ShuffleOp> {
        -:  579:public:
      763:  580:  using ConvertOpToLLVMPattern<vector::ShuffleOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  581:
        -:  582:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorShuffleOpConversion15matchAndRewriteEN4mlir6vector9ShuffleOpENS2_16ShuffleOpAdaptorERNS1_25ConversionPatternRewriterE called 9498 returned 100% blocks executed 93%
     9498:  583:  matchAndRewrite(vector::ShuffleOp shuffleOp, OpAdaptor adaptor,
        -:  584:                  ConversionPatternRewriter &rewriter) const override {
     9498:  585:    auto loc = shuffleOp->getLoc();
call    0 returned 100%
     9498:  586:    auto v1Type = shuffleOp.getV1VectorType();
call    0 returned 100%
     9498:  587:    auto v2Type = shuffleOp.getV2VectorType();
call    0 returned 100%
     9498:  588:    auto vectorType = shuffleOp.getVectorType();
call    0 returned 100%
     9498:  589:    Type llvmType = typeConverter->convertType(vectorType);
call    0 returned 100%
     9498:  590:    auto maskArrayAttr = shuffleOp.getMask();
call    0 returned 100%
        -:  591:
        -:  592:    // Bail if result type cannot be lowered.
     9498:  593:    if (!llvmType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  594:      return failure();
        -:  595:
        -:  596:    // Get rank and dimension sizes.
     9498:  597:    int64_t rank = vectorType.getRank();
call    0 returned 100%
        -:  598:#ifndef NDEBUG
     9498:  599:    bool wellFormed0DCase =
call    0 returned 100%
     9639:  600:        v1Type.getRank() == 0 && v2Type.getRank() == 0 && rank == 1;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     9498:  601:    bool wellFormedNDCase =
call    0 returned 100%
    18855:  602:        v1Type.getRank() == rank && v2Type.getRank() == rank;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    9498*:  603:    assert((wellFormed0DCase || wellFormedNDCase) && "op is not well-formed");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  604:#endif
        -:  605:
        -:  606:    // For rank 0 and 1, where both operands have *exactly* the same vector
        -:  607:    // type, there is direct shuffle support in LLVM. Use it!
     9498:  608:    if (rank <= 1 && v1Type == v2Type) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 88% (fallthrough)
branch  3 taken 12%
     8238:  609:      Value llvmShuffleOp = rewriter.create<LLVM::ShuffleVectorOp>(
     8238:  610:          loc, adaptor.getV1(), adaptor.getV2(),
call    0 returned 100%
branch  1 taken 9%
branch  2 taken 91%
    12357:  611:          LLVM::convertArrayToIndices<int32_t>(maskArrayAttr));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 9%
branch  4 taken 91%
     4119:  612:      rewriter.replaceOp(shuffleOp, llvmShuffleOp);
call    0 returned 100%
call    1 returned 100%
     4119:  613:      return success();
        -:  614:    }
        -:  615:
        -:  616:    // For all other cases, insert the individual values individually.
     5379:  617:    int64_t v1Dim = v1Type.getDimSize(0);
call    0 returned 100%
     5379:  618:    Type eltType;
     5379:  619:    if (auto arrayType = llvmType.dyn_cast<LLVM::LLVMArrayType>())
call    0 returned 100%
branch  1 taken 89%
branch  2 taken 11%
     4806:  620:      eltType = arrayType.getElementType();
call    0 returned 100%
        -:  621:    else
      573:  622:      eltType = llvmType.cast<VectorType>().getElementType();
call    0 returned 100%
call    1 returned 100%
     5379:  623:    Value insert = rewriter.create<LLVM::UndefOp>(loc, llvmType);
call    0 returned 100%
call    1 returned 100%
     5379:  624:    int64_t insPos = 0;
    42459:  625:    for (const auto &en : llvm::enumerate(maskArrayAttr)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 85% (fallthrough)
branch  3 taken 15%
call    4 returned 100%
    31701:  626:      int64_t extPos = en.value().cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
    31701:  627:      Value value = adaptor.getV1();
call    0 returned 100%
    31701:  628:      if (extPos >= v1Dim) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
    12167:  629:        extPos -= v1Dim;
    12167:  630:        value = adaptor.getV2();
call    0 returned 100%
        -:  631:      }
    31701:  632:      Value extract = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 returned 100%
    31701:  633:                                 eltType, rank, extPos);
call    0 returned 100%
    31701:  634:      insert = insertOne(rewriter, *getTypeConverter(), loc, insert, extract,
    31701:  635:                         llvmType, rank, insPos++);
call    0 returned 100%
call    1 returned 100%
        -:  636:    }
     5379:  637:    rewriter.replaceOp(shuffleOp, insert);
call    0 returned 100%
call    1 returned 100%
     5379:  638:    return success();
        -:  639:  }
        -:  640:};
        -:  641:
        -:  642:class VectorExtractElementOpConversion
        -:  643:    : public ConvertOpToLLVMPattern<vector::ExtractElementOp> {
        -:  644:public:
        -:  645:  using ConvertOpToLLVMPattern<
      763:  646:      vector::ExtractElementOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  647:
        -:  648:  LogicalResult
function _ZNK12_GLOBAL__N_132VectorExtractElementOpConversion15matchAndRewriteEN4mlir6vector16ExtractElementOpENS2_23ExtractElementOpAdaptorERNS1_25ConversionPatternRewriterE called 1957 returned 100% blocks executed 74%
     1957:  649:  matchAndRewrite(vector::ExtractElementOp extractEltOp, OpAdaptor adaptor,
        -:  650:                  ConversionPatternRewriter &rewriter) const override {
     1957:  651:    auto vectorType = extractEltOp.getVectorType();
call    0 returned 100%
     1957:  652:    auto llvmType = typeConverter->convertType(vectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
        -:  653:
        -:  654:    // Bail if result type cannot be lowered.
     1957:  655:    if (!llvmType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  656:      return failure();
        -:  657:
     1957:  658:    if (vectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1957:  659:      Location loc = extractEltOp.getLoc();
call    0 returned 100%
     1957:  660:      auto idxType = rewriter.getIndexType();
call    0 returned 100%
     1957:  661:      auto zero = rewriter.create<LLVM::ConstantOp>(
     1957:  662:          loc, typeConverter->convertType(idxType),
call    0 returned 100%
     3914:  663:          rewriter.getIntegerAttr(idxType, 0));
call    0 returned 100%
call    1 returned 100%
     1957:  664:      rewriter.replaceOpWithNewOp<LLVM::ExtractElementOp>(
     1957:  665:          extractEltOp, llvmType, adaptor.getVector(), zero);
call    0 returned 100%
call    1 returned 100%
     1957:  666:      return success();
        -:  667:    }
        -:  668:
    #####:  669:    rewriter.replaceOpWithNewOp<LLVM::ExtractElementOp>(
    #####:  670:        extractEltOp, llvmType, adaptor.getVector(), adaptor.getPosition());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  671:    return success();
        -:  672:  }
        -:  673:};
        -:  674:
        -:  675:class VectorExtractOpConversion
        -:  676:    : public ConvertOpToLLVMPattern<vector::ExtractOp> {
        -:  677:public:
      763:  678:  using ConvertOpToLLVMPattern<vector::ExtractOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  679:
        -:  680:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorExtractOpConversion15matchAndRewriteEN4mlir6vector9ExtractOpENS2_16ExtractOpAdaptorERNS1_25ConversionPatternRewriterE called 397161 returned 100% blocks executed 86%
   397161:  681:  matchAndRewrite(vector::ExtractOp extractOp, OpAdaptor adaptor,
        -:  682:                  ConversionPatternRewriter &rewriter) const override {
   397161:  683:    auto loc = extractOp->getLoc();
call    0 returned 100%
   397161:  684:    auto resultType = extractOp.getResult().getType();
call    0 returned 100%
   397161:  685:    auto llvmResultType = typeConverter->convertType(resultType);
call    0 returned 100%
   397161:  686:    auto positionArrayAttr = extractOp.getPosition();
call    0 returned 100%
        -:  687:
        -:  688:    // Bail if result type cannot be lowered.
   397161:  689:    if (!llvmResultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  690:      return failure();
        -:  691:
        -:  692:    // Extract entire vector. Should be handled by folder, but just to be safe.
   397161:  693:    if (positionArrayAttr.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  694:      rewriter.replaceOp(extractOp, adaptor.getVector());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  695:      return success();
        -:  696:    }
        -:  697:
        -:  698:    // One-shot extraction of vector from array (only requires extractvalue).
   397161:  699:    if (resultType.isa<VectorType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   790660:  700:      SmallVector<int64_t> indices;
call    0 returned 100%
  1083441:  701:      for (auto idx : positionArrayAttr.getAsRange<IntegerAttr>())
call    0 returned 100%
branch  1 taken 64% (fallthrough)
branch  2 taken 36%
call    3 returned 100%
   688111:  702:        indices.push_back(idx.getInt());
call    0 returned 100%
call    1 returned 100%
   790660:  703:      Value extracted = rewriter.create<LLVM::ExtractValueOp>(
   395330:  704:          loc, adaptor.getVector(), indices);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   395330:  705:      rewriter.replaceOp(extractOp, extracted);
call    0 returned 100%
call    1 returned 100%
   395330:  706:      return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  707:    }
        -:  708:
        -:  709:    // Potential extraction of 1-D vector from array.
     1831:  710:    Value extracted = adaptor.getVector();
call    0 returned 100%
     1831:  711:    auto positionAttrs = positionArrayAttr.getValue();
call    0 returned 100%
     1831:  712:    if (positionAttrs.size() > 1) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
      118:  713:      SmallVector<int64_t> nMinusOnePosition;
call    0 returned 100%
      118:  714:      for (auto idx : positionAttrs.drop_back())
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
       59:  715:        nMinusOnePosition.push_back(idx.cast<IntegerAttr>().getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       59:  716:      extracted = rewriter.create<LLVM::ExtractValueOp>(loc, extracted,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       59:  717:                                                        nMinusOnePosition);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  718:    }
        -:  719:
        -:  720:    // Remaining extraction of element from 1-D LLVM vector
     1831:  721:    auto position = positionAttrs.back().cast<IntegerAttr>();
call    0 returned 100%
call    1 returned 100%
     1831:  722:    auto i64Type = IntegerType::get(rewriter.getContext(), 64);
call    0 returned 100%
     1831:  723:    auto constant = rewriter.create<LLVM::ConstantOp>(loc, i64Type, position);
call    0 returned 100%
     1831:  724:    extracted =
     1831:  725:        rewriter.create<LLVM::ExtractElementOp>(loc, extracted, constant);
call    0 returned 100%
call    1 returned 100%
     1831:  726:    rewriter.replaceOp(extractOp, extracted);
call    0 returned 100%
call    1 returned 100%
        -:  727:
     1831:  728:    return success();
        -:  729:  }
        -:  730:};
        -:  731:
        -:  732:/// Conversion pattern that turns a vector.fma on a 1-D vector
        -:  733:/// into an llvm.intr.fmuladd. This is a trivial 1-1 conversion.
        -:  734:/// This does not match vectors of n >= 2 rank.
        -:  735:///
        -:  736:/// Example:
        -:  737:/// ```
        -:  738:///  vector.fma %a, %a, %a : vector<8xf32>
        -:  739:/// ```
        -:  740:/// is converted to:
        -:  741:/// ```
        -:  742:///  llvm.intr.fmuladd %va, %va, %va:
        -:  743:///    (!llvm."<8 x f32>">, !llvm<"<8 x f32>">, !llvm<"<8 x f32>">)
        -:  744:///    -> !llvm."<8 x f32>">
        -:  745:/// ```
        -:  746:class VectorFMAOp1DConversion : public ConvertOpToLLVMPattern<vector::FMAOp> {
        -:  747:public:
      763:  748:  using ConvertOpToLLVMPattern<vector::FMAOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  749:
        -:  750:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorFMAOp1DConversion15matchAndRewriteEN4mlir6vector5FMAOpENS2_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE called 136795 returned 100% blocks executed 100%
   136795:  751:  matchAndRewrite(vector::FMAOp fmaOp, OpAdaptor adaptor,
        -:  752:                  ConversionPatternRewriter &rewriter) const override {
   136795:  753:    VectorType vType = fmaOp.getVectorType();
call    0 returned 100%
   136795:  754:    if (vType.getRank() > 1)
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
    14487:  755:      return failure();
   122308:  756:    rewriter.replaceOpWithNewOp<LLVM::FMulAddOp>(
   122308:  757:        fmaOp, adaptor.getLhs(), adaptor.getRhs(), adaptor.getAcc());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   122308:  758:    return success();
        -:  759:  }
        -:  760:};
        -:  761:
        -:  762:class VectorInsertElementOpConversion
        -:  763:    : public ConvertOpToLLVMPattern<vector::InsertElementOp> {
        -:  764:public:
      763:  765:  using ConvertOpToLLVMPattern<vector::InsertElementOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  766:
        -:  767:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorInsertElementOpConversion15matchAndRewriteEN4mlir6vector15InsertElementOpENS2_22InsertElementOpAdaptorERNS1_25ConversionPatternRewriterE called 4918 returned 100% blocks executed 95%
     4918:  768:  matchAndRewrite(vector::InsertElementOp insertEltOp, OpAdaptor adaptor,
        -:  769:                  ConversionPatternRewriter &rewriter) const override {
     4918:  770:    auto vectorType = insertEltOp.getDestVectorType();
call    0 returned 100%
     4918:  771:    auto llvmType = typeConverter->convertType(vectorType);
call    0 returned 100%
        -:  772:
        -:  773:    // Bail if result type cannot be lowered.
     4918:  774:    if (!llvmType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  775:      return failure();
        -:  776:
     4918:  777:    if (vectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
      250:  778:      Location loc = insertEltOp.getLoc();
call    0 returned 100%
      250:  779:      auto idxType = rewriter.getIndexType();
call    0 returned 100%
      250:  780:      auto zero = rewriter.create<LLVM::ConstantOp>(
      250:  781:          loc, typeConverter->convertType(idxType),
call    0 returned 100%
      500:  782:          rewriter.getIntegerAttr(idxType, 0));
call    0 returned 100%
call    1 returned 100%
      250:  783:      rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
      250:  784:          insertEltOp, llvmType, adaptor.getDest(), adaptor.getSource(), zero);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      250:  785:      return success();
        -:  786:    }
        -:  787:
     4668:  788:    rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
     4668:  789:        insertEltOp, llvmType, adaptor.getDest(), adaptor.getSource(),
call    0 returned 100%
call    1 returned 100%
     9336:  790:        adaptor.getPosition());
call    0 returned 100%
call    1 returned 100%
     4668:  791:    return success();
        -:  792:  }
        -:  793:};
        -:  794:
        -:  795:class VectorInsertOpConversion
        -:  796:    : public ConvertOpToLLVMPattern<vector::InsertOp> {
        -:  797:public:
      763:  798:  using ConvertOpToLLVMPattern<vector::InsertOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  799:
        -:  800:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorInsertOpConversion15matchAndRewriteEN4mlir6vector8InsertOpENS2_15InsertOpAdaptorERNS1_25ConversionPatternRewriterE called 141484 returned 100% blocks executed 62%
   141484:  801:  matchAndRewrite(vector::InsertOp insertOp, OpAdaptor adaptor,
        -:  802:                  ConversionPatternRewriter &rewriter) const override {
   141484:  803:    auto loc = insertOp->getLoc();
call    0 returned 100%
   141484:  804:    auto sourceType = insertOp.getSourceType();
call    0 returned 100%
   141484:  805:    auto destVectorType = insertOp.getDestVectorType();
call    0 returned 100%
   141484:  806:    auto llvmResultType = typeConverter->convertType(destVectorType);
call    0 returned 100%
   141484:  807:    auto positionArrayAttr = insertOp.getPosition();
call    0 returned 100%
        -:  808:
        -:  809:    // Bail if result type cannot be lowered.
   141484:  810:    if (!llvmResultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  811:      return failure();
        -:  812:
        -:  813:    // Overwrite entire vector with value. Should be handled by folder, but
        -:  814:    // just to be safe.
   141484:  815:    if (positionArrayAttr.empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  816:      rewriter.replaceOp(insertOp, adaptor.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  817:      return success();
        -:  818:    }
        -:  819:
        -:  820:    // One-shot insertion of a vector into an array (only requires insertvalue).
   141484:  821:    if (sourceType.isa<VectorType>()) {
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
   278448:  822:      Value inserted = rewriter.create<LLVM::InsertValueOp>(
   278448:  823:          loc, adaptor.getDest(), adaptor.getSource(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   417672:  824:          LLVM::convertArrayToIndices(positionArrayAttr));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   139224:  825:      rewriter.replaceOp(insertOp, inserted);
call    0 returned 100%
call    1 returned 100%
   139224:  826:      return success();
        -:  827:    }
        -:  828:
        -:  829:    // Potential extraction of 1-D vector from array.
     2260:  830:    Value extracted = adaptor.getDest();
call    0 returned 100%
     2260:  831:    auto positionAttrs = positionArrayAttr.getValue();
call    0 returned 100%
     2260:  832:    auto position = positionAttrs.back().cast<IntegerAttr>();
call    0 returned 100%
call    1 returned 100%
     2260:  833:    auto oneDVectorType = destVectorType;
     2260:  834:    if (positionAttrs.size() > 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  835:      oneDVectorType = reducedVectorTypeBack(destVectorType);
call    0 never executed
    #####:  836:      extracted = rewriter.create<LLVM::ExtractValueOp>(
branch  0 never executed
branch  1 never executed
        -:  837:          loc, extracted,
    #####:  838:          LLVM::convertArrayToIndices(positionAttrs.drop_back()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  839:    }
        -:  840:
        -:  841:    // Insertion of an element into a 1-D LLVM vector.
     2260:  842:    auto i64Type = IntegerType::get(rewriter.getContext(), 64);
call    0 returned 100%
     2260:  843:    auto constant = rewriter.create<LLVM::ConstantOp>(loc, i64Type, position);
call    0 returned 100%
     4520:  844:    Value inserted = rewriter.create<LLVM::InsertElementOp>(
     2260:  845:        loc, typeConverter->convertType(oneDVectorType), extracted,
call    0 returned 100%
     4520:  846:        adaptor.getSource(), constant);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  847:
        -:  848:    // Potential insertion of resulting 1-D vector into array.
     2260:  849:    if (positionAttrs.size() > 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  850:      inserted = rewriter.create<LLVM::InsertValueOp>(
    #####:  851:          loc, adaptor.getDest(), inserted,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  852:          LLVM::convertArrayToIndices(positionAttrs.drop_back()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  853:    }
        -:  854:
     2260:  855:    rewriter.replaceOp(insertOp, inserted);
call    0 returned 100%
call    1 returned 100%
     2260:  856:    return success();
        -:  857:  }
        -:  858:};
        -:  859:
        -:  860:/// Rank reducing rewrite for n-D FMA into (n-1)-D FMA where n > 1.
        -:  861:///
        -:  862:/// Example:
        -:  863:/// ```
        -:  864:///   %d = vector.fma %a, %b, %c : vector<2x4xf32>
        -:  865:/// ```
        -:  866:/// is rewritten into:
        -:  867:/// ```
        -:  868:///  %r = splat %f0: vector<2x4xf32>
        -:  869:///  %va = vector.extractvalue %a[0] : vector<2x4xf32>
        -:  870:///  %vb = vector.extractvalue %b[0] : vector<2x4xf32>
        -:  871:///  %vc = vector.extractvalue %c[0] : vector<2x4xf32>
        -:  872:///  %vd = vector.fma %va, %vb, %vc : vector<4xf32>
        -:  873:///  %r2 = vector.insertvalue %vd, %r[0] : vector<4xf32> into vector<2x4xf32>
        -:  874:///  %va2 = vector.extractvalue %a2[1] : vector<2x4xf32>
        -:  875:///  %vb2 = vector.extractvalue %b2[1] : vector<2x4xf32>
        -:  876:///  %vc2 = vector.extractvalue %c2[1] : vector<2x4xf32>
        -:  877:///  %vd2 = vector.fma %va2, %vb2, %vc2 : vector<4xf32>
        -:  878:///  %r3 = vector.insertvalue %vd2, %r2[1] : vector<4xf32> into vector<2x4xf32>
        -:  879:///  // %r3 holds the final value.
        -:  880:/// ```
        -:  881:class VectorFMAOpNDRewritePattern : public OpRewritePattern<FMAOp> {
        -:  882:public:
        -:  883:  using OpRewritePattern<FMAOp>::OpRewritePattern;
        -:  884:
        -:  885:  void initialize() {
        -:  886:    // This pattern recursively unpacks one dimension at a time. The recursion
        -:  887:    // bounded as the rank is strictly decreasing.
        -:  888:    setHasBoundedRewriteRecursion();
        -:  889:  }
        -:  890:
function _ZNK12_GLOBAL__N_127VectorFMAOpNDRewritePattern15matchAndRewriteEN4mlir6vector5FMAOpERNS1_15PatternRewriterE called 14487 returned 100% blocks executed 92%
    14487:  891:  LogicalResult matchAndRewrite(FMAOp op,
        -:  892:                                PatternRewriter &rewriter) const override {
    14487:  893:    auto vType = op.getVectorType();
call    0 returned 100%
    14487:  894:    if (vType.getRank() < 2)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  895:      return failure();
        -:  896:
    14487:  897:    auto loc = op.getLoc();
call    0 returned 100%
    14487:  898:    auto elemType = vType.getElementType();
call    0 returned 100%
    28974:  899:    Value zero = rewriter.create<arith::ConstantOp>(
    14487:  900:        loc, elemType, rewriter.getZeroAttr(elemType));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    14487:  901:    Value desc = rewriter.create<vector::SplatOp>(loc, vType, zero);
call    0 returned 100%
call    1 returned 100%
   145216:  902:    for (int64_t i = 0, e = vType.getShape().front(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 90% (fallthrough)
branch  4 taken 10%
   130729:  903:      Value extrLHS = rewriter.create<ExtractOp>(loc, op.getLhs(), i);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   130729:  904:      Value extrRHS = rewriter.create<ExtractOp>(loc, op.getRhs(), i);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   130729:  905:      Value extrACC = rewriter.create<ExtractOp>(loc, op.getAcc(), i);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   130729:  906:      Value fma = rewriter.create<FMAOp>(loc, extrLHS, extrRHS, extrACC);
call    0 returned 100%
call    1 returned 100%
   130729:  907:      desc = rewriter.create<InsertOp>(loc, fma, desc, i);
call    0 returned 100%
        -:  908:    }
    14487:  909:    rewriter.replaceOp(op, desc);
call    0 returned 100%
call    1 returned 100%
    14487:  910:    return success();
        -:  911:  }
        -:  912:};
        -:  913:
        -:  914:/// Returns the strides if the memory underlying `memRefType` has a contiguous
        -:  915:/// static layout.
        -:  916:static llvm::Optional<SmallVector<int64_t, 4>>
function _ZN12_GLOBAL__N_1L24computeContiguousStridesEN4mlir10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  917:computeContiguousStrides(MemRefType memRefType) {
    #####:  918:  int64_t offset;
    #####:  919:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  920:  if (failed(getStridesAndOffset(memRefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  921:    return None;
    #####:  922:  if (!strides.empty() && strides.back() != 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  923:    return None;
        -:  924:  // If no layout or identity layout, this is contiguous by definition.
    #####:  925:  if (memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  926:    return strides;
branch  0 never executed
branch  1 never executed
        -:  927:
        -:  928:  // Otherwise, we must determine contiguity form shapes. This can only ever
        -:  929:  // work in static cases because MemRefType is underspecified to represent
        -:  930:  // contiguous dynamic shapes in other ways than with just empty/identity
        -:  931:  // layout.
    #####:  932:  auto sizes = memRefType.getShape();
call    0 never executed
    #####:  933:  for (int index = 0, e = strides.size() - 1; index < e; ++index) {
branch  0 never executed
branch  1 never executed
    #####:  934:    if (ShapedType::isDynamic(sizes[index + 1]) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  935:        ShapedType::isDynamicStrideOrOffset(strides[index]) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  936:        ShapedType::isDynamicStrideOrOffset(strides[index + 1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  937:      return None;
    #####:  938:    if (strides[index] != strides[index + 1] * sizes[index + 1])
branch  0 never executed
branch  1 never executed
    #####:  939:      return None;
        -:  940:  }
    #####:  941:  return strides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  942:}
        -:  943:
        -:  944:class VectorTypeCastOpConversion
        -:  945:    : public ConvertOpToLLVMPattern<vector::TypeCastOp> {
        -:  946:public:
      763:  947:  using ConvertOpToLLVMPattern<vector::TypeCastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  948:
        -:  949:  LogicalResult
function _ZNK12_GLOBAL__N_126VectorTypeCastOpConversion15matchAndRewriteEN4mlir6vector10TypeCastOpENS2_17TypeCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  950:  matchAndRewrite(vector::TypeCastOp castOp, OpAdaptor adaptor,
        -:  951:                  ConversionPatternRewriter &rewriter) const override {
    #####:  952:    auto loc = castOp->getLoc();
call    0 never executed
    #####:  953:    MemRefType sourceMemRefType =
call    0 never executed
    #####:  954:        castOp.getOperand().getType().cast<MemRefType>();
call    0 never executed
    #####:  955:    MemRefType targetMemRefType = castOp.getType();
call    0 never executed
        -:  956:
        -:  957:    // Only static shape casts supported atm.
    #####:  958:    if (!sourceMemRefType.hasStaticShape() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  959:        !targetMemRefType.hasStaticShape())
call    0 never executed
    #####:  960:      return failure();
        -:  961:
    #####:  962:    auto llvmSourceDescriptorTy =
    #####:  963:        adaptor.getOperands()[0].getType().dyn_cast<LLVM::LLVMStructType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  964:    if (!llvmSourceDescriptorTy)
branch  0 never executed
branch  1 never executed
    #####:  965:      return failure();
    #####:  966:    MemRefDescriptor sourceMemRef(adaptor.getOperands()[0]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  967:
    #####:  968:    auto llvmTargetDescriptorTy = typeConverter->convertType(targetMemRefType)
call    0 never executed
call    1 never executed
    #####:  969:                                      .dyn_cast_or_null<LLVM::LLVMStructType>();
    #####:  970:    if (!llvmTargetDescriptorTy)
branch  0 never executed
branch  1 never executed
    #####:  971:      return failure();
        -:  972:
        -:  973:    // Only contiguous source buffers supported atm.
    #####:  974:    auto sourceStrides = computeContiguousStrides(sourceMemRefType);
call    0 never executed
    #####:  975:    if (!sourceStrides)
branch  0 never executed
branch  1 never executed
    #####:  976:      return failure();
    #####:  977:    auto targetStrides = computeContiguousStrides(targetMemRefType);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  978:    if (!targetStrides)
branch  0 never executed
branch  1 never executed
    #####:  979:      return failure();
        -:  980:    // Only support static strides for now, regardless of contiguity.
    #####:  981:    if (llvm::any_of(*targetStrides, ShapedType::isDynamicStrideOrOffset))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  982:      return failure();
        -:  983:
    #####:  984:    auto int64Ty = IntegerType::get(rewriter.getContext(), 64);
call    0 never executed
        -:  985:
        -:  986:    // Create descriptor.
    #####:  987:    auto desc = MemRefDescriptor::undef(rewriter, loc, llvmTargetDescriptorTy);
call    0 never executed
    #####:  988:    Type llvmTargetElementTy = desc.getElementPtrType();
call    0 never executed
        -:  989:    // Set allocated ptr.
    #####:  990:    Value allocated = sourceMemRef.allocatedPtr(rewriter, loc);
call    0 never executed
    #####:  991:    allocated =
    #####:  992:        rewriter.create<LLVM::BitcastOp>(loc, llvmTargetElementTy, allocated);
call    0 never executed
call    1 never executed
    #####:  993:    desc.setAllocatedPtr(rewriter, loc, allocated);
call    0 never executed
        -:  994:    // Set aligned ptr.
    #####:  995:    Value ptr = sourceMemRef.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  996:    ptr = rewriter.create<LLVM::BitcastOp>(loc, llvmTargetElementTy, ptr);
call    0 never executed
call    1 never executed
    #####:  997:    desc.setAlignedPtr(rewriter, loc, ptr);
call    0 never executed
        -:  998:    // Fill offset 0.
    #####:  999:    auto attr = rewriter.getIntegerAttr(rewriter.getIndexType(), 0);
call    0 never executed
call    1 never executed
    #####: 1000:    auto zero = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, attr);
call    0 never executed
    #####: 1001:    desc.setOffset(rewriter, loc, zero);
call    0 never executed
        -: 1002:
        -: 1003:    // Fill size and stride descriptors in memref.
    #####: 1004:    for (const auto &indexedSize :
    #####: 1005:         llvm::enumerate(targetMemRefType.getShape())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1006:      int64_t index = indexedSize.index();
call    0 never executed
    #####: 1007:      auto sizeAttr =
    #####: 1008:          rewriter.getIntegerAttr(rewriter.getIndexType(), indexedSize.value());
call    0 never executed
call    1 never executed
    #####: 1009:      auto size = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, sizeAttr);
call    0 never executed
    #####: 1010:      desc.setSize(rewriter, loc, index, size);
call    0 never executed
    #####: 1011:      auto strideAttr = rewriter.getIntegerAttr(rewriter.getIndexType(),
    #####: 1012:                                                (*targetStrides)[index]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####: 1013:      auto stride = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, strideAttr);
call    0 never executed
    #####: 1014:      desc.setStride(rewriter, loc, index, stride);
call    0 never executed
        -: 1015:    }
        -: 1016:
    #####: 1017:    rewriter.replaceOp(castOp, {desc});
call    0 never executed
call    1 never executed
    #####: 1018:    return success();
branch  0 never executed
branch  1 never executed
        -: 1019:  }
        -: 1020:};
        -: 1021:
        -: 1022:/// Conversion pattern for a `vector.create_mask` (1-D scalable vectors only).
        -: 1023:/// Non-scalable versions of this operation are handled in Vector Transforms.
        -: 1024:class VectorCreateMaskOpRewritePattern
        -: 1025:    : public OpRewritePattern<vector::CreateMaskOp> {
        -: 1026:public:
function _ZN12_GLOBAL__N_132VectorCreateMaskOpRewritePatternC2EPN4mlir11MLIRContextEb called 763 returned 100% blocks executed 100%
      763: 1027:  explicit VectorCreateMaskOpRewritePattern(MLIRContext *context,
        -: 1028:                                            bool enableIndexOpt)
      763: 1029:      : OpRewritePattern<vector::CreateMaskOp>(context),
      763: 1030:        force32BitVectorIndices(enableIndexOpt) {}
call    0 returned 100%
call    1 returned 100%
        -: 1031:
function _ZNK12_GLOBAL__N_132VectorCreateMaskOpRewritePattern15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS1_15PatternRewriterE called 5264 returned 100% blocks executed 35%
     5264: 1032:  LogicalResult matchAndRewrite(vector::CreateMaskOp op,
        -: 1033:                                PatternRewriter &rewriter) const override {
     5264: 1034:    auto dstType = op.getType();
call    0 returned 100%
    6582*: 1035:    if (dstType.getRank() != 1 || !dstType.cast<VectorType>().isScalable())
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     5264: 1036:      return failure();
    #####: 1037:    IntegerType idxType =
    #####: 1038:        force32BitVectorIndices ? rewriter.getI32Type() : rewriter.getI64Type();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1039:    auto loc = op->getLoc();
call    0 never executed
    #####: 1040:    Value indices = rewriter.create<LLVM::StepVectorOp>(
    #####: 1041:        loc, LLVM::getVectorType(idxType, dstType.getShape()[0],
branch  0 never executed
branch  1 never executed
    #####: 1042:                                 /*isScalable=*/true));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1043:    auto bound = getValueOrCreateCastToIndexLike(rewriter, loc, idxType,
call    0 never executed
    #####: 1044:                                                 op.getOperand(0));
call    0 never executed
    #####: 1045:    Value bounds = rewriter.create<SplatOp>(loc, indices.getType(), bound);
call    0 never executed
call    1 never executed
    #####: 1046:    Value comp = rewriter.create<arith::CmpIOp>(loc, arith::CmpIPredicate::slt,
    #####: 1047:                                                indices, bounds);
call    0 never executed
call    1 never executed
    #####: 1048:    rewriter.replaceOp(op, comp);
call    0 never executed
call    1 never executed
    #####: 1049:    return success();
        -: 1050:  }
        -: 1051:
        -: 1052:private:
        -: 1053:  const bool force32BitVectorIndices;
        -: 1054:};
        -: 1055:
        -: 1056:class VectorPrintOpConversion : public ConvertOpToLLVMPattern<vector::PrintOp> {
        -: 1057:public:
      763: 1058:  using ConvertOpToLLVMPattern<vector::PrintOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1059:
        -: 1060:  // Proof-of-concept lowering implementation that relies on a small
        -: 1061:  // runtime support library, which only needs to provide a few
        -: 1062:  // printing methods (single value for all data types, opening/closing
        -: 1063:  // bracket, comma, newline). The lowering fully unrolls a vector
        -: 1064:  // in terms of these elementary printing operations. The advantage
        -: 1065:  // of this approach is that the library can remain unaware of all
        -: 1066:  // low-level implementation details of vectors while still supporting
        -: 1067:  // output of any shaped and dimensioned vector. Due to full unrolling,
        -: 1068:  // this approach is less suited for very large vectors though.
        -: 1069:  //
        -: 1070:  // TODO: rely solely on libc in future? something else?
        -: 1071:  //
        -: 1072:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorPrintOpConversion15matchAndRewriteEN4mlir6vector7PrintOpENS2_14PrintOpAdaptorERNS1_25ConversionPatternRewriterE called 51746 returned 100% blocks executed 72%
    51746: 1073:  matchAndRewrite(vector::PrintOp printOp, OpAdaptor adaptor,
        -: 1074:                  ConversionPatternRewriter &rewriter) const override {
    51746: 1075:    Type printType = printOp.getPrintType();
call    0 returned 100%
        -: 1076:
    51746: 1077:    if (typeConverter->convertType(printType) == nullptr)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1078:      return failure();
        -: 1079:
        -: 1080:    // Make sure element type has runtime support.
    51746: 1081:    PrintConversion conversion = PrintConversion::None;
    51746: 1082:    VectorType vectorType = printType.dyn_cast<VectorType>();
call    0 returned 100%
    51746: 1083:    Type eltType = vectorType ? vectorType.getElementType() : printType;
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
call    2 returned 100%
    51746: 1084:    Operation *printer;
    51746: 1085:    if (eltType.isF32()) {
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
    10607: 1086:      printer =
    10607: 1087:          LLVM::lookupOrCreatePrintF32Fn(printOp->getParentOfType<ModuleOp>());
call    0 returned 100%
call    1 returned 100%
    41139: 1088:    } else if (eltType.isF64()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1089:      printer =
    #####: 1090:          LLVM::lookupOrCreatePrintF64Fn(printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
    41139: 1091:    } else if (eltType.isIndex()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1092:      printer =
    #####: 1093:          LLVM::lookupOrCreatePrintU64Fn(printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
    41139: 1094:    } else if (auto intTy = eltType.dyn_cast<IntegerType>()) {
call    0 returned 100%
branch  1 taken 87% (fallthrough)
branch  2 taken 13%
        -: 1095:      // Integers need a zero or sign extension on the operand
        -: 1096:      // (depending on the source type) as well as a signed or
        -: 1097:      // unsigned print method. Up to 64-bit is supported.
    35648: 1098:      unsigned width = intTy.getWidth();
call    0 returned 100%
    35648: 1099:      if (intTy.isUnsigned()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1100:        if (width <= 64) {
branch  0 never executed
branch  1 never executed
    #####: 1101:          if (width < 64)
branch  0 never executed
branch  1 never executed
    #####: 1102:            conversion = PrintConversion::ZeroExt64;
    #####: 1103:          printer = LLVM::lookupOrCreatePrintU64Fn(
    #####: 1104:              printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
        -: 1105:        } else {
    #####: 1106:          return failure();
        -: 1107:        }
        -: 1108:      } else {
   35648*: 1109:        assert(intTy.isSignless() || intTy.isSigned());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
call    5 never executed
    35648: 1110:        if (width <= 64) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1111:          // Note that we *always* zero extend booleans (1-bit integers),
        -: 1112:          // so that true/false is printed as 1/0 rather than -1/0.
    35648: 1113:          if (width == 1)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -: 1114:            conversion = PrintConversion::ZeroExt64;
    21506: 1115:          else if (width < 64)
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
    13669: 1116:            conversion = PrintConversion::SignExt64;
    35648: 1117:          printer = LLVM::lookupOrCreatePrintI64Fn(
    35648: 1118:              printOp->getParentOfType<ModuleOp>());
call    0 returned 100%
call    1 returned 100%
        -: 1119:        } else {
    #####: 1120:          return failure();
        -: 1121:        }
        -: 1122:      }
        -: 1123:    } else {
     5491: 1124:      return failure();
        -: 1125:    }
        -: 1126:
        -: 1127:    // Unroll vector into elementary print calls.
    75642: 1128:    int64_t rank = vectorType ? vectorType.getRank() : 0;
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
    46255: 1129:    Type type = vectorType ? vectorType : eltType;
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
    46255: 1130:    emitRanks(rewriter, printOp, adaptor.getSource(), type, printer, rank,
call    0 returned 100%
call    1 returned 100%
        -: 1131:              conversion);
    92510: 1132:    emitCall(rewriter, printOp->getLoc(),
call    0 returned 100%
call    1 returned 100%
    46255: 1133:             LLVM::lookupOrCreatePrintNewlineFn(
    46255: 1134:                 printOp->getParentOfType<ModuleOp>()));
call    0 returned 100%
call    1 returned 100%
    46255: 1135:    rewriter.eraseOp(printOp);
call    0 returned 100%
    46255: 1136:    return success();
        -: 1137:  }
        -: 1138:
        -: 1139:private:
        -: 1140:  enum class PrintConversion {
        -: 1141:    // clang-format off
        -: 1142:    None,
        -: 1143:    ZeroExt64,
        -: 1144:    SignExt64
        -: 1145:    // clang-format on
        -: 1146:  };
        -: 1147:
function _ZNK12_GLOBAL__N_123VectorPrintOpConversion9emitRanksERN4mlir25ConversionPatternRewriterEPNS1_9OperationENS1_5ValueENS1_4TypeES5_lNS0_15PrintConversionE called 4204021 returned 100% blocks executed 98%
  4204021: 1148:  void emitRanks(ConversionPatternRewriter &rewriter, Operation *op,
        -: 1149:                 Value value, Type type, Operation *printer, int64_t rank,
        -: 1150:                 PrintConversion conversion) const {
  4204021: 1151:    VectorType vectorType = type.dyn_cast<VectorType>();
call    0 returned 100%
  4204021: 1152:    Location loc = op->getLoc();
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
  4204021: 1153:    if (!vectorType) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
 3737209*: 1154:      assert(rank == 0 && "The scalar case expects rank == 0");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  3737209: 1155:      switch (conversion) {
branch  0 taken 30%
branch  1 taken 21%
branch  2 taken 50%
  1108797: 1156:      case PrintConversion::ZeroExt64:
  2217594: 1157:        value = rewriter.create<arith::ExtUIOp>(
  1108797: 1158:            loc, IntegerType::get(rewriter.getContext(), 64), value);
call    0 returned 100%
call    1 returned 100%
  1108797: 1159:        break;
   773153: 1160:      case PrintConversion::SignExt64:
  1546306: 1161:        value = rewriter.create<arith::ExtSIOp>(
   773153: 1162:            loc, IntegerType::get(rewriter.getContext(), 64), value);
call    0 returned 100%
call    1 returned 100%
   773153: 1163:        break;
        -: 1164:      case PrintConversion::None:
        -: 1165:        break;
        -: 1166:      }
  3737209: 1167:      emitCall(rewriter, loc, printer, value);
call    0 returned 100%
call    1 returned 100%
  4155230: 1168:      return;
        -: 1169:    }
        -: 1170:
   933624: 1171:    emitCall(rewriter, loc,
call    0 returned 100%
call    1 returned 100%
   466812: 1172:             LLVM::lookupOrCreatePrintOpenFn(op->getParentOfType<ModuleOp>()));
call    0 returned 100%
call    1 returned 100%
   466812: 1173:    Operation *printComma =
   466812: 1174:        LLVM::lookupOrCreatePrintCommaFn(op->getParentOfType<ModuleOp>());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 90% (fallthrough)
branch  3 taken 10%
        -: 1175:
   466812: 1176:    if (rank <= 1) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
   418021: 1177:      auto reducedType = vectorType.getElementType();
call    0 returned 100%
   418021: 1178:      auto llvmType = typeConverter->convertType(reducedType);
call    0 returned 100%
   418021: 1179:      int64_t dim = rank == 0 ? 1 : vectorType.getDimSize(0);
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
  4138362: 1180:      for (int64_t d = 0; d < dim; ++d) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
  3720341: 1181:        Value nestedVal = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 returned 100%
  3720341: 1182:                                     llvmType, /*rank=*/0, /*pos=*/d);
call    0 returned 100%
  3720341: 1183:        emitRanks(rewriter, op, nestedVal, reducedType, printer, /*rank=*/0,
call    0 returned 100%
        -: 1184:                  conversion);
  3720341: 1185:        if (d != dim - 1)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
  3302320: 1186:          emitCall(rewriter, loc, printComma);
call    0 returned 100%
call    1 returned 100%
        -: 1187:      }
   836042: 1188:      emitCall(
call    0 returned 100%
call    1 returned 100%
        -: 1189:          rewriter, loc,
   418021: 1190:          LLVM::lookupOrCreatePrintCloseFn(op->getParentOfType<ModuleOp>()));
call    0 returned 100%
call    1 returned 100%
   418021: 1191:      return;
        -: 1192:    }
        -: 1193:
    48791: 1194:    int64_t dim = vectorType.getDimSize(0);
   486216: 1195:    for (int64_t d = 0; d < dim; ++d) {
call    0 returned 100%
branch  1 taken 90% (fallthrough)
branch  2 taken 10%
   437425: 1196:      auto reducedType = reducedVectorTypeFront(vectorType);
call    0 returned 100%
   437425: 1197:      auto llvmType = typeConverter->convertType(reducedType);
call    0 returned 100%
   437425: 1198:      Value nestedVal = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 returned 100%
   437425: 1199:                                   llvmType, rank, d);
call    0 returned 100%
   437425: 1200:      emitRanks(rewriter, op, nestedVal, reducedType, printer, rank - 1,
call    0 returned 100%
        -: 1201:                conversion);
   437425: 1202:      if (d != dim - 1)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
   388634: 1203:        emitCall(rewriter, loc, printComma);
call    0 returned 100%
call    1 returned 100%
        -: 1204:    }
    97582: 1205:    emitCall(rewriter, loc,
call    0 returned 100%
call    1 returned 100%
    97582: 1206:             LLVM::lookupOrCreatePrintCloseFn(op->getParentOfType<ModuleOp>()));
call    0 returned 100%
call    1 returned 100%
        -: 1207:  }
        -: 1208:
        -: 1209:  // Helper to emit a call.
function _ZN12_GLOBAL__N_123VectorPrintOpConversion8emitCallERN4mlir25ConversionPatternRewriterENS1_8LocationEPNS1_9OperationENS1_10ValueRangeE called 8408042 returned 100% blocks executed 100%
  8408042: 1210:  static void emitCall(ConversionPatternRewriter &rewriter, Location loc,
        -: 1211:                       Operation *ref, ValueRange params = ValueRange()) {
  8408042: 1212:    rewriter.create<LLVM::CallOp>(loc, TypeRange(), SymbolRefAttr::get(ref),
call    0 returned 100%
 16816084: 1213:                                  params);
call    0 returned 100%
call    1 returned 100%
  8408042: 1214:  }
        -: 1215:};
        -: 1216:
        -: 1217:/// The Splat operation is lowered to an insertelement + a shufflevector
        -: 1218:/// operation. Splat to only 0-d and 1-d vector result types are lowered.
        -: 1219:struct VectorSplatOpLowering : public ConvertOpToLLVMPattern<vector::SplatOp> {
      763: 1220:  using ConvertOpToLLVMPattern<vector::SplatOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1221:
        -: 1222:  LogicalResult
function _ZNK12_GLOBAL__N_121VectorSplatOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterE called 1791 returned 100% blocks executed 97%
     1791: 1223:  matchAndRewrite(vector::SplatOp splatOp, OpAdaptor adaptor,
        -: 1224:                  ConversionPatternRewriter &rewriter) const override {
     1791: 1225:    VectorType resultType = splatOp.getType().cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
     1791: 1226:    if (resultType.getRank() > 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1227:      return failure();
        -: 1228:
        -: 1229:    // First insert it into an undef vector so we can shuffle it.
     1791: 1230:    auto vectorType = typeConverter->convertType(splatOp.getType());
call    0 returned 100%
call    1 returned 100%
     1791: 1231:    Value undef = rewriter.create<LLVM::UndefOp>(splatOp.getLoc(), vectorType);
call    0 returned 100%
call    1 returned 100%
     1791: 1232:    auto zero = rewriter.create<LLVM::ConstantOp>(
        -: 1233:        splatOp.getLoc(),
     1791: 1234:        typeConverter->convertType(rewriter.getIntegerType(32)),
call    0 returned 100%
call    1 returned 100%
     3582: 1235:        rewriter.getZeroAttr(rewriter.getIntegerType(32)));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1236:
        -: 1237:    // For 0-d vector, we simply do `insertelement`.
     1791: 1238:    if (resultType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
      140: 1239:      rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
      140: 1240:          splatOp, vectorType, undef, adaptor.getInput(), zero);
call    0 returned 100%
call    1 returned 100%
      140: 1241:      return success();
        -: 1242:    }
        -: 1243:
        -: 1244:    // For 1-d vector, we additionally do a `vectorshuffle`.
     1651: 1245:    auto v = rewriter.create<LLVM::InsertElementOp>(
     1651: 1246:        splatOp.getLoc(), vectorType, undef, adaptor.getInput(), zero);
call    0 returned 100%
call    1 returned 100%
        -: 1247:
     1651: 1248:    int64_t width = splatOp.getType().cast<VectorType>().getDimSize(0);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1651: 1249:    SmallVector<int32_t> zeroValues(width, 0);
call    0 returned 100%
        -: 1250:
        -: 1251:    // Shuffle the value across the desired number of elements.
     1651: 1252:    rewriter.replaceOpWithNewOp<LLVM::ShuffleVectorOp>(splatOp, v, undef,
     1651: 1253:                                                       zeroValues);
call    0 returned 100%
     1651: 1254:    return success();
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -: 1255:  }
        -: 1256:};
        -: 1257:
        -: 1258:/// The Splat operation is lowered to an insertelement + a shufflevector
        -: 1259:/// operation. Splat to only 2+-d vector result types are lowered by the
        -: 1260:/// SplatNdOpLowering, the 1-d case is handled by SplatOpLowering.
        -: 1261:struct VectorSplatNdOpLowering : public ConvertOpToLLVMPattern<SplatOp> {
      763: 1262:  using ConvertOpToLLVMPattern<SplatOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1263:
        -: 1264:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorSplatNdOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterE called 2944 returned 100% blocks executed 94%
     2944: 1265:  matchAndRewrite(SplatOp splatOp, OpAdaptor adaptor,
        -: 1266:                  ConversionPatternRewriter &rewriter) const override {
     2944: 1267:    VectorType resultType = splatOp.getType();
call    0 returned 100%
     2944: 1268:    if (resultType.getRank() <= 1)
call    0 returned 100%
branch  1 taken 61% (fallthrough)
branch  2 taken 39%
     1791: 1269:      return failure();
        -: 1270:
        -: 1271:    // First insert it into an undef vector so we can shuffle it.
     1153: 1272:    auto loc = splatOp.getLoc();
call    0 returned 100%
     1153: 1273:    auto vectorTypeInfo =
     1153: 1274:        LLVM::detail::extractNDVectorTypeInfo(resultType, *getTypeConverter());
call    0 returned 100%
call    1 returned 100%
     1153: 1275:    auto llvmNDVectorTy = vectorTypeInfo.llvmNDVectorTy;
     1153: 1276:    auto llvm1DVectorTy = vectorTypeInfo.llvm1DVectorTy;
     1153: 1277:    if (!llvmNDVectorTy || !llvm1DVectorTy)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1278:      return failure();
        -: 1279:
        -: 1280:    // Construct returned value.
     1153: 1281:    Value desc = rewriter.create<LLVM::UndefOp>(loc, llvmNDVectorTy);
call    0 returned 100%
call    1 returned 100%
        -: 1282:
        -: 1283:    // Construct a 1-D vector with the splatted value that we insert in all the
        -: 1284:    // places within the returned descriptor.
     1153: 1285:    Value vdesc = rewriter.create<LLVM::UndefOp>(loc, llvm1DVectorTy);
call    0 returned 100%
call    1 returned 100%
     1153: 1286:    auto zero = rewriter.create<LLVM::ConstantOp>(
     1153: 1287:        loc, typeConverter->convertType(rewriter.getIntegerType(32)),
call    0 returned 100%
call    1 returned 100%
     2306: 1288:        rewriter.getZeroAttr(rewriter.getIntegerType(32)));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2306: 1289:    Value v = rewriter.create<LLVM::InsertElementOp>(loc, llvm1DVectorTy, vdesc,
     1153: 1290:                                                     adaptor.getInput(), zero);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1291:
        -: 1292:    // Shuffle the value across the desired number of elements.
     1153: 1293:    int64_t width = resultType.getDimSize(resultType.getRank() - 1);
call    0 returned 100%
call    1 returned 100%
     2306: 1294:    SmallVector<int32_t> zeroValues(width, 0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1153: 1295:    v = rewriter.create<LLVM::ShuffleVectorOp>(loc, v, v, zeroValues);
call    0 returned 100%
call    1 returned 100%
        -: 1296:
        -: 1297:    // Iterate of linear index, convert to coords space and insert splatted 1-D
        -: 1298:    // vector in each position.
function _ZZNK12_GLOBAL__N_123VectorSplatNdOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterEENKUlN4llvm8ArrayRefIlEEE_clES9_ called 35023 returned 100% blocks executed 100%
     1153: 1299:    nDVectorIterate(vectorTypeInfo, rewriter, [&](ArrayRef<int64_t> position) {
call    0 returned 100%
    35023: 1300:      desc = rewriter.create<LLVM::InsertValueOp>(loc, desc, v, position);
call    0 returned 100%
    35023: 1301:    });
     1153: 1302:    rewriter.replaceOp(splatOp, desc);
call    0 returned 100%
call    1 returned 100%
     1153: 1303:    return success();
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -: 1304:  }
        -: 1305:};
        -: 1306:
        -: 1307:} // namespace
        -: 1308:
        -: 1309:/// Populate the given list with patterns that convert from Vector to LLVM.
function _ZN4mlir38populateVectorToLLVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetEbb called 763 returned 100% blocks executed 100%
      763: 1310:void mlir::populateVectorToLLVMConversionPatterns(
        -: 1311:    LLVMTypeConverter &converter, RewritePatternSet &patterns,
        -: 1312:    bool reassociateFPReductions, bool force32BitVectorIndices) {
      763: 1313:  MLIRContext *ctx = converter.getDialect()->getContext();
call    0 returned 100%
      763: 1314:  patterns.add<VectorFMAOpNDRewritePattern>(ctx);
call    0 returned 100%
      763: 1315:  populateVectorInsertExtractStridedSliceTransforms(patterns);
call    0 returned 100%
call    1 returned 100%
      763: 1316:  patterns.add<VectorReductionOpConversion>(converter, reassociateFPReductions);
call    0 returned 100%
      763: 1317:  patterns.add<VectorCreateMaskOpRewritePattern>(ctx, force32BitVectorIndices);
call    0 returned 100%
      763: 1318:  patterns
        -: 1319:      .add<VectorBitCastOpConversion, VectorShuffleOpConversion,
        -: 1320:           VectorExtractElementOpConversion, VectorExtractOpConversion,
        -: 1321:           VectorFMAOp1DConversion, VectorInsertElementOpConversion,
        -: 1322:           VectorInsertOpConversion, VectorPrintOpConversion,
        -: 1323:           VectorTypeCastOpConversion, VectorScaleOpConversion,
        -: 1324:           VectorLoadStoreConversion<vector::LoadOp, vector::LoadOpAdaptor>,
        -: 1325:           VectorLoadStoreConversion<vector::MaskedLoadOp,
        -: 1326:                                     vector::MaskedLoadOpAdaptor>,
        -: 1327:           VectorLoadStoreConversion<vector::StoreOp, vector::StoreOpAdaptor>,
        -: 1328:           VectorLoadStoreConversion<vector::MaskedStoreOp,
        -: 1329:                                     vector::MaskedStoreOpAdaptor>,
        -: 1330:           VectorGatherOpConversion, VectorScatterOpConversion,
        -: 1331:           VectorExpandLoadOpConversion, VectorCompressStoreOpConversion,
      763: 1332:           VectorSplatOpLowering, VectorSplatNdOpLowering>(converter);
call    0 returned 100%
        -: 1333:  // Transfer ops with rank > 1 are handled by VectorToSCF.
      763: 1334:  populateVectorTransferLoweringPatterns(patterns, /*maxTransferRank=*/1);
call    0 returned 100%
call    1 returned 100%
      763: 1335:}
        -: 1336:
function _ZN4mlir44populateVectorToLLVMMatrixConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 766 returned 100% blocks executed 100%
      766: 1337:void mlir::populateVectorToLLVMMatrixConversionPatterns(
        -: 1338:    LLVMTypeConverter &converter, RewritePatternSet &patterns) {
      766: 1339:  patterns.add<VectorMatmulOpConversion>(converter);
call    0 returned 100%
      766: 1340:  patterns.add<VectorFlatTransposeOpConversion>(converter);
call    0 returned 100%
      766: 1341:}
