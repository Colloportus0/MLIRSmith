        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/LLVMCommon/TypeConverter.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/LLVMCommon/CMakeFiles/obj.MLIRLLVMCommonConversion.dir/TypeConverter.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/LLVMCommon/CMakeFiles/obj.MLIRLLVMCommonConversion.dir/TypeConverter.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- TypeConverter.cpp - Convert builtin to LLVM dialect types ----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
        -:   10:#include "MemRefDescriptor.h"
        -:   11:#include "mlir/Conversion/LLVMCommon/MemRefBuilder.h"
        -:   12:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   13:#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
        -:   14:
        -:   15:using namespace mlir;
        -:   16:
        -:   17:/// Create an LLVMTypeConverter using default LowerToLLVMOptions.
function _ZN4mlir17LLVMTypeConverterC2EPNS_11MLIRContextEPKNS_18DataLayoutAnalysisE called 5030 returned 100% blocks executed 100%
     5030:   18:LLVMTypeConverter::LLVMTypeConverter(MLIRContext *ctx,
     5030:   19:                                     const DataLayoutAnalysis *analysis)
     5030:   20:    : LLVMTypeConverter(ctx, LowerToLLVMOptions(ctx), analysis) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   21:
        -:   22:/// Create an LLVMTypeConverter using custom LowerToLLVMOptions.
function _ZN4mlir17LLVMTypeConverterC2EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisE called 7594 returned 100% blocks executed 96%
     7594:   23:LLVMTypeConverter::LLVMTypeConverter(MLIRContext *ctx,
        -:   24:                                     const LowerToLLVMOptions &options,
     7594:   25:                                     const DataLayoutAnalysis *analysis)
     7594:   26:    : llvmDialect(ctx->getOrLoadDialect<LLVM::LLVMDialect>()), options(options),
call    0 returned 100%
    15188:   27:      dataLayoutAnalysis(analysis) {
call    0 returned 100%
call    1 returned 100%
    7594*:   28:  assert(llvmDialect && "LLVM IR dialect is not registered");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   29:
        -:   30:  // Register conversions for the builtin types.
    7594*:   31:  addConversion([&](ComplexType type) { return convertComplexType(type); });
call    0 never executed
call    1 returned 100%
    7594*:   32:  addConversion([&](FloatType type) { return convertFloatType(type); });
call    0 returned 100%
    7594*:   33:  addConversion([&](FunctionType type) { return convertFunctionType(type); });
call    0 never executed
call    1 returned 100%
     7594:   34:  addConversion([&](IndexType type) { return convertIndexType(type); });
call    0 returned 100%
    7594*:   35:  addConversion([&](IntegerType type) { return convertIntegerType(type); });
call    0 never executed
call    1 returned 100%
    64705:   36:  addConversion([&](MemRefType type) { return convertMemRefType(type); });
call    0 returned 100%
call    1 returned 100%
     7594:   37:  addConversion(
call    0 returned 100%
    #####:   38:      [&](UnrankedMemRefType type) { return convertUnrankedMemRefType(type); });
call    0 never executed
    73987:   39:  addConversion([&](VectorType type) { return convertVectorType(type); });
call    0 returned 100%
call    1 returned 100%
        -:   40:
        -:   41:  // LLVM-compatible types are legal, so add a pass-through conversion. Do this
        -:   42:  // before the conversions below since conversions are attempted in reverse
        -:   43:  // order and those should take priority.
     7594:   44:  addConversion([](Type type) {
call    0 returned 100%
   309292:   45:    return LLVM::isCompatibleType(type) ? llvm::Optional<Type>(type)
call    0 returned 100%
   618584:   46:                                        : llvm::None;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 21% (fallthrough)
branch  3 taken 79%
        -:   47:  });
        -:   48:
        -:   49:  // LLVM container types may (recursively) contain other types that must be
        -:   50:  // converted even when the outer type is compatible.
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlNS_4LLVM15LLVMPointerTypeEE8_clESA_.isra.0 called 18 returned 100% blocks executed 83%
     7612:   51:  addConversion([&](LLVM::LLVMPointerType type) -> llvm::Optional<Type> {
call    0 returned 100%
       18:   52:    if (type.isOpaque())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   53:      return type;
       18:   54:    if (auto pointee = convertType(type.getElementType()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       18:   55:      return LLVM::LLVMPointerType::get(pointee, type.getAddressSpace());
call    0 returned 100%
call    1 returned 100%
    #####:   56:    return llvm::None;
        -:   57:  });
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlNS_4LLVM14LLVMStructTypeERN4llvm15SmallVectorImplINS_4TypeEEENSB_8ArrayRefISD_EEE9_clESA_SF_SH_.isra.0 called 800 returned 100% blocks executed 7%
     8394:   58:  addConversion([&](LLVM::LLVMStructType type, SmallVectorImpl<Type> &results,
call    0 returned 100%
        -:   59:                    ArrayRef<Type> callStack) -> llvm::Optional<LogicalResult> {
        -:   60:    // Fastpath for types that won't be converted by this callback anyway.
      800:   61:    if (LLVM::isCompatibleType(type)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      800:   62:      results.push_back(type);
call    0 returned 100%
      800:   63:      return success();
        -:   64:    }
        -:   65:
    #####:   66:    if (type.isIdentified()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:      auto convertedType = LLVM::LLVMStructType::getIdentified(
    #####:   68:          type.getContext(), ("_Converted_" + type.getName()).str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:   69:      unsigned counter = 1;
    #####:   70:      while (convertedType.isInitialized()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   71:        assert(counter != UINT_MAX &&
        -:   72:               "about to overflow struct renaming counter in conversion");
    #####:   73:        convertedType = LLVM::LLVMStructType::getIdentified(
        -:   74:            type.getContext(),
    #####:   75:            ("_Converted_" + std::to_string(counter) + type.getName()).str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
        -:   76:      }
    #####:   77:      if (llvm::count(callStack, type) > 1) {
branch  0 never executed
branch  1 never executed
    #####:   78:        results.push_back(convertedType);
call    0 never executed
    #####:   79:        return success();
        -:   80:      }
        -:   81:
    #####:   82:      SmallVector<Type> convertedElemTypes;
call    0 never executed
    #####:   83:      convertedElemTypes.reserve(type.getBody().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   84:      if (failed(convertTypes(type.getBody(), convertedElemTypes)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   85:        return llvm::None;
        -:   86:
    #####:   87:      if (failed(convertedType.setBody(convertedElemTypes, type.isPacked())))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   88:        return failure();
    #####:   89:      results.push_back(convertedType);
call    0 never executed
    #####:   90:      return success();
        -:   91:    }
        -:   92:
    #####:   93:    SmallVector<Type> convertedSubtypes;
call    0 never executed
    #####:   94:    convertedSubtypes.reserve(type.getBody().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   95:    if (failed(convertTypes(type.getBody(), convertedSubtypes)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   96:      return llvm::None;
        -:   97:
    #####:   98:    results.push_back(LLVM::LLVMStructType::getLiteral(
call    0 never executed
    #####:   99:        type.getContext(), convertedSubtypes, type.isPacked()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  100:    return success();
        -:  101:  });
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlNS_4LLVM13LLVMArrayTypeEE10_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    7594*:  102:  addConversion([&](LLVM::LLVMArrayType type) -> llvm::Optional<Type> {
call    0 returned 100%
    #####:  103:    if (auto element = convertType(type.getElementType()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  104:      return LLVM::LLVMArrayType::get(element, type.getNumElements());
call    0 never executed
call    1 never executed
    #####:  105:    return llvm::None;
        -:  106:  });
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlNS_4LLVM16LLVMFunctionTypeEE11_clESA_.isra.0 called 9 returned 100% blocks executed 76%
     7603:  107:  addConversion([&](LLVM::LLVMFunctionType type) -> llvm::Optional<Type> {
call    0 returned 100%
        9:  108:    Type convertedResType = convertType(type.getReturnType());
call    0 returned 100%
call    1 returned 100%
        9:  109:    if (!convertedResType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  110:      return llvm::None;
        -:  111:
        9:  112:    SmallVector<Type> convertedArgTypes;
call    0 returned 100%
        9:  113:    convertedArgTypes.reserve(type.getNumParams());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        9:  114:    if (failed(convertTypes(type.getParams(), convertedArgTypes)))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  115:      return llvm::None;
        -:  116:
       18:  117:    return LLVM::LLVMFunctionType::get(convertedResType, convertedArgTypes,
call    0 returned 100%
        9:  118:                                       type.isVarArg());
call    0 returned 100%
        -:  119:  });
        -:  120:
        -:  121:  // Materialization for memrefs creates descriptor structs from individual
        -:  122:  // values constituting them, when descriptors are used, i.e. more than one
        -:  123:  // value represents a memref.
     7594:  124:  addArgumentMaterialization(
call    0 returned 100%
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlRNS_9OpBuilderENS_18UnrankedMemRefTypeENS_10ValueRangeENS_8LocationEE12_clESA_SB_SC_SD_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  125:      [&](OpBuilder &builder, UnrankedMemRefType resultType, ValueRange inputs,
        -:  126:          Location loc) -> Optional<Value> {
    #####:  127:        if (inputs.size() == 1)
branch  0 never executed
branch  1 never executed
    #####:  128:          return llvm::None;
    #####:  129:        return UnrankedMemRefDescriptor::pack(builder, loc, *this, resultType,
    #####:  130:                                              inputs);
call    0 never executed
        -:  131:      });
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlRNS_9OpBuilderENS_10MemRefTypeENS_10ValueRangeENS_8LocationEE13_clESA_SB_SC_SD_.isra.0 called 10 returned 100% blocks executed 83%
     7604:  132:  addArgumentMaterialization([&](OpBuilder &builder, MemRefType resultType,
call    0 returned 100%
        -:  133:                                 ValueRange inputs,
        -:  134:                                 Location loc) -> Optional<Value> {
        -:  135:    // TODO: bare ptr conversion could be handled here but we would need a way
        -:  136:    // to distinguish between FuncOp and other regions.
       10:  137:    if (inputs.size() == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  138:      return llvm::None;
       10:  139:    return MemRefDescriptor::pack(builder, loc, *this, resultType, inputs);
call    0 returned 100%
        -:  140:  });
        -:  141:  // Add generic source and target materializations to handle cases where
        -:  142:  // non-LLVM types persist after an LLVM conversion.
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlRNS_9OpBuilderENS_4TypeENS_10ValueRangeENS_8LocationEE14_clESA_SB_SC_SD_.isra.0 called 247878 returned 100% blocks executed 83%
   255472:  143:  addSourceMaterialization([&](OpBuilder &builder, Type resultType,
call    0 returned 100%
        -:  144:                               ValueRange inputs,
        -:  145:                               Location loc) -> Optional<Value> {
   247878:  146:    if (inputs.size() != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  147:      return llvm::None;
        -:  148:
   247878:  149:    return builder.create<UnrealizedConversionCastOp>(loc, resultType, inputs)
call    0 returned 100%
   247878:  150:        .getResult(0);
        -:  151:  });
function _ZZN4mlir17LLVMTypeConverterC4EPNS_11MLIRContextERKNS_18LowerToLLVMOptionsEPKNS_18DataLayoutAnalysisEENKUlRNS_9OpBuilderENS_4TypeENS_10ValueRangeENS_8LocationEE15_clESA_SB_SC_SD_.isra.0 called 50307 returned 100% blocks executed 83%
    57901:  152:  addTargetMaterialization([&](OpBuilder &builder, Type resultType,
call    0 returned 100%
        -:  153:                               ValueRange inputs,
        -:  154:                               Location loc) -> Optional<Value> {
    50307:  155:    if (inputs.size() != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  156:      return llvm::None;
        -:  157:
    50307:  158:    return builder.create<UnrealizedConversionCastOp>(loc, resultType, inputs)
call    0 returned 100%
    50307:  159:        .getResult(0);
        -:  160:  });
     7594:  161:}
        -:  162:
        -:  163:/// Returns the MLIR context.
function _ZN4mlir17LLVMTypeConverter10getContextEv called 315244 returned 100% blocks executed 100%
 1666871*:  164:MLIRContext &LLVMTypeConverter::getContext() {
 1351581*:  165:  return *getDialect()->getContext();
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 never executed
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 never executed
call   11 never executed
call   12 returned 100%
        -:  166:}
        -:  167:
function _ZN4mlir17LLVMTypeConverter12getIndexTypeEv called 1232056 returned 100% blocks executed 100%
 1293585*:  168:Type LLVMTypeConverter::getIndexType() {
 1232056*:  169:  return IntegerType::get(&getContext(), getIndexTypeBitwidth());
call    0 returned 100%
        -:  170:}
        -:  171:
function _ZN4mlir17LLVMTypeConverter18getPointerBitwidthEj called 25629 returned 100% blocks executed 100%
   25629*:  172:unsigned LLVMTypeConverter::getPointerBitwidth(unsigned addressSpace) {
   25629*:  173:  return options.dataLayout.getPointerSizeInBits(addressSpace);
call    0 returned 100%
        -:  174:}
        -:  175:
function _ZN4mlir17LLVMTypeConverter16convertIndexTypeENS_9IndexTypeE called 0 returned 0% blocks executed 0%
    3799*:  176:Type LLVMTypeConverter::convertIndexType(IndexType type) {
    3799*:  177:  return getIndexType();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
        -:  178:}
        -:  179:
function _ZN4mlir17LLVMTypeConverter18convertIntegerTypeENS_11IntegerTypeE called 0 returned 0% blocks executed 0%
    #####:  180:Type LLVMTypeConverter::convertIntegerType(IntegerType type) {
    #####:  181:  return IntegerType::get(&getContext(), type.getWidth());
call    0 never executed
call    1 never executed
        -:  182:}
        -:  183:
function _ZN4mlir17LLVMTypeConverter16convertFloatTypeENS_9FloatTypeE called 0 returned 0% blocks executed 0%
    #####:  184:Type LLVMTypeConverter::convertFloatType(FloatType type) { return type; }
call    0 never executed
        -:  185:
        -:  186:// Convert a `ComplexType` to an LLVM type. The result is a complex number
        -:  187:// struct with entries for the
        -:  188://   1. real part and for the
        -:  189://   2. imaginary part.
function _ZN4mlir17LLVMTypeConverter18convertComplexTypeENS_11ComplexTypeE called 0 returned 0% blocks executed 0%
    #####:  190:Type LLVMTypeConverter::convertComplexType(ComplexType type) {
    #####:  191:  auto elementType = convertType(type.getElementType());
call    0 never executed
call    1 never executed
    #####:  192:  return LLVM::LLVMStructType::getLiteral(&getContext(),
    #####:  193:                                          {elementType, elementType});
call    0 never executed
        -:  194:}
        -:  195:
        -:  196:// Except for signatures, MLIR function types are converted into LLVM
        -:  197:// pointer-to-function types.
function _ZN4mlir17LLVMTypeConverter19convertFunctionTypeENS_12FunctionTypeE called 0 returned 0% blocks executed 0%
    #####:  198:Type LLVMTypeConverter::convertFunctionType(FunctionType type) {
    #####:  199:  SignatureConversion conversion(type.getNumInputs());
call    0 never executed
call    1 never executed
    #####:  200:  Type converted =
    #####:  201:      convertFunctionSignature(type, /*isVariadic=*/false, conversion);
call    0 never executed
    #####:  202:  return LLVM::LLVMPointerType::get(converted);
call    0 never executed
call    1 never executed
        -:  203:}
        -:  204:
        -:  205:// Function types are converted to LLVM Function types by recursively converting
        -:  206:// argument and result types.  If MLIR Function has zero results, the LLVM
        -:  207:// Function has one VoidType result.  If MLIR Function has more than one result,
        -:  208:// they are into an LLVM StructType in their order of appearance.
function _ZN4mlir17LLVMTypeConverter24convertFunctionSignatureENS_12FunctionTypeEbRNS_13TypeConverter19SignatureConversionE called 3351 returned 100% blocks executed 96%
     3351:  209:Type LLVMTypeConverter::convertFunctionSignature(
        -:  210:    FunctionType funcTy, bool isVariadic,
        -:  211:    LLVMTypeConverter::SignatureConversion &result) {
        -:  212:  // Select the argument converter depending on the calling convention.
     6702:  213:  auto funcArgConverter = options.useBarePtrCallConv
     3351:  214:                              ? barePtrFuncArgTypeConverter
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  215:                              : structFuncArgTypeConverter;
        -:  216:  // Convert argument types one by one and check for errors.
     6900:  217:  for (auto &en : llvm::enumerate(funcTy.getInputs())) {
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
     4966:  218:    Type type = en.value();
call    0 returned 100%
     8515:  219:    SmallVector<Type, 8> converted;
call    0 returned 100%
call    1 returned 100%
     4966:  220:    if (failed(funcArgConverter(*this, type, converted)))
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
     1417:  221:      return {};
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3549:  222:    result.addInputs(en.index(), converted);
call    0 returned 100%
branch  1 taken 7% (fallthrough)
branch  2 taken 93%
        -:  223:  }
        -:  224:
        -:  225:  // If function does not return anything, create the void result type,
        -:  226:  // if it returns on element, convert it, otherwise pack the result types into
        -:  227:  // a struct.
     1934:  228:  Type resultType = funcTy.getNumResults() == 0
call    0 returned 100%
      739:  229:                        ? LLVM::LLVMVoidType::get(&getContext())
call    0 returned 100%
     2673:  230:                        : packFunctionResults(funcTy.getResults());
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     1934:  231:  if (!resultType)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
      388:  232:    return {};
     3092:  233:  return LLVM::LLVMFunctionType::get(resultType, result.getConvertedTypes(),
     1546:  234:                                     isVariadic);
call    0 returned 100%
        -:  235:}
        -:  236:
        -:  237:/// Converts the function type to a C-compatible format, in particular using
        -:  238:/// pointers to memref descriptors for arguments.
        -:  239:std::pair<Type, bool>
function _ZN4mlir17LLVMTypeConverter27convertFunctionTypeCWrapperENS_12FunctionTypeE called 309 returned 100% blocks executed 94%
      309:  240:LLVMTypeConverter::convertFunctionTypeCWrapper(FunctionType type) {
      309:  241:  SmallVector<Type, 4> inputs;
call    0 returned 100%
      309:  242:  bool resultIsNowArg = false;
        -:  243:
      309:  244:  Type resultType = type.getNumResults() == 0
call    0 returned 100%
      146:  245:                        ? LLVM::LLVMVoidType::get(&getContext())
call    0 returned 100%
      455:  246:                        : packFunctionResults(type.getResults());
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
      309:  247:  if (!resultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  248:    return {};
        -:  249:
      309:  250:  if (auto structType = resultType.dyn_cast<LLVM::LLVMStructType>()) {
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -:  251:    // Struct types cannot be safely returned via C interface. Make this a
        -:  252:    // pointer argument, instead.
       46:  253:    inputs.push_back(LLVM::LLVMPointerType::get(structType));
call    0 returned 100%
call    1 returned 100%
       46:  254:    resultType = LLVM::LLVMVoidType::get(&getContext());
call    0 returned 100%
       46:  255:    resultIsNowArg = true;
        -:  256:  }
        -:  257:
      693:  258:  for (Type t : type.getInputs()) {
call    0 returned 100%
branch  1 taken 55% (fallthrough)
branch  2 taken 45%
      384:  259:    auto converted = convertType(t);
call    0 returned 100%
      384:  260:    if (!converted || !LLVM::isCompatibleType(converted))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  261:      return {};
      384:  262:    if (t.isa<MemRefType, UnrankedMemRefType>())
call    0 returned 100%
branch  1 taken 16% (fallthrough)
branch  2 taken 84%
       61:  263:      converted = LLVM::LLVMPointerType::get(converted);
call    0 returned 100%
      384:  264:    inputs.push_back(converted);
call    0 returned 100%
        -:  265:  }
        -:  266:
      309:  267:  return {LLVM::LLVMFunctionType::get(resultType, inputs), resultIsNowArg};
call    0 returned 100%
        -:  268:}
        -:  269:
        -:  270:/// Convert a memref type into a list of LLVM IR types that will form the
        -:  271:/// memref descriptor. The result contains the following types:
        -:  272:///  1. The pointer to the allocated data buffer, followed by
        -:  273:///  2. The pointer to the aligned data buffer, followed by
        -:  274:///  3. A lowered `index`-type integer containing the distance between the
        -:  275:///  beginning of the buffer and the first element to be accessed through the
        -:  276:///  view, followed by
        -:  277:///  4. An array containing as many `index`-type integers as the rank of the
        -:  278:///  MemRef: the array represents the size, in number of elements, of the memref
        -:  279:///  along the given dimension. For constant MemRef dimensions, the
        -:  280:///  corresponding size entry is a constant whose runtime value must match the
        -:  281:///  static value, followed by
        -:  282:///  5. A second array containing as many `index`-type integers as the rank of
        -:  283:///  the MemRef: the second array represents the "stride" (in tensor abstraction
        -:  284:///  sense), i.e. the number of consecutive elements of the underlying buffer.
        -:  285:///  TODO: add assertions for the static cases.
        -:  286:///
        -:  287:///  If `unpackAggregates` is set to true, the arrays described in (4) and (5)
        -:  288:///  are expanded into individual index-type elements.
        -:  289:///
        -:  290:///  template <typename Elem, typename Index, size_t Rank>
        -:  291:///  struct {
        -:  292:///    Elem *allocatedPtr;
        -:  293:///    Elem *alignedPtr;
        -:  294:///    Index offset;
        -:  295:///    Index sizes[Rank]; // omitted when rank == 0
        -:  296:///    Index strides[Rank]; // omitted when rank == 0
        -:  297:///  };
        -:  298:SmallVector<Type, 5>
function _ZN4mlir17LLVMTypeConverter25getMemRefDescriptorFieldsENS_10MemRefTypeEb called 57730 returned 100% blocks executed 88%
    57730:  299:LLVMTypeConverter::getMemRefDescriptorFields(MemRefType type,
        -:  300:                                             bool unpackAggregates) {
   57730*:  301:  assert(isStrided(type) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  302:         "Non-strided layout maps must have been normalized away");
        -:  303:
    57730:  304:  Type elementType = convertType(type.getElementType());
call    0 returned 100%
call    1 returned 100%
    57730:  305:  if (!elementType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  306:    return {};
    57730:  307:  auto ptrTy =
    57730:  308:      LLVM::LLVMPointerType::get(elementType, type.getMemorySpaceAsInt());
call    0 returned 100%
call    1 returned 100%
    57730:  309:  auto indexTy = getIndexType();
call    0 returned 100%
        -:  310:
    57730:  311:  SmallVector<Type, 5> results = {ptrTy, ptrTy, indexTy};
call    0 returned 100%
    57730:  312:  auto rank = type.getRank();
call    0 returned 100%
    57730:  313:  if (rank == 0)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
     1757:  314:    return results;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  315:
    55973:  316:  if (unpackAggregates)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      619:  317:    results.insert(results.end(), 2 * rank, indexTy);
call    0 returned 100%
        -:  318:  else
    55354:  319:    results.insert(results.end(), 2, LLVM::LLVMArrayType::get(indexTy, rank));
call    0 returned 100%
call    1 returned 100%
   113703:  320:  return results;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  321:}
        -:  322:
function _ZN4mlir17LLVMTypeConverter23getMemRefDescriptorSizeENS_10MemRefTypeERKNS_10DataLayoutE called 0 returned 0% blocks executed 0%
    #####:  323:unsigned LLVMTypeConverter::getMemRefDescriptorSize(MemRefType type,
        -:  324:                                                    const DataLayout &layout) {
        -:  325:  // Compute the descriptor size given that of its components indicated above.
    #####:  326:  unsigned space = type.getMemorySpaceAsInt();
call    0 never executed
    #####:  327:  return 2 * llvm::divideCeil(getPointerBitwidth(space), 8) +
call    0 never executed
call    1 never executed
    #####:  328:         (1 + 2 * type.getRank()) * layout.getTypeSize(getIndexType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  329:}
        -:  330:
        -:  331:/// Converts MemRefType to LLVMType. A MemRefType is converted to a struct that
        -:  332:/// packs the descriptor fields as defined by `getMemRefDescriptorFields`.
function _ZN4mlir17LLVMTypeConverter17convertMemRefTypeENS_10MemRefTypeE called 57111 returned 100% blocks executed 75%
    57111:  333:Type LLVMTypeConverter::convertMemRefType(MemRefType type) {
        -:  334:  // When converting a MemRefType to a struct with descriptor fields, do not
        -:  335:  // unpack the `sizes` and `strides` arrays.
    57111:  336:  SmallVector<Type, 5> types =
    57111:  337:      getMemRefDescriptorFields(type, /*unpackAggregates=*/false);
call    0 returned 100%
    57111:  338:  if (types.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  339:    return {};
    57111:  340:  return LLVM::LLVMStructType::getLiteral(&getContext(), types);
call    0 returned 100%
        -:  341:}
        -:  342:
        -:  343:/// Convert an unranked memref type into a list of non-aggregate LLVM IR types
        -:  344:/// that will form the unranked memref descriptor. In particular, the fields
        -:  345:/// for an unranked memref descriptor are:
        -:  346:/// 1. index-typed rank, the dynamic rank of this MemRef
        -:  347:/// 2. void* ptr, pointer to the static ranked MemRef descriptor. This will be
        -:  348:///    stack allocated (alloca) copy of a MemRef descriptor that got casted to
        -:  349:///    be unranked.
function _ZN4mlir17LLVMTypeConverter33getUnrankedMemRefDescriptorFieldsEv called 0 returned 0% blocks executed 0%
    #####:  350:SmallVector<Type, 2> LLVMTypeConverter::getUnrankedMemRefDescriptorFields() {
    #####:  351:  return {getIndexType(),
call    0 never executed
call    1 never executed
    #####:  352:          LLVM::LLVMPointerType::get(IntegerType::get(&getContext(), 8))};
call    0 never executed
call    1 never executed
call    2 never executed
        -:  353:}
        -:  354:
        -:  355:unsigned
function _ZN4mlir17LLVMTypeConverter31getUnrankedMemRefDescriptorSizeENS_18UnrankedMemRefTypeERKNS_10DataLayoutE called 0 returned 0% blocks executed 0%
    #####:  356:LLVMTypeConverter::getUnrankedMemRefDescriptorSize(UnrankedMemRefType type,
        -:  357:                                                   const DataLayout &layout) {
        -:  358:  // Compute the descriptor size given that of its components indicated above.
    #####:  359:  unsigned space = type.getMemorySpaceAsInt();
call    0 never executed
    #####:  360:  return layout.getTypeSize(getIndexType()) +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  361:         llvm::divideCeil(getPointerBitwidth(space), 8);
        -:  362:}
        -:  363:
function _ZN4mlir17LLVMTypeConverter25convertUnrankedMemRefTypeENS_18UnrankedMemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  364:Type LLVMTypeConverter::convertUnrankedMemRefType(UnrankedMemRefType type) {
    #####:  365:  if (!convertType(type.getElementType()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  366:    return {};
    #####:  367:  return LLVM::LLVMStructType::getLiteral(&getContext(),
call    0 never executed
    #####:  368:                                          getUnrankedMemRefDescriptorFields());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  369:}
        -:  370:
        -:  371:// Check if a memref type can be converted to a bare pointer.
function _ZN4mlir17LLVMTypeConverter19canConvertToBarePtrENS_14BaseMemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  372:bool LLVMTypeConverter::canConvertToBarePtr(BaseMemRefType type) {
    #####:  373:  if (type.isa<UnrankedMemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  374:    // Unranked memref is not supported in the bare pointer calling convention.
        -:  375:    return false;
        -:  376:
        -:  377:  // Check that the memref has static shape, strides and offset. Otherwise, it
        -:  378:  // cannot be lowered to a bare pointer.
    #####:  379:  auto memrefTy = type.cast<MemRefType>();
call    0 never executed
    #####:  380:  if (!memrefTy.hasStaticShape())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  381:    return false;
        -:  382:
    #####:  383:  int64_t offset = 0;
    #####:  384:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  385:  if (failed(getStridesAndOffset(memrefTy, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  386:    return false;
        -:  387:
    #####:  388:  for (int64_t stride : strides)
branch  0 never executed
branch  1 never executed
    #####:  389:    if (ShapedType::isDynamicStrideOrOffset(stride))
branch  0 never executed
branch  1 never executed
        -:  390:      return false;
        -:  391:
    #####:  392:  return !ShapedType::isDynamicStrideOrOffset(offset);
        -:  393:}
        -:  394:
        -:  395:/// Convert a memref type to a bare pointer to the memref element type.
function _ZN4mlir17LLVMTypeConverter22convertMemRefToBarePtrENS_14BaseMemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  396:Type LLVMTypeConverter::convertMemRefToBarePtr(BaseMemRefType type) {
    #####:  397:  if (!canConvertToBarePtr(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  398:    return {};
    #####:  399:  Type elementType = convertType(type.getElementType());
call    0 never executed
call    1 never executed
    #####:  400:  if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  401:    return {};
    #####:  402:  return LLVM::LLVMPointerType::get(elementType, type.getMemorySpaceAsInt());
call    0 never executed
call    1 never executed
        -:  403:}
        -:  404:
        -:  405:/// Convert an n-D vector type to an LLVM vector type:
        -:  406:///  * 0-D `vector<T>` are converted to vector<1xT>
        -:  407:///  * 1-D `vector<axT>` remains as is while,
        -:  408:///  * n>1 `vector<ax...xkxT>` convert via an (n-1)-D array type to
        -:  409:///    `!llvm.array<ax...array<jxvector<kxT>>>`.
function _ZN4mlir17LLVMTypeConverter17convertVectorTypeENS_10VectorTypeE called 66393 returned 100% blocks executed 88%
    66393:  410:Type LLVMTypeConverter::convertVectorType(VectorType type) {
    66393:  411:  auto elementType = convertType(type.getElementType());
call    0 returned 100%
call    1 returned 100%
    66393:  412:  if (!elementType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  413:    return {};
    66393:  414:  if (type.getShape().empty())
call    0 returned 100%
branch  1 taken 13% (fallthrough)
branch  2 taken 87%
     8326:  415:    return VectorType::get({1}, elementType);
call    0 returned 100%
    58067:  416:  Type vectorType = VectorType::get(type.getShape().back(), elementType,
call    0 returned 100%
   116134:  417:                                    type.getNumScalableDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   58067*:  418:  assert(LLVM::isCompatibleVectorType(vectorType) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  419:         "expected vector type compatible with the LLVM dialect");
    58067:  420:  auto shape = type.getShape();
call    0 returned 100%
   126582:  421:  for (int i = shape.size() - 2; i >= 0; --i)
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
    68515:  422:    vectorType = LLVM::LLVMArrayType::get(vectorType, shape[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
    58067:  423:  return vectorType;
        -:  424:}
        -:  425:
        -:  426:/// Convert a type in the context of the default or bare pointer calling
        -:  427:/// convention. Calling convention sensitive types, such as MemRefType and
        -:  428:/// UnrankedMemRefType, are converted following the specific rules for the
        -:  429:/// calling convention. Calling convention independent types are converted
        -:  430:/// following the default LLVM type conversions.
function _ZN4mlir17LLVMTypeConverter28convertCallingConventionTypeENS_4TypeE called 2321690 returned 100% blocks executed 50%
  2321690:  431:Type LLVMTypeConverter::convertCallingConventionType(Type type) {
  2321690:  432:  if (options.useBarePtrCallConv)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:    if (auto memrefTy = type.dyn_cast<BaseMemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  434:      return convertMemRefToBarePtr(memrefTy);
call    0 never executed
        -:  435:
  2321690:  436:  return convertType(type);
call    0 returned 100%
        -:  437:}
        -:  438:
        -:  439:/// Promote the bare pointers in 'values' that resulted from memrefs to
        -:  440:/// descriptors. 'stdTypes' holds they types of 'values' before the conversion
        -:  441:/// to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type).
function _ZN4mlir17LLVMTypeConverter28promoteBarePtrsToDescriptorsERNS_25ConversionPatternRewriterENS_8LocationEN4llvm8ArrayRefINS_4TypeEEERNS4_15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  442:void LLVMTypeConverter::promoteBarePtrsToDescriptors(
        -:  443:    ConversionPatternRewriter &rewriter, Location loc, ArrayRef<Type> stdTypes,
        -:  444:    SmallVectorImpl<Value> &values) {
    #####:  445:  assert(stdTypes.size() == values.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  446:         "The number of types and values doesn't match");
    #####:  447:  for (unsigned i = 0, end = values.size(); i < end; ++i)
branch  0 never executed
branch  1 never executed
    #####:  448:    if (auto memrefTy = stdTypes[i].dyn_cast<MemRefType>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  449:      values[i] = MemRefDescriptor::fromStaticShape(rewriter, loc, *this,
branch  0 never executed
branch  1 never executed
    #####:  450:                                                    memrefTy, values[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  451:}
        -:  452:
        -:  453:/// Convert a non-empty list of types to be returned from a function into a
        -:  454:/// supported LLVM IR type.  In particular, if more than one value is returned,
        -:  455:/// create an LLVM IR structure type with elements that correspond to each of
        -:  456:/// the MLIR types converted with `convertType`.
function _ZN4mlir17LLVMTypeConverter19packFunctionResultsENS_9TypeRangeE called 2321690 returned 100% blocks executed 21%
  2321690:  457:Type LLVMTypeConverter::packFunctionResults(TypeRange types) {
 2321690*:  458:  assert(!types.empty() && "expected non-empty list of type");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  459:
  2321690:  460:  if (types.size() == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2321690:  461:    return convertCallingConventionType(types.front());
call    0 returned 100%
call    1 returned 100%
        -:  462:
    #####:  463:  SmallVector<Type, 8> resultTypes;
branch  0 never executed
branch  1 never executed
    #####:  464:  resultTypes.reserve(types.size());
branch  0 never executed
branch  1 never executed
    #####:  465:  for (auto t : types) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  466:    auto converted = convertCallingConventionType(t);
call    0 never executed
    #####:  467:    if (!converted || !LLVM::isCompatibleType(converted))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  468:      return {};
    #####:  469:    resultTypes.push_back(converted);
call    0 never executed
        -:  470:  }
        -:  471:
    #####:  472:  return LLVM::LLVMStructType::getLiteral(&getContext(), resultTypes);
call    0 never executed
        -:  473:}
        -:  474:
function _ZN4mlir17LLVMTypeConverter26promoteOneMemRefDescriptorENS_8LocationENS_5ValueERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  475:Value LLVMTypeConverter::promoteOneMemRefDescriptor(Location loc, Value operand,
        -:  476:                                                    OpBuilder &builder) {
        -:  477:  // Alloca with proper alignment. We do not expect optimizations of this
        -:  478:  // alloca op and so we omit allocating at the entry block.
    #####:  479:  auto ptrType = LLVM::LLVMPointerType::get(operand.getType());
call    0 never executed
    #####:  480:  Value one = builder.create<LLVM::ConstantOp>(loc, builder.getI64Type(),
call    0 never executed
    #####:  481:                                               builder.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  482:  Value allocated =
    #####:  483:      builder.create<LLVM::AllocaOp>(loc, ptrType, one, /*alignment=*/0);
call    0 never executed
call    1 never executed
        -:  484:  // Store into the alloca'ed descriptor.
    #####:  485:  builder.create<LLVM::StoreOp>(loc, operand, allocated);
call    0 never executed
    #####:  486:  return allocated;
        -:  487:}
        -:  488:
function _ZN4mlir17LLVMTypeConverter15promoteOperandsENS_8LocationENS_10ValueRangeES2_RNS_9OpBuilderE called 11 returned 100% blocks executed 64%
       11:  489:SmallVector<Value, 4> LLVMTypeConverter::promoteOperands(Location loc,
        -:  490:                                                         ValueRange opOperands,
        -:  491:                                                         ValueRange operands,
        -:  492:                                                         OpBuilder &builder) {
       11:  493:  SmallVector<Value, 4> promotedOperands;
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
       11:  494:  promotedOperands.reserve(operands.size());
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      134:  495:  for (auto it : llvm::zip(opOperands, operands)) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
      123:  496:    auto operand = std::get<0>(it);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      123:  497:    auto llvmOperand = std::get<1>(it);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  498:
      123:  499:    if (options.useBarePtrCallConv) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  500:      // For the bare-ptr calling convention, we only have to extract the
        -:  501:      // aligned pointer of a memref.
    #####:  502:      if (auto memrefType = operand.getType().dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  503:        MemRefDescriptor desc(llvmOperand);
call    0 never executed
    #####:  504:        llvmOperand = desc.alignedPtr(builder, loc);
call    0 never executed
    #####:  505:      } else if (operand.getType().isa<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:        llvm_unreachable("Unranked memrefs are not supported");
call    0 never executed
        -:  507:      }
        -:  508:    } else {
     123*:  509:      if (operand.getType().isa<UnrankedMemRefType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  510:        UnrankedMemRefDescriptor::unpack(builder, loc, llvmOperand,
call    0 never executed
        -:  511:                                         promotedOperands);
      17*:  512:        continue;
        -:  513:      }
      123:  514:      if (auto memrefType = operand.getType().dyn_cast<MemRefType>()) {
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
       17:  515:        MemRefDescriptor::unpack(builder, loc, llvmOperand, memrefType,
call    0 returned 100%
        -:  516:                                 promotedOperands);
       17:  517:        continue;
        -:  518:      }
        -:  519:    }
        -:  520:
      106:  521:    promotedOperands.push_back(llvmOperand);
call    0 returned 100%
        -:  522:  }
       11:  523:  return promotedOperands;
        -:  524:}
        -:  525:
        -:  526:/// Callback to convert function argument types. It converts a MemRef function
        -:  527:/// argument to a list of non-aggregate types containing descriptor
        -:  528:/// information, and an UnrankedmemRef function argument to a list containing
        -:  529:/// the rank and a pointer to a descriptor struct.
function _ZN4mlir26structFuncArgTypeConverterERNS_17LLVMTypeConverterENS_4TypeERN4llvm15SmallVectorImplIS2_EE called 4966 returned 100% blocks executed 65%
     4966:  530:LogicalResult mlir::structFuncArgTypeConverter(LLVMTypeConverter &converter,
        -:  531:                                               Type type,
        -:  532:                                               SmallVectorImpl<Type> &result) {
     4966:  533:  if (auto memref = type.dyn_cast<MemRefType>()) {
call    0 returned 100%
branch  1 taken 12% (fallthrough)
branch  2 taken 88%
        -:  534:    // In signatures, Memref descriptors are expanded into lists of
        -:  535:    // non-aggregate values.
      619:  536:    auto converted =
     1238:  537:        converter.getMemRefDescriptorFields(memref, /*unpackAggregates=*/true);
call    0 returned 100%
      619:  538:    if (converted.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  539:      return failure();
      619:  540:    result.append(converted.begin(), converted.end());
call    0 returned 100%
      619:  541:    return success();
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  542:  }
     4347:  543:  if (type.isa<UnrankedMemRefType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  544:    auto converted = converter.getUnrankedMemRefDescriptorFields();
call    0 never executed
    #####:  545:    if (converted.empty())
branch  0 never executed
branch  1 never executed
    #####:  546:      return failure();
    #####:  547:    result.append(converted.begin(), converted.end());
call    0 never executed
    #####:  548:    return success();
branch  0 never executed
branch  1 never executed
        -:  549:  }
     4347:  550:  auto converted = converter.convertType(type);
call    0 returned 100%
     4347:  551:  if (!converted)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
     1417:  552:    return failure();
     2930:  553:  result.push_back(converted);
call    0 returned 100%
     2930:  554:  return success();
        -:  555:}
        -:  556:
        -:  557:/// Callback to convert function argument types. It converts MemRef function
        -:  558:/// arguments to bare pointers to the MemRef element type.
function _ZN4mlir27barePtrFuncArgTypeConverterERNS_17LLVMTypeConverterENS_4TypeERN4llvm15SmallVectorImplIS2_EE called 0 returned 0% blocks executed 0%
    #####:  559:LogicalResult mlir::barePtrFuncArgTypeConverter(LLVMTypeConverter &converter,
        -:  560:                                                Type type,
        -:  561:                                                SmallVectorImpl<Type> &result) {
    #####:  562:  auto llvmTy = converter.convertCallingConventionType(type);
call    0 never executed
    #####:  563:  if (!llvmTy)
branch  0 never executed
branch  1 never executed
    #####:  564:    return failure();
        -:  565:
    #####:  566:  result.push_back(llvmTy);
call    0 never executed
    #####:  567:  return success();
        -:  568:}
