        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/Vector/IR/VectorOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Vector/IR/CMakeFiles/obj.MLIRVectorDialect.dir/VectorOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Vector/IR/CMakeFiles/obj.MLIRVectorDialect.dir/VectorOps.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- VectorOps.cpp - MLIR Vector Dialect Operations ---------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements convenience types for working with super-vectorization
        -:   10:// operations, in particular super-vector loads and stores.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/Vector/IR/VectorOps.h"
        -:   15:
        -:   16:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   17:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   18:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   19:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   20:#include "mlir/Dialect/Utils/IndexingUtils.h"
        -:   21:#include "mlir/Dialect/Utils/StructuredOpsUtils.h"
        -:   22:#include "mlir/IR/AffineExpr.h"
        -:   23:#include "mlir/IR/AffineMap.h"
        -:   24:#include "mlir/IR/BlockAndValueMapping.h"
        -:   25:#include "mlir/IR/Builders.h"
        -:   26:#include "mlir/IR/BuiltinOps.h"
        -:   27:#include "mlir/IR/BuiltinTypes.h"
        -:   28:#include "mlir/IR/DialectImplementation.h"
        -:   29:#include "mlir/IR/OpImplementation.h"
        -:   30:#include "mlir/IR/PatternMatch.h"
        -:   31:#include "mlir/IR/TypeUtilities.h"
        -:   32:#include "mlir/Support/LLVM.h"
        -:   33:#include "llvm/ADT/StringSet.h"
        -:   34:#include "llvm/ADT/TypeSwitch.h"
        -:   35:#include "llvm/ADT/bit.h"
        -:   36:#include <numeric>
        -:   37:
        -:   38:#include "mlir/Dialect/Vector/IR/VectorOpsDialect.cpp.inc"
        -:   39:// Pull in all enum type and utility function definitions.
        -:   40:#include "mlir/Dialect/Vector/IR/VectorOpsEnums.cpp.inc"
        -:   41:
        -:   42:using namespace mlir;
        -:   43:using namespace mlir::vector;
        -:   44:
        -:   45:/// Helper enum to classify mask value.
        -:   46:enum class MaskFormat {
        -:   47:  AllTrue = 0,
        -:   48:  AllFalse = 1,
        -:   49:  Unknown = 2,
        -:   50:};
        -:   51:
        -:   52:/// Helper method to classify a mask value. Currently, the method
        -:   53:/// looks "under the hood" of a constant value with dense attributes
        -:   54:/// and a constant mask operation (since the client may be called at
        -:   55:/// various stages during progressive lowering).
function _ZL13getMaskFormatN4mlir5ValueE called 80835 returned 100% blocks executed 98%
    80835:   56:static MaskFormat getMaskFormat(Value mask) {
    80835:   57:  if (auto c = mask.getDefiningOp<arith::ConstantOp>()) {
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
        -:   58:    // Inspect constant dense values. We count up for bits that
        -:   59:    // are set, count down for bits that are cleared, and bail
        -:   60:    // when a mix is detected.
    35503:   61:    if (auto denseElts = c.getValue().dyn_cast<DenseIntElementsAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    35503:   62:      int64_t val = 0;
  3354285:   63:      for (bool b : denseElts.getValues<bool>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
  1659480:   64:        if (b && val >= 0)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
   931607:   65:          val++;
   727873:   66:        else if (!b && val <= 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   727695:   67:          val--;
        -:   68:        else
      178:   69:          return MaskFormat::Unknown;
    35325:   70:      if (val > 0)
branch  0 taken 36%
branch  1 taken 64%
        -:   71:        return MaskFormat::AllTrue;
    12695:   72:      if (val < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   73:        return MaskFormat::AllFalse;
        -:   74:    }
    45332:   75:  } else if (auto m = mask.getDefiningOp<ConstantMaskOp>()) {
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        -:   76:    // Inspect constant mask index. If the index exceeds the
        -:   77:    // dimension size, all bits are set. If the index is zero
        -:   78:    // or less, no bits are set.
     2785:   79:    ArrayAttr masks = m.getMaskDimSizes();
call    0 returned 100%
     2785:   80:    auto shape = m.getType().getShape();
call    0 returned 100%
call    1 returned 100%
     2785:   81:    bool allTrue = true;
     2785:   82:    bool allFalse = true;
     6690:   83:    for (auto pair : llvm::zip(masks, shape)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
     3905:   84:      int64_t i = std::get<0>(pair).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
     3905:   85:      int64_t u = std::get<1>(pair);
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
     3905:   86:      if (i < u)
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
     2107:   87:        allTrue = false;
     3905:   88:      if (i > 0)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
     3837:   89:        allFalse = false;
        -:   90:    }
     2785:   91:    if (allTrue)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
      948:   92:      return MaskFormat::AllTrue;
     1898:   93:    if (allFalse)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:   94:      return MaskFormat::AllFalse;
        -:   95:  }
    44384:   96:  return MaskFormat::Unknown;
        -:   97:}
        -:   98:
        -:   99:/// Default callback to build a region with a 'vector.yield' terminator with no
        -:  100:/// arguments.
function _ZN4mlir6vector19buildTerminatedBodyERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  101:void mlir::vector::buildTerminatedBody(OpBuilder &builder, Location loc) {
    #####:  102:  builder.create<vector::YieldOp>(loc);
call    0 never executed
    #####:  103:}
        -:  104:
        -:  105:// Helper for verifying combining kinds in contractions and reductions.
function _ZL24isSupportedCombiningKindN4mlir6vector13CombiningKindENS_4TypeE called 210008648 returned 100% blocks executed 100%
210008648:  106:static bool isSupportedCombiningKind(CombiningKind combiningKind,
        -:  107:                                     Type elementType) {
210008648:  108:  switch (combiningKind) {
branch  0 taken 32%
branch  1 taken 56%
branch  2 taken 12%
branch  3 taken 0%
 67520090:  109:  case CombiningKind::ADD:
 67520090:  110:  case CombiningKind::MUL:
 67520090:  111:    return elementType.isIntOrIndexOrFloat();
call    0 returned 100%
118127347:  112:  case CombiningKind::MINUI:
118127347:  113:  case CombiningKind::MINSI:
118127347:  114:  case CombiningKind::MAXUI:
118127347:  115:  case CombiningKind::MAXSI:
118127347:  116:  case CombiningKind::AND:
118127347:  117:  case CombiningKind::OR:
118127347:  118:  case CombiningKind::XOR:
118127347:  119:    return elementType.isIntOrIndex();
call    0 returned 100%
 24361211:  120:  case CombiningKind::MINF:
 24361211:  121:  case CombiningKind::MAXF:
 24361211:  122:    return elementType.isa<FloatType>();
call    0 returned 100%
        -:  123:  }
        -:  124:  return false;
        -:  125:}
        -:  126:
        -:  127:/// Return true if the last dimension of the MemRefType has unit stride. Also
        -:  128:/// return true for memrefs with no strides.
function _ZN4mlir6vector25isLastMemrefDimUnitStrideENS_10MemRefTypeE called 49779063 returned 100% blocks executed 89%
 49779063:  129:bool mlir::vector::isLastMemrefDimUnitStride(MemRefType type) {
 49779063:  130:  int64_t offset;
 49779063:  131:  SmallVector<int64_t> strides;
call    0 returned 100%
 49779063:  132:  auto successStrides = getStridesAndOffset(type, strides, offset);
call    0 returned 100%
 98975545:  133:  return succeeded(successStrides) && (strides.empty() || strides.back() == 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:  134:}
        -:  135:
function _ZN4mlir6vector27getTransferMinorIdentityMapENS_10ShapedTypeENS_10VectorTypeE called 2019189 returned 100% blocks executed 59%
  2019189:  136:AffineMap mlir::vector::getTransferMinorIdentityMap(ShapedType shapedType,
        -:  137:                                                    VectorType vectorType) {
  2019189:  138:  int64_t elementVectorRank = 0;
  2019189:  139:  VectorType elementVectorType =
  2019189:  140:      shapedType.getElementType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
  2019189:  141:  if (elementVectorType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  142:    elementVectorRank += elementVectorType.getRank();
call    0 never executed
        -:  143:  // 0-d transfers are to/from tensor<t>/memref<t> and vector<1xt>.
        -:  144:  // TODO: replace once we have 0-d vectors.
 2019189*:  145:  if (shapedType.getRank() == 0 &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  146:      vectorType.getShape() == ArrayRef<int64_t>{1})
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  147:    return AffineMap::get(
        -:  148:        /*numDims=*/0, /*numSymbols=*/0,
    #####:  149:        getAffineConstantExpr(0, shapedType.getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
  2019189:  150:  return AffineMap::getMinorIdentityMap(
  2019189:  151:      shapedType.getRank(), vectorType.getRank() - elementVectorRank,
  2019189:  152:      shapedType.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  153:}
        -:  154:
function _ZN4mlir6vector17checkSameValueRAWENS0_15TransferWriteOpENS0_14TransferReadOpE called 64 returned 100% blocks executed 55%
       64:  155:bool mlir::vector::checkSameValueRAW(vector::TransferWriteOp defWrite,
        -:  156:                                     vector::TransferReadOp read) {
       94:  157:  return !defWrite.hasOutOfBoundsDim() && !defWrite.getMask() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      30*:  158:         !read.getMask() && defWrite.getIndices() == read.getIndices() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 never executed
branch  8 never executed
      64*:  159:         defWrite.getVectorType() == read.getVectorType() &&
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  160:         defWrite.getPermutationMap() == read.getPermutationMap();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  161:}
        -:  162:
function _ZN4mlir6vector17checkSameValueWAWENS0_15TransferWriteOpES1_ called 416 returned 100% blocks executed 29%
      416:  163:bool mlir::vector::checkSameValueWAW(vector::TransferWriteOp write,
        -:  164:                                     vector::TransferWriteOp priorWrite) {
     416*:  165:  return priorWrite.getIndices() == write.getIndices() &&
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 never executed
branch  4 never executed
    #####:  166:         priorWrite.getMask() == write.getMask() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
     416*:  167:         priorWrite.getVectorType() == write.getVectorType() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  168:         priorWrite.getPermutationMap() == write.getPermutationMap();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  169:}
        -:  170:
function _ZN4mlir6vector25isDisjointTransferIndicesENS_25VectorTransferOpInterfaceES1_ called 1036 returned 100% blocks executed 100%
     1036:  171:bool mlir::vector::isDisjointTransferIndices(
        -:  172:    VectorTransferOpInterface transferA, VectorTransferOpInterface transferB) {
        -:  173:  // For simplicity only look at transfer of same type.
     1036:  174:  if (transferA.getVectorType() != transferB.getVectorType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 48% (fallthrough)
branch  3 taken 52%
        -:  175:    return false;
      495:  176:  unsigned rankOffset = transferA.getLeadingShapedRank();
call    0 returned 100%
      852:  177:  for (unsigned i = 0, e = transferA.indices().size(); i < e; i++) {
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
      579:  178:    auto indexA = transferA.indices()[i].getDefiningOp<arith::ConstantOp>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      579:  179:    auto indexB = transferB.indices()[i].getDefiningOp<arith::ConstantOp>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  180:    // If any of the indices are dynamic we cannot prove anything.
      579:  181:    if (!indexA || !indexB)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
      350:  182:      continue;
        -:  183:
      229:  184:    if (i < rankOffset) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:  185:      // For leading dimensions, if we can prove that index are different we
        -:  186:      // know we are accessing disjoint slices.
      222:  187:      if (indexA.getValue().cast<IntegerAttr>().getInt() !=
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      222:  188:          indexB.getValue().cast<IntegerAttr>().getInt())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 3%
branch  4 taken 97%
      222:  189:        return true;
        -:  190:    } else {
        -:  191:      // For this dimension, we slice a part of the memref we need to make sure
        -:  192:      // the intervals accessed don't overlap.
        7:  193:      int64_t distance =
       14:  194:          std::abs(indexA.getValue().cast<IntegerAttr>().getInt() -
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        7:  195:                   indexB.getValue().cast<IntegerAttr>().getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        7:  196:      if (distance >= transferA.getVectorType().getDimSize(i - rankOffset))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
        -:  197:        return true;
        -:  198:    }
        -:  199:  }
        -:  200:  return false;
        -:  201:}
        -:  202:
function _ZN4mlir6vector21isDisjointTransferSetENS_25VectorTransferOpInterfaceES1_ called 1036 returned 100% blocks executed 100%
     1036:  203:bool mlir::vector::isDisjointTransferSet(VectorTransferOpInterface transferA,
        -:  204:                                         VectorTransferOpInterface transferB) {
     1036:  205:  if (transferA.source() != transferB.source())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  206:    return false;
     1036:  207:  return isDisjointTransferIndices(transferA, transferB);
call    0 returned 100%
        -:  208:}
        -:  209:
        -:  210://===----------------------------------------------------------------------===//
        -:  211:// CombiningKindAttr
        -:  212://===----------------------------------------------------------------------===//
        -:  213:
        -:  214:namespace mlir {
        -:  215:namespace vector {
        -:  216:namespace detail {
        -:  217:struct BitmaskEnumStorage : public AttributeStorage {
        -:  218:  using KeyTy = uint64_t;
        -:  219:
        -:  220:  BitmaskEnumStorage(KeyTy val) : value(val) {}
        -:  221:
        -:  222:  bool operator==(const KeyTy &key) const { return value == key; }
        -:  223:
        -:  224:  static BitmaskEnumStorage *construct(AttributeStorageAllocator &allocator,
        -:  225:                                       const KeyTy &key) {
        -:  226:    return new (allocator.allocate<BitmaskEnumStorage>())
        -:  227:        BitmaskEnumStorage(key);
        -:  228:  }
        -:  229:
        -:  230:  KeyTy value = 0;
        -:  231:};
        -:  232:} // namespace detail
        -:  233:} // namespace vector
        -:  234:} // namespace mlir
        -:  235:
        -:  236://===----------------------------------------------------------------------===//
        -:  237:// VectorDialect
        -:  238://===----------------------------------------------------------------------===//
        -:  239:
function _ZN4mlir6vector13VectorDialect10initializeEv called 91593 returned 100% blocks executed 100%
    91593:  240:void VectorDialect::initialize() {
    91593:  241:  addAttributes<
        -:  242:#define GET_ATTRDEF_LIST
        -:  243:#include "mlir/Dialect/Vector/IR/VectorOpsAttrDefs.cpp.inc"
    91593:  244:      >();
call    0 returned 100%
        -:  245:
    91593:  246:  addOperations<
        -:  247:#define GET_OP_LIST
        -:  248:#include "mlir/Dialect/Vector/IR/VectorOps.cpp.inc"
    91593:  249:      >();
call    0 returned 100%
    91593:  250:}
        -:  251:
        -:  252:/// Materialize a single constant operation from a given attribute value with
        -:  253:/// the desired resultant type.
function _ZN4mlir6vector13VectorDialect19materializeConstantERNS_9OpBuilderENS_9AttributeENS_4TypeENS_8LocationE called 2509595 returned 100% blocks executed 100%
  2509595:  254:Operation *VectorDialect::materializeConstant(OpBuilder &builder,
        -:  255:                                              Attribute value, Type type,
        -:  256:                                              Location loc) {
  2509595:  257:  return builder.create<arith::ConstantOp>(loc, type, value);
call    0 returned 100%
        -:  258:}
        -:  259:
function _ZN4mlir6vector22getVectorSubscriptTypeERNS_7BuilderE called 0 returned 0% blocks executed 0%
    #####:  260:IntegerType vector::getVectorSubscriptType(Builder &builder) {
    #####:  261:  return builder.getIntegerType(64);
call    0 never executed
        -:  262:}
        -:  263:
function _ZN4mlir6vector22getVectorSubscriptAttrERNS_7BuilderEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
  554119*:  264:ArrayAttr vector::getVectorSubscriptAttr(Builder &builder,
        -:  265:                                         ArrayRef<int64_t> values) {
    3329*:  266:  return builder.getI64ArrayAttr(values);
call    0 returned 100%
call    1 never executed
call    2 returned 100%
call    3 never executed
        -:  267:}
        -:  268:
        -:  269://===----------------------------------------------------------------------===//
        -:  270:// MultiDimReductionOp
        -:  271://===----------------------------------------------------------------------===//
        -:  272:
function _ZN4mlir6vector19MultiDimReductionOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIbEENS0_13CombiningKindE called 0 returned 0% blocks executed 0%
    #####:  273:void vector::MultiDimReductionOp::build(OpBuilder &builder,
        -:  274:                                        OperationState &result, Value source,
        -:  275:                                        Value acc, ArrayRef<bool> reductionMask,
        -:  276:                                        CombiningKind kind) {
    #####:  277:  SmallVector<int64_t> reductionDims;
    #####:  278:  for (const auto &en : llvm::enumerate(reductionMask))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  279:    if (en.value())
branch  0 never executed
branch  1 never executed
    #####:  280:      reductionDims.push_back(en.index());
call    0 never executed
    #####:  281:  build(builder, result, kind, source, acc,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  282:        builder.getI64ArrayAttr(reductionDims));
    #####:  283:}
        -:  284:
function _ZN4mlir6vector19MultiDimReductionOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 241941 returned 100% blocks executed 100%
   241941:  285:OpFoldResult MultiDimReductionOp::fold(ArrayRef<Attribute> operands) {
        -:  286:  // Single parallel dim, this is a noop.
   241941:  287:  if (getSourceVectorType().getRank() == 1 && !isReducedDim(0))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 60% (fallthrough)
branch  3 taken 40%
call    4 returned 100%
branch  5 taken 36% (fallthrough)
branch  6 taken 64%
    53039:  288:    return getSource();
call    0 returned 100%
call    1 returned 100%
   188902:  289:  return {};
        -:  290:}
        -:  291:
function _ZN4mlir6vector19MultiDimReductionOp17getShapeForUnrollEv called 637 returned 100% blocks executed 88%
      637:  292:Optional<SmallVector<int64_t, 4>> MultiDimReductionOp::getShapeForUnroll() {
     1274:  293:  return llvm::to_vector<4>(getSourceVectorType().getShape());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  294:}
        -:  295:
function _ZN4mlir6vector19MultiDimReductionOp6verifyEv called 39824174 returned 100% blocks executed 67%
 39824174:  296:LogicalResult MultiDimReductionOp::verify() {
 39824174:  297:  SmallVector<int64_t> targetShape;
call    0 returned 100%
 39824174:  298:  Type inferredReturnType;
111593028:  299:  for (auto it : llvm::enumerate(getSourceVectorType().getShape()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 64% (fallthrough)
branch  3 taken 36%
call    4 returned 100%
call    5 returned 100%
function _ZZN4mlir6vector19MultiDimReductionOp6verifyEvENKUlNS_9AttributeEE_clES2_.isra.0 called 72243444 returned 100% blocks executed 71%
 71768853:  300:    if (!llvm::any_of(getReductionDims().getValue(), [&](Attribute attr) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 44% (fallthrough)
branch  4 taken 56%
 72243444:  301:          return attr.cast<IntegerAttr>().getValue() == it.index();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  302:        }))
 31355940:  303:      targetShape.push_back(it.value());
call    0 returned 100%
        -:  304:  // TODO: update to also allow 0-d vectors when available.
 39824175:  305:  if (targetShape.empty())
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
 16653979:  306:    inferredReturnType = getSourceVectorType().getElementType();
call    0 returned 100%
call    1 returned 100%
        -:  307:  else
 46340392:  308:    inferredReturnType =
 23170196:  309:        VectorType::get(targetShape, getSourceVectorType().getElementType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 39824175:  310:  if (getType() != inferredReturnType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  311:    return emitOpError() << "destination type " << getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  312:                         << " is incompatible with source type "
    #####:  313:                         << getSourceVectorType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  314:
 39824175:  315:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  316:}
        -:  317:
        -:  318:namespace {
        -:  319:// Only unit dimensions that are being reduced are folded. If the dimension is
        -:  320:// unit, but not reduced, it is not folded, thereby keeping the output type the
        -:  321:// same. If not all dimensions which are reduced are of unit dimension, this
        -:  322:// transformation does nothing. This is just a generalization of
        -:  323:// ElideSingleElementReduction for ReduceOp.
        -:  324:struct ElideUnitDimsInMultiDimReduction
        -:  325:    : public OpRewritePattern<MultiDimReductionOp> {
        -:  326:  using OpRewritePattern::OpRewritePattern;
        -:  327:
function _ZNK12_GLOBAL__N_132ElideUnitDimsInMultiDimReduction15matchAndRewriteEN4mlir6vector19MultiDimReductionOpERNS1_15PatternRewriterE called 1814 returned 100% blocks executed 84%
     1814:  328:  LogicalResult matchAndRewrite(MultiDimReductionOp reductionOp,
        -:  329:                                PatternRewriter &rewriter) const override {
     1814:  330:    ArrayRef<int64_t> shape = reductionOp.getSourceVectorType().getShape();
call    0 returned 100%
call    1 returned 100%
     1911:  331:    for (const auto &dim : enumerate(shape)) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
     1828:  332:      if (reductionOp.isReducedDim(dim.index()) && dim.value() != 1)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 95% (fallthrough)
branch  4 taken 5%
     1731:  333:        return failure();
        -:  334:    }
       83:  335:    Location loc = reductionOp.getLoc();
call    0 returned 100%
       83:  336:    Value acc = reductionOp.getAcc();
call    0 returned 100%
       83:  337:    Value cast;
       83:  338:    if (reductionOp.getDestType().isa<VectorType>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  339:      cast = rewriter.create<vector::ShapeCastOp>(
    #####:  340:          loc, reductionOp.getDestType(), reductionOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  341:    } else {
        -:  342:      // This means we are reducing all the dimensions, and all reduction
        -:  343:      // dimensions are of size 1. So a simple extraction would do.
      166:  344:      cast = rewriter.create<vector::ExtractOp>(
      166:  345:          loc, reductionOp.getDestType(), reductionOp.getSource(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      166:  346:          rewriter.getI64ArrayAttr(SmallVector<int64_t>(shape.size(), 0)));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  347:    }
        -:  348:
       83:  349:    Value result = vector::makeArithReduction(rewriter, loc,
call    0 returned 100%
       83:  350:                                              reductionOp.getKind(), acc, cast);
call    0 returned 100%
       83:  351:    rewriter.replaceOp(reductionOp, result);
call    0 returned 100%
call    1 returned 100%
       83:  352:    return success();
        -:  353:  }
        -:  354:};
        -:  355:} // namespace
        -:  356:
function _ZN4mlir6vector19MultiDimReductionOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  357:void MultiDimReductionOp::getCanonicalizationPatterns(
        -:  358:    RewritePatternSet &results, MLIRContext *context) {
     1235:  359:  results.add<ElideUnitDimsInMultiDimReduction>(context);
call    0 returned 100%
     1235:  360:}
        -:  361:
        -:  362://===----------------------------------------------------------------------===//
        -:  363:// ReductionOp
        -:  364://===----------------------------------------------------------------------===//
        -:  365:
function _ZN4mlir6vector11ReductionOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_13CombiningKindENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  366:void vector::ReductionOp::build(OpBuilder &builder, OperationState &result,
        -:  367:                                CombiningKind kind, Value vector) {
    #####:  368:  build(builder, result, kind, vector, /*acc=*/Value());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  369:}
        -:  370:
function _ZN4mlir6vector11ReductionOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_13CombiningKindENS_5ValueES7_ called 0 returned 0% blocks executed 0%
    #####:  371:void vector::ReductionOp::build(OpBuilder &builder, OperationState &result,
        -:  372:                                CombiningKind kind, Value vector, Value acc) {
    #####:  373:  build(builder, result, vector.getType().cast<VectorType>().getElementType(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  374:        kind, vector, acc);
    #####:  375:}
        -:  376:
function _ZN4mlir6vector11ReductionOp6verifyEv called 54193613 returned 100% blocks executed 31%
 54193613:  377:LogicalResult ReductionOp::verify() {
        -:  378:  // Verify for 0-D and 1-D vector.
 54193613:  379:  int64_t rank = getVectorType().getRank();
call    0 returned 100%
call    1 returned 100%
 54193614:  380:  if (rank > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  381:    return emitOpError("unsupported reduction rank: ") << rank;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  382:
        -:  383:  // Verify supported reduction kind.
 54193614:  384:  Type eltType = getDest().getType();
call    0 returned 100%
call    1 returned 100%
 54193614:  385:  if (!isSupportedCombiningKind(getKind(), eltType))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  386:    return emitOpError("unsupported reduction type '")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  387:           << eltType << "' for kind '" << stringifyCombiningKind(getKind())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  388:           << "'";
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  389:
 54193614:  390:  return success();
        -:  391:}
        -:  392:
function _ZN4mlir6vector11ReductionOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1388923 returned 100% blocks executed 67%
  1388923:  393:ParseResult ReductionOp::parse(OpAsmParser &parser, OperationState &result) {
  1388923:  394:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandsInfo;
call    0 returned 100%
  1388923:  395:  Type redType;
  1388923:  396:  Type resType;
  1388923:  397:  CombiningKindAttr kindAttr;
 2777846*:  398:  if (parser.parseCustomAttributeWithFallback(kindAttr, Type{}, "kind",
 2777846*:  399:                                              result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2777846*:  400:      parser.parseComma() || parser.parseOperandList(operandsInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 2777846*:  401:      parser.parseColonType(redType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 1388923*:  402:      parser.parseKeywordType("into", resType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2777846:  403:      (!operandsInfo.empty() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 1388923*:  404:       parser.resolveOperand(operandsInfo[0], redType, result.operands)) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 1388923*:  405:      (operandsInfo.size() > 1 &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
 1388923*:  406:       parser.resolveOperand(operandsInfo[1], resType, result.operands)) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
branch  3 never executed
branch  4 never executed
  1388923:  407:      parser.addTypeToList(resType, result.types))
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
    #####:  408:    return failure();
  1388923:  409:  if (operandsInfo.empty() || operandsInfo.size() > 2)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####:  410:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  411:                            "unsupported number of operands");
call    0 never executed
call    1 never executed
  1388923:  412:  return success();
        -:  413:}
        -:  414:
function _ZN4mlir6vector11ReductionOp5printERNS_12OpAsmPrinterE called 1817025 returned 100% blocks executed 80%
  1817025:  415:void ReductionOp::print(OpAsmPrinter &p) {
  1817025:  416:  p << " ";
call    0 returned 100%
  1817025:  417:  getKindAttr().print(p);
call    0 returned 100%
call    1 returned 100%
  3634050:  418:  p << ", " << getVector();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1817025:  419:  if (getAcc())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  420:    p << ", " << getAcc();
call    0 never executed
call    1 never executed
call    2 never executed
  5451075:  421:  p << " : " << getVector().getType() << " into " << getDest().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
  1817025:  422:}
        -:  423:
function _ZN4mlir6vector20getVectorReductionOpENS_5arith13AtomicRMWKindERNS_9OpBuilderENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  424:Value mlir::vector::getVectorReductionOp(arith::AtomicRMWKind op,
        -:  425:                                         OpBuilder &builder, Location loc,
        -:  426:                                         Value vector) {
    #####:  427:  switch (op) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####:  428:  case arith::AtomicRMWKind::addf:
    #####:  429:  case arith::AtomicRMWKind::addi:
    #####:  430:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  431:                                               CombiningKind::ADD, vector);
call    0 never executed
call    1 never executed
    #####:  432:  case arith::AtomicRMWKind::mulf:
    #####:  433:  case arith::AtomicRMWKind::muli:
    #####:  434:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  435:                                               CombiningKind::MUL, vector);
call    0 never executed
call    1 never executed
    #####:  436:  case arith::AtomicRMWKind::minf:
    #####:  437:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  438:                                               CombiningKind::MINF, vector);
call    0 never executed
call    1 never executed
    #####:  439:  case arith::AtomicRMWKind::mins:
    #####:  440:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  441:                                               CombiningKind::MINSI, vector);
call    0 never executed
call    1 never executed
    #####:  442:  case arith::AtomicRMWKind::minu:
    #####:  443:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  444:                                               CombiningKind::MINUI, vector);
call    0 never executed
call    1 never executed
    #####:  445:  case arith::AtomicRMWKind::maxf:
    #####:  446:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  447:                                               CombiningKind::MAXF, vector);
call    0 never executed
call    1 never executed
    #####:  448:  case arith::AtomicRMWKind::maxs:
    #####:  449:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  450:                                               CombiningKind::MAXSI, vector);
call    0 never executed
call    1 never executed
    #####:  451:  case arith::AtomicRMWKind::maxu:
    #####:  452:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  453:                                               CombiningKind::MAXUI, vector);
call    0 never executed
call    1 never executed
    #####:  454:  case arith::AtomicRMWKind::andi:
    #####:  455:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  456:                                               CombiningKind::AND, vector);
call    0 never executed
call    1 never executed
    #####:  457:  case arith::AtomicRMWKind::ori:
    #####:  458:    return builder.create<vector::ReductionOp>(vector.getLoc(),
    #####:  459:                                               CombiningKind::OR, vector);
call    0 never executed
call    1 never executed
        -:  460:  // TODO: Add remaining reduction operations.
    #####:  461:  default:
    #####:  462:    (void)emitOptionalError(loc, "Reduction operation type not supported");
call    0 never executed
    #####:  463:    break;
        -:  464:  }
    #####:  465:  return nullptr;
        -:  466:}
        -:  467:
function _ZN4mlir6vector11ReductionOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####:  468:Optional<SmallVector<int64_t, 4>> ReductionOp::getShapeForUnroll() {
    #####:  469:  return llvm::to_vector<4>(getVectorType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  470:}
        -:  471:
        -:  472:namespace {
        -:  473:struct ElideSingleElementReduction : public OpRewritePattern<ReductionOp> {
        -:  474:  using OpRewritePattern::OpRewritePattern;
        -:  475:
function _ZNK12_GLOBAL__N_127ElideSingleElementReduction15matchAndRewriteEN4mlir6vector11ReductionOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  476:  LogicalResult matchAndRewrite(ReductionOp reductionOp,
        -:  477:                                PatternRewriter &rewriter) const override {
    #####:  478:    if (reductionOp.getVectorType().getDimSize(0) != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  479:      return failure();
        -:  480:
    #####:  481:    Location loc = reductionOp.getLoc();
call    0 never executed
    #####:  482:    Value result = rewriter.create<ExtractOp>(loc, reductionOp.getType(),
    #####:  483:                                              reductionOp.getVector(),
call    0 never executed
call    1 never executed
    #####:  484:                                              rewriter.getI64ArrayAttr(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  485:
    #####:  486:    if (Value acc = reductionOp.getAcc())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  487:      result = vector::makeArithReduction(rewriter, loc, reductionOp.getKind(),
call    0 never executed
    #####:  488:                                          result, acc);
call    0 never executed
        -:  489:
    #####:  490:    rewriter.replaceOp(reductionOp, result);
call    0 never executed
call    1 never executed
    #####:  491:    return success();
        -:  492:  }
        -:  493:};
        -:  494:} // namespace
        -:  495:
function _ZN4mlir6vector11ReductionOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  496:void ReductionOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  497:                                              MLIRContext *context) {
     1235:  498:  results.add<ElideSingleElementReduction>(context);
call    0 returned 100%
     1235:  499:}
        -:  500:
        -:  501://===----------------------------------------------------------------------===//
        -:  502:// ContractionOp
        -:  503://===----------------------------------------------------------------------===//
        -:  504:
function _ZN4mlir6vector13ContractionOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_N4llvm8ArrayRefINS8_INS_10AffineExprEEEEENS8_INS0_12IteratorTypeEEE called 0 returned 0% blocks executed 0%
    #####:  505:void vector::ContractionOp::build(OpBuilder &builder, OperationState &result,
        -:  506:                                  Value lhs, Value rhs, Value acc,
        -:  507:                                  ArrayRef<ArrayRef<AffineExpr>> indexingExprs,
        -:  508:                                  ArrayRef<IteratorType> iteratorTypes) {
    #####:  509:  result.addOperands({lhs, rhs, acc});
call    0 never executed
call    1 never executed
    #####:  510:  result.addTypes(acc.getType());
call    0 never executed
    #####:  511:  result.addAttribute(::mlir::getIndexingMapsAttrName(),
call    0 never executed
    #####:  512:                      builder.getAffineMapArrayAttr(
    #####:  513:                          AffineMap::inferFromExprList(indexingExprs)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  514:  result.addAttribute(
call    0 never executed
        -:  515:      ::mlir::getIteratorTypesAttrName(),
    #####:  516:      builder.getArrayAttr(llvm::to_vector(llvm::map_range(
call    0 never executed
        -:  517:          iteratorTypes, [&](IteratorType t) -> mlir::Attribute {
        -:  518:            return IteratorTypeAttr::get(builder.getContext(), t);
    #####:  519:          }))));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  520:}
        -:  521:
function _ZN4mlir6vector13ContractionOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_NS_9ArrayAttrES7_ called 0 returned 0% blocks executed 0%
    #####:  522:void vector::ContractionOp::build(OpBuilder &builder, OperationState &result,
        -:  523:                                  Value lhs, Value rhs, Value acc,
        -:  524:                                  ArrayAttr indexingMaps,
        -:  525:                                  ArrayAttr iteratorTypes) {
    #####:  526:  build(builder, result, lhs, rhs, acc, indexingMaps, iteratorTypes,
call    0 never executed
        -:  527:        ContractionOp::getDefaultKind());
    #####:  528:}
        -:  529:
function _ZN4mlir6vector13ContractionOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_NS_9ArrayAttrES7_NS0_13CombiningKindE called 0 returned 0% blocks executed 0%
    #####:  530:void vector::ContractionOp::build(OpBuilder &builder, OperationState &result,
        -:  531:                                  Value lhs, Value rhs, Value acc,
        -:  532:                                  ArrayAttr indexingMaps,
        -:  533:                                  ArrayAttr iteratorTypes, CombiningKind kind) {
    #####:  534:  result.addOperands({lhs, rhs, acc});
call    0 never executed
call    1 never executed
    #####:  535:  result.addTypes(acc.getType());
call    0 never executed
    #####:  536:  result.addAttribute(::mlir::getIndexingMapsAttrName(), indexingMaps);
call    0 never executed
    #####:  537:  result.addAttribute(::mlir::getIteratorTypesAttrName(), iteratorTypes);
call    0 never executed
    #####:  538:  result.addAttribute(ContractionOp::getKindAttrStrName(),
call    0 never executed
    #####:  539:                      CombiningKindAttr::get(builder.getContext(), kind));
call    0 never executed
call    1 never executed
    #####:  540:}
        -:  541:
function _ZN4mlir6vector13ContractionOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1454537 returned 100% blocks executed 56%
  1454537:  542:ParseResult ContractionOp::parse(OpAsmParser &parser, OperationState &result) {
  1454537:  543:  OpAsmParser::UnresolvedOperand lhsInfo;
call    0 returned 100%
  1454537:  544:  OpAsmParser::UnresolvedOperand rhsInfo;
  1454537:  545:  OpAsmParser::UnresolvedOperand accInfo;
  1454537:  546:  SmallVector<OpAsmParser::UnresolvedOperand, 2> masksInfo;
call    0 returned 100%
  1454537:  547:  SmallVector<Type, 2> types;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1454537:  548:  Type resultType;
  1454537:  549:  auto loc = parser.getCurrentLocation();
call    0 returned 100%
  1454537:  550:  DictionaryAttr dictAttr;
        -:  551:  // TODO: Unify linalg op attribute parsing.
  2909074:  552:  if (parser.parseAttribute(dictAttr, "_", result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  553:      parser.parseOperand(lhsInfo) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 2909074*:  554:      parser.parseOperand(rhsInfo) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 2909074*:  555:      parser.parseOperand(accInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  556:      parser.parseTrailingOperandList(masksInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  557:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  558:      parser.parseColonTypeList(types) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  559:      parser.parseKeywordType("into", resultType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2909074*:  560:      parser.resolveOperand(lhsInfo, types[0], result.operands) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 2909074*:  561:      parser.resolveOperand(rhsInfo, types[1], result.operands) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 2909074*:  562:      parser.resolveOperand(accInfo, resultType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1454537:  563:      parser.addTypeToList(resultType, result.types))
call    0 returned 100%
call    1 returned 100%
    #####:  564:    return failure();
  1454537:  565:  result.attributes.assign(dictAttr.getValue().begin(),
call    0 returned 100%
call    1 returned 100%
  1454537:  566:                           dictAttr.getValue().end());
call    0 returned 100%
        -:  567:
        -:  568:  // Convert array of string into an array of IteratyType enums. This is needed,
        -:  569:  // because tests still use the old format when 'iterator_types' attribute is
        -:  570:  // represented as an array of strings.
        -:  571:  // TODO: Remove this conversion once tests are fixed.
  1454537:  572:  ArrayAttr iteratorTypes =
  1454537:  573:      result.attributes.get("iterator_types").cast<ArrayAttr>();
call    0 returned 100%
call    1 returned 100%
        -:  574:
  2909074:  575:  SmallVector<Attribute> iteratorTypeAttrs;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  576:
  5057586:  577:  for (StringRef s : iteratorTypes.getAsValueRange<StringAttr>()) {
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
call    3 returned 100%
  3603049:  578:    auto maybeIteratorType = symbolizeIteratorType(s);
call    0 returned 100%
  3603049:  579:    if (!maybeIteratorType.has_value())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  580:      return parser.emitError(loc) << "unexpected iterator_type (" << s << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  581:
  7206098:  582:    iteratorTypeAttrs.push_back(IteratorTypeAttr::get(
call    0 returned 100%
  3603049:  583:        parser.getContext(), maybeIteratorType.value()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  584:  }
  1454537:  585:  result.attributes.set("iterator_types",
  1454537:  586:                        parser.getBuilder().getArrayAttr(iteratorTypeAttrs));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  587:
  1454537:  588:  if (!result.attributes.get(ContractionOp::getKindAttrStrName())) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  589:    result.addAttribute(
call    0 never executed
call    1 never executed
        -:  590:        ContractionOp::getKindAttrStrName(),
    #####:  591:        CombiningKindAttr::get(result.getContext(),
    #####:  592:                               ContractionOp::getDefaultKind()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  593:  }
  1454537:  594:  if (masksInfo.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1454537:  595:    return success();
    #####:  596:  if (masksInfo.size() != 2)
branch  0 never executed
branch  1 never executed
    #####:  597:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  598:                            "expected zero or exactly 2 vector mask operands");
call    0 never executed
call    1 never executed
    #####:  599:  auto lhsType = types[0].cast<VectorType>();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  600:  auto rhsType = types[1].cast<VectorType>();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  601:  auto maskElementType = parser.getBuilder().getI1Type();
call    0 never executed
call    1 never executed
    #####:  602:  std::array<Type, 2> maskTypes = {
    #####:  603:      VectorType::Builder(lhsType).setElementType(maskElementType),
call    0 never executed
call    1 never executed
    #####:  604:      VectorType::Builder(rhsType).setElementType(maskElementType)};
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  605:  if (parser.resolveOperands(masksInfo, maskTypes, loc, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  606:    return failure();
    #####:  607:  return success();
        -:  608:}
        -:  609:
function _ZN4mlir6vector13ContractionOp5printERNS_12OpAsmPrinterE called 1931287 returned 100% blocks executed 90%
  1931287:  610:void ContractionOp::print(OpAsmPrinter &p) {
        -:  611:  // TODO: Unify printing code with linalg ops.
  1931287:  612:  auto attrNames = getTraitAttrNames();
  1931287:  613:  llvm::StringSet<> traitAttrsSet;
  1931287:  614:  traitAttrsSet.insert(attrNames.begin(), attrNames.end());
  3862574:  615:  SmallVector<NamedAttribute, 8> attrs;
call    0 returned 100%
call    1 returned 100%
  7725148:  616:  for (auto attr : (*this)->getAttrs()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
  5793861:  617:    if (attr.getName() == getIteratorTypesAttrName()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
  1931287:  618:      auto iteratorTypes =
  1931287:  619:          attr.getValue()
call    0 returned 100%
  1931287:  620:              .cast<ArrayAttr>()
call    0 returned 100%
  1931287:  621:              .getAsValueRange<IteratorTypeAttr, IteratorType>();
        -:  622:      // Convert IteratorType enums into the string representation. This is
        -:  623:      // needed, because tests still use the old format when 'iterator_types'
        -:  624:      // attribute is represented as an array of strings.
        -:  625:      // TODO: Remove this conversion once tests are fixed.
  1931287:  626:      SmallVector<Attribute> iteratorTypeNames = llvm::to_vector(
function _ZZN4mlir6vector13ContractionOp5printERNS_12OpAsmPrinterEENKUlNS0_12IteratorTypeEE_clES4_.isra.0 called 4767012 returned 100% blocks executed 88%
  4767012:  627:          llvm::map_range(iteratorTypes, [&](IteratorType t) -> Attribute {
  6698299:  628:            return StringAttr::get(getContext(), stringifyIteratorType(t));
branch  0 taken 41%
branch  1 taken 0%
branch  2 taken 59%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  3862574:  629:          }));
call    0 returned 100%
call    1 returned 100%
        -:  630:
  1931287:  631:      attrs.emplace_back(getIteratorTypesAttrName(),
call    0 returned 100%
  1931287:  632:                         ArrayAttr::get(getContext(), iteratorTypeNames));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
 3862574*:  633:    } else if (traitAttrsSet.count(attr.getName().strref()) > 0)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  3862574:  634:      attrs.push_back(attr);
call    0 returned 100%
        -:  635:  }
        -:  636:
  1931287:  637:  auto dictAttr = DictionaryAttr::get(getContext(), attrs);
call    0 returned 100%
call    1 returned 100%
  5793861:  638:  p << " " << dictAttr << " " << getLhs() << ", ";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  3862574:  639:  p << getRhs() << ", " << getAcc();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
  1931287:  640:  if (getMasks().size() == 2)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  641:    p << ", " << getMasks();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  642:
  1931287:  643:  p.printOptionalAttrDict((*this)->getAttrs(), attrNames);
call    0 returned 100%
call    1 returned 100%
  7725148:  644:  p << " : " << getLhs().getType() << ", " << getRhs().getType() << " into "
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
  1931287:  645:    << getResultType();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  1931287:  646:}
        -:  647:
function _ZL12verifyDimMapN4mlir10VectorTypeES0_RKSt6vectorISt4pairIllESaIS3_EE called 118761287 returned 100% blocks executed 93%
118761287:  648:static bool verifyDimMap(VectorType lhsType, VectorType rhsType,
        -:  649:                         const std::vector<std::pair<int64_t, int64_t>> &map) {
178141930:  650:  for (auto &dimPair : map) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 59380644:  651:    if (dimPair.first < 0 || dimPair.first >= lhsType.getRank() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
178141931:  652:        dimPair.second < 0 || dimPair.second >= rhsType.getRank() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
 59380643:  653:        lhsType.getDimSize(dimPair.first) != rhsType.getDimSize(dimPair.second))
call    0 returned 100%
call    1 returned 100%
    #####:  654:      return false;
        -:  655:  }
        -:  656:  return true;
        -:  657:}
        -:  658:
function _ZL17verifyOutputShapeN4mlir6vector13ContractionOpENS_10VectorTypeES2_NS_4TypeES3_RKSt6vectorISt4pairIllESaIS6_EESA_ called 59380643 returned 100% blocks executed 67%
 59380643:  659:static LogicalResult verifyOutputShape(
        -:  660:    ContractionOp op, VectorType lhsType, VectorType rhsType, Type accType,
        -:  661:    Type resType,
        -:  662:    const std::vector<std::pair<int64_t, int64_t>> &contractingDimMap,
        -:  663:    const std::vector<std::pair<int64_t, int64_t>> &batchDimMap) {
 59380643:  664:  DenseSet<int64_t> lhsContractingDimSet;
call    0 returned 100%
118761288:  665:  DenseSet<int64_t> rhsContractingDimSet;
call    0 returned 100%
call    1 returned 100%
118761288:  666:  for (auto &dimPair : contractingDimMap) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
 59380643:  667:    lhsContractingDimSet.insert(dimPair.first);
call    0 returned 100%
 59380643:  668:    rhsContractingDimSet.insert(dimPair.second);
call    0 returned 100%
        -:  669:  }
118761290:  670:  DenseSet<int64_t> rhsBatchDimSet;
call    0 returned 100%
call    1 returned 100%
59380645*:  671:  for (auto &dimPair : batchDimMap)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    #####:  672:    rhsBatchDimSet.insert(dimPair.second);
call    0 never executed
        -:  673:
        -:  674:  // Add free and batch dimensions from 'lhsType' to 'expectedResultDims'.
118761289:  675:  SmallVector<int64_t, 4> expectedResultDims;
call    0 returned 100%
call    1 returned 100%
165386756:  676:  for (int64_t i = 0, e = lhsType.getRank(); i < e; ++i) {
call    0 returned 100%
branch  1 taken 64% (fallthrough)
branch  2 taken 36%
106006112:  677:    if (lhsContractingDimSet.count(i) > 0)
call    0 returned 100%
 59380645:  678:      continue;
 46625467:  679:    expectedResultDims.push_back(lhsType.getDimSize(i));
call    0 returned 100%
call    1 returned 100%
        -:  680:  }
        -:  681:
        -:  682:  // Add free dimensions from 'rhsType' to 'expectedResultDims'.
167295711:  683:  for (int64_t i = 0, e = rhsType.getRank(); i < e; ++i) {
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
215830134*:  684:    if (rhsContractingDimSet.count(i) > 0 || rhsBatchDimSet.count(i) > 0)
call    0 returned 100%
call    1 returned 100%
 59380644:  685:      continue;
 48534423:  686:    expectedResultDims.push_back(rhsType.getDimSize(i));
call    0 returned 100%
call    1 returned 100%
        -:  687:  }
        -:  688:
        -:  689:  // Verify 'expectedResultDims'.
 59380644:  690:  if (expectedResultDims.empty()) {
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -:  691:    // No batch or free dimension implies a scalar result.
 42263980:  692:    if (resType.isa<VectorType>() || accType.isa<VectorType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
       1*:  693:      return op.emitOpError("invalid accumulator/result vector shape");
call    0 returned 0%
call    1 never executed
call    2 never executed
call    3 never executed
        -:  694:  } else {
        -:  695:    // At least one batch or free dimension implies a vector result.
 38248654:  696:    auto resVectorType = resType.dyn_cast<VectorType>();
call    0 returned 100%
 38248654:  697:    auto accVectorType = accType.dyn_cast<VectorType>();
call    0 returned 100%
 38248654:  698:    if (!resVectorType || !accVectorType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####:  699:      return op.emitOpError("invalid accumulator/result vector shape");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  700:
        -:  701:    // Infer expected result vector type. Lhs + rhs map and lhs + rhs vector
        -:  702:    // types fully define the result vector type. This assumes the affine maps
        -:  703:    // are well-formed, which must have been verified already.
 38248654:  704:    MLIRContext *ctx = op.getContext();
call    0 returned 100%
 38248654:  705:    AffineMap lhsMap = op.getIndexingMapsArray()[0];
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 38248655:  706:    AffineMap rhsMap = op.getIndexingMapsArray()[1];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 38248655:  707:    if (getUnusedDimsBitVector({lhsMap, rhsMap}).any())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  708:      return op.emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  709:          "expected all dimensions to be either a LHS or a RHS dimension");
call    0 never executed
 76497310:  710:    SmallVector<AffineExpr, 4> extents(lhsMap.getNumInputs());
call    0 returned 100%
call    1 returned 100%
 76497310:  711:    for (auto pair :
114745965:  712:         {std::make_pair(lhsType, lhsMap), std::make_pair(rhsType, rhsMap)}) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
 76497310:  713:      VectorType v = pair.first;
 76497310:  714:      auto map = pair.second;
248154511:  715:      for (unsigned idx = 0, e = v.getRank(); idx < e; ++idx) {
call    0 returned 100%
branch  1 taken 69% (fallthrough)
branch  2 taken 31%
171657201:  716:        unsigned pos = map.getDimPosition(idx);
call    0 returned 100%
171657201:  717:        if (!extents[pos])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 78% (fallthrough)
branch  3 taken 22%
133408546:  718:          extents[pos] = getAffineConstantExpr(v.getShape()[idx], ctx);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  719:      }
        -:  720:    }
 38248655:  721:    if (!llvm::all_of(extents, [](AffineExpr e) { return e; }))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  722:      return op.emitOpError("expected all dimensions to get an extent as "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  723:                            "either a LHS or a RHS dimension");
call    0 never executed
        -:  724:
 38248655:  725:    AffineMap resMap = op.getIndexingMapsArray()[2];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 38248655:  726:    auto extentsMap = AffineMap::get(/*dimCount=*/extents.size(),
call    0 returned 100%
 38248655:  727:                                     /*symCount=*/0, extents, ctx);
call    0 returned 100%
        -:  728:    // Compose the resMap with the extentsMap, which is a constant map.
 38248655:  729:    AffineMap expectedMap = simplifyAffineMap(resMap.compose(extentsMap));
call    0 returned 100%
call    1 returned 100%
38248655*:  730:    assert(llvm::all_of(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  731:               expectedMap.getResults(),
        -:  732:               [](AffineExpr e) { return e.isa<AffineConstantExpr>(); }) &&
        -:  733:           "expected constant extent along all dimensions.");
        -:  734:    // Extract the expected shape and build the type.
 38248655:  735:    auto expectedShape = llvm::to_vector<4>(
 38248655:  736:        llvm::map_range(expectedMap.getResults(), [](AffineExpr e) {
call    0 returned 100%
        -:  737:          return e.cast<AffineConstantExpr>().getValue();
 76497310:  738:        }));
call    0 returned 100%
branch  1 taken 27% (fallthrough)
branch  2 taken 73%
 38248655:  739:    auto expected =
 38248655:  740:        VectorType::get(expectedShape, resVectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
 38248655:  741:    if (resVectorType != expected || accVectorType != expected)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####:  742:      return op.emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  743:                 "invalid accumulator/result vector shape, expected: ")
    #####:  744:             << expected;
call    0 never executed
        -:  745:  }
 59380644:  746:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  747:}
        -:  748:
function _ZN4mlir6vector13ContractionOp6verifyEv called 59380644 returned 100% blocks executed 41%
 59380644:  749:LogicalResult ContractionOp::verify() {
 59380644:  750:  auto lhsType = getLhsType();
call    0 returned 100%
 59380645:  751:  auto rhsType = getRhsType();
call    0 returned 100%
 59380645:  752:  auto accType = getAccType();
call    0 returned 100%
 59380645:  753:  auto resType = getResultType();
call    0 returned 100%
        -:  754:
        -:  755:  // Verify that an indexing map was specified for each vector operand.
 59380645:  756:  if (getIndexingMapsArray().size() != 3)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  757:    return emitOpError("expected an indexing map for each vector operand");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  758:
        -:  759:  // Verify that each index map has 'numIterators' inputs, no symbols, and
        -:  760:  // that the number of map outputs equals the rank of its associated
        -:  761:  // vector operand.
 59380645:  762:  unsigned numIterators = getIteratorTypes().getValue().size();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
296903224:  763:  for (const auto &it : llvm::enumerate(getIndexingMapsArray())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 75% (fallthrough)
branch  6 taken 25%
call    7 returned 100%
178141934:  764:    auto index = it.index();
call    0 returned 100%
178141934:  765:    auto map = it.value();
call    0 returned 100%
178141934:  766:    if (map.getNumSymbols() != 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  767:      return emitOpError("expected indexing map ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  768:             << index << " to have no symbols";
call    0 never executed
call    1 never executed
178141934:  769:    auto vectorType = getOperand(index).getType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
178141933:  770:    unsigned rank = vectorType ? vectorType.getShape().size() : 0;
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
        -:  771:    // Verify that the map has the right number of inputs, outputs, and indices.
        -:  772:    // This also correctly accounts for (..) -> () for rank-0 results.
178141933:  773:    if (map.getNumDims() != numIterators)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  774:      return emitOpError("expected indexing map ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  775:             << index << " to have " << numIterators << " number of inputs";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
178141933:  776:    if (map.getNumResults() != rank)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  777:      return emitOpError("expected indexing map ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  778:             << index << " to have " << rank << " number of outputs";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
178141933:  779:    if (!map.isProjectedPermutation())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  780:      return emitOpError("expected indexing map ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  781:             << index << " to be a projected permutation of its inputs";
call    0 never executed
call    1 never executed
        -:  782:  }
        -:  783:
 59380645:  784:  auto contractingDimMap = getContractingDimMap();
call    0 returned 100%
118761289:  785:  auto batchDimMap = getBatchDimMap();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  786:
        -:  787:  // Verify at least one contracting dimension pair was specified.
 59380644:  788:  if (contractingDimMap.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  789:    return emitOpError("expected at least one contracting dimension pair");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  790:
        -:  791:  // Verify contracting dimension map was properly constructed.
 59380644:  792:  if (!verifyDimMap(lhsType, rhsType, contractingDimMap))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  793:    return emitOpError("invalid contracting dimension map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  794:
        -:  795:  // Verify batch dimension map was properly constructed.
 59380643:  796:  if (!verifyDimMap(lhsType, rhsType, batchDimMap))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  797:    return emitOpError("invalid batch dimension map");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  798:
        -:  799:  // Verify 'accType' and 'resType' shape.
 59380643:  800:  if (failed(verifyOutputShape(*this, lhsType, rhsType, accType, resType,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  801:                               contractingDimMap, batchDimMap)))
    #####:  802:    return failure();
        -:  803:
        -:  804:  // Verify that either two vector masks are set or none are set.
 59380645:  805:  auto lhsMaskType = getLHSVectorMaskType();
call    0 returned 100%
 59380645:  806:  auto rhsMaskType = getRHSVectorMaskType();
call    0 returned 100%
59380645*:  807:  if ((lhsMaskType && !rhsMaskType) || (!lhsMaskType && rhsMaskType))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####:  808:    return emitOpError("invalid number of vector masks specified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
59380645*:  809:  if (lhsMaskType && rhsMaskType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  810:    // Verify mask rank == argument rank.
    #####:  811:    if (lhsMaskType.getShape().size() != lhsType.getShape().size() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  812:        rhsMaskType.getShape().size() != rhsType.getShape().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  813:      return emitOpError("invalid vector mask rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  814:  }
        -:  815:
        -:  816:  // Verify supported combining kind.
 59380645:  817:  auto vectorType = resType.dyn_cast<VectorType>();
call    0 returned 100%
 59380645:  818:  auto elementType = vectorType ? vectorType.getElementType() : resType;
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
call    2 returned 100%
 59380645:  819:  if (!isSupportedCombiningKind(getKind(), elementType))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  820:    return emitOpError("unsupported contraction type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  821:
 59380644:  822:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  823:}
        -:  824:
function _ZN4mlir6vector13ContractionOp17getTraitAttrNamesEv called 0 returned 0% blocks executed 0%
 1931287*:  825:ArrayRef<StringRef> ContractionOp::getTraitAttrNames() {
 1931287*:  826:  static constexpr StringRef names[3] = {::mlir::getIndexingMapsAttrName(),
        -:  827:                                         ::mlir::getIteratorTypesAttrName(),
        -:  828:                                         ContractionOp::getKindAttrStrName()};
 1931287*:  829:  return llvm::makeArrayRef(names);
        -:  830:}
        -:  831:
function _ZL14getResultIndexN4mlir9AffineMapENS_10AffineExprE called 309081071 returned 100% blocks executed 100%
309081071:  832:static int64_t getResultIndex(AffineMap map, AffineExpr targetExpr) {
655127440:  833:  for (int64_t i = 0, e = map.getNumResults(); i < e; ++i)
call    0 returned 100%
branch  1 taken 85% (fallthrough)
branch  2 taken 15%
559967549:  834:    if (targetExpr == map.getResult(i))
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
213921182:  835:      return i;
        -:  836:  return -1;
        -:  837:}
        -:  838:
        -:  839:static std::vector<std::pair<int64_t, int64_t>>
function _ZL9getDimMapN4llvm8ArrayRefIN4mlir9AffineMapEEENS1_9ArrayAttrENS1_6vector12IteratorTypeEPNS1_11MLIRContextE called 118761287 returned 100% blocks executed 90%
118761287:  840:getDimMap(ArrayRef<AffineMap> indexingMaps, ArrayAttr iteratorTypes,
        -:  841:          IteratorType targetIteratorType, MLIRContext *context) {
118761287:  842:  std::vector<std::pair<int64_t, int64_t>> dimMap;
call    0 returned 100%
546603646:  843:  for (const auto &it : llvm::enumerate(iteratorTypes)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 72% (fallthrough)
branch  3 taken 28%
call    4 returned 100%
309081066:  844:    auto iteratorType = it.value().cast<IteratorTypeAttr>().getValue();
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
309081068:  845:    if (iteratorType != targetIteratorType)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
154540535:  846:      continue;
        -:  847:    // Search lhs/rhs map results for 'targetExpr'.
154540533:  848:    auto targetExpr = getAffineDimExpr(it.index(), context);
call    0 returned 100%
154540537:  849:    int64_t lhsDim = getResultIndex(indexingMaps[0], targetExpr);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
154540537:  850:    int64_t rhsDim = getResultIndex(indexingMaps[1], targetExpr);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
154540537:  851:    if (lhsDim >= 0 && rhsDim >= 0)
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
branch  2 taken 56% (fallthrough)
branch  3 taken 44%
 59380645:  852:      dimMap.emplace_back(lhsDim, rhsDim);
call    0 returned 100%
        -:  853:  }
118761289:  854:  return dimMap;
        -:  855:}
        -:  856:
function _ZN4mlir6vector13ContractionOp18getIterationBoundsERN4llvm15SmallVectorImplIlEE called 0 returned 0% blocks executed 0%
    #####:  857:void ContractionOp::getIterationBounds(
        -:  858:    SmallVectorImpl<int64_t> &iterationBounds) {
    #####:  859:  auto lhsShape = getLhsType().getShape();
call    0 never executed
call    1 never executed
    #####:  860:  auto resVectorType = getResultType().dyn_cast<VectorType>();
call    0 never executed
    #####:  861:  SmallVector<AffineMap, 4> indexingMaps(getIndexingMapsArray());
call    0 never executed
    #####:  862:  SmallVector<int64_t, 2> iterationShape;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  863:  for (const auto &it : llvm::enumerate(getIteratorTypes())) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  864:    // Search lhs/rhs map results for 'targetExpr'.
    #####:  865:    auto targetExpr = getAffineDimExpr(it.index(), getContext());
call    0 never executed
call    1 never executed
    #####:  866:    auto iteratorType = it.value().cast<IteratorTypeAttr>().getValue();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  867:    if (iteratorType == IteratorType::reduction) {
branch  0 never executed
branch  1 never executed
        -:  868:      // Get reduction dim size from lhs shape (same size in rhsShape).
    #####:  869:      int64_t lhsDimIndex = getResultIndex(indexingMaps[0], targetExpr);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  870:      assert(lhsDimIndex >= 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  871:      iterationBounds.push_back(lhsShape[lhsDimIndex]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  872:      continue;
        -:  873:    }
        -:  874:    // Get parallel dimension size from result shape.
    #####:  875:    int64_t resDimIndex = getResultIndex(indexingMaps[2], targetExpr);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  876:    assert(resDimIndex >= 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  877:    assert(resVectorType != nullptr);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  878:    iterationBounds.push_back(resVectorType.getShape()[resDimIndex]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  879:  }
    #####:  880:}
        -:  881:
function _ZN4mlir6vector13ContractionOp20getIterationIndexMapERSt6vectorIN4llvm8DenseMapIllNS3_12DenseMapInfoIlvEENS3_6detail12DenseMapPairIllEEEESaISA_EE called 0 returned 0% blocks executed 0%
    #####:  882:void ContractionOp::getIterationIndexMap(
        -:  883:    std::vector<DenseMap<int64_t, int64_t>> &iterationIndexMap) {
    #####:  884:  unsigned numMaps = getIndexingMapsArray().size();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  885:  iterationIndexMap.resize(numMaps);
call    0 never executed
    #####:  886:  for (const auto &it : llvm::enumerate(getIndexingMapsArray())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  887:    auto index = it.index();
call    0 never executed
    #####:  888:    auto map = it.value();
call    0 never executed
    #####:  889:    for (unsigned i = 0, e = map.getNumResults(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  890:      auto dim = map.getResult(i).cast<AffineDimExpr>();
call    0 never executed
call    1 never executed
    #####:  891:      iterationIndexMap[index][dim.getPosition()] = i;
call    0 never executed
call    1 never executed
        -:  892:    }
        -:  893:  }
    #####:  894:}
        -:  895:
function _ZN4mlir6vector13ContractionOp20getContractingDimMapEv called 59380645 returned 100% blocks executed 86%
 59380645:  896:std::vector<std::pair<int64_t, int64_t>> ContractionOp::getContractingDimMap() {
 59380645:  897:  SmallVector<AffineMap, 4> indexingMaps(getIndexingMapsArray());
call    0 returned 100%
 59380645:  898:  return getDimMap(indexingMaps, getIteratorTypes(), IteratorType::reduction,
 59380645:  899:                   getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  900:}
        -:  901:
function _ZN4mlir6vector13ContractionOp14getBatchDimMapEv called 59380645 returned 100% blocks executed 86%
 59380645:  902:std::vector<std::pair<int64_t, int64_t>> ContractionOp::getBatchDimMap() {
 59380645:  903:  SmallVector<AffineMap, 4> indexingMaps(getIndexingMapsArray());
call    0 returned 100%
 59380644:  904:  return getDimMap(indexingMaps, getIteratorTypes(), IteratorType::parallel,
 59380644:  905:                   getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  906:}
        -:  907:
function _ZN4mlir6vector13ContractionOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####:  908:Optional<SmallVector<int64_t, 4>> ContractionOp::getShapeForUnroll() {
    #####:  909:  SmallVector<int64_t, 4> shape;
call    0 never executed
    #####:  910:  getIterationBounds(shape);
call    0 never executed
    #####:  911:  return shape;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  912:}
        -:  913:
        -:  914:/// Return a fused vector::ContractionOp which represents a patterns such as:
        -:  915:///
        -:  916:/// ```mlir
        -:  917:///    %c0 = vector.constant 0: ...
        -:  918:///    %c = vector.contract %a, %b, %c0: ...
        -:  919:///    %e = add %c, %d: ...
        -:  920:/// ```
        -:  921:///
        -:  922:/// by:
        -:  923:///
        -:  924:/// ```mlir
        -:  925:///    %e = vector.contract %a, %b, %d: ...
        -:  926:/// ```
        -:  927:///
        -:  928:/// Return null if the canonicalization does not apply.
        -:  929:// TODO: This should be a folding of Add into Contract in core but while they
        -:  930:// live in different dialects, it is not possible without unnatural
        -:  931:// dependencies.
        -:  932:template <typename AddOpType>
        -:  933:struct CanonicalizeContractAdd : public OpRewritePattern<AddOpType> {
        -:  934:  using OpRewritePattern<AddOpType>::OpRewritePattern;
        -:  935:
      903:  936:  LogicalResult matchAndRewrite(AddOpType addOp,
        -:  937:                                PatternRewriter &rewriter) const override {
    2709*:  938:    auto canonicalize = [&](Value maybeContraction,
        -:  939:                            Value otherOperand) -> vector::ContractionOp {
        -:  940:      vector::ContractionOp contractionOp =
     2782:  941:          dyn_cast_or_null<vector::ContractionOp>(
call    0 returned 100%
branch  1 taken 55% (fallthrough)
branch  2 taken 45%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 53% (fallthrough)
branch  7 taken 47%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
        -:  942:              maybeContraction.getDefiningOp());
     1806:  943:      if (!contractionOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1806:  944:        return vector::ContractionOp();
    #####:  945:      if (auto maybeZero = dyn_cast_or_null<arith::ConstantOp>(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  946:              contractionOp.getAcc().getDefiningOp())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  947:        if (maybeZero.getValue() ==
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  948:            rewriter.getZeroAttr(contractionOp.getAcc().getType())) {
call    0 never executed
call    1 never executed
    #####:  949:          BlockAndValueMapping bvm;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  950:          bvm.map(contractionOp.getAcc(), otherOperand);
call    0 never executed
call    1 never executed
        -:  951:          auto newContraction =
    #####:  952:              cast<vector::ContractionOp>(rewriter.clone(*contractionOp, bvm));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  953:          rewriter.replaceOp(addOp, newContraction.getResult());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  954:          return newContraction;
call    0 never executed
call    1 never executed
        -:  955:        }
        -:  956:      }
    #####:  957:      return vector::ContractionOp();
        -:  958:    };
        -:  959:
      903:  960:    Value a = addOp->getOperand(0), b = addOp->getOperand(1);
      903:  961:    vector::ContractionOp contract = canonicalize(a, b);
      903:  962:    contract = contract ? contract : canonicalize(b, a);
      903:  963:    return contract ? success() : failure();
        -:  964:  }
------------------
_ZNK23CanonicalizeContractAddIN4mlir5arith6AddIOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE:
function _ZNK23CanonicalizeContractAddIN4mlir5arith6AddIOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE called 561 returned 100% blocks executed 90%
      561:  936:  LogicalResult matchAndRewrite(AddOpType addOp,
        -:  937:                                PatternRewriter &rewriter) const override {
      561:  938:    auto canonicalize = [&](Value maybeContraction,
        -:  939:                            Value otherOperand) -> vector::ContractionOp {
        -:  940:      vector::ContractionOp contractionOp =
        -:  941:          dyn_cast_or_null<vector::ContractionOp>(
        -:  942:              maybeContraction.getDefiningOp());
        -:  943:      if (!contractionOp)
        -:  944:        return vector::ContractionOp();
        -:  945:      if (auto maybeZero = dyn_cast_or_null<arith::ConstantOp>(
        -:  946:              contractionOp.getAcc().getDefiningOp())) {
        -:  947:        if (maybeZero.getValue() ==
        -:  948:            rewriter.getZeroAttr(contractionOp.getAcc().getType())) {
        -:  949:          BlockAndValueMapping bvm;
        -:  950:          bvm.map(contractionOp.getAcc(), otherOperand);
        -:  951:          auto newContraction =
        -:  952:              cast<vector::ContractionOp>(rewriter.clone(*contractionOp, bvm));
        -:  953:          rewriter.replaceOp(addOp, newContraction.getResult());
        -:  954:          return newContraction;
        -:  955:        }
        -:  956:      }
        -:  957:      return vector::ContractionOp();
        -:  958:    };
        -:  959:
      561:  960:    Value a = addOp->getOperand(0), b = addOp->getOperand(1);
call    0 returned 100%
call    1 returned 100%
      561:  961:    vector::ContractionOp contract = canonicalize(a, b);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      561:  962:    contract = contract ? contract : canonicalize(b, a);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
      561:  963:    return contract ? success() : failure();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  964:  }
------------------
_ZNK23CanonicalizeContractAddIN4mlir5arith6AddFOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE:
function _ZNK23CanonicalizeContractAddIN4mlir5arith6AddFOpEE15matchAndRewriteES2_RNS0_15PatternRewriterE called 342 returned 100% blocks executed 90%
      342:  936:  LogicalResult matchAndRewrite(AddOpType addOp,
        -:  937:                                PatternRewriter &rewriter) const override {
      342:  938:    auto canonicalize = [&](Value maybeContraction,
        -:  939:                            Value otherOperand) -> vector::ContractionOp {
        -:  940:      vector::ContractionOp contractionOp =
        -:  941:          dyn_cast_or_null<vector::ContractionOp>(
        -:  942:              maybeContraction.getDefiningOp());
        -:  943:      if (!contractionOp)
        -:  944:        return vector::ContractionOp();
        -:  945:      if (auto maybeZero = dyn_cast_or_null<arith::ConstantOp>(
        -:  946:              contractionOp.getAcc().getDefiningOp())) {
        -:  947:        if (maybeZero.getValue() ==
        -:  948:            rewriter.getZeroAttr(contractionOp.getAcc().getType())) {
        -:  949:          BlockAndValueMapping bvm;
        -:  950:          bvm.map(contractionOp.getAcc(), otherOperand);
        -:  951:          auto newContraction =
        -:  952:              cast<vector::ContractionOp>(rewriter.clone(*contractionOp, bvm));
        -:  953:          rewriter.replaceOp(addOp, newContraction.getResult());
        -:  954:          return newContraction;
        -:  955:        }
        -:  956:      }
        -:  957:      return vector::ContractionOp();
        -:  958:    };
        -:  959:
      342:  960:    Value a = addOp->getOperand(0), b = addOp->getOperand(1);
call    0 returned 100%
call    1 returned 100%
      342:  961:    vector::ContractionOp contract = canonicalize(a, b);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      342:  962:    contract = contract ? contract : canonicalize(b, a);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
      342:  963:    return contract ? success() : failure();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  964:  }
------------------
        -:  965:};
        -:  966:
function _ZN4mlir6vector13ContractionOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  967:void ContractionOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  968:                                                MLIRContext *context) {
     1235:  969:  results.add<CanonicalizeContractAdd<arith::AddIOp>,
     1235:  970:              CanonicalizeContractAdd<arith::AddFOp>>(context);
call    0 returned 100%
     1235:  971:}
        -:  972:
        -:  973://===----------------------------------------------------------------------===//
        -:  974:// ExtractElementOp
        -:  975://===----------------------------------------------------------------------===//
        -:  976:
function _ZN4mlir6vector16ExtractElementOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueE called 2645 returned 100% blocks executed 100%
     2645:  977:void vector::ExtractElementOp::build(OpBuilder &builder, OperationState &result,
        -:  978:                                     Value source) {
     2645:  979:  result.addOperands({source});
call    0 returned 100%
call    1 returned 100%
     2645:  980:  result.addTypes(source.getType().cast<VectorType>().getElementType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2645:  981:}
        -:  982:
function _ZN4mlir6vector16ExtractElementOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_ called 484 returned 100% blocks executed 100%
      484:  983:void vector::ExtractElementOp::build(OpBuilder &builder, OperationState &result,
        -:  984:                                     Value source, Value position) {
      484:  985:  result.addOperands({source, position});
call    0 returned 100%
call    1 returned 100%
      484:  986:  result.addTypes(source.getType().cast<VectorType>().getElementType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      484:  987:}
        -:  988:
function _ZN4mlir6vector16ExtractElementOp6verifyEv called 10105 returned 100% blocks executed 44%
    10105:  989:LogicalResult vector::ExtractElementOp::verify() {
    10105:  990:  VectorType vectorType = getVectorType();
call    0 returned 100%
    10105:  991:  if (vectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
     7556:  992:    if (getPosition())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  993:      return emitOpError("expected position to be empty with 0-D vector");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     7556:  994:    return success();
        -:  995:  }
     2549:  996:  if (vectorType.getRank() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  997:    return emitOpError("unexpected >1 vector rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     2549:  998:  if (!getPosition())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  999:    return emitOpError("expected position for 1-D vector");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     2549: 1000:  return success();
        -: 1001:}
        -: 1002:
function _ZN4mlir6vector16ExtractElementOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 8006 returned 100% blocks executed 58%
     8006: 1003:OpFoldResult vector::ExtractElementOp::fold(ArrayRef<Attribute> operands) {
        -: 1004:  // Skip the 0-D vector here now.
     8006: 1005:  if (operands.size() < 2)
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
     6517: 1006:    return {};
        -: 1007:
     1489: 1008:  Attribute src = operands[0];
call    0 returned 100%
     1489: 1009:  Attribute pos = operands[1];
        -: 1010:
        -: 1011:  // Fold extractelement (splat X) -> X.
     1489: 1012:  if (auto splat = getVector().getDefiningOp<vector::SplatOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        1: 1013:    return splat.getInput();
call    0 returned 100%
call    1 returned 100%
        -: 1014:
    1488*: 1015:  if (!pos || !src)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
     1488: 1016:    return {};
        -: 1017:
    #####: 1018:  auto srcElements = src.cast<DenseElementsAttr>().getValues<Attribute>();
call    0 never executed
call    1 never executed
        -: 1019:
    #####: 1020:  auto attr = pos.dyn_cast<IntegerAttr>();
call    0 never executed
    #####: 1021:  uint64_t posIdx = attr.getInt();
call    0 never executed
        -: 1022:
    #####: 1023:  return srcElements[posIdx];
call    0 never executed
call    1 never executed
        -: 1024:}
        -: 1025:
        -: 1026://===----------------------------------------------------------------------===//
        -: 1027:// ExtractOp
        -: 1028://===----------------------------------------------------------------------===//
        -: 1029:
function _ZN4mlir6vector9ExtractOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEE called 393652 returned 100% blocks executed 100%
   393652: 1030:void vector::ExtractOp::build(OpBuilder &builder, OperationState &result,
        -: 1031:                              Value source, ArrayRef<int64_t> position) {
   393652: 1032:  build(builder, result, source, getVectorSubscriptAttr(builder, position));
call    0 returned 100%
call    1 returned 100%
   393652: 1033:}
        -: 1034:
        -: 1035:// Convenience builder which assumes the values are constant indices.
function _ZN4mlir6vector9ExtractOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1036:void vector::ExtractOp::build(OpBuilder &builder, OperationState &result,
        -: 1037:                              Value source, ValueRange position) {
    #####: 1038:  SmallVector<int64_t, 4> positionConstants =
    #####: 1039:      llvm::to_vector<4>(llvm::map_range(position, [](Value pos) {
        -: 1040:        return pos.getDefiningOp<arith::ConstantIndexOp>().value();
    #####: 1041:      }));
call    0 never executed
    #####: 1042:  build(builder, result, source, positionConstants);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1043:}
        -: 1044:
        -: 1045:LogicalResult
function _ZN4mlir6vector9ExtractOp16inferReturnTypesEPNS_11MLIRContextEN4llvm8OptionalINS_8LocationEEENS_10ValueRangeENS_14DictionaryAttrENS_11RegionRangeERNS4_15SmallVectorImplINS_4TypeEEE called 54357148 returned 100% blocks executed 95%
 54357148: 1046:ExtractOp::inferReturnTypes(MLIRContext *, Optional<Location>,
        -: 1047:                            ValueRange operands, DictionaryAttr attributes,
        -: 1048:                            RegionRange,
        -: 1049:                            SmallVectorImpl<Type> &inferredReturnTypes) {
 54357148: 1050:  ExtractOp::Adaptor op(operands, attributes);
call    0 returned 100%
call    1 returned 100%
 54357149: 1051:  auto vectorType = op.getVector().getType().cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
 54357149: 1052:  if (static_cast<int64_t>(op.getPosition().size()) == vectorType.getRank()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 47% (fallthrough)
branch  4 taken 53%
 25537857: 1053:    inferredReturnTypes.push_back(vectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
        -: 1054:  } else {
 28819291: 1055:    auto n =
call    0 returned 100%
 28819291: 1056:        std::min<size_t>(op.getPosition().size(), vectorType.getRank() - 1);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
 28819291: 1057:    inferredReturnTypes.push_back(VectorType::get(
call    0 returned 100%
 57638582: 1058:        vectorType.getShape().drop_front(n), vectorType.getElementType()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 1059:  }
 54357148: 1060:  return success();
        -: 1061:}
        -: 1062:
function _ZN4mlir6vector9ExtractOp23isCompatibleReturnTypesENS_9TypeRangeES2_ called 52589843 returned 100% blocks executed 89%
 52589843: 1063:bool ExtractOp::isCompatibleReturnTypes(TypeRange l, TypeRange r) {
        -: 1064:  // Allow extracting 1-element vectors instead of scalars.
function _ZZN4mlir6vector9ExtractOp23isCompatibleReturnTypesENS_9TypeRangeES2_ENKUlS2_S2_E_clES2_S2_.isra.0 called 105179687 returned 100% blocks executed 100%
157769530: 1065:  auto isCompatible = [](TypeRange l, TypeRange r) {
105179687: 1066:    auto vectorType = l.front().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
106146179: 1067:    return vectorType && vectorType.getShape().equals({1}) &&
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
call    2 returned 100%
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
   966492: 1068:           vectorType.getElementType() == r.front();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1069:  };
105179687: 1070:  if (l.size() == 1 && r.size() == 1 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
105179687: 1071:      (isCompatible(l, r) || isCompatible(r, l)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1072:    return true;
 52589843: 1073:  return l == r;
call    0 returned 100%
        -: 1074:}
        -: 1075:
function _ZN4mlir6vector9ExtractOp6verifyEv called 52589844 returned 100% blocks executed 60%
 52589844: 1076:LogicalResult vector::ExtractOp::verify() {
 52589844: 1077:  auto positionAttr = getPosition().getValue();
call    0 returned 100%
call    1 returned 100%
 52589843: 1078:  if (positionAttr.size() > static_cast<unsigned>(getVectorType().getRank()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1079:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1080:        "expected position attribute of rank smaller than vector rank");
call    0 never executed
109676406: 1081:  for (const auto &en : llvm::enumerate(positionAttr)) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
 57086562: 1082:    auto attr = en.value().dyn_cast<IntegerAttr>();
call    0 returned 100%
114173125: 1083:    if (!attr || attr.getInt() < 0 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
114173126*: 1084:        attr.getInt() >= getVectorType().getDimSize(en.index()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    #####: 1085:      return emitOpError("expected position attribute #")
call    0 never executed
call    1 never executed
    #####: 1086:             << (en.index() + 1)
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1087:             << " to be a non-negative integer smaller than the corresponding "
    #####: 1088:                "vector dimension";
call    0 never executed
        -: 1089:  }
 52589844: 1090:  return success();
        -: 1091:}
        -: 1092:
        -: 1093:template <typename IntType>
  987660*: 1094:static SmallVector<IntType> extractVector(ArrayAttr arrayAttr) {
  987660*: 1095:  return llvm::to_vector<4>(llvm::map_range(
  987660*: 1096:      arrayAttr.getAsRange<IntegerAttr>(),
 2979877*: 1097:      [](IntegerAttr attr) { return static_cast<IntType>(attr.getInt()); }));
call    0 never executed
call    1 returned 100%
        -: 1098:}
------------------
_Z13extractVectorIjEN4llvm11SmallVectorIT_XsrNS0_42CalculateSmallVectorDefaultInlinedElementsIS2_EE5valueEEEN4mlir9ArrayAttrE:
function _Z13extractVectorIjEN4llvm11SmallVectorIT_XsrNS0_42CalculateSmallVectorDefaultInlinedElementsIS2_EE5valueEEEN4mlir9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####: 1094:static SmallVector<IntType> extractVector(ArrayAttr arrayAttr) {
    #####: 1095:  return llvm::to_vector<4>(llvm::map_range(
call    0 never executed
    #####: 1096:      arrayAttr.getAsRange<IntegerAttr>(),
call    0 never executed
    #####: 1097:      [](IntegerAttr attr) { return static_cast<IntType>(attr.getInt()); }));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1098:}
------------------
_Z13extractVectorIlEN4llvm11SmallVectorIT_XsrNS0_42CalculateSmallVectorDefaultInlinedElementsIS2_EE5valueEEEN4mlir9ArrayAttrE:
function _Z13extractVectorIlEN4llvm11SmallVectorIT_XsrNS0_42CalculateSmallVectorDefaultInlinedElementsIS2_EE5valueEEEN4mlir9ArrayAttrE called 987660 returned 100% blocks executed 86%
   987660: 1094:static SmallVector<IntType> extractVector(ArrayAttr arrayAttr) {
   987660: 1095:  return llvm::to_vector<4>(llvm::map_range(
call    0 returned 100%
   987660: 1096:      arrayAttr.getAsRange<IntegerAttr>(),
call    0 returned 100%
  1975320: 1097:      [](IntegerAttr attr) { return static_cast<IntType>(attr.getInt()); }));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1098:}
------------------
        -: 1099:
        -: 1100:/// Fold the result of chains of ExtractOp in place by simply concatenating the
        -: 1101:/// positions.
function _ZL29foldExtractOpFromExtractChainN4mlir6vector9ExtractOpE called 661618 returned 100% blocks executed 91%
   661618: 1102:static LogicalResult foldExtractOpFromExtractChain(ExtractOp extractOp) {
   661618: 1103:  if (!extractOp.getVector().getDefiningOp<ExtractOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 55% (fallthrough)
branch  3 taken 45%
   363515: 1104:    return failure();
        -: 1105:
   298103: 1106:  SmallVector<int64_t, 4> globalPosition;
call    0 returned 100%
   298103: 1107:  ExtractOp currentOp = extractOp;
   596206: 1108:  auto extrPos = extractVector<int64_t>(currentOp.getPosition());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   298103: 1109:  globalPosition.append(extrPos.rbegin(), extrPos.rend());
call    0 returned 100%
   596206: 1110:  while (ExtractOp nextOp = currentOp.getVector().getDefiningOp<ExtractOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
   298103: 1111:    currentOp = nextOp;
   298103: 1112:    auto extrPos = extractVector<int64_t>(currentOp.getPosition());
call    0 returned 100%
call    1 returned 100%
   298103: 1113:    globalPosition.append(extrPos.rbegin(), extrPos.rend());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   298103: 1114:  }
   298103: 1115:  extractOp.setOperand(currentOp.getVector());
call    0 returned 100%
call    1 returned 100%
        -: 1116:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
   298103: 1117:  OpBuilder b(extractOp.getContext());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   298103: 1118:  std::reverse(globalPosition.begin(), globalPosition.end());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   298103: 1119:  extractOp->setAttr(ExtractOp::getPositionAttrStrName(),
call    0 returned 100%
call    1 returned 100%
   298103: 1120:                     b.getI64ArrayAttr(globalPosition));
call    0 returned 100%
   298103: 1121:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1122:}
        -: 1123:
        -: 1124:namespace {
        -: 1125:/// Fold an ExtractOp that is fed by a chain of InsertOps and TransposeOps.
        -: 1126:/// Walk back a chain of InsertOp/TransposeOp until we hit a match.
        -: 1127:/// Compose TransposeOp permutations as we walk back.
        -: 1128:/// This helper class keeps an updated extraction position `extractPosition`
        -: 1129:/// with extra trailing sentinels.
        -: 1130:/// The sentinels encode the internal transposition status of the result vector.
        -: 1131:/// As we iterate, extractPosition is permuted and updated.
        -: 1132:class ExtractFromInsertTransposeChainState {
        -: 1133:public:
        -: 1134:  ExtractFromInsertTransposeChainState(ExtractOp e);
        -: 1135:
        -: 1136:  /// Iterate over producing insert and transpose ops until we find a fold.
        -: 1137:  Value fold();
        -: 1138:
        -: 1139:private:
        -: 1140:  /// Return true if the vector at position `a` is contained within the vector
        -: 1141:  /// at position `b`. Under insert/extract semantics, this is the same as `a`
        -: 1142:  /// is a prefix of `b`.
        -: 1143:  template <typename ContainerA, typename ContainerB>
        -: 1144:  bool isContainedWithin(const ContainerA &a, const ContainerB &b) {
        -: 1145:    return a.size() <= b.size() &&
        -: 1146:           std::equal(a.begin(), a.begin() + a.size(), b.begin());
        -: 1147:  }
        -: 1148:
        -: 1149:  /// Return true if the vector at position `a` intersects the vector at
        -: 1150:  /// position `b`. Under insert/extract semantics, this is the same as equality
        -: 1151:  /// of all entries of `a` that are >=0 with the corresponding entries of b.
        -: 1152:  /// Comparison is on the common prefix (i.e. zip).
        -: 1153:  template <typename ContainerA, typename ContainerB>
        -: 1154:  bool intersectsWhereNonNegative(const ContainerA &a, const ContainerB &b) {
        -: 1155:    for (auto it : llvm::zip(a, b)) {
        -: 1156:      if (std::get<0>(it) < 0 || std::get<0>(it) < 0)
        -: 1157:        continue;
        -: 1158:      if (std::get<0>(it) != std::get<1>(it))
        -: 1159:        return false;
        -: 1160:    }
        -: 1161:    return true;
        -: 1162:  }
        -: 1163:
        -: 1164:  /// Folding is only possible in the absence of an internal permutation in the
        -: 1165:  /// result vector.
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState7canFoldEv called 2 returned 100% blocks executed 100%
        2: 1166:  bool canFold() {
        4: 1167:    return (sentinels ==
        2: 1168:            makeArrayRef(extractPosition).drop_front(extractedRank));
call    0 returned 100%
        -: 1169:  }
        -: 1170:
        -: 1171:  // Helper to get the next defining op of interest.
  363806*: 1172:  void updateStateForNextIteration(Value v) {
  363806*: 1173:    nextInsertOp = v.getDefiningOp<vector::InsertOp>();
  363806*: 1174:    nextTransposeOp = v.getDefiningOp<vector::TransposeOp>();
call    0 returned 100%
call    1 never executed
call    2 returned 100%
        -: 1175:  };
        -: 1176:
        -: 1177:  // Case 1. If we hit a transpose, just compose the map and iterate.
        -: 1178:  // Invariant: insert + transpose do not change rank, we can always compose.
        -: 1179:  LogicalResult handleTransposeOp();
        -: 1180:
        -: 1181:  // Case 2: the insert position matches extractPosition exactly, early return.
        -: 1182:  LogicalResult handleInsertOpWithMatchingPos(Value &res);
        -: 1183:
        -: 1184:  /// Case 3: if the insert position is a prefix of extractPosition, extract a
        -: 1185:  /// portion of the source of the insert.
        -: 1186:  /// Example:
        -: 1187:  /// ```
        -: 1188:  /// %ins = vector.insert %source, %vest[1]: vector<3x4> into vector<2x3x4x5>
        -: 1189:  /// // extractPosition == [1, 2, 3]
        -: 1190:  /// %ext = vector.extract %ins[1, 0]: vector<3x4x5>
        -: 1191:  /// // can fold to vector.extract %source[0, 3]
        -: 1192:  /// %ext = vector.extract %source[3]: vector<5x6>
        -: 1193:  /// ```
        -: 1194:  /// To traverse through %source, we need to set the leading dims to 0 and
        -: 1195:  /// drop the extra leading dims.
        -: 1196:  /// This method updates the internal state.
        -: 1197:  LogicalResult handleInsertOpWithPrefixPos(Value &res);
        -: 1198:
        -: 1199:  /// Try to fold in place to extract(source, extractPosition) and return the
        -: 1200:  /// folded result. Return null if folding is not possible (e.g. due to an
        -: 1201:  /// internal tranposition in the result).
        -: 1202:  Value tryToFoldExtractOpInPlace(Value source);
        -: 1203:
        -: 1204:  ExtractOp extractOp;
        -: 1205:  int64_t vectorRank;
        -: 1206:  int64_t extractedRank;
        -: 1207:
        -: 1208:  InsertOp nextInsertOp;
        -: 1209:  TransposeOp nextTransposeOp;
        -: 1210:
        -: 1211:  /// Sentinel values that encode the internal permutation status of the result.
        -: 1212:  /// They are set to (-1, ... , -k) at the beginning and appended to
        -: 1213:  /// `extractPosition`.
        -: 1214:  /// In the end, the tail of `extractPosition` must be exactly `sentinels` to
        -: 1215:  /// ensure that there is no internal transposition.
        -: 1216:  /// Internal transposition cannot be accounted for with a folding pattern.
        -: 1217:  // TODO: We could relax the internal transposition with an extra transposition
        -: 1218:  // operation in a future canonicalizer.
        -: 1219:  SmallVector<int64_t> sentinels;
        -: 1220:  SmallVector<int64_t> extractPosition;
        -: 1221:};
        -: 1222:} // namespace
        -: 1223:
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainStateC2EN4mlir6vector9ExtractOpE called 363515 returned 100% blocks executed 80%
   363515: 1224:ExtractFromInsertTransposeChainState::ExtractFromInsertTransposeChainState(
   363515: 1225:    ExtractOp e)
   363515: 1226:    : extractOp(e), vectorRank(extractOp.getVectorType().getRank()),
call    0 returned 100%
   727030: 1227:      extractedRank(extractOp.getPosition().size()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  363515*: 1228:  assert(vectorRank >= extractedRank && "extracted pos overflow");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   363515: 1229:  sentinels.reserve(vectorRank - extractedRank);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   674460: 1230:  for (int64_t i = 0, e = vectorRank - extractedRank; i < e; ++i)
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
   310945: 1231:    sentinels.push_back(-(i + 1));
call    0 returned 100%
   363515: 1232:  extractPosition = extractVector<int64_t>(extractOp.getPosition());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   363515: 1233:  llvm::append_range(extractPosition, sentinels);
call    0 returned 100%
   363515: 1234:}
        -: 1235:
        -: 1236:// Case 1. If we hit a transpose, just compose the map and iterate.
        -: 1237:// Invariant: insert + transpose do not change rank, we can always compose.
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState17handleTransposeOpEv called 359 returned 100% blocks executed 20%
      359: 1238:LogicalResult ExtractFromInsertTransposeChainState::handleTransposeOp() {
      359: 1239:  if (!nextTransposeOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      359: 1240:    return failure();
    #####: 1241:  auto permutation = extractVector<unsigned>(nextTransposeOp.getTransp());
call    0 never executed
call    1 never executed
    #####: 1242:  AffineMap m = inversePermutation(
    #####: 1243:      AffineMap::getPermutationMap(permutation, extractOp.getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1244:  extractPosition = applyPermutationMap(m, makeArrayRef(extractPosition));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1245:  return success();
branch  0 never executed
branch  1 never executed
        -: 1246:}
        -: 1247:
        -: 1248:// Case 2: the insert position matches extractPosition exactly, early return.
        -: 1249:LogicalResult
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState29handleInsertOpWithMatchingPosERN4mlir5ValueE called 359 returned 100% blocks executed 83%
      359: 1250:ExtractFromInsertTransposeChainState::handleInsertOpWithMatchingPos(
        -: 1251:    Value &res) {
      359: 1252:  auto insertedPos = extractVector<int64_t>(nextInsertOp.getPosition());
call    0 returned 100%
call    1 returned 100%
      359: 1253:  if (makeArrayRef(insertedPos) !=
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
      718: 1254:      llvm::makeArrayRef(extractPosition).take_front(extractedRank))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
      293: 1255:    return failure();
        -: 1256:  // Case 2.a. early-exit fold.
       66: 1257:  res = nextInsertOp.getSource();
call    0 returned 100%
        -: 1258:  // Case 2.b. if internal transposition is present, canFold will be false.
      359: 1259:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1260:}
        -: 1261:
        -: 1262:/// Case 3: if inserted position is a prefix of extractPosition,
        -: 1263:/// extract a portion of the source of the insertion.
        -: 1264:/// This method updates the internal state.
        -: 1265:LogicalResult
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState27handleInsertOpWithPrefixPosERN4mlir5ValueE called 293 returned 100% blocks executed 92%
      293: 1266:ExtractFromInsertTransposeChainState::handleInsertOpWithPrefixPos(Value &res) {
      293: 1267:  auto insertedPos = extractVector<int64_t>(nextInsertOp.getPosition());
call    0 returned 100%
call    1 returned 100%
      293: 1268:  if (!isContainedWithin(insertedPos, extractPosition))
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      291: 1269:    return failure();
        -: 1270:  // Set leading dims to zero.
        2: 1271:  std::fill_n(extractPosition.begin(), insertedPos.size(), 0);
        -: 1272:  // Drop extra leading dims.
        2: 1273:  extractPosition.erase(extractPosition.begin(),
        2: 1274:                        extractPosition.begin() + insertedPos.size());
call    0 returned 100%
        2: 1275:  extractedRank = extractPosition.size() - sentinels.size();
call    0 returned 100%
        -: 1276:  // Case 3.a. early-exit fold (break and delegate to post-while path).
        2: 1277:  res = nextInsertOp.getSource();
call    0 returned 100%
        -: 1278:  // Case 3.b. if internal transposition is present, canFold will be false.
      293: 1279:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1280:}
        -: 1281:
        -: 1282:/// Try to fold in place to extract(source, extractPosition) and return the
        -: 1283:/// folded result. Return null if folding is not possible (e.g. due to an
        -: 1284:/// internal tranposition in the result).
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState25tryToFoldExtractOpInPlaceEN4mlir5ValueE called 363449 returned 100% blocks executed 89%
   363449: 1285:Value ExtractFromInsertTransposeChainState::tryToFoldExtractOpInPlace(
        -: 1286:    Value source) {
        -: 1287:  // If we can't fold (either internal transposition, or nothing to fold), bail.
   363449: 1288:  bool nothingToFold = (source == extractOp.getVector());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
   363449: 1289:  if (nothingToFold || !canFold())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
   363447: 1290:    return Value();
        -: 1291:  // Otherwise, fold by updating the op inplace and return its result.
        2: 1292:  OpBuilder b(extractOp.getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        4: 1293:  extractOp->setAttr(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -: 1294:      extractOp.getPositionAttrName(),
        2: 1295:      b.getI64ArrayAttr(
        4: 1296:          makeArrayRef(extractPosition).take_front(extractedRank)));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        2: 1297:  extractOp.getVectorMutable().assign(source);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 1298:  return extractOp.getResult();
        -: 1299:}
        -: 1300:
        -: 1301:/// Iterate over producing insert and transpose ops until we find a fold.
function _ZN12_GLOBAL__N_136ExtractFromInsertTransposeChainState4foldEv called 363515 returned 100% blocks executed 78%
   363515: 1302:Value ExtractFromInsertTransposeChainState::fold() {
   363515: 1303:  Value valueToExtractFrom = extractOp.getVector();
call    0 returned 100%
   727030: 1304:  updateStateForNextIteration(valueToExtractFrom);
call    0 returned 100%
   363806: 1305:  while (nextInsertOp || nextTransposeOp) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1306:    // Case 1. If we hit a transpose, just compose the map and iterate.
        -: 1307:    // Invariant: insert + transpose do not change rank, we can always compose.
     359*: 1308:    if (succeeded(handleTransposeOp())) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 1309:      valueToExtractFrom = nextTransposeOp.getVector();
call    0 never executed
    #####: 1310:      updateStateForNextIteration(valueToExtractFrom);
call    0 never executed
    #####: 1311:      continue;
        -: 1312:    }
        -: 1313:
      359: 1314:    Value result;
        -: 1315:    // Case 2: the position match exactly.
      359: 1316:    if (succeeded(handleInsertOpWithMatchingPos(result)))
call    0 returned 100%
branch  1 taken 18% (fallthrough)
branch  2 taken 82%
       68: 1317:      return result;
        -: 1318:
        -: 1319:    // Case 3: if the inserted position is a prefix of extractPosition, we can
        -: 1320:    // just extract a portion of the source of the insert.
      293: 1321:    if (succeeded(handleInsertOpWithPrefixPos(result)))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        2: 1322:      return tryToFoldExtractOpInPlace(result);
call    0 returned 100%
        -: 1323:
        -: 1324:    // Case 4: extractPositionRef intersects insertedPosRef on non-sentinel
        -: 1325:    // values. This is a more difficult case and we bail.
      582: 1326:    auto insertedPos = extractVector<int64_t>(nextInsertOp.getPosition());
call    0 returned 100%
call    1 returned 100%
      582: 1327:    if (isContainedWithin(extractPosition, insertedPos) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      291: 1328:        intersectsWhereNonNegative(extractPosition, insertedPos))
call    0 returned 100%
    #####: 1329:      return Value();
branch  0 never executed
branch  1 never executed
        -: 1330:
        -: 1331:    // Case 5: No intersection, we forward the extract to insertOp.dest().
      291: 1332:    valueToExtractFrom = nextInsertOp.getDest();
call    0 returned 100%
      582: 1333:    updateStateForNextIteration(valueToExtractFrom);
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
        -: 1334:  }
        -: 1335:  // If after all this we can fold, go for it.
   363447: 1336:  return tryToFoldExtractOpInPlace(valueToExtractFrom);
call    0 returned 100%
        -: 1337:}
        -: 1338:
        -: 1339:/// Fold extractOp with scalar result coming from BroadcastOp or SplatOp.
function _ZL24foldExtractFromBroadcastN4mlir6vector9ExtractOpE called 363447 returned 100% blocks executed 33%
   363447: 1340:static Value foldExtractFromBroadcast(ExtractOp extractOp) {
   363447: 1341:  Operation *defOp = extractOp.getVector().getDefiningOp();
call    0 returned 100%
call    1 returned 100%
   363447: 1342:  if (!defOp || !isa<vector::BroadcastOp, SplatOp>(defOp))
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 55% (fallthrough)
branch  4 taken 45%
   200681: 1343:    return Value();
   162766: 1344:  Value source = defOp->getOperand(0);
call    0 returned 100%
   162766: 1345:  if (extractOp.getType() == source.getType())
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
    30217: 1346:    return source;
function _ZZL24foldExtractFromBroadcastN4mlir6vector9ExtractOpEENKUlNS_4TypeEE_clES2_.isra.0 called 265098 returned 100% blocks executed 100%
   397647: 1347:  auto getRank = [](Type type) {
   397647: 1348:    return type.isa<VectorType>() ? type.cast<VectorType>().getRank() : 0;
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
        -: 1349:  };
   132549: 1350:  unsigned broadcastSrcRank = getRank(source.getType());
call    0 returned 100%
   132549: 1351:  unsigned extractResultRank = getRank(extractOp.getType());
call    0 returned 100%
   132549: 1352:  if (extractResultRank >= broadcastSrcRank)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   132549: 1353:    return Value();
        -: 1354:  // Check that the dimension of the result haven't been broadcasted.
    #####: 1355:  auto extractVecType = extractOp.getType().dyn_cast<VectorType>();
call    0 never executed
    #####: 1356:  auto broadcastVecType = source.getType().dyn_cast<VectorType>();
call    0 never executed
    #####: 1357:  if (extractVecType && broadcastVecType &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1358:      extractVecType.getShape() !=
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1359:          broadcastVecType.getShape().take_back(extractResultRank))
call    0 never executed
    #####: 1360:    return Value();
    #####: 1361:  auto extractPos = extractVector<int64_t>(extractOp.getPosition());
call    0 never executed
call    1 never executed
    #####: 1362:  unsigned rankDiff = broadcastSrcRank - extractResultRank;
    #####: 1363:  extractPos.erase(extractPos.begin(),
    #####: 1364:                   std::next(extractPos.begin(), extractPos.size() - rankDiff));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1365:  extractOp.setOperand(source);
call    0 never executed
        -: 1366:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
    #####: 1367:  OpBuilder b(extractOp.getContext());
call    0 never executed
call    1 never executed
    #####: 1368:  extractOp->setAttr(ExtractOp::getPositionAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 1369:                     b.getI64ArrayAttr(extractPos));
call    0 never executed
    #####: 1370:  return extractOp.getResult();
branch  0 never executed
branch  1 never executed
        -: 1371:}
        -: 1372:
        -: 1373:// Fold extractOp with source coming from ShapeCast op.
function _ZL24foldExtractFromShapeCastN4mlir6vector9ExtractOpE called 333230 returned 100% blocks executed 8%
   333230: 1374:static Value foldExtractFromShapeCast(ExtractOp extractOp) {
   333230: 1375:  auto shapeCastOp = extractOp.getVector().getDefiningOp<vector::ShapeCastOp>();
call    0 returned 100%
call    1 returned 100%
   333230: 1376:  if (!shapeCastOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   333230: 1377:    return Value();
        -: 1378:  // Get the nth dimension size starting from lowest dimension.
function _ZZL24foldExtractFromShapeCastN4mlir6vector9ExtractOpEENKUlNS_10VectorTypeElE_clES2_l.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1379:  auto getDimReverse = [](VectorType type, int64_t n) {
    #####: 1380:    return type.getShape().take_back(n + 1).front();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1381:  };
    #####: 1382:  int64_t destinationRank =
call    0 never executed
    #####: 1383:      extractOp.getType().isa<VectorType>()
call    0 never executed
    #####: 1384:          ? extractOp.getType().cast<VectorType>().getRank()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1385:          : 0;
    #####: 1386:  if (destinationRank > shapeCastOp.getSourceVectorType().getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1387:    return Value();
    #####: 1388:  if (destinationRank > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1389:    auto destinationType = extractOp.getResult().getType().cast<VectorType>();
call    0 never executed
    #####: 1390:    for (int64_t i = 0; i < destinationRank; i++) {
branch  0 never executed
branch  1 never executed
        -: 1391:      // The lowest dimension of of the destination must match the lowest
        -: 1392:      // dimension of the shapecast op source.
        -: 1393:      // TODO: This case could be support in a canonicalization pattern.
    #####: 1394:      if (getDimReverse(shapeCastOp.getSourceVectorType(), i) !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1395:          getDimReverse(destinationType, i))
call    0 never executed
    #####: 1396:        return Value();
        -: 1397:    }
        -: 1398:  }
        -: 1399:  // Extract the strides associated with the extract op vector source. Then use
        -: 1400:  // this to calculate a linearized position for the extract.
    #####: 1401:  auto extractedPos = extractVector<int64_t>(extractOp.getPosition());
call    0 never executed
call    1 never executed
    #####: 1402:  std::reverse(extractedPos.begin(), extractedPos.end());
branch  0 never executed
branch  1 never executed
    #####: 1403:  SmallVector<int64_t, 4> strides;
branch  0 never executed
branch  1 never executed
    #####: 1404:  int64_t stride = 1;
    #####: 1405:  for (int64_t i = 0, e = extractedPos.size(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1406:    strides.push_back(stride);
call    0 never executed
    #####: 1407:    stride *= getDimReverse(extractOp.getVectorType(), i + destinationRank);
call    0 never executed
call    1 never executed
        -: 1408:  }
        -: 1409:
    #####: 1410:  int64_t position = linearize(extractedPos, strides);
call    0 never executed
        -: 1411:  // Then extract the strides associated to the shapeCast op vector source and
        -: 1412:  // delinearize the position using those strides.
    #####: 1413:  SmallVector<int64_t, 4> newStrides;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1414:  int64_t numDimension =
    #####: 1415:      shapeCastOp.getSourceVectorType().getRank() - destinationRank;
call    0 never executed
call    1 never executed
    #####: 1416:  stride = 1;
    #####: 1417:  for (int64_t i = 0; i < numDimension; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1418:    newStrides.push_back(stride);
call    0 never executed
    #####: 1419:    stride *=
    #####: 1420:        getDimReverse(shapeCastOp.getSourceVectorType(), i + destinationRank);
call    0 never executed
call    1 never executed
        -: 1421:  }
    #####: 1422:  std::reverse(newStrides.begin(), newStrides.end());
branch  0 never executed
branch  1 never executed
    #####: 1423:  SmallVector<int64_t, 4> newPosition = delinearize(newStrides, position);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1424:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
    #####: 1425:  OpBuilder b(extractOp.getContext());
call    0 never executed
call    1 never executed
    #####: 1426:  extractOp->setAttr(ExtractOp::getPositionAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 1427:                     b.getI64ArrayAttr(newPosition));
call    0 never executed
    #####: 1428:  extractOp.setOperand(shapeCastOp.getSource());
call    0 never executed
call    1 never executed
    #####: 1429:  return extractOp.getResult();
branch  0 never executed
branch  1 never executed
        -: 1430:}
        -: 1431:
        -: 1432:/// Fold an ExtractOp from ExtractStridedSliceOp.
function _ZL29foldExtractFromExtractStridedN4mlir6vector9ExtractOpE called 333230 returned 100% blocks executed 88%
   333230: 1433:static Value foldExtractFromExtractStrided(ExtractOp extractOp) {
   333230: 1434:  auto extractStridedSliceOp =
   333230: 1435:      extractOp.getVector().getDefiningOp<vector::ExtractStridedSliceOp>();
call    0 returned 100%
call    1 returned 100%
   333230: 1436:  if (!extractStridedSliceOp)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
   319709: 1437:    return Value();
        -: 1438:  // Return if 'extractStridedSliceOp' has non-unit strides.
    13521: 1439:  if (extractStridedSliceOp.hasNonUnitStrides())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1440:    return Value();
        -: 1441:
        -: 1442:  // Trim offsets for dimensions fully extracted.
    13521: 1443:  auto sliceOffsets =
call    0 returned 100%
    13521: 1444:      extractVector<int64_t>(extractStridedSliceOp.getOffsets());
call    0 returned 100%
    14571: 1445:  while (!sliceOffsets.empty()) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
    13521: 1446:    size_t lastOffset = sliceOffsets.size() - 1;
call    0 returned 100%
    17154: 1447:    if (sliceOffsets.back() != 0 ||
call    0 returned 100%
branch  1 taken 27% (fallthrough)
branch  2 taken 73%
branch  3 taken 71% (fallthrough)
branch  4 taken 29%
     3633: 1448:        extractStridedSliceOp.getType().getDimSize(lastOffset) !=
call    0 returned 100%
    16104: 1449:            extractStridedSliceOp.getVectorType().getDimSize(lastOffset))
call    0 returned 100%
call    1 returned 100%
        -: 1450:      break;
     1050: 1451:    sliceOffsets.pop_back();
call    0 returned 100%
        -: 1452:  }
    13521: 1453:  unsigned destinationRank = 0;
    13521: 1454:  if (auto vecType = extractOp.getType().dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
     5109: 1455:    destinationRank = vecType.getRank();
call    0 returned 100%
        -: 1456:  // The dimensions of the result need to be untouched by the
        -: 1457:  // extractStridedSlice op.
    13521: 1458:  if (destinationRank >
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    13521: 1459:      extractStridedSliceOp.getVectorType().getRank() - sliceOffsets.size())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
       46: 1460:    return Value();
    26996: 1461:  auto extractedPos = extractVector<int64_t>(extractOp.getPosition());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   13475*: 1462:  assert(extractedPos.size() >= sliceOffsets.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    25900: 1463:  for (size_t i = 0, e = sliceOffsets.size(); i < e; i++)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
    12425: 1464:    extractedPos[i] = extractedPos[i] + sliceOffsets[i];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    13475: 1465:  extractOp.getVectorMutable().assign(extractStridedSliceOp.getVector());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1466:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
    13475: 1467:  OpBuilder b(extractOp.getContext());
call    0 returned 100%
call    1 returned 100%
    13475: 1468:  extractOp->setAttr(ExtractOp::getPositionAttrStrName(),
call    0 returned 100%
call    1 returned 100%
    13475: 1469:                     b.getI64ArrayAttr(extractedPos));
call    0 returned 100%
    13475: 1470:  return extractOp.getResult();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1471:}
        -: 1472:
        -: 1473:/// Fold extract_op fed from a chain of insertStridedSlice ops.
function _ZL35foldExtractStridedOpFromInsertChainN4mlir6vector9ExtractOpE called 319755 returned 100% blocks executed 14%
   319755: 1474:static Value foldExtractStridedOpFromInsertChain(ExtractOp op) {
   319755: 1475:  int64_t destinationRank = op.getType().isa<VectorType>()
call    0 returned 100%
   319755: 1476:                                ? op.getType().cast<VectorType>().getRank()
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
call    2 returned 100%
call    3 returned 100%
   319755: 1477:                                : 0;
   319755: 1478:  auto insertOp = op.getVector().getDefiningOp<InsertStridedSliceOp>();
call    0 returned 100%
call    1 returned 100%
   319755: 1479:  while (insertOp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1480:    int64_t insertRankDiff = insertOp.getDestVectorType().getRank() -
call    0 never executed
call    1 never executed
    #####: 1481:                             insertOp.getSourceVectorType().getRank();
call    0 never executed
call    1 never executed
    #####: 1482:    if (destinationRank > insertOp.getSourceVectorType().getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1483:      return Value();
    #####: 1484:    auto insertOffsets = extractVector<int64_t>(insertOp.getOffsets());
call    0 never executed
call    1 never executed
    #####: 1485:    auto extractOffsets = extractVector<int64_t>(op.getPosition());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1486:
function _ZZL35foldExtractStridedOpFromInsertChainN4mlir6vector9ExtractOpEENKUlNS_9AttributeEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1487:    if (llvm::any_of(insertOp.getStrides(), [](Attribute attr) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1488:          return attr.cast<IntegerAttr>().getInt() != 1;
call    0 never executed
call    1 never executed
        -: 1489:        }))
    #####: 1490:      return Value();
    #####: 1491:    bool disjoint = false;
    #####: 1492:    SmallVector<int64_t, 4> offsetDiffs;
branch  0 never executed
branch  1 never executed
    #####: 1493:    for (unsigned dim = 0, e = extractOffsets.size(); dim < e; ++dim) {
branch  0 never executed
branch  1 never executed
    #####: 1494:      int64_t start = insertOffsets[dim];
branch  0 never executed
branch  1 never executed
    #####: 1495:      int64_t size =
    #####: 1496:          (dim < insertRankDiff)
    #####: 1497:              ? 1
branch  0 never executed
branch  1 never executed
    #####: 1498:              : insertOp.getSourceVectorType().getDimSize(dim - insertRankDiff);
call    0 never executed
call    1 never executed
    #####: 1499:      int64_t end = start + size;
    #####: 1500:      int64_t offset = extractOffsets[dim];
branch  0 never executed
branch  1 never executed
        -: 1501:      // Check if the start of the extract offset is in the interval inserted.
    #####: 1502:      if (start <= offset && offset < end) {
branch  0 never executed
branch  1 never executed
    #####: 1503:        if (dim >= insertRankDiff)
branch  0 never executed
branch  1 never executed
    #####: 1504:          offsetDiffs.push_back(offset - start);
call    0 never executed
    #####: 1505:        continue;
        -: 1506:      }
        -: 1507:      disjoint = true;
        -: 1508:      break;
        -: 1509:    }
        -: 1510:    // The extract element chunk overlap with the vector inserted.
    #####: 1511:    if (!disjoint) {
branch  0 never executed
branch  1 never executed
        -: 1512:      // If any of the inner dimensions are only partially inserted we have a
        -: 1513:      // partial overlap.
    #####: 1514:      int64_t srcRankDiff =
    #####: 1515:          insertOp.getSourceVectorType().getRank() - destinationRank;
call    0 never executed
call    1 never executed
    #####: 1516:      for (int64_t i = 0; i < destinationRank; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1517:        if (insertOp.getSourceVectorType().getDimSize(i + srcRankDiff) !=
call    0 never executed
call    1 never executed
    #####: 1518:            insertOp.getDestVectorType().getDimSize(i + srcRankDiff +
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1519:                                                    insertRankDiff))
    #####: 1520:          return Value();
        -: 1521:      }
    #####: 1522:      op.getVectorMutable().assign(insertOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1523:      // OpBuilder is only used as a helper to build an I64ArrayAttr.
    #####: 1524:      OpBuilder b(op.getContext());
call    0 never executed
call    1 never executed
    #####: 1525:      op->setAttr(ExtractOp::getPositionAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 1526:                  b.getI64ArrayAttr(offsetDiffs));
call    0 never executed
    #####: 1527:      return op.getResult();
branch  0 never executed
branch  1 never executed
        -: 1528:    }
        -: 1529:    // If the chunk extracted is disjoint from the chunk inserted, keep
        -: 1530:    // looking in the insert chain.
    #####: 1531:    insertOp = insertOp.getDest().getDefiningOp<InsertStridedSliceOp>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1532:  }
   319755: 1533:  return Value();
        -: 1534:}
        -: 1535:
function _ZN4mlir6vector9ExtractOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 661618 returned 100% blocks executed 79%
   661618: 1536:OpFoldResult ExtractOp::fold(ArrayRef<Attribute>) {
   661618: 1537:  if (getPosition().empty())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1538:    return getVector();
call    0 never executed
call    1 never executed
   661618: 1539:  if (succeeded(foldExtractOpFromExtractChain(*this)))
call    0 returned 100%
branch  1 taken 45% (fallthrough)
branch  2 taken 55%
   298103: 1540:    return getResult();
call    0 returned 100%
   363515: 1541:  if (auto res = ExtractFromInsertTransposeChainState(*this).fold())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
       68: 1542:    return res;
call    0 returned 100%
   363447: 1543:  if (auto res = foldExtractFromBroadcast(*this))
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
    30217: 1544:    return res;
call    0 returned 100%
   333230: 1545:  if (auto res = foldExtractFromShapeCast(*this))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1546:    return res;
call    0 never executed
   333230: 1547:  if (auto val = foldExtractFromExtractStrided(*this))
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
    13475: 1548:    return val;
call    0 returned 100%
   319755: 1549:  if (auto val = foldExtractStridedOpFromInsertChain(*this))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1550:    return val;
call    0 never executed
   319755: 1551:  return OpFoldResult();
        -: 1552:}
        -: 1553:
        -: 1554:namespace {
        -: 1555:
        -: 1556:// Pattern to rewrite a ExtractOp(Broadcast) -> Broadcast.
        -: 1557:class ExtractOpFromBroadcast final : public OpRewritePattern<ExtractOp> {
        -: 1558:public:
        -: 1559:  using OpRewritePattern::OpRewritePattern;
        -: 1560:
function _ZNK12_GLOBAL__N_122ExtractOpFromBroadcast15matchAndRewriteEN4mlir6vector9ExtractOpERNS1_15PatternRewriterE called 1152 returned 100% blocks executed 88%
     1152: 1561:  LogicalResult matchAndRewrite(ExtractOp extractOp,
        -: 1562:                                PatternRewriter &rewriter) const override {
     1152: 1563:    Operation *defOp = extractOp.getVector().getDefiningOp();
call    0 returned 100%
call    1 returned 100%
     1152: 1564:    if (!defOp || !isa<vector::BroadcastOp, SplatOp>(defOp))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
     1144: 1565:      return failure();
        -: 1566:
        8: 1567:    Value source = defOp->getOperand(0);
call    0 returned 100%
        8: 1568:    if (extractOp.getType() == source.getType())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1569:      return failure();
function _ZZNK12_GLOBAL__N_122ExtractOpFromBroadcast15matchAndRewriteEN4mlir6vector9ExtractOpERNS1_15PatternRewriterEENKUlNS1_4TypeEE_clES6_.isra.0 called 16 returned 100% blocks executed 100%
       24: 1570:    auto getRank = [](Type type) {
       24: 1571:      return type.isa<VectorType>() ? type.cast<VectorType>().getRank() : 0;
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
        -: 1572:    };
        8: 1573:    unsigned broadcastSrcRank = getRank(source.getType());
call    0 returned 100%
        8: 1574:    unsigned extractResultRank = getRank(extractOp.getType());
call    0 returned 100%
        -: 1575:    // We only consider the case where the rank of the source is less than or
        -: 1576:    // equal to the rank of the extract dst. The other cases are handled in the
        -: 1577:    // folding patterns.
        8: 1578:    if (extractResultRank < broadcastSrcRank)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1579:      return failure();
        8: 1580:    rewriter.replaceOpWithNewOp<vector::BroadcastOp>(
        8: 1581:        extractOp, extractOp.getType(), source);
call    0 returned 100%
        8: 1582:    return success();
        -: 1583:  }
        -: 1584:};
        -: 1585:
        -: 1586:// Pattern to rewrite a ExtractOp(splat ConstantOp) -> ConstantOp.
        -: 1587:class ExtractOpSplatConstantFolder final : public OpRewritePattern<ExtractOp> {
        -: 1588:public:
        -: 1589:  using OpRewritePattern::OpRewritePattern;
        -: 1590:
function _ZNK12_GLOBAL__N_128ExtractOpSplatConstantFolder15matchAndRewriteEN4mlir6vector9ExtractOpERNS1_15PatternRewriterE called 1580 returned 100% blocks executed 94%
     1580: 1591:  LogicalResult matchAndRewrite(ExtractOp extractOp,
        -: 1592:                                PatternRewriter &rewriter) const override {
        -: 1593:    // Return if 'ExtractOp' operand is not defined by a splat vector
        -: 1594:    // ConstantOp.
     1580: 1595:    Value sourceVector = extractOp.getVector();
call    0 returned 100%
     1580: 1596:    Attribute vectorCst;
     1580: 1597:    if (!matchPattern(sourceVector, m_Constant(&vectorCst)))
call    0 returned 100%
branch  1 taken 73% (fallthrough)
branch  2 taken 27%
     1152: 1598:      return failure();
      428: 1599:    auto splat = vectorCst.dyn_cast<SplatElementsAttr>();
call    0 returned 100%
      428: 1600:    if (!splat)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1601:      return failure();
      428: 1602:    Attribute newAttr = splat.getSplatValue<Attribute>();
call    0 returned 100%
      428: 1603:    if (auto vecDstType = extractOp.getType().dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
      420: 1604:      newAttr = DenseElementsAttr::get(vecDstType, newAttr);
call    0 returned 100%
call    1 returned 100%
      428: 1605:    rewriter.replaceOpWithNewOp<arith::ConstantOp>(extractOp, newAttr);
call    0 returned 100%
      428: 1606:    return success();
        -: 1607:  }
        -: 1608:};
        -: 1609:
        -: 1610:// Pattern to rewrite a ExtractOp(vector<...xT> ConstantOp)[...] -> ConstantOp,
        -: 1611:// where the position array specifies a scalar element.
        -: 1612:class ExtractOpScalarVectorConstantFolder final
        -: 1613:    : public OpRewritePattern<ExtractOp> {
        -: 1614:public:
        -: 1615:  using OpRewritePattern::OpRewritePattern;
        -: 1616:
function _ZNK12_GLOBAL__N_135ExtractOpScalarVectorConstantFolder15matchAndRewriteEN4mlir6vector9ExtractOpERNS1_15PatternRewriterE called 1152 returned 100% blocks executed 9%
     1152: 1617:  LogicalResult matchAndRewrite(ExtractOp extractOp,
        -: 1618:                                PatternRewriter &rewriter) const override {
        -: 1619:    // Return if 'ExtractOp' operand is not defined by a compatible vector
        -: 1620:    // ConstantOp.
     1152: 1621:    Value sourceVector = extractOp.getVector();
call    0 returned 100%
     1152: 1622:    Attribute vectorCst;
     1152: 1623:    if (!matchPattern(sourceVector, m_Constant(&vectorCst)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1152: 1624:      return failure();
        -: 1625:
    #####: 1626:    auto vecTy = sourceVector.getType().cast<VectorType>();
call    0 never executed
    #####: 1627:    Type elemTy = vecTy.getElementType();
call    0 never executed
    #####: 1628:    ArrayAttr positions = extractOp.getPosition();
call    0 never executed
    #####: 1629:    if (vecTy.isScalable())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1630:      return failure();
        -: 1631:    // Do not allow extracting sub-vectors to limit the size of the generated
        -: 1632:    // constants.
    #####: 1633:    if (vecTy.getRank() != static_cast<int64_t>(positions.size()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1634:      return failure();
        -: 1635:    // TODO: Handle more element types, e.g., complex values.
    #####: 1636:    if (!elemTy.isIntOrIndexOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1637:      return failure();
        -: 1638:
        -: 1639:    // The splat case is handled by `ExtractOpSplatConstantFolder`.
    #####: 1640:    auto dense = vectorCst.dyn_cast<DenseElementsAttr>();
call    0 never executed
    #####: 1641:    if (!dense || dense.isSplat())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1642:      return failure();
        -: 1643:
        -: 1644:    // Calculate the flattened position.
    #####: 1645:    int64_t elemPosition = 0;
    #####: 1646:    int64_t innerElems = 1;
    #####: 1647:    for (auto [dimSize, positionInDim] :
    #####: 1648:         llvm::reverse(llvm::zip(vecTy.getShape(), positions))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1649:      int64_t positionVal = positionInDim.cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
    #####: 1650:      elemPosition += positionVal * innerElems;
    #####: 1651:      innerElems *= dimSize;
        -: 1652:    }
        -: 1653:
    #####: 1654:    Attribute newAttr;
    #####: 1655:    if (vecTy.getElementType().isIntOrIndex()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1656:      auto values = to_vector(dense.getValues<APInt>());
call    0 never executed
call    1 never executed
    #####: 1657:      newAttr = IntegerAttr::get(extractOp.getType(), values[elemPosition]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1658:    } else if (vecTy.getElementType().isa<FloatType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1659:      auto values = to_vector(dense.getValues<APFloat>());
call    0 never executed
call    1 never executed
    #####: 1660:      newAttr = FloatAttr::get(extractOp.getType(), values[elemPosition]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1661:    }
    #####: 1662:    assert(newAttr && "Unhandled case");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1663:
    #####: 1664:    rewriter.replaceOpWithNewOp<arith::ConstantOp>(extractOp, newAttr);
call    0 never executed
    #####: 1665:    return success();
        -: 1666:  }
        -: 1667:};
        -: 1668:
        -: 1669:} // namespace
        -: 1670:
function _ZN4mlir6vector9ExtractOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1671:void ExtractOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1672:                                            MLIRContext *context) {
     1235: 1673:  results.add<ExtractOpSplatConstantFolder, ExtractOpScalarVectorConstantFolder,
     1235: 1674:              ExtractOpFromBroadcast>(context);
call    0 returned 100%
     1235: 1675:}
        -: 1676:
function _ZL26populateFromInt64AttrArrayN4mlir9ArrayAttrERN4llvm15SmallVectorImplIlEE called 186261 returned 100% blocks executed 100%
   186261: 1677:static void populateFromInt64AttrArray(ArrayAttr arrayAttr,
        -: 1678:                                       SmallVectorImpl<int64_t> &results) {
   458078: 1679:  for (auto attr : arrayAttr)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 59% (fallthrough)
branch  3 taken 41%
   271817: 1680:    results.push_back(attr.cast<IntegerAttr>().getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   186261: 1681:}
        -: 1682:
        -: 1683://===----------------------------------------------------------------------===//
        -: 1684:// FmaOp
        -: 1685://===----------------------------------------------------------------------===//
        -: 1686:
function _ZN4mlir6vector5FMAOp17getShapeForUnrollEv called 5757 returned 100% blocks executed 88%
     5757: 1687:Optional<SmallVector<int64_t, 4>> FMAOp::getShapeForUnroll() {
    11514: 1688:  return llvm::to_vector<4>(getVectorType().getShape());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -: 1689:}
        -: 1690:
        -: 1691://===----------------------------------------------------------------------===//
        -: 1692:// BroadcastOp
        -: 1693://===----------------------------------------------------------------------===//
        -: 1694:
        -: 1695:BroadcastableToResult
function _ZN4mlir6vector17isBroadcastableToENS_4TypeENS_10VectorTypeEPSt4pairIiiE called 536305491 returned 100% blocks executed 86%
536305491: 1696:mlir::vector::isBroadcastableTo(Type srcType, VectorType dstVectorType,
        -: 1697:                                std::pair<int, int> *mismatchingDims) {
        -: 1698:  // Broadcast scalar to vector of the same element type.
1072610848: 1699:  if (srcType.isIntOrIndexOrFloat() && dstVectorType &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
536305402: 1700:      getElementTypeOrSelf(srcType) == getElementTypeOrSelf(dstVectorType))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
536305357: 1701:    return BroadcastableToResult::Success;
        -: 1702:  // From now on, only vectors broadcast.
      108: 1703:  VectorType srcVectorType = srcType.dyn_cast<VectorType>();
call    0 returned 100%
      108: 1704:  if (!srcVectorType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1705:    return BroadcastableToResult::SourceTypeNotAVector;
        -: 1706:
      108: 1707:  int64_t srcRank = srcVectorType.getRank();
call    0 returned 100%
      108: 1708:  int64_t dstRank = dstVectorType.getRank();
call    0 returned 100%
      108: 1709:  if (srcRank > dstRank)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1710:    return BroadcastableToResult::SourceRankHigher;
        -: 1711:  // Source has an exact match or singleton value for all trailing dimensions
        -: 1712:  // (all leading dimensions are simply duplicated).
      108: 1713:  int64_t lead = dstRank - srcRank;
      228: 1714:  for (int64_t r = 0; r < srcRank; ++r) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
      120: 1715:    int64_t srcDim = srcVectorType.getDimSize(r);
call    0 returned 100%
      120: 1716:    int64_t dstDim = dstVectorType.getDimSize(lead + r);
call    0 returned 100%
      120: 1717:    if (srcDim != 1 && srcDim != dstDim) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1718:      if (mismatchingDims) {
branch  0 never executed
branch  1 never executed
    #####: 1719:        mismatchingDims->first = srcDim;
    #####: 1720:        mismatchingDims->second = dstDim;
        -: 1721:      }
    #####: 1722:      return BroadcastableToResult::DimensionMismatch;
        -: 1723:    }
        -: 1724:  }
        -: 1725:
        -: 1726:  return BroadcastableToResult::Success;
        -: 1727:}
        -: 1728:
function _ZN4mlir6vector11BroadcastOp6verifyEv called 536305471 returned 100% blocks executed 21%
536305471: 1729:LogicalResult BroadcastOp::verify() {
536305471: 1730:  std::pair<int, int> mismatchingDims;
536305471: 1731:  BroadcastableToResult res =
536305471: 1732:      isBroadcastableTo(getSourceType(), getVectorType(), &mismatchingDims);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
536305463: 1733:  if (res == BroadcastableToResult::Success)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
536305463: 1734:    return success();
    #####: 1735:  if (res == BroadcastableToResult::SourceRankHigher)
branch  0 never executed
branch  1 never executed
    #####: 1736:    return emitOpError("source rank higher than destination rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1737:  if (res == BroadcastableToResult::DimensionMismatch)
branch  0 never executed
branch  1 never executed
    #####: 1738:    return emitOpError("dimension mismatch (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1739:           << mismatchingDims.first << " vs. " << mismatchingDims.second << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1740:  if (res == BroadcastableToResult::SourceTypeNotAVector)
branch  0 never executed
branch  1 never executed
    #####: 1741:    return emitOpError("source type is not a vector");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1742:  llvm_unreachable("unexpected vector.broadcast op error");
call    0 never executed
        -: 1743:}
        -: 1744:
function _ZN4mlir6vector11BroadcastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 3125772 returned 100% blocks executed 65%
  3125772: 1745:OpFoldResult BroadcastOp::fold(ArrayRef<Attribute> operands) {
  3125772: 1746:  if (getSourceType() == getVectorType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        6: 1747:    return getSource();
call    0 returned 100%
call    1 returned 100%
  3125766: 1748:  if (!operands[0])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
   623842: 1749:    return {};
  2501924: 1750:  auto vectorType = getVectorType();
call    0 returned 100%
  2501924: 1751:  if (operands[0].isa<IntegerAttr, FloatAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2501924: 1752:    return DenseElementsAttr::get(vectorType, operands[0]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    #####: 1753:  if (auto attr = operands[0].dyn_cast<SplatElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1754:    return DenseElementsAttr::get(vectorType, attr.getSplatValue<Attribute>());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1755:  return {};
        -: 1756:}
        -: 1757:
        -: 1758:namespace {
        -: 1759:
        -: 1760:// Fold broadcast1(broadcast2(x)) into broadcast1(x).
        -: 1761:struct BroadcastFolder : public OpRewritePattern<BroadcastOp> {
        -: 1762:  using OpRewritePattern::OpRewritePattern;
        -: 1763:
function _ZNK12_GLOBAL__N_115BroadcastFolder15matchAndRewriteEN4mlir6vector11BroadcastOpERNS1_15PatternRewriterE called 18166 returned 100% blocks executed 56%
    18166: 1764:  LogicalResult matchAndRewrite(BroadcastOp broadcastOp,
        -: 1765:                                PatternRewriter &rewriter) const override {
    18166: 1766:    auto srcBroadcast = broadcastOp.getSource().getDefiningOp<BroadcastOp>();
call    0 returned 100%
call    1 returned 100%
    18166: 1767:    if (!srcBroadcast)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    18166: 1768:      return failure();
    #####: 1769:    rewriter.replaceOpWithNewOp<BroadcastOp>(
    #####: 1770:        broadcastOp, broadcastOp.getVectorType(), srcBroadcast.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1771:    return success();
        -: 1772:  }
        -: 1773:};
        -: 1774:} // namespace
        -: 1775:
function _ZN4mlir6vector11BroadcastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1776:void BroadcastOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1777:                                              MLIRContext *context) {
        -: 1778:  // BroadcastToShapeCast is not a default canonicalization, it is opt-in by
        -: 1779:  // calling `populateCastAwayVectorLeadingOneDimPatterns`
     1235: 1780:  results.add<BroadcastFolder>(context);
call    0 returned 100%
     1235: 1781:}
        -: 1782:
        -: 1783://===----------------------------------------------------------------------===//
        -: 1784:// ShuffleOp
        -: 1785://===----------------------------------------------------------------------===//
        -: 1786:
function _ZN4mlir6vector9ShuffleOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1787:void ShuffleOp::build(OpBuilder &builder, OperationState &result, Value v1,
        -: 1788:                      Value v2, ArrayRef<int64_t> mask) {
    #####: 1789:  build(builder, result, v1, v2, getVectorSubscriptAttr(builder, mask));
call    0 never executed
call    1 never executed
    #####: 1790:}
        -: 1791:
function _ZN4mlir6vector9ShuffleOp6verifyEv called 58022983 returned 100% blocks executed 59%
 58022983: 1792:LogicalResult ShuffleOp::verify() {
 58022983: 1793:  VectorType resultType = getVectorType();
call    0 returned 100%
 58022983: 1794:  VectorType v1Type = getV1VectorType();
call    0 returned 100%
 58022984: 1795:  VectorType v2Type = getV2VectorType();
call    0 returned 100%
        -: 1796:  // Verify ranks.
 58022984: 1797:  int64_t resRank = resultType.getRank();
call    0 returned 100%
 58022984: 1798:  int64_t v1Rank = v1Type.getRank();
call    0 returned 100%
 58022984: 1799:  int64_t v2Rank = v2Type.getRank();
call    0 returned 100%
 58022984: 1800:  bool wellFormed0DCase = v1Rank == 0 && v2Rank == 0 && resRank == 1;
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
 58022984: 1801:  bool wellFormedNDCase = v1Rank == resRank && v2Rank == resRank;
 58022984: 1802:  if (!wellFormed0DCase && !wellFormedNDCase)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####: 1803:    return emitOpError("rank mismatch");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1804:
        -: 1805:  // Verify all but leading dimension sizes.
 99807102: 1806:  for (int64_t r = 1; r < v1Rank; ++r) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
 41784117: 1807:    int64_t resDim = resultType.getDimSize(r);
call    0 returned 100%
 41784118: 1808:    int64_t v1Dim = v1Type.getDimSize(r);
call    0 returned 100%
 41784118: 1809:    int64_t v2Dim = v2Type.getDimSize(r);
call    0 returned 100%
 41784118: 1810:    if (resDim != v1Dim || v1Dim != v2Dim)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1811:      return emitOpError("dimension mismatch");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1812:  }
        -: 1813:  // Verify mask length.
 58022985: 1814:  auto maskAttr = getMask().getValue();
call    0 returned 100%
call    1 returned 100%
 58022985: 1815:  int64_t maskLength = maskAttr.size();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 58022985: 1816:  if (maskLength <= 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1817:    return emitOpError("invalid mask length");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 58022985: 1818:  if (maskLength != resultType.getDimSize(0))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1819:    return emitOpError("mask length mismatch");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1820:  // Verify all indices.
 58022985: 1821:  int64_t indexSize = (v1Type.getRank() == 0 ? 1 : v1Type.getDimSize(0)) +
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
 58022985: 1822:                      (v2Type.getRank() == 0 ? 1 : v2Type.getDimSize(0));
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
call    2 returned 100%
503097172: 1823:  for (const auto &en : llvm::enumerate(maskAttr)) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
445074188: 1824:    auto attr = en.value().dyn_cast<IntegerAttr>();
call    0 returned 100%
445074189: 1825:    if (!attr || attr.getInt() < 0 || attr.getInt() >= indexSize)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 1826:      return emitOpError("mask index #") << (en.index() + 1) << " out of range";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 1827:  }
 58022985: 1828:  return success();
        -: 1829:}
        -: 1830:
        -: 1831:LogicalResult
function _ZN4mlir6vector9ShuffleOp16inferReturnTypesEPNS_11MLIRContextEN4llvm8OptionalINS_8LocationEEENS_10ValueRangeENS_14DictionaryAttrENS_11RegionRangeERNS4_15SmallVectorImplINS_4TypeEEE called 59504054 returned 100% blocks executed 88%
 59504054: 1832:ShuffleOp::inferReturnTypes(MLIRContext *, Optional<Location>,
        -: 1833:                            ValueRange operands, DictionaryAttr attributes,
        -: 1834:                            RegionRange,
        -: 1835:                            SmallVectorImpl<Type> &inferredReturnTypes) {
 59504054: 1836:  ShuffleOp::Adaptor op(operands, attributes);
call    0 returned 100%
call    1 returned 100%
 59504058: 1837:  auto v1Type = op.getV1().getType().cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
 59504058: 1838:  auto v1Rank = v1Type.getRank();
call    0 returned 100%
        -: 1839:  // Construct resulting type: leading dimension matches mask
        -: 1840:  // length, all trailing dimensions match the operands.
 59504058: 1841:  SmallVector<int64_t, 4> shape;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 59504058: 1842:  shape.reserve(v1Rank);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
117257251: 1843:  shape.push_back(std::max<size_t>(1, op.getMask().size()));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
call    4 returned 100%
        -: 1844:  // In the 0-D case there is no trailing shape to append.
 59504058: 1845:  if (v1Rank > 0)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
 57852099: 1846:    llvm::append_range(shape, v1Type.getShape().drop_front());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 59504056: 1847:  inferredReturnTypes.push_back(
call    0 returned 100%
 59504057: 1848:      VectorType::get(shape, v1Type.getElementType()));
call    0 returned 100%
call    1 returned 100%
 59504056: 1849:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1850:}
        -: 1851:
function _ZL16isStepIndexArrayN4mlir9ArrayAttrEmm called 481223 returned 100% blocks executed 100%
   481223: 1852:static bool isStepIndexArray(ArrayAttr idxArr, uint64_t begin, size_t width) {
   481223: 1853:  uint64_t expected = begin;
   585897: 1854:  return idxArr.size() == width &&
call    0 returned 100%
branch  1 taken 22% (fallthrough)
branch  2 taken 78%
branch  3 taken 90% (fallthrough)
branch  4 taken 10%
   104674: 1855:         llvm::all_of(idxArr.getAsValueRange<IntegerAttr>(),
call    0 returned 100%
call    1 returned 100%
   138371: 1856:                      [&expected](auto attr) {
   138371: 1857:                        return attr.getZExtValue() == expected++;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   481223: 1858:                      });
        -: 1859:}
        -: 1860:
function _ZN4mlir6vector9ShuffleOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 251808 returned 100% blocks executed 96%
   251808: 1861:OpFoldResult vector::ShuffleOp::fold(ArrayRef<Attribute> operands) {
   251808: 1862:  VectorType v1Type = getV1VectorType();
call    0 returned 100%
        -: 1863:  // For consistency: 0-D shuffle return type is 1-D, this cannot be a folding
        -: 1864:  // but must be a canonicalization into a vector.broadcast.
   251808: 1865:  if (v1Type.getRank() == 0)
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
     7151: 1866:    return {};
        -: 1867:
        -: 1868:  // fold shuffle V1, V2, [0, 1, 2, 3] : <4xi32>, <2xi32> -> V1
   489314: 1869:  if (!v1Type.isScalable() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
   244657: 1870:      isStepIndexArray(getMask(), 0, v1Type.getDimSize(0)))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     8091: 1871:    return getV1();
call    0 returned 100%
call    1 returned 100%
        -: 1872:  // fold shuffle V1, V2, [4, 5] : <4xi32>, <2xi32> -> V2
   473132: 1873:  if (!getV1VectorType().isScalable() && !getV2VectorType().isScalable() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 99% (fallthrough)
branch  9 taken 1%
   236566: 1874:      isStepIndexArray(getMask(), getV1VectorType().getDimSize(0),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   236566: 1875:                       getV2VectorType().getDimSize(0)))
call    0 returned 100%
call    1 returned 100%
     2611: 1876:    return getV2();
call    0 returned 100%
call    1 returned 100%
        -: 1877:
   233955: 1878:  Attribute lhs = operands.front(), rhs = operands.back();
branch  0 taken 0%
branch  1 taken 100%
call    2 returned 100%
   233955: 1879:  if (!lhs || !rhs)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 68% (fallthrough)
branch  3 taken 32%
   232447: 1880:    return {};
        -: 1881:
     1508: 1882:  auto lhsType = lhs.cast<DenseElementsAttr>().getType().cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1883:  // Only support 1-D for now to avoid complicated n-D DenseElementsAttr
        -: 1884:  // manipulation.
     1508: 1885:  if (lhsType.getRank() != 1)
call    0 returned 100%
branch  1 taken 72%
branch  2 taken 28%
     1084: 1886:    return {};
      424: 1887:  int64_t lhsSize = lhsType.getDimSize(0);
call    0 returned 100%
        -: 1888:
      424: 1889:  SmallVector<Attribute> results;
call    0 returned 100%
      424: 1890:  auto lhsElements = lhs.cast<DenseElementsAttr>().getValues<Attribute>();
call    0 returned 100%
call    1 returned 100%
      424: 1891:  auto rhsElements = rhs.cast<DenseElementsAttr>().getValues<Attribute>();
call    0 returned 100%
call    1 returned 100%
     3786: 1892:  for (const auto &index : this->getMask().getAsValueRange<IntegerAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 89% (fallthrough)
branch  3 taken 11%
call    4 returned 100%
     3362: 1893:    int64_t i = index.getZExtValue();
call    0 returned 100%
     3362: 1894:    if (i >= lhsSize) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
     1508: 1895:      results.push_back(rhsElements[i - lhsSize]);
call    0 returned 100%
call    1 returned 100%
        -: 1896:    } else {
     1854: 1897:      results.push_back(lhsElements[i]);
call    0 returned 100%
call    1 returned 100%
        -: 1898:    }
        -: 1899:  }
        -: 1900:
      424: 1901:  return DenseElementsAttr::get(getVectorType(), results);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 57% (fallthrough)
branch  5 taken 43%
        -: 1902:}
        -: 1903:
        -: 1904:namespace {
        -: 1905:
        -: 1906:// Pattern to rewrite a 0-D shuffle with [0] or [1] mask returning a 1-D vector
        -: 1907:// to a broadcast.
        -: 1908:struct Canonicalize0DShuffleOp : public OpRewritePattern<ShuffleOp> {
        -: 1909:  using OpRewritePattern::OpRewritePattern;
        -: 1910:
function _ZNK12_GLOBAL__N_123Canonicalize0DShuffleOp15matchAndRewriteEN4mlir6vector9ShuffleOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1911:  LogicalResult matchAndRewrite(ShuffleOp shuffleOp,
        -: 1912:                                PatternRewriter &rewriter) const override {
    #####: 1913:    VectorType v1VectorType = shuffleOp.getV1VectorType();
call    0 never executed
    #####: 1914:    ArrayAttr mask = shuffleOp.getMask();
call    0 never executed
    #####: 1915:    if (v1VectorType.getRank() > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1916:      return failure();
    #####: 1917:    if (mask.size() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1918:      return failure();
    #####: 1919:    Type resType = VectorType::Builder(v1VectorType).setShape({1});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1920:    if (mask[0].cast<IntegerAttr>().getInt() == 0)
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1921:      rewriter.replaceOpWithNewOp<vector::BroadcastOp>(shuffleOp, resType,
    #####: 1922:                                                       shuffleOp.getV1());
call    0 never executed
call    1 never executed
        -: 1923:    else
    #####: 1924:      rewriter.replaceOpWithNewOp<vector::BroadcastOp>(shuffleOp, resType,
    #####: 1925:                                                       shuffleOp.getV2());
call    0 never executed
call    1 never executed
    #####: 1926:    return success();
        -: 1927:  }
        -: 1928:};
        -: 1929:
        -: 1930:/// Pattern to rewrite a ShuffleOp(SplatOp, SplatOp) to SplatOp.
        -: 1931:class ShuffleSplat final : public OpRewritePattern<ShuffleOp> {
        -: 1932:public:
        -: 1933:  using OpRewritePattern::OpRewritePattern;
        -: 1934:
function _ZNK12_GLOBAL__N_112ShuffleSplat15matchAndRewriteEN4mlir6vector9ShuffleOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1935:  LogicalResult matchAndRewrite(ShuffleOp op,
        -: 1936:                                PatternRewriter &rewriter) const override {
    #####: 1937:    auto v1Splat = op.getV1().getDefiningOp<SplatOp>();
call    0 never executed
call    1 never executed
    #####: 1938:    auto v2Splat = op.getV2().getDefiningOp<SplatOp>();
call    0 never executed
call    1 never executed
        -: 1939:
    #####: 1940:    if (!v1Splat || !v2Splat)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1941:      return failure();
        -: 1942:
    #####: 1943:    if (v1Splat.getInput() != v2Splat.getInput())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1944:      return failure();
        -: 1945:
    #####: 1946:    rewriter.replaceOpWithNewOp<SplatOp>(op, op.getType(), v1Splat.getInput());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1947:    return success();
        -: 1948:  }
        -: 1949:};
        -: 1950:
        -: 1951:} // namespace
        -: 1952:
function _ZN4mlir6vector9ShuffleOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1953:void ShuffleOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1954:                                            MLIRContext *context) {
     1235: 1955:  results.add<ShuffleSplat, Canonicalize0DShuffleOp>(context);
call    0 returned 100%
     1235: 1956:}
        -: 1957:
        -: 1958://===----------------------------------------------------------------------===//
        -: 1959:// InsertElementOp
        -: 1960://===----------------------------------------------------------------------===//
        -: 1961:
function _ZN4mlir6vector15InsertElementOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_ called 0 returned 0% blocks executed 0%
    #####: 1962:void InsertElementOp::build(OpBuilder &builder, OperationState &result,
        -: 1963:                            Value source, Value dest) {
    #####: 1964:  build(builder, result, source, dest, {});
call    0 never executed
    #####: 1965:}
        -: 1966:
function _ZN4mlir6vector15InsertElementOp6verifyEv called 55319188 returned 100% blocks executed 44%
 55319188: 1967:LogicalResult InsertElementOp::verify() {
 55319188: 1968:  auto dstVectorType = getDestVectorType();
call    0 returned 100%
 55319188: 1969:  if (dstVectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
  2819657: 1970:    if (getPosition())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1971:      return emitOpError("expected position to be empty with 0-D vector");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  2819657: 1972:    return success();
        -: 1973:  }
 52499531: 1974:  if (dstVectorType.getRank() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1975:    return emitOpError("unexpected >1 vector rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 52499531: 1976:  if (!getPosition())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1977:    return emitOpError("expected position for 1-D vector");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 52499532: 1978:  return success();
        -: 1979:}
        -: 1980:
function _ZN4mlir6vector15InsertElementOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 232036 returned 100% blocks executed 95%
   232036: 1981:OpFoldResult vector::InsertElementOp::fold(ArrayRef<Attribute> operands) {
        -: 1982:  // Skip the 0-D vector here.
   232036: 1983:  if (operands.size() < 3)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    12873: 1984:    return {};
        -: 1985:
   219163: 1986:  Attribute src = operands[0];
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
   219163: 1987:  Attribute dst = operands[1];
   219163: 1988:  Attribute pos = operands[2];
   219163: 1989:  if (!src || !dst || !pos)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
branch  4 taken 41% (fallthrough)
branch  5 taken 59%
   218972: 1990:    return {};
        -: 1991:
      191: 1992:  auto dstElements = dst.cast<DenseElementsAttr>().getValues<Attribute>();
call    0 returned 100%
call    1 returned 100%
        -: 1993:
      191: 1994:  SmallVector<Attribute> results(dstElements);
call    0 returned 100%
        -: 1995:
      191: 1996:  auto attr = pos.dyn_cast<IntegerAttr>();
call    0 returned 100%
      191: 1997:  uint64_t posIdx = attr.getInt();
call    0 returned 100%
        -: 1998:
      191: 1999:  results[posIdx] = src;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2000:
      191: 2001:  return DenseElementsAttr::get(getDestVectorType(), results);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 87% (fallthrough)
branch  5 taken 13%
        -: 2002:}
        -: 2003:
        -: 2004://===----------------------------------------------------------------------===//
        -: 2005:// InsertOp
        -: 2006://===----------------------------------------------------------------------===//
        -: 2007:
function _ZN4mlir6vector8InsertOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIlEE called 131853 returned 100% blocks executed 100%
   131853: 2008:void InsertOp::build(OpBuilder &builder, OperationState &result, Value source,
        -: 2009:                     Value dest, ArrayRef<int64_t> position) {
   131853: 2010:  result.addOperands({source, dest});
call    0 returned 100%
call    1 returned 100%
   131853: 2011:  auto positionAttr = getVectorSubscriptAttr(builder, position);
call    0 returned 100%
   131853: 2012:  result.addTypes(dest.getType());
call    0 returned 100%
   131853: 2013:  result.addAttribute(getPositionAttrStrName(), positionAttr);
call    0 returned 100%
   131853: 2014:}
        -: 2015:
        -: 2016:// Convenience builder which assumes the values are constant indices.
function _ZN4mlir6vector8InsertOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 2017:void InsertOp::build(OpBuilder &builder, OperationState &result, Value source,
        -: 2018:                     Value dest, ValueRange position) {
    #####: 2019:  SmallVector<int64_t, 4> positionConstants =
    #####: 2020:      llvm::to_vector<4>(llvm::map_range(position, [](Value pos) {
        -: 2021:        return pos.getDefiningOp<arith::ConstantIndexOp>().value();
    #####: 2022:      }));
call    0 never executed
    #####: 2023:  build(builder, result, source, dest, positionConstants);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2024:}
        -: 2025:
function _ZN4mlir6vector8InsertOp6verifyEv called 38363504 returned 100% blocks executed 54%
 38363504: 2026:LogicalResult InsertOp::verify() {
 38363504: 2027:  auto positionAttr = getPosition().getValue();
call    0 returned 100%
call    1 returned 100%
 38363505: 2028:  auto destVectorType = getDestVectorType();
call    0 returned 100%
 38363505: 2029:  if (positionAttr.size() > static_cast<unsigned>(destVectorType.getRank()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2030:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2031:        "expected position attribute of rank smaller than dest vector rank");
call    0 never executed
 38363505: 2032:  auto srcVectorType = getSourceType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
 54815729: 2033:  if (srcVectorType &&
 16452225: 2034:      (static_cast<unsigned>(srcVectorType.getRank()) + positionAttr.size() !=
call    0 returned 100%
 54815729: 2035:       static_cast<unsigned>(destVectorType.getRank())))
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2036:    return emitOpError("expected position attribute rank + source rank to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2037:                       "match dest vector rank");
call    0 never executed
 38363504: 2038:  if (!srcVectorType &&
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
 21911280: 2039:      (positionAttr.size() != static_cast<unsigned>(destVectorType.getRank())))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####: 2040:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2041:        "expected position attribute rank to match the dest vector rank");
call    0 never executed
 77502818: 2042:  for (const auto &en : llvm::enumerate(positionAttr)) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
call    2 returned 100%
 39139313: 2043:    auto attr = en.value().dyn_cast<IntegerAttr>();
call    0 returned 100%
 78278627: 2044:    if (!attr || attr.getInt() < 0 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 39139313: 2045:        attr.getInt() >= destVectorType.getDimSize(en.index()))
call    0 returned 100%
call    1 returned 100%
    #####: 2046:      return emitOpError("expected position attribute #")
call    0 never executed
call    1 never executed
    #####: 2047:             << (en.index() + 1)
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2048:             << " to be a non-negative integer smaller than the corresponding "
    #####: 2049:                "dest vector dimension";
call    0 never executed
        -: 2050:  }
 38363505: 2051:  return success();
        -: 2052:}
        -: 2053:
        -: 2054:namespace {
        -: 2055:
        -: 2056:// If insertOp is only inserting unit dimensions it can be transformed to a
        -: 2057:// broadcast.
        -: 2058:class InsertToBroadcast final : public OpRewritePattern<InsertOp> {
        -: 2059:public:
        -: 2060:  using OpRewritePattern::OpRewritePattern;
        -: 2061:
function _ZNK12_GLOBAL__N_117InsertToBroadcast15matchAndRewriteEN4mlir6vector8InsertOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2062:  LogicalResult matchAndRewrite(InsertOp insertOp,
        -: 2063:                                PatternRewriter &rewriter) const override {
    #####: 2064:    auto srcVecType = insertOp.getSourceType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####: 2065:    if (!srcVecType || insertOp.getDestVectorType().getNumElements() !=
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2066:                           srcVecType.getNumElements())
call    0 never executed
    #####: 2067:      return failure();
    #####: 2068:    rewriter.replaceOpWithNewOp<BroadcastOp>(
    #####: 2069:        insertOp, insertOp.getDestVectorType(), insertOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2070:    return success();
        -: 2071:  }
        -: 2072:};
        -: 2073:
        -: 2074:/// Pattern to rewrite a InsertOp(SplatOp, SplatOp) to SplatOp.
        -: 2075:class InsertSplatToSplat final : public OpRewritePattern<InsertOp> {
        -: 2076:public:
        -: 2077:  using OpRewritePattern::OpRewritePattern;
        -: 2078:
function _ZNK12_GLOBAL__N_118InsertSplatToSplat15matchAndRewriteEN4mlir6vector8InsertOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2079:  LogicalResult matchAndRewrite(InsertOp op,
        -: 2080:                                PatternRewriter &rewriter) const override {
    #####: 2081:    auto srcSplat = op.getSource().getDefiningOp<SplatOp>();
call    0 never executed
call    1 never executed
    #####: 2082:    auto dstSplat = op.getDest().getDefiningOp<SplatOp>();
call    0 never executed
call    1 never executed
        -: 2083:
    #####: 2084:    if (!srcSplat || !dstSplat)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2085:      return failure();
        -: 2086:
    #####: 2087:    if (srcSplat.getInput() != dstSplat.getInput())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2088:      return failure();
        -: 2089:
    #####: 2090:    rewriter.replaceOpWithNewOp<SplatOp>(op, op.getType(), srcSplat.getInput());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2091:    return success();
        -: 2092:  }
        -: 2093:};
        -: 2094:
        -: 2095:} // namespace
        -: 2096:
function _ZN4mlir6vector8InsertOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 2097:void InsertOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2098:                                           MLIRContext *context) {
     1235: 2099:  results.add<InsertToBroadcast, BroadcastFolder, InsertSplatToSplat>(context);
call    0 returned 100%
     1235: 2100:}
        -: 2101:
        -: 2102:// Eliminates insert operations that produce values identical to their source
        -: 2103:// value. This happens when the source and destination vectors have identical
        -: 2104:// sizes.
function _ZN4mlir6vector8InsertOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 371778 returned 100% blocks executed 62%
   371778: 2105:OpFoldResult vector::InsertOp::fold(ArrayRef<Attribute> operands) {
   371778: 2106:  if (getPosition().empty())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2107:    return getSource();
call    0 never executed
call    1 never executed
   371778: 2108:  return {};
        -: 2109:}
        -: 2110:
        -: 2111://===----------------------------------------------------------------------===//
        -: 2112:// InsertStridedSliceOp
        -: 2113://===----------------------------------------------------------------------===//
        -: 2114:
function _ZN4mlir6vector20InsertStridedSliceOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIlEES9_ called 1457 returned 100% blocks executed 100%
     1457: 2115:void InsertStridedSliceOp::build(OpBuilder &builder, OperationState &result,
        -: 2116:                                 Value source, Value dest,
        -: 2117:                                 ArrayRef<int64_t> offsets,
        -: 2118:                                 ArrayRef<int64_t> strides) {
     1457: 2119:  result.addOperands({source, dest});
call    0 returned 100%
call    1 returned 100%
     1457: 2120:  auto offsetsAttr = getVectorSubscriptAttr(builder, offsets);
call    0 returned 100%
     1457: 2121:  auto stridesAttr = getVectorSubscriptAttr(builder, strides);
call    0 returned 100%
     1457: 2122:  result.addTypes(dest.getType());
call    0 returned 100%
     1457: 2123:  result.addAttribute(getOffsetsAttrStrName(), offsetsAttr);
call    0 returned 100%
     1457: 2124:  result.addAttribute(getStridesAttrStrName(), stridesAttr);
call    0 returned 100%
     1457: 2125:}
        -: 2126:
        -: 2127:// TODO: Should be moved to Tablegen ConfinedAttr attributes.
        -: 2128:template <typename OpType>
        -: 2129:static LogicalResult isIntegerArrayAttrSmallerThanShape(OpType op,
        -: 2130:                                                        ArrayAttr arrayAttr,
        -: 2131:                                                        ArrayRef<int64_t> shape,
        -: 2132:                                                        StringRef attrName) {
        -: 2133:  if (arrayAttr.size() > shape.size())
        -: 2134:    return op.emitOpError("expected ")
        -: 2135:           << attrName << " attribute of rank smaller than vector rank";
        -: 2136:  return success();
        -: 2137:}
        -: 2138:
        -: 2139:// Returns true if all integers in `arrayAttr` are in the half-open [min, max}
        -: 2140:// interval. If `halfOpen` is true then the admissible interval is [min, max).
        -: 2141:// Otherwise, the admissible interval is [min, max].
        -: 2142:template <typename OpType>
        -: 2143:static LogicalResult
 44069694: 2144:isIntegerArrayAttrConfinedToRange(OpType op, ArrayAttr arrayAttr, int64_t min,
        -: 2145:                                  int64_t max, StringRef attrName,
        -: 2146:                                  bool halfOpen = true) {
 89464402: 2147:  for (auto attr : arrayAttr) {
 45394709: 2148:    auto val = attr.cast<IntegerAttr>().getInt();
 45394708: 2149:    auto upper = max;
 45394708: 2150:    if (!halfOpen)
 45394708: 2151:      upper += 1;
 45394708: 2152:    if (val < min || val >= upper)
    #####: 2153:      return op.emitOpError("expected ") << attrName << " to be confined to ["
    #####: 2154:                                         << min << ", " << upper << ")";
        -: 2155:  }
 44069693: 2156:  return success();
        -: 2157:}
------------------
_Z33isIntegerArrayAttrConfinedToRangeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEllN4llvm9StringRefEb:
function _Z33isIntegerArrayAttrConfinedToRangeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEllN4llvm9StringRefEb called 44065219 returned 100% blocks executed 54%
 44065219: 2144:isIntegerArrayAttrConfinedToRange(OpType op, ArrayAttr arrayAttr, int64_t min,
        -: 2145:                                  int64_t max, StringRef attrName,
        -: 2146:                                  bool halfOpen = true) {
 89450977: 2147:  for (auto attr : arrayAttr) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 51% (fallthrough)
branch  3 taken 49%
call    4 returned 100%
 45385759: 2148:    auto val = attr.cast<IntegerAttr>().getInt();
call    0 returned 100%
 45385758: 2149:    auto upper = max;
 45385758: 2150:    if (!halfOpen)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 45385758: 2151:      upper += 1;
 45385758: 2152:    if (val < min || val >= upper)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2153:      return op.emitOpError("expected ") << attrName << " to be confined to ["
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2154:                                         << min << ", " << upper << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2155:  }
 44065218: 2156:  return success();
        -: 2157:}
------------------
_Z33isIntegerArrayAttrConfinedToRangeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEllN4llvm9StringRefEb:
function _Z33isIntegerArrayAttrConfinedToRangeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEllN4llvm9StringRefEb called 4475 returned 100% blocks executed 54%
     4475: 2144:isIntegerArrayAttrConfinedToRange(OpType op, ArrayAttr arrayAttr, int64_t min,
        -: 2145:                                  int64_t max, StringRef attrName,
        -: 2146:                                  bool halfOpen = true) {
    13425: 2147:  for (auto attr : arrayAttr) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
call    4 returned 100%
     8950: 2148:    auto val = attr.cast<IntegerAttr>().getInt();
call    0 returned 100%
     8950: 2149:    auto upper = max;
     8950: 2150:    if (!halfOpen)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     8950: 2151:      upper += 1;
     8950: 2152:    if (val < min || val >= upper)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2153:      return op.emitOpError("expected ") << attrName << " to be confined to ["
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2154:                                         << min << ", " << upper << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2155:  }
     4475: 2156:  return success();
        -: 2157:}
------------------
        -: 2158:
        -: 2159:// Returns true if all integers in `arrayAttr` are in the half-open [min, max}
        -: 2160:// interval. If `halfOpen` is true then the admissible interval is [min, max).
        -: 2161:// Otherwise, the admissible interval is [min, max].
        -: 2162:template <typename OpType>
        -: 2163:static LogicalResult
 88134913: 2164:isIntegerArrayAttrConfinedToShape(OpType op, ArrayAttr arrayAttr,
        -: 2165:                                  ArrayRef<int64_t> shape, StringRef attrName,
        -: 2166:                                  bool halfOpen = true, int64_t min = 0) {
88134912*: 2167:  assert(arrayAttr.size() <= shape.size());
 88134912: 2168:  unsigned index = 0;
178915379: 2169:  for (auto it : llvm::zip(arrayAttr, shape)) {
 90780467: 2170:    auto val = std::get<0>(it).cast<IntegerAttr>().getInt();
 90780467: 2171:    auto max = std::get<1>(it);
 90780467: 2172:    if (!halfOpen)
45385759*: 2173:      max += 1;
 90780467: 2174:    if (val < min || val >= max)
        -: 2175:      return op.emitOpError("expected ")
    #####: 2176:             << attrName << " dimension " << index << " to be confined to ["
    #####: 2177:             << min << ", " << max << ")";
 90780467: 2178:    ++index;
        -: 2179:  }
 88134912: 2180:  return success();
        -: 2181:}
------------------
_Z33isIntegerArrayAttrConfinedToShapeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEN4llvm8ArrayRefIlEENS6_9StringRefEbl:
function _Z33isIntegerArrayAttrConfinedToShapeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEN4llvm8ArrayRefIlEENS6_9StringRefEbl called 88130438 returned 100% blocks executed 50%
 88130438: 2164:isIntegerArrayAttrConfinedToShape(OpType op, ArrayAttr arrayAttr,
call    0 returned 100%
        -: 2165:                                  ArrayRef<int64_t> shape, StringRef attrName,
        -: 2166:                                  bool halfOpen = true, int64_t min = 0) {
88130437*: 2167:  assert(arrayAttr.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 88130437: 2168:  unsigned index = 0;
call    0 returned 100%
178901954: 2169:  for (auto it : llvm::zip(arrayAttr, shape)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 51% (fallthrough)
branch  3 taken 49%
call    4 returned 100%
 90771517: 2170:    auto val = std::get<0>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
 90771517: 2171:    auto max = std::get<1>(it);
 90771517: 2172:    if (!halfOpen)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
 45385759: 2173:      max += 1;
 90771517: 2174:    if (val < min || val >= max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2175:      return op.emitOpError("expected ")
    #####: 2176:             << attrName << " dimension " << index << " to be confined to ["
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 2177:             << min << ", " << max << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 90771517: 2178:    ++index;
        -: 2179:  }
 88130437: 2180:  return success();
        -: 2181:}
------------------
_Z33isIntegerArrayAttrConfinedToShapeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEN4llvm8ArrayRefIlEENS6_9StringRefEbl:
function _Z33isIntegerArrayAttrConfinedToShapeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrEN4llvm8ArrayRefIlEENS6_9StringRefEbl called 4475 returned 100% blocks executed 46%
     4475: 2164:isIntegerArrayAttrConfinedToShape(OpType op, ArrayAttr arrayAttr,
call    0 returned 100%
        -: 2165:                                  ArrayRef<int64_t> shape, StringRef attrName,
        -: 2166:                                  bool halfOpen = true, int64_t min = 0) {
    4475*: 2167:  assert(arrayAttr.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     4475: 2168:  unsigned index = 0;
call    0 returned 100%
    13425: 2169:  for (auto it : llvm::zip(arrayAttr, shape)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
call    4 returned 100%
     8950: 2170:    auto val = std::get<0>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     8950: 2171:    auto max = std::get<1>(it);
     8950: 2172:    if (!halfOpen)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2173:      max += 1;
     8950: 2174:    if (val < min || val >= max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2175:      return op.emitOpError("expected ")
    #####: 2176:             << attrName << " dimension " << index << " to be confined to ["
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 2177:             << min << ", " << max << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     8950: 2178:    ++index;
        -: 2179:  }
     4475: 2180:  return success();
        -: 2181:}
------------------
        -: 2182:
        -: 2183:// Returns true if all integers in `arrayAttr` are in the interval [min, max}.
        -: 2184:// interval. If `halfOpen` is true then the admissible interval is [min, max).
        -: 2185:// Otherwise, the admissible interval is [min, max].
        -: 2186:template <typename OpType>
 44069693: 2187:static LogicalResult isSumOfIntegerArrayAttrConfinedToShape(
        -: 2188:    OpType op, ArrayAttr arrayAttr1, ArrayAttr arrayAttr2,
        -: 2189:    ArrayRef<int64_t> shape, StringRef attrName1, StringRef attrName2,
        -: 2190:    bool halfOpen = true, int64_t min = 1) {
44069693*: 2191:  assert(arrayAttr1.size() <= shape.size());
44069693*: 2192:  assert(arrayAttr2.size() <= shape.size());
 44069693: 2193:  unsigned index = 0;
 89464402: 2194:  for (auto it : llvm::zip(arrayAttr1, arrayAttr2, shape)) {
 45394708: 2195:    auto val1 = std::get<0>(it).cast<IntegerAttr>().getInt();
 45394708: 2196:    auto val2 = std::get<1>(it).cast<IntegerAttr>().getInt();
 45394709: 2197:    auto max = std::get<2>(it);
 45394709: 2198:    if (!halfOpen)
 45394709: 2199:      max += 1;
 45394709: 2200:    if (val1 + val2 < 0 || val1 + val2 >= max)
        -: 2201:      return op.emitOpError("expected sum(")
    #####: 2202:             << attrName1 << ", " << attrName2 << ") dimension " << index
    #####: 2203:             << " to be confined to [" << min << ", " << max << ")";
 45394709: 2204:    ++index;
        -: 2205:  }
 44069694: 2206:  return success();
        -: 2207:}
------------------
_Z38isSumOfIntegerArrayAttrConfinedToShapeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrES5_N4llvm8ArrayRefIlEENS6_9StringRefES9_bl:
function _Z38isSumOfIntegerArrayAttrConfinedToShapeIN4mlir6vector21ExtractStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrES5_N4llvm8ArrayRefIlEENS6_9StringRefES9_bl called 44065218 returned 100% blocks executed 51%
 44065218: 2187:static LogicalResult isSumOfIntegerArrayAttrConfinedToShape(
call    0 returned 100%
        -: 2188:    OpType op, ArrayAttr arrayAttr1, ArrayAttr arrayAttr2,
        -: 2189:    ArrayRef<int64_t> shape, StringRef attrName1, StringRef attrName2,
        -: 2190:    bool halfOpen = true, int64_t min = 1) {
44065218*: 2191:  assert(arrayAttr1.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
44065218*: 2192:  assert(arrayAttr2.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 44065218: 2193:  unsigned index = 0;
call    0 returned 100%
 89450977: 2194:  for (auto it : llvm::zip(arrayAttr1, arrayAttr2, shape)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 51% (fallthrough)
branch  3 taken 49%
call    4 returned 100%
 45385758: 2195:    auto val1 = std::get<0>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 45385758: 2196:    auto val2 = std::get<1>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 45385759: 2197:    auto max = std::get<2>(it);
 45385759: 2198:    if (!halfOpen)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 45385759: 2199:      max += 1;
 45385759: 2200:    if (val1 + val2 < 0 || val1 + val2 >= max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2201:      return op.emitOpError("expected sum(")
    #####: 2202:             << attrName1 << ", " << attrName2 << ") dimension " << index
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 2203:             << " to be confined to [" << min << ", " << max << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 45385759: 2204:    ++index;
        -: 2205:  }
 44065219: 2206:  return success();
        -: 2207:}
------------------
_Z38isSumOfIntegerArrayAttrConfinedToShapeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrES5_N4llvm8ArrayRefIlEENS6_9StringRefES9_bl:
function _Z38isSumOfIntegerArrayAttrConfinedToShapeIN4mlir6vector20InsertStridedSliceOpEENS0_13LogicalResultET_NS0_9ArrayAttrES5_N4llvm8ArrayRefIlEENS6_9StringRefES9_bl called 4475 returned 100% blocks executed 51%
     4475: 2187:static LogicalResult isSumOfIntegerArrayAttrConfinedToShape(
call    0 returned 100%
        -: 2188:    OpType op, ArrayAttr arrayAttr1, ArrayAttr arrayAttr2,
        -: 2189:    ArrayRef<int64_t> shape, StringRef attrName1, StringRef attrName2,
        -: 2190:    bool halfOpen = true, int64_t min = 1) {
    4475*: 2191:  assert(arrayAttr1.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    4475*: 2192:  assert(arrayAttr2.size() <= shape.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     4475: 2193:  unsigned index = 0;
call    0 returned 100%
    13425: 2194:  for (auto it : llvm::zip(arrayAttr1, arrayAttr2, shape)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
call    4 returned 100%
     8950: 2195:    auto val1 = std::get<0>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     8950: 2196:    auto val2 = std::get<1>(it).cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     8950: 2197:    auto max = std::get<2>(it);
     8950: 2198:    if (!halfOpen)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     8950: 2199:      max += 1;
     8950: 2200:    if (val1 + val2 < 0 || val1 + val2 >= max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2201:      return op.emitOpError("expected sum(")
    #####: 2202:             << attrName1 << ", " << attrName2 << ") dimension " << index
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 2203:             << " to be confined to [" << min << ", " << max << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
     8950: 2204:    ++index;
        -: 2205:  }
     4475: 2206:  return success();
        -: 2207:}
------------------
        -: 2208:
function _ZL16makeI64ArrayAttrN4llvm8ArrayRefIlEEPN4mlir11MLIRContextE called 4475 returned 100% blocks executed 80%
     4475: 2209:static ArrayAttr makeI64ArrayAttr(ArrayRef<int64_t> values,
        -: 2210:                                  MLIRContext *context) {
function _ZZL16makeI64ArrayAttrN4llvm8ArrayRefIlEEPN4mlir11MLIRContextEENKUllE_clEl.isra.0 called 8950 returned 100% blocks executed 75%
     8950: 2211:  auto attrs = llvm::map_range(values, [context](int64_t v) -> Attribute {
     8950: 2212:    return IntegerAttr::get(IntegerType::get(context, 64), APInt(64, v));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     4475: 2213:  });
call    0 returned 100%
     4475: 2214:  return ArrayAttr::get(context, llvm::to_vector<8>(attrs));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2215:}
        -: 2216:
function _ZN4mlir6vector20InsertStridedSliceOp6verifyEv called 4475 returned 100% blocks executed 67%
     4475: 2217:LogicalResult InsertStridedSliceOp::verify() {
     4475: 2218:  auto sourceVectorType = getSourceVectorType();
call    0 returned 100%
     4475: 2219:  auto destVectorType = getDestVectorType();
call    0 returned 100%
     4475: 2220:  auto offsets = getOffsetsAttr();
call    0 returned 100%
     4475: 2221:  auto strides = getStridesAttr();
call    0 returned 100%
     4475: 2222:  if (offsets.size() != static_cast<unsigned>(destVectorType.getRank()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2223:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2224:        "expected offsets of same size as destination vector rank");
call    0 never executed
     4475: 2225:  if (strides.size() != static_cast<unsigned>(sourceVectorType.getRank()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2226:    return emitOpError("expected strides of same size as source vector rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     4475: 2227:  if (sourceVectorType.getRank() > destVectorType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2228:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2229:        "expected source rank to be smaller than destination rank");
call    0 never executed
        -: 2230:
     4475: 2231:  auto sourceShape = sourceVectorType.getShape();
call    0 returned 100%
     4475: 2232:  auto destShape = destVectorType.getShape();
call    0 returned 100%
     4475: 2233:  SmallVector<int64_t, 4> sourceShapeAsDestShape(
     4475: 2234:      destShape.size() - sourceShape.size(), 0);
call    0 returned 100%
     4475: 2235:  sourceShapeAsDestShape.append(sourceShape.begin(), sourceShape.end());
call    0 returned 100%
     4475: 2236:  auto offName = InsertStridedSliceOp::getOffsetsAttrName();
call    0 returned 100%
     4475: 2237:  auto stridesName = InsertStridedSliceOp::getStridesAttrName();
call    0 returned 100%
     4475: 2238:  if (failed(isIntegerArrayAttrConfinedToShape(*this, offsets, destShape,
call    0 returned 100%
call    1 returned 100%
     4475: 2239:                                               offName)) ||
     4475: 2240:      failed(isIntegerArrayAttrConfinedToRange(*this, strides, 1, 1,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2241:                                               stridesName,
     4475: 2242:                                               /*halfOpen=*/false)) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    4475*: 2243:      failed(isSumOfIntegerArrayAttrConfinedToShape(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 2244:          *this, offsets,
        -: 2245:          makeI64ArrayAttr(sourceShapeAsDestShape, getContext()), destShape,
        -: 2246:          offName, "source vector shape",
        -: 2247:          /*halfOpen=*/false, /*min=*/1)))
    #####: 2248:    return failure();
        -: 2249:
     4475: 2250:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2251:}
        -: 2252:
        -: 2253:namespace {
        -: 2254:/// Pattern to rewrite an InsertStridedSliceOp(SplatOp(X):src_type,
        -: 2255:/// SplatOp(X):dst_type) to SplatOp(X):dst_type.
        -: 2256:class FoldInsertStridedSliceSplat final
        -: 2257:    : public OpRewritePattern<InsertStridedSliceOp> {
        -: 2258:public:
        -: 2259:  using OpRewritePattern::OpRewritePattern;
        -: 2260:
function _ZNK12_GLOBAL__N_127FoldInsertStridedSliceSplat15matchAndRewriteEN4mlir6vector20InsertStridedSliceOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2261:  LogicalResult matchAndRewrite(InsertStridedSliceOp insertStridedSliceOp,
        -: 2262:                                PatternRewriter &rewriter) const override {
    #####: 2263:    auto srcSplatOp =
    #####: 2264:        insertStridedSliceOp.getSource().getDefiningOp<vector::SplatOp>();
call    0 never executed
call    1 never executed
    #####: 2265:    auto destSplatOp =
    #####: 2266:        insertStridedSliceOp.getDest().getDefiningOp<vector::SplatOp>();
call    0 never executed
call    1 never executed
        -: 2267:
    #####: 2268:    if (!srcSplatOp || !destSplatOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2269:      return failure();
        -: 2270:
    #####: 2271:    if (srcSplatOp.getInput() != destSplatOp.getInput())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2272:      return failure();
        -: 2273:
    #####: 2274:    rewriter.replaceOp(insertStridedSliceOp, insertStridedSliceOp.getDest());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2275:    return success();
        -: 2276:  }
        -: 2277:};
        -: 2278:
        -: 2279:/// Pattern to rewrite an InsertStridedSliceOp(ExtractStridedSliceOp(dst), dst)
        -: 2280:/// to dst.
        -: 2281:class FoldInsertStridedSliceOfExtract final
        -: 2282:    : public OpRewritePattern<InsertStridedSliceOp> {
        -: 2283:public:
        -: 2284:  using OpRewritePattern::OpRewritePattern;
        -: 2285:
function _ZNK12_GLOBAL__N_131FoldInsertStridedSliceOfExtract15matchAndRewriteEN4mlir6vector20InsertStridedSliceOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2286:  LogicalResult matchAndRewrite(InsertStridedSliceOp insertStridedSliceOp,
        -: 2287:                                PatternRewriter &rewriter) const override {
    #####: 2288:    auto extractStridedSliceOp =
    #####: 2289:        insertStridedSliceOp.getSource()
call    0 never executed
    #####: 2290:            .getDefiningOp<vector::ExtractStridedSliceOp>();
call    0 never executed
        -: 2291:
    #####: 2292:    if (!extractStridedSliceOp)
branch  0 never executed
branch  1 never executed
    #####: 2293:      return failure();
        -: 2294:
    #####: 2295:    if (extractStridedSliceOp.getOperand() != insertStridedSliceOp.getDest())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2296:      return failure();
        -: 2297:
        -: 2298:    // Check if have the same strides and offsets.
    #####: 2299:    if (extractStridedSliceOp.getStrides() !=
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2300:            insertStridedSliceOp.getStrides() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2301:        extractStridedSliceOp.getOffsets() != insertStridedSliceOp.getOffsets())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2302:      return failure();
        -: 2303:
    #####: 2304:    rewriter.replaceOp(insertStridedSliceOp, insertStridedSliceOp.getDest());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2305:    return success();
        -: 2306:  }
        -: 2307:};
        -: 2308:
        -: 2309:} // namespace
        -: 2310:
function _ZN4mlir6vector20InsertStridedSliceOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 2311:void vector::InsertStridedSliceOp::getCanonicalizationPatterns(
        -: 2312:    RewritePatternSet &results, MLIRContext *context) {
     1235: 2313:  results.add<FoldInsertStridedSliceSplat, FoldInsertStridedSliceOfExtract>(
     1235: 2314:      context);
call    0 returned 100%
     1235: 2315:}
        -: 2316:
function _ZN4mlir6vector20InsertStridedSliceOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 4579 returned 100% blocks executed 62%
     4579: 2317:OpFoldResult InsertStridedSliceOp::fold(ArrayRef<Attribute> operands) {
     4579: 2318:  if (getSourceVectorType() == getDestVectorType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2319:    return getSource();
call    0 never executed
call    1 never executed
     4579: 2320:  return {};
        -: 2321:}
        -: 2322:
        -: 2323://===----------------------------------------------------------------------===//
        -: 2324:// OuterProductOp
        -: 2325://===----------------------------------------------------------------------===//
        -: 2326:
        -: 2327:/// Build an op without mask, use the type of `acc` as the return type.
function _ZN4mlir6vector14OuterProductOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_ called 0 returned 0% blocks executed 0%
    #####: 2328:void OuterProductOp::build(OpBuilder &builder, OperationState &result,
        -: 2329:                           Value lhs, Value rhs, Value acc) {
    #####: 2330:  result.addOperands({lhs, rhs, acc});
call    0 never executed
call    1 never executed
    #####: 2331:  result.addTypes(acc.getType());
call    0 never executed
    #####: 2332:}
        -: 2333:
function _ZN4mlir6vector14OuterProductOp5printERNS_12OpAsmPrinterE called 1339769 returned 100% blocks executed 100%
  1339769: 2334:void OuterProductOp::print(OpAsmPrinter &p) {
  4019307: 2335:  p << " " << getLhs() << ", " << getRhs();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  1339769: 2336:  if (!getAcc().empty()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2679538: 2337:    p << ", " << getAcc();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1339769: 2338:    p.printOptionalAttrDict((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
        -: 2339:  }
  4019307: 2340:  p << " : " << getLhs().getType() << ", " << getRhs().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
  1339769: 2341:}
        -: 2342:
function _ZN4mlir6vector14OuterProductOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1030973 returned 100% blocks executed 60%
  1030973: 2343:ParseResult OuterProductOp::parse(OpAsmParser &parser, OperationState &result) {
  1030973: 2344:  SmallVector<OpAsmParser::UnresolvedOperand, 3> operandsInfo;
call    0 returned 100%
  1030973: 2345:  Type tLHS, tRHS;
 2061946*: 2346:  if (parser.parseOperandList(operandsInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2061946*: 2347:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 3092919*: 2348:      parser.parseColonType(tLHS) || parser.parseComma() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
 1030973*: 2349:      parser.parseType(tRHS))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2350:    return failure();
  1030973: 2351:  if (operandsInfo.size() < 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2352:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2353:                            "expected at least 2 operands");
call    0 never executed
call    1 never executed
  1030973: 2354:  VectorType vLHS = tLHS.dyn_cast<VectorType>();
call    0 returned 100%
  1030973: 2355:  VectorType vRHS = tRHS.dyn_cast<VectorType>();
call    0 returned 100%
  1030973: 2356:  if (!vLHS)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2357:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2358:                            "expected vector type for operand #1");
call    0 never executed
call    1 never executed
  1030973: 2359:  VectorType resType =
  1030973: 2360:      vRHS ? VectorType::get({vLHS.getDimSize(0), vRHS.getDimSize(0)},
call    0 returned 100%
  2061946: 2361:                             vLHS.getElementType())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 1030973*: 2362:           : VectorType::get({vLHS.getDimSize(0)}, vLHS.getElementType());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2363:
  1030973: 2364:  if (!result.attributes.get(OuterProductOp::getKindAttrStrName())) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2365:    result.attributes.append(
call    0 never executed
call    1 never executed
        -: 2366:        OuterProductOp::getKindAttrStrName(),
    #####: 2367:        CombiningKindAttr::get(result.getContext(),
    #####: 2368:                               OuterProductOp::getDefaultKind()));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2369:  }
        -: 2370:
  1030973: 2371:  return failure(
  2061946: 2372:      parser.resolveOperand(operandsInfo[0], tLHS, result.operands) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
  1030973: 2373:      parser.resolveOperand(operandsInfo[1], tRHS, result.operands) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
  2061946: 2374:      (operandsInfo.size() > 2 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  3092919: 2375:       parser.resolveOperand(operandsInfo[2], resType, result.operands)) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1030973: 2376:      parser.addTypeToList(resType, result.types));
call    0 returned 100%
        -: 2377:}
        -: 2378:
function _ZN4mlir6vector14OuterProductOp6verifyEv called 36057169 returned 100% blocks executed 34%
 36057169: 2379:LogicalResult OuterProductOp::verify() {
 36057169: 2380:  Type tRHS = getOperandTypeRHS();
call    0 returned 100%
 36057169: 2381:  VectorType vLHS = getOperandVectorTypeLHS(),
call    0 returned 100%
call    1 returned 100%
 36057169: 2382:             vRHS = tRHS.dyn_cast<VectorType>(),
 36057169: 2383:             vACC = getOperandVectorTypeACC(), vRES = getVectorType();
call    0 returned 100%
call    1 returned 100%
        -: 2384:
 36057169: 2385:  if (vLHS.getRank() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2386:    return emitOpError("expected 1-d vector for operand #1");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2387:
 36057169: 2388:  if (vRHS) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2389:    // Proper OUTER operation.
 36057169: 2390:    if (vRHS.getRank() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2391:      return emitOpError("expected 1-d vector for operand #2");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 36057169: 2392:    if (vRES.getRank() != 2)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2393:      return emitOpError("expected 2-d vector result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 36057169: 2394:    if (vLHS.getDimSize(0) != vRES.getDimSize(0))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2395:      return emitOpError("expected #1 operand dim to match result dim #1");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 36057169: 2396:    if (vRHS.getDimSize(0) != vRES.getDimSize(1))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2397:      return emitOpError("expected #2 operand dim to match result dim #2");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2398:  } else {
        -: 2399:    // An AXPY operation.
    #####: 2400:    if (vRES.getRank() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2401:      return emitOpError("expected 1-d vector result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2402:    if (vLHS.getDimSize(0) != vRES.getDimSize(0))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2403:      return emitOpError("expected #1 operand dim to match result dim #1");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2404:  }
        -: 2405:
 36057170: 2406:  if (vACC && vACC != vRES)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2407:    return emitOpError("expected operand #3 of same type as result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2408:
        -: 2409:  // Verify supported combining kind.
 36057170: 2410:  if (!isSupportedCombiningKind(getKind(), vRES.getElementType()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2411:    return emitOpError("unsupported outerproduct type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2412:
 36057170: 2413:  return success();
        -: 2414:}
        -: 2415:
        -: 2416://===----------------------------------------------------------------------===//
        -: 2417:// ReshapeOp
        -: 2418://===----------------------------------------------------------------------===//
        -: 2419:
function _ZN4mlir6vector9ReshapeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2420:LogicalResult ReshapeOp::verify() {
        -: 2421:  // Verify that rank(numInputs/outputs) + numFixedVec dim matches vec rank.
    #####: 2422:  auto inputVectorType = getInputVectorType();
call    0 never executed
    #####: 2423:  auto outputVectorType = getOutputVectorType();
call    0 never executed
    #####: 2424:  int64_t inputShapeRank = getNumInputShapeSizes();
call    0 never executed
    #####: 2425:  int64_t outputShapeRank = getNumOutputShapeSizes();
call    0 never executed
    #####: 2426:  SmallVector<int64_t, 4> fixedVectorSizes;
call    0 never executed
    #####: 2427:  getFixedVectorSizes(fixedVectorSizes);
call    0 never executed
    #####: 2428:  int64_t numFixedVectorSizes = fixedVectorSizes.size();
call    0 never executed
        -: 2429:
    #####: 2430:  if (inputVectorType.getRank() != inputShapeRank + numFixedVectorSizes)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2431:    return emitError("invalid input shape for vector type ") << inputVectorType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2432:
    #####: 2433:  if (outputVectorType.getRank() != outputShapeRank + numFixedVectorSizes)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2434:    return emitError("invalid output shape for vector type ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2435:           << outputVectorType;
call    0 never executed
        -: 2436:
        -: 2437:  // Verify that the 'fixedVectorSizes' match an input/output vector shape
        -: 2438:  // suffix.
    #####: 2439:  unsigned inputVectorRank = inputVectorType.getRank();
call    0 never executed
    #####: 2440:  for (unsigned i = 0; i < numFixedVectorSizes; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2441:    unsigned index = inputVectorRank - numFixedVectorSizes - i;
    #####: 2442:    if (fixedVectorSizes[i] != inputVectorType.getShape()[index])
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2443:      return emitError("fixed vector size must match input vector for dim ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2444:             << i;
call    0 never executed
        -: 2445:  }
        -: 2446:
    #####: 2447:  unsigned outputVectorRank = outputVectorType.getRank();
call    0 never executed
    #####: 2448:  for (unsigned i = 0; i < numFixedVectorSizes; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2449:    unsigned index = outputVectorRank - numFixedVectorSizes - i;
    #####: 2450:    if (fixedVectorSizes[i] != outputVectorType.getShape()[index])
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2451:      return emitError("fixed vector size must match output vector for dim ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2452:             << i;
call    0 never executed
        -: 2453:  }
        -: 2454:
        -: 2455:  // If all shape operands are produced by constant ops, verify that product
        -: 2456:  // of dimensions for input/output shape match.
function _ZZN4mlir6vector9ReshapeOp6verifyEvENKUlNS_5ValueEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2457:  auto isDefByConstant = [](Value operand) {
    #####: 2458:    return isa_and_nonnull<arith::ConstantIndexOp>(operand.getDefiningOp());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2459:  };
    #####: 2460:  if (llvm::all_of(getInputShape(), isDefByConstant) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2461:      llvm::all_of(getOutputShape(), isDefByConstant)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2462:    int64_t numInputElements = 1;
    #####: 2463:    for (auto operand : getInputShape())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2464:      numInputElements *=
    #####: 2465:          cast<arith::ConstantIndexOp>(operand.getDefiningOp()).value();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2466:    int64_t numOutputElements = 1;
    #####: 2467:    for (auto operand : getOutputShape())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2468:      numOutputElements *=
    #####: 2469:          cast<arith::ConstantIndexOp>(operand.getDefiningOp()).value();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2470:    if (numInputElements != numOutputElements)
branch  0 never executed
branch  1 never executed
    #####: 2471:      return emitError("product of input and output shape sizes must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2472:  }
    #####: 2473:  return success();
branch  0 never executed
branch  1 never executed
        -: 2474:}
        -: 2475:
function _ZN4mlir6vector9ReshapeOp19getFixedVectorSizesERN4llvm15SmallVectorImplIlEE called 0 returned 0% blocks executed 0%
    #####: 2476:void ReshapeOp::getFixedVectorSizes(SmallVectorImpl<int64_t> &results) {
    #####: 2477:  populateFromInt64AttrArray(getFixedVectorSizes(), results);
call    0 never executed
call    1 never executed
    #####: 2478:}
        -: 2479:
        -: 2480://===----------------------------------------------------------------------===//
        -: 2481:// ExtractStridedSliceOp
        -: 2482://===----------------------------------------------------------------------===//
        -: 2483:
        -: 2484:// Inference works as follows:
        -: 2485://   1. Add 'sizes' from prefix of dims in 'offsets'.
        -: 2486://   2. Add sizes from 'vectorType' for remaining dims.
function _ZL29inferStridedSliceOpResultTypeN4mlir10VectorTypeENS_9ArrayAttrES1_S1_ called 44072677 returned 100% blocks executed 84%
 44072677: 2487:static Type inferStridedSliceOpResultType(VectorType vectorType,
        -: 2488:                                          ArrayAttr offsets, ArrayAttr sizes,
        -: 2489:                                          ArrayAttr strides) {
88145354*: 2490:  assert(offsets.size() == sizes.size() && offsets.size() == strides.size());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
 44072677: 2491:  SmallVector<int64_t, 4> shape;
call    0 returned 100%
 44072677: 2492:  shape.reserve(vectorType.getRank());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 44072677: 2493:  unsigned idx = 0;
 89472903: 2494:  for (unsigned e = offsets.size(); idx < e; ++idx)
call    0 returned 100%
branch  1 taken 51% (fallthrough)
branch  2 taken 49%
 45400226: 2495:    shape.push_back(sizes[idx].cast<IntegerAttr>().getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 68689237: 2496:  for (unsigned e = vectorType.getShape().size(); idx < e; ++idx)
call    0 returned 100%
branch  1 taken 36% (fallthrough)
branch  2 taken 64%
 24616561: 2497:    shape.push_back(vectorType.getShape()[idx]);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -: 2498:
 44072676: 2499:  return VectorType::get(shape, vectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2500:}
        -: 2501:
function _ZN4mlir6vector21ExtractStridedSliceOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEES9_S9_ called 7457 returned 100% blocks executed 100%
     7457: 2502:void ExtractStridedSliceOp::build(OpBuilder &builder, OperationState &result,
        -: 2503:                                  Value source, ArrayRef<int64_t> offsets,
        -: 2504:                                  ArrayRef<int64_t> sizes,
        -: 2505:                                  ArrayRef<int64_t> strides) {
     7457: 2506:  result.addOperands(source);
call    0 returned 100%
call    1 returned 100%
     7457: 2507:  auto offsetsAttr = getVectorSubscriptAttr(builder, offsets);
call    0 returned 100%
     7457: 2508:  auto sizesAttr = getVectorSubscriptAttr(builder, sizes);
call    0 returned 100%
     7457: 2509:  auto stridesAttr = getVectorSubscriptAttr(builder, strides);
call    0 returned 100%
     7457: 2510:  result.addTypes(
call    0 returned 100%
     7457: 2511:      inferStridedSliceOpResultType(source.getType().cast<VectorType>(),
call    0 returned 100%
     7457: 2512:                                    offsetsAttr, sizesAttr, stridesAttr));
call    0 returned 100%
call    1 returned 100%
     7457: 2513:  result.addAttribute(getOffsetsAttrStrName(), offsetsAttr);
call    0 returned 100%
     7457: 2514:  result.addAttribute(getSizesAttrStrName(), sizesAttr);
call    0 returned 100%
     7457: 2515:  result.addAttribute(getStridesAttrStrName(), stridesAttr);
call    0 returned 100%
     7457: 2516:}
        -: 2517:
function _ZN4mlir6vector21ExtractStridedSliceOp6verifyEv called 44065218 returned 100% blocks executed 89%
 44065218: 2518:LogicalResult ExtractStridedSliceOp::verify() {
 44065218: 2519:  auto type = getVectorType();
call    0 returned 100%
 44065219: 2520:  auto offsets = getOffsetsAttr();
call    0 returned 100%
 44065219: 2521:  auto sizes = getSizesAttr();
call    0 returned 100%
 44065218: 2522:  auto strides = getStridesAttr();
call    0 returned 100%
 88130434: 2523:  if (offsets.size() != sizes.size() || offsets.size() != strides.size())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####: 2524:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2525:        "expected offsets, sizes and strides attributes of same size");
call    0 never executed
        -: 2526:
 44065217: 2527:  auto shape = type.getShape();
call    0 returned 100%
 44065217: 2528:  auto offName = getOffsetsAttrName();
call    0 returned 100%
 44065218: 2529:  auto sizesName = getSizesAttrName();
call    0 returned 100%
 44065218: 2530:  auto stridesName = getStridesAttrName();
call    0 returned 100%
 44065218: 2531:  if (failed(
call    0 returned 100%
call    1 returned 100%
 44065220: 2532:          isIntegerArrayAttrSmallerThanShape(*this, offsets, shape, offName)) ||
 44065219: 2533:      failed(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 44065220: 2534:          isIntegerArrayAttrSmallerThanShape(*this, sizes, shape, sizesName)) ||
 44065220: 2535:      failed(isIntegerArrayAttrSmallerThanShape(*this, strides, shape,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 44065220: 2536:                                                stridesName)) ||
 44065220: 2537:      failed(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 44065219: 2538:          isIntegerArrayAttrConfinedToShape(*this, offsets, shape, offName)) ||
 44065220: 2539:      failed(isIntegerArrayAttrConfinedToShape(*this, sizes, shape, sizesName,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2540:                                               /*halfOpen=*/false,
 44065218: 2541:                                               /*min=*/1)) ||
 44065219: 2542:      failed(isIntegerArrayAttrConfinedToRange(*this, strides, 1, 1,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2543:                                               stridesName,
 44065220: 2544:                                               /*halfOpen=*/false)) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 44065218: 2545:      failed(isSumOfIntegerArrayAttrConfinedToShape(*this, offsets, sizes,
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 2546:                                                    shape, offName, sizesName,
        -: 2547:                                                    /*halfOpen=*/false)))
    #####: 2548:    return failure();
        -: 2549:
 44065219: 2550:  auto resultType =
 44065219: 2551:      inferStridedSliceOpResultType(getVectorType(), offsets, sizes, strides);
call    0 returned 100%
call    1 returned 100%
 44065220: 2552:  if (getResult().getType() != resultType)
branch  0 taken 1%
branch  1 taken 100%
        2: 2553:    return emitOpError("expected result type to be ") << resultType;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 2554:
 44065218: 2555:  return success();
        -: 2556:}
        -: 2557:
        -: 2558:// When the source of ExtractStrided comes from a chain of InsertStrided ops try
        -: 2559:// to use the source of the InsertStrided ops if we can detect that the
        -: 2560:// extracted vector is a subset of one of the vector inserted.
        -: 2561:static LogicalResult
function _ZL35foldExtractStridedOpFromInsertChainN4mlir6vector21ExtractStridedSliceOpE called 299027 returned 100% blocks executed 88%
   299027: 2562:foldExtractStridedOpFromInsertChain(ExtractStridedSliceOp op) {
        -: 2563:  // Helper to extract integer out of ArrayAttr.
function _ZZL35foldExtractStridedOpFromInsertChainN4mlir6vector21ExtractStridedSliceOpEENKUlNS_9ArrayAttrEiE_clES2_i.isra.0 called 72020 returned 100% blocks executed 100%
    72020: 2564:  auto getElement = [](ArrayAttr array, int idx) {
    72020: 2565:    return array[idx].cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2566:  };
   299027: 2567:  ArrayAttr extractOffsets = op.getOffsets();
call    0 returned 100%
   299027: 2568:  ArrayAttr extractStrides = op.getStrides();
call    0 returned 100%
   299027: 2569:  ArrayAttr extractSizes = op.getSizes();
call    0 returned 100%
   299027: 2570:  auto insertOp = op.getVector().getDefiningOp<InsertStridedSliceOp>();
call    0 returned 100%
call    1 returned 100%
   311229: 2571:  while (insertOp) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
    12611: 2572:    if (op.getVectorType().getRank() !=
call    0 returned 100%
call    1 returned 100%
    12611: 2573:        insertOp.getSourceVectorType().getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2574:      return failure();
    12611: 2575:    ArrayAttr insertOffsets = insertOp.getOffsets();
call    0 returned 100%
    12611: 2576:    ArrayAttr insertStrides = insertOp.getStrides();
call    0 returned 100%
        -: 2577:    // If the rank of extract is greater than the rank of insert, we are likely
        -: 2578:    // extracting a partial chunk of the vector inserted.
    12611: 2579:    if (extractOffsets.size() > insertOffsets.size())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2580:      return failure();
    12611: 2581:    bool patialoverlap = false;
    12611: 2582:    bool disjoint = false;
    24813: 2583:    SmallVector<int64_t, 4> offsetDiffs;
call    0 returned 100%
    14813: 2584:    for (unsigned dim = 0, e = extractOffsets.size(); dim < e; ++dim) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
    14404: 2585:      if (getElement(extractStrides, dim) != getElement(insertStrides, dim))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     409*: 2586:        return failure();
    14404: 2587:      int64_t start = getElement(insertOffsets, dim);
call    0 returned 100%
    14404: 2588:      int64_t end = start + insertOp.getSourceVectorType().getDimSize(dim);
call    0 returned 100%
call    1 returned 100%
    14404: 2589:      int64_t offset = getElement(extractOffsets, dim);
call    0 returned 100%
    14404: 2590:      int64_t size = getElement(extractSizes, dim);
call    0 returned 100%
        -: 2591:      // Check if the start of the extract offset is in the interval inserted.
    14404: 2592:      if (start <= offset && offset < end) {
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -: 2593:        // If the extract interval overlaps but is not fully included we may
        -: 2594:        // have a partial overlap that will prevent any folding.
     2202: 2595:        if (offset + size > end)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2596:          patialoverlap = true;
     2202: 2597:        offsetDiffs.push_back(offset - start);
call    0 returned 100%
     2202: 2598:        continue;
        -: 2599:      }
        -: 2600:      disjoint = true;
        -: 2601:      break;
        -: 2602:    }
        -: 2603:    // The extract element chunk is a subset of the insert element.
    12611: 2604:    if (!disjoint && !patialoverlap) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
      409: 2605:      op.setOperand(insertOp.getSource());
call    0 returned 100%
call    1 returned 100%
        -: 2606:      // OpBuilder is only used as a helper to build an I64ArrayAttr.
      409: 2607:      OpBuilder b(op.getContext());
call    0 returned 100%
call    1 returned 100%
      409: 2608:      op->setAttr(ExtractStridedSliceOp::getOffsetsAttrStrName(),
call    0 returned 100%
call    1 returned 100%
      409: 2609:                  b.getI64ArrayAttr(offsetDiffs));
call    0 returned 100%
      409: 2610:      return success();
        -: 2611:    }
        -: 2612:    // If the chunk extracted is disjoint from the chunk inserted, keep looking
        -: 2613:    // in the insert chain.
    12202: 2614:    if (disjoint)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    12202: 2615:      insertOp = insertOp.getDest().getDefiningOp<InsertStridedSliceOp>();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2616:    else {
        -: 2617:      // The extracted vector partially overlap the inserted vector, we cannot
        -: 2618:      // fold.
     409*: 2619:      return failure();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2620:    }
        -: 2621:  }
   298618: 2622:  return failure();
        -: 2623:}
        -: 2624:
function _ZN4mlir6vector21ExtractStridedSliceOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 334933 returned 100% blocks executed 100%
   334933: 2625:OpFoldResult ExtractStridedSliceOp::fold(ArrayRef<Attribute> operands) {
   334933: 2626:  if (getVectorType() == getResult().getType())
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
    35906: 2627:    return getVector();
call    0 returned 100%
call    1 returned 100%
   299027: 2628:  if (succeeded(foldExtractStridedOpFromInsertChain(*this)))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      409: 2629:    return getResult();
call    0 returned 100%
   298618: 2630:  return {};
        -: 2631:}
        -: 2632:
function _ZN4mlir6vector21ExtractStridedSliceOp10getOffsetsERN4llvm15SmallVectorImplIlEE called 0 returned 0% blocks executed 0%
    #####: 2633:void ExtractStridedSliceOp::getOffsets(SmallVectorImpl<int64_t> &results) {
    #####: 2634:  populateFromInt64AttrArray(getOffsets(), results);
call    0 never executed
call    1 never executed
    #####: 2635:}
        -: 2636:
        -: 2637:namespace {
        -: 2638:
        -: 2639:// Pattern to rewrite an ExtractStridedSliceOp(ConstantMaskOp) to
        -: 2640:// ConstantMaskOp.
        -: 2641:class StridedSliceConstantMaskFolder final
        -: 2642:    : public OpRewritePattern<ExtractStridedSliceOp> {
        -: 2643:public:
        -: 2644:  using OpRewritePattern::OpRewritePattern;
        -: 2645:
function _ZNK12_GLOBAL__N_130StridedSliceConstantMaskFolder15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpERNS1_15PatternRewriterE called 32223 returned 100% blocks executed 85%
    32223: 2646:  LogicalResult matchAndRewrite(ExtractStridedSliceOp extractStridedSliceOp,
        -: 2647:                                PatternRewriter &rewriter) const override {
        -: 2648:    // Return if 'extractStridedSliceOp' operand is not defined by a
        -: 2649:    // ConstantMaskOp.
    32223: 2650:    auto *defOp = extractStridedSliceOp.getVector().getDefiningOp();
call    0 returned 100%
call    1 returned 100%
    32223: 2651:    auto constantMaskOp = dyn_cast_or_null<ConstantMaskOp>(defOp);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    32223: 2652:    if (!constantMaskOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    32157: 2653:      return failure();
        -: 2654:    // Return if 'extractStridedSliceOp' has non-unit strides.
       66: 2655:    if (extractStridedSliceOp.hasNonUnitStrides())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2656:      return failure();
        -: 2657:    // Gather constant mask dimension sizes.
       66: 2658:    SmallVector<int64_t, 4> maskDimSizes;
call    0 returned 100%
       66: 2659:    populateFromInt64AttrArray(constantMaskOp.getMaskDimSizes(), maskDimSizes);
call    0 returned 100%
call    1 returned 100%
        -: 2660:    // Gather strided slice offsets and sizes.
      132: 2661:    SmallVector<int64_t, 4> sliceOffsets;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       66: 2662:    populateFromInt64AttrArray(extractStridedSliceOp.getOffsets(),
call    0 returned 100%
call    1 returned 100%
        -: 2663:                               sliceOffsets);
      132: 2664:    SmallVector<int64_t, 4> sliceSizes;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       66: 2665:    populateFromInt64AttrArray(extractStridedSliceOp.getSizes(), sliceSizes);
call    0 returned 100%
call    1 returned 100%
        -: 2666:
        -: 2667:    // Compute slice of vector mask region.
      132: 2668:    SmallVector<int64_t, 4> sliceMaskDimSizes;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      66*: 2669:    assert(sliceOffsets.size() == maskDimSizes.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      132: 2670:    for (auto it : llvm::zip(maskDimSizes, sliceOffsets, sliceSizes)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       66: 2671:      int64_t maskDimSize = std::get<0>(it);
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
       66: 2672:      int64_t sliceOffset = std::get<1>(it);
       66: 2673:      int64_t sliceSize = std::get<2>(it);
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
       66: 2674:      int64_t sliceMaskDimSize = std::max(
      132: 2675:          static_cast<int64_t>(0),
      105: 2676:          std::min(sliceOffset + sliceSize, maskDimSize) - sliceOffset);
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
branch  2 taken 65% (fallthrough)
branch  3 taken 35%
       66: 2677:      sliceMaskDimSizes.push_back(sliceMaskDimSize);
call    0 returned 100%
        -: 2678:    }
        -: 2679:    // If any of 'sliceMaskDimSizes' are zero, then set all to zero (masked
        -: 2680:    // region is a conjunction of mask dim intervals).
       66: 2681:    if (llvm::is_contained(sliceMaskDimSizes, 0))
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
       23: 2682:      sliceMaskDimSizes.assign(maskDimSizes.size(), 0);
call    0 returned 100%
        -: 2683:
        -: 2684:    // Replace 'extractStridedSliceOp' with ConstantMaskOp with sliced mask
        -: 2685:    // region.
       66: 2686:    rewriter.replaceOpWithNewOp<ConstantMaskOp>(
       66: 2687:        extractStridedSliceOp, extractStridedSliceOp.getResult().getType(),
call    0 returned 100%
       66: 2688:        vector::getVectorSubscriptAttr(rewriter, sliceMaskDimSizes));
call    0 returned 100%
call    1 returned 100%
       66: 2689:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2690:  }
        -: 2691:};
        -: 2692:
        -: 2693:// Pattern to rewrite a ExtractStridedSliceOp(splat ConstantOp) -> ConstantOp.
        -: 2694:class StridedSliceConstantFolder final
        -: 2695:    : public OpRewritePattern<ExtractStridedSliceOp> {
        -: 2696:public:
        -: 2697:  using OpRewritePattern::OpRewritePattern;
        -: 2698:
function _ZNK12_GLOBAL__N_126StridedSliceConstantFolder15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpERNS1_15PatternRewriterE called 2892 returned 100% blocks executed 93%
     2892: 2699:  LogicalResult matchAndRewrite(ExtractStridedSliceOp extractStridedSliceOp,
        -: 2700:                                PatternRewriter &rewriter) const override {
        -: 2701:    // Return if 'extractStridedSliceOp' operand is not defined by a
        -: 2702:    // ConstantOp.
     2892: 2703:    auto constantOp =
     2892: 2704:        extractStridedSliceOp.getVector().getDefiningOp<arith::ConstantOp>();
call    0 returned 100%
call    1 returned 100%
     2892: 2705:    if (!constantOp)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
     2116: 2706:      return failure();
      776: 2707:    auto dense = constantOp.getValue().dyn_cast<SplatElementsAttr>();
call    0 returned 100%
call    1 returned 100%
      776: 2708:    if (!dense)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2709:      return failure();
      776: 2710:    auto newAttr = DenseElementsAttr::get(extractStridedSliceOp.getType(),
      776: 2711:                                          dense.getSplatValue<Attribute>());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      776: 2712:    rewriter.replaceOpWithNewOp<arith::ConstantOp>(extractStridedSliceOp,
      776: 2713:                                                   newAttr);
call    0 returned 100%
      776: 2714:    return success();
        -: 2715:  }
        -: 2716:};
        -: 2717:
        -: 2718:// Pattern to rewrite an ExtractStridedSliceOp(BroadcastOp) to
        -: 2719:// BroadcastOp(ExtractStrideSliceOp).
        -: 2720:class StridedSliceBroadcast final
        -: 2721:    : public OpRewritePattern<ExtractStridedSliceOp> {
        -: 2722:public:
        -: 2723:  using OpRewritePattern::OpRewritePattern;
        -: 2724:
function _ZNK12_GLOBAL__N_121StridedSliceBroadcast15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpERNS1_15PatternRewriterE called 2116 returned 100% blocks executed 45%
     2116: 2725:  LogicalResult matchAndRewrite(ExtractStridedSliceOp op,
        -: 2726:                                PatternRewriter &rewriter) const override {
     2116: 2727:    auto broadcast = op.getVector().getDefiningOp<BroadcastOp>();
call    0 returned 100%
call    1 returned 100%
     2116: 2728:    if (!broadcast)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     2097: 2729:      return failure();
       19: 2730:    auto srcVecType = broadcast.getSource().getType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
      19*: 2731:    unsigned srcRank = srcVecType ? srcVecType.getRank() : 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       19: 2732:    auto dstVecType = op.getType().cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
       19: 2733:    unsigned dstRank = dstVecType.getRank();
call    0 returned 100%
       19: 2734:    unsigned rankDiff = dstRank - srcRank;
        -: 2735:    // Check if the most inner dimensions of the source of the broadcast are the
        -: 2736:    // same as the destination of the extract. If this is the case we can just
        -: 2737:    // use a broadcast as the original dimensions are untouched.
       19: 2738:    bool lowerDimMatch = true;
      19*: 2739:    for (unsigned i = 0; i < srcRank; i++) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2740:      if (srcVecType.getDimSize(i) != dstVecType.getDimSize(i + rankDiff)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2741:        lowerDimMatch = false;
        -: 2742:        break;
        -: 2743:      }
        -: 2744:    }
       19: 2745:    Value source = broadcast.getSource();
call    0 returned 100%
        -: 2746:    // If the inner dimensions don't match, it means we need to extract from the
        -: 2747:    // source of the orignal broadcast and then broadcast the extracted value.
        -: 2748:    // We also need to handle degenerated cases where the source is effectively
        -: 2749:    // just a single scalar.
      19*: 2750:    bool isScalarSrc = (srcRank == 0 || srcVecType.getNumElements() == 1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
       19: 2751:    if (!lowerDimMatch && !isScalarSrc) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2752:      source = rewriter.create<ExtractStridedSliceOp>(
branch  0 never executed
branch  1 never executed
        -: 2753:          op->getLoc(), source,
    #####: 2754:          getI64SubArray(op.getOffsets(), /* dropFront=*/rankDiff),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2755:          getI64SubArray(op.getSizes(), /* dropFront=*/rankDiff),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2756:          getI64SubArray(op.getStrides(), /* dropFront=*/rankDiff));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2757:    }
       19: 2758:    rewriter.replaceOpWithNewOp<BroadcastOp>(op, op.getType(), source);
call    0 returned 100%
call    1 returned 100%
       19: 2759:    return success();
        -: 2760:  }
        -: 2761:};
        -: 2762:
        -: 2763:/// Pattern to rewrite an ExtractStridedSliceOp(SplatOp) to SplatOp.
        -: 2764:class StridedSliceSplat final : public OpRewritePattern<ExtractStridedSliceOp> {
        -: 2765:public:
        -: 2766:  using OpRewritePattern::OpRewritePattern;
        -: 2767:
function _ZNK12_GLOBAL__N_117StridedSliceSplat15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpERNS1_15PatternRewriterE called 2097 returned 100% blocks executed 56%
     2097: 2768:  LogicalResult matchAndRewrite(ExtractStridedSliceOp op,
        -: 2769:                                PatternRewriter &rewriter) const override {
     2097: 2770:    auto splat = op.getVector().getDefiningOp<SplatOp>();
call    0 returned 100%
call    1 returned 100%
     2097: 2771:    if (!splat)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2097: 2772:      return failure();
    #####: 2773:    rewriter.replaceOpWithNewOp<SplatOp>(op, op.getType(), splat.getInput());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2774:    return success();
        -: 2775:  }
        -: 2776:};
        -: 2777:
        -: 2778:} // namespace
        -: 2779:
function _ZN4mlir6vector21ExtractStridedSliceOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 2780:void ExtractStridedSliceOp::getCanonicalizationPatterns(
        -: 2781:    RewritePatternSet &results, MLIRContext *context) {
        -: 2782:  // Pattern to rewrite a ExtractStridedSliceOp(ConstantMaskOp) ->
        -: 2783:  // ConstantMaskOp and ExtractStridedSliceOp(ConstantOp) -> ConstantOp.
     1235: 2784:  results.add<StridedSliceConstantMaskFolder, StridedSliceConstantFolder,
     1235: 2785:              StridedSliceBroadcast, StridedSliceSplat>(context);
call    0 returned 100%
     1235: 2786:}
        -: 2787:
        -: 2788://===----------------------------------------------------------------------===//
        -: 2789:// TransferReadOp
        -: 2790://===----------------------------------------------------------------------===//
        -: 2791:
        -: 2792:/// 1. Builder that sets padding to zero and an empty mask (variant with attrs).
function _ZN4mlir6vector14TransferReadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_10ValueRangeENS_13AffineMapAttrENS_9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####: 2793:void TransferReadOp::build(OpBuilder &builder, OperationState &result,
        -: 2794:                           VectorType vectorType, Value source,
        -: 2795:                           ValueRange indices, AffineMapAttr permutationMapAttr,
        -: 2796:                           /*optional*/ ArrayAttr inBoundsAttr) {
    #####: 2797:  Type elemType = source.getType().cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 2798:  Value padding = builder.create<arith::ConstantOp>(
    #####: 2799:      result.location, elemType, builder.getZeroAttr(elemType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2800:  build(builder, result, vectorType, source, indices, permutationMapAttr,
call    0 never executed
        -: 2801:        padding, /*mask=*/Value(), inBoundsAttr);
    #####: 2802:}
        -: 2803:
        -: 2804:/// 2. Builder that sets padding to zero an empty mask (variant without attrs).
function _ZN4mlir6vector14TransferReadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_10ValueRangeENS_9AffineMapEN4llvm8OptionalINSA_8ArrayRefIbEEEE called 0 returned 0% blocks executed 0%
    #####: 2805:void TransferReadOp::build(OpBuilder &builder, OperationState &result,
        -: 2806:                           VectorType vectorType, Value source,
        -: 2807:                           ValueRange indices, AffineMap permutationMap,
        -: 2808:                           Optional<ArrayRef<bool>> inBounds) {
    #####: 2809:  auto permutationMapAttr = AffineMapAttr::get(permutationMap);
call    0 never executed
    #####: 2810:  auto inBoundsAttr = (inBounds && !inBounds.value().empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2811:                          ? builder.getBoolArrayAttr(inBounds.value())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2812:                          : ArrayAttr();
    #####: 2813:  build(builder, result, vectorType, source, indices, permutationMapAttr,
call    0 never executed
        -: 2814:        inBoundsAttr);
    #####: 2815:}
        -: 2816:
        -: 2817:/// 3. Builder that sets permutation map to 'getMinorIdentityMap'.
function _ZN4mlir6vector14TransferReadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_10ValueRangeES7_N4llvm8OptionalINS9_8ArrayRefIbEEEE called 0 returned 0% blocks executed 0%
    #####: 2818:void TransferReadOp::build(OpBuilder &builder, OperationState &result,
        -: 2819:                           VectorType vectorType, Value source,
        -: 2820:                           ValueRange indices, Value padding,
        -: 2821:                           Optional<ArrayRef<bool>> inBounds) {
    #####: 2822:  AffineMap permutationMap = getTransferMinorIdentityMap(
    #####: 2823:      source.getType().cast<ShapedType>(), vectorType);
call    0 never executed
call    1 never executed
    #####: 2824:  auto permutationMapAttr = AffineMapAttr::get(permutationMap);
call    0 never executed
    #####: 2825:  auto inBoundsAttr = (inBounds && !inBounds.value().empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2826:                          ? builder.getBoolArrayAttr(inBounds.value())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2827:                          : ArrayAttr();
    #####: 2828:  build(builder, result, vectorType, source, indices, permutationMapAttr,
call    0 never executed
        -: 2829:        padding,
        -: 2830:        /*mask=*/Value(), inBoundsAttr);
    #####: 2831:}
        -: 2832:
        -: 2833:/// 4. Builder that sets padding to zero and permutation map to
        -: 2834:/// 'getMinorIdentityMap'.
function _ZN4mlir6vector14TransferReadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_10ValueRangeEN4llvm8OptionalINS9_8ArrayRefIbEEEE called 0 returned 0% blocks executed 0%
    #####: 2835:void TransferReadOp::build(OpBuilder &builder, OperationState &result,
        -: 2836:                           VectorType vectorType, Value source,
        -: 2837:                           ValueRange indices,
        -: 2838:                           Optional<ArrayRef<bool>> inBounds) {
    #####: 2839:  Type elemType = source.getType().cast<ShapedType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 2840:  Value padding = builder.create<arith::ConstantOp>(
    #####: 2841:      result.location, elemType, builder.getZeroAttr(elemType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2842:  build(builder, result, vectorType, source, indices, padding, inBounds);
call    0 never executed
    #####: 2843:}
        -: 2844:
        -: 2845:template <typename EmitFun>
112415536: 2846:static LogicalResult verifyPermutationMap(AffineMap permutationMap,
        -: 2847:                                          EmitFun emitOpError) {
112415536: 2848:  SmallVector<bool, 8> seen(permutationMap.getNumInputs(), false);
168194186: 2849:  for (auto expr : permutationMap.getResults()) {
 55778648: 2850:    auto dim = expr.dyn_cast<AffineDimExpr>();
 55778647: 2851:    auto zero = expr.dyn_cast<AffineConstantExpr>();
55778646*: 2852:    if (zero) {
 7839724*: 2853:      if (zero.getValue() != 0) {
        -: 2854:        return emitOpError(
        -: 2855:            "requires a projected permutation_map (at most one dim or the zero "
    #####: 2856:            "constant can appear in each result)");
        -: 2857:      }
 7839724*: 2858:      continue;
        -: 2859:    }
 47938922: 2860:    if (!dim) {
        -: 2861:      return emitOpError("requires a projected permutation_map (at most one "
    #####: 2862:                         "dim or the zero constant can appear in each result)");
        -: 2863:    }
 47938922: 2864:    if (seen[dim.getPosition()]) {
        -: 2865:      return emitOpError(
        -: 2866:          "requires a permutation_map that is a permutation (found one dim "
    #####: 2867:          "used more than once)");
        -: 2868:    }
 47938922: 2869:    seen[dim.getPosition()] = true;
        -: 2870:  }
112415537: 2871:  return success();
        -: 2872:}
------------------
_Z20verifyPermutationMapIZN4mlir6vector15TransferWriteOp6verifyEvEUlN4llvm5TwineEE_ENS0_13LogicalResultENS0_9AffineMapET_:
function _Z20verifyPermutationMapIZN4mlir6vector15TransferWriteOp6verifyEvEUlN4llvm5TwineEE_ENS0_13LogicalResultENS0_9AffineMapET_ called 51867175 returned 100% blocks executed 46%
 51867175: 2846:static LogicalResult verifyPermutationMap(AffineMap permutationMap,
        -: 2847:                                          EmitFun emitOpError) {
 51867175: 2848:  SmallVector<bool, 8> seen(permutationMap.getNumInputs(), false);
call    0 returned 100%
call    1 returned 100%
 77633563: 2849:  for (auto expr : permutationMap.getResults()) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
 25766386: 2850:    auto dim = expr.dyn_cast<AffineDimExpr>();
call    0 returned 100%
 25766386: 2851:    auto zero = expr.dyn_cast<AffineConstantExpr>();
call    0 returned 100%
25766386*: 2852:    if (zero) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2853:      if (zero.getValue() != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2854:        return emitOpError(
        -: 2855:            "requires a projected permutation_map (at most one dim or the zero "
    #####: 2856:            "constant can appear in each result)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2857:      }
    #####: 2858:      continue;
        -: 2859:    }
 25766386: 2860:    if (!dim) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2861:      return emitOpError("requires a projected permutation_map (at most one "
    #####: 2862:                         "dim or the zero constant can appear in each result)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2863:    }
 25766386: 2864:    if (seen[dim.getPosition()]) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2865:      return emitOpError(
        -: 2866:          "requires a permutation_map that is a permutation (found one dim "
    #####: 2867:          "used more than once)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2868:    }
 25766386: 2869:    seen[dim.getPosition()] = true;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2870:  }
 51867177: 2871:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2872:}
------------------
_Z20verifyPermutationMapIZN4mlir6vector14TransferReadOp6verifyEvEUlN4llvm5TwineEE_ENS0_13LogicalResultENS0_9AffineMapET_:
function _Z20verifyPermutationMapIZN4mlir6vector14TransferReadOp6verifyEvEUlN4llvm5TwineEE_ENS0_13LogicalResultENS0_9AffineMapET_ called 60548361 returned 100% blocks executed 54%
 60548361: 2846:static LogicalResult verifyPermutationMap(AffineMap permutationMap,
        -: 2847:                                          EmitFun emitOpError) {
 60548361: 2848:  SmallVector<bool, 8> seen(permutationMap.getNumInputs(), false);
call    0 returned 100%
call    1 returned 100%
 90560623: 2849:  for (auto expr : permutationMap.getResults()) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
 30012262: 2850:    auto dim = expr.dyn_cast<AffineDimExpr>();
call    0 returned 100%
 30012261: 2851:    auto zero = expr.dyn_cast<AffineConstantExpr>();
call    0 returned 100%
 30012260: 2852:    if (zero) {
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
  7839724: 2853:      if (zero.getValue() != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2854:        return emitOpError(
        -: 2855:            "requires a projected permutation_map (at most one dim or the zero "
    #####: 2856:            "constant can appear in each result)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2857:      }
  7839724: 2858:      continue;
        -: 2859:    }
 22172536: 2860:    if (!dim) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2861:      return emitOpError("requires a projected permutation_map (at most one "
    #####: 2862:                         "dim or the zero constant can appear in each result)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2863:    }
 22172536: 2864:    if (seen[dim.getPosition()]) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2865:      return emitOpError(
        -: 2866:          "requires a permutation_map that is a permutation (found one dim "
    #####: 2867:          "used more than once)");
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2868:    }
 22172536: 2869:    seen[dim.getPosition()] = true;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2870:  }
 60548360: 2871:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2872:}
------------------
        -: 2873:
        -: 2874:static LogicalResult
        -: 2875:verifyTransferOp(VectorTransferOpInterface op, ShapedType shapedType,
        -: 2876:                 VectorType vectorType, VectorType maskType,
        -: 2877:                 AffineMap permutationMap, ArrayAttr inBounds) {
        -: 2878:  if (op->hasAttr("masked")) {
        -: 2879:    return op->emitOpError("masked attribute has been removed. "
        -: 2880:                           "Use in_bounds instead.");
        -: 2881:  }
        -: 2882:
        -: 2883:  if (!shapedType.isa<MemRefType, RankedTensorType>())
        -: 2884:    return op->emitOpError(
        -: 2885:        "requires source to be a memref or ranked tensor type");
        -: 2886:
        -: 2887:  auto elementType = shapedType.getElementType();
        -: 2888:  DataLayout dataLayout = DataLayout::closest(op);
        -: 2889:  if (auto vectorElementType = elementType.dyn_cast<VectorType>()) {
        -: 2890:    // Memref or tensor has vector element type.
        -: 2891:    unsigned sourceVecSize =
        -: 2892:        dataLayout.getTypeSizeInBits(vectorElementType.getElementType()) *
        -: 2893:        vectorElementType.getShape().back();
        -: 2894:    unsigned resultVecSize =
        -: 2895:        dataLayout.getTypeSizeInBits(vectorType.getElementType()) *
        -: 2896:        vectorType.getShape().back();
        -: 2897:    if (resultVecSize % sourceVecSize != 0)
        -: 2898:      return op->emitOpError(
        -: 2899:          "requires the bitwidth of the minor 1-D vector to be an integral "
        -: 2900:          "multiple of the bitwidth of the minor 1-D vector of the source");
        -: 2901:
        -: 2902:    unsigned sourceVecEltRank = vectorElementType.getRank();
        -: 2903:    unsigned resultVecRank = vectorType.getRank();
        -: 2904:    if (sourceVecEltRank > resultVecRank)
        -: 2905:      return op->emitOpError(
        -: 2906:          "requires source vector element and vector result ranks to match.");
        -: 2907:    unsigned rankOffset = resultVecRank - sourceVecEltRank;
        -: 2908:    // Check that permutation map results match 'rankOffset' of vector type.
        -: 2909:    if (permutationMap.getNumResults() != rankOffset)
        -: 2910:      return op->emitOpError("requires a permutation_map with result dims of "
        -: 2911:                             "the same rank as the vector type");
        -: 2912:
        -: 2913:    if (maskType)
        -: 2914:      return op->emitOpError("does not support masks with vector element type");
        -: 2915:  } else {
        -: 2916:    // Memref or tensor has scalar element type.
        -: 2917:    unsigned minorSize =
        -: 2918:        vectorType.getRank() == 0 ? 1 : vectorType.getShape().back();
        -: 2919:    unsigned resultVecSize =
        -: 2920:        dataLayout.getTypeSizeInBits(vectorType.getElementType()) * minorSize;
        -: 2921:    if (resultVecSize % dataLayout.getTypeSizeInBits(elementType) != 0)
        -: 2922:      return op->emitOpError(
        -: 2923:          "requires the bitwidth of the minor 1-D vector to be an integral "
        -: 2924:          "multiple of the bitwidth of the source element type");
        -: 2925:
        -: 2926:    // Check that permutation map results match rank of vector type.
        -: 2927:    if (permutationMap.getNumResults() != vectorType.getRank())
        -: 2928:      return op->emitOpError("requires a permutation_map with result dims of "
        -: 2929:                             "the same rank as the vector type");
        -: 2930:
        -: 2931:    VectorType expectedMaskType =
        -: 2932:        vector::detail::transferMaskType(vectorType, permutationMap);
        -: 2933:    if (maskType && expectedMaskType != maskType)
        -: 2934:      return op->emitOpError("expects mask type consistent with permutation "
        -: 2935:                             "map: ")
        -: 2936:             << maskType;
        -: 2937:  }
        -: 2938:
        -: 2939:  if (permutationMap.getNumSymbols() != 0)
        -: 2940:    return op->emitOpError("requires permutation_map without symbols");
        -: 2941:
        -: 2942:  if (permutationMap.getNumInputs() != shapedType.getRank())
        -: 2943:    return op->emitOpError("requires a permutation_map with input dims of the "
        -: 2944:                           "same rank as the source type");
        -: 2945:
        -: 2946:  if (inBounds) {
        -: 2947:    if (permutationMap.getNumResults() != static_cast<int64_t>(inBounds.size()))
        -: 2948:      return op->emitOpError("expects the optional in_bounds attr of same rank "
        -: 2949:                             "as permutation_map results: ")
        -: 2950:             << AffineMapAttr::get(permutationMap)
        -: 2951:             << " vs inBounds of size: " << inBounds.size();
        -: 2952:    for (unsigned int i = 0; i < permutationMap.getNumResults(); ++i)
        -: 2953:      if (permutationMap.getResult(i).isa<AffineConstantExpr>() &&
        -: 2954:          !inBounds.getValue()[i].cast<BoolAttr>().getValue())
        -: 2955:        return op->emitOpError("requires broadcast dimensions to be in-bounds");
        -: 2956:  }
        -: 2957:
        -: 2958:  return success();
        -: 2959:}
        -: 2960:
function _ZL18printTransferAttrsRN4mlir12OpAsmPrinterENS_25VectorTransferOpInterfaceE called 3854449 returned 100% blocks executed 96%
  3854449: 2961:static void printTransferAttrs(OpAsmPrinter &p, VectorTransferOpInterface op) {
  3854449: 2962:  SmallVector<StringRef, 3> elidedAttrs;
call    0 returned 100%
  3854449: 2963:  elidedAttrs.push_back(TransferReadOp::getOperandSegmentSizeAttr());
call    0 returned 100%
  3854449: 2964:  if (op.permutation_map().isMinorIdentity())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
  2742213: 2965:    elidedAttrs.push_back(op.getPermutationMapAttrStrName());
call    0 returned 100%
call    1 returned 100%
  3854449: 2966:  bool elideInBounds = true;
  3854449: 2967:  if (auto inBounds = op.in_bounds()) {
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
    39014: 2968:    for (auto attr : *inBounds) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
    39012: 2969:      if (attr.template cast<BoolAttr>().getValue()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 18% (fallthrough)
branch  3 taken 82%
        -: 2970:        elideInBounds = false;
        -: 2971:        break;
        -: 2972:      }
        -: 2973:    }
        -: 2974:  }
  3854449: 2975:  if (elideInBounds)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
  3822364: 2976:    elidedAttrs.push_back(op.getInBoundsAttrStrName());
call    0 returned 100%
call    1 returned 100%
  3854449: 2977:  p.printOptionalAttrDict(op->getAttrs(), elidedAttrs);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  3854449: 2978:}
        -: 2979:
function _ZN4mlir6vector14TransferReadOp5printERNS_12OpAsmPrinterE called 1969404 returned 100% blocks executed 83%
  1969404: 2980:void TransferReadOp::print(OpAsmPrinter &p) {
  7877616: 2981:  p << " " << getSource() << "[" << getIndices() << "], " << getPadding();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
  1969404: 2982:  if (getMask())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2983:    p << ", " << getMask();
call    0 never executed
call    1 never executed
call    2 never executed
  1969404: 2984:  printTransferAttrs(p, *this);
call    0 returned 100%
call    1 returned 100%
  5908212: 2985:  p << " : " << getShapedType() << ", " << getVectorType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  1969404: 2986:}
        -: 2987:
function _ZN4mlir6vector14TransferReadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1498559 returned 100% blocks executed 53%
  1498559: 2988:ParseResult TransferReadOp::parse(OpAsmParser &parser, OperationState &result) {
  1498559: 2989:  auto &builder = parser.getBuilder();
call    0 returned 100%
  1498559: 2990:  SMLoc typesLoc;
  1498559: 2991:  OpAsmParser::UnresolvedOperand sourceInfo;
call    0 returned 100%
  1498559: 2992:  SmallVector<OpAsmParser::UnresolvedOperand, 8> indexInfo;
call    0 returned 100%
  1498559: 2993:  OpAsmParser::UnresolvedOperand paddingInfo;
  1498559: 2994:  SmallVector<Type, 2> types;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1498559: 2995:  OpAsmParser::UnresolvedOperand maskInfo;
        -: 2996:  // Parsing with support for paddingValue.
 2997118*: 2997:  if (parser.parseOperand(sourceInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2997118*: 2998:      parser.parseOperandList(indexInfo, OpAsmParser::Delimiter::Square) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2997118*: 2999:      parser.parseComma() || parser.parseOperand(paddingInfo))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 3000:    return failure();
  1498559: 3001:  ParseResult hasMask = parser.parseOptionalComma();
call    0 returned 100%
  1498559: 3002:  if (hasMask.succeeded()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3003:    if (parser.parseOperand(maskInfo))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3004:      return failure();
        -: 3005:  }
 1498559*: 3006:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 1498559*: 3007:      parser.getCurrentLocation(&typesLoc) || parser.parseColonTypeList(types))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 3008:    return failure();
  1498559: 3009:  if (types.size() != 2)
branch  0 taken 0%
branch  1 taken 100%
    #####: 3010:    return parser.emitError(typesLoc, "requires two types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1498559: 3011:  auto indexType = builder.getIndexType();
call    0 returned 100%
  1498559: 3012:  auto shapedType = types[0].dyn_cast<ShapedType>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  2997118: 3013:  if (!shapedType || !shapedType.isa<MemRefType, RankedTensorType>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 3014:    return parser.emitError(typesLoc, "requires memref or ranked tensor type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1498559: 3015:  VectorType vectorType = types[1].dyn_cast<VectorType>();
branch  0 taken 0%
branch  1 taken 100%
call    2 returned 100%
  1498559: 3016:  if (!vectorType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3017:    return parser.emitError(typesLoc, "requires vector type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1498559: 3018:  auto permutationAttrName = TransferReadOp::getPermutationMapAttrStrName();
call    0 returned 100%
  1498559: 3019:  Attribute mapAttr = result.attributes.get(permutationAttrName);
call    0 returned 100%
  1498559: 3020:  if (!mapAttr) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
  1208090: 3021:    auto permMap = getTransferMinorIdentityMap(shapedType, vectorType);
call    0 returned 100%
        -: 3022:    // Update `mapAttr` that is used later to determine mask type.
  1208090: 3023:    mapAttr = AffineMapAttr::get(permMap);
call    0 returned 100%
  1208090: 3024:    result.attributes.set(permutationAttrName, mapAttr);
call    0 returned 100%
        -: 3025:  }
 2997118*: 3026:  if (parser.resolveOperand(sourceInfo, shapedType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2997118*: 3027:      parser.resolveOperands(indexInfo, indexType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 1498559*: 3028:      parser.resolveOperand(paddingInfo, shapedType.getElementType(),
  1498559: 3029:                            result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 3030:    return failure();
  1498559: 3031:  if (hasMask.succeeded()) {
branch  0 taken 0%
branch  1 taken 100%
    #####: 3032:    if (shapedType.getElementType().dyn_cast<VectorType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3033:      return parser.emitError(
call    0 never executed
call    1 never executed
    #####: 3034:          maskInfo.location, "does not support masks with vector element type");
call    0 never executed
call    1 never executed
    #####: 3035:    auto map = mapAttr.dyn_cast<AffineMapAttr>().getValue();
call    0 never executed
call    1 never executed
        -: 3036:    // Instead of adding the mask type as an op type, compute it based on the
        -: 3037:    // vector type and the permutation map (to keep the type signature small).
    #####: 3038:    auto maskType = mlir::vector::detail::transferMaskType(vectorType, map);
call    0 never executed
    #####: 3039:    if (parser.resolveOperand(maskInfo, maskType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3040:      return failure();
        -: 3041:  }
  1498559: 3042:  result.addAttribute(TransferReadOp::getOperandSegmentSizeAttr(),
call    0 returned 100%
  1498559: 3043:                      builder.getDenseI32ArrayAttr(
  1498559: 3044:                          {1, static_cast<int32_t>(indexInfo.size()), 1,
  1498559: 3045:                           static_cast<int32_t>(hasMask.succeeded())}));
call    0 returned 100%
  1498559: 3046:  return parser.addTypeToList(vectorType, result.types);
call    0 returned 100%
        -: 3047:}
        -: 3048:
function _ZN4mlir6vector14TransferReadOp6verifyEv called 60548362 returned 100% blocks executed 50%
 60548362: 3049:LogicalResult TransferReadOp::verify() {
        -: 3050:  // Consistency of elemental types in source and vector.
 60548362: 3051:  ShapedType shapedType = getShapedType();
call    0 returned 100%
 60548363: 3052:  VectorType vectorType = getVectorType();
call    0 returned 100%
 60548362: 3053:  VectorType maskType = getMaskType();
call    0 returned 100%
 60548356: 3054:  auto paddingType = getPadding().getType();
call    0 returned 100%
call    1 returned 100%
 60548357: 3055:  auto permutationMap = getPermutationMap();
call    0 returned 100%
 60548356: 3056:  auto sourceElementType = shapedType.getElementType();
call    0 returned 100%
        -: 3057:
 60548356: 3058:  if (static_cast<int64_t>(getIndices().size()) != shapedType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3059:    return emitOpError("requires ") << shapedType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 3060:
 61451188: 3061:  if (failed(verifyTransferOp(cast<VectorTransferOpInterface>(getOperation()),
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
        -: 3062:                              shapedType, vectorType, maskType, permutationMap,
121096723: 3063:                              getInBounds() ? *getInBounds() : ArrayAttr())))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 3064:    return failure();
        -: 3065:
 60548361: 3066:  if (auto sourceVectorElementType = sourceElementType.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3067:    // Source has vector element type.
        -: 3068:    // Check that 'sourceVectorElementType' and 'paddingType' types match.
    #####: 3069:    if (sourceVectorElementType != paddingType)
branch  0 never executed
branch  1 never executed
    #####: 3070:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3071:          "requires source element type and padding type to match.");
call    0 never executed
        -: 3072:
        -: 3073:  } else {
        -: 3074:    // Check that 'paddingType' is valid to store in a vector type.
 60548361: 3075:    if (!VectorType::isValidElementType(paddingType))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3076:      return emitOpError("requires valid padding vector elemental type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3077:
        -: 3078:    // Check that padding type and vector element types match.
 60548361: 3079:    if (paddingType != sourceElementType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3080:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3081:          "requires formal padding and source of the same elemental type");
call    0 never executed
        -: 3082:  }
        -: 3083:
 60548361: 3084:  return verifyPermutationMap(permutationMap,
60548361*: 3085:                              [&](Twine t) { return emitOpError(t); });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
        -: 3086:}
        -: 3087:
        -: 3088:template <typename TransferOp>
   320294: 3089:static bool isInBounds(TransferOp op, int64_t resultIdx, int64_t indicesIdx) {
        -: 3090:  // TODO: support more aggressive createOrFold on:
        -: 3091:  // `op.indices()[indicesIdx] + vectorType < dim(op.source(), indicesIdx)`
   320294: 3092:  if (op.getShapedType().isDynamicDim(indicesIdx))
        -: 3093:    return false;
   320294: 3094:  Value index = op.getIndices()[indicesIdx];
   320294: 3095:  auto cstOp = index.getDefiningOp<arith::ConstantIndexOp>();
   320294: 3096:  if (!cstOp)
        -: 3097:    return false;
        -: 3098:
   198310: 3099:  int64_t sourceSize = op.getShapedType().getDimSize(indicesIdx);
   198310: 3100:  int64_t vectorSize = op.getVectorType().getDimSize(resultIdx);
        -: 3101:
   198310: 3102:  return cstOp.value() + vectorSize <= sourceSize;
        -: 3103:}
------------------
_Z10isInBoundsIN4mlir6vector15TransferWriteOpEEbT_ll:
function _Z10isInBoundsIN4mlir6vector15TransferWriteOpEEbT_ll called 232011 returned 100% blocks executed 100%
   232011: 3089:static bool isInBounds(TransferOp op, int64_t resultIdx, int64_t indicesIdx) {
        -: 3090:  // TODO: support more aggressive createOrFold on:
        -: 3091:  // `op.indices()[indicesIdx] + vectorType < dim(op.source(), indicesIdx)`
   232011: 3092:  if (op.getShapedType().isDynamicDim(indicesIdx))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3093:    return false;
   232011: 3094:  Value index = op.getIndices()[indicesIdx];
call    0 returned 100%
   232011: 3095:  auto cstOp = index.getDefiningOp<arith::ConstantIndexOp>();
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
   232011: 3096:  if (!cstOp)
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
        -: 3097:    return false;
        -: 3098:
   145649: 3099:  int64_t sourceSize = op.getShapedType().getDimSize(indicesIdx);
call    0 returned 100%
call    1 returned 100%
   145649: 3100:  int64_t vectorSize = op.getVectorType().getDimSize(resultIdx);
call    0 returned 100%
call    1 returned 100%
        -: 3101:
   145649: 3102:  return cstOp.value() + vectorSize <= sourceSize;
call    0 returned 100%
        -: 3103:}
------------------
_Z10isInBoundsIN4mlir6vector14TransferReadOpEEbT_ll:
function _Z10isInBoundsIN4mlir6vector14TransferReadOpEEbT_ll called 88283 returned 100% blocks executed 100%
    88283: 3089:static bool isInBounds(TransferOp op, int64_t resultIdx, int64_t indicesIdx) {
        -: 3090:  // TODO: support more aggressive createOrFold on:
        -: 3091:  // `op.indices()[indicesIdx] + vectorType < dim(op.source(), indicesIdx)`
    88283: 3092:  if (op.getShapedType().isDynamicDim(indicesIdx))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3093:    return false;
    88283: 3094:  Value index = op.getIndices()[indicesIdx];
call    0 returned 100%
    88283: 3095:  auto cstOp = index.getDefiningOp<arith::ConstantIndexOp>();
call    0 returned 100%
branch  1 taken 60% (fallthrough)
branch  2 taken 40%
    88283: 3096:  if (!cstOp)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -: 3097:    return false;
        -: 3098:
    52661: 3099:  int64_t sourceSize = op.getShapedType().getDimSize(indicesIdx);
call    0 returned 100%
call    1 returned 100%
    52661: 3100:  int64_t vectorSize = op.getVectorType().getDimSize(resultIdx);
call    0 returned 100%
call    1 returned 100%
        -: 3101:
    52661: 3102:  return cstOp.value() + vectorSize <= sourceSize;
call    0 returned 100%
        -: 3103:}
------------------
        -: 3104:
        -: 3105:template <typename TransferOp>
   722697: 3106:static LogicalResult foldTransferInBoundsAttribute(TransferOp op) {
        -: 3107:  // TODO: support 0-d corner case.
        -: 3108:  // TODO: Be less conservative.
   722697: 3109:  if (op.getTransferRank() == 0)
   722697: 3110:    return failure();
   281484: 3111:  AffineMap permutationMap = op.getPermutationMap();
   281484: 3112:  bool changed = false;
  1004181: 3113:  SmallVector<bool, 4> newInBounds;
   281484: 3114:  newInBounds.reserve(op.getTransferRank());
   642432: 3115:  for (unsigned i = 0; i < op.getTransferRank(); ++i) {
        -: 3116:    // Already marked as in-bounds, nothing to see here.
   360948: 3117:    if (op.isDimInBounds(i)) {
    40654: 3118:      newInBounds.push_back(true);
    40654: 3119:      continue;
        -: 3120:    }
        -: 3121:    // Currently out-of-bounds, check whether we can statically determine it is
        -: 3122:    // inBounds.
   320294: 3123:    auto dimExpr = permutationMap.getResult(i).dyn_cast<AffineDimExpr>();
  320294*: 3124:    assert(dimExpr && "Broadcast dims must be in-bounds");
        -: 3125:    auto inBounds =
   320294: 3126:        isInBounds(op, /*resultIdx=*/i, /*indicesIdx=*/dimExpr.getPosition());
   320294: 3127:    newInBounds.push_back(inBounds);
        -: 3128:    // We commit the pattern if it is "more inbounds".
   320294: 3129:    changed |= inBounds;
        -: 3130:  }
   281484: 3131:  if (!changed)
   281484: 3132:    return failure();
        -: 3133:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
    20017: 3134:  OpBuilder b(op.getContext());
    20017: 3135:  op->setAttr(TransferOp::getInBoundsAttrStrName(),
    40034: 3136:              b.getBoolArrayAttr(newInBounds));
   281484: 3137:  return success();
        -: 3138:}
------------------
_Z29foldTransferInBoundsAttributeIN4mlir6vector15TransferWriteOpEENS0_13LogicalResultET_:
function _Z29foldTransferInBoundsAttributeIN4mlir6vector15TransferWriteOpEENS0_13LogicalResultET_ called 471516 returned 100% blocks executed 89%
   471516: 3106:static LogicalResult foldTransferInBoundsAttribute(TransferOp op) {
        -: 3107:  // TODO: support 0-d corner case.
        -: 3108:  // TODO: Be less conservative.
   471516: 3109:  if (op.getTransferRank() == 0)
call    0 returned 100%
branch  1 taken 60% (fallthrough)
branch  2 taken 40%
   471516: 3110:    return failure();
   186548: 3111:  AffineMap permutationMap = op.getPermutationMap();
   186548: 3112:  bool changed = false;
call    0 returned 100%
   658064: 3113:  SmallVector<bool, 4> newInBounds;
   186548: 3114:  newInBounds.reserve(op.getTransferRank());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   427768: 3115:  for (unsigned i = 0; i < op.getTransferRank(); ++i) {
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
        -: 3116:    // Already marked as in-bounds, nothing to see here.
   241220: 3117:    if (op.isDimInBounds(i)) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
     9209: 3118:      newInBounds.push_back(true);
call    0 returned 100%
     9209: 3119:      continue;
        -: 3120:    }
        -: 3121:    // Currently out-of-bounds, check whether we can statically determine it is
        -: 3122:    // inBounds.
   232011: 3123:    auto dimExpr = permutationMap.getResult(i).dyn_cast<AffineDimExpr>();
call    0 returned 100%
call    1 returned 100%
  232011*: 3124:    assert(dimExpr && "Broadcast dims must be in-bounds");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 3125:    auto inBounds =
   232011: 3126:        isInBounds(op, /*resultIdx=*/i, /*indicesIdx=*/dimExpr.getPosition());
call    0 returned 100%
call    1 returned 100%
   232011: 3127:    newInBounds.push_back(inBounds);
call    0 returned 100%
        -: 3128:    // We commit the pattern if it is "more inbounds".
   232011: 3129:    changed |= inBounds;
        -: 3130:  }
   186548: 3131:  if (!changed)
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
   186548: 3132:    return failure();
        -: 3133:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
    12732: 3134:  OpBuilder b(op.getContext());
call    0 returned 100%
    12732: 3135:  op->setAttr(TransferOp::getInBoundsAttrStrName(),
call    0 returned 100%
call    1 returned 100%
    25464: 3136:              b.getBoolArrayAttr(newInBounds));
call    0 returned 100%
   186548: 3137:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3138:}
------------------
_Z29foldTransferInBoundsAttributeIN4mlir6vector14TransferReadOpEENS0_13LogicalResultET_:
function _Z29foldTransferInBoundsAttributeIN4mlir6vector14TransferReadOpEENS0_13LogicalResultET_ called 251181 returned 100% blocks executed 89%
   251181: 3106:static LogicalResult foldTransferInBoundsAttribute(TransferOp op) {
        -: 3107:  // TODO: support 0-d corner case.
        -: 3108:  // TODO: Be less conservative.
   251181: 3109:  if (op.getTransferRank() == 0)
call    0 returned 100%
branch  1 taken 62% (fallthrough)
branch  2 taken 38%
   251181: 3110:    return failure();
    94936: 3111:  AffineMap permutationMap = op.getPermutationMap();
    94936: 3112:  bool changed = false;
call    0 returned 100%
   346117: 3113:  SmallVector<bool, 4> newInBounds;
    94936: 3114:  newInBounds.reserve(op.getTransferRank());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   214664: 3115:  for (unsigned i = 0; i < op.getTransferRank(); ++i) {
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
        -: 3116:    // Already marked as in-bounds, nothing to see here.
   119728: 3117:    if (op.isDimInBounds(i)) {
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
    31445: 3118:      newInBounds.push_back(true);
call    0 returned 100%
    31445: 3119:      continue;
        -: 3120:    }
        -: 3121:    // Currently out-of-bounds, check whether we can statically determine it is
        -: 3122:    // inBounds.
    88283: 3123:    auto dimExpr = permutationMap.getResult(i).dyn_cast<AffineDimExpr>();
call    0 returned 100%
call    1 returned 100%
   88283*: 3124:    assert(dimExpr && "Broadcast dims must be in-bounds");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 3125:    auto inBounds =
    88283: 3126:        isInBounds(op, /*resultIdx=*/i, /*indicesIdx=*/dimExpr.getPosition());
call    0 returned 100%
call    1 returned 100%
    88283: 3127:    newInBounds.push_back(inBounds);
call    0 returned 100%
        -: 3128:    // We commit the pattern if it is "more inbounds".
    88283: 3129:    changed |= inBounds;
        -: 3130:  }
    94936: 3131:  if (!changed)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
    94936: 3132:    return failure();
        -: 3133:  // OpBuilder is only used as a helper to build an I64ArrayAttr.
     7285: 3134:  OpBuilder b(op.getContext());
call    0 returned 100%
     7285: 3135:  op->setAttr(TransferOp::getInBoundsAttrStrName(),
call    0 returned 100%
call    1 returned 100%
    14570: 3136:              b.getBoolArrayAttr(newInBounds));
call    0 returned 100%
    94936: 3137:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3138:}
------------------
        -: 3139:
        -: 3140:///  ```
        -: 3141:///  %w0 = vector.transfer_write %v0, %arg0[%c1, %c0] {in_bounds = [true, true]}
        -: 3142:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3143:///  %0 = vector.transfer_read %w0[%c1, %c0], %cf0 {in_bounds = [true, true]}
        -: 3144:///    : tensor<4x4xf32>, vector<1x4xf32>
        -: 3145:///  ```
        -: 3146:///  -> Folds into
        -: 3147:///  ```
        -: 3148:///  %v0
        -: 3149:///  ```
function _ZL7foldRAWN4mlir6vector14TransferReadOpE called 251181 returned 100% blocks executed 48%
   251181: 3150:static Value foldRAW(TransferReadOp readOp) {
   251181: 3151:  if (!readOp.getShapedType().isa<RankedTensorType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 37% (fallthrough)
branch  3 taken 63%
    93982: 3152:    return {};
   157199: 3153:  auto defWrite = readOp.getSource().getDefiningOp<vector::TransferWriteOp>();
call    0 returned 100%
call    1 returned 100%
   157199: 3154:  while (defWrite) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3155:    if (checkSameValueRAW(defWrite, readOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3156:      return defWrite.getVector();
call    0 never executed
    #####: 3157:    if (!isDisjointTransferIndices(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3158:            cast<VectorTransferOpInterface>(defWrite.getOperation()),
        -: 3159:            cast<VectorTransferOpInterface>(readOp.getOperation())))
        -: 3160:      break;
    #####: 3161:    defWrite = defWrite.getSource().getDefiningOp<vector::TransferWriteOp>();
call    0 never executed
call    1 never executed
        -: 3162:  }
   157199: 3163:  return {};
        -: 3164:}
        -: 3165:
function _ZN4mlir6vector14TransferReadOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 251181 returned 100% blocks executed 67%
   251181: 3166:OpFoldResult TransferReadOp::fold(ArrayRef<Attribute>) {
   251181: 3167:  if (Value vec = foldRAW(*this))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3168:    return vec;
call    0 never executed
        -: 3169:  /// transfer_read(memrefcast) -> transfer_read
   251181: 3170:  if (succeeded(foldTransferInBoundsAttribute(*this)))
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
     7285: 3171:    return getResult();
call    0 returned 100%
   243896: 3172:  if (succeeded(memref::foldMemRefCast(*this)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3173:    return getResult();
call    0 never executed
   243896: 3174:  if (succeeded(tensor::foldTensorCast(*this)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3175:    return getResult();
call    0 never executed
   243896: 3176:  return OpFoldResult();
        -: 3177:}
        -: 3178:
function _ZN4mlir6vector14TransferReadOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####: 3179:Optional<SmallVector<int64_t, 4>> TransferReadOp::getShapeForUnroll() {
    #####: 3180:  return llvm::to_vector<4>(getVectorType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 3181:}
        -: 3182:
function _ZN4mlir6vector14TransferReadOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 274491 returned 100% blocks executed 100%
   274491: 3183:void TransferReadOp::getEffects(
        -: 3184:    SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>>
        -: 3185:        &effects) {
   274491: 3186:  if (getShapedType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 38% (fallthrough)
branch  3 taken 62%
   412748: 3187:    effects.emplace_back(MemoryEffects::Read::get(), getSource(),
   206374: 3188:                         SideEffects::DefaultResource::get());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   274491: 3189:}
        -: 3190:
        -: 3191:/// Returns true if all rank reduced in the given `extractOp` happen in leading
        -: 3192:/// dimensions earlier than last `trailingRank` dimensions.
function _ZL27areAllRankReducedLeadingDimN4mlir6tensor14ExtractSliceOpEj called 0 returned 0% blocks executed 0%
    #####: 3193:static bool areAllRankReducedLeadingDim(tensor::ExtractSliceOp extractOp,
        -: 3194:                                        unsigned trailingRank) {
        -: 3195:  // If no ranks are reduced at all, it's a degenerated case; always true.
    #####: 3196:  if (extractOp.getSourceType().getRank() == extractOp.getType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 3197:    return true;
        -: 3198:
    #####: 3199:  RankedTensorType inferredType = extractOp.inferResultType(
    #####: 3200:      extractOp.getSourceType(), extractOp.getMixedOffsets(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3201:      extractOp.getMixedSizes(), extractOp.getMixedStrides());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 3202:  return extractOp.getType().getShape().take_back(trailingRank) ==
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3203:         inferredType.getShape().take_back(trailingRank);
call    0 never executed
        -: 3204:}
        -: 3205:
        -: 3206:namespace {
        -: 3207:/// Fold transfer_reads of a tensor.extract_slice op. E.g.:
        -: 3208:///
        -: 3209:/// ```
        -: 3210:/// %0 = tensor.extract_slice %t[%a, %b] [%c, %d] [1, 1]
        -: 3211:///     : tensor<?x?xf32> to tensor<?x?xf32>
        -: 3212:/// %1 = vector.transfer_read %0[%e, %f], %cst {in_bounds = [true, true]}
        -: 3213:///     : tensor<?x?xf32>, vector<4x5xf32>
        -: 3214:/// ```
        -: 3215:/// is rewritten to:
        -: 3216:/// ```
        -: 3217:/// %p0 = arith.addi %a, %e : index
        -: 3218:/// %p1 = arith.addi %b, %f : index
        -: 3219:/// %1 = vector.transfer_read %t[%p0, %p1], %cst {in_bounds = [true, true]}
        -: 3220:///     : tensor<?x?xf32>, vector<4x5xf32>
        -: 3221:/// ```
        -: 3222:struct FoldExtractSliceIntoTransferRead
        -: 3223:    : public OpRewritePattern<TransferReadOp> {
        -: 3224:public:
        -: 3225:  using OpRewritePattern::OpRewritePattern;
        -: 3226:
function _ZNK12_GLOBAL__N_132FoldExtractSliceIntoTransferRead15matchAndRewriteEN4mlir6vector14TransferReadOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3227:  LogicalResult matchAndRewrite(TransferReadOp xferOp,
        -: 3228:                                PatternRewriter &rewriter) const override {
        -: 3229:    // TODO: support 0-d corner case.
    #####: 3230:    if (xferOp.getTransferRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3231:      return failure();
    #####: 3232:    if (xferOp.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3233:      return failure();
    #####: 3234:    if (!xferOp.getPermutationMap().isMinorIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3235:      return failure();
    #####: 3236:    if (xferOp.getMask())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3237:      return failure();
    #####: 3238:    auto extractOp = xferOp.getSource().getDefiningOp<tensor::ExtractSliceOp>();
call    0 never executed
call    1 never executed
    #####: 3239:    if (!extractOp)
branch  0 never executed
branch  1 never executed
    #####: 3240:      return failure();
    #####: 3241:    if (!extractOp.hasUnitStride())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3242:      return failure();
        -: 3243:
        -: 3244:    // Bail on illegal rank-reduction: we need to check that the rank-reduced
        -: 3245:    // dims are exactly the leading dims. I.e. the following is illegal:
        -: 3246:    // ```
        -: 3247:    //    %0 = tensor.extract_slice %t[0,0,0][2,1,4][1,1,1] :
        -: 3248:    //      tensor<2x1x4xf32> to tensor<2x4xf32>
        -: 3249:    //    %1 = vector.transfer_read %0[0,0], %cst :
        -: 3250:    //      tensor<2x4xf32>, vector<2x4xf32>
        -: 3251:    // ```
        -: 3252:    //
        -: 3253:    // Cannot fold into:
        -: 3254:    // ```
        -: 3255:    //    %0 = vector.transfer_read %t[0,0,0], %cst :
        -: 3256:    //      tensor<2x1x4xf32>, vector<2x4xf32>
        -: 3257:    // ```
        -: 3258:    // For this, check the trailing `vectorRank` dims of the extract_slice
        -: 3259:    // result tensor match the trailing dims of the inferred result tensor.
    #####: 3260:    if (!areAllRankReducedLeadingDim(extractOp, extractOp.getType().getRank()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3261:      return failure();
        -: 3262:
    #####: 3263:    int64_t rankReduced =
    #####: 3264:        extractOp.getSourceType().getRank() - extractOp.getType().getRank();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3265:
    #####: 3266:    SmallVector<Value> newIndices;
        -: 3267:    // In case this is a rank-reducing ExtractSliceOp, copy rank-reduced
        -: 3268:    // indices first.
    #####: 3269:    for (int64_t i = 0; i < rankReduced; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 3270:      OpFoldResult offset = extractOp.getMixedOffsets()[i];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3271:      newIndices.push_back(getValueOrCreateConstantIndexOp(
call    0 never executed
call    1 never executed
        -: 3272:          rewriter, extractOp.getLoc(), offset));
        -: 3273:    }
    #####: 3274:    for (const auto &it : llvm::enumerate(xferOp.getIndices())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3275:      OpFoldResult offset =
    #####: 3276:          extractOp.getMixedOffsets()[it.index() + rankReduced];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3277:      newIndices.push_back(rewriter.create<arith::AddIOp>(
call    0 never executed
    #####: 3278:          xferOp->getLoc(), it.value(),
call    0 never executed
    #####: 3279:          getValueOrCreateConstantIndexOp(rewriter, extractOp.getLoc(),
call    0 never executed
    #####: 3280:                                          offset)));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3281:    }
    #####: 3282:    SmallVector<bool> inBounds(xferOp.getTransferRank(), true);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3283:    rewriter.replaceOpWithNewOp<TransferReadOp>(
    #####: 3284:        xferOp, xferOp.getVectorType(), extractOp.getSource(), newIndices,
call    0 never executed
    #####: 3285:        xferOp.getPadding(), ArrayRef<bool>{inBounds});
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3286:
    #####: 3287:    return success();
branch  0 never executed
branch  1 never executed
        -: 3288:  }
        -: 3289:};
        -: 3290:
        -: 3291:/// Store to load forwarding for transfer operations with permuation maps.
        -: 3292:/// Even if the permutation maps are different we can still propagate the store
        -: 3293:/// into the load if the size of the dimensions read and written match. Then we
        -: 3294:/// can replace the transfer_read + transfer_write by vector.broadcast and
        -: 3295:/// vector.transpose.
        -: 3296:/// Example:
        -: 3297:/// ```
        -: 3298:/// %w0 = vector.transfer_write %v0, %arg0[%c0, %c0, %c0]
        -: 3299:///  {in_bounds = [true, true],
        -: 3300:///   permutation_map = affine_map<(d0, d1, d2) -> (d2, d1)>} :
        -: 3301:///   vector<4x1xf32>, tensor<4x4x4xf32>
        -: 3302:///  %r = vector.transfer_read %w0[%c0, %c0, %c0], %cf0
        -: 3303:///   {in_bounds = [true, true, true, true],
        -: 3304:///   permutation_map = affine_map<(d0, d1, d2) -> (d1, 0, d2, 0)>} :
        -: 3305:///   tensor<4x4x4xf32>, vector<1x100x4x5xf32>
        -: 3306:/// ```
        -: 3307:/// To:
        -: 3308:/// ```
        -: 3309:/// %0 = vector.broadcast %arg1 : vector<4x1xf32> to vector<100x5x4x1xf32>
        -: 3310:/// %r = vector.transpose %0, [3, 0, 2, 1] :
        -: 3311:///   vector<100x5x4x1xf32> to vector<1x100x4x5xf32>
        -: 3312:/// ```
        -: 3313:struct TransferReadAfterWriteToBroadcast
        -: 3314:    : public OpRewritePattern<TransferReadOp> {
        -: 3315:  using OpRewritePattern::OpRewritePattern;
        -: 3316:
function _ZNK12_GLOBAL__N_133TransferReadAfterWriteToBroadcast15matchAndRewriteEN4mlir6vector14TransferReadOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3317:  LogicalResult matchAndRewrite(TransferReadOp readOp,
        -: 3318:                                PatternRewriter &rewriter) const override {
    #####: 3319:    if (readOp.hasOutOfBoundsDim() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3320:        !readOp.getShapedType().isa<RankedTensorType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3321:      return failure();
    #####: 3322:    auto defWrite = readOp.getSource().getDefiningOp<vector::TransferWriteOp>();
call    0 never executed
call    1 never executed
    #####: 3323:    if (!defWrite)
branch  0 never executed
branch  1 never executed
    #####: 3324:      return failure();
        -: 3325:
    #####: 3326:    SmallVector<int64_t> readDims = readOp.getTransferChunkAccessed();
call    0 never executed
    #####: 3327:    Value vec;
    #####: 3328:    if (readOp.getIndices() == defWrite.getIndices() &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 3329:        readOp.getMask() == defWrite.getMask()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3330:      SmallVector<int64_t> writeDims = defWrite.getTransferChunkAccessed();
call    0 never executed
        -: 3331:      // TODO: If the writeDim is a superset of the read dims we could do an
        -: 3332:      // extract_strided_slice.
    #####: 3333:      if (writeDims == readDims)
branch  0 never executed
branch  1 never executed
    #####: 3334:        vec = defWrite.getVector();
call    0 never executed
        -: 3335:    }
        -: 3336:    // TODO: loop through the chain of transfer_write if we can prove that they
        -: 3337:    // don't overlap with the transfer_read. This requires improving
        -: 3338:    // `isDisjointTransferIndices` helper.
    #####: 3339:    if (!vec)
branch  0 never executed
branch  1 never executed
    #####: 3340:      return failure();
    #####: 3341:    SmallVector<unsigned> permutation;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3342:    AffineMap readMap = compressUnusedDims(readOp.getPermutationMap());
call    0 never executed
call    1 never executed
    #####: 3343:    AffineMap writeMap = compressUnusedDims(defWrite.getPermutationMap());
call    0 never executed
call    1 never executed
    #####: 3344:    AffineMap map = readMap.compose(writeMap);
call    0 never executed
    #####: 3345:    if (map.getNumResults() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3346:      return failure();
        -: 3347:    // Calculate the permuation to apply to go from the vector stored to the
        -: 3348:    // vector read.
    #####: 3349:    if (!map.isPermutationOfMinorIdentityWithBroadcasting(permutation))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3350:      return failure();
        -: 3351:
    #####: 3352:    Location loc = readOp.getLoc();
call    0 never executed
        -: 3353:    // Calculate the broadcast shape by applying the reverse permuation to the
        -: 3354:    // final shape we want.
    #####: 3355:    ArrayRef<int64_t> destShape = readOp.getVectorType().getShape();
call    0 never executed
call    1 never executed
    #####: 3356:    SmallVector<int64_t> broadcastShape(destShape.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3357:    for (const auto &pos : llvm::enumerate(permutation))
branch  0 never executed
branch  1 never executed
    #####: 3358:      broadcastShape[pos.value()] = destShape[pos.index()];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3359:    VectorType broadcastedType = VectorType::get(
    #####: 3360:        broadcastShape, defWrite.getVectorType().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3361:    vec = rewriter.create<vector::BroadcastOp>(loc, broadcastedType, vec);
call    0 never executed
call    1 never executed
    #####: 3362:    SmallVector<int64_t> transposePerm(permutation.begin(), permutation.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3363:    rewriter.replaceOpWithNewOp<vector::TransposeOp>(readOp, vec,
    #####: 3364:                                                     transposePerm);
call    0 never executed
    #####: 3365:    return success();
branch  0 never executed
branch  1 never executed
        -: 3366:  }
        -: 3367:};
        -: 3368:} // namespace
        -: 3369:
function _ZN4mlir6vector14TransferReadOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 3370:void TransferReadOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 3371:                                                 MLIRContext *context) {
     1235: 3372:  results
        -: 3373:      .add<FoldExtractSliceIntoTransferRead, TransferReadAfterWriteToBroadcast>(
     1235: 3374:          context);
call    0 returned 100%
     1235: 3375:}
        -: 3376:
        -: 3377://===----------------------------------------------------------------------===//
        -: 3378:// TransferWriteOp
        -: 3379://===----------------------------------------------------------------------===//
        -: 3380:
        -: 3381:/// 1. Builder with type inference.
function _ZN4mlir6vector15TransferWriteOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeENS_13AffineMapAttrES6_NS_9ArrayAttrE called 5337 returned 100% blocks executed 100%
     5337: 3382:void TransferWriteOp::build(OpBuilder &builder, OperationState &result,
        -: 3383:                            Value vector, Value dest, ValueRange indices,
        -: 3384:                            AffineMapAttr permutationMapAttr,
        -: 3385:                            /*optional*/ Value mask,
        -: 3386:                            /*optional*/ ArrayAttr inBoundsAttr) {
     5337: 3387:  Type resultType = dest.getType().dyn_cast<RankedTensorType>();
call    0 returned 100%
     5337: 3388:  build(builder, result, resultType, vector, dest, indices, permutationMapAttr,
call    0 returned 100%
        -: 3389:        mask, inBoundsAttr);
     5337: 3390:}
        -: 3391:
        -: 3392:/// 2. Builder with type inference that sets an empty mask (variant with attrs).
function _ZN4mlir6vector15TransferWriteOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeENS_13AffineMapAttrENS_9ArrayAttrE called 2645 returned 100% blocks executed 100%
    2645*: 3393:void TransferWriteOp::build(OpBuilder &builder, OperationState &result,
        -: 3394:                            Value vector, Value dest, ValueRange indices,
        -: 3395:                            AffineMapAttr permutationMapAttr,
        -: 3396:                            /*optional*/ ArrayAttr inBoundsAttr) {
    2645*: 3397:  build(builder, result, vector, dest, indices, permutationMapAttr,
call    0 never executed
call    1 never executed
call    2 returned 100%
        -: 3398:        /*mask=*/Value(), inBoundsAttr);
     2645: 3399:}
        -: 3400:
        -: 3401:/// 3. Builder with type inference that sets an empty mask (variant without
        -: 3402:/// attrs)
function _ZN4mlir6vector15TransferWriteOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeENS_9AffineMapEN4llvm8OptionalINS9_8ArrayRefIbEEEE called 0 returned 0% blocks executed 0%
    #####: 3403:void TransferWriteOp::build(OpBuilder &builder, OperationState &result,
        -: 3404:                            Value vector, Value dest, ValueRange indices,
        -: 3405:                            AffineMap permutationMap,
        -: 3406:                            Optional<ArrayRef<bool>> inBounds) {
    #####: 3407:  auto permutationMapAttr = AffineMapAttr::get(permutationMap);
call    0 never executed
    #####: 3408:  auto inBoundsAttr = (inBounds && !inBounds.value().empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3409:                          ? builder.getBoolArrayAttr(inBounds.value())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3410:                          : ArrayAttr();
    #####: 3411:  build(builder, result, vector, dest, indices, permutationMapAttr,
call    0 never executed
        -: 3412:        /*mask=*/Value(), inBoundsAttr);
    #####: 3413:}
        -: 3414:
        -: 3415:/// 4. Builder with type inference that sets an empty mask and sets permutation
        -: 3416:///    map to 'getMinorIdentityMap'.
function _ZN4mlir6vector15TransferWriteOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeEN4llvm8OptionalINS8_8ArrayRefIbEEEE called 0 returned 0% blocks executed 0%
    #####: 3417:void TransferWriteOp::build(OpBuilder &builder, OperationState &result,
        -: 3418:                            Value vector, Value dest, ValueRange indices,
        -: 3419:                            Optional<ArrayRef<bool>> inBounds) {
    #####: 3420:  auto vectorType = vector.getType().cast<VectorType>();
call    0 never executed
    #####: 3421:  AffineMap permutationMap = getTransferMinorIdentityMap(
    #####: 3422:      dest.getType().cast<ShapedType>(), vectorType);
call    0 never executed
call    1 never executed
    #####: 3423:  build(builder, result, vector, dest, indices, permutationMap, inBounds);
call    0 never executed
    #####: 3424:}
        -: 3425:
function _ZN4mlir6vector15TransferWriteOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1330882 returned 100% blocks executed 54%
  1330882: 3426:ParseResult TransferWriteOp::parse(OpAsmParser &parser,
        -: 3427:                                   OperationState &result) {
  1330882: 3428:  auto &builder = parser.getBuilder();
call    0 returned 100%
  1330882: 3429:  SMLoc typesLoc;
  1330882: 3430:  OpAsmParser::UnresolvedOperand vectorInfo, sourceInfo;
call    0 returned 100%
  1330882: 3431:  SmallVector<OpAsmParser::UnresolvedOperand, 8> indexInfo;
call    0 returned 100%
  1330882: 3432:  SmallVector<Type, 2> types;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1330882: 3433:  OpAsmParser::UnresolvedOperand maskInfo;
 2661764*: 3434:  if (parser.parseOperand(vectorInfo) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
 3992646*: 3435:      parser.parseOperand(sourceInfo) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
 1330882*: 3436:      parser.parseOperandList(indexInfo, OpAsmParser::Delimiter::Square))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3437:    return failure();
  1330882: 3438:  ParseResult hasMask = parser.parseOptionalComma();
call    0 returned 100%
 1330882*: 3439:  if (hasMask.succeeded() && parser.parseOperand(maskInfo))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3440:    return failure();
 1330882*: 3441:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
 1330882*: 3442:      parser.getCurrentLocation(&typesLoc) || parser.parseColonTypeList(types))
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 3443:    return failure();
  1330882: 3444:  if (types.size() != 2)
branch  0 taken 0%
branch  1 taken 100%
    #####: 3445:    return parser.emitError(typesLoc, "requires two types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1330882: 3446:  auto indexType = builder.getIndexType();
call    0 returned 100%
  1330882: 3447:  VectorType vectorType = types[0].dyn_cast<VectorType>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  1330882: 3448:  if (!vectorType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3449:    return parser.emitError(typesLoc, "requires vector type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1330882: 3450:  ShapedType shapedType = types[1].dyn_cast<ShapedType>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  2661764: 3451:  if (!shapedType || !shapedType.isa<MemRefType, RankedTensorType>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 3452:    return parser.emitError(typesLoc, "requires memref or ranked tensor type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  1330882: 3453:  auto permutationAttrName = TransferWriteOp::getPermutationMapAttrStrName();
call    0 returned 100%
  1330882: 3454:  auto attr = result.attributes.get(permutationAttrName);
call    0 returned 100%
  1330882: 3455:  if (!attr) {
branch  0 taken 61%
branch  1 taken 39%
   811099: 3456:    auto permMap = getTransferMinorIdentityMap(shapedType, vectorType);
call    0 returned 100%
   811099: 3457:    result.attributes.set(permutationAttrName, AffineMapAttr::get(permMap));
call    0 returned 100%
call    1 returned 100%
        -: 3458:  }
 2661764*: 3459:  if (parser.resolveOperand(vectorInfo, vectorType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 2661764*: 3460:      parser.resolveOperand(sourceInfo, shapedType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
 1330882*: 3461:      parser.resolveOperands(indexInfo, indexType, result.operands))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####: 3462:    return failure();
  1330882: 3463:  if (hasMask.succeeded()) {
branch  0 taken 0%
branch  1 taken 100%
    #####: 3464:    if (shapedType.getElementType().dyn_cast<VectorType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3465:      return parser.emitError(
call    0 never executed
call    1 never executed
    #####: 3466:          maskInfo.location, "does not support masks with vector element type");
call    0 never executed
call    1 never executed
    #####: 3467:    auto maskType = VectorType::get(vectorType.getShape(), builder.getI1Type());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3468:    if (parser.resolveOperand(maskInfo, maskType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3469:      return failure();
        -: 3470:  }
  1330882: 3471:  result.addAttribute(TransferWriteOp::getOperandSegmentSizeAttr(),
call    0 returned 100%
  1330882: 3472:                      builder.getDenseI32ArrayAttr(
  1330882: 3473:                          {1, 1, static_cast<int32_t>(indexInfo.size()),
  1330882: 3474:                           static_cast<int32_t>(hasMask.succeeded())}));
call    0 returned 100%
  1330882: 3475:  return failure(shapedType.isa<RankedTensorType>() &&
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
  1330882: 3476:                 parser.addTypeToList(shapedType, result.types));
call    0 returned 100%
        -: 3477:}
        -: 3478:
function _ZN4mlir6vector15TransferWriteOp5printERNS_12OpAsmPrinterE called 1885045 returned 100% blocks executed 84%
  1885045: 3479:void TransferWriteOp::print(OpAsmPrinter &p) {
  7540180: 3480:  p << " " << getVector() << ", " << getSource() << "[" << getIndices() << "]";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
  1885045: 3481:  if (getMask())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3482:    p << ", " << getMask();
call    0 never executed
call    1 never executed
call    2 never executed
  1885045: 3483:  printTransferAttrs(p, *this);
call    0 returned 100%
call    1 returned 100%
  5655135: 3484:  p << " : " << getVectorType() << ", " << getShapedType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  1885045: 3485:}
        -: 3486:
function _ZN4mlir6vector15TransferWriteOp6verifyEv called 51867176 returned 100% blocks executed 58%
 51867176: 3487:LogicalResult TransferWriteOp::verify() {
        -: 3488:  // Consistency of elemental types in shape and vector.
 51867176: 3489:  ShapedType shapedType = getShapedType();
call    0 returned 100%
 51867175: 3490:  VectorType vectorType = getVectorType();
call    0 returned 100%
 51867176: 3491:  VectorType maskType = getMaskType();
call    0 returned 100%
 51867174: 3492:  auto permutationMap = getPermutationMap();
call    0 returned 100%
        -: 3493:
 51867174: 3494:  if (llvm::size(getIndices()) != shapedType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3495:    return emitOpError("requires ") << shapedType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 3496:
        -: 3497:  // We do not allow broadcast dimensions on TransferWriteOps for the moment,
        -: 3498:  // as the semantics is unclear. This can be revisited later if necessary.
 51867175: 3499:  if (hasBroadcastDim())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3500:    return emitOpError("should not have broadcast dimensions");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3501:
 53091292: 3502:  if (failed(verifyTransferOp(cast<VectorTransferOpInterface>(getOperation()),
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
call    2 returned 100%
call    3 returned 100%
        -: 3503:                              shapedType, vectorType, maskType, permutationMap,
103734350: 3504:                              getInBounds() ? *getInBounds() : ArrayAttr())))
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 3505:    return failure();
        -: 3506:
 51867175: 3507:  return verifyPermutationMap(permutationMap,
51867175*: 3508:                              [&](Twine t) { return emitOpError(t); });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
        -: 3509:}
        -: 3510:
        -: 3511:/// Fold:
        -: 3512:/// ```
        -: 3513:///    %t1 = ...
        -: 3514:///    %v = vector.transfer_read %t0[%c0...], {in_bounds = [true...]} :
        -: 3515:///      tensor<static_sizesxf32>, vector<static_sizesxf32>
        -: 3516:///    %t2 = vector.transfer_write %v, %t1[%c0...] {in_bounds = [true...]} :
        -: 3517:///      vector<static_sizesxf32>, tensor<static_sizesxf32>
        -: 3518:/// ```
        -: 3519:///
        -: 3520:/// into:
        -: 3521:///
        -: 3522:/// ```
        -: 3523:///    %t0
        -: 3524:/// ```
        -: 3525:///
        -: 3526:/// The producer of t1 may or may not be DCE'd depending on whether it is a
        -: 3527:/// block argument or has side effects.
        -: 3528:static LogicalResult foldReadInitWrite(TransferWriteOp write,
        -: 3529:                                       ArrayRef<Attribute>,
        -: 3530:                                       SmallVectorImpl<OpFoldResult> &results) {
        -: 3531:  // TODO: support 0-d corner case.
        -: 3532:  if (write.getTransferRank() == 0)
        -: 3533:    return failure();
        -: 3534:  auto rankedTensorType =
        -: 3535:      write.getSource().getType().dyn_cast<RankedTensorType>();
        -: 3536:  // If not operating on tensors, bail.
        -: 3537:  if (!rankedTensorType)
        -: 3538:    return failure();
        -: 3539:  // If no read, bail.
        -: 3540:  auto read = write.getVector().getDefiningOp<vector::TransferReadOp>();
        -: 3541:  if (!read)
        -: 3542:    return failure();
        -: 3543:  // TODO: support 0-d corner case.
        -: 3544:  if (read.getTransferRank() == 0)
        -: 3545:    return failure();
        -: 3546:  // For now, only accept minor identity. Future: composition is minor identity.
        -: 3547:  if (!read.getPermutationMap().isMinorIdentity() ||
        -: 3548:      !write.getPermutationMap().isMinorIdentity())
        -: 3549:    return failure();
        -: 3550:  // Bail on mismatching ranks.
        -: 3551:  if (read.getTransferRank() != write.getTransferRank())
        -: 3552:    return failure();
        -: 3553:  // Bail on potential out-of-bounds accesses.
        -: 3554:  if (read.hasOutOfBoundsDim() || write.hasOutOfBoundsDim())
        -: 3555:    return failure();
        -: 3556:  // Tensor types must be the same.
        -: 3557:  if (read.getSource().getType() != rankedTensorType)
        -: 3558:    return failure();
        -: 3559:  // Vector types must be the same.
        -: 3560:  if (read.getVectorType() != write.getVectorType())
        -: 3561:    return failure();
        -: 3562:  // Vector and Tensor shapes must match.
        -: 3563:  if (read.getVectorType().getShape() != rankedTensorType.getShape())
        -: 3564:    return failure();
        -: 3565:  // If any index is nonzero.
function _ZZL17foldReadInitWriteN4mlir6vector15TransferWriteOpEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEENKUlNS_5ValueEE_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3566:  auto isNotConstantZero = [](Value v) {
    #####: 3567:    auto cstOp = v.getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
    #####: 3568:    return !cstOp || cstOp.value() != 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3569:  };
        -: 3570:  if (llvm::any_of(read.getIndices(), isNotConstantZero) ||
        -: 3571:      llvm::any_of(write.getIndices(), isNotConstantZero))
        -: 3572:    return failure();
        -: 3573:  // Success.
        -: 3574:  results.push_back(read.getSource());
        -: 3575:  return success();
        -: 3576:}
        -: 3577:
function _ZL17checkSameValueWARN4mlir6vector14TransferReadOpENS0_15TransferWriteOpE called 0 returned 0% blocks executed 0%
    #####: 3578:static bool checkSameValueWAR(vector::TransferReadOp read,
        -: 3579:                              vector::TransferWriteOp write) {
    #####: 3580:  return read.getSource() == write.getSource() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3581:         read.getIndices() == write.getIndices() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3582:         read.getPermutationMap() == write.getPermutationMap() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3583:         read.getVectorType() == write.getVectorType() && !read.getMask() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 3584:         !write.getMask();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3585:}
        -: 3586:/// Fold transfer_write write after read:
        -: 3587:/// ```
        -: 3588:///    %t0 = ...
        -: 3589:///    %v = vector.transfer_read %t0[%c0...] :
        -: 3590:///      tensor<static_sizesxf32>, vector<static_sizesxf32>
        -: 3591:///    %t1 = vector.transfer_write %v, %t0[%c0...] :
        -: 3592:///      vector<static_sizesxf32>, tensor<static_sizesxf32>
        -: 3593:/// ```
        -: 3594:///
        -: 3595:/// into:
        -: 3596:///
        -: 3597:/// ```
        -: 3598:///    %t0
        -: 3599:/// ```
function _ZL7foldWARN4mlir6vector15TransferWriteOpERN4llvm15SmallVectorImplINS_12OpFoldResultEEE called 471516 returned 100% blocks executed 59%
   471516: 3600:static LogicalResult foldWAR(TransferWriteOp write,
        -: 3601:                             SmallVectorImpl<OpFoldResult> &results) {
   471516: 3602:  if (!write.getSource().getType().isa<RankedTensorType>())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 70% (fallthrough)
branch  4 taken 30%
   328322: 3603:    return failure();
   143194: 3604:  auto read = write.getVector().getDefiningOp<vector::TransferReadOp>();
call    0 returned 100%
call    1 returned 100%
   143194: 3605:  if (!read)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   143194: 3606:    return failure();
        -: 3607:
    #####: 3608:  if (!checkSameValueWAR(read, write))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3609:    return failure();
    #####: 3610:  results.push_back(read.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3611:  return success();
        -: 3612:}
        -: 3613:
function _ZN4mlir6vector15TransferWriteOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 471516 returned 100% blocks executed 83%
   471516: 3614:LogicalResult TransferWriteOp::fold(ArrayRef<Attribute> operands,
        -: 3615:                                    SmallVectorImpl<OpFoldResult> &results) {
   471516: 3616:  if (succeeded(foldReadInitWrite(*this, operands, results)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3617:    return success();
   471516: 3618:  if (succeeded(foldWAR(*this, results)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3619:    return success();
   471516: 3620:  if (succeeded(foldTransferInBoundsAttribute(*this)))
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
    12732: 3621:    return success();
   458784: 3622:  return memref::foldMemRefCast(*this);
call    0 returned 100%
        -: 3623:}
        -: 3624:
function _ZN4mlir6vector15TransferWriteOp17getShapeForUnrollEv called 12630 returned 100% blocks executed 88%
    12630: 3625:Optional<SmallVector<int64_t, 4>> TransferWriteOp::getShapeForUnroll() {
    25260: 3626:  return llvm::to_vector<4>(getVectorType().getShape());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -: 3627:}
        -: 3628:
function _ZN4mlir6vector15TransferWriteOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 650881 returned 100% blocks executed 100%
   650881: 3629:void TransferWriteOp::getEffects(
        -: 3630:    SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>>
        -: 3631:        &effects) {
   650881: 3632:  if (getShapedType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 77% (fallthrough)
branch  3 taken 23%
  2016512: 3633:    effects.emplace_back(MemoryEffects::Write::get(), getSource(),
  1008256: 3634:                         SideEffects::DefaultResource::get());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   650881: 3635:}
        -: 3636:
        -: 3637:namespace {
        -: 3638:/// Remove dead transfer write from the SSA chain so that it an be eliminated by
        -: 3639:/// DCE
        -: 3640:/// ```
        -: 3641:///  %w0 = vector.transfer_write %v0, %arg0[%c1, %c0] {in_bounds = [true, true]}
        -: 3642:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3643:///  %w1 = vector.transfer_write %v0, %w0[%c2, %c0] {in_bounds = [true, true]}
        -: 3644:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3645:///  %w2 = vector.transfer_write %v1, %w1[%c1, %c0] {in_bounds = [true, true]}
        -: 3646:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3647:/// ```
        -: 3648:///
        -: 3649:/// into:
        -: 3650:///
        -: 3651:/// ```
        -: 3652:///  %w0 = vector.transfer_write %v0, %arg0[%c1, %c0] {in_bounds = [true, true]}
        -: 3653:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3654:///  %w1 = vector.transfer_write %v0, %arg0[%c2, %c0] {in_bounds = [true, true]}
        -: 3655:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3656:///  %w2 = vector.transfer_write %v1, %w1[%c1, %c0] {in_bounds = [true, true]}
        -: 3657:///    : vector<1x4xf32>, tensor<4x4xf32>
        -: 3658:/// ```
        -: 3659:///
        -: 3660:/// `%w0 = vector.transfer_write` op will be removed by DCE if it doesn't have
        -: 3661:/// any other uses.
        -: 3662:class FoldWaw final : public OpRewritePattern<TransferWriteOp> {
        -: 3663:public:
        -: 3664:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_17FoldWaw15matchAndRewriteEN4mlir6vector15TransferWriteOpERNS1_15PatternRewriterE called 7186 returned 100% blocks executed 19%
     7186: 3665:  LogicalResult matchAndRewrite(TransferWriteOp writeOp,
        -: 3666:                                PatternRewriter &rewriter) const override {
     7186: 3667:    if (!writeOp.getShapedType().isa<RankedTensorType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     7186: 3668:      return failure();
    #####: 3669:    vector::TransferWriteOp writeToModify = writeOp;
        -: 3670:
    #####: 3671:    auto defWrite =
    #####: 3672:        writeOp.getSource().getDefiningOp<vector::TransferWriteOp>();
call    0 never executed
call    1 never executed
    #####: 3673:    while (defWrite) {
branch  0 never executed
branch  1 never executed
    #####: 3674:      if (checkSameValueWAW(writeOp, defWrite)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3675:        writeToModify.getSourceMutable().assign(defWrite.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3676:        return success();
        -: 3677:      }
    #####: 3678:      if (!isDisjointTransferIndices(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3679:              cast<VectorTransferOpInterface>(defWrite.getOperation()),
        -: 3680:              cast<VectorTransferOpInterface>(writeOp.getOperation())))
        -: 3681:        break;
        -: 3682:      // If the previous write op doesn't have any other use we an safely look
        -: 3683:      // at the previous store to see if it can be removed.
    #####: 3684:      if (!defWrite->hasOneUse())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3685:        break;
    #####: 3686:      writeToModify = defWrite;
    #####: 3687:      defWrite = defWrite.getSource().getDefiningOp<vector::TransferWriteOp>();
call    0 never executed
call    1 never executed
        -: 3688:    }
    #####: 3689:    return failure();
        -: 3690:  }
        -: 3691:};
        -: 3692:
        -: 3693:/// Fold tensor.insert_slice into vector.transfer_write if the transfer_write
        -: 3694:/// could directly write to the insert_slice's destination. E.g.:
        -: 3695:///
        -: 3696:/// ```
        -: 3697:/// %0 = vector.transfer_write %v, %t1[%c0, %c0] {in_bounds = [true, true]}
        -: 3698:///     : vector<4x5xf32>, tensor<4x5xf32>
        -: 3699:/// %1 = tensor.insert_slice %0 into %t2[%a, %b] [4, 5] [1, 1]
        -: 3700:///     : tensor<4x5xf32> into tensor<?x?xf32>
        -: 3701:/// ```
        -: 3702:/// is rewritten to:
        -: 3703:/// ```
        -: 3704:/// %1 = vector.transfer_write %v, %t2[%a, %b] {in_bounds = [true, true]}
        -: 3705:///     : vector<4x5xf32>, tensor<?x?xf32>
        -: 3706:/// ```
        -: 3707:struct FoldInsertSliceIntoTransferWrite
        -: 3708:    : public OpRewritePattern<tensor::InsertSliceOp> {
        -: 3709:public:
        -: 3710:  using OpRewritePattern::OpRewritePattern;
        -: 3711:
function _ZNK12_GLOBAL__N_132FoldInsertSliceIntoTransferWrite15matchAndRewriteEN4mlir6tensor13InsertSliceOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3712:  LogicalResult matchAndRewrite(tensor::InsertSliceOp insertOp,
        -: 3713:                                PatternRewriter &rewriter) const override {
    #####: 3714:    if (!insertOp.hasUnitStride())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3715:      return failure();
        -: 3716:
    #####: 3717:    auto xferOp = insertOp.getSource().getDefiningOp<TransferWriteOp>();
call    0 never executed
call    1 never executed
    #####: 3718:    if (!xferOp)
branch  0 never executed
branch  1 never executed
    #####: 3719:      return failure();
        -: 3720:    // TODO: support 0-d corner case.
    #####: 3721:    if (xferOp.getTransferRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3722:      return failure();
        -: 3723:
    #####: 3724:    if (xferOp.hasOutOfBoundsDim())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3725:      return failure();
    #####: 3726:    if (xferOp.getVectorType().getRank() != xferOp.getShapedType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3727:      return failure();
    #####: 3728:    if (xferOp.getMask())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3729:      return failure();
        -: 3730:    // Fold only if the TransferWriteOp completely overwrites the `source` with
        -: 3731:    // a vector. I.e., the result of the TransferWriteOp is a new tensor whose
        -: 3732:    // content is the data of the vector.
    #####: 3733:    if (!llvm::equal(xferOp.getVectorType().getShape(),
call    0 never executed
call    1 never executed
    #####: 3734:                     xferOp.getShapedType().getShape()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3735:      return failure();
    #####: 3736:    if (!xferOp.getPermutationMap().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3737:      return failure();
        -: 3738:
        -: 3739:    // Bail on illegal rank-reduction: we need to check that the rank-reduced
        -: 3740:    // dims are exactly the leading dims. I.e. the following is illegal:
        -: 3741:    // ```
        -: 3742:    //    %0 = vector.transfer_write %v, %t[0,0], %cst :
        -: 3743:    //      vector<2x4xf32>, tensor<2x4xf32>
        -: 3744:    //    %1 = tensor.insert_slice %0 into %tt[0,0,0][2,1,4][1,1,1] :
        -: 3745:    //      tensor<2x4xf32> into tensor<2x1x4xf32>
        -: 3746:    // ```
        -: 3747:    //
        -: 3748:    // Cannot fold into:
        -: 3749:    // ```
        -: 3750:    //    %0 = vector.transfer_write %v, %t[0,0,0], %cst :
        -: 3751:    //      vector<2x4xf32>, tensor<2x1x4xf32>
        -: 3752:    // ```
        -: 3753:    // For this, check the trailing `vectorRank` dims of the insert_slice result
        -: 3754:    // tensor match the trailing dims of the inferred result tensor.
    #####: 3755:    int64_t rankReduced =
    #####: 3756:        insertOp.getType().getRank() - insertOp.getSourceType().getRank();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3757:    int64_t vectorRank = xferOp.getVectorType().getRank();
call    0 never executed
call    1 never executed
    #####: 3758:    RankedTensorType inferredSourceTensorType =
        -: 3759:        tensor::ExtractSliceOp::inferResultType(
    #####: 3760:            insertOp.getType(), insertOp.getMixedOffsets(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3761:            insertOp.getMixedSizes(), insertOp.getMixedStrides());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 3762:    auto actualSourceTensorShape = insertOp.getSourceType().getShape();
call    0 never executed
call    1 never executed
    #####: 3763:    if (rankReduced > 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3764:        actualSourceTensorShape.take_back(vectorRank) !=
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3765:            inferredSourceTensorType.getShape().take_back(vectorRank))
call    0 never executed
    #####: 3766:      return failure();
        -: 3767:
    #####: 3768:    SmallVector<Value> indices = getValueOrCreateConstantIndexOp(
    #####: 3769:        rewriter, insertOp.getLoc(), insertOp.getMixedOffsets());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3770:    SmallVector<bool> inBounds(xferOp.getTransferRank(), true);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3771:    rewriter.replaceOpWithNewOp<TransferWriteOp>(insertOp, xferOp.getVector(),
call    0 never executed
    #####: 3772:                                                 insertOp.getDest(), indices,
call    0 never executed
    #####: 3773:                                                 ArrayRef<bool>{inBounds});
call    0 never executed
call    1 never executed
    #####: 3774:    return success();
branch  0 never executed
branch  1 never executed
        -: 3775:  }
        -: 3776:};
        -: 3777:
        -: 3778:/// Rewrite tensor::ExtractSliceOp(vector::TransferWriteOp) to
        -: 3779:/// vector::TransferWriteOp(tensor::ExtractSliceOp) if the full slice is
        -: 3780:/// overwritten and inserted into another tensor. After this rewrite, the
        -: 3781:/// operations bufferize in-place since all of them work on the same slice.
        -: 3782:///
        -: 3783:/// For example:
        -: 3784:/// ```mlir
        -: 3785:///   %0 = vector.transfer_write %vec, %init_tensor[%c0, %c0]
        -: 3786:///        : vector<8x16xf32>, tensor<8x16xf32>
        -: 3787:///   %1 = tensor.extract_slice %0[0, 0] [%sz0, %sz1] [1, 1]
        -: 3788:///        : tensor<8x16xf32> to tensor<?x?xf32>
        -: 3789:///   %r = tensor.insert_slice %1 into %iter_arg[%iv0, %iv1] [%sz0, %sz1] [1, 1]
        -: 3790:///        : tensor<?x?xf32> into tensor<27x37xf32>
        -: 3791:/// ```
        -: 3792:/// folds to
        -: 3793:/// ```mlir
        -: 3794:///   %0 = tensor.extract_slice %iter_arg[%iv0, %iv1] [%sz0, %sz1] [1, 1]
        -: 3795:///        : tensor<27x37xf32> to tensor<?x?xf32>
        -: 3796:///   %1 = vector.transfer_write %vec, %0[%c0, %c0]
        -: 3797:///        : vector<8x16xf32>, tensor<?x?xf32>
        -: 3798:///   %r = tensor.insert_slice %1 into %iter_arg[%iv0, %iv1] [%sz0, %sz1] [1, 1]
        -: 3799:///        : tensor<?x?xf32> into tensor<27x37xf32>
        -: 3800:/// ```
        -: 3801:struct SwapExtractSliceOfTransferWrite
        -: 3802:    : public OpRewritePattern<tensor::InsertSliceOp> {
        -: 3803:public:
        -: 3804:  using OpRewritePattern::OpRewritePattern;
        -: 3805:
function _ZNK12_GLOBAL__N_131SwapExtractSliceOfTransferWrite15matchAndRewriteEN4mlir6tensor13InsertSliceOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3806:  LogicalResult matchAndRewrite(tensor::InsertSliceOp insertOp,
        -: 3807:                                PatternRewriter &rewriter) const override {
    #####: 3808:    if (!insertOp.hasUnitStride())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3809:      return failure();
    #####: 3810:    auto extractOp =
    #####: 3811:        insertOp.getSource().getDefiningOp<tensor::ExtractSliceOp>();
call    0 never executed
call    1 never executed
    #####: 3812:    if (!extractOp || !extractOp.hasUnitStride() || !extractOp->hasOneUse())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3813:      return failure();
    #####: 3814:    auto transferOp = extractOp.getSource().getDefiningOp<TransferWriteOp>();
call    0 never executed
call    1 never executed
    #####: 3815:    if (!transferOp || !transferOp->hasOneUse())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3816:      return failure();
        -: 3817:
        -: 3818:    // Fail if vector::TransferWriteOp or tensor::ExtractSliceOp is
        -: 3819:    // rank-reducing.
    #####: 3820:    if (insertOp.getSourceType().getRank() != transferOp.getTransferRank()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3821:      return rewriter.notifyMatchFailure(insertOp,
    #####: 3822:                                         "use-def chain is rank-reducing");
call    0 never executed
        -: 3823:    }
        -: 3824:
        -: 3825:    // Fail if tensor::ExtractSliceOp has non-zero offset.
    #####: 3826:    if (!extractOp.hasZeroOffset()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3827:      return rewriter.notifyMatchFailure(insertOp,
    #####: 3828:                                         "ExtractSliceOp has non-zero offset");
call    0 never executed
        -: 3829:    }
        -: 3830:
        -: 3831:    // Fail if tensor::TransferWriteOp has non-zero offset.
function _ZZNK12_GLOBAL__N_131SwapExtractSliceOfTransferWrite15matchAndRewriteEN4mlir6tensor13InsertSliceOpERNS1_15PatternRewriterEENKUlNS1_5ValueEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3832:    if (!llvm::all_of(transferOp.getIndices(), [](Value value) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3833:          return getConstantIntValue(value) == static_cast<int64_t>(0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 3834:        })) {
    #####: 3835:      return rewriter.notifyMatchFailure(insertOp,
    #####: 3836:                                         "TranferWriteOp has non-zero offset");
call    0 never executed
        -: 3837:    }
        -: 3838:
        -: 3839:    // Fail if tensor::ExtractSliceOp and tensor::InsertSliceOp sizes differ.
    #####: 3840:    for (const auto &it :
    #####: 3841:         llvm::zip(insertOp.getMixedSizes(), extractOp.getMixedSizes())) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 3842:      if (!isEqualConstantIntOrValue(std::get<0>(it), std::get<1>(it))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3843:        return rewriter.notifyMatchFailure(
    #####: 3844:            insertOp, "InsertSliceOp and ExtractSliceOp sizes differ");
call    0 never executed
call    1 never executed
        -: 3845:      }
        -: 3846:    }
        -: 3847:
        -: 3848:    // Fail if the vector::TransferWriteOp may not overwrite the full tensor.
    #####: 3849:    assert(transferOp.getVectorType().hasStaticShape() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 3850:           "expected vector to have a static shape");
    #####: 3851:    ArrayRef<int64_t> vectorShape = transferOp.getVectorType().getShape();
call    0 never executed
call    1 never executed
    #####: 3852:    SmallVector<int64_t> resultShape = applyPermutationMap(
    #####: 3853:        transferOp.getPermutationMap(), transferOp.getShapedType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3854:    if (transferOp.getMask() || !vectorShape.equals(resultShape)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3855:      return rewriter.notifyMatchFailure(
    #####: 3856:          insertOp, "TransferWriteOp may not write the full tensor.");
call    0 never executed
        -: 3857:    }
        -: 3858:
        -: 3859:    // Swap the tensor::ExtractSliceOp in front of the vector::TransferWriteOp.
    #####: 3860:    SmallVector<int64_t> newResultShape = applyPermutationMap(
    #####: 3861:        transferOp.getPermutationMap(), insertOp.getSourceType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3862:    SmallVector<bool> newInBounds;
branch  0 never executed
branch  1 never executed
    #####: 3863:    for (const auto &en : enumerate(newResultShape))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3864:      newInBounds.push_back(en.value() == vectorShape[en.index()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3865:    auto newExtractOp = rewriter.create<tensor::ExtractSliceOp>(
    #####: 3866:        extractOp.getLoc(), insertOp.getSourceType(), insertOp.getDest(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3867:        insertOp.getMixedOffsets(), insertOp.getMixedSizes(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3868:        insertOp.getMixedStrides());
call    0 never executed
call    1 never executed
    #####: 3869:    auto newTransferWriteOp = rewriter.create<TransferWriteOp>(
    #####: 3870:        transferOp.getLoc(), transferOp.getVector(), newExtractOp.getResult(),
call    0 never executed
    #####: 3871:        transferOp.getIndices(), transferOp.getPermutationMapAttr(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3872:        rewriter.getBoolArrayAttr(newInBounds));
call    0 never executed
call    1 never executed
function _ZZNK12_GLOBAL__N_131SwapExtractSliceOfTransferWrite15matchAndRewriteEN4mlir6tensor13InsertSliceOpERNS1_15PatternRewriterEENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3873:    rewriter.updateRootInPlace(insertOp, [&]() {
call    0 never executed
    #####: 3874:      insertOp.getSourceMutable().assign(newTransferWriteOp.getResult());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3875:    });
    #####: 3876:    return success();
branch  0 never executed
branch  1 never executed
        -: 3877:  }
        -: 3878:};
        -: 3879:
        -: 3880:} // namespace
        -: 3881:
function _ZN4mlir6vector15TransferWriteOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 3882:void TransferWriteOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 3883:                                                  MLIRContext *context) {
     1235: 3884:  results.add<FoldWaw, FoldInsertSliceIntoTransferWrite,
     1235: 3885:              SwapExtractSliceOfTransferWrite>(context);
call    0 returned 100%
     1235: 3886:}
        -: 3887:
        -: 3888://===----------------------------------------------------------------------===//
        -: 3889:// LoadOp
        -: 3890://===----------------------------------------------------------------------===//
        -: 3891:
function _ZL27verifyLoadStoreMemRefLayoutPN4mlir9OperationENS_10MemRefTypeE called 49774761 returned 100% blocks executed 44%
 49774761: 3892:static LogicalResult verifyLoadStoreMemRefLayout(Operation *op,
        -: 3893:                                                 MemRefType memRefTy) {
 49774761: 3894:  if (!isLastMemrefDimUnitStride(memRefTy))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3895:    return op->emitOpError("most minor memref dim must have unit stride");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 49774762: 3896:  return success();
        -: 3897:}
        -: 3898:
function _ZN4mlir6vector6LoadOp6verifyEv called 49745710 returned 100% blocks executed 40%
 49745710: 3899:LogicalResult vector::LoadOp::verify() {
 49745710: 3900:  VectorType resVecTy = getVectorType();
call    0 returned 100%
 49745710: 3901:  MemRefType memRefTy = getMemRefType();
call    0 returned 100%
        -: 3902:
 49745708: 3903:  if (failed(verifyLoadStoreMemRefLayout(*this, memRefTy)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3904:    return failure();
        -: 3905:
        -: 3906:  // Checks for vector memrefs.
 49745709: 3907:  Type memElemTy = memRefTy.getElementType();
call    0 returned 100%
 49745709: 3908:  if (auto memVecTy = memElemTy.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3909:    if (memVecTy != resVecTy)
branch  0 never executed
branch  1 never executed
    #####: 3910:      return emitOpError("base memref and result vector types should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3911:    memElemTy = memVecTy.getElementType();
call    0 never executed
        -: 3912:  }
        -: 3913:
 49745709: 3914:  if (resVecTy.getElementType() != memElemTy)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3915:    return emitOpError("base and result element types should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 49745709: 3916:  if (llvm::size(getIndices()) != memRefTy.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3917:    return emitOpError("requires ") << memRefTy.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 49745709: 3918:  return success();
        -: 3919:}
        -: 3920:
function _ZN4mlir6vector6LoadOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 310606 returned 100% blocks executed 57%
   310606: 3921:OpFoldResult LoadOp::fold(ArrayRef<Attribute>) {
   310606: 3922:  if (succeeded(memref::foldMemRefCast(*this)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3923:    return getResult();
call    0 never executed
call    1 never executed
   310606: 3924:  return OpFoldResult();
        -: 3925:}
        -: 3926:
        -: 3927://===----------------------------------------------------------------------===//
        -: 3928:// StoreOp
        -: 3929://===----------------------------------------------------------------------===//
        -: 3930:
function _ZN4mlir6vector7StoreOp6verifyEv called 29053 returned 100% blocks executed 40%
    29053: 3931:LogicalResult vector::StoreOp::verify() {
    29053: 3932:  VectorType valueVecTy = getVectorType();
call    0 returned 100%
    29053: 3933:  MemRefType memRefTy = getMemRefType();
call    0 returned 100%
        -: 3934:
    29053: 3935:  if (failed(verifyLoadStoreMemRefLayout(*this, memRefTy)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3936:    return failure();
        -: 3937:
        -: 3938:  // Checks for vector memrefs.
    29053: 3939:  Type memElemTy = memRefTy.getElementType();
call    0 returned 100%
    29053: 3940:  if (auto memVecTy = memElemTy.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3941:    if (memVecTy != valueVecTy)
branch  0 never executed
branch  1 never executed
    #####: 3942:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3943:          "base memref and valueToStore vector types should match");
call    0 never executed
    #####: 3944:    memElemTy = memVecTy.getElementType();
call    0 never executed
        -: 3945:  }
        -: 3946:
    29053: 3947:  if (valueVecTy.getElementType() != memElemTy)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3948:    return emitOpError("base and valueToStore element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    29053: 3949:  if (llvm::size(getIndices()) != memRefTy.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3950:    return emitOpError("requires ") << memRefTy.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    29053: 3951:  return success();
        -: 3952:}
        -: 3953:
function _ZN4mlir6vector7StoreOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 3954:LogicalResult StoreOp::fold(ArrayRef<Attribute> operands,
        -: 3955:                            SmallVectorImpl<OpFoldResult> &results) {
    #####: 3956:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 3957:}
        -: 3958:
        -: 3959://===----------------------------------------------------------------------===//
        -: 3960:// MaskedLoadOp
        -: 3961://===----------------------------------------------------------------------===//
        -: 3962:
function _ZN4mlir6vector12MaskedLoadOp6verifyEv called 42470698 returned 100% blocks executed 41%
 42470698: 3963:LogicalResult MaskedLoadOp::verify() {
 42470698: 3964:  VectorType maskVType = getMaskVectorType();
call    0 returned 100%
 42470698: 3965:  VectorType passVType = getPassThruVectorType();
call    0 returned 100%
 42470698: 3966:  VectorType resVType = getVectorType();
call    0 returned 100%
 42470698: 3967:  MemRefType memType = getMemRefType();
call    0 returned 100%
        -: 3968:
 42470698: 3969:  if (resVType.getElementType() != memType.getElementType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3970:    return emitOpError("base and result element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 42470698: 3971:  if (llvm::size(getIndices()) != memType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3972:    return emitOpError("requires ") << memType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 42470698: 3973:  if (resVType.getDimSize(0) != maskVType.getDimSize(0))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3974:    return emitOpError("expected result dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 42470698: 3975:  if (resVType != passVType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3976:    return emitOpError("expected pass_thru of same type as result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 42470698: 3977:  return success();
        -: 3978:}
        -: 3979:
        -: 3980:namespace {
        -: 3981:class MaskedLoadFolder final : public OpRewritePattern<MaskedLoadOp> {
        -: 3982:public:
        -: 3983:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_116MaskedLoadFolder15matchAndRewriteEN4mlir6vector12MaskedLoadOpERNS1_15PatternRewriterE called 8345 returned 100% blocks executed 93%
     8345: 3984:  LogicalResult matchAndRewrite(MaskedLoadOp load,
        -: 3985:                                PatternRewriter &rewriter) const override {
     8345: 3986:    switch (getMaskFormat(load.getMask())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 22%
branch  3 taken 24%
branch  4 taken 54%
branch  5 taken 0%
     1838: 3987:    case MaskFormat::AllTrue:
     1838: 3988:      rewriter.replaceOpWithNewOp<vector::LoadOp>(
     1838: 3989:          load, load.getType(), load.getBase(), load.getIndices());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1838: 3990:      return success();
     2013: 3991:    case MaskFormat::AllFalse:
     2013: 3992:      rewriter.replaceOp(load, load.getPassThru());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2013: 3993:      return success();
     4494: 3994:    case MaskFormat::Unknown:
     4494: 3995:      return failure();
        -: 3996:    }
    #####: 3997:    llvm_unreachable("Unexpected 1DMaskFormat on MaskedLoad");
call    0 never executed
        -: 3998:  }
        -: 3999:};
        -: 4000:} // namespace
        -: 4001:
function _ZN4mlir6vector12MaskedLoadOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4002:void MaskedLoadOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4003:                                               MLIRContext *context) {
     1235: 4004:  results.add<MaskedLoadFolder>(context);
call    0 returned 100%
     1235: 4005:}
        -: 4006:
function _ZN4mlir6vector12MaskedLoadOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 301886 returned 100% blocks executed 57%
   301886: 4007:OpFoldResult MaskedLoadOp::fold(ArrayRef<Attribute>) {
   301886: 4008:  if (succeeded(memref::foldMemRefCast(*this)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4009:    return getResult();
call    0 never executed
call    1 never executed
   301886: 4010:  return OpFoldResult();
        -: 4011:}
        -: 4012:
        -: 4013://===----------------------------------------------------------------------===//
        -: 4014:// MaskedStoreOp
        -: 4015://===----------------------------------------------------------------------===//
        -: 4016:
function _ZN4mlir6vector13MaskedStoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4017:LogicalResult MaskedStoreOp::verify() {
    #####: 4018:  VectorType maskVType = getMaskVectorType();
call    0 never executed
    #####: 4019:  VectorType valueVType = getVectorType();
call    0 never executed
    #####: 4020:  MemRefType memType = getMemRefType();
call    0 never executed
        -: 4021:
    #####: 4022:  if (valueVType.getElementType() != memType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4023:    return emitOpError("base and valueToStore element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4024:  if (llvm::size(getIndices()) != memType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4025:    return emitOpError("requires ") << memType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 4026:  if (valueVType.getDimSize(0) != maskVType.getDimSize(0))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4027:    return emitOpError("expected valueToStore dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4028:  return success();
        -: 4029:}
        -: 4030:
        -: 4031:namespace {
        -: 4032:class MaskedStoreFolder final : public OpRewritePattern<MaskedStoreOp> {
        -: 4033:public:
        -: 4034:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_117MaskedStoreFolder15matchAndRewriteEN4mlir6vector13MaskedStoreOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4035:  LogicalResult matchAndRewrite(MaskedStoreOp store,
        -: 4036:                                PatternRewriter &rewriter) const override {
    #####: 4037:    switch (getMaskFormat(store.getMask())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4038:    case MaskFormat::AllTrue:
    #####: 4039:      rewriter.replaceOpWithNewOp<vector::StoreOp>(
    #####: 4040:          store, store.getValueToStore(), store.getBase(), store.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4041:      return success();
    #####: 4042:    case MaskFormat::AllFalse:
    #####: 4043:      rewriter.eraseOp(store);
call    0 never executed
    #####: 4044:      return success();
    #####: 4045:    case MaskFormat::Unknown:
    #####: 4046:      return failure();
        -: 4047:    }
    #####: 4048:    llvm_unreachable("Unexpected 1DMaskFormat on MaskedStore");
call    0 never executed
        -: 4049:  }
        -: 4050:};
        -: 4051:} // namespace
        -: 4052:
function _ZN4mlir6vector13MaskedStoreOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4053:void MaskedStoreOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4054:                                                MLIRContext *context) {
     1235: 4055:  results.add<MaskedStoreFolder>(context);
call    0 returned 100%
     1235: 4056:}
        -: 4057:
function _ZN4mlir6vector13MaskedStoreOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 4058:LogicalResult MaskedStoreOp::fold(ArrayRef<Attribute> operands,
        -: 4059:                                  SmallVectorImpl<OpFoldResult> &results) {
    #####: 4060:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 4061:}
        -: 4062:
        -: 4063://===----------------------------------------------------------------------===//
        -: 4064:// GatherOp
        -: 4065://===----------------------------------------------------------------------===//
        -: 4066:
function _ZN4mlir6vector8GatherOp6verifyEv called 50837806 returned 100% blocks executed 40%
 50837806: 4067:LogicalResult GatherOp::verify() {
 50837806: 4068:  VectorType indVType = getIndexVectorType();
call    0 returned 100%
 50837806: 4069:  VectorType maskVType = getMaskVectorType();
call    0 returned 100%
 50837806: 4070:  VectorType resVType = getVectorType();
call    0 returned 100%
 50837806: 4071:  ShapedType baseType = getBaseType();
call    0 returned 100%
        -: 4072:
 50837806: 4073:  if (!baseType.isa<MemRefType, RankedTensorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4074:    return emitOpError("requires base to be a memref or ranked tensor type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4075:
 50837806: 4076:  if (resVType.getElementType() != baseType.getElementType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4077:    return emitOpError("base and result element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 50837806: 4078:  if (llvm::size(getIndices()) != baseType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4079:    return emitOpError("requires ") << baseType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 50837806: 4080:  if (resVType.getShape() != indVType.getShape())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4081:    return emitOpError("expected result dim to match indices dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 50837806: 4082:  if (resVType.getShape() != maskVType.getShape())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4083:    return emitOpError("expected result dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 50837806: 4084:  if (resVType != getPassThruVectorType())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4085:    return emitOpError("expected pass_thru of same type as result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 50837806: 4086:  return success();
        -: 4087:}
        -: 4088:
        -: 4089:namespace {
        -: 4090:class GatherFolder final : public OpRewritePattern<GatherOp> {
        -: 4091:public:
        -: 4092:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_112GatherFolder15matchAndRewriteEN4mlir6vector8GatherOpERNS1_15PatternRewriterE called 17113 returned 100% blocks executed 91%
    17113: 4093:  LogicalResult matchAndRewrite(GatherOp gather,
        -: 4094:                                PatternRewriter &rewriter) const override {
    17113: 4095:    switch (getMaskFormat(gather.getMask())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 19%
branch  3 taken 18%
branch  4 taken 63%
branch  5 taken 0%
     3281: 4096:    case MaskFormat::AllTrue:
     3281: 4097:      return failure(); // no unmasked equivalent
     3002: 4098:    case MaskFormat::AllFalse:
     3002: 4099:      rewriter.replaceOp(gather, gather.getPassThru());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3002: 4100:      return success();
    10830: 4101:    case MaskFormat::Unknown:
    10830: 4102:      return failure();
        -: 4103:    }
    #####: 4104:    llvm_unreachable("Unexpected 1DMaskFormat on GatherFolder");
call    0 never executed
        -: 4105:  }
        -: 4106:};
        -: 4107:} // namespace
        -: 4108:
function _ZN4mlir6vector8GatherOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4109:void GatherOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4110:                                           MLIRContext *context) {
     1235: 4111:  results.add<GatherFolder>(context);
call    0 returned 100%
     1235: 4112:}
        -: 4113:
        -: 4114://===----------------------------------------------------------------------===//
        -: 4115:// ScatterOp
        -: 4116://===----------------------------------------------------------------------===//
        -: 4117:
function _ZN4mlir6vector9ScatterOp6verifyEv called 43037990 returned 100% blocks executed 44%
 43037990: 4118:LogicalResult ScatterOp::verify() {
 43037990: 4119:  VectorType indVType = getIndexVectorType();
call    0 returned 100%
 43037989: 4120:  VectorType maskVType = getMaskVectorType();
call    0 returned 100%
 43037989: 4121:  VectorType valueVType = getVectorType();
call    0 returned 100%
 43037989: 4122:  MemRefType memType = getMemRefType();
call    0 returned 100%
        -: 4123:
 43037989: 4124:  if (valueVType.getElementType() != memType.getElementType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4125:    return emitOpError("base and valueToStore element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 43037989: 4126:  if (llvm::size(getIndices()) != memType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4127:    return emitOpError("requires ") << memType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
 43037989: 4128:  if (valueVType.getDimSize(0) != indVType.getDimSize(0))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4129:    return emitOpError("expected valueToStore dim to match indices dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 43037988: 4130:  if (valueVType.getDimSize(0) != maskVType.getDimSize(0))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4131:    return emitOpError("expected valueToStore dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 43037988: 4132:  return success();
        -: 4133:}
        -: 4134:
        -: 4135:namespace {
        -: 4136:class ScatterFolder final : public OpRewritePattern<ScatterOp> {
        -: 4137:public:
        -: 4138:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_113ScatterFolder15matchAndRewriteEN4mlir6vector9ScatterOpERNS1_15PatternRewriterE called 55377 returned 100% blocks executed 89%
    55377: 4139:  LogicalResult matchAndRewrite(ScatterOp scatter,
        -: 4140:                                PatternRewriter &rewriter) const override {
    55377: 4141:    switch (getMaskFormat(scatter.getMask())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 33%
branch  3 taken 14%
branch  4 taken 53%
branch  5 taken 0%
    18398: 4142:    case MaskFormat::AllTrue:
    18398: 4143:      return failure(); // no unmasked equivalent
     7741: 4144:    case MaskFormat::AllFalse:
     7741: 4145:      rewriter.eraseOp(scatter);
call    0 returned 100%
     7741: 4146:      return success();
    29238: 4147:    case MaskFormat::Unknown:
    29238: 4148:      return failure();
        -: 4149:    }
    #####: 4150:    llvm_unreachable("Unexpected 1DMaskFormat on ScatterFolder");
call    0 never executed
        -: 4151:  }
        -: 4152:};
        -: 4153:} // namespace
        -: 4154:
function _ZN4mlir6vector9ScatterOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4155:void ScatterOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4156:                                            MLIRContext *context) {
     1235: 4157:  results.add<ScatterFolder>(context);
call    0 returned 100%
     1235: 4158:}
        -: 4159:
        -: 4160://===----------------------------------------------------------------------===//
        -: 4161:// ExpandLoadOp
        -: 4162://===----------------------------------------------------------------------===//
        -: 4163:
function _ZN4mlir6vector12ExpandLoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4164:LogicalResult ExpandLoadOp::verify() {
    #####: 4165:  VectorType maskVType = getMaskVectorType();
call    0 never executed
    #####: 4166:  VectorType passVType = getPassThruVectorType();
call    0 never executed
    #####: 4167:  VectorType resVType = getVectorType();
call    0 never executed
    #####: 4168:  MemRefType memType = getMemRefType();
call    0 never executed
        -: 4169:
    #####: 4170:  if (resVType.getElementType() != memType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4171:    return emitOpError("base and result element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4172:  if (llvm::size(getIndices()) != memType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4173:    return emitOpError("requires ") << memType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 4174:  if (resVType.getDimSize(0) != maskVType.getDimSize(0))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4175:    return emitOpError("expected result dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4176:  if (resVType != passVType)
branch  0 never executed
branch  1 never executed
    #####: 4177:    return emitOpError("expected pass_thru of same type as result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4178:  return success();
        -: 4179:}
        -: 4180:
        -: 4181:namespace {
        -: 4182:class ExpandLoadFolder final : public OpRewritePattern<ExpandLoadOp> {
        -: 4183:public:
        -: 4184:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_116ExpandLoadFolder15matchAndRewriteEN4mlir6vector12ExpandLoadOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4185:  LogicalResult matchAndRewrite(ExpandLoadOp expand,
        -: 4186:                                PatternRewriter &rewriter) const override {
    #####: 4187:    switch (getMaskFormat(expand.getMask())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4188:    case MaskFormat::AllTrue:
    #####: 4189:      rewriter.replaceOpWithNewOp<vector::LoadOp>(
    #####: 4190:          expand, expand.getType(), expand.getBase(), expand.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4191:      return success();
    #####: 4192:    case MaskFormat::AllFalse:
    #####: 4193:      rewriter.replaceOp(expand, expand.getPassThru());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4194:      return success();
    #####: 4195:    case MaskFormat::Unknown:
    #####: 4196:      return failure();
        -: 4197:    }
    #####: 4198:    llvm_unreachable("Unexpected 1DMaskFormat on ExpandLoadFolder");
call    0 never executed
        -: 4199:  }
        -: 4200:};
        -: 4201:} // namespace
        -: 4202:
function _ZN4mlir6vector12ExpandLoadOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4203:void ExpandLoadOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4204:                                               MLIRContext *context) {
     1235: 4205:  results.add<ExpandLoadFolder>(context);
call    0 returned 100%
     1235: 4206:}
        -: 4207:
        -: 4208://===----------------------------------------------------------------------===//
        -: 4209:// CompressStoreOp
        -: 4210://===----------------------------------------------------------------------===//
        -: 4211:
function _ZN4mlir6vector15CompressStoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4212:LogicalResult CompressStoreOp::verify() {
    #####: 4213:  VectorType maskVType = getMaskVectorType();
call    0 never executed
    #####: 4214:  VectorType valueVType = getVectorType();
call    0 never executed
    #####: 4215:  MemRefType memType = getMemRefType();
call    0 never executed
        -: 4216:
    #####: 4217:  if (valueVType.getElementType() != memType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4218:    return emitOpError("base and valueToStore element type should match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4219:  if (llvm::size(getIndices()) != memType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4220:    return emitOpError("requires ") << memType.getRank() << " indices";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 4221:  if (valueVType.getDimSize(0) != maskVType.getDimSize(0))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4222:    return emitOpError("expected valueToStore dim to match mask dim");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4223:  return success();
        -: 4224:}
        -: 4225:
        -: 4226:namespace {
        -: 4227:class CompressStoreFolder final : public OpRewritePattern<CompressStoreOp> {
        -: 4228:public:
        -: 4229:  using OpRewritePattern::OpRewritePattern;
function _ZNK12_GLOBAL__N_119CompressStoreFolder15matchAndRewriteEN4mlir6vector15CompressStoreOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4230:  LogicalResult matchAndRewrite(CompressStoreOp compress,
        -: 4231:                                PatternRewriter &rewriter) const override {
    #####: 4232:    switch (getMaskFormat(compress.getMask())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4233:    case MaskFormat::AllTrue:
    #####: 4234:      rewriter.replaceOpWithNewOp<vector::StoreOp>(
    #####: 4235:          compress, compress.getValueToStore(), compress.getBase(),
call    0 never executed
    #####: 4236:          compress.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4237:      return success();
    #####: 4238:    case MaskFormat::AllFalse:
    #####: 4239:      rewriter.eraseOp(compress);
call    0 never executed
    #####: 4240:      return success();
    #####: 4241:    case MaskFormat::Unknown:
    #####: 4242:      return failure();
        -: 4243:    }
    #####: 4244:    llvm_unreachable("Unexpected 1DMaskFormat on CompressStoreFolder");
call    0 never executed
        -: 4245:  }
        -: 4246:};
        -: 4247:} // namespace
        -: 4248:
function _ZN4mlir6vector15CompressStoreOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4249:void CompressStoreOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4250:                                                  MLIRContext *context) {
     1235: 4251:  results.add<CompressStoreFolder>(context);
call    0 returned 100%
     1235: 4252:}
        -: 4253:
        -: 4254://===----------------------------------------------------------------------===//
        -: 4255:// ShapeCastOp
        -: 4256://===----------------------------------------------------------------------===//
        -: 4257:
        -: 4258:/// Returns true if each element of 'a' is equal to the product of a contiguous
        -: 4259:/// sequence of the elements of 'b'. Returns false otherwise.
function _ZL16isValidShapeCastN4llvm8ArrayRefIlEES1_ called 0 returned 0% blocks executed 0%
    #####: 4260:static bool isValidShapeCast(ArrayRef<int64_t> a, ArrayRef<int64_t> b) {
    #####: 4261:  unsigned rankA = a.size();
branch  0 never executed
branch  1 never executed
    #####: 4262:  unsigned rankB = b.size();
    #####: 4263:  assert(rankA < rankB);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4264:
        -: 4265:  unsigned i = 0;
        -: 4266:  unsigned j = 0;
    #####: 4267:  while (i < rankA && j < rankB) {
branch  0 never executed
branch  1 never executed
    #####: 4268:    int64_t dimA = a[i];
branch  0 never executed
branch  1 never executed
    #####: 4269:    int64_t dimB = 1;
    #####: 4270:    while (dimB < dimA && j < rankB)
branch  0 never executed
branch  1 never executed
    #####: 4271:      dimB *= b[j++];
branch  0 never executed
branch  1 never executed
    #####: 4272:    if (dimA != dimB)
branch  0 never executed
branch  1 never executed
        -: 4273:      break;
    #####: 4274:    ++i;
        -: 4275:
        -: 4276:    // Handle the case when trailing dimensions are of size 1.
        -: 4277:    // Include them into the contiguous sequence.
    #####: 4278:    auto isOne = [](int64_t v) { return v == 1; };
    #####: 4279:    if (i < rankA && llvm::all_of(a.slice(i), isOne))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4280:      i = rankA;
    #####: 4281:    if (j < rankB && llvm::all_of(b.slice(j), isOne))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4282:      j = rankB;
        -: 4283:  }
        -: 4284:
    #####: 4285:  return i == rankA && j == rankB;
        -: 4286:}
        -: 4287:
function _ZL21verifyVectorShapeCastPN4mlir9OperationENS_10VectorTypeES2_ called 0 returned 0% blocks executed 0%
    #####: 4288:static LogicalResult verifyVectorShapeCast(Operation *op,
        -: 4289:                                           VectorType sourceVectorType,
        -: 4290:                                           VectorType resultVectorType) {
        -: 4291:  // Check that element type is the same.
    #####: 4292:  if (sourceVectorType.getElementType() != resultVectorType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4293:    return op->emitOpError("source/result vectors must have same element type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4294:  auto sourceShape = sourceVectorType.getShape();
call    0 never executed
    #####: 4295:  auto resultShape = resultVectorType.getShape();
call    0 never executed
        -: 4296:
        -: 4297:  // Check that product of source dim sizes matches product of result dim sizes.
    #####: 4298:  int64_t sourceDimProduct = std::accumulate(
        -: 4299:      sourceShape.begin(), sourceShape.end(), 1LL, std::multiplies<int64_t>{});
    #####: 4300:  int64_t resultDimProduct = std::accumulate(
        -: 4301:      resultShape.begin(), resultShape.end(), 1LL, std::multiplies<int64_t>{});
    #####: 4302:  if (sourceDimProduct != resultDimProduct)
branch  0 never executed
branch  1 never executed
    #####: 4303:    return op->emitOpError("source/result number of elements must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4304:
        -: 4305:  // Check that expanding/contracting rank cases.
    #####: 4306:  unsigned sourceRank = sourceVectorType.getRank();
call    0 never executed
    #####: 4307:  unsigned resultRank = resultVectorType.getRank();
call    0 never executed
    #####: 4308:  if (sourceRank < resultRank) {
branch  0 never executed
branch  1 never executed
    #####: 4309:    if (!isValidShapeCast(sourceShape, resultShape))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4310:      return op->emitOpError("invalid shape cast");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4311:  } else if (sourceRank > resultRank) {
branch  0 never executed
branch  1 never executed
    #####: 4312:    if (!isValidShapeCast(resultShape, sourceShape))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4313:      return op->emitOpError("invalid shape cast");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4314:  }
    #####: 4315:  return success();
        -: 4316:}
        -: 4317:
function _ZN4mlir6vector11ShapeCastOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4318:LogicalResult ShapeCastOp::verify() {
    #####: 4319:  auto sourceVectorType = getSource().getType().dyn_cast_or_null<VectorType>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4320:  auto resultVectorType = getResult().getType().dyn_cast_or_null<VectorType>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 4321:
        -: 4322:  // Check if source/result are of vector type.
    #####: 4323:  if (sourceVectorType && resultVectorType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4324:    return verifyVectorShapeCast(*this, sourceVectorType, resultVectorType);
call    0 never executed
        -: 4325:
    #####: 4326:  return success();
        -: 4327:}
        -: 4328:
function _ZN4mlir6vector11ShapeCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 4329:OpFoldResult ShapeCastOp::fold(ArrayRef<Attribute> operands) {
        -: 4330:  // No-op shape cast.
    #####: 4331:  if (getSource().getType() == getResult().getType())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4332:    return getSource();
call    0 never executed
call    1 never executed
        -: 4333:
        -: 4334:  // Canceling shape casts.
    #####: 4335:  if (auto otherOp = getSource().getDefiningOp<ShapeCastOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4336:    if (getResult().getType() == otherOp.getSource().getType())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4337:      return otherOp.getSource();
call    0 never executed
call    1 never executed
        -: 4338:
        -: 4339:    // Only allows valid transitive folding.
    #####: 4340:    VectorType srcType = otherOp.getSource().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4341:    VectorType resultType = getResult().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4342:    if (srcType.getRank() < resultType.getRank()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4343:      if (!isValidShapeCast(srcType.getShape(), resultType.getShape()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4344:        return {};
    #####: 4345:    } else if (srcType.getRank() > resultType.getRank()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4346:      if (!isValidShapeCast(resultType.getShape(), srcType.getShape()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4347:        return {};
        -: 4348:    } else {
    #####: 4349:      return {};
        -: 4350:    }
        -: 4351:
    #####: 4352:    setOperand(otherOp.getSource());
call    0 never executed
call    1 never executed
    #####: 4353:    return getResult();
call    0 never executed
call    1 never executed
        -: 4354:  }
        -: 4355:
        -: 4356:  // Cancelling broadcast and shape cast ops.
    #####: 4357:  if (auto bcastOp = getSource().getDefiningOp<BroadcastOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4358:    if (bcastOp.getSourceType() == getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4359:      return bcastOp.getSource();
call    0 never executed
call    1 never executed
        -: 4360:  }
        -: 4361:
    #####: 4362:  return {};
        -: 4363:}
        -: 4364:
        -: 4365:namespace {
        -: 4366:// Pattern to rewrite a ShapeCast(splat ConstantOp) -> ConstantOp.
        -: 4367:class ShapeCastConstantFolder final : public OpRewritePattern<ShapeCastOp> {
        -: 4368:public:
        -: 4369:  using OpRewritePattern::OpRewritePattern;
        -: 4370:
function _ZNK12_GLOBAL__N_123ShapeCastConstantFolder15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4371:  LogicalResult matchAndRewrite(ShapeCastOp shapeCastOp,
        -: 4372:                                PatternRewriter &rewriter) const override {
    #####: 4373:    auto constantOp =
    #####: 4374:        shapeCastOp.getSource().getDefiningOp<arith::ConstantOp>();
call    0 never executed
call    1 never executed
    #####: 4375:    if (!constantOp)
branch  0 never executed
branch  1 never executed
    #####: 4376:      return failure();
        -: 4377:    // Only handle splat for now.
    #####: 4378:    auto dense = constantOp.getValue().dyn_cast<SplatElementsAttr>();
call    0 never executed
call    1 never executed
    #####: 4379:    if (!dense)
branch  0 never executed
branch  1 never executed
    #####: 4380:      return failure();
    #####: 4381:    auto newAttr =
    #####: 4382:        DenseElementsAttr::get(shapeCastOp.getType().cast<VectorType>(),
call    0 never executed
    #####: 4383:                               dense.getSplatValue<Attribute>());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4384:    rewriter.replaceOpWithNewOp<arith::ConstantOp>(shapeCastOp, newAttr);
call    0 never executed
    #####: 4385:    return success();
        -: 4386:  }
        -: 4387:};
        -: 4388:
        -: 4389:/// Pattern to rewrite a ShapeCast(Broadcast) -> Broadcast.
        -: 4390:/// This only applies when the shape of the broadcast source is a suffix of the
        -: 4391:/// shape of the result (i.e. when broadcast without reshape is expressive
        -: 4392:/// enough to capture the result in a single op).
        -: 4393:class ShapeCastBroadcastFolder final : public OpRewritePattern<ShapeCastOp> {
        -: 4394:public:
        -: 4395:  using OpRewritePattern::OpRewritePattern;
        -: 4396:
function _ZNK12_GLOBAL__N_124ShapeCastBroadcastFolder15matchAndRewriteEN4mlir6vector11ShapeCastOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4397:  LogicalResult matchAndRewrite(ShapeCastOp shapeCastOp,
        -: 4398:                                PatternRewriter &rewriter) const override {
    #####: 4399:    auto broadcastOp =
    #####: 4400:        shapeCastOp.getSource().getDefiningOp<vector::BroadcastOp>();
call    0 never executed
call    1 never executed
    #####: 4401:    if (!broadcastOp)
branch  0 never executed
branch  1 never executed
    #####: 4402:      return failure();
        -: 4403:
    #####: 4404:    auto broadcastSourceVectorType =
call    0 never executed
    #####: 4405:        broadcastOp.getSourceType().dyn_cast<VectorType>();
call    0 never executed
    #####: 4406:    auto broadcastSourceShape = broadcastSourceVectorType
    #####: 4407:                                    ? broadcastSourceVectorType.getShape()
call    0 never executed
    #####: 4408:                                    : ArrayRef<int64_t>{};
branch  0 never executed
branch  1 never executed
    #####: 4409:    auto shapeCastTargetShape = shapeCastOp.getResultVectorType().getShape();
call    0 never executed
call    1 never executed
        -: 4410:
        -: 4411:    // Bail if `broadcastSourceShape` is not a suffix of the result.
    #####: 4412:    bool isSuffix = (broadcastSourceShape == shapeCastTargetShape.take_back(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4413:                                                 broadcastSourceShape.size()));
    #####: 4414:    if (!isSuffix)
branch  0 never executed
branch  1 never executed
    #####: 4415:      return failure();
        -: 4416:
    #####: 4417:    rewriter.replaceOpWithNewOp<vector::BroadcastOp>(
    #####: 4418:        shapeCastOp, shapeCastOp.getResultVectorType(),
    #####: 4419:        broadcastOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4420:    return success();
        -: 4421:  }
        -: 4422:};
        -: 4423:
        -: 4424:} // namespace
        -: 4425:
function _ZN4mlir6vector11ShapeCastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4426:void ShapeCastOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4427:                                              MLIRContext *context) {
     1235: 4428:  results.add<ShapeCastConstantFolder, ShapeCastBroadcastFolder>(context);
call    0 returned 100%
     1235: 4429:}
        -: 4430:
        -: 4431://===----------------------------------------------------------------------===//
        -: 4432:// VectorBitCastOp
        -: 4433://===----------------------------------------------------------------------===//
        -: 4434:
function _ZN4mlir6vector9BitCastOp6verifyEv called 31310536 returned 100% blocks executed 59%
 31310536: 4435:LogicalResult BitCastOp::verify() {
 31310536: 4436:  auto sourceVectorType = getSourceVectorType();
call    0 returned 100%
 31310536: 4437:  auto resultVectorType = getResultVectorType();
call    0 returned 100%
        -: 4438:
 54354331: 4439:  for (int64_t i = 0, e = sourceVectorType.getRank() - 1; i < e; i++) {
call    0 returned 100%
branch  1 taken 42% (fallthrough)
branch  2 taken 58%
 23043796: 4440:    if (sourceVectorType.getDimSize(i) != resultVectorType.getDimSize(i))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4441:      return emitOpError("dimension size mismatch at: ") << i;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4442:  }
        -: 4443:
 31310535: 4444:  DataLayout dataLayout = DataLayout::closest(*this);
call    0 returned 100%
 31310535: 4445:  auto sourceElementBits =
 31310535: 4446:      dataLayout.getTypeSizeInBits(sourceVectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
 31310537: 4447:  auto resultElementBits =
 31310537: 4448:      dataLayout.getTypeSizeInBits(resultVectorType.getElementType());
call    0 returned 100%
call    1 returned 100%
        -: 4449:
 31310535: 4450:  if (sourceVectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4451:    if (sourceElementBits != resultElementBits)
branch  0 never executed
branch  1 never executed
    #####: 4452:      return emitOpError("source/result bitwidth of the 0-D vector element "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4453:                         "types must be equal");
call    0 never executed
 31310535: 4454:  } else if (sourceElementBits * sourceVectorType.getShape().back() !=
call    0 returned 100%
call    1 returned 100%
 31310535: 4455:             resultElementBits * resultVectorType.getShape().back()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4456:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4457:        "source/result bitwidth of the minor 1-D vectors must be equal");
call    0 never executed
        -: 4458:  }
        -: 4459:
 31310535: 4460:  return success();
call    0 returned 100%
        -: 4461:}
        -: 4462:
function _ZN4mlir6vector9BitCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 275512 returned 100% blocks executed 70%
   275512: 4463:OpFoldResult BitCastOp::fold(ArrayRef<Attribute> operands) {
        -: 4464:  // Nop cast.
   275512: 4465:  if (getSource().getType() == getResult().getType())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 88% (fallthrough)
branch  5 taken 12%
   241571: 4466:    return getSource();
call    0 returned 100%
call    1 returned 100%
        -: 4467:
        -: 4468:  // Canceling bitcasts.
    33941: 4469:  if (auto otherOp = getSource().getDefiningOp<BitCastOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
     2442: 4470:    if (getResult().getType() == otherOp.getSource().getType())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 10% (fallthrough)
branch  5 taken 90%
      249: 4471:      return otherOp.getSource();
call    0 returned 100%
call    1 returned 100%
        -: 4472:
     2193: 4473:    setOperand(otherOp.getSource());
call    0 returned 100%
call    1 returned 100%
     2193: 4474:    return getResult();
call    0 returned 100%
call    1 returned 100%
        -: 4475:  }
        -: 4476:
    31499: 4477:  Attribute sourceConstant = operands.front();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    31499: 4478:  if (!sourceConstant)
branch  0 taken 81%
branch  1 taken 19%
    25643: 4479:    return {};
        -: 4480:
     5856: 4481:  Type srcElemType = getSourceVectorType().getElementType();
call    0 returned 100%
call    1 returned 100%
     5856: 4482:  Type dstElemType = getResultVectorType().getElementType();
call    0 returned 100%
call    1 returned 100%
        -: 4483:
     5856: 4484:  if (auto floatPack = sourceConstant.dyn_cast<DenseFPElementsAttr>()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
     4349: 4485:    if (floatPack.isSplat()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     4349: 4486:      auto splat = floatPack.getSplatValue<FloatAttr>();
call    0 returned 100%
        -: 4487:
        -: 4488:      // Casting fp16 into fp32.
     4349: 4489:      if (srcElemType.isF16() && dstElemType.isF32()) {
call    0 returned 100%
branch  1 taken 7% (fallthrough)
branch  2 taken 93%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 4490:        uint32_t bits = static_cast<uint32_t>(
    #####: 4491:            splat.getValue().bitcastToAPInt().getZExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 4492:        // Duplicate the 16-bit pattern.
    #####: 4493:        bits = (bits << 16) | (bits & 0xffff);
    #####: 4494:        APInt intBits(32, bits);
call    0 never executed
    #####: 4495:        APFloat floatBits(llvm::APFloat::IEEEsingle(), intBits);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4496:        return DenseElementsAttr::get(getResultVectorType(), floatBits);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4497:      }
        -: 4498:    }
        -: 4499:  }
        -: 4500:
     5856: 4501:  return {};
        -: 4502:}
        -: 4503:
        -: 4504://===----------------------------------------------------------------------===//
        -: 4505:// TypeCastOp
        -: 4506://===----------------------------------------------------------------------===//
        -: 4507:
function _ZL12extractShapeN4mlir10MemRefTypeE called 622 returned 100% blocks executed 100%
      622: 4508:static SmallVector<int64_t, 8> extractShape(MemRefType memRefType) {
      622: 4509:  auto vectorType = memRefType.getElementType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
      622: 4510:  SmallVector<int64_t, 8> res(memRefType.getShape().begin(),
call    0 returned 100%
      622: 4511:                              memRefType.getShape().end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      622: 4512:  if (vectorType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      622: 4513:    res.append(vectorType.getShape().begin(), vectorType.getShape().end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      622: 4514:  return res;
        -: 4515:}
        -: 4516:
        -: 4517:/// Build the canonical memRefType with a single vector.
        -: 4518:/// E.g. memref<4 x 5 x vector<6 x f32>> -> memref<vector<4 x 5 x 6 x f32>>.
function _ZN4mlir6vector10TypeCastOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 4519:void TypeCastOp::build(OpBuilder &builder, OperationState &result,
        -: 4520:                       Value source) {
    #####: 4521:  result.addOperands(source);
call    0 never executed
call    1 never executed
    #####: 4522:  MemRefType memRefType = source.getType().cast<MemRefType>();
call    0 never executed
    #####: 4523:  VectorType vectorType =
    #####: 4524:      VectorType::get(extractShape(memRefType),
call    0 never executed
call    1 never executed
    #####: 4525:                      getElementTypeOrSelf(getElementTypeOrSelf(memRefType)));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4526:  result.addTypes(MemRefType::get({}, vectorType, MemRefLayoutAttrInterface(),
call    0 never executed
    #####: 4527:                                  memRefType.getMemorySpace()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4528:}
        -: 4529:
function _ZN4mlir6vector10TypeCastOp6verifyEv called 311 returned 100% blocks executed 49%
      311: 4530:LogicalResult TypeCastOp::verify() {
      311: 4531:  MemRefType canonicalType = canonicalizeStridedLayout(getMemRefType());
call    0 returned 100%
call    1 returned 100%
      311: 4532:  if (!canonicalType.getLayout().isIdentity())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4533:    return emitOpError("expects operand to be a memref with identity layout");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      311: 4534:  if (!getResultMemRefType().getLayout().isIdentity())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 4535:    return emitOpError("expects result to be a memref with identity layout");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      311: 4536:  if (getResultMemRefType().getMemorySpace() !=
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
      622: 4537:      getMemRefType().getMemorySpace())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4538:    return emitOpError("expects result in same memory space");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4539:
      311: 4540:  auto sourceType = getMemRefType();
call    0 returned 100%
      311: 4541:  auto resultType = getResultMemRefType();
call    0 returned 100%
      311: 4542:  if (getElementTypeOrSelf(getElementTypeOrSelf(sourceType)) !=
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 4543:      getElementTypeOrSelf(getElementTypeOrSelf(resultType)))
    #####: 4544:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4545:               "expects result and operand with same underlying scalar type: ")
    #####: 4546:           << resultType;
call    0 never executed
      311: 4547:  if (extractShape(sourceType) != extractShape(resultType))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 4548:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4549:               "expects concatenated result and operand shapes to be equal: ")
    #####: 4550:           << resultType;
call    0 never executed
      311: 4551:  return success();
        -: 4552:}
        -: 4553:
        -: 4554://===----------------------------------------------------------------------===//
        -: 4555:// TransposeOp
        -: 4556://===----------------------------------------------------------------------===//
        -: 4557:
function _ZN4mlir6vector11TransposeOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 4558:void vector::TransposeOp::build(OpBuilder &builder, OperationState &result,
        -: 4559:                                Value vector, ArrayRef<int64_t> transp) {
    #####: 4560:  VectorType vt = vector.getType().cast<VectorType>();
call    0 never executed
    #####: 4561:  SmallVector<int64_t, 4> transposedShape(vt.getRank());
call    0 never executed
call    1 never executed
    #####: 4562:  for (unsigned i = 0; i < transp.size(); ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4563:    transposedShape[i] = vt.getShape()[transp[i]];
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 4564:
    #####: 4565:  result.addOperands(vector);
call    0 never executed
call    1 never executed
    #####: 4566:  result.addTypes(VectorType::get(transposedShape, vt.getElementType()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4567:  result.addAttribute(getTranspAttrStrName(), builder.getI64ArrayAttr(transp));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4568:}
        -: 4569:
function _ZN4mlir6vector11TransposeOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 186829 returned 100% blocks executed 88%
   186829: 4570:OpFoldResult vector::TransposeOp::fold(ArrayRef<Attribute> operands) {
        -: 4571:  // Eliminate splat constant transpose ops.
   186829: 4572:  if (auto attr = operands.front().dyn_cast_or_null<DenseElementsAttr>())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
      766: 4573:    if (attr.isSplat())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      766: 4574:      return attr.reshape(getResultType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 4575:
        -: 4576:  // Eliminate identity transpose ops. This happens when the dimensions of the
        -: 4577:  // input vector remain in their original order after the transpose operation.
   186063: 4578:  SmallVector<int64_t, 4> transp;
call    0 returned 100%
   186063: 4579:  getTransp(transp);
call    0 returned 100%
        -: 4580:
        -: 4581:  // Check if the permutation of the dimensions contains sequential values:
        -: 4582:  // {0, 1, 2, ...}.
   362394: 4583:  for (int64_t i = 0, e = transp.size(); i < e; i++) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
   216415: 4584:    if (transp[i] != i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 19% (fallthrough)
branch  3 taken 81%
    40084: 4585:      return {};
        -: 4586:  }
        -: 4587:
   145979: 4588:  return getVector();
call    0 returned 100%
call    1 returned 100%
        -: 4589:}
        -: 4590:
function _ZN4mlir6vector11TransposeOp6verifyEv called 26259869 returned 100% blocks executed 43%
 26259869: 4591:LogicalResult vector::TransposeOp::verify() {
 26259869: 4592:  VectorType vectorType = getVectorType();
call    0 returned 100%
 26259869: 4593:  VectorType resultType = getResultType();
call    0 returned 100%
 26259869: 4594:  int64_t rank = resultType.getRank();
call    0 returned 100%
 26259869: 4595:  if (vectorType.getRank() != rank)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4596:    return emitOpError("vector result rank mismatch: ") << rank;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4597:  // Verify transposition array.
 26259869: 4598:  auto transpAttr = getTransp().getValue();
call    0 returned 100%
call    1 returned 100%
 26259869: 4599:  int64_t size = transpAttr.size();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 26259869: 4600:  if (rank != size)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 4601:    return emitOpError("transposition length mismatch: ") << size;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 26259869: 4602:  SmallVector<bool, 8> seen(rank, false);
call    0 returned 100%
 69349021: 4603:  for (const auto &ta : llvm::enumerate(transpAttr)) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
call    2 returned 100%
 43089152: 4604:    int64_t i = ta.value().cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
 43089152: 4605:    if (i < 0 || i >= rank)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4606:      return emitOpError("transposition index out of range: ") << i;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 43089152: 4607:    if (seen[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4608:      return emitOpError("duplicate position index: ") << i;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 43089152: 4609:    seen[i] = true;
call    0 returned 100%
 43089152: 4610:    if (resultType.getDimSize(ta.index()) != vectorType.getDimSize(i))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4611:      return emitOpError("dimension size mismatch at: ") << i;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4612:  }
 26259869: 4613:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 4614:}
        -: 4615:
function _ZN4mlir6vector11TransposeOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####: 4616:Optional<SmallVector<int64_t, 4>> TransposeOp::getShapeForUnroll() {
    #####: 4617:  return llvm::to_vector<4>(getResultType().getShape());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 4618:}
        -: 4619:
        -: 4620:namespace {
        -: 4621:
        -: 4622:// Rewrites two back-to-back TransposeOp operations into a single TransposeOp.
        -: 4623:class TransposeFolder final : public OpRewritePattern<vector::TransposeOp> {
        -: 4624:public:
        -: 4625:  using OpRewritePattern::OpRewritePattern;
        -: 4626:
function _ZNK12_GLOBAL__N_115TransposeFolder15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4627:  LogicalResult matchAndRewrite(vector::TransposeOp transposeOp,
        -: 4628:                                PatternRewriter &rewriter) const override {
        -: 4629:    // Wrapper around vector::TransposeOp::getTransp() for cleaner code.
    #####: 4630:    auto getPermutation = [](vector::TransposeOp transpose) {
    #####: 4631:      SmallVector<int64_t, 4> permutation;
call    0 never executed
    #####: 4632:      transpose.getTransp(permutation);
call    0 never executed
call    1 never executed
    #####: 4633:      return permutation;
        -: 4634:    };
        -: 4635:
        -: 4636:    // Composes two permutations: result[i] = permutation1[permutation2[i]].
function _ZZNK12_GLOBAL__N_115TransposeFolder15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterEENKUlN4llvm8ArrayRefIlEES8_E0_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 4637:    auto composePermutations = [](ArrayRef<int64_t> permutation1,
        -: 4638:                                  ArrayRef<int64_t> permutation2) {
    #####: 4639:      SmallVector<int64_t, 4> result;
    #####: 4640:      for (auto index : permutation2)
branch  0 never executed
branch  1 never executed
    #####: 4641:        result.push_back(permutation1[index]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4642:      return result;
        -: 4643:    };
        -: 4644:
        -: 4645:    // Return if the input of 'transposeOp' is not defined by another transpose.
    #####: 4646:    vector::TransposeOp parentTransposeOp =
    #####: 4647:        transposeOp.getVector().getDefiningOp<vector::TransposeOp>();
call    0 never executed
call    1 never executed
    #####: 4648:    if (!parentTransposeOp)
branch  0 never executed
branch  1 never executed
    #####: 4649:      return failure();
        -: 4650:
    #####: 4651:    SmallVector<int64_t, 4> permutation = composePermutations(
    #####: 4652:        getPermutation(parentTransposeOp), getPermutation(transposeOp));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 4653:    // Replace 'transposeOp' with a new transpose operation.
    #####: 4654:    rewriter.replaceOpWithNewOp<vector::TransposeOp>(
    #####: 4655:        transposeOp, transposeOp.getResult().getType(),
call    0 never executed
call    1 never executed
    #####: 4656:        parentTransposeOp.getVector(),
    #####: 4657:        vector::getVectorSubscriptAttr(rewriter, permutation));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4658:    return success();
branch  0 never executed
branch  1 never executed
        -: 4659:  }
        -: 4660:};
        -: 4661:
        -: 4662:// Folds transpose(broadcast(<scalar>)) into brodcast(<scalar>).
        -: 4663:struct FoldTransposedScalarBroadcast final
        -: 4664:    : public OpRewritePattern<vector::TransposeOp> {
        -: 4665:  using OpRewritePattern::OpRewritePattern;
        -: 4666:
function _ZNK12_GLOBAL__N_129FoldTransposedScalarBroadcast15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4667:  LogicalResult matchAndRewrite(vector::TransposeOp transposeOp,
        -: 4668:                                PatternRewriter &rewriter) const override {
    #####: 4669:    auto bcastOp = transposeOp.getVector().getDefiningOp<vector::BroadcastOp>();
call    0 never executed
call    1 never executed
    #####: 4670:    if (!bcastOp)
branch  0 never executed
branch  1 never executed
    #####: 4671:      return failure();
        -: 4672:
    #####: 4673:    auto srcVectorType = bcastOp.getSourceType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####: 4674:    if (!srcVectorType || srcVectorType.getNumElements() == 1) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4675:      rewriter.replaceOpWithNewOp<vector::BroadcastOp>(
    #####: 4676:          transposeOp, transposeOp.getResultType(), bcastOp.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4677:      return success();
        -: 4678:    }
        -: 4679:
    #####: 4680:    return failure();
        -: 4681:  }
        -: 4682:};
        -: 4683:
        -: 4684:// Folds transpose(splat x : src_type) : res_type into splat x : res_type.
        -: 4685:class FoldTransposeSplat final : public OpRewritePattern<TransposeOp> {
        -: 4686:public:
        -: 4687:  using OpRewritePattern::OpRewritePattern;
        -: 4688:
function _ZNK12_GLOBAL__N_118FoldTransposeSplat15matchAndRewriteEN4mlir6vector11TransposeOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 4689:  LogicalResult matchAndRewrite(TransposeOp transposeOp,
        -: 4690:                                PatternRewriter &rewriter) const override {
    #####: 4691:    auto splatOp = transposeOp.getVector().getDefiningOp<vector::SplatOp>();
call    0 never executed
call    1 never executed
    #####: 4692:    if (!splatOp)
branch  0 never executed
branch  1 never executed
    #####: 4693:      return failure();
        -: 4694:
    #####: 4695:    rewriter.replaceOpWithNewOp<vector::SplatOp>(
    #####: 4696:        transposeOp, transposeOp.getResultType(), splatOp.getInput());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4697:    return success();
        -: 4698:  }
        -: 4699:};
        -: 4700:
        -: 4701:} // namespace
        -: 4702:
function _ZN4mlir6vector11TransposeOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4703:void vector::TransposeOp::getCanonicalizationPatterns(
        -: 4704:    RewritePatternSet &results, MLIRContext *context) {
     1235: 4705:  results
        -: 4706:      .add<FoldTransposedScalarBroadcast, TransposeFolder, FoldTransposeSplat>(
     1235: 4707:          context);
call    0 returned 100%
     1235: 4708:}
        -: 4709:
function _ZN4mlir6vector11TransposeOp9getTranspERN4llvm15SmallVectorImplIlEE called 186063 returned 100% blocks executed 100%
   186063: 4710:void vector::TransposeOp::getTransp(SmallVectorImpl<int64_t> &results) {
   186063: 4711:  populateFromInt64AttrArray(getTransp(), results);
call    0 returned 100%
call    1 returned 100%
   186063: 4712:}
        -: 4713:
        -: 4714://===----------------------------------------------------------------------===//
        -: 4715:// ConstantMaskOp
        -: 4716://===----------------------------------------------------------------------===//
        -: 4717:
function _ZN4mlir6vector14ConstantMaskOp6verifyEv called 17204 returned 100% blocks executed 37%
    17204: 4718:LogicalResult ConstantMaskOp::verify() {
    17204: 4719:  auto resultType = getResult().getType().cast<VectorType>();
call    0 returned 100%
        -: 4720:  // Check the corner case of 0-D vectors first.
    17204: 4721:  if (resultType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4722:    if (getMaskDimSizes().size() != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4723:      return emitError("array attr must have length 1 for 0-D vectors");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4724:    auto dim = getMaskDimSizes()[0].cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4725:    if (dim != 0 && dim != 1)
branch  0 never executed
branch  1 never executed
    #####: 4726:      return emitError("mask dim size must be either 0 or 1 for 0-D vectors");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4727:    return success();
        -: 4728:  }
        -: 4729:
        -: 4730:  // Verify that array attr size matches the rank of the vector result.
    17204: 4731:  if (static_cast<int64_t>(getMaskDimSizes().size()) != resultType.getRank())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 4732:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4733:        "must specify array attr of size equal vector result rank");
call    0 never executed
        -: 4734:  // Verify that each array attr element is in bounds of corresponding vector
        -: 4735:  // result dimension size.
    17204: 4736:  auto resultShape = resultType.getShape();
call    0 returned 100%
    17204: 4737:  SmallVector<int64_t, 4> maskDimSizes;
call    0 returned 100%
    71102: 4738:  for (const auto &it : llvm::enumerate(getMaskDimSizes())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 68% (fallthrough)
branch  4 taken 32%
call    5 returned 100%
    36694: 4739:    int64_t attrValue = it.value().cast<IntegerAttr>().getInt();
call    0 returned 100%
call    1 returned 100%
    36694: 4740:    if (attrValue < 0 || attrValue > resultShape[it.index()])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 4741:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4742:          "array attr of size out of bounds of vector result dimension size");
call    0 never executed
    36694: 4743:    maskDimSizes.push_back(attrValue);
call    0 returned 100%
        -: 4744:  }
        -: 4745:  // Verify that if one mask dim size is zero, they all should be zero (because
        -: 4746:  // the mask region is a conjunction of each mask dimension interval).
    17204: 4747:  bool anyZeros = llvm::is_contained(maskDimSizes, 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    17204: 4748:  bool allZeros = llvm::all_of(maskDimSizes, [](int64_t s) { return s == 0; });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    17204: 4749:  if (anyZeros && !allZeros)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 4750:    return emitOpError("expected all mask dim sizes to be zeros, "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4751:                       "as a result of conjunction with zero mask dim");
call    0 never executed
        -: 4752:  // Verify that if the mask type is scalable, dimensions should be zero because
        -: 4753:  // constant scalable masks can only be defined for the "none set" or "all set"
        -: 4754:  // cases, and there is no VLA way to define an "all set" case for
        -: 4755:  // `vector.constant_mask`. In the future, a convention could be established
        -: 4756:  // to decide if a specific dimension value could be considered as "all set".
   17204*: 4757:  if (resultType.isScalable() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
    #####: 4758:      getMaskDimSizes()[0].cast<IntegerAttr>().getInt() != 0)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4759:    return emitOpError("expected mask dim sizes for scalable masks to be 0");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    17204: 4760:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 4761:}
        -: 4762:
        -: 4763://===----------------------------------------------------------------------===//
        -: 4764:// CreateMaskOp
        -: 4765://===----------------------------------------------------------------------===//
        -: 4766:
function _ZN4mlir6vector12CreateMaskOp6verifyEv called 52977886 returned 100% blocks executed 43%
 52977886: 4767:LogicalResult CreateMaskOp::verify() {
 52977886: 4768:  auto vectorType = getResult().getType().cast<VectorType>();
call    0 returned 100%
        -: 4769:  // Verify that an operand was specified for each result vector each dimension.
 52977886: 4770:  if (vectorType.getRank() == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4771:    if (getNumOperands() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4772:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4773:          "must specify exactly one operand for 0-D create_mask");
call    0 never executed
 52977886: 4774:  } else if (getNumOperands() !=
call    0 returned 100%
call    1 returned 100%
 52977886: 4775:             getResult().getType().cast<VectorType>().getRank()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4776:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4777:        "must specify an operand for each result vector dimension");
call    0 never executed
        -: 4778:  }
 52977887: 4779:  return success();
        -: 4780:}
        -: 4781:
        -: 4782:namespace {
        -: 4783:
        -: 4784:// Pattern to rewrite a CreateMaskOp with a ConstantMaskOp.
        -: 4785:class CreateMaskFolder final : public OpRewritePattern<CreateMaskOp> {
        -: 4786:public:
        -: 4787:  using OpRewritePattern::OpRewritePattern;
        -: 4788:
function _ZNK12_GLOBAL__N_116CreateMaskFolder15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS1_15PatternRewriterE called 12774 returned 100% blocks executed 65%
    12774: 4789:  LogicalResult matchAndRewrite(CreateMaskOp createMaskOp,
        -: 4790:                                PatternRewriter &rewriter) const override {
        -: 4791:    // Return if any of 'createMaskOp' operands are not defined by a constant.
function _ZZNK12_GLOBAL__N_116CreateMaskFolder15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS1_15PatternRewriterEENKUlNS1_5ValueEE_clES6_.isra.0 called 19564 returned 100% blocks executed 100%
    19564: 4792:    auto isNotDefByConstant = [](Value operand) {
    19564: 4793:      return !isa_and_nonnull<arith::ConstantIndexOp>(operand.getDefiningOp());
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
        -: 4794:    };
    12774: 4795:    if (llvm::any_of(createMaskOp.operands(), isNotDefByConstant))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 74% (fallthrough)
branch  3 taken 26%
     9511: 4796:      return failure();
        -: 4797:
        -: 4798:    // CreateMaskOp for scalable vectors can be folded only if all dimensions
        -: 4799:    // are negative or zero.
     3263: 4800:    if (auto vType = createMaskOp.getType().dyn_cast<VectorType>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     3263: 4801:      if (vType.isScalable())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 4802:        for (auto opDim : createMaskOp.getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 4803:          APInt intVal;
call    0 never executed
    #####: 4804:          if (matchPattern(opDim, m_ConstantInt(&intVal)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 4805:              intVal.isStrictlyPositive())
call    0 never executed
    #####: 4806:            return failure();
branch  0 never executed
branch  1 never executed
        -: 4807:        }
        -: 4808:    }
        -: 4809:
        -: 4810:    // Gather constant mask dimension sizes.
     3263: 4811:    SmallVector<int64_t, 4> maskDimSizes;
call    0 returned 100%
     7713: 4812:    for (auto it : llvm::zip(createMaskOp.operands(),
call    0 returned 100%
     7713: 4813:                             createMaskOp.getType().getShape())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 70% (fallthrough)
branch  3 taken 30%
     5385: 4814:      auto *defOp = std::get<0>(it).getDefiningOp();
call    0 returned 100%
     5385: 4815:      int64_t maxDimSize = std::get<1>(it);
call    0 returned 100%
     5385: 4816:      int64_t dimSize = cast<arith::ConstantIndexOp>(defOp).value();
call    0 returned 100%
call    1 returned 100%
     5385: 4817:      dimSize = std::min(dimSize, maxDimSize);
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
        -: 4818:      // If one of dim sizes is zero, set all dims to zero.
     5385: 4819:      if (dimSize <= 0) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
      935: 4820:        maskDimSizes.assign(createMaskOp.getType().getRank(), 0);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      935: 4821:        break;
        -: 4822:      }
     4450: 4823:      maskDimSizes.push_back(dimSize);
call    0 returned 100%
        -: 4824:    }
        -: 4825:    // Replace 'createMaskOp' with ConstantMaskOp.
     3263: 4826:    rewriter.replaceOpWithNewOp<ConstantMaskOp>(
     3263: 4827:        createMaskOp, createMaskOp.getResult().getType(),
call    0 returned 100%
     3263: 4828:        vector::getVectorSubscriptAttr(rewriter, maskDimSizes));
call    0 returned 100%
call    1 returned 100%
     3263: 4829:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 4830:  }
        -: 4831:};
        -: 4832:
        -: 4833:} // namespace
        -: 4834:
function _ZN4mlir6vector12CreateMaskOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4835:void CreateMaskOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4836:                                               MLIRContext *context) {
     1235: 4837:  results.add<CreateMaskFolder>(context);
call    0 returned 100%
     1235: 4838:}
        -: 4839:
        -: 4840://===----------------------------------------------------------------------===//
        -: 4841:// MaskOp
        -: 4842://===----------------------------------------------------------------------===//
        -: 4843:
function _ZN4mlir6vector6MaskOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm12function_refIFvS3_NS_8LocationEEEE called 0 returned 0% blocks executed 0%
    #####: 4844:void MaskOp::build(
        -: 4845:    OpBuilder &builder, OperationState &result, Value mask,
        -: 4846:    function_ref<void(OpBuilder &, Location)> maskRegionBuilder) {
    #####: 4847:  assert(maskRegionBuilder &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4848:         "builder callback for 'maskRegion' must be present");
        -: 4849:
    #####: 4850:  result.addOperands(mask);
call    0 never executed
call    1 never executed
    #####: 4851:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 4852:  Region *maskRegion = result.addRegion();
call    0 never executed
    #####: 4853:  builder.createBlock(maskRegion);
call    0 never executed
call    1 never executed
    #####: 4854:  maskRegionBuilder(builder, result.location);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4855:}
        -: 4856:
function _ZN4mlir6vector6MaskOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_5ValueEN4llvm12function_refIFvS3_NS_8LocationEEEE called 0 returned 0% blocks executed 0%
    #####: 4857:void MaskOp::build(
        -: 4858:    OpBuilder &builder, OperationState &result, Type resultType, Value mask,
        -: 4859:    function_ref<void(OpBuilder &, Location)> maskRegionBuilder) {
    #####: 4860:  build(builder, result, resultType, mask, /*passthru=*/Value(),
call    0 never executed
        -: 4861:        maskRegionBuilder);
    #####: 4862:}
        -: 4863:
function _ZN4mlir6vector6MaskOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_5ValueES7_N4llvm12function_refIFvS3_NS_8LocationEEEE called 0 returned 0% blocks executed 0%
    #####: 4864:void MaskOp::build(
        -: 4865:    OpBuilder &builder, OperationState &result, Type resultType, Value mask,
        -: 4866:    Value passthru,
        -: 4867:    function_ref<void(OpBuilder &, Location)> maskRegionBuilder) {
    #####: 4868:  build(builder, result, mask, maskRegionBuilder);
call    0 never executed
    #####: 4869:  if (passthru)
branch  0 never executed
branch  1 never executed
    #####: 4870:    result.addOperands(passthru);
call    0 never executed
call    1 never executed
    #####: 4871:  result.addTypes(resultType);
call    0 never executed
    #####: 4872:}
        -: 4873:
function _ZN4mlir6vector6MaskOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4874:ParseResult MaskOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 4875:  // Create the op region.
    #####: 4876:  result.regions.reserve(1);
branch  0 never executed
branch  1 never executed
    #####: 4877:  Region &maskRegion = *result.addRegion();
call    0 never executed
        -: 4878:
    #####: 4879:  auto &builder = parser.getBuilder();
call    0 never executed
        -: 4880:
        -: 4881:  // Parse all the operands.
    #####: 4882:  OpAsmParser::UnresolvedOperand mask;
call    0 never executed
    #####: 4883:  if (parser.parseOperand(mask))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4884:    return failure();
        -: 4885:
        -: 4886:  // Optional passthru operand.
    #####: 4887:  OpAsmParser::UnresolvedOperand passthru;
call    0 never executed
    #####: 4888:  ParseResult parsePassthru = parser.parseOptionalComma();
call    0 never executed
    #####: 4889:  if (parsePassthru.succeeded() && parser.parseOperand(passthru))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4890:    return failure();
        -: 4891:
        -: 4892:  // Parse op region.
    #####: 4893:  if (parser.parseRegion(maskRegion, /*arguments=*/{}, /*argTypes=*/{}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4894:    return failure();
        -: 4895:
    #####: 4896:  MaskOp::ensureTerminator(maskRegion, builder, result.location);
call    0 never executed
        -: 4897:
        -: 4898:  // Parse the optional attribute list.
    #####: 4899:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4900:    return failure();
        -: 4901:
        -: 4902:  // Parse all the types.
    #####: 4903:  Type maskType;
    #####: 4904:  if (parser.parseColonType(maskType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4905:    return failure();
        -: 4906:
    #####: 4907:  SmallVector<Type> resultTypes;
call    0 never executed
    #####: 4908:  if (parser.parseOptionalArrowTypeList(resultTypes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4909:    return failure();
    #####: 4910:  result.types.append(resultTypes);
call    0 never executed
        -: 4911:
        -: 4912:  // Resolve operands.
    #####: 4913:  if (parser.resolveOperand(mask, maskType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4914:    return failure();
        -: 4915:
    #####: 4916:  if (parsePassthru.succeeded())
branch  0 never executed
branch  1 never executed
    #####: 4917:    if (parser.resolveOperand(passthru, resultTypes[0], result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4918:      return failure();
        -: 4919:
    #####: 4920:  return success();
        -: 4921:}
        -: 4922:
function _ZN4mlir6vector6MaskOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4923:void mlir::vector::MaskOp::print(OpAsmPrinter &p) {
    #####: 4924:  p << " " << getMask();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4925:  if (getPassthru())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4926:    p << ", " << getPassthru();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4927:
        -: 4928:  // Print single masked operation and skip terminator.
    #####: 4929:  p << " { ";
call    0 never executed
    #####: 4930:  Block *singleBlock = &getMaskRegion().getBlocks().front();
call    0 never executed
call    1 never executed
    #####: 4931:  if (singleBlock && singleBlock->getOperations().size() > 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4932:    p.printCustomOrGenericOp(&singleBlock->front());
call    0 never executed
call    1 never executed
    #####: 4933:  p << " }";
call    0 never executed
        -: 4934:
    #####: 4935:  p.printOptionalAttrDict(getOperation()->getAttrs());
call    0 never executed
call    1 never executed
        -: 4936:
    #####: 4937:  p << " : " << getMask().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4938:  if (getNumResults() > 0)
branch  0 never executed
branch  1 never executed
    #####: 4939:    p << " -> " << getResultTypes();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 4940:}
        -: 4941:
function _ZN4mlir6vector6MaskOp16ensureTerminatorERNS_6RegionERNS_7BuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 4942:void MaskOp::ensureTerminator(Region &region, Builder &builder, Location loc) {
    #####: 4943:  OpTrait::SingleBlockImplicitTerminator<vector::YieldOp>::Impl<
call    0 never executed
    #####: 4944:      MaskOp>::ensureTerminator(region, builder, loc);
        -: 4945:  // Keep the default yield terminator if the number of masked operations is not
        -: 4946:  // the expected. This case will trigger a verification failure.
    #####: 4947:  if (region.front().getOperations().size() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4948:    return;
        -: 4949:
        -: 4950:  // Replace default yield terminator with a new one that returns the results
        -: 4951:  // from the masked operation.
    #####: 4952:  OpBuilder opBuilder(builder.getContext());
call    0 never executed
    #####: 4953:  Operation *maskedOp = &region.front().front();
call    0 never executed
call    1 never executed
    #####: 4954:  Operation *oldYieldOp = &region.front().back();
call    0 never executed
call    1 never executed
    #####: 4955:  assert(isa<vector::YieldOp>(oldYieldOp) && "Expected vector::YieldOp");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 4956:
    #####: 4957:  opBuilder.setInsertionPoint(oldYieldOp);
call    0 never executed
    #####: 4958:  opBuilder.create<vector::YieldOp>(maskedOp->getLoc(), maskedOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4959:  oldYieldOp->dropAllReferences();
call    0 never executed
    #####: 4960:  oldYieldOp->erase();
call    0 never executed
        -: 4961:}
        -: 4962:
function _ZN4mlir6vector6MaskOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4963:LogicalResult MaskOp::verify() {
        -: 4964:  // Structural checks.
    #####: 4965:  Block &block = getMaskRegion().getBlocks().front();
call    0 never executed
call    1 never executed
    #####: 4966:  if (block.getOperations().size() < 2)
branch  0 never executed
branch  1 never executed
    #####: 4967:    return emitOpError("expects an operation to mask");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4968:  if (block.getOperations().size() > 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4969:    return emitOpError("expects only one operation to mask");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4970:
    #####: 4971:  auto maskableOp = dyn_cast<MaskableOpInterface>(block.front());
call    0 never executed
call    1 never executed
    #####: 4972:  if (!maskableOp)
branch  0 never executed
branch  1 never executed
    #####: 4973:    return emitOpError("expects a maskable operation");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4974:
        -: 4975:  // Result checks.
    #####: 4976:  if (maskableOp->getNumResults() != getNumResults())
branch  0 never executed
branch  1 never executed
    #####: 4977:    return emitOpError("expects number of results to match maskable operation "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4978:                       "number of results");
call    0 never executed
        -: 4979:
    #####: 4980:  if (!llvm::equal(maskableOp->getResultTypes(), getResultTypes()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 4981:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4982:        "expects result type to match maskable operation result type");
call    0 never executed
        -: 4983:
        -: 4984:  // Mask checks.
    #####: 4985:  if (getMask().getType() != maskableOp.getExpectedMaskType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4986:    return emitOpError("expects a ") << maskableOp.getExpectedMaskType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 4987:                                     << " mask for the maskable operation";
call    0 never executed
        -: 4988:
        -: 4989:  // Passthru checks.
    #####: 4990:  Value passthru = getPassthru();
call    0 never executed
    #####: 4991:  if (passthru) {
branch  0 never executed
branch  1 never executed
    #####: 4992:    if (!maskableOp.supportsPassthru())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4993:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4994:          "doesn't expect a passthru argument for this maskable operation");
call    0 never executed
        -: 4995:
    #####: 4996:    if (maskableOp->getNumResults() != 1)
branch  0 never executed
branch  1 never executed
    #####: 4997:      return emitOpError("expects result when passthru argument is provided");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4998:
    #####: 4999:    if (passthru.getType() != maskableOp->getResultTypes()[0])
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5000:      return emitOpError("expects passthru type to match result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 5001:  }
        -: 5002:
    #####: 5003:  return success();
        -: 5004:}
        -: 5005:
        -: 5006:// MaskingOpInterface definitions.
        -: 5007:
        -: 5008:/// Returns the operation masked by this 'vector.mask'.
function _ZN4mlir6vector6MaskOp13getMaskableOpEv called 0 returned 0% blocks executed 0%
    #####: 5009:Operation *MaskOp::getMaskableOp() { return &getMaskRegion().front().front(); }
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5010:
        -: 5011:/// Returns true if 'vector.mask' has a passthru value.
function _ZN4mlir6vector6MaskOp11hasPassthruEv called 0 returned 0% blocks executed 0%
    #####: 5012:bool MaskOp::hasPassthru() { return getPassthru() != Value(); }
call    0 never executed
call    1 never executed
        -: 5013:
        -: 5014://===----------------------------------------------------------------------===//
        -: 5015:// ScanOp
        -: 5016://===----------------------------------------------------------------------===//
        -: 5017:
function _ZN4mlir6vector6ScanOp6verifyEv called 60377220 returned 100% blocks executed 41%
 60377220: 5018:LogicalResult ScanOp::verify() {
 60377220: 5019:  VectorType srcType = getSourceType();
call    0 returned 100%
 60377219: 5020:  VectorType initialType = getInitialValueType();
call    0 returned 100%
        -: 5021:  // Check reduction dimension < rank.
 60377218: 5022:  int64_t srcRank = srcType.getRank();
call    0 returned 100%
 60377218: 5023:  int64_t reductionDim = getReductionDim();
call    0 returned 100%
 60377218: 5024:  if (reductionDim >= srcRank)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5025:    return emitOpError("reduction dimension ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 5026:           << reductionDim << " has to be less than " << srcRank;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5027:
        -: 5028:  // Check that rank(initial_value) = rank(src) - 1.
 60377218: 5029:  int64_t initialValueRank = initialType.getRank();
call    0 returned 100%
 60377218: 5030:  if (initialValueRank != srcRank - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5031:    return emitOpError("initial value rank ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5032:           << initialValueRank << " has to be equal to " << srcRank - 1;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 5033:
        -: 5034:  // Check shapes of initial value and src.
 60377218: 5035:  ArrayRef<int64_t> srcShape = srcType.getShape();
call    0 returned 100%
 60377218: 5036:  ArrayRef<int64_t> initialValueShapes = initialType.getShape();
call    0 returned 100%
 60377218: 5037:  SmallVector<int64_t> expectedShape;
202006536: 5038:  for (int i = 0; i < srcRank; i++) {
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
141629317: 5039:    if (i != reductionDim)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
 81252100: 5040:      expectedShape.push_back(srcShape[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 5041:  }
 60377219: 5042:  if (llvm::any_of(llvm::zip(initialValueShapes, expectedShape),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 5043:                   [](std::tuple<int64_t, int64_t> s) {
        -: 5044:                     return std::get<0>(s) != std::get<1>(s);
        -: 5045:                   })) {
    #####: 5046:    return emitOpError("incompatible input/initial value shapes");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 5047:  }
        -: 5048:
        -: 5049:  // Verify supported reduction kind.
 60377219: 5050:  Type eltType = getDestType().getElementType();
call    0 returned 100%
call    1 returned 100%
 60377220: 5051:  if (!isSupportedCombiningKind(getKind(), eltType))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 5052:    return emitOpError("unsupported reduction type ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5053:           << eltType << " for kind '" << stringifyCombiningKind(getKind())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 5054:           << "'";
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5055:
 60377219: 5056:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 5057:}
        -: 5058:
function _ZN4mlir6vector46populateVectorToVectorCanonicalizationPatternsERNS_17RewritePatternSetENS_14PatternBenefitE called 2005 returned 100% blocks executed 100%
     2005: 5059:void mlir::vector::populateVectorToVectorCanonicalizationPatterns(
        -: 5060:    RewritePatternSet &patterns, PatternBenefit benefit) {
     2005: 5061:  patterns
        -: 5062:      .add<CreateMaskFolder, MaskedLoadFolder, MaskedStoreFolder, GatherFolder,
        -: 5063:           ScatterFolder, ExpandLoadFolder, CompressStoreFolder,
        -: 5064:           StridedSliceConstantMaskFolder, TransposeFolder>(
     2005: 5065:          patterns.getContext(), benefit);
call    0 returned 100%
     2006: 5066:}
        -: 5067:
        -: 5068://===----------------------------------------------------------------------===//
        -: 5069:// SplatOp
        -: 5070://===----------------------------------------------------------------------===//
        -: 5071:
function _ZN4mlir6vector7SplatOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 212117 returned 100% blocks executed 92%
   212117: 5072:OpFoldResult SplatOp::fold(ArrayRef<Attribute> operands) {
   212117: 5073:  auto constOperand = operands.front();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   348361: 5074:  if (!constOperand.isa_and_nonnull<IntegerAttr, FloatAttr>())
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    75873: 5075:    return {};
        -: 5076:
        -: 5077:  // SplatElementsAttr::get treats single value for second arg as being a splat.
   136244: 5078:  return SplatElementsAttr::get(getType(), {constOperand});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 5079:}
        -: 5080:
        -: 5081://===----------------------------------------------------------------------===//
        -: 5082:// WarpExecuteOnLane0Op
        -: 5083://===----------------------------------------------------------------------===//
        -: 5084:
function _ZN4mlir6vector20WarpExecuteOnLane0Op5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 5085:void WarpExecuteOnLane0Op::print(OpAsmPrinter &p) {
    #####: 5086:  p << "(" << getLaneid() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 5087:
    #####: 5088:  SmallVector<StringRef> coreAttr = {getWarpSizeAttrName()};
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5089:  auto warpSizeAttr = getOperation()->getAttr(getWarpSizeAttrName());
call    0 never executed
call    1 never executed
    #####: 5090:  p << "[" << warpSizeAttr.cast<IntegerAttr>().getInt() << "]";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 5091:
    #####: 5092:  if (!getArgs().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5093:    p << " args(" << getArgs() << " : " << getArgs().getTypes() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 5094:  if (!getResults().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5095:    p << " -> (" << getResults().getTypes() << ')';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 5096:  p << " ";
call    0 never executed
    #####: 5097:  p.printRegion(getRegion(),
call    0 never executed
call    1 never executed
        -: 5098:                /*printEntryBlockArgs=*/true,
    #####: 5099:                /*printBlockTerminators=*/!getResults().empty());
call    0 never executed
call    1 never executed
    #####: 5100:  p.printOptionalAttrDict(getOperation()->getAttrs(), coreAttr);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5101:}
        -: 5102:
function _ZN4mlir6vector20WarpExecuteOnLane0Op5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 5103:ParseResult WarpExecuteOnLane0Op::parse(OpAsmParser &parser,
        -: 5104:                                        OperationState &result) {
        -: 5105:  // Create the region.
    #####: 5106:  result.regions.reserve(1);
branch  0 never executed
branch  1 never executed
    #####: 5107:  Region *warpRegion = result.addRegion();
call    0 never executed
        -: 5108:
    #####: 5109:  auto &builder = parser.getBuilder();
call    0 never executed
    #####: 5110:  OpAsmParser::UnresolvedOperand laneId;
call    0 never executed
        -: 5111:
        -: 5112:  // Parse predicate operand.
    #####: 5113:  if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5114:      parser.parseOperand(laneId, /*allowResultNumber=*/false) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 5115:      parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5116:    return failure();
        -: 5117:
    #####: 5118:  int64_t warpSize;
    #####: 5119:  if (parser.parseLSquare() || parser.parseInteger(warpSize) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5120:      parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5121:    return failure();
    #####: 5122:  result.addAttribute(getWarpSizeAttrName(OperationName(getOperationName(),
call    0 never executed
call    1 never executed
        -: 5123:                                                        builder.getContext())),
    #####: 5124:                      builder.getI64IntegerAttr(warpSize));
call    0 never executed
        -: 5125:
    #####: 5126:  if (parser.resolveOperand(laneId, builder.getIndexType(), result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5127:    return failure();
        -: 5128:
    #####: 5129:  llvm::SMLoc inputsOperandsLoc;
    #####: 5130:  SmallVector<OpAsmParser::UnresolvedOperand> inputsOperands;
call    0 never executed
    #####: 5131:  SmallVector<Type> inputTypes;
branch  0 never executed
branch  1 never executed
    #####: 5132:  if (succeeded(parser.parseOptionalKeyword("args"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5133:    if (parser.parseLParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5134:      return failure();
        -: 5135:
    #####: 5136:    inputsOperandsLoc = parser.getCurrentLocation();
call    0 never executed
    #####: 5137:    if (parser.parseOperandList(inputsOperands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5138:        parser.parseColonTypeList(inputTypes) || parser.parseRParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 5139:      return failure();
        -: 5140:  }
    #####: 5141:  if (parser.resolveOperands(inputsOperands, inputTypes, inputsOperandsLoc,
branch  0 never executed
branch  1 never executed
    #####: 5142:                             result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5143:    return failure();
        -: 5144:
        -: 5145:  // Parse optional results type list.
    #####: 5146:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5147:    return failure();
        -: 5148:  // Parse the region.
    #####: 5149:  if (parser.parseRegion(*warpRegion, /*arguments=*/{},
branch  0 never executed
branch  1 never executed
    #####: 5150:                         /*argTypes=*/{}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5151:    return failure();
    #####: 5152:  WarpExecuteOnLane0Op::ensureTerminator(*warpRegion, builder, result.location);
call    0 never executed
        -: 5153:
        -: 5154:  // Parse the optional attribute list.
    #####: 5155:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5156:    return failure();
    #####: 5157:  return success();
        -: 5158:}
        -: 5159:
function _ZN4mlir6vector20WarpExecuteOnLane0Op19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####: 5160:void WarpExecuteOnLane0Op::getSuccessorRegions(
        -: 5161:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -: 5162:    SmallVectorImpl<RegionSuccessor> &regions) {
    #####: 5163:  if (index) {
branch  0 never executed
branch  1 never executed
    #####: 5164:    regions.push_back(RegionSuccessor(getResults()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5165:    return;
        -: 5166:  }
        -: 5167:
        -: 5168:  // The warp region is always executed
    #####: 5169:  regions.push_back(RegionSuccessor(&getWarpRegion()));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5170:}
        -: 5171:
function _ZN4mlir6vector20WarpExecuteOnLane0Op5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####: 5172:void WarpExecuteOnLane0Op::build(OpBuilder &builder, OperationState &result,
        -: 5173:                                 TypeRange resultTypes, Value laneId,
        -: 5174:                                 int64_t warpSize) {
    #####: 5175:  build(builder, result, resultTypes, laneId, warpSize,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5176:        /*operands=*/llvm::None, /*argTypes=*/llvm::None);
    #####: 5177:}
        -: 5178:
function _ZN4mlir6vector20WarpExecuteOnLane0Op5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_5ValueElNS_10ValueRangeES6_ called 0 returned 0% blocks executed 0%
    #####: 5179:void WarpExecuteOnLane0Op::build(OpBuilder &builder, OperationState &result,
        -: 5180:                                 TypeRange resultTypes, Value laneId,
        -: 5181:                                 int64_t warpSize, ValueRange args,
        -: 5182:                                 TypeRange blockArgTypes) {
    #####: 5183:  result.addOperands(laneId);
call    0 never executed
call    1 never executed
    #####: 5184:  result.addAttribute(getAttributeNames()[0],
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 5185:                      builder.getI64IntegerAttr(warpSize));
call    0 never executed
    #####: 5186:  result.addTypes(resultTypes);
call    0 never executed
    #####: 5187:  result.addOperands(args);
call    0 never executed
    #####: 5188:  assert(args.size() == blockArgTypes.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 5189:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 5190:  Region *warpRegion = result.addRegion();
call    0 never executed
    #####: 5191:  Block *block = builder.createBlock(warpRegion);
call    0 never executed
call    1 never executed
    #####: 5192:  for (auto it : llvm::zip(blockArgTypes, args))
branch  0 never executed
branch  1 never executed
    #####: 5193:    block->addArgument(std::get<0>(it), std::get<1>(it).getLoc());
call    0 never executed
call    1 never executed
    #####: 5194:}
        -: 5195:
        -: 5196:/// Helper check if the distributed vector type is consistent with the expanded
        -: 5197:/// type and distributed size.
function _ZL21verifyDistributedTypeN4mlir4TypeES0_lPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 5198:static LogicalResult verifyDistributedType(Type expanded, Type distributed,
        -: 5199:                                           int64_t warpSize, Operation *op) {
        -: 5200:  // If the types matches there is no distribution.
    #####: 5201:  if (expanded == distributed)
branch  0 never executed
branch  1 never executed
    #####: 5202:    return success();
    #####: 5203:  auto expandedVecType = expanded.dyn_cast<VectorType>();
call    0 never executed
    #####: 5204:  auto distributedVecType = distributed.dyn_cast<VectorType>();
call    0 never executed
    #####: 5205:  if (!expandedVecType || !distributedVecType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5206:    return op->emitOpError("expected vector type for distributed operands.");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 5207:  if (expandedVecType.getRank() != distributedVecType.getRank() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 5208:      expandedVecType.getElementType() != distributedVecType.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5209:    return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5210:        "expected distributed vectors to have same rank and element type.");
call    0 never executed
    #####: 5211:  bool foundDistributedDim = false;
    #####: 5212:  for (int64_t i = 0, e = expandedVecType.getRank(); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5213:    if (expandedVecType.getDimSize(i) == distributedVecType.getDimSize(i))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5214:      continue;
    #####: 5215:    if (expandedVecType.getDimSize(i) ==
call    0 never executed
    #####: 5216:        distributedVecType.getDimSize(i) * warpSize) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5217:      if (foundDistributedDim)
branch  0 never executed
branch  1 never executed
    #####: 5218:        return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 5219:               << "expected only one dimension to be distributed from "
call    0 never executed
    #####: 5220:               << expandedVecType << " to " << distributedVecType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5221:      foundDistributedDim = true;
    #####: 5222:      continue;
        -: 5223:    }
    #####: 5224:    return op->emitOpError() << "incompatible distribution dimensions from "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 5225:                             << expandedVecType << " to " << distributedVecType;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5226:  }
    #####: 5227:  return success();
        -: 5228:}
        -: 5229:
function _ZN4mlir6vector20WarpExecuteOnLane0Op6verifyEv called 0 returned 0% blocks executed 0%
    #####: 5230:LogicalResult WarpExecuteOnLane0Op::verify() {
    #####: 5231:  if (getArgs().size() != getWarpRegion().getNumArguments())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5232:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5233:        "expected same number op arguments and block arguments.");
call    0 never executed
    #####: 5234:  auto yield =
call    0 never executed
    #####: 5235:      cast<YieldOp>(getWarpRegion().getBlocks().begin()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5236:  if (yield.getNumOperands() != getNumResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5237:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 5238:        "expected same number of yield operands and return values.");
call    0 never executed
    #####: 5239:  int64_t warpSize = getWarpSize();
call    0 never executed
    #####: 5240:  for (auto it : llvm::zip(getWarpRegion().getArguments(), getArgs())) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 5241:    if (failed(verifyDistributedType(std::get<0>(it).getType(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5242:                                     std::get<1>(it).getType(), warpSize,
call    0 never executed
        -: 5243:                                     getOperation())))
    #####: 5244:      return failure();
        -: 5245:  }
    #####: 5246:  for (auto it : llvm::zip(yield.getOperands(), getResults())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5247:    if (failed(verifyDistributedType(std::get<0>(it).getType(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 5248:                                     std::get<1>(it).getType(), warpSize,
call    0 never executed
        -: 5249:                                     getOperation())))
    #####: 5250:      return failure();
        -: 5251:  }
    #####: 5252:  return success();
        -: 5253:}
        -: 5254:
function _ZN4mlir6vector20WarpExecuteOnLane0Op18areTypesCompatibleENS_4TypeES2_ called 0 returned 0% blocks executed 0%
    #####: 5255:bool WarpExecuteOnLane0Op::areTypesCompatible(Type lhs, Type rhs) {
    #####: 5256:  return succeeded(
call    0 never executed
call    1 never executed
    #####: 5257:      verifyDistributedType(lhs, rhs, getWarpSize(), getOperation()));
call    0 never executed
        -: 5258:}
        -: 5259:
function _ZN4mlir6vector18makeArithReductionERNS_9OpBuilderENS_8LocationENS0_13CombiningKindENS_5ValueES5_ called 83 returned 100% blocks executed 67%
       83: 5260:Value mlir::vector::makeArithReduction(OpBuilder &b, Location loc,
        -: 5261:                                       CombiningKind kind, Value v1, Value v2) {
       83: 5262:  Type t1 = getElementTypeOrSelf(v1.getType());
call    0 returned 100%
       83: 5263:  Type t2 = getElementTypeOrSelf(v2.getType());
call    0 returned 100%
       83: 5264:  switch (kind) {
branch  0 taken 33%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 5%
branch  4 taken 2%
branch  5 taken 11%
branch  6 taken 12%
branch  7 taken 4%
branch  8 taken 11%
branch  9 taken 23%
branch 10 taken 0%
branch 11 taken 0%
       27: 5265:  case CombiningKind::ADD:
       27: 5266:    if (t1.isIntOrIndex() && t2.isIntOrIndex())
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       16: 5267:      return b.createOrFold<arith::AddIOp>(loc, v1, v2);
call    0 returned 100%
       22: 5268:    else if (t1.isa<FloatType>() && t2.isa<FloatType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
       11: 5269:      return b.createOrFold<arith::AddFOp>(loc, v1, v2);
call    0 returned 100%
    #####: 5270:    llvm_unreachable("invalid value types for ADD reduction");
call    0 never executed
    #####: 5271:  case CombiningKind::AND:
    #####: 5272:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 5273:    return b.createOrFold<arith::AndIOp>(loc, v1, v2);
call    0 never executed
    #####: 5274:  case CombiningKind::MAXF:
    #####: 5275:    assert(t1.isa<FloatType>() && t2.isa<FloatType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 5276:           "expected float values");
    #####: 5277:    return b.createOrFold<arith::MaxFOp>(loc, v1, v2);
call    0 never executed
        4: 5278:  case CombiningKind::MINF:
       8*: 5279:    assert(t1.isa<FloatType>() && t2.isa<FloatType>() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -: 5280:           "expected float values");
        4: 5281:    return b.createOrFold<arith::MinFOp>(loc, v1, v2);
call    0 returned 100%
        2: 5282:  case CombiningKind::MAXSI:
       2*: 5283:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        2: 5284:    return b.createOrFold<arith::MaxSIOp>(loc, v1, v2);
call    0 returned 100%
        9: 5285:  case CombiningKind::MINSI:
       9*: 5286:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        9: 5287:    return b.createOrFold<arith::MinSIOp>(loc, v1, v2);
call    0 returned 100%
       10: 5288:  case CombiningKind::MAXUI:
      10*: 5289:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
       10: 5290:    return b.createOrFold<arith::MaxUIOp>(loc, v1, v2);
call    0 returned 100%
        3: 5291:  case CombiningKind::MINUI:
       3*: 5292:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        3: 5293:    return b.createOrFold<arith::MinUIOp>(loc, v1, v2);
call    0 returned 100%
        9: 5294:  case CombiningKind::MUL:
        9: 5295:    if (t1.isIntOrIndex() && t2.isIntOrIndex())
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        5: 5296:      return b.createOrFold<arith::MulIOp>(loc, v1, v2);
call    0 returned 100%
        8: 5297:    else if (t1.isa<FloatType>() && t2.isa<FloatType>())
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        4: 5298:      return b.createOrFold<arith::MulFOp>(loc, v1, v2);
call    0 returned 100%
    #####: 5299:    llvm_unreachable("invalid value types for MUL reduction");
call    0 never executed
       19: 5300:  case CombiningKind::OR:
      19*: 5301:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
       19: 5302:    return b.createOrFold<arith::OrIOp>(loc, v1, v2);
call    0 returned 100%
    #####: 5303:  case CombiningKind::XOR:
    #####: 5304:    assert(t1.isIntOrIndex() && t2.isIntOrIndex() && "expected int values");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 5305:    return b.createOrFold<arith::XOrIOp>(loc, v1, v2);
call    0 never executed
    #####: 5306:  };
    #####: 5307:  llvm_unreachable("unknown CombiningKind");
call    0 never executed
        -: 5308:}
        -: 5309:
        -: 5310://===----------------------------------------------------------------------===//
        -: 5311:// TableGen'd op method definitions
        -: 5312://===----------------------------------------------------------------------===//
        -: 5313:
        -: 5314:#define GET_ATTRDEF_CLASSES
        -: 5315:#include "mlir/Dialect/Vector/IR/VectorOpsAttrDefs.cpp.inc"
        -: 5316:
        -: 5317:#define GET_OP_CLASSES
        -: 5318:#include "mlir/Dialect/Vector/IR/VectorOps.cpp.inc"
