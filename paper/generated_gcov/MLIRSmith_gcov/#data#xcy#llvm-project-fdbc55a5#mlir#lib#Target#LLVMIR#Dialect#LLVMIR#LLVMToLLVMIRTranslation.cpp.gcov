        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.cpp
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:116169
        -:    1://===- LLVMToLLVMIRTranslation.cpp - Translate LLVM dialect to LLVM IR ----===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements a translation between the MLIR LLVM dialect and LLVM IR.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Target/LLVMIR/Dialect/LLVMIR/LLVMToLLVMIRTranslation.h"
        -:   14:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   15:#include "mlir/IR/Operation.h"
        -:   16:#include "mlir/Support/LLVM.h"
        -:   17:#include "mlir/Target/LLVMIR/ModuleTranslation.h"
        -:   18:
        -:   19:#include "llvm/IR/IRBuilder.h"
        -:   20:#include "llvm/IR/InlineAsm.h"
        -:   21:#include "llvm/IR/MDBuilder.h"
        -:   22:#include "llvm/IR/MatrixBuilder.h"
        -:   23:#include "llvm/IR/Operator.h"
        -:   24:
        -:   25:using namespace mlir;
        -:   26:using namespace mlir::LLVM;
        -:   27:using mlir::LLVM::detail::getLLVMConstant;
        -:   28:
        -:   29:#include "mlir/Dialect/LLVMIR/LLVMConversionEnumsToLLVM.inc"
        -:   30:
        -:   31:/// Convert MLIR integer comparison predicate to LLVM IR comparison predicate.
    #####:   32:static llvm::CmpInst::Predicate getLLVMCmpPredicate(ICmpPredicate p) {
    #####:   33:  switch (p) {
branch  0 never executed
branch  1 never executed
        -:   34:  case LLVM::ICmpPredicate::eq:
        -:   35:    return llvm::CmpInst::Predicate::ICMP_EQ;
        -:   36:  case LLVM::ICmpPredicate::ne:
        -:   37:    return llvm::CmpInst::Predicate::ICMP_NE;
        -:   38:  case LLVM::ICmpPredicate::slt:
        -:   39:    return llvm::CmpInst::Predicate::ICMP_SLT;
        -:   40:  case LLVM::ICmpPredicate::sle:
        -:   41:    return llvm::CmpInst::Predicate::ICMP_SLE;
        -:   42:  case LLVM::ICmpPredicate::sgt:
        -:   43:    return llvm::CmpInst::Predicate::ICMP_SGT;
        -:   44:  case LLVM::ICmpPredicate::sge:
        -:   45:    return llvm::CmpInst::Predicate::ICMP_SGE;
        -:   46:  case LLVM::ICmpPredicate::ult:
        -:   47:    return llvm::CmpInst::Predicate::ICMP_ULT;
        -:   48:  case LLVM::ICmpPredicate::ule:
        -:   49:    return llvm::CmpInst::Predicate::ICMP_ULE;
        -:   50:  case LLVM::ICmpPredicate::ugt:
        -:   51:    return llvm::CmpInst::Predicate::ICMP_UGT;
        -:   52:  case LLVM::ICmpPredicate::uge:
        -:   53:    return llvm::CmpInst::Predicate::ICMP_UGE;
        -:   54:  }
    #####:   55:  llvm_unreachable("incorrect comparison predicate");
call    0 never executed
        -:   56:}
        -:   57:
    #####:   58:static llvm::CmpInst::Predicate getLLVMCmpPredicate(FCmpPredicate p) {
    #####:   59:  switch (p) {
branch  0 never executed
branch  1 never executed
        -:   60:  case LLVM::FCmpPredicate::_false:
        -:   61:    return llvm::CmpInst::Predicate::FCMP_FALSE;
        -:   62:  case LLVM::FCmpPredicate::oeq:
        -:   63:    return llvm::CmpInst::Predicate::FCMP_OEQ;
        -:   64:  case LLVM::FCmpPredicate::ogt:
        -:   65:    return llvm::CmpInst::Predicate::FCMP_OGT;
        -:   66:  case LLVM::FCmpPredicate::oge:
        -:   67:    return llvm::CmpInst::Predicate::FCMP_OGE;
        -:   68:  case LLVM::FCmpPredicate::olt:
        -:   69:    return llvm::CmpInst::Predicate::FCMP_OLT;
        -:   70:  case LLVM::FCmpPredicate::ole:
        -:   71:    return llvm::CmpInst::Predicate::FCMP_OLE;
        -:   72:  case LLVM::FCmpPredicate::one:
        -:   73:    return llvm::CmpInst::Predicate::FCMP_ONE;
        -:   74:  case LLVM::FCmpPredicate::ord:
        -:   75:    return llvm::CmpInst::Predicate::FCMP_ORD;
        -:   76:  case LLVM::FCmpPredicate::ueq:
        -:   77:    return llvm::CmpInst::Predicate::FCMP_UEQ;
        -:   78:  case LLVM::FCmpPredicate::ugt:
        -:   79:    return llvm::CmpInst::Predicate::FCMP_UGT;
        -:   80:  case LLVM::FCmpPredicate::uge:
        -:   81:    return llvm::CmpInst::Predicate::FCMP_UGE;
        -:   82:  case LLVM::FCmpPredicate::ult:
        -:   83:    return llvm::CmpInst::Predicate::FCMP_ULT;
        -:   84:  case LLVM::FCmpPredicate::ule:
        -:   85:    return llvm::CmpInst::Predicate::FCMP_ULE;
        -:   86:  case LLVM::FCmpPredicate::une:
        -:   87:    return llvm::CmpInst::Predicate::FCMP_UNE;
        -:   88:  case LLVM::FCmpPredicate::uno:
        -:   89:    return llvm::CmpInst::Predicate::FCMP_UNO;
        -:   90:  case LLVM::FCmpPredicate::_true:
        -:   91:    return llvm::CmpInst::Predicate::FCMP_TRUE;
        -:   92:  }
    #####:   93:  llvm_unreachable("incorrect comparison predicate");
call    0 never executed
        -:   94:}
        -:   95:
    #####:   96:static llvm::AtomicRMWInst::BinOp getLLVMAtomicBinOp(AtomicBinOp op) {
    #####:   97:  switch (op) {
branch  0 never executed
branch  1 never executed
        -:   98:  case LLVM::AtomicBinOp::xchg:
        -:   99:    return llvm::AtomicRMWInst::BinOp::Xchg;
        -:  100:  case LLVM::AtomicBinOp::add:
        -:  101:    return llvm::AtomicRMWInst::BinOp::Add;
        -:  102:  case LLVM::AtomicBinOp::sub:
        -:  103:    return llvm::AtomicRMWInst::BinOp::Sub;
        -:  104:  case LLVM::AtomicBinOp::_and:
        -:  105:    return llvm::AtomicRMWInst::BinOp::And;
        -:  106:  case LLVM::AtomicBinOp::nand:
        -:  107:    return llvm::AtomicRMWInst::BinOp::Nand;
        -:  108:  case LLVM::AtomicBinOp::_or:
        -:  109:    return llvm::AtomicRMWInst::BinOp::Or;
        -:  110:  case LLVM::AtomicBinOp::_xor:
        -:  111:    return llvm::AtomicRMWInst::BinOp::Xor;
        -:  112:  case LLVM::AtomicBinOp::max:
        -:  113:    return llvm::AtomicRMWInst::BinOp::Max;
        -:  114:  case LLVM::AtomicBinOp::min:
        -:  115:    return llvm::AtomicRMWInst::BinOp::Min;
        -:  116:  case LLVM::AtomicBinOp::umax:
        -:  117:    return llvm::AtomicRMWInst::BinOp::UMax;
        -:  118:  case LLVM::AtomicBinOp::umin:
        -:  119:    return llvm::AtomicRMWInst::BinOp::UMin;
        -:  120:  case LLVM::AtomicBinOp::fadd:
        -:  121:    return llvm::AtomicRMWInst::BinOp::FAdd;
        -:  122:  case LLVM::AtomicBinOp::fsub:
        -:  123:    return llvm::AtomicRMWInst::BinOp::FSub;
        -:  124:  }
    #####:  125:  llvm_unreachable("incorrect atomic binary operator");
call    0 never executed
        -:  126:}
        -:  127:
function _ZL21getLLVMAtomicOrderingN4mlir4LLVM14AtomicOrderingE called 0 returned 0% blocks executed 0%
    #####:  128:static llvm::AtomicOrdering getLLVMAtomicOrdering(AtomicOrdering ordering) {
    #####:  129:  switch (ordering) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  130:  case LLVM::AtomicOrdering::not_atomic:
        -:  131:    return llvm::AtomicOrdering::NotAtomic;
    #####:  132:  case LLVM::AtomicOrdering::unordered:
    #####:  133:    return llvm::AtomicOrdering::Unordered;
    #####:  134:  case LLVM::AtomicOrdering::monotonic:
    #####:  135:    return llvm::AtomicOrdering::Monotonic;
    #####:  136:  case LLVM::AtomicOrdering::acquire:
    #####:  137:    return llvm::AtomicOrdering::Acquire;
    #####:  138:  case LLVM::AtomicOrdering::release:
    #####:  139:    return llvm::AtomicOrdering::Release;
    #####:  140:  case LLVM::AtomicOrdering::acq_rel:
    #####:  141:    return llvm::AtomicOrdering::AcquireRelease;
    #####:  142:  case LLVM::AtomicOrdering::seq_cst:
    #####:  143:    return llvm::AtomicOrdering::SequentiallyConsistent;
        -:  144:  }
    #####:  145:  llvm_unreachable("incorrect atomic ordering");
call    0 never executed
        -:  146:}
        -:  147:
function _ZL16getFastmathFlagsRN4mlir4LLVM22FastmathFlagsInterfaceE called 0 returned 0% blocks executed 0%
    #####:  148:static llvm::FastMathFlags getFastmathFlags(FastmathFlagsInterface &op) {
    #####:  149:  using llvmFMF = llvm::FastMathFlags;
    #####:  150:  using FuncT = void (llvmFMF::*)(bool);
    #####:  151:  const std::pair<FastmathFlags, FuncT> handlers[] = {
        -:  152:      // clang-format off
        -:  153:      {FastmathFlags::nnan,     &llvmFMF::setNoNaNs},
        -:  154:      {FastmathFlags::ninf,     &llvmFMF::setNoInfs},
        -:  155:      {FastmathFlags::nsz,      &llvmFMF::setNoSignedZeros},
        -:  156:      {FastmathFlags::arcp,     &llvmFMF::setAllowReciprocal},
        -:  157:      {FastmathFlags::contract, &llvmFMF::setAllowContract},
        -:  158:      {FastmathFlags::afn,      &llvmFMF::setApproxFunc},
        -:  159:      {FastmathFlags::reassoc,  &llvmFMF::setAllowReassoc},
        -:  160:      // clang-format on
        -:  161:  };
    #####:  162:  llvm::FastMathFlags ret;
    #####:  163:  ::mlir::LLVM::FastmathFlags fmfMlir = op.getFastmathAttr().getValue();
call    0 never executed
call    1 never executed
    #####:  164:  for (auto it : handlers)
branch  0 never executed
branch  1 never executed
    #####:  165:    if (bitEnumContainsAll(fmfMlir, it.first))
branch  0 never executed
branch  1 never executed
    #####:  166:      (ret.*(it.second))(true);
call    0 never executed
    #####:  167:  return ret;
        -:  168:}
        -:  169:
        -:  170:/// Returns an LLVM metadata node corresponding to a loop option. This metadata
        -:  171:/// is attached to an llvm.loop node.
function _ZL21getLoopOptionMetadataRN4llvm11LLVMContextEN4mlir4LLVM14LoopOptionCaseEl called 0 returned 0% blocks executed 0%
    #####:  172:static llvm::MDNode *getLoopOptionMetadata(llvm::LLVMContext &ctx,
        -:  173:                                           LoopOptionCase option,
        -:  174:                                           int64_t value) {
    #####:  175:  StringRef name;
    #####:  176:  llvm::Constant *cstValue = nullptr;
    #####:  177:  switch (option) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  178:  case LoopOptionCase::disable_licm:
    #####:  179:    name = "llvm.licm.disable";
call    0 never executed
    #####:  180:    cstValue = llvm::ConstantInt::getBool(ctx, value);
    #####:  181:    break;
call    0 never executed
    #####:  182:  case LoopOptionCase::disable_unroll:
    #####:  183:    name = "llvm.loop.unroll.disable";
call    0 never executed
    #####:  184:    cstValue = llvm::ConstantInt::getBool(ctx, value);
    #####:  185:    break;
call    0 never executed
    #####:  186:  case LoopOptionCase::interleave_count:
    #####:  187:    name = "llvm.loop.interleave.count";
call    0 never executed
    #####:  188:    cstValue = llvm::ConstantInt::get(
call    0 never executed
        -:  189:        llvm::IntegerType::get(ctx, /*NumBits=*/32), value);
    #####:  190:    break;
call    0 never executed
    #####:  191:  case LoopOptionCase::disable_pipeline:
    #####:  192:    name = "llvm.loop.pipeline.disable";
call    0 never executed
    #####:  193:    cstValue = llvm::ConstantInt::getBool(ctx, value);
    #####:  194:    break;
call    0 never executed
    #####:  195:  case LoopOptionCase::pipeline_initiation_interval:
    #####:  196:    name = "llvm.loop.pipeline.initiationinterval";
call    0 never executed
    #####:  197:    cstValue = llvm::ConstantInt::get(
call    0 never executed
        -:  198:        llvm::IntegerType::get(ctx, /*NumBits=*/32), value);
    #####:  199:    break;
call    0 never executed
        -:  200:  }
    #####:  201:  return llvm::MDNode::get(ctx, {llvm::MDString::get(ctx, name),
call    0 never executed
call    1 never executed
    #####:  202:                                 llvm::ConstantAsMetadata::get(cstValue)});
call    0 never executed
        -:  203:}
        -:  204:
function _ZL15setLoopMetadataRN4mlir9OperationERN4llvm11InstructionERNS2_13IRBuilderBaseERNS_4LLVM17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  205:static void setLoopMetadata(Operation &opInst, llvm::Instruction &llvmInst,
        -:  206:                            llvm::IRBuilderBase &builder,
        -:  207:                            LLVM::ModuleTranslation &moduleTranslation) {
    #####:  208:  if (Attribute attr = opInst.getAttr(LLVMDialect::getLoopAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  209:    llvm::Module *module = builder.GetInsertBlock()->getModule();
call    0 never executed
    #####:  210:    llvm::MDNode *loopMD = moduleTranslation.lookupLoopOptionsMetadata(attr);
call    0 never executed
    #####:  211:    if (!loopMD) {
branch  0 never executed
branch  1 never executed
    #####:  212:      llvm::LLVMContext &ctx = module->getContext();
call    0 never executed
        -:  213:
    #####:  214:      SmallVector<llvm::Metadata *> loopOptions;
call    0 never executed
        -:  215:      // Reserve operand 0 for loop id self reference.
    #####:  216:      auto dummy = llvm::MDNode::getTemporary(ctx, llvm::None);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:      loopOptions.push_back(dummy.get());
call    0 never executed
        -:  218:
    #####:  219:      auto loopAttr = attr.cast<DictionaryAttr>();
call    0 never executed
    #####:  220:      auto parallelAccessGroup =
call    0 never executed
    #####:  221:          loopAttr.getNamed(LLVMDialect::getParallelAccessAttrName());
call    0 never executed
    #####:  222:      if (parallelAccessGroup) {
branch  0 never executed
branch  1 never executed
    #####:  223:        SmallVector<llvm::Metadata *> parallelAccess;
call    0 never executed
    #####:  224:        parallelAccess.push_back(
call    0 never executed
    #####:  225:            llvm::MDString::get(ctx, "llvm.loop.parallel_accesses"));
call    0 never executed
    #####:  226:        for (SymbolRefAttr accessGroupRef : parallelAccessGroup->getValue()
call    0 never executed
    #####:  227:                                                .cast<ArrayAttr>()
    #####:  228:                                                .getAsRange<SymbolRefAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  229:          parallelAccess.push_back(
call    0 never executed
    #####:  230:              moduleTranslation.getAccessGroup(opInst, accessGroupRef));
call    0 never executed
    #####:  231:        loopOptions.push_back(llvm::MDNode::get(ctx, parallelAccess));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  232:      }
        -:  233:
    #####:  234:      if (auto loopOptionsAttr = loopAttr.getAs<LoopOptionsAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  235:              LLVMDialect::getLoopOptionsAttrName())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  236:        for (auto option : loopOptionsAttr.getOptions())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  237:          loopOptions.push_back(
call    0 never executed
    #####:  238:              getLoopOptionMetadata(ctx, option.first, option.second));
call    0 never executed
        -:  239:      }
        -:  240:
        -:  241:      // Create loop options and set the first operand to itself.
    #####:  242:      loopMD = llvm::MDNode::get(ctx, loopOptions);
call    0 never executed
    #####:  243:      loopMD->replaceOperandWith(0, loopMD);
call    0 never executed
        -:  244:
        -:  245:      // Store a map from this Attribute to the LLVM metadata in case we
        -:  246:      // encounter it again.
    #####:  247:      moduleTranslation.mapLoopOptionsMetadata(attr, loopMD);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  248:    }
        -:  249:
    #####:  250:    llvmInst.setMetadata(module->getMDKindID("llvm.loop"), loopMD);
call    0 never executed
call    1 never executed
        -:  251:  }
    #####:  252:}
        -:  253:
        -:  254:/// Convert the value of a DenseI64ArrayAttr to a vector of unsigned indices.
    #####:  255:static SmallVector<unsigned> extractPosition(ArrayRef<int64_t> indices) {
    #####:  256:  SmallVector<unsigned> position;
call    0 never executed
call    1 never executed
    #####:  257:  llvm::append_range(position, indices);
call    0 never executed
call    1 never executed
    #####:  258:  return position;
call    0 never executed
call    1 never executed
        -:  259:}
        -:  260:
        -:  261:static LogicalResult
function _ZL20convertOperationImplRN4mlir9OperationERN4llvm13IRBuilderBaseERNS_4LLVM17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  262:convertOperationImpl(Operation &opInst, llvm::IRBuilderBase &builder,
        -:  263:                     LLVM::ModuleTranslation &moduleTranslation) {
        -:  264:
    #####:  265:  llvm::IRBuilder<>::FastMathFlagGuard fmfGuard(builder);
call    0 never executed
    #####:  266:  if (auto fmf = dyn_cast<FastmathFlagsInterface>(opInst))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  267:    builder.setFastMathFlags(getFastmathFlags(fmf));
call    0 never executed
        -:  268:
        -:  269:#include "mlir/Dialect/LLVMIR/LLVMConversions.inc"
        -:  270:#include "mlir/Dialect/LLVMIR/LLVMIntrinsicConversions.inc"
        -:  271:
        -:  272:  // Emit function calls.  If the "callee" attribute is present, this is a
        -:  273:  // direct function call and we also need to look up the remapped function
        -:  274:  // itself.  Otherwise, this is an indirect call and the callee is the first
        -:  275:  // operand, look it up as a normal value.  Return the llvm::Value representing
        -:  276:  // the function result, which may be of llvm::VoidTy type.
function _ZZL20convertOperationImplRN4mlir9OperationERN4llvm13IRBuilderBaseERNS_4LLVM17ModuleTranslationEENKUlS1_E_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  277:  auto convertCall = [&](Operation &op) -> llvm::Value * {
    #####:  278:    auto operands = moduleTranslation.lookupValues(op.getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  279:    ArrayRef<llvm::Value *> operandsRef(operands);
call    0 never executed
    #####:  280:    if (auto attr = op.getAttrOfType<FlatSymbolRefAttr>("callee"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  281:      return builder.CreateCall(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  282:          moduleTranslation.lookupFunction(attr.getValue()), operandsRef);
    #####:  283:    auto calleeType =
call    0 never executed
    #####:  284:        op.getOperands().front().getType().cast<LLVMPointerType>();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  285:    auto *calleeFunctionType = cast<llvm::FunctionType>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  286:        moduleTranslation.convertType(calleeType.getElementType()));
    #####:  287:    return builder.CreateCall(calleeFunctionType, operandsRef.front(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  288:                              operandsRef.drop_front());
    #####:  289:  };
        -:  290:
        -:  291:  // Emit calls.  If the called function has a result, remap the corresponding
        -:  292:  // value.  Note that LLVM IR dialect CallOp has either 0 or 1 result.
    #####:  293:  if (isa<LLVM::CallOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:    llvm::Value *result = convertCall(opInst);
call    0 never executed
    #####:  295:    if (opInst.getNumResults() != 0) {
branch  0 never executed
branch  1 never executed
    #####:  296:      moduleTranslation.mapValue(opInst.getResult(0), result);
call    0 never executed
    #####:  297:      return success();
        -:  298:    }
        -:  299:    // Check that LLVM call returns void for 0-result functions.
    #####:  300:    return success(result->getType()->isVoidTy());
        -:  301:  }
        -:  302:
    #####:  303:  if (auto inlineAsmOp = dyn_cast<LLVM::InlineAsmOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  304:    // TODO: refactor function type creation which usually occurs in std-LLVM
        -:  305:    // conversion.
    #####:  306:    SmallVector<Type, 8> operandTypes;
call    0 never executed
    #####:  307:    llvm::append_range(operandTypes, inlineAsmOp.getOperands().getTypes());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  308:
    #####:  309:    Type resultType;
    #####:  310:    if (inlineAsmOp.getNumResults() == 0) {
branch  0 never executed
branch  1 never executed
    #####:  311:      resultType = LLVM::LLVMVoidType::get(&moduleTranslation.getContext());
call    0 never executed
call    1 never executed
        -:  312:    } else {
    #####:  313:      assert(inlineAsmOp.getNumResults() == 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  314:      resultType = inlineAsmOp.getResultTypes()[0];
call    0 never executed
call    1 never executed
        -:  315:    }
    #####:  316:    auto ft = LLVM::LLVMFunctionType::get(resultType, operandTypes);
call    0 never executed
    #####:  317:    llvm::InlineAsm *inlineAsmInst =
    #####:  318:        inlineAsmOp.getAsmDialect()
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  319:            ? llvm::InlineAsm::get(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  320:                  static_cast<llvm::FunctionType *>(
    #####:  321:                      moduleTranslation.convertType(ft)),
call    0 never executed
        -:  322:                  inlineAsmOp.getAsmString(), inlineAsmOp.getConstraints(),
    #####:  323:                  inlineAsmOp.getHasSideEffects(),
call    0 never executed
    #####:  324:                  inlineAsmOp.getIsAlignStack(),
call    0 never executed
    #####:  325:                  convertAsmDialectToLLVM(*inlineAsmOp.getAsmDialect()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  326:            : llvm::InlineAsm::get(static_cast<llvm::FunctionType *>(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  327:                                       moduleTranslation.convertType(ft)),
call    0 never executed
        -:  328:                                   inlineAsmOp.getAsmString(),
        -:  329:                                   inlineAsmOp.getConstraints(),
    #####:  330:                                   inlineAsmOp.getHasSideEffects(),
call    0 never executed
    #####:  331:                                   inlineAsmOp.getIsAlignStack());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  332:    llvm::CallInst *inst = builder.CreateCall(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  333:        inlineAsmInst,
    #####:  334:        moduleTranslation.lookupValues(inlineAsmOp.getOperands()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  335:    if (auto maybeOperandAttrs = inlineAsmOp.getOperandAttrs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  336:      llvm::AttributeList attrList;
    #####:  337:      for (const auto &it : llvm::enumerate(*maybeOperandAttrs)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  338:        Attribute attr = it.value();
branch  0 never executed
branch  1 never executed
    #####:  339:        if (!attr)
branch  0 never executed
branch  1 never executed
    #####:  340:          continue;
    #####:  341:        DictionaryAttr dAttr = attr.cast<DictionaryAttr>();
call    0 never executed
    #####:  342:        TypeAttr tAttr =
call    0 never executed
    #####:  343:            dAttr.get(InlineAsmOp::getElementTypeAttrName()).cast<TypeAttr>();
call    0 never executed
call    1 never executed
    #####:  344:        llvm::AttrBuilder b(moduleTranslation.getLLVMContext());
call    0 never executed
    #####:  345:        llvm::Type *ty = moduleTranslation.convertType(tAttr.getValue());
call    0 never executed
call    1 never executed
    #####:  346:        b.addTypeAttr(llvm::Attribute::ElementType, ty);
call    0 never executed
        -:  347:        // shift to account for the returned value (this is always 1 aggregate
        -:  348:        // value in LLVM).
    #####:  349:        int shift = (opInst.getNumResults() > 0) ? 1 : 0;
branch  0 never executed
branch  1 never executed
    #####:  350:        attrList = attrList.addAttributesAtIndex(
    #####:  351:            moduleTranslation.getLLVMContext(), it.index() + shift, b);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  352:      }
    #####:  353:      inst->setAttributes(attrList);
        -:  354:    }
        -:  355:
    #####:  356:    if (opInst.getNumResults() != 0)
branch  0 never executed
branch  1 never executed
    #####:  357:      moduleTranslation.mapValue(opInst.getResult(0), inst);
call    0 never executed
    #####:  358:    return success();
branch  0 never executed
branch  1 never executed
        -:  359:  }
        -:  360:
    #####:  361:  if (auto invOp = dyn_cast<LLVM::InvokeOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  362:    auto operands = moduleTranslation.lookupValues(invOp.getCalleeOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  363:    ArrayRef<llvm::Value *> operandsRef(operands);
call    0 never executed
    #####:  364:    llvm::Instruction *result;
    #####:  365:    if (auto attr = opInst.getAttrOfType<FlatSymbolRefAttr>("callee")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  366:      result = builder.CreateInvoke(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
        -:  367:          moduleTranslation.lookupFunction(attr.getValue()),
        -:  368:          moduleTranslation.lookupBlock(invOp.getSuccessor(0)),
        -:  369:          moduleTranslation.lookupBlock(invOp.getSuccessor(1)), operandsRef);
        -:  370:    } else {
    #####:  371:      auto calleeType =
    #####:  372:          invOp.getCalleeOperands().front().getType().cast<LLVMPointerType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  373:      auto *calleeFunctionType = cast<llvm::FunctionType>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  374:          moduleTranslation.convertType(calleeType.getElementType()));
    #####:  375:      result = builder.CreateInvoke(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  376:          calleeFunctionType, operandsRef.front(),
call    0 never executed
        -:  377:          moduleTranslation.lookupBlock(invOp.getSuccessor(0)),
        -:  378:          moduleTranslation.lookupBlock(invOp.getSuccessor(1)),
        -:  379:          operandsRef.drop_front());
        -:  380:    }
    #####:  381:    moduleTranslation.mapBranch(invOp, result);
call    0 never executed
        -:  382:    // InvokeOp can only have 0 or 1 result
    #####:  383:    if (invOp->getNumResults() != 0) {
branch  0 never executed
branch  1 never executed
    #####:  384:      moduleTranslation.mapValue(opInst.getResult(0), result);
call    0 never executed
    #####:  385:      return success();
        -:  386:    }
    #####:  387:    return success(result->getType()->isVoidTy());
branch  0 never executed
branch  1 never executed
        -:  388:  }
        -:  389:
    #####:  390:  if (auto lpOp = dyn_cast<LLVM::LandingpadOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  391:    llvm::Type *ty = moduleTranslation.convertType(lpOp.getType());
call    0 never executed
    #####:  392:    llvm::LandingPadInst *lpi =
    #####:  393:        builder.CreateLandingPad(ty, lpOp.getNumOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  394:    lpi->setCleanup(lpOp.getCleanup());
call    0 never executed
call    1 never executed
        -:  395:
        -:  396:    // Add clauses
    #####:  397:    for (llvm::Value *operand :
call    0 never executed
    #####:  398:         moduleTranslation.lookupValues(lpOp.getOperands())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  399:      // All operands should be constant - checked by verifier
    #####:  400:      if (auto *constOperand = dyn_cast<llvm::Constant>(operand))
branch  0 never executed
branch  1 never executed
    #####:  401:        lpi->addClause(constOperand);
call    0 never executed
        -:  402:    }
    #####:  403:    moduleTranslation.mapValue(lpOp.getResult(), lpi);
call    0 never executed
    #####:  404:    return success();
        -:  405:  }
        -:  406:
        -:  407:  // Emit branches.  We need to look up the remapped blocks and ignore the block
        -:  408:  // arguments that were transformed into PHI nodes.
    #####:  409:  if (auto brOp = dyn_cast<LLVM::BrOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  410:    llvm::BranchInst *branch =
call    0 never executed
    #####:  411:        builder.CreateBr(moduleTranslation.lookupBlock(brOp.getSuccessor()));
call    0 never executed
call    1 never executed
    #####:  412:    moduleTranslation.mapBranch(&opInst, branch);
call    0 never executed
    #####:  413:    setLoopMetadata(opInst, *branch, builder, moduleTranslation);
call    0 never executed
    #####:  414:    return success();
        -:  415:  }
    #####:  416:  if (auto condbrOp = dyn_cast<LLVM::CondBrOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  417:    llvm::MDNode *branchWeights = nullptr;
    #####:  418:    if (auto weights = condbrOp.getBranchWeights()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  419:      // Map weight attributes to LLVM metadata.
    #####:  420:      auto weightValues = weights->getValues<APInt>();
call    0 never executed
    #####:  421:      auto trueWeight = weightValues[0].getSExtValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  422:      auto falseWeight = weightValues[1].getSExtValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  423:      branchWeights =
call    0 never executed
    #####:  424:          llvm::MDBuilder(moduleTranslation.getLLVMContext())
call    0 never executed
    #####:  425:              .createBranchWeights(static_cast<uint32_t>(trueWeight),
call    0 never executed
call    1 never executed
        -:  426:                                   static_cast<uint32_t>(falseWeight));
        -:  427:    }
    #####:  428:    llvm::BranchInst *branch = builder.CreateCondBr(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  429:        moduleTranslation.lookupValue(condbrOp.getOperand(0)),
        -:  430:        moduleTranslation.lookupBlock(condbrOp.getSuccessor(0)),
        -:  431:        moduleTranslation.lookupBlock(condbrOp.getSuccessor(1)), branchWeights);
    #####:  432:    moduleTranslation.mapBranch(&opInst, branch);
call    0 never executed
    #####:  433:    setLoopMetadata(opInst, *branch, builder, moduleTranslation);
call    0 never executed
    #####:  434:    return success();
        -:  435:  }
    #####:  436:  if (auto switchOp = dyn_cast<LLVM::SwitchOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  437:    llvm::MDNode *branchWeights = nullptr;
    #####:  438:    if (auto weights = switchOp.getBranchWeights()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  439:      llvm::SmallVector<uint32_t> weightValues;
call    0 never executed
    #####:  440:      weightValues.reserve(weights->size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  441:      for (llvm::APInt weight : weights->cast<DenseIntElementsAttr>())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  442:        weightValues.push_back(weight.getLimitedValue());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  443:      branchWeights = llvm::MDBuilder(moduleTranslation.getLLVMContext())
call    0 never executed
    #####:  444:                          .createBranchWeights(weightValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  445:    }
        -:  446:
    #####:  447:    llvm::SwitchInst *switchInst = builder.CreateSwitch(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  448:        moduleTranslation.lookupValue(switchOp.getValue()),
call    0 never executed
call    1 never executed
        -:  449:        moduleTranslation.lookupBlock(switchOp.getDefaultDestination()),
    #####:  450:        switchOp.getCaseDestinations().size(), branchWeights);
call    0 never executed
call    1 never executed
        -:  451:
    #####:  452:    auto *ty = llvm::cast<llvm::IntegerType>(
call    0 never executed
    #####:  453:        moduleTranslation.convertType(switchOp.getValue().getType()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  454:    for (auto i :
    #####:  455:         llvm::zip(switchOp.getCaseValues()->cast<DenseIntElementsAttr>(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  456:                   switchOp.getCaseDestinations()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  457:      switchInst->addCase(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  458:          llvm::ConstantInt::get(ty, std::get<0>(i).getLimitedValue()),
call    0 never executed
    #####:  459:          moduleTranslation.lookupBlock(std::get<1>(i)));
call    0 never executed
        -:  460:
    #####:  461:    moduleTranslation.mapBranch(&opInst, switchInst);
call    0 never executed
    #####:  462:    return success();
        -:  463:  }
        -:  464:
        -:  465:  // Emit addressof.  We need to look up the global value referenced by the
        -:  466:  // operation and store it in the MLIR-to-LLVM value mapping.  This does not
        -:  467:  // emit any LLVM instruction.
    #####:  468:  if (auto addressOfOp = dyn_cast<LLVM::AddressOfOp>(opInst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  469:    LLVM::GlobalOp global =
call    0 never executed
    #####:  470:        addressOfOp.getGlobal(moduleTranslation.symbolTable());
call    0 never executed
    #####:  471:    LLVM::LLVMFuncOp function =
call    0 never executed
    #####:  472:        addressOfOp.getFunction(moduleTranslation.symbolTable());
call    0 never executed
        -:  473:
        -:  474:    // The verifier should not have allowed this.
    #####:  475:    assert((global || function) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  476:           "referencing an undefined global or function");
        -:  477:
    #####:  478:    moduleTranslation.mapValue(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  479:        addressOfOp.getResult(),
    #####:  480:        global ? moduleTranslation.lookupGlobal(global)
call    0 never executed
    #####:  481:               : moduleTranslation.lookupFunction(function.getName()));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  482:    return success();
        -:  483:  }
        -:  484:
    #####:  485:  return failure();
        -:  486:}
        -:  487:
        -:  488:namespace {
        -:  489:/// Implementation of the dialect interface that converts operations belonging
        -:  490:/// to the LLVM dialect to LLVM IR.
        -:  491:class LLVMDialectLLVMIRTranslationInterface
        -:  492:    : public LLVMTranslationDialectInterface {
        -:  493:public:
        -:  494:  using LLVMTranslationDialectInterface::LLVMTranslationDialectInterface;
        -:  495:
        -:  496:  /// Translates the given operation to LLVM IR using the provided IR builder
        -:  497:  /// and saving the state in `moduleTranslation`.
        -:  498:  LogicalResult
function _ZNK12_GLOBAL__N_137LLVMDialectLLVMIRTranslationInterface16convertOperationEPN4mlir9OperationERN4llvm13IRBuilderBaseERNS1_4LLVM17ModuleTranslationE called 0 returned 0% blocks executed 0%
    #####:  499:  convertOperation(Operation *op, llvm::IRBuilderBase &builder,
        -:  500:                   LLVM::ModuleTranslation &moduleTranslation) const final {
    #####:  501:    return convertOperationImpl(*op, builder, moduleTranslation);
call    0 never executed
        -:  502:  }
        -:  503:};
        -:  504:} // namespace
        -:  505:
function _ZN4mlir30registerLLVMDialectTranslationERNS_15DialectRegistryE called 0 returned 0% blocks executed 0%
    #####:  506:void mlir::registerLLVMDialectTranslation(DialectRegistry &registry) {
    #####:  507:  registry.insert<LLVM::LLVMDialect>();
call    0 never executed
    #####:  508:  registry.addExtension(+[](MLIRContext *ctx, LLVM::LLVMDialect *dialect) {
call    0 never executed
call    1 never executed
        -:  509:    dialect->addInterfaces<LLVMDialectLLVMIRTranslationInterface>();
        -:  510:  });
    #####:  511:}
        -:  512:
function _ZN4mlir30registerLLVMDialectTranslationERNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  513:void mlir::registerLLVMDialectTranslation(MLIRContext &context) {
    #####:  514:  DialectRegistry registry;
call    0 never executed
    #####:  515:  registerLLVMDialectTranslation(registry);
call    0 never executed
    #####:  516:  context.appendDialectRegistry(registry);
call    0 never executed
call    1 never executed
    #####:  517:}
