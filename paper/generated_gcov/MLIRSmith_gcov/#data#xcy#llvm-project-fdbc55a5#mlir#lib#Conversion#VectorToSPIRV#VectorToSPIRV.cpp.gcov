        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Conversion/VectorToSPIRV/VectorToSPIRV.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/VectorToSPIRV/CMakeFiles/obj.MLIRVectorToSPIRV.dir/VectorToSPIRV.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/VectorToSPIRV/CMakeFiles/obj.MLIRVectorToSPIRV.dir/VectorToSPIRV.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- VectorToSPIRV.cpp - Vector to SPIR-V Patterns ----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements patterns to convert Vector dialect to SPIRV dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Conversion/VectorToSPIRV/VectorToSPIRV.h"
        -:   14:
        -:   15:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   18:#include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
        -:   19:#include "mlir/Dialect/Vector/IR/VectorOps.h"
        -:   20:#include "mlir/IR/BuiltinAttributes.h"
        -:   21:#include "mlir/IR/BuiltinTypes.h"
        -:   22:#include "mlir/Transforms/DialectConversion.h"
        -:   23:#include "llvm/ADT/ArrayRef.h"
        -:   24:#include "llvm/ADT/STLExtras.h"
        -:   25:#include <numeric>
        -:   26:
        -:   27:using namespace mlir;
        -:   28:
        -:   29:/// Gets the first integer value from `attr`, assuming it is an integer array
        -:   30:/// attribute.
function _ZL16getFirstIntValueN4mlir9ArrayAttrE called 8 returned 100% blocks executed 71%
        8:   31:static uint64_t getFirstIntValue(ArrayAttr attr) {
        8:   32:  return (*attr.getAsValueRange<IntegerAttr>().begin()).getZExtValue();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:   33:}
        -:   34:
        -:   35:namespace {
        -:   36:
        -:   37:struct VectorBitcastConvert final
        -:   38:    : public OpConversionPattern<vector::BitCastOp> {
        -:   39:  using OpConversionPattern::OpConversionPattern;
        -:   40:
        -:   41:  LogicalResult
function _ZNK12_GLOBAL__N_120VectorBitcastConvert15matchAndRewriteEN4mlir6vector9BitCastOpENS2_16BitCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   42:  matchAndRewrite(vector::BitCastOp bitcastOp, OpAdaptor adaptor,
        -:   43:                  ConversionPatternRewriter &rewriter) const override {
    #####:   44:    Type dstType = getTypeConverter()->convertType(bitcastOp.getType());
call    0 never executed
call    1 never executed
    #####:   45:    if (!dstType)
branch  0 never executed
branch  1 never executed
    #####:   46:      return failure();
        -:   47:
    #####:   48:    if (dstType == adaptor.getSource().getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   49:      rewriter.replaceOp(bitcastOp, adaptor.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   50:    else
    #####:   51:      rewriter.replaceOpWithNewOp<spirv::BitcastOp>(bitcastOp, dstType,
    #####:   52:                                                    adaptor.getSource());
call    0 never executed
call    1 never executed
        -:   53:
    #####:   54:    return success();
        -:   55:  }
        -:   56:};
        -:   57:
        -:   58:struct VectorBroadcastConvert final
        -:   59:    : public OpConversionPattern<vector::BroadcastOp> {
        -:   60:  using OpConversionPattern::OpConversionPattern;
        -:   61:
        -:   62:  LogicalResult
function _ZNK12_GLOBAL__N_122VectorBroadcastConvert15matchAndRewriteEN4mlir6vector11BroadcastOpENS2_18BroadcastOpAdaptorERNS1_25ConversionPatternRewriterE called 261 returned 100% blocks executed 100%
      261:   63:  matchAndRewrite(vector::BroadcastOp castOp, OpAdaptor adaptor,
        -:   64:                  ConversionPatternRewriter &rewriter) const override {
      261:   65:    Type resultType = getTypeConverter()->convertType(castOp.getVectorType());
call    0 returned 100%
call    1 returned 100%
      261:   66:    if (!resultType)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
      191:   67:      return failure();
        -:   68:
       70:   69:    if (resultType.isa<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 21% (fallthrough)
branch  2 taken 79%
       15:   70:      rewriter.replaceOp(castOp, adaptor.getSource());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       15:   71:      return success();
        -:   72:    }
        -:   73:
       55:   74:    SmallVector<Value, 4> source(castOp.getVectorType().getNumElements(),
call    0 returned 100%
call    1 returned 100%
      110:   75:                                 adaptor.getSource());
call    0 returned 100%
call    1 returned 100%
       55:   76:    rewriter.replaceOpWithNewOp<spirv::CompositeConstructOp>(
       55:   77:        castOp, castOp.getVectorType(), source);
call    0 returned 100%
call    1 returned 100%
       55:   78:    return success();
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        -:   79:  }
        -:   80:};
        -:   81:
        -:   82:struct VectorExtractOpConvert final
        -:   83:    : public OpConversionPattern<vector::ExtractOp> {
        -:   84:  using OpConversionPattern::OpConversionPattern;
        -:   85:
        -:   86:  LogicalResult
function _ZNK12_GLOBAL__N_122VectorExtractOpConvert15matchAndRewriteEN4mlir6vector9ExtractOpENS2_16ExtractOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   87:  matchAndRewrite(vector::ExtractOp extractOp, OpAdaptor adaptor,
        -:   88:                  ConversionPatternRewriter &rewriter) const override {
        -:   89:    // Only support extracting a scalar value now.
    #####:   90:    VectorType resultVectorType = extractOp.getType().dyn_cast<VectorType>();
call    0 never executed
    #####:   91:    if (resultVectorType && resultVectorType.getNumElements() > 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   92:      return failure();
        -:   93:
    #####:   94:    Type dstType = getTypeConverter()->convertType(extractOp.getType());
call    0 never executed
    #####:   95:    if (!dstType)
branch  0 never executed
branch  1 never executed
    #####:   96:      return failure();
        -:   97:
    #####:   98:    if (adaptor.getVector().getType().isa<spirv::ScalarType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   99:      rewriter.replaceOp(extractOp, adaptor.getVector());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  100:      return success();
        -:  101:    }
        -:  102:
    #####:  103:    int32_t id = getFirstIntValue(extractOp.getPosition());
call    0 never executed
call    1 never executed
    #####:  104:    rewriter.replaceOpWithNewOp<spirv::CompositeExtractOp>(
    #####:  105:        extractOp, adaptor.getVector(), id);
call    0 never executed
call    1 never executed
    #####:  106:    return success();
        -:  107:  }
        -:  108:};
        -:  109:
        -:  110:struct VectorExtractStridedSliceOpConvert final
        -:  111:    : public OpConversionPattern<vector::ExtractStridedSliceOp> {
        -:  112:  using OpConversionPattern::OpConversionPattern;
        -:  113:
        -:  114:  LogicalResult
function _ZNK12_GLOBAL__N_134VectorExtractStridedSliceOpConvert15matchAndRewriteEN4mlir6vector21ExtractStridedSliceOpENS2_28ExtractStridedSliceOpAdaptorERNS1_25ConversionPatternRewriterE called 2 returned 100% blocks executed 82%
        2:  115:  matchAndRewrite(vector::ExtractStridedSliceOp extractOp, OpAdaptor adaptor,
        -:  116:                  ConversionPatternRewriter &rewriter) const override {
        2:  117:    Type dstType = getTypeConverter()->convertType(extractOp.getType());
call    0 returned 100%
call    1 returned 100%
        2:  118:    if (!dstType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  119:      return failure();
        -:  120:
        2:  121:    uint64_t offset = getFirstIntValue(extractOp.getOffsets());
call    0 returned 100%
call    1 returned 100%
        2:  122:    uint64_t size = getFirstIntValue(extractOp.getSizes());
call    0 returned 100%
call    1 returned 100%
        2:  123:    uint64_t stride = getFirstIntValue(extractOp.getStrides());
call    0 returned 100%
call    1 returned 100%
        2:  124:    if (stride != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  125:      return failure();
        -:  126:
        2:  127:    Value srcVector = adaptor.getOperands().front();
call    0 returned 100%
call    1 returned 100%
        -:  128:
        -:  129:    // Extract vector<1xT> case.
        2:  130:    if (dstType.isa<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:      rewriter.replaceOpWithNewOp<spirv::CompositeExtractOp>(extractOp,
    #####:  132:                                                             srcVector, offset);
call    0 never executed
    #####:  133:      return success();
        -:  134:    }
        -:  135:
        2:  136:    SmallVector<int32_t, 2> indices(size);
call    0 returned 100%
        2:  137:    std::iota(indices.begin(), indices.end(), offset);
        -:  138:
        2:  139:    rewriter.replaceOpWithNewOp<spirv::VectorShuffleOp>(
        -:  140:        extractOp, dstType, srcVector, srcVector,
        2:  141:        rewriter.getI32ArrayAttr(indices));
call    0 returned 100%
call    1 returned 100%
        -:  142:
        2:  143:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  144:  }
        -:  145:};
        -:  146:
        -:  147:template <class SPIRVFMAOp>
        -:  148:struct VectorFmaOpConvert final : public OpConversionPattern<vector::FMAOp> {
        -:  149:  using OpConversionPattern::OpConversionPattern;
        -:  150:
        -:  151:  LogicalResult
        4:  152:  matchAndRewrite(vector::FMAOp fmaOp, OpAdaptor adaptor,
        -:  153:                  ConversionPatternRewriter &rewriter) const override {
        4:  154:    Type dstType = getTypeConverter()->convertType(fmaOp.getType());
        4:  155:    if (!dstType)
        4:  156:      return failure();
        4:  157:    rewriter.replaceOpWithNewOp<SPIRVFMAOp>(fmaOp, dstType, adaptor.getLhs(),
        8:  158:                                            adaptor.getRhs(), adaptor.getAcc());
        4:  159:    return success();
        -:  160:  }
------------------
_ZNK12_GLOBAL__N_118VectorFmaOpConvertIN4mlir5spirv7GLFmaOpEE15matchAndRewriteENS1_6vector5FMAOpENS5_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_118VectorFmaOpConvertIN4mlir5spirv7GLFmaOpEE15matchAndRewriteENS1_6vector5FMAOpENS5_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE called 2 returned 100% blocks executed 90%
        2:  152:  matchAndRewrite(vector::FMAOp fmaOp, OpAdaptor adaptor,
        -:  153:                  ConversionPatternRewriter &rewriter) const override {
        2:  154:    Type dstType = getTypeConverter()->convertType(fmaOp.getType());
call    0 returned 100%
call    1 returned 100%
        2:  155:    if (!dstType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        2:  156:      return failure();
        2:  157:    rewriter.replaceOpWithNewOp<SPIRVFMAOp>(fmaOp, dstType, adaptor.getLhs(),
call    0 returned 100%
call    1 returned 100%
        4:  158:                                            adaptor.getRhs(), adaptor.getAcc());
call    0 returned 100%
call    1 returned 100%
        2:  159:    return success();
        -:  160:  }
------------------
_ZNK12_GLOBAL__N_118VectorFmaOpConvertIN4mlir5spirv7CLFmaOpEE15matchAndRewriteENS1_6vector5FMAOpENS5_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_118VectorFmaOpConvertIN4mlir5spirv7CLFmaOpEE15matchAndRewriteENS1_6vector5FMAOpENS5_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE called 2 returned 100% blocks executed 90%
        2:  152:  matchAndRewrite(vector::FMAOp fmaOp, OpAdaptor adaptor,
        -:  153:                  ConversionPatternRewriter &rewriter) const override {
        2:  154:    Type dstType = getTypeConverter()->convertType(fmaOp.getType());
call    0 returned 100%
call    1 returned 100%
        2:  155:    if (!dstType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        2:  156:      return failure();
        2:  157:    rewriter.replaceOpWithNewOp<SPIRVFMAOp>(fmaOp, dstType, adaptor.getLhs(),
call    0 returned 100%
call    1 returned 100%
        4:  158:                                            adaptor.getRhs(), adaptor.getAcc());
call    0 returned 100%
call    1 returned 100%
        2:  159:    return success();
        -:  160:  }
------------------
        -:  161:};
        -:  162:
        -:  163:struct VectorInsertOpConvert final
        -:  164:    : public OpConversionPattern<vector::InsertOp> {
        -:  165:  using OpConversionPattern::OpConversionPattern;
        -:  166:
        -:  167:  LogicalResult
function _ZNK12_GLOBAL__N_121VectorInsertOpConvert15matchAndRewriteEN4mlir6vector8InsertOpENS2_15InsertOpAdaptorERNS1_25ConversionPatternRewriterE called 2 returned 100% blocks executed 79%
        2:  168:  matchAndRewrite(vector::InsertOp insertOp, OpAdaptor adaptor,
        -:  169:                  ConversionPatternRewriter &rewriter) const override {
        -:  170:    // Special case for inserting scalar values into size-1 vectors.
       4*:  171:    if (insertOp.getSourceType().isIntOrFloat() &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       2*:  172:        insertOp.getDestVectorType().getNumElements() == 1) {
call    0 returned 100%
call    1 returned 100%
    #####:  173:      rewriter.replaceOp(insertOp, adaptor.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  174:      return success();
        -:  175:    }
        -:  176:
       4*:  177:    if (insertOp.getSourceType().isa<VectorType>() ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        2:  178:        !spirv::CompositeType::isValid(insertOp.getDestVectorType()))
call    0 returned 100%
call    1 returned 100%
    #####:  179:      return failure();
        2:  180:    int32_t id = getFirstIntValue(insertOp.getPosition());
call    0 returned 100%
call    1 returned 100%
        2:  181:    rewriter.replaceOpWithNewOp<spirv::CompositeInsertOp>(
        2:  182:        insertOp, adaptor.getSource(), adaptor.getDest(), id);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2:  183:    return success();
        -:  184:  }
        -:  185:};
        -:  186:
        -:  187:struct VectorExtractElementOpConvert final
        -:  188:    : public OpConversionPattern<vector::ExtractElementOp> {
        -:  189:  using OpConversionPattern::OpConversionPattern;
        -:  190:
        -:  191:  LogicalResult
function _ZNK12_GLOBAL__N_129VectorExtractElementOpConvert15matchAndRewriteEN4mlir6vector16ExtractElementOpENS2_23ExtractElementOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  192:  matchAndRewrite(vector::ExtractElementOp extractOp, OpAdaptor adaptor,
        -:  193:                  ConversionPatternRewriter &rewriter) const override {
    #####:  194:    Type vectorType =
    #####:  195:        getTypeConverter()->convertType(adaptor.getVector().getType());
call    0 never executed
call    1 never executed
    #####:  196:    if (!vectorType)
branch  0 never executed
branch  1 never executed
    #####:  197:      return failure();
        -:  198:
    #####:  199:    if (vectorType.isa<spirv::ScalarType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  200:      rewriter.replaceOp(extractOp, adaptor.getVector());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  201:      return success();
        -:  202:    }
        -:  203:
    #####:  204:    rewriter.replaceOpWithNewOp<spirv::VectorExtractDynamicOp>(
    #####:  205:        extractOp, extractOp.getType(), adaptor.getVector(),
call    0 never executed
call    1 never executed
    #####:  206:        extractOp.getPosition());
call    0 never executed
call    1 never executed
    #####:  207:    return success();
        -:  208:  }
        -:  209:};
        -:  210:
        -:  211:struct VectorInsertElementOpConvert final
        -:  212:    : public OpConversionPattern<vector::InsertElementOp> {
        -:  213:  using OpConversionPattern::OpConversionPattern;
        -:  214:
        -:  215:  LogicalResult
function _ZNK12_GLOBAL__N_128VectorInsertElementOpConvert15matchAndRewriteEN4mlir6vector15InsertElementOpENS2_22InsertElementOpAdaptorERNS1_25ConversionPatternRewriterE called 6 returned 100% blocks executed 94%
        6:  216:  matchAndRewrite(vector::InsertElementOp insertOp, OpAdaptor adaptor,
        -:  217:                  ConversionPatternRewriter &rewriter) const override {
        6:  218:    Type vectorType = getTypeConverter()->convertType(insertOp.getType());
call    0 returned 100%
call    1 returned 100%
        6:  219:    if (!vectorType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  220:      return failure();
        -:  221:
        6:  222:    if (vectorType.isa<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        2:  223:      rewriter.replaceOp(insertOp, adaptor.getSource());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2:  224:      return success();
        -:  225:    }
        -:  226:
        4:  227:    rewriter.replaceOpWithNewOp<spirv::VectorInsertDynamicOp>(
        4:  228:        insertOp, vectorType, insertOp.getDest(), adaptor.getSource(),
call    0 returned 100%
call    1 returned 100%
        8:  229:        insertOp.getPosition());
call    0 returned 100%
call    1 returned 100%
        4:  230:    return success();
        -:  231:  }
        -:  232:};
        -:  233:
        -:  234:struct VectorInsertStridedSliceOpConvert final
        -:  235:    : public OpConversionPattern<vector::InsertStridedSliceOp> {
        -:  236:  using OpConversionPattern::OpConversionPattern;
        -:  237:
        -:  238:  LogicalResult
function _ZNK12_GLOBAL__N_133VectorInsertStridedSliceOpConvert15matchAndRewriteEN4mlir6vector20InsertStridedSliceOpENS2_27InsertStridedSliceOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  239:  matchAndRewrite(vector::InsertStridedSliceOp insertOp, OpAdaptor adaptor,
        -:  240:                  ConversionPatternRewriter &rewriter) const override {
    #####:  241:    Value srcVector = adaptor.getOperands().front();
call    0 never executed
call    1 never executed
    #####:  242:    Value dstVector = adaptor.getOperands().back();
call    0 never executed
call    1 never executed
        -:  243:
    #####:  244:    uint64_t stride = getFirstIntValue(insertOp.getStrides());
call    0 never executed
call    1 never executed
    #####:  245:    if (stride != 1)
branch  0 never executed
branch  1 never executed
    #####:  246:      return failure();
    #####:  247:    uint64_t offset = getFirstIntValue(insertOp.getOffsets());
call    0 never executed
call    1 never executed
        -:  248:
    #####:  249:    if (srcVector.getType().isa<spirv::ScalarType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  250:      assert(!dstVector.getType().isa<spirv::ScalarType>());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  251:      rewriter.replaceOpWithNewOp<spirv::CompositeInsertOp>(
    #####:  252:          insertOp, dstVector.getType(), srcVector, dstVector,
call    0 never executed
    #####:  253:          rewriter.getI32ArrayAttr(offset));
call    0 never executed
call    1 never executed
    #####:  254:      return success();
        -:  255:    }
        -:  256:
    #####:  257:    uint64_t totalSize =
    #####:  258:        dstVector.getType().cast<VectorType>().getNumElements();
call    0 never executed
call    1 never executed
    #####:  259:    uint64_t insertSize =
    #####:  260:        srcVector.getType().cast<VectorType>().getNumElements();
call    0 never executed
call    1 never executed
        -:  261:
    #####:  262:    SmallVector<int32_t, 2> indices(totalSize);
call    0 never executed
    #####:  263:    std::iota(indices.begin(), indices.end(), 0);
    #####:  264:    std::iota(indices.begin() + offset, indices.begin() + offset + insertSize,
        -:  265:              totalSize);
        -:  266:
    #####:  267:    rewriter.replaceOpWithNewOp<spirv::VectorShuffleOp>(
    #####:  268:        insertOp, dstVector.getType(), dstVector, srcVector,
call    0 never executed
    #####:  269:        rewriter.getI32ArrayAttr(indices));
call    0 never executed
call    1 never executed
        -:  270:
    #####:  271:    return success();
branch  0 never executed
branch  1 never executed
        -:  272:  }
        -:  273:};
        -:  274:
        -:  275:template <class SPIRVFMaxOp, class SPIRVFMinOp, class SPIRVUMaxOp,
        -:  276:          class SPIRVUMinOp, class SPIRVSMaxOp, class SPIRVSMinOp>
        -:  277:struct VectorReductionPattern final
        -:  278:    : public OpConversionPattern<vector::ReductionOp> {
        -:  279:  using OpConversionPattern::OpConversionPattern;
        -:  280:
        -:  281:  LogicalResult
       12:  282:  matchAndRewrite(vector::ReductionOp reduceOp, OpAdaptor adaptor,
        -:  283:                  ConversionPatternRewriter &rewriter) const override {
       12:  284:    Type resultType = typeConverter->convertType(reduceOp.getType());
       12:  285:    if (!resultType)
       12:  286:      return failure();
        -:  287:
       12:  288:    auto srcVectorType = adaptor.getVector().getType().dyn_cast<VectorType>();
       24:  289:    if (!srcVectorType || srcVectorType.getRank() != 1)
    #####:  290:      return rewriter.notifyMatchFailure(reduceOp, "not 1-D vector source");
        -:  291:
        -:  292:    // Extract all elements.
       12:  293:    int numElements = srcVectorType.getDimSize(0);
       12:  294:    SmallVector<Value, 4> values;
       12:  295:    values.reserve(numElements + (adaptor.getAcc() != nullptr));
       12:  296:    Location loc = reduceOp.getLoc();
       62:  297:    for (int i = 0; i < numElements; ++i) {
       50:  298:      values.push_back(rewriter.create<spirv::CompositeExtractOp>(
       50:  299:          loc, srcVectorType.getElementType(), adaptor.getVector(),
      100:  300:          rewriter.getI32ArrayAttr({i})));
        -:  301:    }
       12:  302:    if (Value acc = adaptor.getAcc())
    #####:  303:      values.push_back(acc);
        -:  304:
        -:  305:    // Reduce them.
       12:  306:    Value result = values.front();
       50:  307:    for (Value next : llvm::makeArrayRef(values).drop_front()) {
       38:  308:      switch (reduceOp.getKind()) {
        -:  309:
        -:  310:#define INT_AND_FLOAT_CASE(kind, iop, fop)                                     \
        -:  311:  case vector::CombiningKind::kind:                                            \
        -:  312:    if (resultType.isa<IntegerType>()) {                                       \
        -:  313:      result = rewriter.create<spirv::iop>(loc, resultType, result, next);     \
        -:  314:    } else {                                                                   \
        -:  315:      assert(resultType.isa<FloatType>());                                     \
        -:  316:      result = rewriter.create<spirv::fop>(loc, resultType, result, next);     \
        -:  317:    }                                                                          \
        -:  318:    break
        -:  319:
        -:  320:#define INT_OR_FLOAT_CASE(kind, fop)                                           \
        -:  321:  case vector::CombiningKind::kind:                                            \
        -:  322:    result = rewriter.create<fop>(loc, resultType, result, next);              \
        -:  323:    break
        -:  324:
       4*:  325:        INT_AND_FLOAT_CASE(ADD, IAddOp, FAddOp);
    #####:  326:        INT_AND_FLOAT_CASE(MUL, IMulOp, FMulOp);
        -:  327:
       12:  328:        INT_OR_FLOAT_CASE(MAXF, SPIRVFMaxOp);
        8:  329:        INT_OR_FLOAT_CASE(MINF, SPIRVFMinOp);
    #####:  330:        INT_OR_FLOAT_CASE(MINUI, SPIRVUMinOp);
    #####:  331:        INT_OR_FLOAT_CASE(MINSI, SPIRVSMinOp);
    #####:  332:        INT_OR_FLOAT_CASE(MAXUI, SPIRVUMaxOp);
       14:  333:        INT_OR_FLOAT_CASE(MAXSI, SPIRVSMaxOp);
        -:  334:
    #####:  335:      case vector::CombiningKind::AND:
        -:  336:      case vector::CombiningKind::OR:
        -:  337:      case vector::CombiningKind::XOR:
    #####:  338:        return rewriter.notifyMatchFailure(reduceOp, "unimplemented");
        -:  339:      }
        -:  340:    }
        -:  341:
       12:  342:    rewriter.replaceOp(reduceOp, result);
       12:  343:    return success();
        -:  344:  }
------------------
_ZNK12_GLOBAL__N_122VectorReductionPatternIN4mlir5spirv8GLFMaxOpENS2_8GLFMinOpENS2_8GLUMaxOpENS2_8GLUMinOpENS2_8GLSMaxOpENS2_8GLSMinOpEE15matchAndRewriteENS1_6vector11ReductionOpENSA_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122VectorReductionPatternIN4mlir5spirv8GLFMaxOpENS2_8GLFMinOpENS2_8GLUMaxOpENS2_8GLUMinOpENS2_8GLSMaxOpENS2_8GLSMinOpEE15matchAndRewriteENS1_6vector11ReductionOpENSA_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE called 5 returned 100% blocks executed 58%
        5:  282:  matchAndRewrite(vector::ReductionOp reduceOp, OpAdaptor adaptor,
        -:  283:                  ConversionPatternRewriter &rewriter) const override {
        5:  284:    Type resultType = typeConverter->convertType(reduceOp.getType());
call    0 returned 100%
        5:  285:    if (!resultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5:  286:      return failure();
        -:  287:
        5:  288:    auto srcVectorType = adaptor.getVector().getType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
       10:  289:    if (!srcVectorType || srcVectorType.getRank() != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  290:      return rewriter.notifyMatchFailure(reduceOp, "not 1-D vector source");
call    0 never executed
        -:  291:
        -:  292:    // Extract all elements.
        5:  293:    int numElements = srcVectorType.getDimSize(0);
call    0 returned 100%
call    1 returned 100%
        5:  294:    SmallVector<Value, 4> values;
call    0 returned 100%
        5:  295:    values.reserve(numElements + (adaptor.getAcc() != nullptr));
call    0 returned 100%
branch  1 taken 20% (fallthrough)
branch  2 taken 80%
        5:  296:    Location loc = reduceOp.getLoc();
       27:  297:    for (int i = 0; i < numElements; ++i) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
       22:  298:      values.push_back(rewriter.create<spirv::CompositeExtractOp>(
call    0 returned 100%
call    1 returned 100%
       22:  299:          loc, srcVectorType.getElementType(), adaptor.getVector(),
call    0 returned 100%
call    1 returned 100%
       44:  300:          rewriter.getI32ArrayAttr({i})));
call    0 returned 100%
        -:  301:    }
        5:  302:    if (Value acc = adaptor.getAcc())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  303:      values.push_back(acc);
call    0 never executed
        -:  304:
        -:  305:    // Reduce them.
        5:  306:    Value result = values.front();
call    0 returned 100%
       22:  307:    for (Value next : llvm::makeArrayRef(values).drop_front()) {
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23%
       17:  308:      switch (reduceOp.getKind()) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 35%
branch  4 taken 24%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 41%
branch  9 taken 0%
branch 10 taken 0%
        -:  309:
        -:  310:#define INT_AND_FLOAT_CASE(kind, iop, fop)                                     \
        -:  311:  case vector::CombiningKind::kind:                                            \
        -:  312:    if (resultType.isa<IntegerType>()) {                                       \
        -:  313:      result = rewriter.create<spirv::iop>(loc, resultType, result, next);     \
        -:  314:    } else {                                                                   \
        -:  315:      assert(resultType.isa<FloatType>());                                     \
        -:  316:      result = rewriter.create<spirv::fop>(loc, resultType, result, next);     \
        -:  317:    }                                                                          \
        -:  318:    break
        -:  319:
        -:  320:#define INT_OR_FLOAT_CASE(kind, fop)                                           \
        -:  321:  case vector::CombiningKind::kind:                                            \
        -:  322:    result = rewriter.create<fop>(loc, resultType, result, next);              \
        -:  323:    break
        -:  324:
    #####:  325:        INT_AND_FLOAT_CASE(ADD, IAddOp, FAddOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
    #####:  326:        INT_AND_FLOAT_CASE(MUL, IMulOp, FMulOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -:  327:
        6:  328:        INT_OR_FLOAT_CASE(MAXF, SPIRVFMaxOp);
call    0 returned 100%
        4:  329:        INT_OR_FLOAT_CASE(MINF, SPIRVFMinOp);
call    0 returned 100%
    #####:  330:        INT_OR_FLOAT_CASE(MINUI, SPIRVUMinOp);
call    0 never executed
    #####:  331:        INT_OR_FLOAT_CASE(MINSI, SPIRVSMinOp);
call    0 never executed
    #####:  332:        INT_OR_FLOAT_CASE(MAXUI, SPIRVUMaxOp);
call    0 never executed
        7:  333:        INT_OR_FLOAT_CASE(MAXSI, SPIRVSMaxOp);
call    0 returned 100%
        -:  334:
    #####:  335:      case vector::CombiningKind::AND:
        -:  336:      case vector::CombiningKind::OR:
        -:  337:      case vector::CombiningKind::XOR:
    #####:  338:        return rewriter.notifyMatchFailure(reduceOp, "unimplemented");
call    0 never executed
        -:  339:      }
        -:  340:    }
        -:  341:
        5:  342:    rewriter.replaceOp(reduceOp, result);
call    0 returned 100%
        5:  343:    return success();
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  344:  }
------------------
_ZNK12_GLOBAL__N_122VectorReductionPatternIN4mlir5spirv8CLFMaxOpENS2_8CLFMinOpENS2_8CLUMaxOpENS2_8CLUMinOpENS2_8CLSMaxOpENS2_8CLSMinOpEE15matchAndRewriteENS1_6vector11ReductionOpENSA_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122VectorReductionPatternIN4mlir5spirv8CLFMaxOpENS2_8CLFMinOpENS2_8CLUMaxOpENS2_8CLUMinOpENS2_8CLSMaxOpENS2_8CLSMinOpEE15matchAndRewriteENS1_6vector11ReductionOpENSA_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE called 7 returned 100% blocks executed 64%
        7:  282:  matchAndRewrite(vector::ReductionOp reduceOp, OpAdaptor adaptor,
        -:  283:                  ConversionPatternRewriter &rewriter) const override {
        7:  284:    Type resultType = typeConverter->convertType(reduceOp.getType());
call    0 returned 100%
        7:  285:    if (!resultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        7:  286:      return failure();
        -:  287:
        7:  288:    auto srcVectorType = adaptor.getVector().getType().dyn_cast<VectorType>();
call    0 returned 100%
call    1 returned 100%
       14:  289:    if (!srcVectorType || srcVectorType.getRank() != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  290:      return rewriter.notifyMatchFailure(reduceOp, "not 1-D vector source");
call    0 never executed
        -:  291:
        -:  292:    // Extract all elements.
        7:  293:    int numElements = srcVectorType.getDimSize(0);
call    0 returned 100%
call    1 returned 100%
        7:  294:    SmallVector<Value, 4> values;
call    0 returned 100%
        7:  295:    values.reserve(numElements + (adaptor.getAcc() != nullptr));
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
        7:  296:    Location loc = reduceOp.getLoc();
       35:  297:    for (int i = 0; i < numElements; ++i) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       28:  298:      values.push_back(rewriter.create<spirv::CompositeExtractOp>(
call    0 returned 100%
call    1 returned 100%
       28:  299:          loc, srcVectorType.getElementType(), adaptor.getVector(),
call    0 returned 100%
call    1 returned 100%
       56:  300:          rewriter.getI32ArrayAttr({i})));
call    0 returned 100%
        -:  301:    }
        7:  302:    if (Value acc = adaptor.getAcc())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  303:      values.push_back(acc);
call    0 never executed
        -:  304:
        -:  305:    // Reduce them.
        7:  306:    Value result = values.front();
call    0 returned 100%
       28:  307:    for (Value next : llvm::makeArrayRef(values).drop_front()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
       21:  308:      switch (reduceOp.getKind()) {
call    0 returned 100%
branch  1 taken 19%
branch  2 taken 0%
branch  3 taken 29%
branch  4 taken 19%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 33%
branch  9 taken 0%
branch 10 taken 0%
        -:  309:
        -:  310:#define INT_AND_FLOAT_CASE(kind, iop, fop)                                     \
        -:  311:  case vector::CombiningKind::kind:                                            \
        -:  312:    if (resultType.isa<IntegerType>()) {                                       \
        -:  313:      result = rewriter.create<spirv::iop>(loc, resultType, result, next);     \
        -:  314:    } else {                                                                   \
        -:  315:      assert(resultType.isa<FloatType>());                                     \
        -:  316:      result = rewriter.create<spirv::fop>(loc, resultType, result, next);     \
        -:  317:    }                                                                          \
        -:  318:    break
        -:  319:
        -:  320:#define INT_OR_FLOAT_CASE(kind, fop)                                           \
        -:  321:  case vector::CombiningKind::kind:                                            \
        -:  322:    result = rewriter.create<fop>(loc, resultType, result, next);              \
        -:  323:    break
        -:  324:
       4*:  325:        INT_AND_FLOAT_CASE(ADD, IAddOp, FAddOp);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
    #####:  326:        INT_AND_FLOAT_CASE(MUL, IMulOp, FMulOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
        -:  327:
        6:  328:        INT_OR_FLOAT_CASE(MAXF, SPIRVFMaxOp);
call    0 returned 100%
        4:  329:        INT_OR_FLOAT_CASE(MINF, SPIRVFMinOp);
call    0 returned 100%
    #####:  330:        INT_OR_FLOAT_CASE(MINUI, SPIRVUMinOp);
call    0 never executed
    #####:  331:        INT_OR_FLOAT_CASE(MINSI, SPIRVSMinOp);
call    0 never executed
    #####:  332:        INT_OR_FLOAT_CASE(MAXUI, SPIRVUMaxOp);
call    0 never executed
        7:  333:        INT_OR_FLOAT_CASE(MAXSI, SPIRVSMaxOp);
call    0 returned 100%
        -:  334:
    #####:  335:      case vector::CombiningKind::AND:
        -:  336:      case vector::CombiningKind::OR:
        -:  337:      case vector::CombiningKind::XOR:
    #####:  338:        return rewriter.notifyMatchFailure(reduceOp, "unimplemented");
call    0 never executed
        -:  339:      }
        -:  340:    }
        -:  341:
        7:  342:    rewriter.replaceOp(reduceOp, result);
call    0 returned 100%
        7:  343:    return success();
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:  344:  }
------------------
        -:  345:};
        -:  346:
        -:  347:class VectorSplatPattern final : public OpConversionPattern<vector::SplatOp> {
        -:  348:public:
        -:  349:  using OpConversionPattern<vector::SplatOp>::OpConversionPattern;
        -:  350:
        -:  351:  LogicalResult
function _ZNK12_GLOBAL__N_118VectorSplatPattern15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterE called 2 returned 100% blocks executed 25%
        2:  352:  matchAndRewrite(vector::SplatOp op, OpAdaptor adaptor,
        -:  353:                  ConversionPatternRewriter &rewriter) const override {
        2:  354:    Type dstType = getTypeConverter()->convertType(op.getType());
call    0 returned 100%
call    1 returned 100%
        2:  355:    if (!dstType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  356:      return failure();
    #####:  357:    if (dstType.isa<spirv::ScalarType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  358:      rewriter.replaceOp(op, adaptor.getInput());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  359:    } else {
    #####:  360:      auto dstVecType = dstType.cast<VectorType>();
call    0 never executed
    #####:  361:      SmallVector<Value, 4> source(dstVecType.getNumElements(),
call    0 never executed
    #####:  362:                                   adaptor.getInput());
call    0 never executed
call    1 never executed
    #####:  363:      rewriter.replaceOpWithNewOp<spirv::CompositeConstructOp>(op, dstType,
    #####:  364:                                                               source);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  365:    }
    #####:  366:    return success();
        -:  367:  }
        -:  368:};
        -:  369:
        -:  370:struct VectorShuffleOpConvert final
        -:  371:    : public OpConversionPattern<vector::ShuffleOp> {
        -:  372:  using OpConversionPattern::OpConversionPattern;
        -:  373:
        -:  374:  LogicalResult
function _ZNK12_GLOBAL__N_122VectorShuffleOpConvert15matchAndRewriteEN4mlir6vector9ShuffleOpENS2_16ShuffleOpAdaptorERNS1_25ConversionPatternRewriterE called 6 returned 100% blocks executed 42%
        6:  375:  matchAndRewrite(vector::ShuffleOp shuffleOp, OpAdaptor adaptor,
        -:  376:                  ConversionPatternRewriter &rewriter) const override {
        6:  377:    auto oldResultType = shuffleOp.getVectorType();
call    0 returned 100%
        6:  378:    if (!spirv::CompositeType::isValid(oldResultType))
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        2:  379:      return failure();
        4:  380:    Type newResultType = getTypeConverter()->convertType(oldResultType);
call    0 returned 100%
        -:  381:
        4:  382:    auto oldSourceType = shuffleOp.getV1VectorType();
call    0 returned 100%
        4:  383:    if (oldSourceType.getNumElements() > 1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        4:  384:      SmallVector<int32_t, 4> components = llvm::to_vector<4>(
function _ZZNK12_GLOBAL__N_122VectorShuffleOpConvert15matchAndRewriteEN4mlir6vector9ShuffleOpENS2_16ShuffleOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_9AttributeEE_clES7_.isra.0 called 15 returned 100% blocks executed 71%
        4:  385:          llvm::map_range(shuffleOp.getMask(), [](Attribute attr) -> int32_t {
call    0 returned 100%
       15:  386:            return attr.cast<IntegerAttr>().getValue().getZExtValue();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        8:  387:          }));
call    0 returned 100%
call    1 returned 100%
        4:  388:      rewriter.replaceOpWithNewOp<spirv::VectorShuffleOp>(
        4:  389:          shuffleOp, newResultType, adaptor.getV1(), adaptor.getV2(),
call    0 returned 100%
call    1 returned 100%
        8:  390:          rewriter.getI32ArrayAttr(components));
call    0 returned 100%
call    1 returned 100%
        4:  391:      return success();
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  392:    }
        -:  393:
    #####:  394:    SmallVector<Value, 2> oldOperands = {adaptor.getV1(), adaptor.getV2()};
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  395:    SmallVector<Value, 4> newOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  396:    newOperands.reserve(oldResultType.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  397:    for (const APInt &i : shuffleOp.getMask().getAsValueRange<IntegerAttr>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  398:      newOperands.push_back(oldOperands[i.getZExtValue()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  399:    }
    #####:  400:    rewriter.replaceOpWithNewOp<spirv::CompositeConstructOp>(
    #####:  401:        shuffleOp, newResultType, newOperands);
call    0 never executed
        -:  402:
    #####:  403:    return success();
branch  0 never executed
branch  1 never executed
        -:  404:  }
        -:  405:};
        -:  406:
        -:  407:} // namespace
        -:  408:#define CL_MAX_MIN_OPS                                                         \
        -:  409:  spirv::CLFMaxOp, spirv::CLFMinOp, spirv::CLUMaxOp, spirv::CLUMinOp,          \
        -:  410:      spirv::CLSMaxOp, spirv::CLSMinOp
        -:  411:
        -:  412:#define GL_MAX_MIN_OPS                                                         \
        -:  413:  spirv::GLFMaxOp, spirv::GLFMinOp, spirv::GLUMaxOp, spirv::GLUMinOp,          \
        -:  414:      spirv::GLSMaxOp, spirv::GLSMinOp
        -:  415:
function _ZN4mlir29populateVectorToSPIRVPatternsERNS_18SPIRVTypeConverterERNS_17RewritePatternSetE called 3 returned 100% blocks executed 100%
        3:  416:void mlir::populateVectorToSPIRVPatterns(SPIRVTypeConverter &typeConverter,
        -:  417:                                         RewritePatternSet &patterns) {
        3:  418:  patterns.add<
        -:  419:      VectorBitcastConvert, VectorBroadcastConvert,
        -:  420:      VectorExtractElementOpConvert, VectorExtractOpConvert,
        -:  421:      VectorExtractStridedSliceOpConvert, VectorFmaOpConvert<spirv::GLFmaOp>,
        -:  422:      VectorFmaOpConvert<spirv::CLFmaOp>, VectorInsertElementOpConvert,
        -:  423:      VectorInsertOpConvert, VectorReductionPattern<GL_MAX_MIN_OPS>,
        -:  424:      VectorReductionPattern<CL_MAX_MIN_OPS>, VectorInsertStridedSliceOpConvert,
        -:  425:      VectorShuffleOpConvert, VectorSplatPattern>(typeConverter,
        3:  426:                                                  patterns.getContext());
call    0 returned 100%
        3:  427:}
