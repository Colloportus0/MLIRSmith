        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/Affine/IR/AffineOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/IR/CMakeFiles/obj.MLIRAffineDialect.dir/AffineOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/IR/CMakeFiles/obj.MLIRAffineDialect.dir/AffineOps.cpp.gcda
        -:    0:Runs:116157
        -:    1://===- AffineOps.cpp - MLIR Affine Operations -----------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   10:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   11:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   12:#include "mlir/IR/AffineExprVisitor.h"
        -:   13:#include "mlir/IR/BlockAndValueMapping.h"
        -:   14:#include "mlir/IR/IntegerSet.h"
        -:   15:#include "mlir/IR/Matchers.h"
        -:   16:#include "mlir/IR/OpDefinition.h"
        -:   17:#include "mlir/IR/PatternMatch.h"
        -:   18:#include "mlir/Interfaces/ShapedOpInterfaces.h"
        -:   19:#include "mlir/Transforms/InliningUtils.h"
        -:   20:#include "llvm/ADT/ScopeExit.h"
        -:   21:#include "llvm/ADT/SmallBitVector.h"
        -:   22:#include "llvm/ADT/TypeSwitch.h"
        -:   23:#include "llvm/Support/Debug.h"
        -:   24:#include <numeric>
        -:   25:
        -:   26:using namespace mlir;
        -:   27:
        -:   28:#define DEBUG_TYPE "affine-analysis"
        -:   29:
        -:   30:#include "mlir/Dialect/Affine/IR/AffineOpsDialect.cpp.inc"
        -:   31:
        -:   32:/// A utility function to check if a value is defined at the top level of
        -:   33:/// `region` or is an argument of `region`. A value of index type defined at the
        -:   34:/// top level of a `AffineScope` region is always a valid symbol for all
        -:   35:/// uses in that region.
function _ZN4mlir15isTopLevelValueENS_5ValueEPNS_6RegionE called 187163526 returned 100% blocks executed 100%
187163526:   36:bool mlir::isTopLevelValue(Value value, Region *region) {
187163526:   37:  if (auto arg = value.dyn_cast<BlockArgument>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
     4139:   38:    return arg.getParentRegion() == region;
call    0 returned 100%
374318773:   39:  return value.getDefiningOp()->getParentRegion() == region;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   40:}
        -:   41:
        -:   42:/// Checks if `value` known to be a legal affine dimension or symbol in `src`
        -:   43:/// region remains legal if the operation that uses it is inlined into `dest`
        -:   44:/// with the given value mapping. `legalityCheck` is either `isValidDim` or
        -:   45:/// `isValidSymbol`, depending on the value being required to remain a valid
        -:   46:/// dimension or symbol.
        -:   47:static bool
function _ZL23remainsLegalAfterInlineN4mlir5ValueEPNS_6RegionES2_RKNS_20BlockAndValueMappingEN4llvm12function_refIFbS0_S2_EEE called 0 returned 0% blocks executed 0%
    #####:   48:remainsLegalAfterInline(Value value, Region *src, Region *dest,
        -:   49:                        const BlockAndValueMapping &mapping,
        -:   50:                        function_ref<bool(Value, Region *)> legalityCheck) {
        -:   51:  // If the value is a valid dimension for any other reason than being
        -:   52:  // a top-level value, it will remain valid: constants get inlined
        -:   53:  // with the function, transitive affine applies also get inlined and
        -:   54:  // will be checked themselves, etc.
    #####:   55:  if (!isTopLevelValue(value, src))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   56:    return true;
        -:   57:
        -:   58:  // If it's a top-level value because it's a block operand, i.e. a
        -:   59:  // function argument, check whether the value replacing it after
        -:   60:  // inlining is a valid dimension in the new region.
    #####:   61:  if (value.isa<BlockArgument>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   62:    return legalityCheck(mapping.lookup(value), dest);
call    0 never executed
call    1 never executed
        -:   63:
        -:   64:  // If it's a top-level value because it's defined in the region,
        -:   65:  // it can only be inlined if the defining op is a constant or a
        -:   66:  // `dim`, which can appear anywhere and be valid, since the defining
        -:   67:  // op won't be top-level anymore after inlining.
    #####:   68:  Attribute operandCst;
    #####:   69:  bool isDimLikeOp = isa<ShapedDimOpInterface>(value.getDefiningOp());
call    0 never executed
call    1 never executed
    #####:   70:  return matchPattern(value.getDefiningOp(), m_Constant(&operandCst)) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   71:         isDimLikeOp;
        -:   72:}
        -:   73:
        -:   74:/// Checks if all values known to be legal affine dimensions or symbols in `src`
        -:   75:/// remain so if their respective users are inlined into `dest`.
        -:   76:static bool
    #####:   77:remainsLegalAfterInline(ValueRange values, Region *src, Region *dest,
        -:   78:                        const BlockAndValueMapping &mapping,
        -:   79:                        function_ref<bool(Value, Region *)> legalityCheck) {
    #####:   80:  return llvm::all_of(values, [&](Value v) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:   81:    return remainsLegalAfterInline(v, src, dest, mapping, legalityCheck);
call    0 never executed
        -:   82:  });
        -:   83:}
        -:   84:
        -:   85:/// Checks if an affine read or write operation remains legal after inlining
        -:   86:/// from `src` to `dest`.
        -:   87:template <typename OpTy>
    #####:   88:static bool remainsLegalAfterInline(OpTy op, Region *src, Region *dest,
        -:   89:                                    const BlockAndValueMapping &mapping) {
        -:   90:  static_assert(llvm::is_one_of<OpTy, AffineReadOpInterface,
        -:   91:                                AffineWriteOpInterface>::value,
        -:   92:                "only ops with affine read/write interface are supported");
        -:   93:
    #####:   94:  AffineMap map = op.getAffineMap();
    #####:   95:  ValueRange dimOperands = op.getMapOperands().take_front(map.getNumDims());
    #####:   96:  ValueRange symbolOperands =
    #####:   97:      op.getMapOperands().take_back(map.getNumSymbols());
    #####:   98:  if (!remainsLegalAfterInline(
        -:   99:          dimOperands, src, dest, mapping,
        -:  100:          static_cast<bool (*)(Value, Region *)>(isValidDim)))
        -:  101:    return false;
    #####:  102:  if (!remainsLegalAfterInline(
        -:  103:          symbolOperands, src, dest, mapping,
        -:  104:          static_cast<bool (*)(Value, Region *)>(isValidSymbol)))
    #####:  105:    return false;
        -:  106:  return true;
        -:  107:}
------------------
_Z23remainsLegalAfterInlineIN4mlir22AffineWriteOpInterfaceEEbT_PNS0_6RegionES4_RKNS0_20BlockAndValueMappingE:
function _Z23remainsLegalAfterInlineIN4mlir22AffineWriteOpInterfaceEEbT_PNS0_6RegionES4_RKNS0_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:   88:static bool remainsLegalAfterInline(OpTy op, Region *src, Region *dest,
        -:   89:                                    const BlockAndValueMapping &mapping) {
        -:   90:  static_assert(llvm::is_one_of<OpTy, AffineReadOpInterface,
        -:   91:                                AffineWriteOpInterface>::value,
        -:   92:                "only ops with affine read/write interface are supported");
        -:   93:
    #####:   94:  AffineMap map = op.getAffineMap();
call    0 never executed
    #####:   95:  ValueRange dimOperands = op.getMapOperands().take_front(map.getNumDims());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   96:  ValueRange symbolOperands =
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   97:      op.getMapOperands().take_back(map.getNumSymbols());
call    0 never executed
call    1 never executed
    #####:   98:  if (!remainsLegalAfterInline(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   99:          dimOperands, src, dest, mapping,
        -:  100:          static_cast<bool (*)(Value, Region *)>(isValidDim)))
        -:  101:    return false;
    #####:  102:  if (!remainsLegalAfterInline(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  103:          symbolOperands, src, dest, mapping,
        -:  104:          static_cast<bool (*)(Value, Region *)>(isValidSymbol)))
    #####:  105:    return false;
        -:  106:  return true;
        -:  107:}
------------------
_Z23remainsLegalAfterInlineIN4mlir21AffineReadOpInterfaceEEbT_PNS0_6RegionES4_RKNS0_20BlockAndValueMappingE:
function _Z23remainsLegalAfterInlineIN4mlir21AffineReadOpInterfaceEEbT_PNS0_6RegionES4_RKNS0_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:   88:static bool remainsLegalAfterInline(OpTy op, Region *src, Region *dest,
        -:   89:                                    const BlockAndValueMapping &mapping) {
        -:   90:  static_assert(llvm::is_one_of<OpTy, AffineReadOpInterface,
        -:   91:                                AffineWriteOpInterface>::value,
        -:   92:                "only ops with affine read/write interface are supported");
        -:   93:
    #####:   94:  AffineMap map = op.getAffineMap();
call    0 never executed
    #####:   95:  ValueRange dimOperands = op.getMapOperands().take_front(map.getNumDims());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   96:  ValueRange symbolOperands =
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   97:      op.getMapOperands().take_back(map.getNumSymbols());
call    0 never executed
call    1 never executed
    #####:   98:  if (!remainsLegalAfterInline(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   99:          dimOperands, src, dest, mapping,
        -:  100:          static_cast<bool (*)(Value, Region *)>(isValidDim)))
        -:  101:    return false;
    #####:  102:  if (!remainsLegalAfterInline(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  103:          symbolOperands, src, dest, mapping,
        -:  104:          static_cast<bool (*)(Value, Region *)>(isValidSymbol)))
    #####:  105:    return false;
        -:  106:  return true;
        -:  107:}
------------------
        -:  108:
        -:  109:/// Checks if an affine apply operation remains legal after inlining from `src`
        -:  110:/// to `dest`.
        -:  111://  Use "unused attribute" marker to silence clang-tidy warning stemming from
        -:  112://  the inability to see through "llvm::TypeSwitch".
        -:  113:template <>
        -:  114:bool LLVM_ATTRIBUTE_UNUSED
function _Z23remainsLegalAfterInlineIN4mlir13AffineApplyOpEEbT_PNS0_6RegionES4_RKNS0_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  115:remainsLegalAfterInline(AffineApplyOp op, Region *src, Region *dest,
        -:  116:                        const BlockAndValueMapping &mapping) {
        -:  117:  // If it's a valid dimension, we need to check that it remains so.
    #####:  118:  if (isValidDim(op.getResult(), src))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return remainsLegalAfterInline(
call    0 never executed
        -:  120:        op.getMapOperands(), src, dest, mapping,
    #####:  121:        static_cast<bool (*)(Value, Region *)>(isValidDim));
call    0 never executed
        -:  122:
        -:  123:  // Otherwise it must be a valid symbol, check that it remains so.
    #####:  124:  return remainsLegalAfterInline(
call    0 never executed
        -:  125:      op.getMapOperands(), src, dest, mapping,
    #####:  126:      static_cast<bool (*)(Value, Region *)>(isValidSymbol));
call    0 never executed
        -:  127:}
        -:  128:
        -:  129://===----------------------------------------------------------------------===//
        -:  130:// AffineDialect Interfaces
        -:  131://===----------------------------------------------------------------------===//
        -:  132:
        -:  133:namespace {
        -:  134:/// This class defines the interface for handling inlining with affine
        -:  135:/// operations.
        -:  136:struct AffineInlinerInterface : public DialectInlinerInterface {
        -:  137:  using DialectInlinerInterface::DialectInlinerInterface;
        -:  138:
        -:  139:  //===--------------------------------------------------------------------===//
        -:  140:  // Analysis Hooks
        -:  141:  //===--------------------------------------------------------------------===//
        -:  142:
        -:  143:  /// Returns true if the given region 'src' can be inlined into the region
        -:  144:  /// 'dest' that is attached to an operation registered to the current dialect.
        -:  145:  /// 'wouldBeCloned' is set if the region is cloned into its new location
        -:  146:  /// rather than moved, indicating there may be other users.
function _ZNK12_GLOBAL__N_122AffineInlinerInterface15isLegalToInlineEPN4mlir6RegionES3_bRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  147:  bool isLegalToInline(Region *dest, Region *src, bool wouldBeCloned,
        -:  148:                       BlockAndValueMapping &valueMapping) const final {
        -:  149:    // We can inline into affine loops and conditionals if this doesn't break
        -:  150:    // affine value categorization rules.
    #####:  151:    Operation *destOp = dest->getParentOp();
call    0 never executed
    #####:  152:    if (!isa<AffineParallelOp, AffineForOp, AffineIfOp>(destOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  153:      return false;
        -:  154:
        -:  155:    // Multi-block regions cannot be inlined into affine constructs, all of
        -:  156:    // which require single-block regions.
    #####:  157:    if (!llvm::hasSingleElement(*src))
branch  0 never executed
branch  1 never executed
        -:  158:      return false;
        -:  159:
        -:  160:    // Side-effecting operations that the affine dialect cannot understand
        -:  161:    // should not be inlined.
    #####:  162:    Block &srcBlock = src->front();
call    0 never executed
    #####:  163:    for (Operation &op : srcBlock) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  164:      // Ops with no side effects are fine,
    #####:  165:      if (auto iface = dyn_cast<MemoryEffectOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  166:        if (iface.hasNoEffect())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  167:          continue;
        -:  168:      }
        -:  169:
        -:  170:      // Assuming the inlined region is valid, we only need to check if the
        -:  171:      // inlining would change it.
    #####:  172:      bool remainsValid =
    #####:  173:          llvm::TypeSwitch<Operation *, bool>(&op)
call    0 never executed
        -:  174:              .Case<AffineApplyOp, AffineReadOpInterface,
    #####:  175:                    AffineWriteOpInterface>([&](auto op) {
    #####:  176:                return remainsLegalAfterInline(op, src, dest, valueMapping);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  177:              })
call    0 never executed
    #####:  178:              .Default([](Operation *) {
branch  0 never executed
branch  1 never executed
        -:  179:                // Conservatively disallow inlining ops we cannot reason about.
        -:  180:                return false;
        -:  181:              });
        -:  182:
    #####:  183:      if (!remainsValid)
branch  0 never executed
branch  1 never executed
    #####:  184:        return false;
        -:  185:    }
        -:  186:
        -:  187:    return true;
        -:  188:  }
        -:  189:
        -:  190:  /// Returns true if the given operation 'op', that is registered to this
        -:  191:  /// dialect, can be inlined into the given region, false otherwise.
function _ZNK12_GLOBAL__N_122AffineInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  192:  bool isLegalToInline(Operation *op, Region *region, bool wouldBeCloned,
        -:  193:                       BlockAndValueMapping &valueMapping) const final {
        -:  194:    // Always allow inlining affine operations into a region that is marked as
        -:  195:    // affine scope, or into affine loops and conditionals. There are some edge
        -:  196:    // cases when inlining *into* affine structures, but that is handled in the
        -:  197:    // other 'isLegalToInline' hook above.
    #####:  198:    Operation *parentOp = region->getParentOp();
call    0 never executed
    #####:  199:    return parentOp->hasTrait<OpTrait::AffineScope>() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  200:           isa<AffineForOp, AffineParallelOp, AffineIfOp>(parentOp);
call    0 never executed
        -:  201:  }
        -:  202:
        -:  203:  /// Affine regions should be analyzed recursively.
function _ZNK12_GLOBAL__N_122AffineInlinerInterface24shouldAnalyzeRecursivelyEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  204:  bool shouldAnalyzeRecursively(Operation *op) const final { return true; }
        -:  205:};
        -:  206:} // namespace
        -:  207:
        -:  208://===----------------------------------------------------------------------===//
        -:  209:// AffineDialect
        -:  210://===----------------------------------------------------------------------===//
        -:  211:
function _ZN4mlir13AffineDialect10initializeEv called 0 returned 0% blocks executed 0%
   91592*:  212:void AffineDialect::initialize() {
   91592*:  213:  addOperations<AffineDmaStartOp, AffineDmaWaitOp,
        -:  214:#define GET_OP_LIST
        -:  215:#include "mlir/Dialect/Affine/IR/AffineOps.cpp.inc"
   91592*:  216:                >();
call    0 never executed
call    1 returned 100%
   91592*:  217:  addInterfaces<AffineInlinerInterface>();
call    0 never executed
call    1 returned 100%
    #####:  218:}
        -:  219:
        -:  220:/// Materialize a single constant operation from a given attribute value with
        -:  221:/// the desired resultant type.
function _ZN4mlir13AffineDialect19materializeConstantERNS_9OpBuilderENS_9AttributeENS_4TypeENS_8LocationE called 325740 returned 100% blocks executed 100%
   325740:  222:Operation *AffineDialect::materializeConstant(OpBuilder &builder,
        -:  223:                                              Attribute value, Type type,
        -:  224:                                              Location loc) {
   325740:  225:  return builder.create<arith::ConstantOp>(loc, type, value);
call    0 returned 100%
        -:  226:}
        -:  227:
        -:  228:/// A utility function to check if a value is defined at the top level of an
        -:  229:/// op with trait `AffineScope`. If the value is defined in an unlinked region,
        -:  230:/// conservatively assume it is not top-level. A value of index type defined at
        -:  231:/// the top level is always a valid symbol.
function _ZN4mlir15isTopLevelValueENS_5ValueE called 500334 returned 100% blocks executed 100%
   500334:  232:bool mlir::isTopLevelValue(Value value) {
   500334:  233:  if (auto arg = value.dyn_cast<BlockArgument>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  234:    // The block owning the argument may be unlinked, e.g. when the surrounding
        -:  235:    // region has not yet been attached to an Op, at which point the parent Op
        -:  236:    // is null.
     1648:  237:    Operation *parentOp = arg.getOwner()->getParentOp();
call    0 returned 100%
     2080:  238:    return parentOp && parentOp->hasTrait<OpTrait::AffineScope>();
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  239:  }
        -:  240:  // The defining Op may live in an unlinked block so its parent Op may be null.
   498686:  241:  Operation *parentOp = value.getDefiningOp()->getParentOp();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   997372:  242:  return parentOp && parentOp->hasTrait<OpTrait::AffineScope>();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
        -:  243:}
        -:  244:
        -:  245:/// Returns the closest region enclosing `op` that is held by an operation with
        -:  246:/// trait `AffineScope`; `nullptr` if there is no such region.
function _ZN4mlir14getAffineScopeEPNS_9OperationE called 109107987 returned 100% blocks executed 100%
109107987:  247:Region *mlir::getAffineScope(Operation *op) {
109107987:  248:  auto *curOp = op;
459384619:  249:  while (auto *parentOp = curOp->getParentOp()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
229692309:  250:    if (parentOp->hasTrait<OpTrait::AffineScope>())
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
109107988:  251:      return curOp->getParentRegion();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  252:    curOp = parentOp;
        -:  253:  }
        -:  254:  return nullptr;
        -:  255:}
        -:  256:
        -:  257:// A Value can be used as a dimension id iff it meets one of the following
        -:  258:// conditions:
        -:  259:// *) It is valid as a symbol.
        -:  260:// *) It is an induction variable.
        -:  261:// *) It is the result of affine apply operation with dimension id arguments.
function _ZN4mlir10isValidDimENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  262:bool mlir::isValidDim(Value value) {
        -:  263:  // The value must be an index type.
    #####:  264:  if (!value.getType().isIndex())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  265:    return false;
        -:  266:
    #####:  267:  if (auto *defOp = value.getDefiningOp())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  268:    return isValidDim(value, getAffineScope(defOp));
call    0 never executed
call    1 never executed
        -:  269:
        -:  270:  // This value has to be a block argument for an op that has the
        -:  271:  // `AffineScope` trait or for an affine.for or affine.parallel.
    #####:  272:  auto *parentOp = value.cast<BlockArgument>().getOwner()->getParentOp();
call    0 never executed
call    1 never executed
    #####:  273:  return parentOp && (parentOp->hasTrait<OpTrait::AffineScope>() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  274:                      isa<AffineForOp, AffineParallelOp>(parentOp));
call    0 never executed
        -:  275:}
        -:  276:
        -:  277:// Value can be used as a dimension id iff it meets one of the following
        -:  278:// conditions:
        -:  279:// *) It is valid as a symbol.
        -:  280:// *) It is an induction variable.
        -:  281:// *) It is the result of an affine apply operation with dimension id operands.
function _ZN4mlir10isValidDimENS_5ValueEPNS_6RegionE called 187144976 returned 100% blocks executed 86%
187144976:  282:bool mlir::isValidDim(Value value, Region *region) {
        -:  283:  // The value must be an index type.
187144976:  284:  if (!value.getType().isIndex())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken -0%
        -:  285:    return false;
        -:  286:
        -:  287:  // All valid symbols are okay.
187144974:  288:  if (isValidSymbol(value, region))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  289:    return true;
        -:  290:
     4947:  291:  auto *op = value.getDefiningOp();
call    0 returned 100%
     4947:  292:  if (!op) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
        -:  293:    // This value has to be a block argument for an affine.for or an
        -:  294:    // affine.parallel.
     3879:  295:    auto *parentOp = value.cast<BlockArgument>().getOwner()->getParentOp();
call    0 returned 100%
call    1 returned 100%
     3879:  296:    return isa<AffineForOp, AffineParallelOp>(parentOp);
call    0 returned 100%
        -:  297:  }
        -:  298:
        -:  299:  // Affine apply operation is ok if all of its operands are ok.
     1068:  300:  if (auto applyOp = dyn_cast<AffineApplyOp>(op))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        6:  301:    return applyOp.isValidDim(region);
call    0 returned 100%
        -:  302:  // The dim op is okay if its operand memref/tensor is defined at the top
        -:  303:  // level.
     1062:  304:  if (auto dimOp = dyn_cast<ShapedDimOpInterface>(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  305:    return isTopLevelValue(dimOp.getShapedValue());
call    0 never executed
call    1 never executed
     1062:  306:  return false;
        -:  307:}
        -:  308:
        -:  309:/// Returns true if the 'index' dimension of the `memref` defined by
        -:  310:/// `memrefDefOp` is a statically  shaped one or defined using a valid symbol
        -:  311:/// for `region`.
        -:  312:template <typename AnyMemRefDefOp>
    #####:  313:static bool isMemRefSizeValidSymbol(AnyMemRefDefOp memrefDefOp, unsigned index,
        -:  314:                                    Region *region) {
    #####:  315:  auto memRefType = memrefDefOp.getType();
        -:  316:  // Statically shaped.
    #####:  317:  if (!memRefType.isDynamicDim(index))
        -:  318:    return true;
        -:  319:  // Get the position of the dimension among dynamic dimensions;
    #####:  320:  unsigned dynamicDimPos = memRefType.getDynamicDimIndex(index);
    #####:  321:  return isValidSymbol(*(memrefDefOp.getDynamicSizes().begin() + dynamicDimPos),
        -:  322:                       region);
        -:  323:}
------------------
_Z23isMemRefSizeValidSymbolIN4mlir6memref7AllocOpEEbT_jPNS0_6RegionE:
function _Z23isMemRefSizeValidSymbolIN4mlir6memref7AllocOpEEbT_jPNS0_6RegionE called 0 returned 0% blocks executed 0%
    #####:  313:static bool isMemRefSizeValidSymbol(AnyMemRefDefOp memrefDefOp, unsigned index,
call    0 never executed
        -:  314:                                    Region *region) {
    #####:  315:  auto memRefType = memrefDefOp.getType();
        -:  316:  // Statically shaped.
    #####:  317:  if (!memRefType.isDynamicDim(index))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  318:    return true;
        -:  319:  // Get the position of the dimension among dynamic dimensions;
    #####:  320:  unsigned dynamicDimPos = memRefType.getDynamicDimIndex(index);
call    0 never executed
    #####:  321:  return isValidSymbol(*(memrefDefOp.getDynamicSizes().begin() + dynamicDimPos),
call    0 never executed
call    1 never executed
        -:  322:                       region);
        -:  323:}
------------------
_Z23isMemRefSizeValidSymbolIN4mlir6memref9SubViewOpEEbT_jPNS0_6RegionE:
function _Z23isMemRefSizeValidSymbolIN4mlir6memref9SubViewOpEEbT_jPNS0_6RegionE called 0 returned 0% blocks executed 0%
    #####:  313:static bool isMemRefSizeValidSymbol(AnyMemRefDefOp memrefDefOp, unsigned index,
        -:  314:                                    Region *region) {
    #####:  315:  auto memRefType = memrefDefOp.getType();
call    0 never executed
        -:  316:  // Statically shaped.
    #####:  317:  if (!memRefType.isDynamicDim(index))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  318:    return true;
        -:  319:  // Get the position of the dimension among dynamic dimensions;
    #####:  320:  unsigned dynamicDimPos = memRefType.getDynamicDimIndex(index);
call    0 never executed
    #####:  321:  return isValidSymbol(*(memrefDefOp.getDynamicSizes().begin() + dynamicDimPos),
call    0 never executed
call    1 never executed
        -:  322:                       region);
        -:  323:}
------------------
_Z23isMemRefSizeValidSymbolIN4mlir6memref6ViewOpEEbT_jPNS0_6RegionE:
function _Z23isMemRefSizeValidSymbolIN4mlir6memref6ViewOpEEbT_jPNS0_6RegionE called 0 returned 0% blocks executed 0%
    #####:  313:static bool isMemRefSizeValidSymbol(AnyMemRefDefOp memrefDefOp, unsigned index,
call    0 never executed
        -:  314:                                    Region *region) {
    #####:  315:  auto memRefType = memrefDefOp.getType();
        -:  316:  // Statically shaped.
    #####:  317:  if (!memRefType.isDynamicDim(index))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  318:    return true;
        -:  319:  // Get the position of the dimension among dynamic dimensions;
    #####:  320:  unsigned dynamicDimPos = memRefType.getDynamicDimIndex(index);
call    0 never executed
    #####:  321:  return isValidSymbol(*(memrefDefOp.getDynamicSizes().begin() + dynamicDimPos),
call    0 never executed
call    1 never executed
        -:  322:                       region);
        -:  323:}
------------------
        -:  324:
        -:  325:/// Returns true if the result of the dim op is a valid symbol for `region`.
function _ZL18isDimOpValidSymbolN4mlir20ShapedDimOpInterfaceEPNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  326:static bool isDimOpValidSymbol(ShapedDimOpInterface dimOp, Region *region) {
        -:  327:  // The dim op is okay if its source is defined at the top level.
    #####:  328:  if (isTopLevelValue(dimOp.getShapedValue()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  329:    return true;
        -:  330:
        -:  331:  // Conservatively handle remaining BlockArguments as non-valid symbols.
        -:  332:  // E.g. scf.for iterArgs.
    #####:  333:  if (dimOp.getShapedValue().template isa<BlockArgument>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  334:    return false;
        -:  335:
        -:  336:  // The dim op is also okay if its operand memref is a view/subview whose
        -:  337:  // corresponding size is a valid symbol.
    #####:  338:  Optional<int64_t> index = getConstantIntValue(dimOp.getDimension());
call    0 never executed
call    1 never executed
    #####:  339:  assert(index.has_value() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  340:         "expect only `dim` operations with a constant index");
    #####:  341:  int64_t i = index.value();
call    0 never executed
    #####:  342:  return TypeSwitch<Operation *, bool>(dimOp.getShapedValue().getDefiningOp())
call    0 never executed
call    1 never executed
call    2 never executed
        -:  343:      .Case<memref::ViewOp, memref::SubViewOp, memref::AllocOp>(
    #####:  344:          [&](auto op) { return isMemRefSizeValidSymbol(op, i, region); })
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  345:      .Default([](Operation *) { return false; });
branch  0 never executed
branch  1 never executed
        -:  346:}
        -:  347:
        -:  348:// A value can be used as a symbol (at all its use sites) iff it meets one of
        -:  349:// the following conditions:
        -:  350:// *) It is a constant.
        -:  351:// *) Its defining op or block arg appearance is immediately enclosed by an op
        -:  352://    with `AffineScope` trait.
        -:  353:// *) It is the result of an affine.apply operation with symbol operands.
        -:  354:// *) It is a result of the dim op on a memref whose corresponding size is a
        -:  355://    valid symbol.
function _ZN4mlir13isValidSymbolENS_5ValueE called 500412 returned 100% blocks executed 100%
   500412:  356:bool mlir::isValidSymbol(Value value) {
   500412:  357:  if (!value)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  358:    return false;
        -:  359:
        -:  360:  // The value must be an index type.
   500334:  361:  if (!value.getType().isIndex())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  362:    return false;
        -:  363:
        -:  364:  // Check that the value is a top level value.
   500334:  365:  if (isTopLevelValue(value))
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
        -:  366:    return true;
        -:  367:
    18860:  368:  if (auto *defOp = value.getDefiningOp())
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
    17212:  369:    return isValidSymbol(value, getAffineScope(defOp));
call    0 returned 100%
call    1 returned 100%
        -:  370:
        -:  371:  return false;
        -:  372:}
        -:  373:
        -:  374:/// A value can be used as a symbol for `region` iff it meets one of the
        -:  375:/// following conditions:
        -:  376:/// *) It is a constant.
        -:  377:/// *) It is the result of an affine apply operation with symbol arguments.
        -:  378:/// *) It is a result of the dim op on a memref whose corresponding size is
        -:  379:///    a valid symbol.
        -:  380:/// *) It is defined at the top level of 'region' or is its argument.
        -:  381:/// *) It dominates `region`'s parent op.
        -:  382:/// If `region` is null, conservatively assume the symbol definition scope does
        -:  383:/// not exist and only accept the values that would be symbols regardless of
        -:  384:/// the surrounding region structure, i.e. the first three cases above.
function _ZN4mlir13isValidSymbolENS_5ValueEPNS_6RegionE called 187163526 returned 100% blocks executed 71%
187163526:  385:bool mlir::isValidSymbol(Value value, Region *region) {
        -:  386:  // The value must be an index type.
187163526:  387:  if (!value.getType().isIndex())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  388:    return false;
        -:  389:
        -:  390:  // A top-level value is a valid symbol.
187163526:  391:  if (region && ::isTopLevelValue(value, region))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        -:  392:    return true;
        -:  393:
    50688:  394:  auto *defOp = value.getDefiningOp();
call    0 returned 100%
    50688:  395:  if (!defOp) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  396:    // A block argument that is not a top-level value is a valid symbol if it
        -:  397:    // dominates region's parent op.
     3879:  398:    Operation *regionOp = region ? region->getParentOp() : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     7758:  399:    if (regionOp && !regionOp->hasTrait<OpTrait::IsIsolatedFromAbove>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  400:      if (auto *parentOpRegion = region->getParentOp()->getParentRegion())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  401:        return isValidSymbol(value, parentOpRegion);
call    0 never executed
     3879:  402:    return false;
        -:  403:  }
        -:  404:
        -:  405:  // Constant operation is ok.
    46809:  406:  Attribute operandCst;
    46809:  407:  if (matchPattern(defOp, m_Constant(&operandCst)))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
        -:  408:    return true;
        -:  409:
        -:  410:  // Affine apply operation is ok if all of its operands are ok.
     2289:  411:  if (auto applyOp = dyn_cast<AffineApplyOp>(defOp))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
       19:  412:    return applyOp.isValidSymbol(region);
call    0 returned 100%
        -:  413:
        -:  414:  // Dim op results could be valid symbols at any level.
     2270:  415:  if (auto dimOp = dyn_cast<ShapedDimOpInterface>(defOp))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  416:    return isDimOpValidSymbol(dimOp, region);
call    0 never executed
        -:  417:
        -:  418:  // Check for values dominating `region`'s parent op.
     2270:  419:  Operation *regionOp = region ? region->getParentOp() : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     4540:  420:  if (regionOp && !regionOp->hasTrait<OpTrait::IsIsolatedFromAbove>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  421:    if (auto *parentRegion = region->getParentOp()->getParentRegion())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  422:      return isValidSymbol(value, parentRegion);
call    0 never executed
        -:  423:
        -:  424:  return false;
        -:  425:}
        -:  426:
        -:  427:// Returns true if 'value' is a valid index to an affine operation (e.g.
        -:  428:// affine.load, affine.store, affine.dma_start, affine.dma_wait) where
        -:  429:// `region` provides the polyhedral symbol scope. Returns false otherwise.
function _ZL25isValidAffineIndexOperandN4mlir5ValueEPNS_6RegionE called 162519099 returned 100% blocks executed 83%
162519099:  430:static bool isValidAffineIndexOperand(Value value, Region *region) {
162519099:  431:  return isValidDim(value, region) || isValidSymbol(value, region);
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  432:}
        -:  433:
        -:  434:/// Prints dimension and symbol list.
        -:  435:static void printDimAndSymbolList(Operation::operand_iterator begin,
        -:  436:                                  Operation::operand_iterator end,
        -:  437:                                  unsigned numDims, OpAsmPrinter &printer) {
        -:  438:  OperandRange operands(begin, end);
        -:  439:  printer << '(' << operands.take_front(numDims) << ')';
        -:  440:  if (operands.size() > numDims)
        -:  441:    printer << '[' << operands.drop_front(numDims) << ']';
        -:  442:}
        -:  443:
        -:  444:/// Parses dimension and symbol list and returns true if parsing failed.
function _ZN4mlir21parseDimAndSymbolListERNS_11OpAsmParserERN4llvm15SmallVectorImplINS_5ValueEEERj called 1478830 returned 100% blocks executed 79%
  1478830:  445:ParseResult mlir::parseDimAndSymbolList(OpAsmParser &parser,
        -:  446:                                        SmallVectorImpl<Value> &operands,
        -:  447:                                        unsigned &numDims) {
  1478830:  448:  SmallVector<OpAsmParser::UnresolvedOperand, 8> opInfos;
call    0 returned 100%
  1478830:  449:  if (parser.parseOperandList(opInfos, OpAsmParser::Delimiter::Paren))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  450:    return failure();
        -:  451:  // Store number of dimensions for validation by caller.
  1478830:  452:  numDims = opInfos.size();
call    0 returned 100%
        -:  453:
        -:  454:  // Parse the optional symbol operands.
  1478830:  455:  auto indexTy = parser.getBuilder().getIndexType();
call    0 returned 100%
call    1 returned 100%
  1478830:  456:  return failure(parser.parseOperandList(
  2957660:  457:                     opInfos, OpAsmParser::Delimiter::OptionalSquare) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  1478830:  458:                 parser.resolveOperands(opInfos, indexTy, operands));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  459:}
        -:  460:
        -:  461:/// Utility function to verify that a set of operands are valid dimension and
        -:  462:/// symbol identifiers. The operands should be laid out such that the dimension
        -:  463:/// operands are before the symbol operands. This function returns failure if
        -:  464:/// there was an invalid operand. An operation is provided to emit any necessary
        -:  465:/// errors.
        -:  466:template <typename OpTy>
        -:  467:static LogicalResult
 19552455:  468:verifyDimAndSymbolIdentifiers(OpTy &op, Operation::operand_range operands,
        -:  469:                              unsigned numDims) {
 19552455:  470:  unsigned opIt = 0;
 44178581:  471:  for (auto operand : operands) {
 24626127:  472:    if (opIt++ < numDims) {
 24625870:  473:      if (!isValidDim(operand, getAffineScope(op)))
    #####:  474:        return op.emitOpError("operand cannot be used as a dimension id");
     257*:  475:    } else if (!isValidSymbol(operand, getAffineScope(op))) {
       1*:  476:      return op.emitOpError("operand cannot be used as a symbol");
        -:  477:    }
        -:  478:  }
 19552455:  479:  return success();
        -:  480:}
------------------
_Z29verifyDimAndSymbolIdentifiersIN4mlir16AffineParallelOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj:
function _Z29verifyDimAndSymbolIdentifiersIN4mlir16AffineParallelOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj called 10188 returned 100% blocks executed 39%
    10188:  468:verifyDimAndSymbolIdentifiers(OpTy &op, Operation::operand_range operands,
        -:  469:                              unsigned numDims) {
    10188:  470:  unsigned opIt = 0;
    10196:  471:  for (auto operand : operands) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        8:  472:    if (opIt++ < numDims) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  473:      if (!isValidDim(operand, getAffineScope(op)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  474:        return op.emitOpError("operand cannot be used as a dimension id");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  475:    } else if (!isValidSymbol(operand, getAffineScope(op))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  476:      return op.emitOpError("operand cannot be used as a symbol");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  477:    }
        -:  478:  }
    10188:  479:  return success();
        -:  480:}
------------------
_Z29verifyDimAndSymbolIdentifiersIN4mlir10AffineIfOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj:
function _Z29verifyDimAndSymbolIdentifiersIN4mlir10AffineIfOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj called 19538368 returned 100% blocks executed 39%
 19538368:  468:verifyDimAndSymbolIdentifiers(OpTy &op, Operation::operand_range operands,
        -:  469:                              unsigned numDims) {
 19538368:  470:  unsigned opIt = 0;
 44160417:  471:  for (auto operand : operands) {
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 24622049:  472:    if (opIt++ < numDims) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 24622049:  473:      if (!isValidDim(operand, getAffineScope(op)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  474:        return op.emitOpError("operand cannot be used as a dimension id");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  475:    } else if (!isValidSymbol(operand, getAffineScope(op))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  476:      return op.emitOpError("operand cannot be used as a symbol");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  477:    }
        -:  478:  }
 19538368:  479:  return success();
        -:  480:}
------------------
_Z29verifyDimAndSymbolIdentifiersIN4mlir11AffineForOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj:
function _Z29verifyDimAndSymbolIdentifiersIN4mlir11AffineForOpEENS0_13LogicalResultERT_NS0_12OperandRangeEj called 3899 returned 100% blocks executed 78%
     3899:  468:verifyDimAndSymbolIdentifiers(OpTy &op, Operation::operand_range operands,
        -:  469:                              unsigned numDims) {
     3899:  470:  unsigned opIt = 0;
     7968:  471:  for (auto operand : operands) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
     4070:  472:    if (opIt++ < numDims) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     3813:  473:      if (!isValidDim(operand, getAffineScope(op)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  474:        return op.emitOpError("operand cannot be used as a dimension id");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      257:  475:    } else if (!isValidSymbol(operand, getAffineScope(op))) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        1:  476:      return op.emitOpError("operand cannot be used as a symbol");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  477:    }
        -:  478:  }
     3899:  479:  return success();
        -:  480:}
------------------
        -:  481:
        -:  482://===----------------------------------------------------------------------===//
        -:  483:// AffineApplyOp
        -:  484://===----------------------------------------------------------------------===//
        -:  485:
function _ZN4mlir13AffineApplyOp17getAffineValueMapEv called 0 returned 0% blocks executed 0%
    #####:  486:AffineValueMap AffineApplyOp::getAffineValueMap() {
    #####:  487:  return AffineValueMap(getAffineMap(), getOperands(), getResult());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  488:}
        -:  489:
function _ZN4mlir13AffineApplyOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 978395 returned 100% blocks executed 71%
   978395:  490:ParseResult AffineApplyOp::parse(OpAsmParser &parser, OperationState &result) {
   978395:  491:  auto &builder = parser.getBuilder();
call    0 returned 100%
   978395:  492:  auto indexTy = builder.getIndexType();
call    0 returned 100%
        -:  493:
   978395:  494:  AffineMapAttr mapAttr;
   978395:  495:  unsigned numDims;
  1956790:  496:  if (parser.parseAttribute(mapAttr, "map", result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 1956790*:  497:      parseDimAndSymbolList(parser, result.operands, numDims) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
  978395*:  498:      parser.parseOptionalAttrDict(result.attributes))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  499:    return failure();
   978395:  500:  auto map = mapAttr.getValue();
call    0 returned 100%
        -:  501:
  1956790:  502:  if (map.getNumDims() != numDims ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   978395:  503:      numDims + map.getNumSymbols() != result.operands.size()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  504:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  505:                            "dimension or symbol index mismatch");
call    0 never executed
call    1 never executed
        -:  506:  }
        -:  507:
   978395:  508:  result.types.append(map.getNumResults(), indexTy);
call    0 returned 100%
call    1 returned 100%
   978395:  509:  return success();
        -:  510:}
        -:  511:
function _ZN4mlir13AffineApplyOp5printERNS_12OpAsmPrinterE called 1202510 returned 100% blocks executed 100%
  1202510:  512:void AffineApplyOp::print(OpAsmPrinter &p) {
  2405020:  513:  p << " " << getMapAttr();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1202510:  514:  printDimAndSymbolList(operand_begin(), operand_end(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1202510:  515:                        getAffineMap().getNumDims(), p);
call    0 returned 100%
  1202510:  516:  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"map"});
call    0 returned 100%
call    1 returned 100%
  1202510:  517:}
        -:  518:
function _ZN4mlir13AffineApplyOp6verifyEv called 31329986 returned 100% blocks executed 50%
 31329986:  519:LogicalResult AffineApplyOp::verify() {
        -:  520:  // Check input and output dimensions match.
 31329986:  521:  AffineMap affineMap = getMap();
call    0 returned 100%
        -:  522:
        -:  523:  // Verify that operand count matches affine map dimension and symbol count.
 31329986:  524:  if (getNumOperands() != affineMap.getNumDims() + affineMap.getNumSymbols())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  525:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  526:        "operand count and affine map dimension and symbol count must match");
call    0 never executed
        -:  527:
        -:  528:  // Verify that the map only produces one result.
 31329986:  529:  if (affineMap.getNumResults() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  530:    return emitOpError("mapping must produce one value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  531:
 31329986:  532:  return success();
        -:  533:}
        -:  534:
        -:  535:// The result of the affine apply operation can be used as a dimension id if all
        -:  536:// its operands are valid dimension ids.
function _ZN4mlir13AffineApplyOp10isValidDimEv called 0 returned 0% blocks executed 0%
    #####:  537:bool AffineApplyOp::isValidDim() {
    #####:  538:  return llvm::all_of(getOperands(),
call    0 never executed
call    1 never executed
    #####:  539:                      [](Value op) { return mlir::isValidDim(op); });
        -:  540:}
        -:  541:
        -:  542:// The result of the affine apply operation can be used as a dimension id if all
        -:  543:// its operands are valid dimension ids with the parent operation of `region`
        -:  544:// defining the polyhedral scope for symbols.
function _ZN4mlir13AffineApplyOp10isValidDimEPNS_6RegionE called 6 returned 100% blocks executed 100%
        6:  545:bool AffineApplyOp::isValidDim(Region *region) {
        6:  546:  return llvm::all_of(getOperands(),
call    0 returned 100%
call    1 returned 100%
        6:  547:                      [&](Value op) { return ::isValidDim(op, region); });
        -:  548:}
        -:  549:
        -:  550:// The result of the affine apply operation can be used as a symbol if all its
        -:  551:// operands are symbols.
function _ZN4mlir13AffineApplyOp13isValidSymbolEv called 0 returned 0% blocks executed 0%
    #####:  552:bool AffineApplyOp::isValidSymbol() {
    #####:  553:  return llvm::all_of(getOperands(),
call    0 never executed
call    1 never executed
    #####:  554:                      [](Value op) { return mlir::isValidSymbol(op); });
        -:  555:}
        -:  556:
        -:  557:// The result of the affine apply operation can be used as a symbol in `region`
        -:  558:// if all its operands are symbols in `region`.
function _ZN4mlir13AffineApplyOp13isValidSymbolEPNS_6RegionE called 19 returned 100% blocks executed 100%
       19:  559:bool AffineApplyOp::isValidSymbol(Region *region) {
       19:  560:  return llvm::all_of(getOperands(), [&](Value operand) {
call    0 returned 100%
call    1 returned 100%
        -:  561:    return mlir::isValidSymbol(operand, region);
       19:  562:  });
        -:  563:}
        -:  564:
function _ZN4mlir13AffineApplyOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 199923 returned 100% blocks executed 92%
   199923:  565:OpFoldResult AffineApplyOp::fold(ArrayRef<Attribute> operands) {
   199923:  566:  auto map = getAffineMap();
call    0 returned 100%
        -:  567:
        -:  568:  // Fold dims and symbols to existing values.
   199923:  569:  auto expr = map.getResult(0);
call    0 returned 100%
   199923:  570:  if (auto dim = expr.dyn_cast<AffineDimExpr>())
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
    21021:  571:    return getOperand(dim.getPosition());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   178902:  572:  if (auto sym = expr.dyn_cast<AffineSymbolExpr>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       16:  573:    return getOperand(map.getNumDims() + sym.getPosition());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  574:
        -:  575:  // Otherwise, default to folding the map.
   178886:  576:  SmallVector<Attribute, 1> result;
call    0 returned 100%
   178886:  577:  if (failed(map.constantFold(operands, result)))
call    0 returned 100%
branch  1 taken 45% (fallthrough)
branch  2 taken 55%
    79853:  578:    return {};
    99033:  579:  return result[0];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  580:}
        -:  581:
        -:  582:/// Returns the largest known divisor of `e`. Exploits information from the
        -:  583:/// values in `operands`.
function _ZL22getLargestKnownDivisorN4mlir10AffineExprEN4llvm8ArrayRefINS_5ValueEEE called 1291 returned 100% blocks executed 33%
     1291:  584:static int64_t getLargestKnownDivisor(AffineExpr e, ArrayRef<Value> operands) {
        -:  585:  // This method isn't aware of `operands`.
     1291:  586:  int64_t div = e.getLargestKnownDivisor();
call    0 returned 100%
        -:  587:
        -:  588:  // We now make use of operands for the case `e` is a dim expression.
        -:  589:  // TODO: More powerful simplification would have to modify
        -:  590:  // getLargestKnownDivisor to take `operands` and exploit that information as
        -:  591:  // well for dim/sym expressions, but in that case, getLargestKnownDivisor
        -:  592:  // can't be part of the IR library but of the `Analysis` library. The IR
        -:  593:  // library can only really depend on simple O(1) checks.
     1291:  594:  auto dimExpr = e.dyn_cast<AffineDimExpr>();
call    0 returned 100%
        -:  595:  // If it's not a dim expr, `div` is the best we have.
     1291:  596:  if (!dimExpr)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  597:    return div;
        -:  598:
        -:  599:  // We simply exploit information from loop IVs.
        -:  600:  // We don't need to use mlir::getLargestKnownDivisorOfValue since the other
        -:  601:  // desired simplifications are expected to be part of other
        -:  602:  // canonicalizations. Also, mlir::getLargestKnownDivisorOfValue is part of the
        -:  603:  // LoopAnalysis library.
       38:  604:  Value operand = operands[dimExpr.getPosition()];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       38:  605:  int64_t operandDivisor = 1;
        -:  606:  // TODO: With the right accessors, this can be extended to
        -:  607:  // LoopLikeOpInterface.
       38:  608:  if (AffineForOp forOp = getForInductionVarOwner(operand)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  609:    if (forOp.hasConstantLowerBound() && forOp.getConstantLowerBound() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  610:      operandDivisor = forOp.getStep();
call    0 never executed
        -:  611:    } else {
    #####:  612:      uint64_t lbLargestKnownDivisor =
call    0 never executed
    #####:  613:          forOp.getLowerBoundMap().getLargestKnownDivisorOfMapExprs();
call    0 never executed
    #####:  614:      operandDivisor = std::gcd(lbLargestKnownDivisor, forOp.getStep());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  615:    }
        -:  616:  }
       38:  617:  return operandDivisor;
        -:  618:}
        -:  619:
        -:  620:/// Check if `e` is known to be: 0 <= `e` < `k`. Handles the simple cases of `e`
        -:  621:/// being an affine dim expression or a constant.
function _ZL22isNonNegativeBoundedByN4mlir10AffineExprEN4llvm8ArrayRefINS_5ValueEEEl called 1291 returned 100% blocks executed 55%
     1291:  622:static bool isNonNegativeBoundedBy(AffineExpr e, ArrayRef<Value> operands,
        -:  623:                                   int64_t k) {
     1291:  624:  if (auto constExpr = e.dyn_cast<AffineConstantExpr>()) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
       67:  625:    int64_t constVal = constExpr.getValue();
call    0 returned 100%
       67:  626:    return constVal >= 0 && constVal < k;
        -:  627:  }
     1224:  628:  auto dimExpr = e.dyn_cast<AffineDimExpr>();
call    0 returned 100%
     1224:  629:  if (!dimExpr)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  630:    return false;
       38:  631:  Value operand = operands[dimExpr.getPosition()];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  632:  // TODO: With the right accessors, this can be extended to
        -:  633:  // LoopLikeOpInterface.
       38:  634:  if (AffineForOp forOp = getForInductionVarOwner(operand)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  635:    if (forOp.hasConstantLowerBound() && forOp.getConstantLowerBound() >= 0 &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  636:        forOp.hasConstantUpperBound() && forOp.getConstantUpperBound() <= k) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  637:      return true;
        -:  638:    }
        -:  639:  }
        -:  640:
        -:  641:  // We don't consider other cases like `operand` being defined by a constant or
        -:  642:  // an affine.apply op since such cases will already be handled by other
        -:  643:  // patterns and propagation of loop IVs or constant would happen.
       38:  644:  return false;
        -:  645:}
        -:  646:
        -:  647:/// Check if expression `e` is of the form d*e_1 + e_2 where 0 <= e_2 < d.
        -:  648:/// Set `div` to `d`, `quotientTimesDiv` to e_1 and `rem` to e_2 if the
        -:  649:/// expression is in that form.
        -:  650:static bool isQTimesDPlusR(AffineExpr e, ArrayRef<Value> operands, int64_t &div,
        -:  651:                           AffineExpr &quotientTimesDiv, AffineExpr &rem) {
        -:  652:  auto bin = e.dyn_cast<AffineBinaryOpExpr>();
        -:  653:  if (!bin || bin.getKind() != AffineExprKind::Add)
        -:  654:    return false;
        -:  655:
        -:  656:  AffineExpr llhs = bin.getLHS();
        -:  657:  AffineExpr rlhs = bin.getRHS();
        -:  658:  div = getLargestKnownDivisor(llhs, operands);
        -:  659:  if (isNonNegativeBoundedBy(rlhs, operands, div)) {
        -:  660:    quotientTimesDiv = llhs;
        -:  661:    rem = rlhs;
        -:  662:    return true;
        -:  663:  }
        -:  664:  div = getLargestKnownDivisor(rlhs, operands);
        -:  665:  if (isNonNegativeBoundedBy(llhs, operands, div)) {
        -:  666:    quotientTimesDiv = rlhs;
        -:  667:    rem = llhs;
        -:  668:    return true;
        -:  669:  }
        -:  670:  return false;
        -:  671:}
        -:  672:
        -:  673:/// Simplify `expr` while exploiting information from the values in `operands`.
function _ZL23simplifyExprAndOperandsRN4mlir10AffineExprEN4llvm8ArrayRefINS_5ValueEEE called 79948 returned 100% blocks executed 64%
    79948:  674:static void simplifyExprAndOperands(AffineExpr &expr,
        -:  675:                                    ArrayRef<Value> operands) {
        -:  676:  // We do this only for certain floordiv/mod expressions.
    79948:  677:  auto binExpr = expr.dyn_cast<AffineBinaryOpExpr>();
call    0 returned 100%
    79948:  678:  if (!binExpr)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    78809:  679:    return;
        -:  680:
        -:  681:  // Simplify the child expressions first.
     4489:  682:  auto lhs = binExpr.getLHS();
call    0 returned 100%
     4489:  683:  auto rhs = binExpr.getRHS();
call    0 returned 100%
     4489:  684:  simplifyExprAndOperands(lhs, operands);
call    0 returned 100%
     4489:  685:  simplifyExprAndOperands(rhs, operands);
call    0 returned 100%
     4489:  686:  expr = getAffineBinaryOpExpr(binExpr.getKind(), lhs, rhs);
call    0 returned 100%
call    1 returned 100%
        -:  687:
     4489:  688:  binExpr = expr.dyn_cast<AffineBinaryOpExpr>();
call    0 returned 100%
     8123:  689:  if (!binExpr || (binExpr.getKind() != AffineExprKind::FloorDiv &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 81% (fallthrough)
branch  4 taken 19%
branch  5 taken 92% (fallthrough)
branch  6 taken 8%
     3634:  690:                   binExpr.getKind() != AffineExprKind::Mod)) {
call    0 returned 100%
     3350:  691:    return;
        -:  692:  }
        -:  693:
     1139:  694:  auto rhsConst = rhs.dyn_cast<AffineConstantExpr>();
call    0 returned 100%
     1139:  695:  if (!rhsConst)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  696:    return;
        -:  697:
     1139:  698:  int64_t rhsConstVal = rhsConst.getValue();
call    0 returned 100%
     1139:  699:  AffineExpr quotientTimesDiv, rem;
     1139:  700:  int64_t divisor;
        -:  701:
        -:  702:  // Simplify expressions of the form e = (e_1 + e_2) floordiv c or (e_1 + e_2)
        -:  703:  // mod c, where e_1 is a multiple of `k` and 0 <= e_2 < k. In such cases, if
        -:  704:  // `c` % `k` == 0, (e_1 + e_2) floordiv c can be simplified to e_1 floordiv c.
        -:  705:  // And when k % c == 0, (e_1 + e_2) mod c can be simplified to e_2 mod c.
     1139:  706:  if (isQTimesDPlusR(lhs, operands, divisor, quotientTimesDiv, rem)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  707:    if (rhsConstVal % divisor == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  708:        binExpr.getKind() == AffineExprKind::FloorDiv) {
call    0 never executed
    #####:  709:      expr = quotientTimesDiv.floorDiv(rhsConst);
call    0 never executed
    #####:  710:    } else if (divisor % rhsConstVal == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  711:               binExpr.getKind() == AffineExprKind::Mod) {
call    0 never executed
    #####:  712:      expr = rem % rhsConst;
call    0 never executed
        -:  713:    }
    #####:  714:    return;
        -:  715:  }
        -:  716:
        -:  717:  // Handle the simple case when the LHS expression can be either upper
        -:  718:  // bounded or is a known multiple of RHS constant.
        -:  719:  // lhs floordiv c -> 0 if 0 <= lhs < c,
        -:  720:  // lhs mod c -> 0 if lhs % c = 0.
    1139*:  721:  if ((isNonNegativeBoundedBy(lhs, operands, rhsConstVal) &&
call    0 returned 100%
branch  1 never executed
branch  2 never executed
    1139*:  722:       binExpr.getKind() == AffineExprKind::FloorDiv) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    1139*:  723:      (getLargestKnownDivisor(lhs, operands) % rhsConstVal == 0 &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
    #####:  724:       binExpr.getKind() == AffineExprKind::Mod)) {
call    0 never executed
    #####:  725:    expr = getAffineConstantExpr(0, expr.getContext());
call    0 never executed
call    1 never executed
        -:  726:  }
        -:  727:}
        -:  728:
        -:  729:/// Simplify the map while exploiting information on the values in `operands`.
        -:  730://  Use "unused attribute" marker to silence warning stemming from the inability
        -:  731://  to see through the template expansion.
        -:  732:static void LLVM_ATTRIBUTE_UNUSED
function _ZL23simplifyMapWithOperandsRN4mlir9AffineMapEN4llvm8ArrayRefINS_5ValueEEE called 36798 returned 100% blocks executed 80%
    36798:  733:simplifyMapWithOperands(AffineMap &map, ArrayRef<Value> operands) {
   36798*:  734:  assert(map.getNumInputs() == operands.size() && "invalid operands for map");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    36798:  735:  SmallVector<AffineExpr> newResults;
call    0 returned 100%
    36798:  736:  newResults.reserve(map.getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   107768:  737:  for (AffineExpr expr : map.getResults()) {
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
    70970:  738:    simplifyExprAndOperands(expr, operands);
call    0 returned 100%
    70970:  739:    newResults.push_back(expr);
call    0 returned 100%
        -:  740:  }
    36798:  741:  map = AffineMap::get(map.getNumDims(), map.getNumSymbols(), newResults,
    36798:  742:                       map.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    36798:  743:}
        -:  744:
        -:  745:/// Replace all occurrences of AffineExpr at position `pos` in `map` by the
        -:  746:/// defining AffineApplyOp expression and operands.
        -:  747:/// When `dimOrSymbolPosition < dims.size()`, AffineDimExpr@[pos] is replaced.
        -:  748:/// When `dimOrSymbolPosition >= dims.size()`,
        -:  749:/// AffineSymbolExpr@[pos - dims.size()] is replaced.
        -:  750:/// Mutate `map`,`dims` and `syms` in place as follows:
        -:  751:///   1. `dims` and `syms` are only appended to.
        -:  752:///   2. `map` dim and symbols are gradually shifted to higher positions.
        -:  753:///   3. Old `dim` and `sym` entries are replaced by nullptr
        -:  754:/// This avoids the need for any bookkeeping.
function _ZL15replaceDimOrSymPN4mlir9AffineMapEjRN4llvm15SmallVectorImplINS_5ValueEEES6_ called 48818 returned 100% blocks executed 90%
    48818:  755:static LogicalResult replaceDimOrSym(AffineMap *map,
        -:  756:                                     unsigned dimOrSymbolPosition,
        -:  757:                                     SmallVectorImpl<Value> &dims,
        -:  758:                                     SmallVectorImpl<Value> &syms) {
    48818:  759:  bool isDimReplacement = (dimOrSymbolPosition < dims.size());
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
    48818:  760:  unsigned pos = isDimReplacement ? dimOrSymbolPosition
    48818:  761:                                  : dimOrSymbolPosition - dims.size();
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
    48818:  762:  Value &v = isDimReplacement ? dims[pos] : syms[pos];
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    48818:  763:  if (!v)
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
    11322:  764:    return failure();
        -:  765:
    37496:  766:  auto affineApply = v.getDefiningOp<AffineApplyOp>();
call    0 returned 100%
    37496:  767:  if (!affineApply)
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
    33490:  768:    return failure();
        -:  769:
        -:  770:  // At this point we will perform a replacement of `v`, set the entry in `dim`
        -:  771:  // or `sym` to nullptr immediately.
     4006:  772:  v = nullptr;
call    0 returned 100%
        -:  773:
        -:  774:  // Compute the map, dims and symbols coming from the AffineApplyOp.
     4006:  775:  AffineMap composeMap = affineApply.getAffineMap();
call    0 returned 100%
    4006*:  776:  assert(composeMap.getNumResults() == 1 && "affine.apply with >1 results");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     4006:  777:  AffineExpr composeExpr =
     4006:  778:      composeMap.shiftDims(dims.size()).shiftSymbols(syms.size()).getResult(0);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     4006:  779:  ValueRange composeDims =
call    0 returned 100%
     4006:  780:      affineApply.getMapOperands().take_front(composeMap.getNumDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     4006:  781:  ValueRange composeSyms =
call    0 returned 100%
     8012:  782:      affineApply.getMapOperands().take_back(composeMap.getNumSymbols());
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
call    3 returned 100%
        -:  783:
        -:  784:  // Append the dims and symbols where relevant and perform the replacement.
     4006:  785:  MLIRContext *ctx = map->getContext();
call    0 returned 100%
     4006:  786:  AffineExpr toReplace = isDimReplacement ? getAffineDimExpr(pos, ctx)
call    0 returned 100%
    4006*:  787:                                          : getAffineSymbolExpr(pos, ctx);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
     4006:  788:  dims.append(composeDims.begin(), composeDims.end());
call    0 returned 100%
     4006:  789:  syms.append(composeSyms.begin(), composeSyms.end());
call    0 returned 100%
     4006:  790:  *map = map->replace(toReplace, composeExpr, dims.size(), syms.size());
call    0 returned 100%
        -:  791:
     4006:  792:  return success();
        -:  793:}
        -:  794:
        -:  795:/// Iterate over `operands` and fold away all those produced by an AffineApplyOp
        -:  796:/// iteratively. Perform canonicalization of map and operands as well as
        -:  797:/// AffineMap simplification. `map` and `operands` are mutated in place.
function _ZL27composeAffineMapAndOperandsPN4mlir9AffineMapEPN4llvm15SmallVectorImplINS_5ValueEEE called 221421 returned 100% blocks executed 88%
   221421:  798:static void composeAffineMapAndOperands(AffineMap *map,
        -:  799:                                        SmallVectorImpl<Value> *operands) {
   221421:  800:  if (map->getNumResults() == 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      502:  801:    canonicalizeMapAndOperands(map, operands);
      251:  802:    *map = simplifyAffineMap(*map);
call    0 returned 100%
      251:  803:    return;
        -:  804:  }
        -:  805:
   221170:  806:  MLIRContext *ctx = map->getContext();
call    0 returned 100%
   221170:  807:  SmallVector<Value, 4> dims(operands->begin(),
   442340:  808:                             operands->begin() + map->getNumDims());
call    0 returned 100%
call    1 returned 100%
   442340:  809:  SmallVector<Value, 4> syms(operands->begin() + map->getNumDims(),
   442340:  810:                             operands->end());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        -:  811:
        -:  812:  // Iterate over dims and symbols coming from AffineApplyOp and replace until
        -:  813:  // exhaustion. This iteratively mutates `map`, `dims` and `syms`. Both `dims`
        -:  814:  // and `syms` can only increase by construction.
        -:  815:  // The implementation uses a `while` loop to support the case of symbols
        -:  816:  // that may be constructed from dims ;this may be overkill.
   225176:  817:  while (true) {
   225176:  818:    bool changed = false;
   269988:  819:    for (unsigned pos = 0; pos != dims.size() + syms.size(); ++pos)
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
    48818:  820:      if ((changed |= succeeded(replaceDimOrSym(map, pos, dims, syms))))
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
        -:  821:        break;
   225176:  822:    if (!changed)
branch  0 taken 2%
branch  1 taken 98% (fallthrough)
        -:  823:      break;
        -:  824:  }
        -:  825:
        -:  826:  // Clear operands so we can fill them anew.
   221170:  827:  operands->clear();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  828:
        -:  829:  // At this point we may have introduced null operands, prune them out before
        -:  830:  // canonicalizing map and operands.
   221170:  831:  unsigned nDims = 0, nSyms = 0;
   443567:  832:  SmallVector<AffineExpr, 4> dimReplacements, symReplacements;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   221170:  833:  dimReplacements.reserve(dims.size());
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
   221170:  834:  symReplacements.reserve(syms.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   663510:  835:  for (auto *container : {&dims, &syms}) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
   442340:  836:    bool isDim = (container == &dims);
   442340:  837:    auto &repls = isDim ? dimReplacements : symReplacements;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   479678:  838:    for (const auto &en : llvm::enumerate(*container)) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
call    2 returned 100%
    37338:  839:      Value v = en.value();
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
    37338:  840:      if (!v) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
    4006*:  841:        assert(isDim ? !map->isFunctionOfDim(en.index())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        -:  842:                     : !map->isFunctionOfSymbol(en.index()) &&
        -:  843:                           "map is function of unexpected expr@pos");
     4006:  844:        repls.push_back(getAffineConstantExpr(0, ctx));
call    0 returned 100%
call    1 returned 100%
     4006:  845:        continue;
        -:  846:      }
    35473:  847:      repls.push_back(isDim ? getAffineDimExpr(nDims++, ctx)
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
call    2 returned 100%
call    3 returned 100%
     2141:  848:                            : getAffineSymbolExpr(nSyms++, ctx));
call    0 returned 100%
    33332:  849:      operands->push_back(v);
call    0 returned 100%
        -:  850:    }
        -:  851:  }
   221170:  852:  *map = map->replaceDimsAndSymbols(dimReplacements, symReplacements, nDims,
call    0 returned 100%
   221170:  853:                                    nSyms);
call    0 returned 100%
        -:  854:
        -:  855:  // Canonicalize and simplify before returning.
   442340:  856:  canonicalizeMapAndOperands(map, operands);
   221170:  857:  *map = simplifyAffineMap(*map);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  858:}
        -:  859:
function _ZN4mlir32fullyComposeAffineMapAndOperandsEPNS_9AffineMapEPN4llvm15SmallVectorImplINS_5ValueEEE called 108915 returned 100% blocks executed 100%
   108915:  860:void mlir::fullyComposeAffineMapAndOperands(AffineMap *map,
        -:  861:                                            SmallVectorImpl<Value> *operands) {
function _ZZN4mlir32fullyComposeAffineMapAndOperandsEPNS_9AffineMapEPN4llvm15SmallVectorImplINS_5ValueEEEENKUlS4_E_clES4_.isra.0 called 175761 returned 100% blocks executed 100%
   286236:  862:  while (llvm::any_of(*operands, [](Value v) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
   175761:  863:    return isa_and_nonnull<AffineApplyOp>(v.getDefiningOp());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -:  864:  })) {
     1560:  865:    composeAffineMapAndOperands(map, operands);
call    0 returned 100%
        -:  866:  }
   108915:  867:}
        -:  868:
        -:  869:/// Given a list of `OpFoldResult`, build the necessary operations to populate
        -:  870:/// `actualValues` with values produced by operations. In particular, for any
        -:  871:/// attribute-typed element in `values`, call the constant materializer
        -:  872:/// associated with the Affine dialect to produce an operation. Do NOT notify
        -:  873:/// the builder listener about the constant ops being created as they are
        -:  874:/// intended to be removed after being folded into affine constructs; this is
        -:  875:/// not suitable for use beyond the Affine dialect.
function _ZL20materializeConstantsRN4mlir9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_12OpFoldResultEEERNS3_15SmallVectorImplIPNS_9OperationEEERNS7_INS_5ValueEEE called 48 returned 100% blocks executed 83%
       48:  876:static void materializeConstants(OpBuilder &b, Location loc,
        -:  877:                                 ArrayRef<OpFoldResult> values,
        -:  878:                                 SmallVectorImpl<Operation *> &constants,
        -:  879:                                 SmallVectorImpl<Value> &actualValues) {
       48:  880:  OpBuilder::Listener *listener = b.getListener();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48:  881:  b.setListener(nullptr);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48:  882:  auto listenerResetter =
       48:  883:      llvm::make_scope_exit([listener, &b] { b.setListener(listener); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  884:
       48:  885:  actualValues.reserve(values.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48:  886:  auto *dialect = b.getContext()->getLoadedDialect<AffineDialect>();
call    0 returned 100%
      336:  887:  for (OpFoldResult ofr : values) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
     576*:  888:    if (auto value = ofr.dyn_cast<Value>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  889:      actualValues.push_back(value);
call    0 never executed
    #####:  890:      continue;
        -:  891:    }
        -:  892:    // Since we are directly specifying `index` as the result type, we need to
        -:  893:    // ensure the provided attribute is also an index type. Otherwise, the
        -:  894:    // AffineDialect materializer will create invalid `arith.constant`
        -:  895:    // operations if the provided Attribute is any other kind of integer.
      288:  896:    constants.push_back(dialect->materializeConstant(
call    0 returned 100%
call    1 returned 100%
      288:  897:        b, b.getIndexAttr(ofr.get<Attribute>().cast<IntegerAttr>().getInt()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      288:  898:        b.getIndexType(), loc));
call    0 returned 100%
      288:  899:    actualValues.push_back(constants.back()->getResult(0));
call    0 returned 100%
call    1 returned 100%
        -:  900:  }
       48:  901:}
        -:  902:
        -:  903:/// Create an operation of the type provided as template argument and attempt to
        -:  904:/// fold it immediately. The operation is expected to have a builder taking
        -:  905:/// arbitrary `leadingArguments`, followed by a list of Value-typed `operands`.
        -:  906:/// The operation is also expected to always produce a single result. Return an
        -:  907:/// `OpFoldResult` containing the Attribute representing the folded constant if
        -:  908:/// complete folding was possible and a Value produced by the created operation
        -:  909:/// otherwise.
        -:  910:template <typename OpTy, typename... Args>
        -:  911:static std::enable_if_t<OpTy::template hasTrait<OpTrait::OneResult>(),
        -:  912:                        OpFoldResult>
      48*:  913:createOrFold(OpBuilder &b, Location loc, ValueRange operands,
        -:  914:             Args &&...leadingArguments) {
        -:  915:  // Identify the constant operands and extract their values as attributes.
        -:  916:  // Note that we cannot use the original values directly because the list of
        -:  917:  // operands may have changed due to canonicalization and composition.
      96*:  918:  SmallVector<Attribute> constantOperands;
      48*:  919:  constantOperands.reserve(operands.size());
      48*:  920:  for (Value operand : operands) {
    #####:  921:    IntegerAttr attr;
    #####:  922:    if (matchPattern(operand, m_Constant(&attr)))
    #####:  923:      constantOperands.push_back(attr);
        -:  924:    else
    #####:  925:      constantOperands.push_back(nullptr);
        -:  926:  }
        -:  927:
        -:  928:  // Create the operation and immediately attempt to fold it. On success,
        -:  929:  // delete the operation and prepare the (unmaterialized) value for being
        -:  930:  // returned. On failure, return the operation result value. Temporarily remove
        -:  931:  // the listener to avoid notifying it when the op is created as it may be
        -:  932:  // removed immediately and there is no way of notifying the caller about that
        -:  933:  // without resorting to RewriterBase.
        -:  934:  //
        -:  935:  // TODO: arguably, the main folder (createOrFold) API should support this use
        -:  936:  // case instead of indiscriminately materializing constants.
      48*:  937:  OpBuilder::Listener *listener = b.getListener();
      48*:  938:  b.setListener(nullptr);
      96*:  939:  auto listenerResetter =
      48*:  940:      llvm::make_scope_exit([listener, &b] { b.setListener(listener); });
      48*:  941:  OpTy op =
        -:  942:      b.create<OpTy>(loc, std::forward<Args>(leadingArguments)..., operands);
      48*:  943:  SmallVector<OpFoldResult, 1> foldResults;
      48*:  944:  if (succeeded(op->fold(constantOperands, foldResults)) &&
      48*:  945:      !foldResults.empty()) {
      48*:  946:    op->erase();
      48*:  947:    return foldResults.front();
        -:  948:  }
        -:  949:
        -:  950:  // Notify the listener now that we definitely know that the operation will
        -:  951:  // persist. Use the original listener stored in the variable.
    #####:  952:  if (listener)
    #####:  953:    listener->notifyOperationInserted(op);
    #####:  954:  return op->getResult(0);
        -:  955:}
------------------
_Z12createOrFoldIN4mlir11AffineMaxOpEJNS0_9IndexTypeERNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_:
function _Z12createOrFoldIN4mlir11AffineMaxOpEJNS0_9IndexTypeERNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:  913:createOrFold(OpBuilder &b, Location loc, ValueRange operands,
branch  0 never executed
branch  1 never executed
        -:  914:             Args &&...leadingArguments) {
        -:  915:  // Identify the constant operands and extract their values as attributes.
        -:  916:  // Note that we cannot use the original values directly because the list of
        -:  917:  // operands may have changed due to canonicalization and composition.
    #####:  918:  SmallVector<Attribute> constantOperands;
    #####:  919:  constantOperands.reserve(operands.size());
branch  0 never executed
branch  1 never executed
    #####:  920:  for (Value operand : operands) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  921:    IntegerAttr attr;
call    0 never executed
    #####:  922:    if (matchPattern(operand, m_Constant(&attr)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:      constantOperands.push_back(attr);
call    0 never executed
        -:  924:    else
    #####:  925:      constantOperands.push_back(nullptr);
call    0 never executed
        -:  926:  }
        -:  927:
        -:  928:  // Create the operation and immediately attempt to fold it. On success,
        -:  929:  // delete the operation and prepare the (unmaterialized) value for being
        -:  930:  // returned. On failure, return the operation result value. Temporarily remove
        -:  931:  // the listener to avoid notifying it when the op is created as it may be
        -:  932:  // removed immediately and there is no way of notifying the caller about that
        -:  933:  // without resorting to RewriterBase.
        -:  934:  //
        -:  935:  // TODO: arguably, the main folder (createOrFold) API should support this use
        -:  936:  // case instead of indiscriminately materializing constants.
    #####:  937:  OpBuilder::Listener *listener = b.getListener();
call    0 never executed
    #####:  938:  b.setListener(nullptr);
call    0 never executed
    #####:  939:  auto listenerResetter =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:      llvm::make_scope_exit([listener, &b] { b.setListener(listener); });
branch  0 never executed
branch  1 never executed
    #####:  941:  OpTy op =
call    0 never executed
call    1 never executed
        -:  942:      b.create<OpTy>(loc, std::forward<Args>(leadingArguments)..., operands);
    #####:  943:  SmallVector<OpFoldResult, 1> foldResults;
branch  0 never executed
branch  1 never executed
    #####:  944:  if (succeeded(op->fold(constantOperands, foldResults)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  945:      !foldResults.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  946:    op->erase();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  947:    return foldResults.front();
        -:  948:  }
        -:  949:
        -:  950:  // Notify the listener now that we definitely know that the operation will
        -:  951:  // persist. Use the original listener stored in the variable.
    #####:  952:  if (listener)
branch  0 never executed
branch  1 never executed
    #####:  953:    listener->notifyOperationInserted(op);
call    0 never executed
    #####:  954:  return op->getResult(0);
call    0 never executed
        -:  955:}
------------------
_Z12createOrFoldIN4mlir11AffineMinOpEJNS0_9IndexTypeERNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_:
function _Z12createOrFoldIN4mlir11AffineMinOpEJNS0_9IndexTypeERNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:  913:createOrFold(OpBuilder &b, Location loc, ValueRange operands,
branch  0 never executed
branch  1 never executed
        -:  914:             Args &&...leadingArguments) {
        -:  915:  // Identify the constant operands and extract their values as attributes.
        -:  916:  // Note that we cannot use the original values directly because the list of
        -:  917:  // operands may have changed due to canonicalization and composition.
    #####:  918:  SmallVector<Attribute> constantOperands;
    #####:  919:  constantOperands.reserve(operands.size());
branch  0 never executed
branch  1 never executed
    #####:  920:  for (Value operand : operands) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  921:    IntegerAttr attr;
call    0 never executed
    #####:  922:    if (matchPattern(operand, m_Constant(&attr)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:      constantOperands.push_back(attr);
call    0 never executed
        -:  924:    else
    #####:  925:      constantOperands.push_back(nullptr);
call    0 never executed
        -:  926:  }
        -:  927:
        -:  928:  // Create the operation and immediately attempt to fold it. On success,
        -:  929:  // delete the operation and prepare the (unmaterialized) value for being
        -:  930:  // returned. On failure, return the operation result value. Temporarily remove
        -:  931:  // the listener to avoid notifying it when the op is created as it may be
        -:  932:  // removed immediately and there is no way of notifying the caller about that
        -:  933:  // without resorting to RewriterBase.
        -:  934:  //
        -:  935:  // TODO: arguably, the main folder (createOrFold) API should support this use
        -:  936:  // case instead of indiscriminately materializing constants.
    #####:  937:  OpBuilder::Listener *listener = b.getListener();
call    0 never executed
    #####:  938:  b.setListener(nullptr);
call    0 never executed
    #####:  939:  auto listenerResetter =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  940:      llvm::make_scope_exit([listener, &b] { b.setListener(listener); });
branch  0 never executed
branch  1 never executed
    #####:  941:  OpTy op =
call    0 never executed
call    1 never executed
        -:  942:      b.create<OpTy>(loc, std::forward<Args>(leadingArguments)..., operands);
    #####:  943:  SmallVector<OpFoldResult, 1> foldResults;
branch  0 never executed
branch  1 never executed
    #####:  944:  if (succeeded(op->fold(constantOperands, foldResults)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  945:      !foldResults.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  946:    op->erase();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  947:    return foldResults.front();
        -:  948:  }
        -:  949:
        -:  950:  // Notify the listener now that we definitely know that the operation will
        -:  951:  // persist. Use the original listener stored in the variable.
    #####:  952:  if (listener)
branch  0 never executed
branch  1 never executed
    #####:  953:    listener->notifyOperationInserted(op);
call    0 never executed
    #####:  954:  return op->getResult(0);
call    0 never executed
        -:  955:}
------------------
_Z12createOrFoldIN4mlir13AffineApplyOpEJRNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_:
function _Z12createOrFoldIN4mlir13AffineApplyOpEJRNS0_9AffineMapEEENSt9enable_ifIXclsrT_8hasTraitINS0_7OpTrait9OneResultEEEENS0_12OpFoldResultEE4typeERNS0_9OpBuilderENS0_8LocationENS0_10ValueRangeEDpOT0_ called 48 returned 100% blocks executed 47%
       48:  913:createOrFold(OpBuilder &b, Location loc, ValueRange operands,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  914:             Args &&...leadingArguments) {
        -:  915:  // Identify the constant operands and extract their values as attributes.
        -:  916:  // Note that we cannot use the original values directly because the list of
        -:  917:  // operands may have changed due to canonicalization and composition.
       96:  918:  SmallVector<Attribute> constantOperands;
       48:  919:  constantOperands.reserve(operands.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      48*:  920:  for (Value operand : operands) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
    #####:  921:    IntegerAttr attr;
call    0 never executed
    #####:  922:    if (matchPattern(operand, m_Constant(&attr)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:      constantOperands.push_back(attr);
call    0 never executed
        -:  924:    else
    #####:  925:      constantOperands.push_back(nullptr);
call    0 never executed
        -:  926:  }
        -:  927:
        -:  928:  // Create the operation and immediately attempt to fold it. On success,
        -:  929:  // delete the operation and prepare the (unmaterialized) value for being
        -:  930:  // returned. On failure, return the operation result value. Temporarily remove
        -:  931:  // the listener to avoid notifying it when the op is created as it may be
        -:  932:  // removed immediately and there is no way of notifying the caller about that
        -:  933:  // without resorting to RewriterBase.
        -:  934:  //
        -:  935:  // TODO: arguably, the main folder (createOrFold) API should support this use
        -:  936:  // case instead of indiscriminately materializing constants.
       48:  937:  OpBuilder::Listener *listener = b.getListener();
call    0 returned 100%
       48:  938:  b.setListener(nullptr);
call    0 returned 100%
       96:  939:  auto listenerResetter =
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       48:  940:      llvm::make_scope_exit([listener, &b] { b.setListener(listener); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48:  941:  OpTy op =
call    0 returned 100%
call    1 returned 100%
        -:  942:      b.create<OpTy>(loc, std::forward<Args>(leadingArguments)..., operands);
       48:  943:  SmallVector<OpFoldResult, 1> foldResults;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      48*:  944:  if (succeeded(op->fold(constantOperands, foldResults)) &&
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
       48:  945:      !foldResults.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48:  946:    op->erase();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       48:  947:    return foldResults.front();
        -:  948:  }
        -:  949:
        -:  950:  // Notify the listener now that we definitely know that the operation will
        -:  951:  // persist. Use the original listener stored in the variable.
    #####:  952:  if (listener)
branch  0 never executed
branch  1 never executed
    #####:  953:    listener->notifyOperationInserted(op);
call    0 never executed
    #####:  954:  return op->getResult(0);
call    0 never executed
        -:  955:}
------------------
        -:  956:
function _ZN4mlir23makeComposedAffineApplyERNS_9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeE called 1129 returned 100% blocks executed 75%
     1129:  957:AffineApplyOp mlir::makeComposedAffineApply(OpBuilder &b, Location loc,
        -:  958:                                            AffineMap map,
        -:  959:                                            ValueRange operands) {
     1129:  960:  AffineMap normalizedMap = map;
     1129:  961:  SmallVector<Value, 8> normalizedOperands(operands.begin(), operands.end());
call    0 returned 100%
     1129:  962:  composeAffineMapAndOperands(&normalizedMap, &normalizedOperands);
call    0 returned 100%
    1129*:  963:  assert(normalizedMap);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     1129:  964:  return b.create<AffineApplyOp>(loc, normalizedMap, normalizedOperands);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  965:}
        -:  966:
function _ZN4mlir23makeComposedAffineApplyERNS_9OpBuilderENS_8LocationENS_10AffineExprENS_10ValueRangeE called 1129 returned 100% blocks executed 71%
     1129:  967:AffineApplyOp mlir::makeComposedAffineApply(OpBuilder &b, Location loc,
        -:  968:                                            AffineExpr e, ValueRange values) {
     1129:  969:  return makeComposedAffineApply(
     1129:  970:      b, loc, AffineMap::inferFromExprList(ArrayRef<AffineExpr>{e}).front(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1129:  971:      values);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  972:}
        -:  973:
        -:  974:/// Composes the given affine map with the given list of operands, pulling in
        -:  975:/// the maps from any affine.apply operations that supply the operands.
function _ZL27composeMultiResultAffineMapRN4mlir9AffineMapERN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  976:static void composeMultiResultAffineMap(AffineMap &map,
        -:  977:                                        SmallVectorImpl<Value> &operands) {
        -:  978:  // Compose and canonicalize each expression in the map individually because
        -:  979:  // composition only applies to single-result maps, collecting potentially
        -:  980:  // duplicate operands in a single list with shifted dimensions and symbols.
    #####:  981:  SmallVector<Value> dims, symbols;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  982:  SmallVector<AffineExpr> exprs;
branch  0 never executed
branch  1 never executed
    #####:  983:  for (unsigned i : llvm::seq<unsigned>(0, map.getNumResults())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  984:    SmallVector<Value> submapOperands(operands.begin(), operands.end());
call    0 never executed
call    1 never executed
    #####:  985:    AffineMap submap = map.getSubMap({i});
call    0 never executed
    #####:  986:    fullyComposeAffineMapAndOperands(&submap, &submapOperands);
call    0 never executed
    #####:  987:    canonicalizeMapAndOperands(&submap, &submapOperands);
    #####:  988:    unsigned numNewDims = submap.getNumDims();
call    0 never executed
    #####:  989:    submap = submap.shiftDims(dims.size()).shiftSymbols(symbols.size());
call    0 never executed
call    1 never executed
    #####:  990:    llvm::append_range(dims,
branch  0 never executed
branch  1 never executed
    #####:  991:                       ArrayRef<Value>(submapOperands).take_front(numNewDims));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  992:    llvm::append_range(symbols,
call    0 never executed
call    1 never executed
    #####:  993:                       ArrayRef<Value>(submapOperands).drop_front(numNewDims));
call    0 never executed
    #####:  994:    exprs.push_back(submap.getResult(0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  995:  }
        -:  996:
        -:  997:  // Canonicalize the map created from composed expressions to deduplicate the
        -:  998:  // dimension and symbol operands.
    #####:  999:  operands = llvm::to_vector(llvm::concat<Value>(dims, symbols));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1000:  map = AffineMap::get(dims.size(), symbols.size(), exprs, map.getContext());
call    0 never executed
call    1 never executed
    #####: 1001:  canonicalizeMapAndOperands(&map, &operands);
branch  0 never executed
branch  1 never executed
    #####: 1002:}
        -: 1003:
        -: 1004:OpFoldResult
function _ZN4mlir29makeComposedFoldedAffineApplyERNS_9OpBuilderENS_8LocationENS_9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEE called 48 returned 100% blocks executed 81%
       48: 1005:mlir::makeComposedFoldedAffineApply(OpBuilder &b, Location loc, AffineMap map,
        -: 1006:                                    ArrayRef<OpFoldResult> operands) {
      48*: 1007:  assert(map.getNumResults() == 1 && "building affine.apply with !=1 result");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1008:
       48: 1009:  SmallVector<Operation *> constants;
call    0 returned 100%
       48: 1010:  SmallVector<Value> actualValues;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       48: 1011:  materializeConstants(b, loc, operands, constants, actualValues);
call    0 returned 100%
       48: 1012:  composeAffineMapAndOperands(&map, &actualValues);
call    0 returned 100%
       48: 1013:  OpFoldResult result = createOrFold<AffineApplyOp>(b, loc, actualValues, map);
call    0 returned 100%
call    1 returned 100%
        -: 1014:
        -: 1015:  // Constants are always folded into affine min/max because they can be
        -: 1016:  // represented as constant expressions, so delete them.
      336: 1017:  for (Operation *op : constants)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
      288: 1018:    op->erase();
call    0 returned 100%
       48: 1019:  return result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1020:}
        -: 1021:
        -: 1022:OpFoldResult
function _ZN4mlir29makeComposedFoldedAffineApplyERNS_9OpBuilderENS_8LocationENS_10AffineExprEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1023:mlir::makeComposedFoldedAffineApply(OpBuilder &b, Location loc, AffineExpr expr,
        -: 1024:                                    ArrayRef<OpFoldResult> operands) {
    #####: 1025:  return makeComposedFoldedAffineApply(
    #####: 1026:      b, loc, AffineMap::inferFromExprList(ArrayRef<AffineExpr>{expr}).front(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1027:      operands);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1028:}
        -: 1029:
function _ZN4mlir40makeComposedFoldedMultiResultAffineApplyERNS_9OpBuilderENS_8LocationENS_9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEE called 16 returned 100% blocks executed 100%
       16: 1030:SmallVector<OpFoldResult> mlir::makeComposedFoldedMultiResultAffineApply(
        -: 1031:    OpBuilder &b, Location loc, AffineMap map,
        -: 1032:    ArrayRef<OpFoldResult> operands) {
       32: 1033:  return llvm::to_vector(llvm::map_range(
function _ZZN4mlir40makeComposedFoldedMultiResultAffineApplyERNS_9OpBuilderENS_8LocationENS_9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEEENKUljE_clEj called 48 returned 100% blocks executed 100%
       16: 1034:      llvm::seq<unsigned>(0, map.getNumResults()), [&](unsigned i) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       96: 1035:        return makeComposedFoldedAffineApply(b, loc, map.getSubMap({i}),
       48: 1036:                                             operands);
call    0 returned 100%
call    1 returned 100%
       16: 1037:      }));
call    0 returned 100%
        -: 1038:}
        -: 1039:
function _ZN4mlir21makeComposedAffineMinERNS_9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1040:Value mlir::makeComposedAffineMin(OpBuilder &b, Location loc, AffineMap map,
        -: 1041:                                  ValueRange operands) {
    #####: 1042:  SmallVector<Value> allOperands = llvm::to_vector(operands);
call    0 never executed
    #####: 1043:  composeMultiResultAffineMap(map, allOperands);
call    0 never executed
    #####: 1044:  return b.createOrFold<AffineMinOp>(loc, b.getIndexType(), map, allOperands);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1045:}
        -: 1046:
        -: 1047:template <typename OpTy>
    #####: 1048:static OpFoldResult makeComposedFoldedMinMax(OpBuilder &b, Location loc,
        -: 1049:                                             AffineMap map,
        -: 1050:                                             ArrayRef<OpFoldResult> operands) {
    #####: 1051:  SmallVector<Operation *> constants;
    #####: 1052:  SmallVector<Value> actualValues;
    #####: 1053:  materializeConstants(b, loc, operands, constants, actualValues);
    #####: 1054:  composeMultiResultAffineMap(map, actualValues);
        -: 1055:  OpFoldResult result =
    #####: 1056:      createOrFold<OpTy>(b, loc, actualValues, b.getIndexType(), map);
        -: 1057:
        -: 1058:  // Constants are always folded into affine min/max because they can be
        -: 1059:  // represented as constant expressions, so delete them.
    #####: 1060:  for (Operation *op : constants)
    #####: 1061:    op->erase();
    #####: 1062:  return result;
        -: 1063:}
------------------
_Z24makeComposedFoldedMinMaxIN4mlir11AffineMaxOpEENS0_12OpFoldResultERNS0_9OpBuilderENS0_8LocationENS0_9AffineMapEN4llvm8ArrayRefIS2_EE:
function _Z24makeComposedFoldedMinMaxIN4mlir11AffineMaxOpEENS0_12OpFoldResultERNS0_9OpBuilderENS0_8LocationENS0_9AffineMapEN4llvm8ArrayRefIS2_EE called 0 returned 0% blocks executed 0%
    #####: 1048:static OpFoldResult makeComposedFoldedMinMax(OpBuilder &b, Location loc,
call    0 never executed
        -: 1049:                                             AffineMap map,
        -: 1050:                                             ArrayRef<OpFoldResult> operands) {
    #####: 1051:  SmallVector<Operation *> constants;
    #####: 1052:  SmallVector<Value> actualValues;
branch  0 never executed
branch  1 never executed
    #####: 1053:  materializeConstants(b, loc, operands, constants, actualValues);
call    0 never executed
    #####: 1054:  composeMultiResultAffineMap(map, actualValues);
call    0 never executed
        -: 1055:  OpFoldResult result =
    #####: 1056:      createOrFold<OpTy>(b, loc, actualValues, b.getIndexType(), map);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1057:
        -: 1058:  // Constants are always folded into affine min/max because they can be
        -: 1059:  // represented as constant expressions, so delete them.
    #####: 1060:  for (Operation *op : constants)
branch  0 never executed
branch  1 never executed
    #####: 1061:    op->erase();
call    0 never executed
    #####: 1062:  return result;
branch  0 never executed
branch  1 never executed
        -: 1063:}
------------------
_Z24makeComposedFoldedMinMaxIN4mlir11AffineMinOpEENS0_12OpFoldResultERNS0_9OpBuilderENS0_8LocationENS0_9AffineMapEN4llvm8ArrayRefIS2_EE:
function _Z24makeComposedFoldedMinMaxIN4mlir11AffineMinOpEENS0_12OpFoldResultERNS0_9OpBuilderENS0_8LocationENS0_9AffineMapEN4llvm8ArrayRefIS2_EE called 0 returned 0% blocks executed 0%
    #####: 1048:static OpFoldResult makeComposedFoldedMinMax(OpBuilder &b, Location loc,
call    0 never executed
        -: 1049:                                             AffineMap map,
        -: 1050:                                             ArrayRef<OpFoldResult> operands) {
    #####: 1051:  SmallVector<Operation *> constants;
    #####: 1052:  SmallVector<Value> actualValues;
branch  0 never executed
branch  1 never executed
    #####: 1053:  materializeConstants(b, loc, operands, constants, actualValues);
call    0 never executed
    #####: 1054:  composeMultiResultAffineMap(map, actualValues);
call    0 never executed
        -: 1055:  OpFoldResult result =
    #####: 1056:      createOrFold<OpTy>(b, loc, actualValues, b.getIndexType(), map);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1057:
        -: 1058:  // Constants are always folded into affine min/max because they can be
        -: 1059:  // represented as constant expressions, so delete them.
    #####: 1060:  for (Operation *op : constants)
branch  0 never executed
branch  1 never executed
    #####: 1061:    op->erase();
call    0 never executed
    #####: 1062:  return result;
branch  0 never executed
branch  1 never executed
        -: 1063:}
------------------
        -: 1064:
        -: 1065:OpFoldResult
function _ZN4mlir27makeComposedFoldedAffineMinERNS_9OpBuilderENS_8LocationENS_9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1066:mlir::makeComposedFoldedAffineMin(OpBuilder &b, Location loc, AffineMap map,
        -: 1067:                                  ArrayRef<OpFoldResult> operands) {
    #####: 1068:  return makeComposedFoldedMinMax<AffineMinOp>(b, loc, map, operands);
call    0 never executed
        -: 1069:}
        -: 1070:
        -: 1071:OpFoldResult
function _ZN4mlir27makeComposedFoldedAffineMaxERNS_9OpBuilderENS_8LocationENS_9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1072:mlir::makeComposedFoldedAffineMax(OpBuilder &b, Location loc, AffineMap map,
        -: 1073:                                  ArrayRef<OpFoldResult> operands) {
    #####: 1074:  return makeComposedFoldedMinMax<AffineMaxOp>(b, loc, map, operands);
call    0 never executed
        -: 1075:}
        -: 1076:
        -: 1077:/// Fully compose map with operands and canonicalize the result.
        -: 1078:/// Return the `createOrFold`'ed AffineApply op.
function _ZL31createFoldedComposedAffineApplyRN4mlir9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeE called 1625 returned 100% blocks executed 86%
     1625: 1079:static Value createFoldedComposedAffineApply(OpBuilder &b, Location loc,
        -: 1080:                                             AffineMap map,
        -: 1081:                                             ValueRange operandsRef) {
     1625: 1082:  SmallVector<Value, 4> operands(operandsRef.begin(), operandsRef.end());
call    0 returned 100%
     1625: 1083:  fullyComposeAffineMapAndOperands(&map, &operands);
call    0 returned 100%
     3250: 1084:  canonicalizeMapAndOperands(&map, &operands);
     1625: 1085:  return b.createOrFold<AffineApplyOp>(loc, map, operands);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1086:}
        -: 1087:
function _ZN4mlir16applyMapToValuesERNS_9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeE called 1625 returned 100% blocks executed 86%
     1625: 1088:SmallVector<Value, 4> mlir::applyMapToValues(OpBuilder &b, Location loc,
        -: 1089:                                             AffineMap map, ValueRange values) {
     1625: 1090:  SmallVector<Value, 4> res;
call    0 returned 100%
     1625: 1091:  res.reserve(map.getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1625: 1092:  unsigned numDims = map.getNumDims(), numSym = map.getNumSymbols();
call    0 returned 100%
call    1 returned 100%
        -: 1093:  // For each `expr` in `map`, applies the `expr` to the values extracted from
        -: 1094:  // ranges. If the resulting application can be folded into a Value, the
        -: 1095:  // folding occurs eagerly.
     3250: 1096:  for (auto expr : map.getResults()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
     1625: 1097:    AffineMap map = AffineMap::get(numDims, numSym, expr);
call    0 returned 100%
     1625: 1098:    res.push_back(createFoldedComposedAffineApply(b, loc, map, values));
call    0 returned 100%
call    1 returned 100%
        -: 1099:  }
     1625: 1100:  return res;
        -: 1101:}
        -: 1102:
        -: 1103:// A symbol may appear as a dim in affine.apply operations. This function
        -: 1104:// canonicalizes dims that are valid symbols into actual symbols.
        -: 1105:template <class MapOrSet>
   223228: 1106:static void canonicalizePromotedSymbols(MapOrSet *mapOrSet,
        -: 1107:                                        SmallVectorImpl<Value> *operands) {
   223228: 1108:  if (!mapOrSet || operands->empty())
    #####: 1109:    return;
        -: 1110:
  223228*: 1111:  assert(mapOrSet->getNumInputs() == operands->size() &&
        -: 1112:         "map/set inputs must match number of operands");
        -: 1113:
   223227: 1114:  auto *context = mapOrSet->getContext();
   223228: 1115:  SmallVector<Value, 8> resultOperands;
   223613: 1116:  resultOperands.reserve(operands->size());
   223228: 1117:  SmallVector<Value, 8> remappedSymbols;
   223227: 1118:  remappedSymbols.reserve(operands->size());
   223227: 1119:  unsigned nextDim = 0;
   223227: 1120:  unsigned nextSym = 0;
   223227: 1121:  unsigned oldNumSyms = mapOrSet->getNumSymbols();
   446455: 1122:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
   732203: 1123:  for (unsigned i = 0, e = mapOrSet->getNumInputs(); i != e; ++i) {
   508975: 1124:    if (i < mapOrSet->getNumDims()) {
   499613: 1125:      if (isValidSymbol((*operands)[i])) {
        -: 1126:        // This is a valid symbol that appears as a dim, canonicalize it.
   497748: 1127:        dimRemapping[i] = getAffineSymbolExpr(oldNumSyms + nextSym++, context);
   497748: 1128:        remappedSymbols.push_back((*operands)[i]);
        -: 1129:      } else {
    1865*: 1130:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
    1866*: 1131:        resultOperands.push_back((*operands)[i]);
        -: 1132:      }
        -: 1133:    } else {
    9362*: 1134:      resultOperands.push_back((*operands)[i]);
        -: 1135:    }
        -: 1136:  }
        -: 1137:
   223228: 1138:  resultOperands.append(remappedSymbols.begin(), remappedSymbols.end());
   223228: 1139:  *operands = resultOperands;
   223228: 1140:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, {}, nextDim,
        -: 1141:                                              oldNumSyms + nextSym);
        -: 1142:
  223228*: 1143:  assert(mapOrSet->getNumInputs() == operands->size() &&
        -: 1144:         "map/set inputs must match number of operands");
        -: 1145:}
------------------
_Z27canonicalizePromotedSymbolsIN4mlir10IntegerSetEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE:
function _Z27canonicalizePromotedSymbolsIN4mlir10IntegerSetEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE called 144301 returned 100% blocks executed 59%
   144301: 1106:static void canonicalizePromotedSymbols(MapOrSet *mapOrSet,
        -: 1107:                                        SmallVectorImpl<Value> *operands) {
   144301: 1108:  if (!mapOrSet || operands->empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1109:    return;
        -: 1110:
  144301*: 1111:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1112:         "map/set inputs must match number of operands");
        -: 1113:
   144301: 1114:  auto *context = mapOrSet->getContext();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   144301: 1115:  SmallVector<Value, 8> resultOperands;
   144301: 1116:  resultOperands.reserve(operands->size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   144301: 1117:  SmallVector<Value, 8> remappedSymbols;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   144301: 1118:  remappedSymbols.reserve(operands->size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   144301: 1119:  unsigned nextDim = 0;
   144301: 1120:  unsigned nextSym = 0;
   144301: 1121:  unsigned oldNumSyms = mapOrSet->getNumSymbols();
call    0 returned 100%
call    1 returned 100%
   288602: 1122:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   503020: 1123:  for (unsigned i = 0, e = mapOrSet->getNumInputs(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
   358719: 1124:    if (i < mapOrSet->getNumDims()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   358719: 1125:      if (isValidSymbol((*operands)[i])) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -: 1126:        // This is a valid symbol that appears as a dim, canonicalize it.
   358719: 1127:        dimRemapping[i] = getAffineSymbolExpr(oldNumSyms + nextSym++, context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   358719: 1128:        remappedSymbols.push_back((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1129:      } else {
    #####: 1130:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1131:        resultOperands.push_back((*operands)[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1132:      }
        -: 1133:    } else {
    #####: 1134:      resultOperands.push_back((*operands)[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1135:    }
        -: 1136:  }
        -: 1137:
   144301: 1138:  resultOperands.append(remappedSymbols.begin(), remappedSymbols.end());
call    0 returned 100%
   144301: 1139:  *operands = resultOperands;
call    0 returned 100%
   144301: 1140:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, {}, nextDim,
call    0 returned 100%
        -: 1141:                                              oldNumSyms + nextSym);
        -: 1142:
  144301*: 1143:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1144:         "map/set inputs must match number of operands");
        -: 1145:}
------------------
_Z27canonicalizePromotedSymbolsIN4mlir9AffineMapEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE:
function _Z27canonicalizePromotedSymbolsIN4mlir9AffineMapEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE called 78927 returned 100% blocks executed 83%
    78927: 1106:static void canonicalizePromotedSymbols(MapOrSet *mapOrSet,
        -: 1107:                                        SmallVectorImpl<Value> *operands) {
    78927: 1108:  if (!mapOrSet || operands->empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1109:    return;
        -: 1110:
   78927*: 1111:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1112:         "map/set inputs must match number of operands");
        -: 1113:
    78926: 1114:  auto *context = mapOrSet->getContext();
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
    78927: 1115:  SmallVector<Value, 8> resultOperands;
    79312: 1116:  resultOperands.reserve(operands->size());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
    78927: 1117:  SmallVector<Value, 8> remappedSymbols;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    78926: 1118:  remappedSymbols.reserve(operands->size());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    78926: 1119:  unsigned nextDim = 0;
    78926: 1120:  unsigned nextSym = 0;
    78926: 1121:  unsigned oldNumSyms = mapOrSet->getNumSymbols();
call    0 returned 100%
call    1 returned 100%
   157853: 1122:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
   229183: 1123:  for (unsigned i = 0, e = mapOrSet->getNumInputs(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
   150256: 1124:    if (i < mapOrSet->getNumDims()) {
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
   140894: 1125:      if (isValidSymbol((*operands)[i])) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 99% (fallthrough)
branch  4 taken 1%
        -: 1126:        // This is a valid symbol that appears as a dim, canonicalize it.
   139029: 1127:        dimRemapping[i] = getAffineSymbolExpr(oldNumSyms + nextSym++, context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   139029: 1128:        remappedSymbols.push_back((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1129:      } else {
     1865: 1130:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1866: 1131:        resultOperands.push_back((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1132:      }
        -: 1133:    } else {
     9362: 1134:      resultOperands.push_back((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1135:    }
        -: 1136:  }
        -: 1137:
    78927: 1138:  resultOperands.append(remappedSymbols.begin(), remappedSymbols.end());
call    0 returned 100%
    78927: 1139:  *operands = resultOperands;
call    0 returned 100%
    78927: 1140:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, {}, nextDim,
call    0 returned 100%
        -: 1141:                                              oldNumSyms + nextSym);
        -: 1142:
   78927*: 1143:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1144:         "map/set inputs must match number of operands");
        -: 1145:}
------------------
        -: 1146:
        -: 1147:// Works for either an affine map or an integer set.
        -: 1148:template <class MapOrSet>
   753297: 1149:static void canonicalizeMapOrSetAndOperands(MapOrSet *mapOrSet,
        -: 1150:                                            SmallVectorImpl<Value> *operands) {
        -: 1151:  static_assert(llvm::is_one_of<MapOrSet, AffineMap, IntegerSet>::value,
        -: 1152:                "Argument must be either of AffineMap or IntegerSet type");
        -: 1153:
   753297: 1154:  if (!mapOrSet || operands->empty())
   530069: 1155:    return;
        -: 1156:
  223228*: 1157:  assert(mapOrSet->getNumInputs() == operands->size() &&
        -: 1158:         "map/set inputs must match number of operands");
        -: 1159:
   223228: 1160:  canonicalizePromotedSymbols<MapOrSet>(mapOrSet, operands);
        -: 1161:
        -: 1162:  // Check to see what dims are used.
   446456: 1163:  llvm::SmallBitVector usedDims(mapOrSet->getNumDims());
   223228: 1164:  llvm::SmallBitVector usedSyms(mapOrSet->getNumSymbols());
 2129934*: 1165:  mapOrSet->walkExprs([&](AffineExpr expr) {
  1906706: 1166:    if (auto dimExpr = expr.dyn_cast<AffineDimExpr>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
    1697*: 1167:      usedDims[dimExpr.getPosition()] = true;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
  1905009: 1168:    else if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>())
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
call    3 returned 100%
branch  4 taken 82% (fallthrough)
branch  5 taken 18%
   598528: 1169:      usedSyms[symExpr.getPosition()] = true;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -: 1170:  });
        -: 1171:
   223227: 1172:  auto *context = mapOrSet->getContext();
        -: 1173:
   223228: 1174:  SmallVector<Value, 8> resultOperands;
   223613: 1175:  resultOperands.reserve(operands->size());
        -: 1176:
   446455: 1177:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenDims;
   446455: 1178:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
   223227: 1179:  unsigned nextDim = 0;
  225093*: 1180:  for (unsigned i = 0, e = mapOrSet->getNumDims(); i != e; ++i) {
    1865*: 1181:    if (usedDims[i]) {
        -: 1182:      // Remap dim positions for duplicate operands.
    1608*: 1183:      auto it = seenDims.find((*operands)[i]);
    1608*: 1184:      if (it == seenDims.end()) {
    1603*: 1185:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
    1604*: 1186:        resultOperands.push_back((*operands)[i]);
    1604*: 1187:        seenDims.insert(std::make_pair((*operands)[i], dimRemapping[i]));
        -: 1188:      } else {
       5*: 1189:        dimRemapping[i] = it->second;
        -: 1190:      }
        -: 1191:    }
        -: 1192:  }
   446456: 1193:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenSymbols;
   446456: 1194:  SmallVector<AffineExpr, 8> symRemapping(mapOrSet->getNumSymbols());
   223228: 1195:  unsigned nextSym = 0;
   730338: 1196:  for (unsigned i = 0, e = mapOrSet->getNumSymbols(); i != e; ++i) {
   507110: 1197:    if (!usedSyms[i])
   497226: 1198:      continue;
        -: 1199:    // Handle constant operands (only needed for symbolic operands since
        -: 1200:    // constant operands in dimensional positions would have already been
        -: 1201:    // promoted to symbolic positions above).
   380904: 1202:    IntegerAttr operandCst;
   380904: 1203:    if (matchPattern((*operands)[i + mapOrSet->getNumDims()],
   761808: 1204:                     m_Constant(&operandCst))) {
   371020: 1205:      symRemapping[i] =
   371020: 1206:          getAffineConstantExpr(operandCst.getValue().getSExtValue(), context);
   371020: 1207:      continue;
        -: 1208:    }
        -: 1209:    // Remap symbol positions for duplicate operands.
    9884*: 1210:    auto it = seenSymbols.find((*operands)[i + mapOrSet->getNumDims()]);
    9884*: 1211:    if (it == seenSymbols.end()) {
    9841*: 1212:      symRemapping[i] = getAffineSymbolExpr(nextSym++, context);
    9841*: 1213:      resultOperands.push_back((*operands)[i + mapOrSet->getNumDims()]);
    9841*: 1214:      seenSymbols.insert(std::make_pair((*operands)[i + mapOrSet->getNumDims()],
        -: 1215:                                        symRemapping[i]));
        -: 1216:    } else {
      43*: 1217:      symRemapping[i] = it->second;
        -: 1218:    }
        -: 1219:  }
   223228: 1220:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, symRemapping,
        -: 1221:                                              nextDim, nextSym);
   223228: 1222:  *operands = resultOperands;
        -: 1223:}
------------------
_Z31canonicalizeMapOrSetAndOperandsIN4mlir10IntegerSetEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE:
function _Z31canonicalizeMapOrSetAndOperandsIN4mlir10IntegerSetEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE called 244961 returned 100% blocks executed 44%
   244961: 1149:static void canonicalizeMapOrSetAndOperands(MapOrSet *mapOrSet,
        -: 1150:                                            SmallVectorImpl<Value> *operands) {
        -: 1151:  static_assert(llvm::is_one_of<MapOrSet, AffineMap, IntegerSet>::value,
        -: 1152:                "Argument must be either of AffineMap or IntegerSet type");
        -: 1153:
   244961: 1154:  if (!mapOrSet || operands->empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 41% (fallthrough)
branch  3 taken 59%
   100660: 1155:    return;
        -: 1156:
  144301*: 1157:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1158:         "map/set inputs must match number of operands");
        -: 1159:
   144301: 1160:  canonicalizePromotedSymbols<MapOrSet>(mapOrSet, operands);
call    0 returned 100%
        -: 1161:
        -: 1162:  // Check to see what dims are used.
   288602: 1163:  llvm::SmallBitVector usedDims(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   144301: 1164:  llvm::SmallBitVector usedSyms(mapOrSet->getNumSymbols());
call    0 returned 100%
call    1 returned 100%
   144301: 1165:  mapOrSet->walkExprs([&](AffineExpr expr) {
call    0 returned 100%
        -: 1166:    if (auto dimExpr = expr.dyn_cast<AffineDimExpr>())
        -: 1167:      usedDims[dimExpr.getPosition()] = true;
        -: 1168:    else if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>())
        -: 1169:      usedSyms[symExpr.getPosition()] = true;
        -: 1170:  });
        -: 1171:
   144301: 1172:  auto *context = mapOrSet->getContext();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1173:
   144301: 1174:  SmallVector<Value, 8> resultOperands;
call    0 returned 100%
   144301: 1175:  resultOperands.reserve(operands->size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1176:
   288602: 1177:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenDims;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   288602: 1178:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   144301: 1179:  unsigned nextDim = 0;
  144301*: 1180:  for (unsigned i = 0, e = mapOrSet->getNumDims(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1181:    if (usedDims[i]) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1182:      // Remap dim positions for duplicate operands.
    #####: 1183:      auto it = seenDims.find((*operands)[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1184:      if (it == seenDims.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1185:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1186:        resultOperands.push_back((*operands)[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1187:        seenDims.insert(std::make_pair((*operands)[i], dimRemapping[i]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1188:      } else {
    #####: 1189:        dimRemapping[i] = it->second;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1190:      }
        -: 1191:    }
        -: 1192:  }
   288602: 1193:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenSymbols;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   288602: 1194:  SmallVector<AffineExpr, 8> symRemapping(mapOrSet->getNumSymbols());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   144301: 1195:  unsigned nextSym = 0;
   503020: 1196:  for (unsigned i = 0, e = mapOrSet->getNumSymbols(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
   358719: 1197:    if (!usedSyms[i])
call    0 returned 100%
call    1 returned 100%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
   358719: 1198:      continue;
        -: 1199:    // Handle constant operands (only needed for symbolic operands since
        -: 1200:    // constant operands in dimensional positions would have already been
        -: 1201:    // promoted to symbolic positions above).
   238186: 1202:    IntegerAttr operandCst;
call    0 returned 100%
   238186: 1203:    if (matchPattern((*operands)[i + mapOrSet->getNumDims()],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
   476372: 1204:                     m_Constant(&operandCst))) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   238186: 1205:      symRemapping[i] =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   238186: 1206:          getAffineConstantExpr(operandCst.getValue().getSExtValue(), context);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   238186: 1207:      continue;
        -: 1208:    }
        -: 1209:    // Remap symbol positions for duplicate operands.
    #####: 1210:    auto it = seenSymbols.find((*operands)[i + mapOrSet->getNumDims()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1211:    if (it == seenSymbols.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1212:      symRemapping[i] = getAffineSymbolExpr(nextSym++, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1213:      resultOperands.push_back((*operands)[i + mapOrSet->getNumDims()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1214:      seenSymbols.insert(std::make_pair((*operands)[i + mapOrSet->getNumDims()],
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1215:                                        symRemapping[i]));
        -: 1216:    } else {
    #####: 1217:      symRemapping[i] = it->second;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1218:    }
        -: 1219:  }
   144301: 1220:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, symRemapping,
call    0 returned 100%
        -: 1221:                                              nextDim, nextSym);
   144301: 1222:  *operands = resultOperands;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1223:}
------------------
_Z31canonicalizeMapOrSetAndOperandsIN4mlir9AffineMapEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE:
function _Z31canonicalizeMapOrSetAndOperandsIN4mlir9AffineMapEEvPT_PN4llvm15SmallVectorImplINS0_5ValueEEE called 508336 returned 100% blocks executed 84%
   508336: 1149:static void canonicalizeMapOrSetAndOperands(MapOrSet *mapOrSet,
        -: 1150:                                            SmallVectorImpl<Value> *operands) {
        -: 1151:  static_assert(llvm::is_one_of<MapOrSet, AffineMap, IntegerSet>::value,
        -: 1152:                "Argument must be either of AffineMap or IntegerSet type");
        -: 1153:
   508336: 1154:  if (!mapOrSet || operands->empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 84% (fallthrough)
branch  3 taken 16%
   429409: 1155:    return;
        -: 1156:
   78927*: 1157:  assert(mapOrSet->getNumInputs() == operands->size() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1158:         "map/set inputs must match number of operands");
        -: 1159:
    78927: 1160:  canonicalizePromotedSymbols<MapOrSet>(mapOrSet, operands);
call    0 returned 100%
        -: 1161:
        -: 1162:  // Check to see what dims are used.
   157854: 1163:  llvm::SmallBitVector usedDims(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    78927: 1164:  llvm::SmallBitVector usedSyms(mapOrSet->getNumSymbols());
call    0 returned 100%
call    1 returned 100%
    78927: 1165:  mapOrSet->walkExprs([&](AffineExpr expr) {
call    0 returned 100%
        -: 1166:    if (auto dimExpr = expr.dyn_cast<AffineDimExpr>())
        -: 1167:      usedDims[dimExpr.getPosition()] = true;
        -: 1168:    else if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>())
        -: 1169:      usedSyms[symExpr.getPosition()] = true;
        -: 1170:  });
        -: 1171:
    78926: 1172:  auto *context = mapOrSet->getContext();
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -: 1173:
    78927: 1174:  SmallVector<Value, 8> resultOperands;
call    0 returned 100%
    79312: 1175:  resultOperands.reserve(operands->size());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 1176:
   157853: 1177:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenDims;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
   157853: 1178:  SmallVector<AffineExpr, 8> dimRemapping(mapOrSet->getNumDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    78926: 1179:  unsigned nextDim = 0;
    80792: 1180:  for (unsigned i = 0, e = mapOrSet->getNumDims(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
     1865: 1181:    if (usedDims[i]) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
        -: 1182:      // Remap dim positions for duplicate operands.
     1608: 1183:      auto it = seenDims.find((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
     1608: 1184:      if (it == seenDims.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
     1603: 1185:        dimRemapping[i] = getAffineDimExpr(nextDim++, context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1604: 1186:        resultOperands.push_back((*operands)[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
     1604: 1187:        seenDims.insert(std::make_pair((*operands)[i], dimRemapping[i]));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -: 1188:      } else {
        5: 1189:        dimRemapping[i] = it->second;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1190:      }
        -: 1191:    }
        -: 1192:  }
   157854: 1193:  llvm::SmallDenseMap<Value, AffineExpr, 8> seenSymbols;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   157854: 1194:  SmallVector<AffineExpr, 8> symRemapping(mapOrSet->getNumSymbols());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    78927: 1195:  unsigned nextSym = 0;
   227318: 1196:  for (unsigned i = 0, e = mapOrSet->getNumSymbols(); i != e; ++i) {
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
   148391: 1197:    if (!usedSyms[i])
call    0 returned 100%
call    1 returned 100%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
   138507: 1198:      continue;
        -: 1199:    // Handle constant operands (only needed for symbolic operands since
        -: 1200:    // constant operands in dimensional positions would have already been
        -: 1201:    // promoted to symbolic positions above).
   142718: 1202:    IntegerAttr operandCst;
call    0 returned 100%
   142718: 1203:    if (matchPattern((*operands)[i + mapOrSet->getNumDims()],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
   285436: 1204:                     m_Constant(&operandCst))) {
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
   132834: 1205:      symRemapping[i] =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   132834: 1206:          getAffineConstantExpr(operandCst.getValue().getSExtValue(), context);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   132834: 1207:      continue;
        -: 1208:    }
        -: 1209:    // Remap symbol positions for duplicate operands.
     9884: 1210:    auto it = seenSymbols.find((*operands)[i + mapOrSet->getNumDims()]);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
     9884: 1211:    if (it == seenSymbols.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
     9841: 1212:      symRemapping[i] = getAffineSymbolExpr(nextSym++, context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     9841: 1213:      resultOperands.push_back((*operands)[i + mapOrSet->getNumDims()]);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
     9841: 1214:      seenSymbols.insert(std::make_pair((*operands)[i + mapOrSet->getNumDims()],
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 returned 100%
        -: 1215:                                        symRemapping[i]));
        -: 1216:    } else {
       43: 1217:      symRemapping[i] = it->second;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1218:    }
        -: 1219:  }
    78927: 1220:  *mapOrSet = mapOrSet->replaceDimsAndSymbols(dimRemapping, symRemapping,
call    0 returned 100%
        -: 1221:                                              nextDim, nextSym);
    78927: 1222:  *operands = resultOperands;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -: 1223:}
------------------
        -: 1224:
function _ZN4mlir26canonicalizeMapAndOperandsEPNS_9AffineMapEPN4llvm15SmallVectorImplINS_5ValueEEE called 66752 returned 100% blocks executed 100%
  508336*: 1225:void mlir::canonicalizeMapAndOperands(AffineMap *map,
        -: 1226:                                      SmallVectorImpl<Value> *operands) {
  289798*: 1227:  canonicalizeMapOrSetAndOperands<AffineMap>(map, operands);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 returned 100%
    66752: 1228:}
        -: 1229:
function _ZN4mlir26canonicalizeSetAndOperandsEPNS_10IntegerSetEPN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
  244961*: 1230:void mlir::canonicalizeSetAndOperands(IntegerSet *set,
        -: 1231:                                      SmallVectorImpl<Value> *operands) {
    #####: 1232:  canonicalizeMapOrSetAndOperands<IntegerSet>(set, operands);
call    0 never executed
    #####: 1233:}
        -: 1234:
        -: 1235:namespace {
        -: 1236:/// Simplify AffineApply, AffineLoad, and AffineStore operations by composing
        -: 1237:/// maps that supply results into them.
        -: 1238:///
        -: 1239:template <typename AffineOpTy>
        -: 1240:struct SimplifyAffineOp : public OpRewritePattern<AffineOpTy> {
        -: 1241:  using OpRewritePattern<AffineOpTy>::OpRewritePattern;
        -: 1242:
        -: 1243:  /// Replace the affine op with another instance of it with the supplied
        -: 1244:  /// map and mapOperands.
        -: 1245:  void replaceAffineOp(PatternRewriter &rewriter, AffineOpTy affineOp,
        -: 1246:                       AffineMap map, ArrayRef<Value> mapOperands) const;
        -: 1247:
   36798*: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
   36798*: 1256:    auto map = affineOp.getAffineMap();
   36798*: 1257:    AffineMap oldMap = map;
   36798*: 1258:    auto oldOperands = affineOp.getMapOperands();
   73596*: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
   36798*: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
   36798*: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
   36798*: 1262:    simplifyMapWithOperands(map, resultOperands);
   62346*: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
        -: 1264:                                    resultOperands.begin()))
   36798*: 1265:      return failure();
        -: 1266:
   10812*: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
   36798*: 1268:    return success();
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir12AffineLoadOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir12AffineLoadOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 6679 returned 100% blocks executed 94%
     6679: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
     6679: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
     6679: 1257:    AffineMap oldMap = map;
     6679: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
    13358: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
     6679: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
     6679: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
     6679: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
    11184: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1264:                                    resultOperands.begin()))
     6679: 1265:      return failure();
        -: 1266:
     2174: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
call    0 returned 100%
     6679: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir16AffinePrefetchOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir16AffinePrefetchOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
call    0 never executed
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
    #####: 1256:    auto map = affineOp.getAffineMap();
    #####: 1257:    AffineMap oldMap = map;
    #####: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 never executed
call    1 never executed
    #####: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
    #####: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 never executed
call    1 never executed
    #####: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 never executed
    #####: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 never executed
    #####: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1264:                                    resultOperands.begin()))
    #####: 1265:      return failure();
        -: 1266:
    #####: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
call    0 never executed
    #####: 1268:    return success();
branch  0 never executed
branch  1 never executed
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir13AffineStoreOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir13AffineStoreOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 16804 returned 100% blocks executed 94%
    16804: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
    16804: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
    16804: 1257:    AffineMap oldMap = map;
    16804: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
    33608: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
    16804: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
    16804: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
    16804: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
    28965: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1264:                                    resultOperands.begin()))
    16804: 1265:      return failure();
        -: 1266:
     4643: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
call    0 returned 100%
    16804: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir18AffineVectorLoadOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir18AffineVectorLoadOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 5854 returned 100% blocks executed 94%
     5854: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
     5854: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
     5854: 1257:    AffineMap oldMap = map;
     5854: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
    11708: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
     5854: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
     5854: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
     5854: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
    10110: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1264:                                    resultOperands.begin()))
     5854: 1265:      return failure();
        -: 1266:
     1598: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
call    0 returned 100%
     5854: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir19AffineVectorStoreOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir19AffineVectorStoreOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 5841 returned 100% blocks executed 94%
     5841: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
     5841: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
     5841: 1257:    AffineMap oldMap = map;
     5841: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
    11682: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
     5841: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
     5841: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
     5841: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
    10097: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1264:                                    resultOperands.begin()))
     5841: 1265:      return failure();
        -: 1266:
     1585: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
call    0 returned 100%
     5841: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir13AffineApplyOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir13AffineApplyOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 920 returned 100% blocks executed 100%
      920: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
      920: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
      920: 1257:    AffineMap oldMap = map;
call    0 returned 100%
      920: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
     1840: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
      920: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
      920: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
      920: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
     1290: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1264:                                    resultOperands.begin()))
      920: 1265:      return failure();
        -: 1266:
      550: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
      920: 1268:    return success();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir11AffineMinOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir11AffineMinOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 430 returned 100% blocks executed 93%
      430: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
      430: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
      430: 1257:    AffineMap oldMap = map;
      430: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
      860: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
      430: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
      430: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
      430: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
      430: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -: 1264:                                    resultOperands.begin()))
      430: 1265:      return failure();
        -: 1266:
      138: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
      430: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
_ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir11AffineMaxOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE:
function _ZNK12_GLOBAL__N_116SimplifyAffineOpIN4mlir11AffineMaxOpEE15matchAndRewriteES2_RNS1_15PatternRewriterE called 270 returned 100% blocks executed 93%
      270: 1248:  LogicalResult matchAndRewrite(AffineOpTy affineOp,
        -: 1249:                                PatternRewriter &rewriter) const override {
        -: 1250:    static_assert(
        -: 1251:        llvm::is_one_of<AffineOpTy, AffineLoadOp, AffinePrefetchOp,
        -: 1252:                        AffineStoreOp, AffineApplyOp, AffineMinOp, AffineMaxOp,
        -: 1253:                        AffineVectorStoreOp, AffineVectorLoadOp>::value,
        -: 1254:        "affine load/store/vectorstore/vectorload/apply/prefetch/min/max op "
        -: 1255:        "expected");
      270: 1256:    auto map = affineOp.getAffineMap();
call    0 returned 100%
      270: 1257:    AffineMap oldMap = map;
      270: 1258:    auto oldOperands = affineOp.getMapOperands();
call    0 returned 100%
call    1 returned 100%
      540: 1259:    SmallVector<Value, 8> resultOperands(oldOperands);
      270: 1260:    composeAffineMapAndOperands(&map, &resultOperands);
call    0 returned 100%
call    1 returned 100%
      270: 1261:    canonicalizeMapAndOperands(&map, &resultOperands);
call    0 returned 100%
      270: 1262:    simplifyMapWithOperands(map, resultOperands);
call    0 returned 100%
      270: 1263:    if (map == oldMap && std::equal(oldOperands.begin(), oldOperands.end(),
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -: 1264:                                    resultOperands.begin()))
      270: 1265:      return failure();
        -: 1266:
      124: 1267:    replaceAffineOp(rewriter, affineOp, map, resultOperands);
      270: 1268:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1269:  }
------------------
        -: 1270:};
        -: 1271:
        -: 1272:// Specialize the template to account for the different build signatures for
        -: 1273:// affine load, store, and apply ops.
        -: 1274:template <>
        -: 1275:void SimplifyAffineOp<AffineLoadOp>::replaceAffineOp(
        -: 1276:    PatternRewriter &rewriter, AffineLoadOp load, AffineMap map,
        -: 1277:    ArrayRef<Value> mapOperands) const {
        -: 1278:  rewriter.replaceOpWithNewOp<AffineLoadOp>(load, load.getMemRef(), map,
        -: 1279:                                            mapOperands);
        -: 1280:}
        -: 1281:template <>
        -: 1282:void SimplifyAffineOp<AffinePrefetchOp>::replaceAffineOp(
        -: 1283:    PatternRewriter &rewriter, AffinePrefetchOp prefetch, AffineMap map,
        -: 1284:    ArrayRef<Value> mapOperands) const {
        -: 1285:  rewriter.replaceOpWithNewOp<AffinePrefetchOp>(
        -: 1286:      prefetch, prefetch.getMemref(), map, mapOperands,
        -: 1287:      prefetch.getLocalityHint(), prefetch.getIsWrite(),
        -: 1288:      prefetch.getIsDataCache());
        -: 1289:}
        -: 1290:template <>
        -: 1291:void SimplifyAffineOp<AffineStoreOp>::replaceAffineOp(
        -: 1292:    PatternRewriter &rewriter, AffineStoreOp store, AffineMap map,
        -: 1293:    ArrayRef<Value> mapOperands) const {
        -: 1294:  rewriter.replaceOpWithNewOp<AffineStoreOp>(
        -: 1295:      store, store.getValueToStore(), store.getMemRef(), map, mapOperands);
        -: 1296:}
        -: 1297:template <>
        -: 1298:void SimplifyAffineOp<AffineVectorLoadOp>::replaceAffineOp(
        -: 1299:    PatternRewriter &rewriter, AffineVectorLoadOp vectorload, AffineMap map,
        -: 1300:    ArrayRef<Value> mapOperands) const {
        -: 1301:  rewriter.replaceOpWithNewOp<AffineVectorLoadOp>(
        -: 1302:      vectorload, vectorload.getVectorType(), vectorload.getMemRef(), map,
        -: 1303:      mapOperands);
        -: 1304:}
        -: 1305:template <>
        -: 1306:void SimplifyAffineOp<AffineVectorStoreOp>::replaceAffineOp(
        -: 1307:    PatternRewriter &rewriter, AffineVectorStoreOp vectorstore, AffineMap map,
        -: 1308:    ArrayRef<Value> mapOperands) const {
        -: 1309:  rewriter.replaceOpWithNewOp<AffineVectorStoreOp>(
        -: 1310:      vectorstore, vectorstore.getValueToStore(), vectorstore.getMemRef(), map,
        -: 1311:      mapOperands);
        -: 1312:}
        -: 1313:
        -: 1314:// Generic version for ops that don't have extra operands.
        -: 1315:template <typename AffineOpTy>
      812: 1316:void SimplifyAffineOp<AffineOpTy>::replaceAffineOp(
        -: 1317:    PatternRewriter &rewriter, AffineOpTy op, AffineMap map,
        -: 1318:    ArrayRef<Value> mapOperands) const {
      812: 1319:  rewriter.replaceOpWithNewOp<AffineOpTy>(op, map, mapOperands);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1320:}
        -: 1321:} // namespace
        -: 1322:
function _ZN4mlir13AffineApplyOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 2235 returned 100% blocks executed 100%
     2235: 1323:void AffineApplyOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1324:                                                MLIRContext *context) {
     2235: 1325:  results.add<SimplifyAffineOp<AffineApplyOp>>(context);
call    0 returned 100%
     2230: 1326:}
        -: 1327:
        -: 1328://===----------------------------------------------------------------------===//
        -: 1329:// AffineDmaStartOp
        -: 1330://===----------------------------------------------------------------------===//
        -: 1331:
        -: 1332:// TODO: Check that map operands are loop IVs or symbols.
function _ZN4mlir16AffineDmaStartOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_9AffineMapENS_10ValueRangeES5_S6_S7_S5_S6_S7_S5_S5_S5_ called 13562 returned 100% blocks executed 100%
    13562: 1333:void AffineDmaStartOp::build(OpBuilder &builder, OperationState &result,
        -: 1334:                             Value srcMemRef, AffineMap srcMap,
        -: 1335:                             ValueRange srcIndices, Value destMemRef,
        -: 1336:                             AffineMap dstMap, ValueRange destIndices,
        -: 1337:                             Value tagMemRef, AffineMap tagMap,
        -: 1338:                             ValueRange tagIndices, Value numElements,
        -: 1339:                             Value stride, Value elementsPerStride) {
    13562: 1340:  result.addOperands(srcMemRef);
call    0 returned 100%
call    1 returned 100%
    13562: 1341:  result.addAttribute(getSrcMapAttrStrName(), AffineMapAttr::get(srcMap));
call    0 returned 100%
call    1 returned 100%
    13562: 1342:  result.addOperands(srcIndices);
call    0 returned 100%
    13562: 1343:  result.addOperands(destMemRef);
call    0 returned 100%
call    1 returned 100%
    13562: 1344:  result.addAttribute(getDstMapAttrStrName(), AffineMapAttr::get(dstMap));
call    0 returned 100%
call    1 returned 100%
    13562: 1345:  result.addOperands(destIndices);
call    0 returned 100%
    13562: 1346:  result.addOperands(tagMemRef);
call    0 returned 100%
call    1 returned 100%
    13562: 1347:  result.addAttribute(getTagMapAttrStrName(), AffineMapAttr::get(tagMap));
call    0 returned 100%
call    1 returned 100%
    13562: 1348:  result.addOperands(tagIndices);
call    0 returned 100%
    13562: 1349:  result.addOperands(numElements);
call    0 returned 100%
call    1 returned 100%
    13562: 1350:  if (stride) {
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
     1646: 1351:    result.addOperands({stride, elementsPerStride});
call    0 returned 100%
call    1 returned 100%
        -: 1352:  }
    13562: 1353:}
        -: 1354:
function _ZN4mlir16AffineDmaStartOp5printERNS_12OpAsmPrinterE called 13890 returned 100% blocks executed 100%
    13890: 1355:void AffineDmaStartOp::print(OpAsmPrinter &p) {
    27780: 1356:  p << " " << getSrcMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    13890: 1357:  p.printAffineMapOfSSAIds(getSrcMapAttr(), getSrcIndices());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    27780: 1358:  p << "], " << getDstMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    13890: 1359:  p.printAffineMapOfSSAIds(getDstMapAttr(), getDstIndices());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    27780: 1360:  p << "], " << getTagMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    13890: 1361:  p.printAffineMapOfSSAIds(getTagMapAttr(), getTagIndices());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    27780: 1362:  p << "], " << getNumElements();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    13890: 1363:  if (isStrided()) {
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
     2172: 1364:    p << ", " << getStride();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     2172: 1365:    p << ", " << getNumElementsPerStride();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1366:  }
    41670: 1367:  p << " : " << getSrcMemRefType() << ", " << getDstMemRefType() << ", "
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
    13890: 1368:    << getTagMemRefType();
call    0 returned 100%
call    1 returned 100%
    13890: 1369:}
        -: 1370:
        -: 1371:// Parse AffineDmaStartOp.
        -: 1372:// Ex:
        -: 1373://   affine.dma_start %src[%i, %j], %dst[%k, %l], %tag[%index], %size,
        -: 1374://     %stride, %num_elt_per_stride
        -: 1375://       : memref<3076 x f32, 0>, memref<1024 x f32, 2>, memref<1 x i32>
        -: 1376://
function _ZN4mlir16AffineDmaStartOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1377:ParseResult AffineDmaStartOp::parse(OpAsmParser &parser,
        -: 1378:                                    OperationState &result) {
    #####: 1379:  OpAsmParser::UnresolvedOperand srcMemRefInfo;
call    0 never executed
    #####: 1380:  AffineMapAttr srcMapAttr;
    #####: 1381:  SmallVector<OpAsmParser::UnresolvedOperand, 4> srcMapOperands;
call    0 never executed
    #####: 1382:  OpAsmParser::UnresolvedOperand dstMemRefInfo;
    #####: 1383:  AffineMapAttr dstMapAttr;
    #####: 1384:  SmallVector<OpAsmParser::UnresolvedOperand, 4> dstMapOperands;
branch  0 never executed
branch  1 never executed
    #####: 1385:  OpAsmParser::UnresolvedOperand tagMemRefInfo;
    #####: 1386:  AffineMapAttr tagMapAttr;
    #####: 1387:  SmallVector<OpAsmParser::UnresolvedOperand, 4> tagMapOperands;
branch  0 never executed
branch  1 never executed
    #####: 1388:  OpAsmParser::UnresolvedOperand numElementsInfo;
    #####: 1389:  SmallVector<OpAsmParser::UnresolvedOperand, 2> strideInfo;
branch  0 never executed
branch  1 never executed
        -: 1390:
    #####: 1391:  SmallVector<Type, 3> types;
branch  0 never executed
branch  1 never executed
    #####: 1392:  auto indexType = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
        -: 1393:
        -: 1394:  // Parse and resolve the following list of operands:
        -: 1395:  // *) dst memref followed by its affine maps operands (in square brackets).
        -: 1396:  // *) src memref followed by its affine map operands (in square brackets).
        -: 1397:  // *) tag memref followed by its affine map operands (in square brackets).
        -: 1398:  // *) number of elements transferred by DMA operation.
    #####: 1399:  if (parser.parseOperand(srcMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1400:      parser.parseAffineMapOfSSAIds(srcMapOperands, srcMapAttr,
        -: 1401:                                    getSrcMapAttrStrName(),
    #####: 1402:                                    result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1403:      parser.parseComma() || parser.parseOperand(dstMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1404:      parser.parseAffineMapOfSSAIds(dstMapOperands, dstMapAttr,
        -: 1405:                                    getDstMapAttrStrName(),
    #####: 1406:                                    result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1407:      parser.parseComma() || parser.parseOperand(tagMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1408:      parser.parseAffineMapOfSSAIds(tagMapOperands, tagMapAttr,
        -: 1409:                                    getTagMapAttrStrName(),
    #####: 1410:                                    result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1411:      parser.parseComma() || parser.parseOperand(numElementsInfo))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1412:    return failure();
        -: 1413:
        -: 1414:  // Parse optional stride and elements per stride.
    #####: 1415:  if (parser.parseTrailingOperandList(strideInfo))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1416:    return failure();
        -: 1417:
    #####: 1418:  if (!strideInfo.empty() && strideInfo.size() != 2) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1419:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1420:                            "expected two stride related operands");
call    0 never executed
call    1 never executed
        -: 1421:  }
    #####: 1422:  bool isStrided = strideInfo.size() == 2;
call    0 never executed
        -: 1423:
    #####: 1424:  if (parser.parseColonTypeList(types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1425:    return failure();
        -: 1426:
    #####: 1427:  if (types.size() != 3)
branch  0 never executed
branch  1 never executed
    #####: 1428:    return parser.emitError(parser.getNameLoc(), "expected three types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1429:
    #####: 1430:  if (parser.resolveOperand(srcMemRefInfo, types[0], result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1431:      parser.resolveOperands(srcMapOperands, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1432:      parser.resolveOperand(dstMemRefInfo, types[1], result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1433:      parser.resolveOperands(dstMapOperands, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1434:      parser.resolveOperand(tagMemRefInfo, types[2], result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1435:      parser.resolveOperands(tagMapOperands, indexType, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1436:      parser.resolveOperand(numElementsInfo, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1437:    return failure();
        -: 1438:
    #####: 1439:  if (isStrided) {
branch  0 never executed
branch  1 never executed
    #####: 1440:    if (parser.resolveOperands(strideInfo, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1441:      return failure();
        -: 1442:  }
        -: 1443:
        -: 1444:  // Check that src/dst/tag operand counts match their map.numInputs.
    #####: 1445:  if (srcMapOperands.size() != srcMapAttr.getValue().getNumInputs() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1446:      dstMapOperands.size() != dstMapAttr.getValue().getNumInputs() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1447:      tagMapOperands.size() != tagMapAttr.getValue().getNumInputs())
call    0 never executed
call    1 never executed
    #####: 1448:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1449:                            "memref operand count not equal to map.numInputs");
call    0 never executed
call    1 never executed
    #####: 1450:  return success();
        -: 1451:}
        -: 1452:
function _ZN4mlir16AffineDmaStartOp20verifyInvariantsImplEv called 107424 returned 100% blocks executed 49%
   107424: 1453:LogicalResult AffineDmaStartOp::verifyInvariantsImpl() {
   107424: 1454:  if (!getOperand(getSrcMemRefOperandIndex()).getType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1455:    return emitOpError("expected DMA source to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   107424: 1456:  if (!getOperand(getDstMemRefOperandIndex()).getType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1457:    return emitOpError("expected DMA destination to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   107424: 1458:  if (!getOperand(getTagMemRefOperandIndex()).getType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1459:    return emitOpError("expected DMA tag to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1460:
   322272: 1461:  unsigned numInputsAllMaps = getSrcMap().getNumInputs() +
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   107424: 1462:                              getDstMap().getNumInputs() +
call    0 returned 100%
   107424: 1463:                              getTagMap().getNumInputs();
call    0 returned 100%
   107424: 1464:  if (getNumOperands() != numInputsAllMaps + 3 + 1 &&
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
     9913: 1465:      getNumOperands() != numInputsAllMaps + 3 + 1 + 2) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1466:    return emitOpError("incorrect number of operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1467:  }
        -: 1468:
   107424: 1469:  Region *scope = getAffineScope(*this);
call    0 returned 100%
   292841: 1470:  for (auto idx : getSrcIndices()) {
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
call    3 returned 100%
   185417: 1471:    if (!idx.getType().isIndex())
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 1472:      return emitOpError("src index to dma_start must have 'index' type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   185417: 1473:    if (!isValidAffineIndexOperand(idx, scope))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1474:      return emitOpError("src index must be a dimension or symbol identifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1475:  }
   292813: 1476:  for (auto idx : getDstIndices()) {
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
call    3 returned 100%
   185389: 1477:    if (!idx.getType().isIndex())
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 1478:      return emitOpError("dst index to dma_start must have 'index' type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   185389: 1479:    if (!isValidAffineIndexOperand(idx, scope))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1480:      return emitOpError("dst index must be a dimension or symbol identifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1481:  }
   214848: 1482:  for (auto idx : getTagIndices()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
   107424: 1483:    if (!idx.getType().isIndex())
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 1484:      return emitOpError("tag index to dma_start must have 'index' type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   107424: 1485:    if (!isValidAffineIndexOperand(idx, scope))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1486:      return emitOpError("tag index must be a dimension or symbol identifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1487:  }
   107424: 1488:  return success();
        -: 1489:}
        -: 1490:
function _ZN4mlir16AffineDmaStartOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1491:LogicalResult AffineDmaStartOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1492:                                     SmallVectorImpl<OpFoldResult> &results) {
        -: 1493:  /// dma_start(memrefcast) -> dma_start
    #####: 1494:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 1495:}
        -: 1496:
        -: 1497://===----------------------------------------------------------------------===//
        -: 1498:// AffineDmaWaitOp
        -: 1499://===----------------------------------------------------------------------===//
        -: 1500:
        -: 1501:// TODO: Check that map operands are loop IVs or symbols.
function _ZN4mlir15AffineDmaWaitOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_9AffineMapENS_10ValueRangeES5_ called 13562 returned 100% blocks executed 100%
    13562: 1502:void AffineDmaWaitOp::build(OpBuilder &builder, OperationState &result,
        -: 1503:                            Value tagMemRef, AffineMap tagMap,
        -: 1504:                            ValueRange tagIndices, Value numElements) {
    13562: 1505:  result.addOperands(tagMemRef);
call    0 returned 100%
call    1 returned 100%
    13562: 1506:  result.addAttribute(getTagMapAttrStrName(), AffineMapAttr::get(tagMap));
call    0 returned 100%
call    1 returned 100%
    13562: 1507:  result.addOperands(tagIndices);
call    0 returned 100%
    13562: 1508:  result.addOperands(numElements);
call    0 returned 100%
call    1 returned 100%
    13562: 1509:}
        -: 1510:
function _ZN4mlir15AffineDmaWaitOp5printERNS_12OpAsmPrinterE called 13890 returned 100% blocks executed 95%
    13890: 1511:void AffineDmaWaitOp::print(OpAsmPrinter &p) {
    27780: 1512:  p << " " << getTagMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    13890: 1513:  SmallVector<Value, 2> operands(getTagIndices());
call    0 returned 100%
call    1 returned 100%
    13890: 1514:  p.printAffineMapOfSSAIds(getTagMapAttr(), operands);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    13890: 1515:  p << "], ";
call    0 returned 100%
    13890: 1516:  p.printOperand(getNumElements());
call    0 returned 100%
call    1 returned 100%
    27780: 1517:  p << " : " << getTagMemRef().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    13890: 1518:}
        -: 1519:
        -: 1520:// Parse AffineDmaWaitOp.
        -: 1521:// Eg:
        -: 1522://   affine.dma_wait %tag[%index], %num_elements
        -: 1523://     : memref<1 x i32, (d0) -> (d0), 4>
        -: 1524://
function _ZN4mlir15AffineDmaWaitOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1525:ParseResult AffineDmaWaitOp::parse(OpAsmParser &parser,
        -: 1526:                                   OperationState &result) {
    #####: 1527:  OpAsmParser::UnresolvedOperand tagMemRefInfo;
call    0 never executed
    #####: 1528:  AffineMapAttr tagMapAttr;
    #####: 1529:  SmallVector<OpAsmParser::UnresolvedOperand, 2> tagMapOperands;
call    0 never executed
    #####: 1530:  Type type;
    #####: 1531:  auto indexType = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 1532:  OpAsmParser::UnresolvedOperand numElementsInfo;
call    0 never executed
        -: 1533:
        -: 1534:  // Parse tag memref, its map operands, and dma size.
    #####: 1535:  if (parser.parseOperand(tagMemRefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1536:      parser.parseAffineMapOfSSAIds(tagMapOperands, tagMapAttr,
        -: 1537:                                    getTagMapAttrStrName(),
    #####: 1538:                                    result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1539:      parser.parseComma() || parser.parseOperand(numElementsInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1540:      parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1541:      parser.resolveOperand(tagMemRefInfo, type, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1542:      parser.resolveOperands(tagMapOperands, indexType, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1543:      parser.resolveOperand(numElementsInfo, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1544:    return failure();
        -: 1545:
    #####: 1546:  if (!type.isa<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1547:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1548:                            "expected tag to be of memref type");
call    0 never executed
call    1 never executed
        -: 1549:
    #####: 1550:  if (tagMapOperands.size() != tagMapAttr.getValue().getNumInputs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1551:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1552:                            "tag memref operand count != to map.numInputs");
call    0 never executed
call    1 never executed
    #####: 1553:  return success();
        -: 1554:}
        -: 1555:
function _ZN4mlir15AffineDmaWaitOp20verifyInvariantsImplEv called 107424 returned 100% blocks executed 47%
   107424: 1556:LogicalResult AffineDmaWaitOp::verifyInvariantsImpl() {
   107424: 1557:  if (!getOperand(0).getType().isa<MemRefType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1558:    return emitOpError("expected DMA tag to be of memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   107424: 1559:  Region *scope = getAffineScope(*this);
call    0 returned 100%
   214848: 1560:  for (auto idx : getTagIndices()) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
call    3 returned 100%
   107424: 1561:    if (!idx.getType().isIndex())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1562:      return emitOpError("index to dma_wait must have 'index' type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   107424: 1563:    if (!isValidAffineIndexOperand(idx, scope))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1564:      return emitOpError("index must be a dimension or symbol identifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1565:  }
   107424: 1566:  return success();
        -: 1567:}
        -: 1568:
function _ZN4mlir15AffineDmaWaitOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1569:LogicalResult AffineDmaWaitOp::fold(ArrayRef<Attribute> cstOperands,
        -: 1570:                                    SmallVectorImpl<OpFoldResult> &results) {
        -: 1571:  /// dma_wait(memrefcast) -> dma_wait
    #####: 1572:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 1573:}
        -: 1574:
        -: 1575://===----------------------------------------------------------------------===//
        -: 1576:// AffineForOp
        -: 1577://===----------------------------------------------------------------------===//
        -: 1578:
        -: 1579:/// 'bodyBuilder' is used to build the body of affine.for. If iterArgs and
        -: 1580:/// bodyBuilder are empty/null, we include default terminator op.
function _ZN4mlir11AffineForOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeENS_9AffineMapES5_S6_lS5_N4llvm12function_refIFvS2_NS_8LocationENS_5ValueES5_EEE called 750 returned 100% blocks executed 77%
      750: 1581:void AffineForOp::build(OpBuilder &builder, OperationState &result,
        -: 1582:                        ValueRange lbOperands, AffineMap lbMap,
        -: 1583:                        ValueRange ubOperands, AffineMap ubMap, int64_t step,
        -: 1584:                        ValueRange iterArgs, BodyBuilderFn bodyBuilder) {
     750*: 1585:  assert(((!lbMap && lbOperands.empty()) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
        -: 1586:          lbOperands.size() == lbMap.getNumInputs()) &&
        -: 1587:         "lower bound operand count does not match the affine map");
     750*: 1588:  assert(((!ubMap && ubOperands.empty()) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 never executed
        -: 1589:          ubOperands.size() == ubMap.getNumInputs()) &&
        -: 1590:         "upper bound operand count does not match the affine map");
     750*: 1591:  assert(step > 0 && "step has to be a positive integer constant");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1592:
     750*: 1593:  for (Value val : iterArgs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
    #####: 1594:    result.addTypes(val.getType());
call    0 never executed
        -: 1595:
        -: 1596:  // Add an attribute for the step.
      750: 1597:  result.addAttribute(getStepAttrStrName(),
call    0 returned 100%
      750: 1598:                      builder.getIntegerAttr(builder.getIndexType(), step));
call    0 returned 100%
call    1 returned 100%
        -: 1599:
        -: 1600:  // Add the lower bound.
      750: 1601:  result.addAttribute(getLowerBoundAttrStrName(), AffineMapAttr::get(lbMap));
call    0 returned 100%
call    1 returned 100%
      750: 1602:  result.addOperands(lbOperands);
call    0 returned 100%
        -: 1603:
        -: 1604:  // Add the upper bound.
      750: 1605:  result.addAttribute(getUpperBoundAttrStrName(), AffineMapAttr::get(ubMap));
call    0 returned 100%
call    1 returned 100%
      750: 1606:  result.addOperands(ubOperands);
call    0 returned 100%
        -: 1607:
      750: 1608:  result.addOperands(iterArgs);
call    0 returned 100%
        -: 1609:  // Create a region and a block for the body.  The argument of the region is
        -: 1610:  // the loop induction variable.
      750: 1611:  Region *bodyRegion = result.addRegion();
call    0 returned 100%
      750: 1612:  bodyRegion->push_back(new Block);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      750: 1613:  Block &bodyBlock = bodyRegion->front();
call    0 returned 100%
      750: 1614:  Value inductionVar =
      750: 1615:      bodyBlock.addArgument(builder.getIndexType(), result.location);
call    0 returned 100%
call    1 returned 100%
     750*: 1616:  for (Value val : iterArgs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
    #####: 1617:    bodyBlock.addArgument(val.getType(), val.getLoc());
call    0 never executed
call    1 never executed
        -: 1618:
        -: 1619:  // Create the default terminator if the builder is not provided and if the
        -: 1620:  // iteration arguments are not provided. Otherwise, leave this to the caller
        -: 1621:  // because we don't know which values to return from the loop.
      750: 1622:  if (iterArgs.empty() && !bodyBuilder) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
      738: 1623:    ensureTerminator(*bodyRegion, builder, result.location);
call    0 returned 100%
       12: 1624:  } else if (bodyBuilder) {
branch  0 taken 100%
branch  1 taken 0%
       24: 1625:    OpBuilder::InsertionGuard guard(builder);
call    0 returned 100%
       12: 1626:    builder.setInsertionPointToStart(&bodyBlock);
call    0 returned 100%
       24: 1627:    bodyBuilder(builder, result.location, inductionVar,
call    0 returned 100%
call    1 returned 100%
       24: 1628:                bodyBlock.getArguments().drop_front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1629:  }
      750: 1630:}
        -: 1631:
function _ZN4mlir11AffineForOp5buildERNS_9OpBuilderERNS_14OperationStateElllNS_10ValueRangeEN4llvm12function_refIFvS2_NS_8LocationENS_5ValueES5_EEE called 750 returned 100% blocks executed 100%
      750: 1632:void AffineForOp::build(OpBuilder &builder, OperationState &result, int64_t lb,
        -: 1633:                        int64_t ub, int64_t step, ValueRange iterArgs,
        -: 1634:                        BodyBuilderFn bodyBuilder) {
      750: 1635:  auto lbMap = AffineMap::getConstantMap(lb, builder.getContext());
call    0 returned 100%
      750: 1636:  auto ubMap = AffineMap::getConstantMap(ub, builder.getContext());
call    0 returned 100%
      750: 1637:  return build(builder, result, {}, lbMap, {}, ubMap, step, iterArgs,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      750: 1638:               bodyBuilder);
        -: 1639:}
        -: 1640:
function _ZN4mlir11AffineForOp13verifyRegionsEv called 20406884 returned 100% blocks executed 67%
 20406884: 1641:LogicalResult AffineForOp::verifyRegions() {
        -: 1642:  // Check that the body defines as single block argument for the induction
        -: 1643:  // variable.
 20406884: 1644:  auto *body = getBody();
call    0 returned 100%
20406884*: 1645:  if (body->getNumArguments() == 0 || !body->getArgument(0).getType().isIndex())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1646:    return emitOpError("expected body to have a single index argument for the "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1647:                       "induction variable");
call    0 never executed
        -: 1648:
        -: 1649:  // Verify that the bound operands are valid dimension/symbols.
        -: 1650:  /// Lower bound.
 40813768: 1651:  if (getLowerBoundMap().getNumInputs() > 0)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
     3812: 1652:    if (failed(verifyDimAndSymbolIdentifiers(*this, getLowerBoundOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3812: 1653:                                             getLowerBoundMap().getNumDims())))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        1: 1654:      return failure();
        -: 1655:  /// Upper bound.
 40813766: 1656:  if (getUpperBoundMap().getNumInputs() > 0)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
     3986: 1657:    if (failed(verifyDimAndSymbolIdentifiers(*this, getUpperBoundOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3986: 1658:                                             getUpperBoundMap().getNumDims())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1659:      return failure();
        -: 1660:
 20406883: 1661:  unsigned opNumResults = getNumResults();
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
 20406883: 1662:  if (opNumResults == 0)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
 10346272: 1663:    return success();
        -: 1664:
        -: 1665:  // If ForOp defines values, check that the number and types of the defined
        -: 1666:  // values match ForOp initial iter operands and backedge basic block
        -: 1667:  // arguments.
 10060611: 1668:  if (getNumIterOperands() != opNumResults)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1669:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1670:        "mismatch between the number of loop-carried values and results");
call    0 never executed
 10060611: 1671:  if (getNumRegionIterArgs() != opNumResults)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1672:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1673:        "mismatch between the number of basic block args and results");
call    0 never executed
        -: 1674:
 10060611: 1675:  return success();
        -: 1676:}
        -: 1677:
        -: 1678:/// Parse a for operation loop bounds.
function _ZL10parseBoundbRN4mlir14OperationStateERNS_11OpAsmParserE called 1067262 returned 100% blocks executed 29%
  1067262: 1679:static ParseResult parseBound(bool isLower, OperationState &result,
        -: 1680:                              OpAsmParser &p) {
        -: 1681:  // 'min' / 'max' prefixes are generally syntactic sugar, but are required if
        -: 1682:  // the map has multiple results.
  1067262: 1683:  bool failedToParsedMinMax =
  1600893: 1684:      failed(p.parseOptionalKeyword(isLower ? "max" : "min"));
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
        -: 1685:
  1067262: 1686:  auto &builder = p.getBuilder();
call    0 returned 100%
   533631: 1687:  auto boundAttrStrName = isLower ? AffineForOp::getLowerBoundAttrStrName()
  1067262: 1688:                                  : AffineForOp::getUpperBoundAttrStrName();
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1689:
        -: 1690:  // Parse ssa-id as identity map.
  1067262: 1691:  SmallVector<OpAsmParser::UnresolvedOperand, 1> boundOpInfos;
call    0 returned 100%
  1067262: 1692:  if (p.parseOperandList(boundOpInfos))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1693:    return failure();
        -: 1694:
  1067262: 1695:  if (!boundOpInfos.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1696:    // Check that only one operand was parsed.
    #####: 1697:    if (boundOpInfos.size() > 1)
branch  0 never executed
branch  1 never executed
    #####: 1698:      return p.emitError(p.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1699:                         "expected only one loop bound operand");
call    0 never executed
call    1 never executed
        -: 1700:
        -: 1701:    // TODO: improve error message when SSA value is not of index type.
        -: 1702:    // Currently it is 'use of value ... expects different type than prior uses'
    #####: 1703:    if (p.resolveOperand(boundOpInfos.front(), builder.getIndexType(),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1704:                         result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1705:      return failure();
        -: 1706:
        -: 1707:    // Create an identity map using symbol id. This representation is optimized
        -: 1708:    // for storage. Analysis passes may expand it into a multi-dimensional map
        -: 1709:    // if desired.
    #####: 1710:    AffineMap map = builder.getSymbolIdentityMap();
call    0 never executed
    #####: 1711:    result.addAttribute(boundAttrStrName, AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
    #####: 1712:    return success();
        -: 1713:  }
        -: 1714:
        -: 1715:  // Get the attribute location.
  1067262: 1716:  SMLoc attrLoc = p.getCurrentLocation();
call    0 returned 100%
        -: 1717:
  1067262: 1718:  Attribute boundAttr;
  1067262: 1719:  if (p.parseAttribute(boundAttr, builder.getIndexType(), boundAttrStrName,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1067262: 1720:                       result.attributes))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1721:    return failure();
        -: 1722:
        -: 1723:  // Parse full form - affine map followed by dim and symbol list.
  1067262: 1724:  if (auto affineMapAttr = boundAttr.dyn_cast<AffineMapAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1725:    unsigned currentNumOperands = result.operands.size();
call    0 never executed
    #####: 1726:    unsigned numDims;
    #####: 1727:    if (parseDimAndSymbolList(p, result.operands, numDims))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1728:      return failure();
        -: 1729:
    #####: 1730:    auto map = affineMapAttr.getValue();
call    0 never executed
    #####: 1731:    if (map.getNumDims() != numDims)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1732:      return p.emitError(
call    0 never executed
call    1 never executed
    #####: 1733:          p.getNameLoc(),
call    0 never executed
    #####: 1734:          "dim operand count and affine map dim count must match");
call    0 never executed
call    1 never executed
        -: 1735:
    #####: 1736:    unsigned numDimAndSymbolOperands =
    #####: 1737:        result.operands.size() - currentNumOperands;
call    0 never executed
    #####: 1738:    if (numDims + map.getNumSymbols() != numDimAndSymbolOperands)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1739:      return p.emitError(
call    0 never executed
call    1 never executed
    #####: 1740:          p.getNameLoc(),
call    0 never executed
    #####: 1741:          "symbol operand count and affine map symbol count must match");
call    0 never executed
call    1 never executed
        -: 1742:
        -: 1743:    // If the map has multiple results, make sure that we parsed the min/max
        -: 1744:    // prefix.
    #####: 1745:    if (map.getNumResults() > 1 && failedToParsedMinMax) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1746:      if (isLower) {
branch  0 never executed
branch  1 never executed
    #####: 1747:        return p.emitError(attrLoc, "lower loop bound affine map with "
call    0 never executed
call    1 never executed
    #####: 1748:                                    "multiple results requires 'max' prefix");
call    0 never executed
call    1 never executed
        -: 1749:      }
    #####: 1750:      return p.emitError(attrLoc, "upper loop bound affine map with multiple "
call    0 never executed
call    1 never executed
    #####: 1751:                                  "results requires 'min' prefix");
call    0 never executed
call    1 never executed
        -: 1752:    }
    #####: 1753:    return success();
        -: 1754:  }
        -: 1755:
        -: 1756:  // Parse custom assembly form.
  1067262: 1757:  if (auto integerAttr = boundAttr.dyn_cast<IntegerAttr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1067262: 1758:    result.attributes.pop_back();
call    0 returned 100%
  1067262: 1759:    result.addAttribute(
call    0 returned 100%
        -: 1760:        boundAttrStrName,
  1067262: 1761:        AffineMapAttr::get(builder.getConstantAffineMap(integerAttr.getInt())));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1067262: 1762:    return success();
        -: 1763:  }
        -: 1764:
    #####: 1765:  return p.emitError(
call    0 never executed
call    1 never executed
    #####: 1766:      p.getNameLoc(),
call    0 never executed
    #####: 1767:      "expected valid affine map representation for loop bounds");
call    0 never executed
call    1 never executed
        -: 1768:}
        -: 1769:
function _ZN4mlir11AffineForOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 533631 returned 100% blocks executed 58%
   533631: 1770:ParseResult AffineForOp::parse(OpAsmParser &parser, OperationState &result) {
   533631: 1771:  auto &builder = parser.getBuilder();
call    0 returned 100%
   533631: 1772:  OpAsmParser::Argument inductionVariable;
call    0 returned 100%
   533631: 1773:  inductionVariable.type = builder.getIndexType();
call    0 returned 100%
        -: 1774:  // Parse the induction variable followed by '='.
  533631*: 1775:  if (parser.parseArgument(inductionVariable) || parser.parseEqual())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 1776:    return failure();
        -: 1777:
        -: 1778:  // Parse loop bounds.
 1067262*: 1779:  if (parseBound(/*isLower=*/true, result, parser) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 1067262*: 1780:      parser.parseKeyword("to", " between bounds") ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
  533631*: 1781:      parseBound(/*isLower=*/false, result, parser))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####: 1782:    return failure();
        -: 1783:
        -: 1784:  // Parse the optional loop step, we default to 1 if one is not present.
   533631: 1785:  if (parser.parseOptionalKeyword("step")) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
   533631: 1786:    result.addAttribute(
call    0 returned 100%
        -: 1787:        AffineForOp::getStepAttrStrName(),
  1067262: 1788:        builder.getIntegerAttr(builder.getIndexType(), /*value=*/1));
call    0 returned 100%
call    1 returned 100%
        -: 1789:  } else {
    #####: 1790:    SMLoc stepLoc = parser.getCurrentLocation();
call    0 never executed
    #####: 1791:    IntegerAttr stepAttr;
    #####: 1792:    if (parser.parseAttribute(stepAttr, builder.getIndexType(),
branch  0 never executed
branch  1 never executed
    #####: 1793:                              AffineForOp::getStepAttrStrName().data(),
call    0 never executed
    #####: 1794:                              result.attributes))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1795:      return failure();
        -: 1796:
    #####: 1797:    if (stepAttr.getValue().getSExtValue() < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1798:      return parser.emitError(
call    0 never executed
call    1 never executed
        -: 1799:          stepLoc,
    #####: 1800:          "expected step to be representable as a positive signed integer");
call    0 never executed
call    1 never executed
        -: 1801:  }
        -: 1802:
        -: 1803:  // Parse the optional initial iteration arguments.
   533631: 1804:  SmallVector<OpAsmParser::Argument, 4> regionArgs;
call    0 returned 100%
   533631: 1805:  SmallVector<OpAsmParser::UnresolvedOperand, 4> operands;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1806:
        -: 1807:  // Induction variable.
   533631: 1808:  regionArgs.push_back(inductionVariable);
call    0 returned 100%
        -: 1809:
   533631: 1810:  if (succeeded(parser.parseOptionalKeyword("iter_args"))) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -: 1811:    // Parse assignment list and results type list.
  529122*: 1812:    if (parser.parseAssignmentList(regionArgs, operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  264561*: 1813:        parser.parseArrowTypeList(result.types))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 1814:      return failure();
        -: 1815:    // Resolve input operands.
   264561: 1816:    for (auto argOperandType :
   529122: 1817:         llvm::zip(llvm::drop_begin(regionArgs), operands, result.types)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   264561: 1818:      Type type = std::get<2>(argOperandType);
call    0 returned 100%
   264561: 1819:      std::get<0>(argOperandType).type = type;
call    0 returned 100%
   264561: 1820:      if (parser.resolveOperand(std::get<1>(argOperandType), type,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   264561: 1821:                                result.operands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1822:        return failure();
        -: 1823:    }
        -: 1824:  }
        -: 1825:
        -: 1826:  // Parse the body region.
   533631: 1827:  Region *body = result.addRegion();
call    0 returned 100%
   533631: 1828:  if (regionArgs.size() != result.types.size() + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1829:    return parser.emitError(
call    0 never executed
call    1 never executed
    #####: 1830:        parser.getNameLoc(),
call    0 never executed
    #####: 1831:        "mismatch between the number of loop-carried values and results");
call    0 never executed
call    1 never executed
   533631: 1832:  if (parser.parseRegion(*body, regionArgs))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1833:    return failure();
        -: 1834:
   533631: 1835:  AffineForOp::ensureTerminator(*body, builder, result.location);
call    0 returned 100%
        -: 1836:
        -: 1837:  // Parse the optional attribute list.
   533631: 1838:  return parser.parseOptionalAttrDict(result.attributes);
call    0 returned 100%
        -: 1839:}
        -: 1840:
function _ZL10printBoundN4mlir13AffineMapAttrENS_12OperandRangeEPKcRNS_12OpAsmPrinterE called 1358440 returned 100% blocks executed 91%
  1358440: 1841:static void printBound(AffineMapAttr boundMap,
        -: 1842:                       Operation::operand_range boundOperands,
        -: 1843:                       const char *prefix, OpAsmPrinter &p) {
  1358440: 1844:  AffineMap map = boundMap.getValue();
call    0 returned 100%
        -: 1845:
        -: 1846:  // Check if this bound should be printed using custom assembly form.
        -: 1847:  // The decision to restrict printing custom assembly form to trivial cases
        -: 1848:  // comes from the will to roundtrip MLIR binary -> text -> binary in a
        -: 1849:  // lossless way.
        -: 1850:  // Therefore, custom assembly form parsing and printing is only supported for
        -: 1851:  // zero-operand constant maps and single symbol operand identity maps.
  1358440: 1852:  if (map.getNumResults() == 1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
  1358389: 1853:    AffineExpr expr = map.getResult(0);
call    0 returned 100%
        -: 1854:
        -: 1855:    // Print constant bound.
  1358389: 1856:    if (map.getNumDims() == 0 && map.getNumSymbols() == 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
  1357133: 1857:      if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1357133: 1858:        p << constExpr.getValue();
call    0 returned 100%
call    1 returned 100%
  1357133: 1859:        return;
        -: 1860:      }
        -: 1861:    }
        -: 1862:
        -: 1863:    // Print bound that consists of a single SSA symbol if the map is over a
        -: 1864:    // single symbol.
     1256: 1865:    if (map.getNumDims() == 0 && map.getNumSymbols() == 1) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       51: 1866:      if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1867:        p.printOperand(*boundOperands.begin());
call    0 never executed
    #####: 1868:        return;
        -: 1869:      }
        -: 1870:    }
        -: 1871:  } else {
        -: 1872:    // Map has multiple results. Print 'min' or 'max' prefix.
      102: 1873:    p << prefix << ' ';
call    0 returned 100%
call    1 returned 100%
        -: 1874:  }
        -: 1875:
        -: 1876:  // Print the map and its operands.
     1307: 1877:  p << boundMap;
call    0 returned 100%
     1307: 1878:  printDimAndSymbolList(boundOperands.begin(), boundOperands.end(),
call    0 returned 100%
call    1 returned 100%
        -: 1879:                        map.getNumDims(), p);
        -: 1880:}
        -: 1881:
function _ZN4mlir11AffineForOp18getNumIterOperandsEv called 31507166 returned 100% blocks executed 100%
 31507166: 1882:unsigned AffineForOp::getNumIterOperands() {
 31507166: 1883:  AffineMap lbMap = getLowerBoundMapAttr().getValue();
call    0 returned 100%
call    1 returned 100%
 31507166: 1884:  AffineMap ubMap = getUpperBoundMapAttr().getValue();
call    0 returned 100%
call    1 returned 100%
        -: 1885:
 31507166: 1886:  return getNumOperands() - lbMap.getNumInputs() - ubMap.getNumInputs();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1887:}
        -: 1888:
function _ZN4mlir11AffineForOp5printERNS_12OpAsmPrinterE called 679220 returned 100% blocks executed 88%
   679220: 1889:void AffineForOp::print(OpAsmPrinter &p) {
   679220: 1890:  p << ' ';
call    0 returned 100%
   679220: 1891:  p.printRegionArgument(getBody()->getArgument(0), /*argAttrs=*/{},
call    0 returned 100%
   679220: 1892:                        /*omitType=*/true);
call    0 returned 100%
   679220: 1893:  p << " = ";
call    0 returned 100%
   679220: 1894:  printBound(getLowerBoundMapAttr(), getLowerBoundOperands(), "max", p);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   679220: 1895:  p << " to ";
call    0 returned 100%
   679220: 1896:  printBound(getUpperBoundMapAttr(), getUpperBoundOperands(), "min", p);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1897:
   679220: 1898:  if (getStep() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1899:    p << " step " << getStep();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1900:
   679220: 1901:  bool printBlockTerminators = false;
   679220: 1902:  if (getNumIterOperands() > 0) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
   337907: 1903:    p << " iter_args(";
call    0 returned 100%
   337907: 1904:    auto regionArgs = getRegionIterArgs();
call    0 returned 100%
   337907: 1905:    auto operands = getIterOperands();
call    0 returned 100%
        -: 1906:
function _ZZN4mlir11AffineForOp5printERNS_12OpAsmPrinterEENKUlT_E_clISt5tupleIJRNS_13BlockArgumentENS_5ValueEEEEEDaS3_.isra.0 called 337907 returned 100% blocks executed 100%
   675814: 1907:    llvm::interleaveComma(llvm::zip(regionArgs, operands), p, [&](auto it) {
call    0 returned 100%
   675814: 1908:      p << std::get<0>(it) << " = " << std::get<1>(it);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   337907: 1909:    });
  1013721: 1910:    p << ") -> (" << getResultTypes() << ")";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
   337907: 1911:    printBlockTerminators = true;
        -: 1912:  }
        -: 1913:
   679220: 1914:  p << ' ';
call    0 returned 100%
   679220: 1915:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
call    0 returned 100%
   679220: 1916:                printBlockTerminators);
call    0 returned 100%
   679220: 1917:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
   679220: 1918:                          /*elidedAttrs=*/{getLowerBoundAttrStrName(),
call    0 returned 100%
   679220: 1919:                                           getUpperBoundAttrStrName(),
call    0 returned 100%
   679220: 1920:                                           getStepAttrStrName()});
call    0 returned 100%
   679220: 1921:}
        -: 1922:
        -: 1923:/// Fold the constant bounds of a loop.
function _ZL14foldLoopBoundsN4mlir11AffineForOpE called 90870 returned 100% blocks executed 100%
    90870: 1924:static LogicalResult foldLoopBounds(AffineForOp forOp) {
function _ZZL14foldLoopBoundsN4mlir11AffineForOpEENKUlbE_clEb called 63 returned 100% blocks executed 41%
      63*: 1925:  auto foldLowerOrUpperBound = [&forOp](bool lower) {
call    0 returned 100%
call    1 returned 100%
        -: 1926:    // Check to see if each of the operands is the result of a constant.  If
        -: 1927:    // so, get the value.  If not, ignore it.
       63: 1928:    SmallVector<Attribute, 8> operandConstants;
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
       63: 1929:    auto boundOperands =
       63: 1930:        lower ? forOp.getLowerBoundOperands() : forOp.getUpperBoundOperands();
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
call    2 returned 100%
call    3 returned 100%
      138: 1931:    for (auto operand : boundOperands) {
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
call    2 returned 100%
       75: 1932:      Attribute operandCst;
       75: 1933:      matchPattern(operand, m_Constant(&operandCst));
call    0 returned 100%
       75: 1934:      operandConstants.push_back(operandCst);
call    0 returned 100%
        -: 1935:    }
        -: 1936:
       63: 1937:    AffineMap boundMap =
      126: 1938:        lower ? forOp.getLowerBoundMap() : forOp.getUpperBoundMap();
branch  0 taken 43%
branch  1 taken 57%
      63*: 1939:    assert(boundMap.getNumResults() >= 1 &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1940:           "bound maps should have at least one result");
      126: 1941:    SmallVector<Attribute, 4> foldedResults;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       63: 1942:    if (failed(boundMap.constantFold(operandConstants, foldedResults)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       63: 1943:      return failure();
        -: 1944:
        -: 1945:    // Compute the max or min as applicable over the results.
    #####: 1946:    assert(!foldedResults.empty() && "bounds should have at least one result");
branch  0 never executed
branch  1 never executed
call    2 never executed
      63*: 1947:    auto maxOrMin = foldedResults[0].cast<IntegerAttr>().getValue();
call    0 never executed
call    1 never executed
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1948:    for (unsigned i = 1, e = foldedResults.size(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1949:      auto foldedResult = foldedResults[i].cast<IntegerAttr>().getValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1950:      maxOrMin = lower ? llvm::APIntOps::smax(maxOrMin, foldedResult)
    #####: 1951:                       : llvm::APIntOps::smin(maxOrMin, foldedResult);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1952:    }
    #####: 1953:    lower ? forOp.setConstantLowerBound(maxOrMin.getSExtValue())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1954:          : forOp.setConstantUpperBound(maxOrMin.getSExtValue());
call    0 never executed
call    1 never executed
    #####: 1955:    return success();
branch  0 never executed
branch  1 never executed
    90870: 1956:  };
        -: 1957:
        -: 1958:  // Try to fold the lower bound.
    90870: 1959:  bool folded = false;
    90870: 1960:  if (!forOp.hasConstantLowerBound())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       27: 1961:    folded |= succeeded(foldLowerOrUpperBound(/*lower=*/true));
call    0 returned 100%
        -: 1962:
        -: 1963:  // Try to fold the upper bound.
    90870: 1964:  if (!forOp.hasConstantUpperBound())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       36: 1965:    folded |= succeeded(foldLowerOrUpperBound(/*lower=*/false));
call    0 returned 100%
    90870: 1966:  return success(folded);
        -: 1967:}
        -: 1968:
        -: 1969:/// Canonicalize the bounds of the given loop.
function _ZL22canonicalizeLoopBoundsN4mlir11AffineForOpE called 90870 returned 100% blocks executed 84%
    90870: 1970:static LogicalResult canonicalizeLoopBounds(AffineForOp forOp) {
    90870: 1971:  SmallVector<Value, 4> lbOperands(forOp.getLowerBoundOperands());
call    0 returned 100%
call    1 returned 100%
   181740: 1972:  SmallVector<Value, 4> ubOperands(forOp.getUpperBoundOperands());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1973:
    90870: 1974:  auto lbMap = forOp.getLowerBoundMap();
call    0 returned 100%
    90870: 1975:  auto ubMap = forOp.getUpperBoundMap();
call    0 returned 100%
    90870: 1976:  auto prevLbMap = lbMap;
    90870: 1977:  auto prevUbMap = ubMap;
        -: 1978:
    90870: 1979:  composeAffineMapAndOperands(&lbMap, &lbOperands);
call    0 returned 100%
    90870: 1980:  canonicalizeMapAndOperands(&lbMap, &lbOperands);
call    0 returned 100%
    90870: 1981:  lbMap = removeDuplicateExprs(lbMap);
call    0 returned 100%
        -: 1982:
    90870: 1983:  composeAffineMapAndOperands(&ubMap, &ubOperands);
call    0 returned 100%
    90870: 1984:  canonicalizeMapAndOperands(&ubMap, &ubOperands);
call    0 returned 100%
    90870: 1985:  ubMap = removeDuplicateExprs(ubMap);
call    0 returned 100%
        -: 1986:
        -: 1987:  // Any canonicalization change always leads to updated map(s).
    90870: 1988:  if (lbMap == prevLbMap && ubMap == prevUbMap)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
    90868: 1989:    return failure();
        -: 1990:
        2: 1991:  if (lbMap != prevLbMap)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1992:    forOp.setLowerBound(lbOperands, lbMap);
call    0 never executed
call    1 never executed
        2: 1993:  if (ubMap != prevUbMap)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1994:    forOp.setUpperBound(ubOperands, ubMap);
call    0 returned 100%
call    1 returned 100%
    90870: 1995:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1996:}
        -: 1997:
        -: 1998:namespace {
        -: 1999:/// Returns constant trip count in trivial cases.
function _ZN12_GLOBAL__N_1L27getTrivialConstantTripCountEN4mlir11AffineForOpE called 40924744 returned 100% blocks executed 100%
 40924744: 2000:static Optional<uint64_t> getTrivialConstantTripCount(AffineForOp forOp) {
 40924744: 2001:  int64_t step = forOp.getStep();
call    0 returned 100%
 40924744: 2002:  if (!forOp.hasConstantBounds() || step <= 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
     4024: 2003:    return None;
 40920720: 2004:  int64_t lb = forOp.getConstantLowerBound();
call    0 returned 100%
 40920720: 2005:  int64_t ub = forOp.getConstantUpperBound();
call    0 returned 100%
 40920720: 2006:  return ub - lb <= 0 ? 0 : (ub - lb + step - 1) / step;
branch  0 taken 100%
branch  1 taken 1%
        -: 2007:}
        -: 2008:
        -: 2009:/// This is a pattern to fold trivially empty loop bodies.
        -: 2010:/// TODO: This should be moved into the folding hook.
        -: 2011:struct AffineForEmptyLoopFolder : public OpRewritePattern<AffineForOp> {
        -: 2012:  using OpRewritePattern<AffineForOp>::OpRewritePattern;
        -: 2013:
function _ZNK12_GLOBAL__N_124AffineForEmptyLoopFolder15matchAndRewriteEN4mlir11AffineForOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2014:  LogicalResult matchAndRewrite(AffineForOp forOp,
        -: 2015:                                PatternRewriter &rewriter) const override {
        -: 2016:    // Check that the body only contains a yield.
    #####: 2017:    if (!llvm::hasSingleElement(*forOp.getBody()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2018:      return failure();
    #####: 2019:    if (forOp.getNumResults() == 0)
branch  0 never executed
branch  1 never executed
    #####: 2020:      return success();
    #####: 2021:    Optional<uint64_t> tripCount = getTrivialConstantTripCount(forOp);
call    0 never executed
    #####: 2022:    if (tripCount && *tripCount == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2023:      // The initial values of the iteration arguments would be the op's
        -: 2024:      // results.
    #####: 2025:      rewriter.replaceOp(forOp, forOp.getIterOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2026:      return success();
        -: 2027:    }
    #####: 2028:    SmallVector<Value, 4> replacements;
call    0 never executed
    #####: 2029:    auto yieldOp = cast<AffineYieldOp>(forOp.getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2030:    auto iterArgs = forOp.getRegionIterArgs();
call    0 never executed
    #####: 2031:    bool hasValDefinedOutsideLoop = false;
    #####: 2032:    bool iterArgsNotInOrder = false;
    #####: 2033:    for (unsigned i = 0, e = yieldOp->getNumOperands(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2034:      Value val = yieldOp.getOperand(i);
call    0 never executed
    #####: 2035:      auto *iterArgIt = llvm::find(iterArgs, val);
branch  0 never executed
branch  1 never executed
    #####: 2036:      if (iterArgIt == iterArgs.end()) {
branch  0 never executed
branch  1 never executed
        -: 2037:        // `val` is defined outside of the loop.
    #####: 2038:        assert(forOp.isDefinedOutsideOfLoop(val) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 2039:               "must be defined outside of the loop");
    #####: 2040:        hasValDefinedOutsideLoop = true;
    #####: 2041:        replacements.push_back(val);
call    0 never executed
        -: 2042:      } else {
    #####: 2043:        unsigned pos = std::distance(iterArgs.begin(), iterArgIt);
branch  0 never executed
branch  1 never executed
    #####: 2044:        if (pos != i)
branch  0 never executed
branch  1 never executed
    #####: 2045:          iterArgsNotInOrder = true;
    #####: 2046:        replacements.push_back(forOp.getIterOperands()[pos]);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2047:      }
        -: 2048:    }
        -: 2049:    // Bail out when the trip count is unknown and the loop returns any value
        -: 2050:    // defined outside of the loop or any iterArg out of order.
    #####: 2051:    if (!tripCount.has_value() &&
branch  0 never executed
branch  1 never executed
    #####: 2052:        (hasValDefinedOutsideLoop || iterArgsNotInOrder))
branch  0 never executed
branch  1 never executed
    #####: 2053:      return failure();
        -: 2054:    // Bail out when the loop iterates more than once and it returns any iterArg
        -: 2055:    // out of order.
    #####: 2056:    if (tripCount.has_value() && tripCount.value() >= 2 && iterArgsNotInOrder)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2057:      return failure();
    #####: 2058:    rewriter.replaceOp(forOp, replacements);
call    0 never executed
call    1 never executed
    #####: 2059:    return success();
branch  0 never executed
branch  1 never executed
        -: 2060:  }
        -: 2061:};
        -: 2062:} // namespace
        -: 2063:
function _ZN4mlir11AffineForOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1770 returned 100% blocks executed 100%
     1770: 2064:void AffineForOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2065:                                              MLIRContext *context) {
     1770: 2066:  results.add<AffineForEmptyLoopFolder>(context);
call    0 returned 100%
     1768: 2067:}
        -: 2068:
        -: 2069:/// Return operands used when entering the region at 'index'. These operands
        -: 2070:/// correspond to the loop iterator operands, i.e., those excluding the
        -: 2071:/// induction variable. AffineForOp only has one region, so zero is the only
        -: 2072:/// valid value for `index`.
function _ZN4mlir11AffineForOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 20419427 returned 100% blocks executed 80%
 20419427: 2073:OperandRange AffineForOp::getSuccessorEntryOperands(Optional<unsigned> index) {
20419427*: 2074:  assert((!index || *index == 0) && "invalid region index");
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 2075:
        -: 2076:  // The initial operands map to the loop arguments after the induction
        -: 2077:  // variable or are forwarded to the results when the trip count is zero.
 20419427: 2078:  return getIterOperands();
call    0 returned 100%
        -: 2079:}
        -: 2080:
        -: 2081:/// Given the region at `index`, or the parent operation if `index` is None,
        -: 2082:/// return the successor regions. These are the regions that may be selected
        -: 2083:/// during the flow of control. `operands` is a set of optional attributes that
        -: 2084:/// correspond to a constant value for each operand, or null if that operand is
        -: 2085:/// not a constant.
function _ZN4mlir11AffineForOp19getSuccessorRegionsEN4llvm8OptionalIjEENS1_8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_15RegionSuccessorEEE called 40833874 returned 100% blocks executed 97%
 40833874: 2086:void AffineForOp::getSuccessorRegions(
        -: 2087:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -: 2088:    SmallVectorImpl<RegionSuccessor> &regions) {
40833874*: 2089:  assert((!index.has_value() || index.value() == 0) && "expected loop region");
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 2090:  // The loop may typically branch back to its body or to the parent operation.
        -: 2091:  // If the predecessor is the parent op and the trip count is known to be at
        -: 2092:  // least one, branch into the body using the iterator arguments. And in cases
        -: 2093:  // we know the trip count is zero, it can only branch back to its parent.
 40833874: 2094:  Optional<uint64_t> tripCount = getTrivialConstantTripCount(*this);
call    0 returned 100%
 40833874: 2095:  if (!index.has_value() && tripCount.has_value()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
 20414768: 2096:    if (tripCount.value() > 0) {
branch  0 taken 100%
branch  1 taken 1%
 40643226: 2097:      regions.push_back(RegionSuccessor(&getLoopBody(), getRegionIterArgs()));
call    0 returned 100%
call    1 returned 100%
 20527842: 2098:      return;
        -: 2099:    }
    93155: 2100:    if (tripCount.value() == 0) {
call    0 returned 100%
    93155: 2101:      regions.push_back(RegionSuccessor(getResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    93155: 2102:      return;
        -: 2103:    }
        -: 2104:  }
        -: 2105:
        -: 2106:  // From the loop body, if the trip count is one, we can only branch back to
        -: 2107:  // the parent.
 20419106: 2108:  if (index && tripCount && *tripCount == 1) {
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
branch  4 taken 99% (fallthrough)
branch  5 taken 1%
   113074: 2109:    regions.push_back(RegionSuccessor(getResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   113074: 2110:    return;
        -: 2111:  }
        -: 2112:
        -: 2113:  // In all other cases, the loop may branch back to itself or the parent
        -: 2114:  // operation.
 40612064: 2115:  regions.push_back(RegionSuccessor(&getLoopBody(), getRegionIterArgs()));
call    0 returned 100%
call    1 returned 100%
 20306032: 2116:  regions.push_back(RegionSuccessor(getResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2117:}
        -: 2118:
        -: 2119:/// Returns true if the affine.for has zero iterations in trivial cases.
    90870: 2120:static bool hasTrivialZeroTripCount(AffineForOp op) {
   181740: 2121:  Optional<uint64_t> tripCount = getTrivialConstantTripCount(op);
    90870: 2122:  return tripCount && *tripCount == 0;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
        -: 2123:}
        -: 2124:
function _ZN4mlir11AffineForOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 90870 returned 100% blocks executed 100%
    90870: 2125:LogicalResult AffineForOp::fold(ArrayRef<Attribute> operands,
        -: 2126:                                SmallVectorImpl<OpFoldResult> &results) {
    90870: 2127:  bool folded = succeeded(foldLoopBounds(*this));
call    0 returned 100%
    90870: 2128:  folded |= succeeded(canonicalizeLoopBounds(*this));
call    0 returned 100%
   181246: 2129:  if (hasTrivialZeroTripCount(*this)) {
call    0 returned 100%
        -: 2130:    // The initial values of the loop-carried variables (iter_args) are the
        -: 2131:    // results of the op.
      494: 2132:    results.assign(getIterOperands().begin(), getIterOperands().end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      494: 2133:    folded = true;
        -: 2134:  }
    90870: 2135:  return success(folded);
        -: 2136:}
        -: 2137:
function _ZN4mlir11AffineForOp13getLowerBoundEv called 40 returned 100% blocks executed 100%
       40: 2138:AffineBound AffineForOp::getLowerBound() {
       40: 2139:  auto lbMap = getLowerBoundMap();
call    0 returned 100%
       40: 2140:  return AffineBound(AffineForOp(*this), 0, lbMap.getNumInputs(), lbMap);
call    0 returned 100%
        -: 2141:}
        -: 2142:
function _ZN4mlir11AffineForOp13getUpperBoundEv called 78 returned 100% blocks executed 100%
       78: 2143:AffineBound AffineForOp::getUpperBound() {
       78: 2144:  auto lbMap = getLowerBoundMap();
call    0 returned 100%
       78: 2145:  auto ubMap = getUpperBoundMap();
call    0 returned 100%
       78: 2146:  return AffineBound(AffineForOp(*this), lbMap.getNumInputs(),
       78: 2147:                     lbMap.getNumInputs() + ubMap.getNumInputs(), ubMap);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2148:}
        -: 2149:
function _ZN4mlir11AffineForOp13setLowerBoundENS_10ValueRangeENS_9AffineMapE called 740 returned 100% blocks executed 83%
      740: 2150:void AffineForOp::setLowerBound(ValueRange lbOperands, AffineMap map) {
     740*: 2151:  assert(lbOperands.size() == map.getNumInputs());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     740*: 2152:  assert(map.getNumResults() >= 1 && "bound map has at least one result");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 2153:
      740: 2154:  SmallVector<Value, 4> newOperands(lbOperands.begin(), lbOperands.end());
call    0 returned 100%
        -: 2155:
      740: 2156:  auto ubOperands = getUpperBoundOperands();
call    0 returned 100%
      740: 2157:  newOperands.append(ubOperands.begin(), ubOperands.end());
call    0 returned 100%
      740: 2158:  auto iterOperands = getIterOperands();
call    0 returned 100%
      740: 2159:  newOperands.append(iterOperands.begin(), iterOperands.end());
call    0 returned 100%
      740: 2160:  (*this)->setOperands(newOperands);
call    0 returned 100%
call    1 returned 100%
        -: 2161:
      740: 2162:  (*this)->setAttr(getLowerBoundAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      740: 2163:}
        -: 2164:
function _ZN4mlir11AffineForOp13setUpperBoundENS_10ValueRangeENS_9AffineMapE called 742 returned 100% blocks executed 83%
      742: 2165:void AffineForOp::setUpperBound(ValueRange ubOperands, AffineMap map) {
     742*: 2166:  assert(ubOperands.size() == map.getNumInputs());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     742*: 2167:  assert(map.getNumResults() >= 1 && "bound map has at least one result");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 2168:
      742: 2169:  SmallVector<Value, 4> newOperands(getLowerBoundOperands());
call    0 returned 100%
call    1 returned 100%
      742: 2170:  newOperands.append(ubOperands.begin(), ubOperands.end());
call    0 returned 100%
      742: 2171:  auto iterOperands = getIterOperands();
call    0 returned 100%
      742: 2172:  newOperands.append(iterOperands.begin(), iterOperands.end());
call    0 returned 100%
      742: 2173:  (*this)->setOperands(newOperands);
call    0 returned 100%
call    1 returned 100%
        -: 2174:
      742: 2175:  (*this)->setAttr(getUpperBoundAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      742: 2176:}
        -: 2177:
function _ZN4mlir11AffineForOp16setLowerBoundMapENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 2178:void AffineForOp::setLowerBoundMap(AffineMap map) {
    #####: 2179:  auto lbMap = getLowerBoundMap();
call    0 never executed
    #####: 2180:  assert(lbMap.getNumDims() == map.getNumDims() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2181:         lbMap.getNumSymbols() == map.getNumSymbols());
    #####: 2182:  assert(map.getNumResults() >= 1 && "bound map has at least one result");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2183:  (void)lbMap;
    #####: 2184:  (*this)->setAttr(getLowerBoundAttrStrName(), AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
    #####: 2185:}
        -: 2186:
function _ZN4mlir11AffineForOp16setUpperBoundMapENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 2187:void AffineForOp::setUpperBoundMap(AffineMap map) {
    #####: 2188:  auto ubMap = getUpperBoundMap();
call    0 never executed
    #####: 2189:  assert(ubMap.getNumDims() == map.getNumDims() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2190:         ubMap.getNumSymbols() == map.getNumSymbols());
    #####: 2191:  assert(map.getNumResults() >= 1 && "bound map has at least one result");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2192:  (void)ubMap;
    #####: 2193:  (*this)->setAttr(getUpperBoundAttrStrName(), AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
    #####: 2194:}
        -: 2195:
function _ZN4mlir11AffineForOp21hasConstantLowerBoundEv called 41026905 returned 100% blocks executed 100%
 41026905: 2196:bool AffineForOp::hasConstantLowerBound() {
 82053810: 2197:  return getLowerBoundMap().isSingleConstant();
call    0 returned 100%
call    1 returned 100%
        -: 2198:}
        -: 2199:
function _ZN4mlir11AffineForOp21hasConstantUpperBoundEv called 41020916 returned 100% blocks executed 100%
 41020916: 2200:bool AffineForOp::hasConstantUpperBound() {
 82041832: 2201:  return getUpperBoundMap().isSingleConstant();
call    0 returned 100%
call    1 returned 100%
        -: 2202:}
        -: 2203:
function _ZN4mlir11AffineForOp21getConstantLowerBoundEv called 40932002 returned 100% blocks executed 100%
 40932002: 2204:int64_t AffineForOp::getConstantLowerBound() {
 81864004: 2205:  return getLowerBoundMap().getSingleConstantResult();
call    0 returned 100%
call    1 returned 100%
        -: 2206:}
        -: 2207:
function _ZN4mlir11AffineForOp21getConstantUpperBoundEv called 40929859 returned 100% blocks executed 100%
 40929859: 2208:int64_t AffineForOp::getConstantUpperBound() {
 81859718: 2209:  return getUpperBoundMap().getSingleConstantResult();
call    0 returned 100%
call    1 returned 100%
        -: 2210:}
        -: 2211:
function _ZN4mlir11AffineForOp21setConstantLowerBoundEl called 0 returned 0% blocks executed 0%
    #####: 2212:void AffineForOp::setConstantLowerBound(int64_t value) {
    #####: 2213:  setLowerBound({}, AffineMap::getConstantMap(value, getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2214:}
        -: 2215:
function _ZN4mlir11AffineForOp21setConstantUpperBoundEl called 0 returned 0% blocks executed 0%
    #####: 2216:void AffineForOp::setConstantUpperBound(int64_t value) {
    #####: 2217:  setUpperBound({}, AffineMap::getConstantMap(value, getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2218:}
        -: 2219:
function _ZN4mlir11AffineForOp21getLowerBoundOperandsEv called 776269 returned 100% blocks executed 100%
   776269: 2220:AffineForOp::operand_range AffineForOp::getLowerBoundOperands() {
  1552538: 2221:  return {operand_begin(), operand_begin() + getLowerBoundMap().getNumInputs()};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2222:}
        -: 2223:
function _ZN4mlir11AffineForOp21getUpperBoundOperandsEv called 776325 returned 100% blocks executed 100%
   776325: 2224:AffineForOp::operand_range AffineForOp::getUpperBoundOperands() {
  2328975: 2225:  return {operand_begin() + getLowerBoundMap().getNumInputs(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   776325: 2226:          operand_begin() + getLowerBoundMap().getNumInputs() +
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
  2328975: 2227:              getUpperBoundMap().getNumInputs()};
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
        -: 2228:}
        -: 2229:
function _ZN4mlir11AffineForOp18getControlOperandsEv called 0 returned 0% blocks executed 0%
    #####: 2230:AffineForOp::operand_range AffineForOp::getControlOperands() {
    #####: 2231:  return {operand_begin(), operand_begin() + getLowerBoundMap().getNumInputs() +
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2232:                               getUpperBoundMap().getNumInputs()};
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2233:}
        -: 2234:
function _ZN4mlir11AffineForOp24matchingBoundOperandListEv called 0 returned 0% blocks executed 0%
    #####: 2235:bool AffineForOp::matchingBoundOperandList() {
    #####: 2236:  auto lbMap = getLowerBoundMap();
call    0 never executed
    #####: 2237:  auto ubMap = getUpperBoundMap();
call    0 never executed
    #####: 2238:  if (lbMap.getNumDims() != ubMap.getNumDims() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2239:      lbMap.getNumSymbols() != ubMap.getNumSymbols())
call    0 never executed
call    1 never executed
    #####: 2240:    return false;
        -: 2241:
    #####: 2242:  unsigned numOperands = lbMap.getNumInputs();
call    0 never executed
    #####: 2243:  for (unsigned i = 0, e = lbMap.getNumInputs(); i < e; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2244:    // Compare Value 's.
    #####: 2245:    if (getOperand(i) != getOperand(numOperands + i))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 2246:      return false;
        -: 2247:  }
        -: 2248:  return true;
        -: 2249:}
        -: 2250:
function _ZN4mlir11AffineForOp11getLoopBodyEv called 5 returned 100% blocks executed 100%
40629643*: 2251:Region &AffineForOp::getLoopBody() { return getRegion(); }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
        -: 2252:
function _ZN4mlir11AffineForOp21getSingleInductionVarEv called 0 returned 0% blocks executed 0%
    2125*: 2253:Optional<Value> AffineForOp::getSingleInductionVar() {
    2125*: 2254:  return getInductionVar();
call    0 returned 100%
call    1 never executed
        -: 2255:}
        -: 2256:
function _ZN4mlir11AffineForOp19getSingleLowerBoundEv called 2125 returned 100% blocks executed 89%
     2125: 2257:Optional<OpFoldResult> AffineForOp::getSingleLowerBound() {
     2125: 2258:  if (!hasConstantLowerBound())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2259:    return llvm::None;
     2125: 2260:  OpBuilder b(getContext());
call    0 returned 100%
call    1 returned 100%
     2125: 2261:  return OpFoldResult(b.getI64IntegerAttr(getConstantLowerBound()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2262:}
        -: 2263:
function _ZN4mlir11AffineForOp13getSingleStepEv called 2125 returned 100% blocks executed 100%
     2125: 2264:Optional<OpFoldResult> AffineForOp::getSingleStep() {
     2125: 2265:  OpBuilder b(getContext());
call    0 returned 100%
call    1 returned 100%
     2125: 2266:  return OpFoldResult(b.getI64IntegerAttr(getStep()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2267:}
        -: 2268:
function _ZN4mlir11AffineForOp19getSingleUpperBoundEv called 2125 returned 100% blocks executed 89%
     2125: 2269:Optional<OpFoldResult> AffineForOp::getSingleUpperBound() {
     2125: 2270:  if (!hasConstantUpperBound())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2271:    return llvm::None;
     2125: 2272:  OpBuilder b(getContext());
call    0 returned 100%
call    1 returned 100%
     2125: 2273:  return OpFoldResult(b.getI64IntegerAttr(getConstantUpperBound()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2274:}
        -: 2275:
function _ZN4mlir11AffineForOp18getSpeculatabilityEv called 0 returned 0% blocks executed 0%
      46*: 2276:Speculation::Speculatability AffineForOp::getSpeculatability() {
        -: 2277:  // `affine.for (I = Start; I < End; I += 1)` terminates for all values of
        -: 2278:  // Start and End.
        -: 2279:  //
        -: 2280:  // For Step != 1, the loop may not terminate.  We can add more smarts here if
        -: 2281:  // needed.
      46*: 2282:  return getStep() == 1 ? Speculation::RecursivelySpeculatable
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2283:                        : Speculation::NotSpeculatable;
        -: 2284:}
        -: 2285:
        -: 2286:/// Returns true if the provided value is the induction variable of a
        -: 2287:/// AffineForOp.
function _ZN4mlir17isForInductionVarENS_5ValueE called 134 returned 100% blocks executed 100%
      134: 2288:bool mlir::isForInductionVar(Value val) {
      134: 2289:  return getForInductionVarOwner(val) != AffineForOp();
call    0 returned 100%
        -: 2290:}
        -: 2291:
        -: 2292:/// Returns the loop parent of an induction variable. If the provided value is
        -: 2293:/// not an induction variable, then return nullptr.
function _ZN4mlir23getForInductionVarOwnerENS_5ValueE called 1808 returned 100% blocks executed 29%
     1808: 2294:AffineForOp mlir::getForInductionVarOwner(Value val) {
     1808: 2295:  auto ivArg = val.dyn_cast<BlockArgument>();
call    0 returned 100%
    1808*: 2296:  if (!ivArg || !ivArg.getOwner())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
     1808: 2297:    return AffineForOp();
    #####: 2298:  auto *containingInst = ivArg.getOwner()->getParent()->getParentOp();
call    0 never executed
call    1 never executed
    #####: 2299:  if (auto forOp = dyn_cast<AffineForOp>(containingInst))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2300:    // Check to make sure `val` is the induction variable, not an iter_arg.
    #####: 2301:    return forOp.getInductionVar() == val ? forOp : AffineForOp();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2302:  return AffineForOp();
        -: 2303:}
        -: 2304:
        -: 2305:/// Extracts the induction variables from a list of AffineForOps and returns
        -: 2306:/// them.
function _ZN4mlir23extractForInductionVarsEN4llvm8ArrayRefINS_11AffineForOpEEEPNS0_15SmallVectorImplINS_5ValueEEE called 15549 returned 100% blocks executed 78%
    15549: 2307:void mlir::extractForInductionVars(ArrayRef<AffineForOp> forInsts,
        -: 2308:                                   SmallVectorImpl<Value> *ivs) {
    15549: 2309:  ivs->reserve(forInsts.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15918: 2310:  for (auto forInst : forInsts)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      369: 2311:    ivs->push_back(forInst.getInductionVar());
call    0 returned 100%
call    1 returned 100%
    15549: 2312:}
        -: 2313:
        -: 2314:/// Builds an affine loop nest, using "loopCreatorFn" to create individual loop
        -: 2315:/// operations.
        -: 2316:template <typename BoundListTy, typename LoopCreatorTy>
       5*: 2317:static void buildAffineLoopNestImpl(
        -: 2318:    OpBuilder &builder, Location loc, BoundListTy lbs, BoundListTy ubs,
        -: 2319:    ArrayRef<int64_t> steps,
        -: 2320:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn,
        -: 2321:    LoopCreatorTy &&loopCreatorFn) {
       5*: 2322:  assert(lbs.size() == ubs.size() && "Mismatch in number of arguments");
       5*: 2323:  assert(lbs.size() == steps.size() && "Mismatch in number of arguments");
        -: 2324:
        -: 2325:  // If there are no loops to be constructed, construct the body anyway.
      10*: 2326:  OpBuilder::InsertionGuard guard(builder);
       5*: 2327:  if (lbs.empty()) {
    #####: 2328:    if (bodyBuilderFn)
    #####: 2329:      bodyBuilderFn(builder, loc, ValueRange());
    #####: 2330:    return;
        -: 2331:  }
        -: 2332:
        -: 2333:  // Create the loops iteratively and store the induction variables.
       5*: 2334:  SmallVector<Value, 4> ivs;
       5*: 2335:  ivs.reserve(lbs.size());
      17*: 2336:  for (unsigned i = 0, e = lbs.size(); i < e; ++i) {
        -: 2337:    // Callback for creating the loop body, always creates the terminator.
      24*: 2338:    auto loopBody = [&](OpBuilder &nestedBuilder, Location nestedLoc, Value iv,
        -: 2339:                        ValueRange iterArgs) {
      12*: 2340:      ivs.push_back(iv);
call    0 returned 100%
call    1 never executed
        -: 2341:      // In the innermost loop, call the body builder.
      12*: 2342:      if (i == e - 1 && bodyBuilderFn) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
      10*: 2343:        OpBuilder::InsertionGuard nestedGuard(nestedBuilder);
call    0 returned 100%
call    1 never executed
       5*: 2344:        bodyBuilderFn(nestedBuilder, nestedLoc, ivs);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2345:      }
      12*: 2346:      nestedBuilder.create<AffineYieldOp>(nestedLoc);
call    0 returned 100%
call    1 never executed
        -: 2347:    };
        -: 2348:
        -: 2349:    // Delegate actual loop creation to the callback in order to dispatch
        -: 2350:    // between constant- and variable-bound loops.
      12*: 2351:    auto loop = loopCreatorFn(builder, loc, lbs[i], ubs[i], steps[i], loopBody);
      12*: 2352:    builder.setInsertionPointToStart(loop.getBody());
        -: 2353:  }
        -: 2354:}
------------------
_Z23buildAffineLoopNestImplIN4mlir10ValueRangeERFNS0_11AffineForOpERNS0_9OpBuilderENS0_8LocationENS0_5ValueES6_lN4llvm12function_refIFvS4_S5_S6_S1_EEEEEvS4_S5_T_SD_NS7_8ArrayRefIlEENS8_IFvS4_S5_S1_EEEOT0_:
function _Z23buildAffineLoopNestImplIN4mlir10ValueRangeERFNS0_11AffineForOpERNS0_9OpBuilderENS0_8LocationENS0_5ValueES6_lN4llvm12function_refIFvS4_S5_S6_S1_EEEEEvS4_S5_T_SD_NS7_8ArrayRefIlEENS8_IFvS4_S5_S1_EEEOT0_ called 5 returned 100% blocks executed 53%
        5: 2317:static void buildAffineLoopNestImpl(
        -: 2318:    OpBuilder &builder, Location loc, BoundListTy lbs, BoundListTy ubs,
        -: 2319:    ArrayRef<int64_t> steps,
        -: 2320:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn,
        -: 2321:    LoopCreatorTy &&loopCreatorFn) {
       5*: 2322:  assert(lbs.size() == ubs.size() && "Mismatch in number of arguments");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       5*: 2323:  assert(lbs.size() == steps.size() && "Mismatch in number of arguments");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 2324:
        -: 2325:  // If there are no loops to be constructed, construct the body anyway.
       10: 2326:  OpBuilder::InsertionGuard guard(builder);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        5: 2327:  if (lbs.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2328:    if (bodyBuilderFn)
branch  0 never executed
branch  1 never executed
    #####: 2329:      bodyBuilderFn(builder, loc, ValueRange());
call    0 never executed
call    1 never executed
    #####: 2330:    return;
branch  0 never executed
branch  1 never executed
        -: 2331:  }
        -: 2332:
        -: 2333:  // Create the loops iteratively and store the induction variables.
        5: 2334:  SmallVector<Value, 4> ivs;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5: 2335:  ivs.reserve(lbs.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       17: 2336:  for (unsigned i = 0, e = lbs.size(); i < e; ++i) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
        -: 2337:    // Callback for creating the loop body, always creates the terminator.
       12: 2338:    auto loopBody = [&](OpBuilder &nestedBuilder, Location nestedLoc, Value iv,
        -: 2339:                        ValueRange iterArgs) {
        -: 2340:      ivs.push_back(iv);
        -: 2341:      // In the innermost loop, call the body builder.
        -: 2342:      if (i == e - 1 && bodyBuilderFn) {
        -: 2343:        OpBuilder::InsertionGuard nestedGuard(nestedBuilder);
        -: 2344:        bodyBuilderFn(nestedBuilder, nestedLoc, ivs);
        -: 2345:      }
        -: 2346:      nestedBuilder.create<AffineYieldOp>(nestedLoc);
        -: 2347:    };
        -: 2348:
        -: 2349:    // Delegate actual loop creation to the callback in order to dispatch
        -: 2350:    // between constant- and variable-bound loops.
       12: 2351:    auto loop = loopCreatorFn(builder, loc, lbs[i], ubs[i], steps[i], loopBody);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
       12: 2352:    builder.setInsertionPointToStart(loop.getBody());
call    0 returned 100%
        -: 2353:  }
        -: 2354:}
------------------
_Z23buildAffineLoopNestImplIN4llvm8ArrayRefIlEERFN4mlir11AffineForOpERNS3_9OpBuilderENS3_8LocationElllNS0_12function_refIFvS6_S7_NS3_5ValueENS3_10ValueRangeEEEEEEvS6_S7_T_SF_S2_NS8_IFvS6_S7_SA_EEEOT0_:
function _Z23buildAffineLoopNestImplIN4llvm8ArrayRefIlEERFN4mlir11AffineForOpERNS3_9OpBuilderENS3_8LocationElllNS0_12function_refIFvS6_S7_NS3_5ValueENS3_10ValueRangeEEEEEEvS6_S7_T_SF_S2_NS8_IFvS6_S7_SA_EEEOT0_ called 0 returned 0% blocks executed 0%
    #####: 2317:static void buildAffineLoopNestImpl(
        -: 2318:    OpBuilder &builder, Location loc, BoundListTy lbs, BoundListTy ubs,
        -: 2319:    ArrayRef<int64_t> steps,
        -: 2320:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn,
        -: 2321:    LoopCreatorTy &&loopCreatorFn) {
    #####: 2322:  assert(lbs.size() == ubs.size() && "Mismatch in number of arguments");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2323:  assert(lbs.size() == steps.size() && "Mismatch in number of arguments");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2324:
        -: 2325:  // If there are no loops to be constructed, construct the body anyway.
    #####: 2326:  OpBuilder::InsertionGuard guard(builder);
    #####: 2327:  if (lbs.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2328:    if (bodyBuilderFn)
branch  0 never executed
branch  1 never executed
    #####: 2329:      bodyBuilderFn(builder, loc, ValueRange());
call    0 never executed
call    1 never executed
    #####: 2330:    return;
branch  0 never executed
branch  1 never executed
        -: 2331:  }
        -: 2332:
        -: 2333:  // Create the loops iteratively and store the induction variables.
    #####: 2334:  SmallVector<Value, 4> ivs;
branch  0 never executed
branch  1 never executed
    #####: 2335:  ivs.reserve(lbs.size());
branch  0 never executed
branch  1 never executed
    #####: 2336:  for (unsigned i = 0, e = lbs.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -: 2337:    // Callback for creating the loop body, always creates the terminator.
    #####: 2338:    auto loopBody = [&](OpBuilder &nestedBuilder, Location nestedLoc, Value iv,
        -: 2339:                        ValueRange iterArgs) {
        -: 2340:      ivs.push_back(iv);
        -: 2341:      // In the innermost loop, call the body builder.
        -: 2342:      if (i == e - 1 && bodyBuilderFn) {
        -: 2343:        OpBuilder::InsertionGuard nestedGuard(nestedBuilder);
        -: 2344:        bodyBuilderFn(nestedBuilder, nestedLoc, ivs);
        -: 2345:      }
        -: 2346:      nestedBuilder.create<AffineYieldOp>(nestedLoc);
        -: 2347:    };
        -: 2348:
        -: 2349:    // Delegate actual loop creation to the callback in order to dispatch
        -: 2350:    // between constant- and variable-bound loops.
    #####: 2351:    auto loop = loopCreatorFn(builder, loc, lbs[i], ubs[i], steps[i], loopBody);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 2352:    builder.setInsertionPointToStart(loop.getBody());
call    0 never executed
        -: 2353:  }
        -: 2354:}
------------------
        -: 2355:
        -: 2356:/// Creates an affine loop from the bounds known to be constants.
        -: 2357:static AffineForOp
function _ZL28buildAffineLoopFromConstantsRN4mlir9OpBuilderENS_8LocationElllN4llvm12function_refIFvS1_S2_NS_5ValueENS_10ValueRangeEEEE called 0 returned 0% blocks executed 0%
      12*: 2358:buildAffineLoopFromConstants(OpBuilder &builder, Location loc, int64_t lb,
        -: 2359:                             int64_t ub, int64_t step,
        -: 2360:                             AffineForOp::BodyBuilderFn bodyBuilderFn) {
      12*: 2361:  return builder.create<AffineForOp>(loc, lb, ub, step, /*iterArgs=*/llvm::None,
    #####: 2362:                                     bodyBuilderFn);
call    0 never executed
        -: 2363:}
        -: 2364:
        -: 2365:/// Creates an affine loop from the bounds that may or may not be constants.
        -: 2366:static AffineForOp
function _ZL25buildAffineLoopFromValuesRN4mlir9OpBuilderENS_8LocationENS_5ValueES3_lN4llvm12function_refIFvS1_S2_S3_NS_10ValueRangeEEEE called 12 returned 100% blocks executed 69%
       12: 2367:buildAffineLoopFromValues(OpBuilder &builder, Location loc, Value lb, Value ub,
        -: 2368:                          int64_t step,
        -: 2369:                          AffineForOp::BodyBuilderFn bodyBuilderFn) {
       12: 2370:  auto lbConst = lb.getDefiningOp<arith::ConstantIndexOp>();
call    0 returned 100%
       12: 2371:  auto ubConst = ub.getDefiningOp<arith::ConstantIndexOp>();
call    0 returned 100%
       12: 2372:  if (lbConst && ubConst)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       12: 2373:    return buildAffineLoopFromConstants(builder, loc, lbConst.value(),
       12: 2374:                                        ubConst.value(), step, bodyBuilderFn);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    #####: 2375:  return builder.create<AffineForOp>(loc, lb, builder.getDimIdentityMap(), ub,
call    0 never executed
    #####: 2376:                                     builder.getDimIdentityMap(), step,
call    0 never executed
    #####: 2377:                                     /*iterArgs=*/llvm::None, bodyBuilderFn);
call    0 never executed
        -: 2378:}
        -: 2379:
function _ZN4mlir19buildAffineLoopNestERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefIlEES5_S5_NS3_12function_refIFvS1_S2_NS_10ValueRangeEEEE called 0 returned 0% blocks executed 0%
    #####: 2380:void mlir::buildAffineLoopNest(
        -: 2381:    OpBuilder &builder, Location loc, ArrayRef<int64_t> lbs,
        -: 2382:    ArrayRef<int64_t> ubs, ArrayRef<int64_t> steps,
        -: 2383:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn) {
    #####: 2384:  buildAffineLoopNestImpl(builder, loc, lbs, ubs, steps, bodyBuilderFn,
call    0 never executed
        -: 2385:                          buildAffineLoopFromConstants);
    #####: 2386:}
        -: 2387:
function _ZN4mlir19buildAffineLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES3_N4llvm8ArrayRefIlEENS4_12function_refIFvS1_S2_S3_EEE called 5 returned 100% blocks executed 100%
        5: 2388:void mlir::buildAffineLoopNest(
        -: 2389:    OpBuilder &builder, Location loc, ValueRange lbs, ValueRange ubs,
        -: 2390:    ArrayRef<int64_t> steps,
        -: 2391:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn) {
        5: 2392:  buildAffineLoopNestImpl(builder, loc, lbs, ubs, steps, bodyBuilderFn,
call    0 returned 100%
        -: 2393:                          buildAffineLoopFromValues);
        5: 2394:}
        -: 2395:
function _ZN4mlir25replaceForOpWithNewYieldsERNS_9OpBuilderENS_11AffineForOpENS_10ValueRangeES3_S3_b called 0 returned 0% blocks executed 0%
    #####: 2396:AffineForOp mlir::replaceForOpWithNewYields(OpBuilder &b, AffineForOp loop,
        -: 2397:                                            ValueRange newIterOperands,
        -: 2398:                                            ValueRange newYieldedValues,
        -: 2399:                                            ValueRange newIterArgs,
        -: 2400:                                            bool replaceLoopResults) {
    #####: 2401:  assert(newIterOperands.size() == newYieldedValues.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2402:         "newIterOperands must be of the same size as newYieldedValues");
        -: 2403:  // Create a new loop before the existing one, with the extra operands.
    #####: 2404:  OpBuilder::InsertionGuard g(b);
call    0 never executed
    #####: 2405:  b.setInsertionPoint(loop);
call    0 never executed
    #####: 2406:  auto operands = llvm::to_vector<4>(loop.getIterOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2407:  operands.append(newIterOperands.begin(), newIterOperands.end());
call    0 never executed
    #####: 2408:  SmallVector<Value, 4> lbOperands(loop.getLowerBoundOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2409:  SmallVector<Value, 4> ubOperands(loop.getUpperBoundOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2410:  SmallVector<Value, 4> steps(loop.getStep());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2411:  auto lbMap = loop.getLowerBoundMap();
call    0 never executed
    #####: 2412:  auto ubMap = loop.getUpperBoundMap();
call    0 never executed
    #####: 2413:  AffineForOp newLoop =
        -: 2414:      b.create<AffineForOp>(loop.getLoc(), lbOperands, lbMap, ubOperands, ubMap,
    #####: 2415:                            loop.getStep(), operands);
call    0 never executed
call    1 never executed
        -: 2416:  // Take the body of the original parent loop.
    #####: 2417:  newLoop.getLoopBody().takeBody(loop.getLoopBody());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2418:  for (Value val : newIterArgs)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2419:    newLoop.getLoopBody().addArgument(val.getType(), val.getLoc());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2420:
        -: 2421:  // Update yield operation with new values to be added.
    #####: 2422:  if (!newYieldedValues.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2423:    auto yield = cast<AffineYieldOp>(newLoop.getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2424:    b.setInsertionPoint(yield);
call    0 never executed
    #####: 2425:    auto yieldOperands = llvm::to_vector<4>(yield.getOperands());
call    0 never executed
call    1 never executed
    #####: 2426:    yieldOperands.append(newYieldedValues.begin(), newYieldedValues.end());
call    0 never executed
    #####: 2427:    b.create<AffineYieldOp>(yield.getLoc(), yieldOperands);
call    0 never executed
    #####: 2428:    yield.erase();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2429:  }
    #####: 2430:  if (replaceLoopResults) {
branch  0 never executed
branch  1 never executed
    #####: 2431:    for (auto it : llvm::zip(loop.getResults(), newLoop.getResults().take_front(
call    0 never executed
call    1 never executed
    #####: 2432:                                                    loop.getNumResults()))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2433:      std::get<0>(it).replaceAllUsesWith(std::get<1>(it));
call    0 never executed
        -: 2434:    }
        -: 2435:  }
    #####: 2436:  return newLoop;
branch  0 never executed
branch  1 never executed
        -: 2437:}
        -: 2438:
        -: 2439://===----------------------------------------------------------------------===//
        -: 2440:// AffineIfOp
        -: 2441://===----------------------------------------------------------------------===//
        -: 2442:
        -: 2443:namespace {
        -: 2444:/// Remove else blocks that have nothing other than a zero value yield.
        -: 2445:struct SimplifyDeadElse : public OpRewritePattern<AffineIfOp> {
        -: 2446:  using OpRewritePattern<AffineIfOp>::OpRewritePattern;
        -: 2447:
function _ZNK12_GLOBAL__N_116SimplifyDeadElse15matchAndRewriteEN4mlir10AffineIfOpERNS1_15PatternRewriterE called 8466 returned 100% blocks executed 62%
     8466: 2448:  LogicalResult matchAndRewrite(AffineIfOp ifOp,
        -: 2449:                                PatternRewriter &rewriter) const override {
     8466: 2450:    if (ifOp.getElseRegion().empty() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     9319: 2451:        !llvm::hasSingleElement(*ifOp.getElseBlock()) || ifOp.getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     8466: 2452:      return failure();
        -: 2453:
    #####: 2454:    rewriter.startRootUpdate(ifOp);
call    0 never executed
    #####: 2455:    rewriter.eraseBlock(ifOp.getElseBlock());
call    0 never executed
call    1 never executed
    #####: 2456:    rewriter.finalizeRootUpdate(ifOp);
call    0 never executed
    #####: 2457:    return success();
        -: 2458:  }
        -: 2459:};
        -: 2460:
        -: 2461:/// Removes affine.if cond if the condition is always true or false in certain
        -: 2462:/// trivial cases. Promotes the then/else block in the parent operation block.
        -: 2463:struct AlwaysTrueOrFalseIf : public OpRewritePattern<AffineIfOp> {
        -: 2464:  using OpRewritePattern<AffineIfOp>::OpRewritePattern;
        -: 2465:
function _ZNK12_GLOBAL__N_119AlwaysTrueOrFalseIf15matchAndRewriteEN4mlir10AffineIfOpERNS1_15PatternRewriterE called 8466 returned 100% blocks executed 82%
     8466: 2466:  LogicalResult matchAndRewrite(AffineIfOp op,
        -: 2467:                                PatternRewriter &rewriter) const override {
        -: 2468:
    16932: 2469:    auto isTriviallyFalse = [](IntegerSet iSet) {
     8466: 2470:      return iSet.isEmptyIntegerSet();
        -: 2471:    };
        -: 2472:
function _ZZNK12_GLOBAL__N_119AlwaysTrueOrFalseIf15matchAndRewriteEN4mlir10AffineIfOpERNS1_15PatternRewriterEENKUlNS1_10IntegerSetEE0_clES5_.isra.0 called 7972 returned 100% blocks executed 100%
     7972: 2473:    auto isTriviallyTrue = [](IntegerSet iSet) {
     8598: 2474:      return (iSet.getNumEqualities() == 1 && iSet.getNumInequalities() == 0 &&
call    0 returned 100%
branch  1 taken 34% (fallthrough)
branch  2 taken 66%
call    3 returned 100%
branch  4 taken 23% (fallthrough)
branch  5 taken 77%
branch  6 taken 79% (fallthrough)
branch  7 taken 21%
      626: 2475:              iSet.getConstraint(0) == 0);
call    0 returned 100%
call    1 returned 100%
        -: 2476:    };
        -: 2477:
     8466: 2478:    IntegerSet affineIfConditions = op.getIntegerSet();
call    0 returned 100%
     8466: 2479:    Block *blockToMove;
     8466: 2480:    if (isTriviallyFalse(affineIfConditions)) {
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        -: 2481:      // The absence, or equivalently, the emptiness of the else region need not
        -: 2482:      // be checked when affine.if is returning results because if an affine.if
        -: 2483:      // operation is returning results, it always has a non-empty else region.
     494*: 2484:      if (op.getNumResults() == 0 && !op.hasElse()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 2485:        // If the else region is absent, or equivalently, empty, remove the
        -: 2486:        // affine.if operation (which is not returning any results).
    #####: 2487:        rewriter.eraseOp(op);
call    0 never executed
    #####: 2488:        return success();
        -: 2489:      }
      494: 2490:      blockToMove = op.getElseBlock();
call    0 returned 100%
     7972: 2491:    } else if (isTriviallyTrue(affineIfConditions)) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
      131: 2492:      blockToMove = op.getThenBlock();
call    0 returned 100%
        -: 2493:    } else {
     7841: 2494:      return failure();
        -: 2495:    }
      625: 2496:    Operation *blockToMoveTerminator = blockToMove->getTerminator();
call    0 returned 100%
        -: 2497:    // Promote the "blockToMove" block to the parent operation block between the
        -: 2498:    // prologue and epilogue of "op".
      625: 2499:    rewriter.mergeBlockBefore(blockToMove, op);
call    0 returned 100%
call    1 returned 100%
        -: 2500:    // Replace the "op" operation with the operands of the
        -: 2501:    // "blockToMoveTerminator" operation. Note that "blockToMoveTerminator" is
        -: 2502:    // the affine.yield operation present in the "blockToMove" block. It has no
        -: 2503:    // operands when affine.if is not returning results and therefore, in that
        -: 2504:    // case, replaceOp just erases "op". When affine.if is not returning
        -: 2505:    // results, the affine.yield operation can be omitted. It gets inserted
        -: 2506:    // implicitly.
      625: 2507:    rewriter.replaceOp(op, blockToMoveTerminator->getOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2508:    // Erase the "blockToMoveTerminator" operation since it is now in the parent
        -: 2509:    // operation block, which already has its own terminator.
      625: 2510:    rewriter.eraseOp(blockToMoveTerminator);
call    0 returned 100%
      625: 2511:    return success();
        -: 2512:  }
        -: 2513:};
        -: 2514:} // namespace
        -: 2515:
function _ZN4mlir10AffineIfOp6verifyEv called 19538368 returned 100% blocks executed 52%
 19538368: 2516:LogicalResult AffineIfOp::verify() {
        -: 2517:  // Verify that we have a condition attribute.
        -: 2518:  // FIXME: This should be specified in the arguments list in ODS.
 19538368: 2519:  auto conditionAttr =
 19538368: 2520:      (*this)->getAttrOfType<IntegerSetAttr>(getConditionAttrStrName());
call    0 returned 100%
 19538368: 2521:  if (!conditionAttr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2522:    return emitOpError("requires an integer set attribute named 'condition'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2523:
        -: 2524:  // Verify that there are enough operands for the condition.
 19538368: 2525:  IntegerSet condition = conditionAttr.getValue();
call    0 returned 100%
 19538368: 2526:  if (getNumOperands() != condition.getNumInputs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2527:    return emitOpError("operand count and condition integer set dimension and "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2528:                       "symbol count must match");
call    0 never executed
        -: 2529:
        -: 2530:  // Verify that the operands are valid dimension/symbols.
 19538368: 2531:  if (failed(verifyDimAndSymbolIdentifiers(*this, getOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2532:                                           condition.getNumDims())))
    #####: 2533:    return failure();
        -: 2534:
 19538368: 2535:  return success();
        -: 2536:}
        -: 2537:
function _ZN4mlir10AffineIfOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 500435 returned 100% blocks executed 64%
   500435: 2538:ParseResult AffineIfOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 2539:  // Parse the condition attribute set.
   500435: 2540:  IntegerSetAttr conditionAttr;
   500435: 2541:  unsigned numDims;
   500435: 2542:  if (parser.parseAttribute(conditionAttr,
        -: 2543:                            AffineIfOp::getConditionAttrStrName(),
  1000870: 2544:                            result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  500435*: 2545:      parseDimAndSymbolList(parser, result.operands, numDims))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2546:    return failure();
        -: 2547:
        -: 2548:  // Verify the condition operands.
   500435: 2549:  auto set = conditionAttr.getValue();
call    0 returned 100%
   500435: 2550:  if (set.getNumDims() != numDims)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2551:    return parser.emitError(
call    0 never executed
call    1 never executed
    #####: 2552:        parser.getNameLoc(),
call    0 never executed
    #####: 2553:        "dim operand count and integer set dim count must match");
call    0 never executed
call    1 never executed
   500435: 2554:  if (numDims + set.getNumSymbols() != result.operands.size())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2555:    return parser.emitError(
call    0 never executed
call    1 never executed
    #####: 2556:        parser.getNameLoc(),
call    0 never executed
    #####: 2557:        "symbol operand count and integer set symbol count must match");
call    0 never executed
call    1 never executed
        -: 2558:
   500435: 2559:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2560:    return failure();
        -: 2561:
        -: 2562:  // Create the regions for 'then' and 'else'.  The latter must be created even
        -: 2563:  // if it remains empty for the validity of the operation.
   500435: 2564:  result.regions.reserve(2);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   500435: 2565:  Region *thenRegion = result.addRegion();
call    0 returned 100%
   500435: 2566:  Region *elseRegion = result.addRegion();
call    0 returned 100%
        -: 2567:
        -: 2568:  // Parse the 'then' region.
   500435: 2569:  if (parser.parseRegion(*thenRegion, {}, {}))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2570:    return failure();
   500435: 2571:  AffineIfOp::ensureTerminator(*thenRegion, parser.getBuilder(),
call    0 returned 100%
call    1 returned 100%
        -: 2572:                               result.location);
        -: 2573:
        -: 2574:  // If we find an 'else' keyword then parse the 'else' region.
   500435: 2575:  if (!parser.parseOptionalKeyword("else")) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   500435: 2576:    if (parser.parseRegion(*elseRegion, {}, {}))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2577:      return failure();
   500435: 2578:    AffineIfOp::ensureTerminator(*elseRegion, parser.getBuilder(),
call    0 returned 100%
call    1 returned 100%
        -: 2579:                                 result.location);
        -: 2580:  }
        -: 2581:
        -: 2582:  // Parse the optional attribute list.
   500435: 2583:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2584:    return failure();
        -: 2585:
   500435: 2586:  return success();
        -: 2587:}
        -: 2588:
function _ZN4mlir10AffineIfOp5printERNS_12OpAsmPrinterE called 766099 returned 100% blocks executed 100%
   766099: 2589:void AffineIfOp::print(OpAsmPrinter &p) {
   766099: 2590:  auto conditionAttr =
   766099: 2591:      (*this)->getAttrOfType<IntegerSetAttr>(getConditionAttrStrName());
call    0 returned 100%
  1532198: 2592:  p << " " << conditionAttr;
call    0 returned 100%
call    1 returned 100%
   766099: 2593:  printDimAndSymbolList(operand_begin(), operand_end(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   766099: 2594:                        conditionAttr.getValue().getNumDims(), p);
call    0 returned 100%
  1532198: 2595:  p.printOptionalArrowTypeList(getResultTypes());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   766099: 2596:  p << ' ';
call    0 returned 100%
   766099: 2597:  p.printRegion(getThenRegion(), /*printEntryBlockArgs=*/false,
call    0 returned 100%
   766099: 2598:                /*printBlockTerminators=*/getNumResults());
call    0 returned 100%
        -: 2599:
        -: 2600:  // Print the 'else' regions if it has any blocks.
   766099: 2601:  auto &elseRegion = this->getElseRegion();
call    0 returned 100%
   766099: 2602:  if (!elseRegion.empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   766099: 2603:    p << " else ";
call    0 returned 100%
   766099: 2604:    p.printRegion(elseRegion,
        -: 2605:                  /*printEntryBlockArgs=*/false,
   766099: 2606:                  /*printBlockTerminators=*/getNumResults());
call    0 returned 100%
        -: 2607:  }
        -: 2608:
        -: 2609:  // Print the attribute list.
   766099: 2610:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
   766099: 2611:                          /*elidedAttrs=*/getConditionAttrStrName());
call    0 returned 100%
   766099: 2612:}
        -: 2613:
function _ZN4mlir10AffineIfOp13getIntegerSetEv called 501302 returned 100% blocks executed 100%
   501302: 2614:IntegerSet AffineIfOp::getIntegerSet() {
   501302: 2615:  return (*this)
   501302: 2616:      ->getAttrOfType<IntegerSetAttr>(getConditionAttrStrName())
call    0 returned 100%
   501302: 2617:      .getValue();
call    0 returned 100%
        -: 2618:}
        -: 2619:
function _ZN4mlir10AffineIfOp13setIntegerSetENS_10IntegerSetE called 144301 returned 100% blocks executed 100%
   144301: 2620:void AffineIfOp::setIntegerSet(IntegerSet newSet) {
   144301: 2621:  (*this)->setAttr(getConditionAttrStrName(), IntegerSetAttr::get(newSet));
call    0 returned 100%
call    1 returned 100%
   144301: 2622:}
        -: 2623:
function _ZN4mlir10AffineIfOp14setConditionalENS_10IntegerSetENS_10ValueRangeE called 0 returned 0% blocks executed 0%
  144301*: 2624:void AffineIfOp::setConditional(IntegerSet set, ValueRange operands) {
    #####: 2625:  setIntegerSet(set);
call    0 never executed
  144301*: 2626:  (*this)->setOperands(operands);
call    0 returned 100%
call    1 never executed
    #####: 2627:}
        -: 2628:
function _ZN4mlir10AffineIfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_10IntegerSetENS_10ValueRangeEb called 0 returned 0% blocks executed 0%
    #####: 2629:void AffineIfOp::build(OpBuilder &builder, OperationState &result,
        -: 2630:                       TypeRange resultTypes, IntegerSet set, ValueRange args,
        -: 2631:                       bool withElseRegion) {
    #####: 2632:  assert(resultTypes.empty() || withElseRegion);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 2633:  result.addTypes(resultTypes);
call    0 never executed
    #####: 2634:  result.addOperands(args);
call    0 never executed
    #####: 2635:  result.addAttribute(getConditionAttrStrName(), IntegerSetAttr::get(set));
call    0 never executed
call    1 never executed
        -: 2636:
    #####: 2637:  Region *thenRegion = result.addRegion();
call    0 never executed
    #####: 2638:  thenRegion->push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2639:  if (resultTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 2640:    AffineIfOp::ensureTerminator(*thenRegion, builder, result.location);
call    0 never executed
        -: 2641:
    #####: 2642:  Region *elseRegion = result.addRegion();
call    0 never executed
    #####: 2643:  if (withElseRegion) {
branch  0 never executed
branch  1 never executed
    #####: 2644:    elseRegion->push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2645:    if (resultTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 2646:      AffineIfOp::ensureTerminator(*elseRegion, builder, result.location);
call    0 never executed
        -: 2647:  }
    #####: 2648:}
        -: 2649:
function _ZN4mlir10AffineIfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10IntegerSetENS_10ValueRangeEb called 0 returned 0% blocks executed 0%
    #####: 2650:void AffineIfOp::build(OpBuilder &builder, OperationState &result,
        -: 2651:                       IntegerSet set, ValueRange args, bool withElseRegion) {
    #####: 2652:  AffineIfOp::build(builder, result, /*resultTypes=*/{}, set, args,
call    0 never executed
call    1 never executed
        -: 2653:                    withElseRegion);
    #####: 2654:}
        -: 2655:
        -: 2656:/// Compose any affine.apply ops feeding into `operands` of the integer set
        -: 2657:/// `set` by composing the maps of such affine.apply ops with the integer
        -: 2658:/// set constraints.
function _ZL21composeSetAndOperandsRN4mlir10IntegerSetERN4llvm15SmallVectorImplINS_5ValueEEE called 244961 returned 100% blocks executed 56%
   244961: 2659:static void composeSetAndOperands(IntegerSet &set,
        -: 2660:                                  SmallVectorImpl<Value> &operands) {
        -: 2661:  // We will simply reuse the API of the map composition by viewing the LHSs of
        -: 2662:  // the equalities and inequalities of `set` as the affine exprs of an affine
        -: 2663:  // map. Convert to equivalent map, compose, and convert back to set.
   244961: 2664:  auto map = AffineMap::get(set.getNumDims(), set.getNumSymbols(),
   244961: 2665:                            set.getConstraints(), set.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 2666:  // Check if any composition is possible.
   244961: 2667:  if (llvm::none_of(operands,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2668:                    [](Value v) { return v.getDefiningOp<AffineApplyOp>(); }))
   244961: 2669:    return;
        -: 2670:
    #####: 2671:  composeAffineMapAndOperands(&map, &operands);
call    0 never executed
    #####: 2672:  set = IntegerSet::get(map.getNumDims(), map.getNumSymbols(), map.getResults(),
    #####: 2673:                        set.getEqFlags());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2674:}
        -: 2675:
        -: 2676:/// Canonicalize an affine if op's conditional (integer set + operands).
function _ZN4mlir10AffineIfOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 244961 returned 100% blocks executed 94%
   244961: 2677:LogicalResult AffineIfOp::fold(ArrayRef<Attribute>,
        -: 2678:                               SmallVectorImpl<OpFoldResult> &) {
   244961: 2679:  auto set = getIntegerSet();
call    0 returned 100%
   244961: 2680:  SmallVector<Value, 4> operands(getOperands());
call    0 returned 100%
call    1 returned 100%
   244961: 2681:  composeSetAndOperands(set, operands);
call    0 returned 100%
   244961: 2682:  canonicalizeSetAndOperands(&set, &operands);
call    0 returned 100%
        -: 2683:
        -: 2684:  // Check if the canonicalization or composition led to any change.
   345621: 2685:  if (getIntegerSet() == set && llvm::equal(operands, getOperands()))
call    0 returned 100%
branch  1 taken 41% (fallthrough)
branch  2 taken 59%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
   100660: 2686:    return failure();
        -: 2687:
   144301: 2688:  setConditional(set, operands);
call    0 returned 100%
call    1 returned 100%
   244961: 2689:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2690:}
        -: 2691:
function _ZN4mlir10AffineIfOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1741 returned 100% blocks executed 100%
     1741: 2692:void AffineIfOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2693:                                             MLIRContext *context) {
     1741: 2694:  results.add<SimplifyDeadElse, AlwaysTrueOrFalseIf>(context);
call    0 returned 100%
     1747: 2695:}
        -: 2696:
        -: 2697://===----------------------------------------------------------------------===//
        -: 2698:// AffineLoadOp
        -: 2699://===----------------------------------------------------------------------===//
        -: 2700:
function _ZN4mlir12AffineLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 2701:void AffineLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 2702:                         AffineMap map, ValueRange operands) {
    #####: 2703:  assert(operands.size() == 1 + map.getNumInputs() && "inconsistent operands");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2704:  result.addOperands(operands);
call    0 never executed
    #####: 2705:  if (map)
branch  0 never executed
branch  1 never executed
    #####: 2706:    result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
    #####: 2707:  auto memrefType = operands[0].getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 2708:  result.types.push_back(memrefType.getElementType());
call    0 never executed
call    1 never executed
    #####: 2709:}
        -: 2710:
function _ZN4mlir12AffineLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_9AffineMapENS_10ValueRangeE called 2184 returned 100% blocks executed 92%
     2184: 2711:void AffineLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 2712:                         Value memref, AffineMap map, ValueRange mapOperands) {
    2184*: 2713:  assert(map.getNumInputs() == mapOperands.size() && "inconsistent index info");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     2184: 2714:  result.addOperands(memref);
call    0 returned 100%
call    1 returned 100%
     2184: 2715:  result.addOperands(mapOperands);
call    0 returned 100%
     2184: 2716:  auto memrefType = memref.getType().cast<MemRefType>();
call    0 returned 100%
     2184: 2717:  result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
     2184: 2718:  result.types.push_back(memrefType.getElementType());
call    0 returned 100%
call    1 returned 100%
     2184: 2719:}
        -: 2720:
function _ZN4mlir12AffineLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeE called 10 returned 100% blocks executed 86%
       10: 2721:void AffineLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 2722:                         Value memref, ValueRange indices) {
       10: 2723:  auto memrefType = memref.getType().cast<MemRefType>();
call    0 returned 100%
       10: 2724:  int64_t rank = memrefType.getRank();
call    0 returned 100%
        -: 2725:  // Create identity map for memrefs with at least one dimension or () -> ()
        -: 2726:  // for zero-dimensional memrefs.
       10: 2727:  auto map =
      10*: 2728:      rank ? builder.getMultiDimIdentityMap(rank) : builder.getEmptyAffineMap();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
       10: 2729:  build(builder, result, memref, map, indices);
call    0 returned 100%
       10: 2730:}
        -: 2731:
function _ZN4mlir12AffineLoadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1005311 returned 100% blocks executed 100%
  1005311: 2732:ParseResult AffineLoadOp::parse(OpAsmParser &parser, OperationState &result) {
  1005311: 2733:  auto &builder = parser.getBuilder();
call    0 returned 100%
  1005311: 2734:  auto indexTy = builder.getIndexType();
call    0 returned 100%
        -: 2735:
  1005311: 2736:  MemRefType type;
  1005311: 2737:  OpAsmParser::UnresolvedOperand memrefInfo;
call    0 returned 100%
  1005311: 2738:  AffineMapAttr mapAttr;
  1005311: 2739:  SmallVector<OpAsmParser::UnresolvedOperand, 1> mapOperands;
call    0 returned 100%
  1005311: 2740:  return failure(
  2010622: 2741:      parser.parseOperand(memrefInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1005311: 2742:      parser.parseAffineMapOfSSAIds(mapOperands, mapAttr,
        -: 2743:                                    AffineLoadOp::getMapAttrStrName(),
  2010622: 2744:                                    result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2010622: 2745:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2010622: 2746:      parser.parseColonType(type) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2010622: 2747:      parser.resolveOperand(memrefInfo, type, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  3015933: 2748:      parser.resolveOperands(mapOperands, indexTy, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 66% (fallthrough)
branch  6 taken 34%
  1005311: 2749:      parser.addTypeToList(type.getElementType(), result.types));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 66% (fallthrough)
branch  3 taken 34%
        -: 2750:}
        -: 2751:
function _ZN4mlir12AffineLoadOp5printERNS_12OpAsmPrinterE called 1456074 returned 100% blocks executed 100%
  1456074: 2752:void AffineLoadOp::print(OpAsmPrinter &p) {
  2912148: 2753:  p << " " << getMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1456074: 2754:  if (AffineMapAttr mapAttr =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1456074: 2755:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1456074: 2756:    p.printAffineMapOfSSAIds(mapAttr, getMapOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1456074: 2757:  p << ']';
call    0 returned 100%
  1456074: 2758:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
  1456074: 2759:                          /*elidedAttrs=*/{getMapAttrStrName()});
call    0 returned 100%
  2912148: 2760:  p << " : " << getMemRefType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1456074: 2761:}
        -: 2762:
        -: 2763:/// Verify common indexing invariants of affine.load, affine.store,
        -: 2764:/// affine.vector_load and affine.vector_store.
        -: 2765:static LogicalResult
function _ZL22verifyMemoryOpIndexingPN4mlir9OperationENS_13AffineMapAttrENS_12OperandRangeENS_10MemRefTypeEj called 84234882 returned 100% blocks executed 50%
 84234882: 2766:verifyMemoryOpIndexing(Operation *op, AffineMapAttr mapAttr,
        -: 2767:                       Operation::operand_range mapOperands,
        -: 2768:                       MemRefType memrefType, unsigned numIndexOperands) {
 84234882: 2769:  if (mapAttr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 84234882: 2770:    AffineMap map = mapAttr.getValue();
call    0 returned 100%
 84234882: 2771:    if (map.getNumResults() != memrefType.getRank())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2772:      return op->emitOpError("affine map num results must equal memref rank");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 84234880: 2773:    if (map.getNumInputs() != numIndexOperands)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2774:      return op->emitOpError("expects as many subscripts as affine map inputs");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2775:  } else {
    #####: 2776:    if (memrefType.getRank() != numIndexOperands)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2777:      return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2778:          "expects the number of subscripts to be equal to memref rank");
call    0 never executed
        -: 2779:  }
        -: 2780:
 84234880: 2781:  Region *scope = getAffineScope(op);
call    0 returned 100%
246167262: 2782:  for (auto idx : mapOperands) {
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
call    2 returned 100%
161933447: 2783:    if (!idx.getType().isIndex())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2784:      return op->emitOpError("index to load must have 'index' type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
161933445: 2785:    if (!isValidAffineIndexOperand(idx, scope))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
     1062: 2786:      return op->emitOpError("index must be a dimension or symbol identifier");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2787:  }
        -: 2788:
 84233815: 2789:  return success();
        -: 2790:}
        -: 2791:
function _ZN4mlir12AffineLoadOp6verifyEv called 37460399 returned 100% blocks executed 69%
 37460399: 2792:LogicalResult AffineLoadOp::verify() {
 37460399: 2793:  auto memrefType = getMemRefType();
call    0 returned 100%
 37460400: 2794:  if (getType() != memrefType.getElementType())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2795:    return emitOpError("result type must match element type of memref");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2796:
 37460400: 2797:  if (failed(verifyMemoryOpIndexing(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        -: 2798:          getOperation(),
        -: 2799:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()),
        -: 2800:          getMapOperands(), memrefType,
 37460400: 2801:          /*numIndexOperands=*/getNumOperands() - 1)))
call    0 returned 100%
      100: 2802:    return failure();
        -: 2803:
 37460300: 2804:  return success();
        -: 2805:}
        -: 2806:
function _ZN4mlir12AffineLoadOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3283 returned 100% blocks executed 100%
     3283: 2807:void AffineLoadOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2808:                                               MLIRContext *context) {
     3283: 2809:  results.add<SimplifyAffineOp<AffineLoadOp>>(context);
call    0 returned 100%
     3299: 2810:}
        -: 2811:
function _ZN4mlir12AffineLoadOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 256649 returned 100% blocks executed 15%
   256649: 2812:OpFoldResult AffineLoadOp::fold(ArrayRef<Attribute> cstOperands) {
        -: 2813:  /// load(memrefcast) -> load
   256649: 2814:  if (succeeded(memref::foldMemRefCast(*this)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2815:    return getResult();
call    0 never executed
call    1 never executed
        -: 2816:
        -: 2817:  // Fold load from a global constant memref.
   256649: 2818:  auto getGlobalOp = getMemref().getDefiningOp<memref::GetGlobalOp>();
call    0 returned 100%
call    1 returned 100%
   256649: 2819:  if (!getGlobalOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   256649: 2820:    return {};
        -: 2821:  // Get to the memref.global defining the symbol.
    #####: 2822:  auto *symbolTableOp = getGlobalOp->getParentWithTrait<OpTrait::SymbolTable>();
call    0 never executed
    #####: 2823:  if (!symbolTableOp)
branch  0 never executed
branch  1 never executed
    #####: 2824:    return {};
    #####: 2825:  auto global = dyn_cast_or_null<memref::GlobalOp>(
    #####: 2826:      SymbolTable::lookupSymbolIn(symbolTableOp, getGlobalOp.getNameAttr()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2827:  if (!global)
branch  0 never executed
branch  1 never executed
    #####: 2828:    return {};
        -: 2829:
        -: 2830:  // Check if the global memref is a constant.
    #####: 2831:  auto cstAttr =
    #####: 2832:      global.getConstantInitValue().dyn_cast_or_null<DenseElementsAttr>();
call    0 never executed
call    1 never executed
    #####: 2833:  if (!cstAttr)
branch  0 never executed
branch  1 never executed
    #####: 2834:    return {};
        -: 2835:  // If it's a splat constant, we can fold irrespective of indices.
    #####: 2836:  if (auto splatAttr = cstAttr.dyn_cast<SplatElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2837:    return splatAttr.getSplatValue<Attribute>();
call    0 never executed
call    1 never executed
        -: 2838:  // Otherwise, we can fold only if we know the indices.
    #####: 2839:  if (!getAffineMap().isConstant())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2840:    return {};
    #####: 2841:  auto indices = llvm::to_vector<4>(
    #####: 2842:      llvm::map_range(getAffineMap().getConstantResults(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2843:                      [](int64_t v) -> uint64_t { return v; }));
call    0 never executed
    #####: 2844:  return cstAttr.getValues<Attribute>()[indices];
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2845:}
        -: 2846:
        -: 2847://===----------------------------------------------------------------------===//
        -: 2848:// AffineStoreOp
        -: 2849://===----------------------------------------------------------------------===//
        -: 2850:
function _ZN4mlir13AffineStoreOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES5_NS_9AffineMapENS_10ValueRangeE called 4648 returned 100% blocks executed 91%
     4648: 2851:void AffineStoreOp::build(OpBuilder &builder, OperationState &result,
        -: 2852:                          Value valueToStore, Value memref, AffineMap map,
        -: 2853:                          ValueRange mapOperands) {
    4648*: 2854:  assert(map.getNumInputs() == mapOperands.size() && "inconsistent index info");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     4648: 2855:  result.addOperands(valueToStore);
call    0 returned 100%
call    1 returned 100%
     4648: 2856:  result.addOperands(memref);
call    0 returned 100%
call    1 returned 100%
     4648: 2857:  result.addOperands(mapOperands);
call    0 returned 100%
     4648: 2858:  result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
     4648: 2859:}
        -: 2860:
        -: 2861:// Use identity map.
function _ZN4mlir13AffineStoreOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES5_NS_10ValueRangeE called 5 returned 100% blocks executed 86%
        5: 2862:void AffineStoreOp::build(OpBuilder &builder, OperationState &result,
        -: 2863:                          Value valueToStore, Value memref,
        -: 2864:                          ValueRange indices) {
        5: 2865:  auto memrefType = memref.getType().cast<MemRefType>();
call    0 returned 100%
        5: 2866:  int64_t rank = memrefType.getRank();
call    0 returned 100%
        -: 2867:  // Create identity map for memrefs with at least one dimension or () -> ()
        -: 2868:  // for zero-dimensional memrefs.
        5: 2869:  auto map =
       5*: 2870:      rank ? builder.getMultiDimIdentityMap(rank) : builder.getEmptyAffineMap();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        5: 2871:  build(builder, result, valueToStore, memref, map, indices);
call    0 returned 100%
        5: 2872:}
        -: 2873:
function _ZN4mlir13AffineStoreOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 863631 returned 100% blocks executed 96%
   863631: 2874:ParseResult AffineStoreOp::parse(OpAsmParser &parser, OperationState &result) {
   863631: 2875:  auto indexTy = parser.getBuilder().getIndexType();
call    0 returned 100%
call    1 returned 100%
        -: 2876:
   863631: 2877:  MemRefType type;
   863631: 2878:  OpAsmParser::UnresolvedOperand storeValueInfo;
call    0 returned 100%
   863631: 2879:  OpAsmParser::UnresolvedOperand memrefInfo;
   863631: 2880:  AffineMapAttr mapAttr;
   863631: 2881:  SmallVector<OpAsmParser::UnresolvedOperand, 1> mapOperands;
call    0 returned 100%
  1727262: 2882:  return failure(parser.parseOperand(storeValueInfo) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
  1727262: 2883:                 parser.parseOperand(memrefInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   863631: 2884:                 parser.parseAffineMapOfSSAIds(
        -: 2885:                     mapOperands, mapAttr, AffineStoreOp::getMapAttrStrName(),
  1727262: 2886:                     result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1727262: 2887:                 parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1727262: 2888:                 parser.parseColonType(type) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   863631: 2889:                 parser.resolveOperand(storeValueInfo, type.getElementType(),
  1727262: 2890:                                       result.operands) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
  2590893: 2891:                 parser.resolveOperand(memrefInfo, type, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 68% (fallthrough)
branch  8 taken 32%
   863631: 2892:                 parser.resolveOperands(mapOperands, indexTy, result.operands));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 68% (fallthrough)
branch  4 taken 32%
        -: 2893:}
        -: 2894:
function _ZN4mlir13AffineStoreOp5printERNS_12OpAsmPrinterE called 1405625 returned 100% blocks executed 100%
  1405625: 2895:void AffineStoreOp::print(OpAsmPrinter &p) {
  2811250: 2896:  p << " " << getValueToStore();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  2811250: 2897:  p << ", " << getMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1405625: 2898:  if (AffineMapAttr mapAttr =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1405625: 2899:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1405625: 2900:    p.printAffineMapOfSSAIds(mapAttr, getMapOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1405625: 2901:  p << ']';
call    0 returned 100%
  1405625: 2902:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
  1405625: 2903:                          /*elidedAttrs=*/{getMapAttrStrName()});
call    0 returned 100%
  2811250: 2904:  p << " : " << getMemRefType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  1405625: 2905:}
        -: 2906:
function _ZN4mlir13AffineStoreOp6verifyEv called 33033774 returned 100% blocks executed 71%
 33033774: 2907:LogicalResult AffineStoreOp::verify() {
        -: 2908:  // The value to store must have the same type as memref element type.
 33033774: 2909:  auto memrefType = getMemRefType();
call    0 returned 100%
 33033774: 2910:  if (getValueToStore().getType() != memrefType.getElementType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2911:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2912:        "value to store must have the same type as memref element type");
call    0 never executed
        -: 2913:
 33033773: 2914:  if (failed(verifyMemoryOpIndexing(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        -: 2915:          getOperation(),
        -: 2916:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()),
        -: 2917:          getMapOperands(), memrefType,
 33033773: 2918:          /*numIndexOperands=*/getNumOperands() - 2)))
call    0 returned 100%
      207: 2919:    return failure();
        -: 2920:
 33033564: 2921:  return success();
        -: 2922:}
        -: 2923:
function _ZN4mlir13AffineStoreOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3298 returned 100% blocks executed 100%
     3298: 2924:void AffineStoreOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2925:                                                MLIRContext *context) {
     3298: 2926:  results.add<SimplifyAffineOp<AffineStoreOp>>(context);
call    0 returned 100%
     3303: 2927:}
        -: 2928:
function _ZN4mlir13AffineStoreOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 2929:LogicalResult AffineStoreOp::fold(ArrayRef<Attribute> cstOperands,
        -: 2930:                                  SmallVectorImpl<OpFoldResult> &results) {
        -: 2931:  /// store(memrefcast) -> store
    #####: 2932:  return memref::foldMemRefCast(*this, getValueToStore());
call    0 never executed
call    1 never executed
        -: 2933:}
        -: 2934:
        -: 2935://===----------------------------------------------------------------------===//
        -: 2936:// AffineMinMaxOpBase
        -: 2937://===----------------------------------------------------------------------===//
        -: 2938:
        -: 2939:template <typename T>
 95087847: 2940:static LogicalResult verifyAffineMinMaxOp(T op) {
        -: 2941:  // Verify that operand count matches affine map dimension and symbol count.
 95087847: 2942:  if (op.getNumOperands() !=
190175695: 2943:      op.getMap().getNumDims() + op.getMap().getNumSymbols())
        -: 2944:    return op.emitOpError(
    #####: 2945:        "operand count and affine map dimension and symbol count must match");
 95087847: 2946:  return success();
        -: 2947:}
------------------
_Z20verifyAffineMinMaxOpIN4mlir11AffineMaxOpEENS0_13LogicalResultET_:
function _Z20verifyAffineMinMaxOpIN4mlir11AffineMaxOpEENS0_13LogicalResultET_ called 48002360 returned 100% blocks executed 67%
 48002360: 2940:static LogicalResult verifyAffineMinMaxOp(T op) {
        -: 2941:  // Verify that operand count matches affine map dimension and symbol count.
 48002360: 2942:  if (op.getNumOperands() !=
call    0 returned 100%
call    1 returned 100%
 96004720: 2943:      op.getMap().getNumDims() + op.getMap().getNumSymbols())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2944:    return op.emitOpError(
    #####: 2945:        "operand count and affine map dimension and symbol count must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 48002360: 2946:  return success();
        -: 2947:}
------------------
_Z20verifyAffineMinMaxOpIN4mlir11AffineMinOpEENS0_13LogicalResultET_:
function _Z20verifyAffineMinMaxOpIN4mlir11AffineMinOpEENS0_13LogicalResultET_ called 47085487 returned 100% blocks executed 67%
 47085487: 2940:static LogicalResult verifyAffineMinMaxOp(T op) {
        -: 2941:  // Verify that operand count matches affine map dimension and symbol count.
 47085487: 2942:  if (op.getNumOperands() !=
call    0 returned 100%
call    1 returned 100%
 94170975: 2943:      op.getMap().getNumDims() + op.getMap().getNumSymbols())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2944:    return op.emitOpError(
    #####: 2945:        "operand count and affine map dimension and symbol count must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 47085487: 2946:  return success();
        -: 2947:}
------------------
        -: 2948:
        -: 2949:template <typename T>
  3122339: 2950:static void printAffineMinMaxOp(OpAsmPrinter &p, T op) {
  3122339: 2951:  p << ' ' << op->getAttr(T::getMapAttrStrName());
  3122339: 2952:  auto operands = op.getOperands();
  3122339: 2953:  unsigned numDims = op.getMap().getNumDims();
  3122339: 2954:  p << '(' << operands.take_front(numDims) << ')';
        -: 2955:
  3122339: 2956:  if (operands.size() != numDims)
       88: 2957:    p << '[' << operands.drop_front(numDims) << ']';
  3122339: 2958:  p.printOptionalAttrDict(op->getAttrs(),
  3122339: 2959:                          /*elidedAttrs=*/{T::getMapAttrStrName()});
  3122339: 2960:}
------------------
_Z19printAffineMinMaxOpIN4mlir11AffineMaxOpEEvRNS0_12OpAsmPrinterET_:
function _Z19printAffineMinMaxOpIN4mlir11AffineMaxOpEEvRNS0_12OpAsmPrinterET_ called 1571193 returned 100% blocks executed 100%
  1571193: 2950:static void printAffineMinMaxOp(OpAsmPrinter &p, T op) {
  1571193: 2951:  p << ' ' << op->getAttr(T::getMapAttrStrName());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1571193: 2952:  auto operands = op.getOperands();
call    0 returned 100%
  1571193: 2953:  unsigned numDims = op.getMap().getNumDims();
call    0 returned 100%
  1571193: 2954:  p << '(' << operands.take_front(numDims) << ')';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2955:
  1571193: 2956:  if (operands.size() != numDims)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       14: 2957:    p << '[' << operands.drop_front(numDims) << ']';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1571193: 2958:  p.printOptionalAttrDict(op->getAttrs(),
call    0 returned 100%
call    1 returned 100%
  1571193: 2959:                          /*elidedAttrs=*/{T::getMapAttrStrName()});
call    0 returned 100%
  1571193: 2960:}
------------------
_Z19printAffineMinMaxOpIN4mlir11AffineMinOpEEvRNS0_12OpAsmPrinterET_:
function _Z19printAffineMinMaxOpIN4mlir11AffineMinOpEEvRNS0_12OpAsmPrinterET_ called 1551146 returned 100% blocks executed 100%
  1551146: 2950:static void printAffineMinMaxOp(OpAsmPrinter &p, T op) {
  1551146: 2951:  p << ' ' << op->getAttr(T::getMapAttrStrName());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1551146: 2952:  auto operands = op.getOperands();
call    0 returned 100%
  1551146: 2953:  unsigned numDims = op.getMap().getNumDims();
call    0 returned 100%
  1551146: 2954:  p << '(' << operands.take_front(numDims) << ')';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2955:
  1551146: 2956:  if (operands.size() != numDims)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       74: 2957:    p << '[' << operands.drop_front(numDims) << ']';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
  1551146: 2958:  p.printOptionalAttrDict(op->getAttrs(),
call    0 returned 100%
call    1 returned 100%
  1551146: 2959:                          /*elidedAttrs=*/{T::getMapAttrStrName()});
call    0 returned 100%
  1551146: 2960:}
------------------
        -: 2961:
        -: 2962:template <typename T>
  2475281: 2963:static ParseResult parseAffineMinMaxOp(OpAsmParser &parser,
        -: 2964:                                       OperationState &result) {
  2475281: 2965:  auto &builder = parser.getBuilder();
  2475281: 2966:  auto indexType = builder.getIndexType();
  4950562: 2967:  SmallVector<OpAsmParser::UnresolvedOperand, 8> dimInfos;
  2475281: 2968:  SmallVector<OpAsmParser::UnresolvedOperand, 8> symInfos;
  2475281: 2969:  AffineMapAttr mapAttr;
        -: 2970:  return failure(
        -: 2971:      parser.parseAttribute(mapAttr, T::getMapAttrStrName(),
  4950562: 2972:                            result.attributes) ||
  4950562: 2973:      parser.parseOperandList(dimInfos, OpAsmParser::Delimiter::Paren) ||
  2475281: 2974:      parser.parseOperandList(symInfos,
  2475281: 2975:                              OpAsmParser::Delimiter::OptionalSquare) ||
  4950562: 2976:      parser.parseOptionalAttrDict(result.attributes) ||
  4950562: 2977:      parser.resolveOperands(dimInfos, indexType, result.operands) ||
  7425843: 2978:      parser.resolveOperands(symInfos, indexType, result.operands) ||
  2475281: 2979:      parser.addTypeToList(indexType, result.types));
        -: 2980:}
------------------
_Z19parseAffineMinMaxOpIN4mlir11AffineMaxOpEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE:
function _Z19parseAffineMinMaxOpIN4mlir11AffineMaxOpEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE called 1251084 returned 100% blocks executed 90%
  1251084: 2963:static ParseResult parseAffineMinMaxOp(OpAsmParser &parser,
        -: 2964:                                       OperationState &result) {
  1251084: 2965:  auto &builder = parser.getBuilder();
call    0 returned 100%
  1251084: 2966:  auto indexType = builder.getIndexType();
call    0 returned 100%
call    1 returned 100%
  2502168: 2967:  SmallVector<OpAsmParser::UnresolvedOperand, 8> dimInfos;
  1251084: 2968:  SmallVector<OpAsmParser::UnresolvedOperand, 8> symInfos;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1251084: 2969:  AffineMapAttr mapAttr;
        -: 2970:  return failure(
        -: 2971:      parser.parseAttribute(mapAttr, T::getMapAttrStrName(),
  2502168: 2972:                            result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2502168: 2973:      parser.parseOperandList(dimInfos, OpAsmParser::Delimiter::Paren) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1251084: 2974:      parser.parseOperandList(symInfos,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1251084: 2975:                              OpAsmParser::Delimiter::OptionalSquare) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2502168: 2976:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2502168: 2977:      parser.resolveOperands(dimInfos, indexType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  3753252: 2978:      parser.resolveOperands(symInfos, indexType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
  1251084: 2979:      parser.addTypeToList(indexType, result.types));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2980:}
------------------
_Z19parseAffineMinMaxOpIN4mlir11AffineMinOpEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE:
function _Z19parseAffineMinMaxOpIN4mlir11AffineMinOpEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateE called 1224197 returned 100% blocks executed 90%
  1224197: 2963:static ParseResult parseAffineMinMaxOp(OpAsmParser &parser,
        -: 2964:                                       OperationState &result) {
  1224197: 2965:  auto &builder = parser.getBuilder();
call    0 returned 100%
  1224197: 2966:  auto indexType = builder.getIndexType();
call    0 returned 100%
call    1 returned 100%
  2448394: 2967:  SmallVector<OpAsmParser::UnresolvedOperand, 8> dimInfos;
  1224197: 2968:  SmallVector<OpAsmParser::UnresolvedOperand, 8> symInfos;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1224197: 2969:  AffineMapAttr mapAttr;
        -: 2970:  return failure(
        -: 2971:      parser.parseAttribute(mapAttr, T::getMapAttrStrName(),
  2448394: 2972:                            result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2448394: 2973:      parser.parseOperandList(dimInfos, OpAsmParser::Delimiter::Paren) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1224197: 2974:      parser.parseOperandList(symInfos,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  1224197: 2975:                              OpAsmParser::Delimiter::OptionalSquare) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2448394: 2976:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  2448394: 2977:      parser.resolveOperands(dimInfos, indexType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  3672591: 2978:      parser.resolveOperands(symInfos, indexType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
  1224197: 2979:      parser.addTypeToList(indexType, result.types));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2980:}
------------------
        -: 2981:
        -: 2982:/// Fold an affine min or max operation with the given operands. The operand
        -: 2983:/// list may contain nulls, which are interpreted as the operand not being a
        -: 2984:/// constant.
        -: 2985:template <typename T>
   501579: 2986:static OpFoldResult foldMinMaxOp(T op, ArrayRef<Attribute> operands) {
        -: 2987:  static_assert(llvm::is_one_of<T, AffineMinOp, AffineMaxOp>::value,
        -: 2988:                "expected affine min or max op");
        -: 2989:
        -: 2990:  // Fold the affine map.
        -: 2991:  // TODO: Fold more cases:
        -: 2992:  // min(some_affine, some_affine + constant, ...), etc.
   501579: 2993:  SmallVector<int64_t, 2> results;
   501579: 2994:  auto foldedMap = op.getMap().partialConstantFold(operands, &results);
        -: 2995:
        -: 2996:  // If some of the map results are not constant, try changing the map in-place.
   501579: 2997:  if (results.empty()) {
        -: 2998:    // If the map is the same, report that folding did not happen.
   265372: 2999:    if (foldedMap == op.getMap())
   191677: 3000:      return {};
    73695: 3001:    op->setAttr("map", AffineMapAttr::get(foldedMap));
    73695: 3002:    return op.getResult();
        -: 3003:  }
        -: 3004:
        -: 3005:  // Otherwise, completely fold the op into a constant.
        -: 3006:  auto resultIt = std::is_same<T, AffineMinOp>::value
   472414: 3007:                      ? std::min_element(results.begin(), results.end())
        -: 3008:                      : std::max_element(results.begin(), results.end());
   236207: 3009:  if (resultIt == results.end())
    #####: 3010:    return {};
   236207: 3011:  return IntegerAttr::get(IndexType::get(op.getContext()), *resultIt);
        -: 3012:}
------------------
_Z12foldMinMaxOpIN4mlir11AffineMaxOpEENS0_12OpFoldResultET_N4llvm8ArrayRefINS0_9AttributeEEE:
function _Z12foldMinMaxOpIN4mlir11AffineMaxOpEENS0_12OpFoldResultET_N4llvm8ArrayRefINS0_9AttributeEEE called 254064 returned 100% blocks executed 96%
   254064: 2986:static OpFoldResult foldMinMaxOp(T op, ArrayRef<Attribute> operands) {
call    0 returned 100%
        -: 2987:  static_assert(llvm::is_one_of<T, AffineMinOp, AffineMaxOp>::value,
        -: 2988:                "expected affine min or max op");
        -: 2989:
        -: 2990:  // Fold the affine map.
        -: 2991:  // TODO: Fold more cases:
        -: 2992:  // min(some_affine, some_affine + constant, ...), etc.
   254064: 2993:  SmallVector<int64_t, 2> results;
call    0 returned 100%
   254064: 2994:  auto foldedMap = op.getMap().partialConstantFold(operands, &results);
call    0 returned 100%
        -: 2995:
        -: 2996:  // If some of the map results are not constant, try changing the map in-place.
   254064: 2997:  if (results.empty()) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -: 2998:    // If the map is the same, report that folding did not happen.
   129922: 2999:    if (foldedMap == op.getMap())
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
    92238: 3000:      return {};
    37684: 3001:    op->setAttr("map", AffineMapAttr::get(foldedMap));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    37684: 3002:    return op.getResult();
call    0 returned 100%
        -: 3003:  }
        -: 3004:
        -: 3005:  // Otherwise, completely fold the op into a constant.
        -: 3006:  auto resultIt = std::is_same<T, AffineMinOp>::value
   248284: 3007:                      ? std::min_element(results.begin(), results.end())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 3008:                      : std::max_element(results.begin(), results.end());
   124142: 3009:  if (resultIt == results.end())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3010:    return {};
   124142: 3011:  return IntegerAttr::get(IndexType::get(op.getContext()), *resultIt);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 3012:}
------------------
_Z12foldMinMaxOpIN4mlir11AffineMinOpEENS0_12OpFoldResultET_N4llvm8ArrayRefINS0_9AttributeEEE:
function _Z12foldMinMaxOpIN4mlir11AffineMinOpEENS0_12OpFoldResultET_N4llvm8ArrayRefINS0_9AttributeEEE called 247515 returned 100% blocks executed 96%
   247515: 2986:static OpFoldResult foldMinMaxOp(T op, ArrayRef<Attribute> operands) {
call    0 returned 100%
        -: 2987:  static_assert(llvm::is_one_of<T, AffineMinOp, AffineMaxOp>::value,
        -: 2988:                "expected affine min or max op");
        -: 2989:
        -: 2990:  // Fold the affine map.
        -: 2991:  // TODO: Fold more cases:
        -: 2992:  // min(some_affine, some_affine + constant, ...), etc.
   247515: 2993:  SmallVector<int64_t, 2> results;
call    0 returned 100%
   247515: 2994:  auto foldedMap = op.getMap().partialConstantFold(operands, &results);
call    0 returned 100%
        -: 2995:
        -: 2996:  // If some of the map results are not constant, try changing the map in-place.
   247515: 2997:  if (results.empty()) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
        -: 2998:    // If the map is the same, report that folding did not happen.
   135450: 2999:    if (foldedMap == op.getMap())
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
    99439: 3000:      return {};
    36011: 3001:    op->setAttr("map", AffineMapAttr::get(foldedMap));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    36011: 3002:    return op.getResult();
call    0 returned 100%
        -: 3003:  }
        -: 3004:
        -: 3005:  // Otherwise, completely fold the op into a constant.
        -: 3006:  auto resultIt = std::is_same<T, AffineMinOp>::value
   224130: 3007:                      ? std::min_element(results.begin(), results.end())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 3008:                      : std::max_element(results.begin(), results.end());
   112065: 3009:  if (resultIt == results.end())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3010:    return {};
   112065: 3011:  return IntegerAttr::get(IndexType::get(op.getContext()), *resultIt);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 3012:}
------------------
        -: 3013:
        -: 3014:/// Remove duplicated expressions in affine min/max ops.
        -: 3015:template <typename T>
        -: 3016:struct DeduplicateAffineMinMaxExpressions : public OpRewritePattern<T> {
        -: 3017:  using OpRewritePattern<T>::OpRewritePattern;
        -: 3018:
      788: 3019:  LogicalResult matchAndRewrite(T affineOp,
        -: 3020:                                PatternRewriter &rewriter) const override {
      788: 3021:    AffineMap oldMap = affineOp.getAffineMap();
        -: 3022:
     1576: 3023:    SmallVector<AffineExpr, 4> newExprs;
     3035: 3024:    for (AffineExpr expr : oldMap.getResults()) {
        -: 3025:      // This is a linear scan over newExprs, but it should be fine given that
        -: 3026:      // we typically just have a few expressions per op.
     2247: 3027:      if (!llvm::is_contained(newExprs, expr))
     2159: 3028:        newExprs.push_back(expr);
        -: 3029:    }
        -: 3030:
      788: 3031:    if (newExprs.size() == oldMap.getNumResults())
      788: 3032:      return failure();
        -: 3033:
       85: 3034:    auto newMap = AffineMap::get(oldMap.getNumDims(), oldMap.getNumSymbols(),
        -: 3035:                                 newExprs, rewriter.getContext());
       85: 3036:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, affineOp.getMapOperands());
        -: 3037:
      788: 3038:    return success();
        -: 3039:  }
------------------
_ZNK34DeduplicateAffineMinMaxExpressionsIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK34DeduplicateAffineMinMaxExpressionsIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 480 returned 100% blocks executed 100%
      480: 3019:  LogicalResult matchAndRewrite(T affineOp,
        -: 3020:                                PatternRewriter &rewriter) const override {
      480: 3021:    AffineMap oldMap = affineOp.getAffineMap();
call    0 returned 100%
call    1 returned 100%
        -: 3022:
      960: 3023:    SmallVector<AffineExpr, 4> newExprs;
     1845: 3024:    for (AffineExpr expr : oldMap.getResults()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
branch  3 taken 97% (fallthrough)
branch  4 taken 3%
        -: 3025:      // This is a linear scan over newExprs, but it should be fine given that
        -: 3026:      // we typically just have a few expressions per op.
     1365: 3027:      if (!llvm::is_contained(newExprs, expr))
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
     1318: 3028:        newExprs.push_back(expr);
call    0 returned 100%
        -: 3029:    }
        -: 3030:
      480: 3031:    if (newExprs.size() == oldMap.getNumResults())
call    0 returned 100%
branch  1 taken 90% (fallthrough)
branch  2 taken 10%
      480: 3032:      return failure();
        -: 3033:
       47: 3034:    auto newMap = AffineMap::get(oldMap.getNumDims(), oldMap.getNumSymbols(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3035:                                 newExprs, rewriter.getContext());
       47: 3036:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, affineOp.getMapOperands());
call    0 returned 100%
call    1 returned 100%
        -: 3037:
      480: 3038:    return success();
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -: 3039:  }
------------------
_ZNK34DeduplicateAffineMinMaxExpressionsIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK34DeduplicateAffineMinMaxExpressionsIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 308 returned 100% blocks executed 95%
      308: 3019:  LogicalResult matchAndRewrite(T affineOp,
        -: 3020:                                PatternRewriter &rewriter) const override {
      308: 3021:    AffineMap oldMap = affineOp.getAffineMap();
call    0 returned 100%
call    1 returned 100%
        -: 3022:
      616: 3023:    SmallVector<AffineExpr, 4> newExprs;
     1190: 3024:    for (AffineExpr expr : oldMap.getResults()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
branch  3 taken 95% (fallthrough)
branch  4 taken 5%
        -: 3025:      // This is a linear scan over newExprs, but it should be fine given that
        -: 3026:      // we typically just have a few expressions per op.
      882: 3027:      if (!llvm::is_contained(newExprs, expr))
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
      841: 3028:        newExprs.push_back(expr);
call    0 returned 100%
        -: 3029:    }
        -: 3030:
      308: 3031:    if (newExprs.size() == oldMap.getNumResults())
call    0 returned 100%
branch  1 taken 88% (fallthrough)
branch  2 taken 12%
      308: 3032:      return failure();
        -: 3033:
       38: 3034:    auto newMap = AffineMap::get(oldMap.getNumDims(), oldMap.getNumSymbols(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3035:                                 newExprs, rewriter.getContext());
       38: 3036:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, affineOp.getMapOperands());
call    0 returned 100%
call    1 returned 100%
        -: 3037:
      308: 3038:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3039:  }
------------------
        -: 3040:};
        -: 3041:
        -: 3042:/// Merge an affine min/max op to its consumers if its consumer is also an
        -: 3043:/// affine min/max op.
        -: 3044:///
        -: 3045:/// This pattern requires the producer affine min/max op is bound to a
        -: 3046:/// dimension/symbol that is used as a standalone expression in the consumer
        -: 3047:/// affine op's map.
        -: 3048:///
        -: 3049:/// For example, a pattern like the following:
        -: 3050:///
        -: 3051:///   %0 = affine.min affine_map<()[s0] -> (s0 + 16, s0 * 8)> ()[%sym1]
        -: 3052:///   %1 = affine.min affine_map<(d0)[s0] -> (s0 + 4, d0)> (%0)[%sym2]
        -: 3053:///
        -: 3054:/// Can be turned into:
        -: 3055:///
        -: 3056:///   %1 = affine.min affine_map<
        -: 3057:///          ()[s0, s1] -> (s0 + 4, s1 + 16, s1 * 8)> ()[%sym2, %sym1]
        -: 3058:template <typename T>
        -: 3059:struct MergeAffineMinMaxOp : public OpRewritePattern<T> {
        -: 3060:  using OpRewritePattern<T>::OpRewritePattern;
        -: 3061:
      703: 3062:  LogicalResult matchAndRewrite(T affineOp,
        -: 3063:                                PatternRewriter &rewriter) const override {
      703: 3064:    AffineMap oldMap = affineOp.getAffineMap();
      703: 3065:    ValueRange dimOperands =
      703: 3066:        affineOp.getMapOperands().take_front(oldMap.getNumDims());
      703: 3067:    ValueRange symOperands =
     1406: 3068:        affineOp.getMapOperands().take_back(oldMap.getNumSymbols());
        -: 3069:
      703: 3070:    auto newDimOperands = llvm::to_vector<8>(dimOperands);
     1406: 3071:    auto newSymOperands = llvm::to_vector<8>(symOperands);
      703: 3072:    SmallVector<AffineExpr, 4> newExprs;
      703: 3073:    SmallVector<T, 4> producerOps;
        -: 3074:
        -: 3075:    // Go over each expression to see whether it's a single dimension/symbol
        -: 3076:    // with the corresponding operand which is the result of another affine
        -: 3077:    // min/max op. If So it can be merged into this affine op.
     2644: 3078:    for (AffineExpr expr : oldMap.getResults()) {
     1941: 3079:      if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>()) {
       86: 3080:        Value symValue = symOperands[symExpr.getPosition()];
      86*: 3081:        if (auto producerOp = symValue.getDefiningOp<T>()) {
    #####: 3082:          producerOps.push_back(producerOp);
    #####: 3083:          continue;
        -: 3084:        }
     1855: 3085:      } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
       71: 3086:        Value dimValue = dimOperands[dimExpr.getPosition()];
      71*: 3087:        if (auto producerOp = dimValue.getDefiningOp<T>()) {
       3*: 3088:          producerOps.push_back(producerOp);
       3*: 3089:          continue;
        -: 3090:        }
        -: 3091:      }
        -: 3092:      // For the above cases we will remove the expression by merging the
        -: 3093:      // producer affine min/max's affine expressions. Otherwise we need to
        -: 3094:      // keep the existing expression.
     1938: 3095:      newExprs.push_back(expr);
        -: 3096:    }
        -: 3097:
      703: 3098:    if (producerOps.empty())
      703: 3099:      return failure();
        -: 3100:
       3*: 3101:    unsigned numUsedDims = oldMap.getNumDims();
       3*: 3102:    unsigned numUsedSyms = oldMap.getNumSymbols();
        -: 3103:
        -: 3104:    // Now go over all producer affine ops and merge their expressions.
       6*: 3105:    for (T producerOp : producerOps) {
       3*: 3106:      AffineMap producerMap = producerOp.getAffineMap();
       3*: 3107:      unsigned numProducerDims = producerMap.getNumDims();
       3*: 3108:      unsigned numProducerSyms = producerMap.getNumSymbols();
        -: 3109:
        -: 3110:      // Collect all dimension/symbol values.
       3*: 3111:      ValueRange dimValues =
       3*: 3112:          producerOp.getMapOperands().take_front(numProducerDims);
       3*: 3113:      ValueRange symValues =
       6*: 3114:          producerOp.getMapOperands().take_back(numProducerSyms);
       3*: 3115:      newDimOperands.append(dimValues.begin(), dimValues.end());
       3*: 3116:      newSymOperands.append(symValues.begin(), symValues.end());
        -: 3117:
        -: 3118:      // For expressions we need to shift to avoid overlap.
      12*: 3119:      for (AffineExpr expr : producerMap.getResults()) {
       9*: 3120:        newExprs.push_back(expr.shiftDims(numProducerDims, numUsedDims)
        -: 3121:                               .shiftSymbols(numProducerSyms, numUsedSyms));
        -: 3122:      }
        -: 3123:
       3*: 3124:      numUsedDims += numProducerDims;
       3*: 3125:      numUsedSyms += numProducerSyms;
        -: 3126:    }
        -: 3127:
       3*: 3128:    auto newMap = AffineMap::get(numUsedDims, numUsedSyms, newExprs,
        -: 3129:                                 rewriter.getContext());
     706*: 3130:    auto newOperands =
        -: 3131:        llvm::to_vector<8>(llvm::concat<Value>(newDimOperands, newSymOperands));
       3*: 3132:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, newOperands);
        -: 3133:
       3*: 3134:    return success();
        -: 3135:  }
------------------
_ZNK19MergeAffineMinMaxOpIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK19MergeAffineMinMaxOpIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 433 returned 100% blocks executed 91%
      433: 3062:  LogicalResult matchAndRewrite(T affineOp,
        -: 3063:                                PatternRewriter &rewriter) const override {
      433: 3064:    AffineMap oldMap = affineOp.getAffineMap();
call    0 returned 100%
      433: 3065:    ValueRange dimOperands =
call    0 returned 100%
      433: 3066:        affineOp.getMapOperands().take_front(oldMap.getNumDims());
call    0 returned 100%
call    1 returned 100%
      433: 3067:    ValueRange symOperands =
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
      866: 3068:        affineOp.getMapOperands().take_back(oldMap.getNumSymbols());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3069:
      433: 3070:    auto newDimOperands = llvm::to_vector<8>(dimOperands);
call    0 returned 100%
      866: 3071:    auto newSymOperands = llvm::to_vector<8>(symOperands);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      433: 3072:    SmallVector<AffineExpr, 4> newExprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      433: 3073:    SmallVector<T, 4> producerOps;
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -: 3074:
        -: 3075:    // Go over each expression to see whether it's a single dimension/symbol
        -: 3076:    // with the corresponding operand which is the result of another affine
        -: 3077:    // min/max op. If So it can be merged into this affine op.
     1623: 3078:    for (AffineExpr expr : oldMap.getResults()) {
call    0 returned 100%
branch  1 taken 73% (fallthrough)
branch  2 taken 27%
     1190: 3079:      if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>()) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
       59: 3080:        Value symValue = symOperands[symExpr.getPosition()];
call    0 returned 100%
call    1 returned 100%
      59*: 3081:        if (auto producerOp = symValue.getDefiningOp<T>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3082:          producerOps.push_back(producerOp);
call    0 never executed
    #####: 3083:          continue;
        -: 3084:        }
     1131: 3085:      } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
       48: 3086:        Value dimValue = dimOperands[dimExpr.getPosition()];
call    0 returned 100%
call    1 returned 100%
       48: 3087:        if (auto producerOp = dimValue.getDefiningOp<T>()) {
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        3: 3088:          producerOps.push_back(producerOp);
call    0 returned 100%
        3: 3089:          continue;
        -: 3090:        }
        -: 3091:      }
        -: 3092:      // For the above cases we will remove the expression by merging the
        -: 3093:      // producer affine min/max's affine expressions. Otherwise we need to
        -: 3094:      // keep the existing expression.
     1187: 3095:      newExprs.push_back(expr);
call    0 returned 100%
        -: 3096:    }
        -: 3097:
      433: 3098:    if (producerOps.empty())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      433: 3099:      return failure();
        -: 3100:
        3: 3101:    unsigned numUsedDims = oldMap.getNumDims();
call    0 returned 100%
        3: 3102:    unsigned numUsedSyms = oldMap.getNumSymbols();
call    0 returned 100%
        -: 3103:
        -: 3104:    // Now go over all producer affine ops and merge their expressions.
        6: 3105:    for (T producerOp : producerOps) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        3: 3106:      AffineMap producerMap = producerOp.getAffineMap();
call    0 returned 100%
        3: 3107:      unsigned numProducerDims = producerMap.getNumDims();
call    0 returned 100%
        3: 3108:      unsigned numProducerSyms = producerMap.getNumSymbols();
call    0 returned 100%
        -: 3109:
        -: 3110:      // Collect all dimension/symbol values.
        3: 3111:      ValueRange dimValues =
call    0 returned 100%
        3: 3112:          producerOp.getMapOperands().take_front(numProducerDims);
call    0 returned 100%
        3: 3113:      ValueRange symValues =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6: 3114:          producerOp.getMapOperands().take_back(numProducerSyms);
call    0 returned 100%
call    1 returned 100%
        3: 3115:      newDimOperands.append(dimValues.begin(), dimValues.end());
call    0 returned 100%
call    1 returned 100%
        3: 3116:      newSymOperands.append(symValues.begin(), symValues.end());
call    0 returned 100%
        -: 3117:
        -: 3118:      // For expressions we need to shift to avoid overlap.
       12: 3119:      for (AffineExpr expr : producerMap.getResults()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
        9: 3120:        newExprs.push_back(expr.shiftDims(numProducerDims, numUsedDims)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3121:                               .shiftSymbols(numProducerSyms, numUsedSyms));
        -: 3122:      }
        -: 3123:
        3: 3124:      numUsedDims += numProducerDims;
        3: 3125:      numUsedSyms += numProducerSyms;
        -: 3126:    }
        -: 3127:
        3: 3128:    auto newMap = AffineMap::get(numUsedDims, numUsedSyms, newExprs,
call    0 returned 100%
call    1 returned 100%
        -: 3129:                                 rewriter.getContext());
      436: 3130:    auto newOperands =
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3131:        llvm::to_vector<8>(llvm::concat<Value>(newDimOperands, newSymOperands));
        3: 3132:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, newOperands);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3133:
        3: 3134:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3135:  }
------------------
_ZNK19MergeAffineMinMaxOpIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK19MergeAffineMinMaxOpIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 270 returned 100% blocks executed 50%
      270: 3062:  LogicalResult matchAndRewrite(T affineOp,
        -: 3063:                                PatternRewriter &rewriter) const override {
      270: 3064:    AffineMap oldMap = affineOp.getAffineMap();
call    0 returned 100%
      270: 3065:    ValueRange dimOperands =
call    0 returned 100%
      270: 3066:        affineOp.getMapOperands().take_front(oldMap.getNumDims());
call    0 returned 100%
call    1 returned 100%
      270: 3067:    ValueRange symOperands =
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
      540: 3068:        affineOp.getMapOperands().take_back(oldMap.getNumSymbols());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3069:
      270: 3070:    auto newDimOperands = llvm::to_vector<8>(dimOperands);
call    0 returned 100%
      540: 3071:    auto newSymOperands = llvm::to_vector<8>(symOperands);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      270: 3072:    SmallVector<AffineExpr, 4> newExprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      270: 3073:    SmallVector<T, 4> producerOps;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3074:
        -: 3075:    // Go over each expression to see whether it's a single dimension/symbol
        -: 3076:    // with the corresponding operand which is the result of another affine
        -: 3077:    // min/max op. If So it can be merged into this affine op.
     1021: 3078:    for (AffineExpr expr : oldMap.getResults()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
      751: 3079:      if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>()) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
       27: 3080:        Value symValue = symOperands[symExpr.getPosition()];
call    0 returned 100%
call    1 returned 100%
      27*: 3081:        if (auto producerOp = symValue.getDefiningOp<T>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3082:          producerOps.push_back(producerOp);
call    0 never executed
    #####: 3083:          continue;
        -: 3084:        }
      724: 3085:      } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
       23: 3086:        Value dimValue = dimOperands[dimExpr.getPosition()];
call    0 returned 100%
call    1 returned 100%
      23*: 3087:        if (auto producerOp = dimValue.getDefiningOp<T>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3088:          producerOps.push_back(producerOp);
call    0 never executed
    #####: 3089:          continue;
        -: 3090:        }
        -: 3091:      }
        -: 3092:      // For the above cases we will remove the expression by merging the
        -: 3093:      // producer affine min/max's affine expressions. Otherwise we need to
        -: 3094:      // keep the existing expression.
      751: 3095:      newExprs.push_back(expr);
call    0 returned 100%
        -: 3096:    }
        -: 3097:
      270: 3098:    if (producerOps.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      270: 3099:      return failure();
        -: 3100:
    #####: 3101:    unsigned numUsedDims = oldMap.getNumDims();
call    0 never executed
    #####: 3102:    unsigned numUsedSyms = oldMap.getNumSymbols();
call    0 never executed
        -: 3103:
        -: 3104:    // Now go over all producer affine ops and merge their expressions.
    #####: 3105:    for (T producerOp : producerOps) {
branch  0 never executed
branch  1 never executed
    #####: 3106:      AffineMap producerMap = producerOp.getAffineMap();
call    0 never executed
    #####: 3107:      unsigned numProducerDims = producerMap.getNumDims();
call    0 never executed
    #####: 3108:      unsigned numProducerSyms = producerMap.getNumSymbols();
call    0 never executed
        -: 3109:
        -: 3110:      // Collect all dimension/symbol values.
    #####: 3111:      ValueRange dimValues =
call    0 never executed
    #####: 3112:          producerOp.getMapOperands().take_front(numProducerDims);
call    0 never executed
    #####: 3113:      ValueRange symValues =
branch  0 never executed
branch  1 never executed
    #####: 3114:          producerOp.getMapOperands().take_back(numProducerSyms);
call    0 never executed
call    1 never executed
    #####: 3115:      newDimOperands.append(dimValues.begin(), dimValues.end());
call    0 never executed
call    1 never executed
    #####: 3116:      newSymOperands.append(symValues.begin(), symValues.end());
call    0 never executed
        -: 3117:
        -: 3118:      // For expressions we need to shift to avoid overlap.
    #####: 3119:      for (AffineExpr expr : producerMap.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3120:        newExprs.push_back(expr.shiftDims(numProducerDims, numUsedDims)
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3121:                               .shiftSymbols(numProducerSyms, numUsedSyms));
        -: 3122:      }
        -: 3123:
    #####: 3124:      numUsedDims += numProducerDims;
    #####: 3125:      numUsedSyms += numProducerSyms;
        -: 3126:    }
        -: 3127:
    #####: 3128:    auto newMap = AffineMap::get(numUsedDims, numUsedSyms, newExprs,
call    0 never executed
call    1 never executed
        -: 3129:                                 rewriter.getContext());
     270*: 3130:    auto newOperands =
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3131:        llvm::to_vector<8>(llvm::concat<Value>(newDimOperands, newSymOperands));
    #####: 3132:    rewriter.replaceOpWithNewOp<T>(affineOp, newMap, newOperands);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3133:
    #####: 3134:    return success();
branch  0 never executed
branch  1 never executed
        -: 3135:  }
------------------
        -: 3136:};
        -: 3137:
        -: 3138:/// Canonicalize the result expression order of an affine map and return success
        -: 3139:/// if the order changed.
        -: 3140:///
        -: 3141:/// The function flattens the map's affine expressions to coefficient arrays and
        -: 3142:/// sorts them in lexicographic order. A coefficient array contains a multiplier
        -: 3143:/// for every dimension/symbol and a constant term. The canonicalization fails
        -: 3144:/// if a result expression is not pure or if the flattening requires local
        -: 3145:/// variables that, unlike dimensions and symbols, have no global order.
function _ZL31canonicalizeMapExprAndTermOrderRN4mlir9AffineMapE called 438 returned 100% blocks executed 93%
      438: 3146:static LogicalResult canonicalizeMapExprAndTermOrder(AffineMap &map) {
      438: 3147:  SmallVector<SmallVector<int64_t>> flattenedExprs;
call    0 returned 100%
     1019: 3148:  for (const AffineExpr &resultExpr : map.getResults()) {
call    0 returned 100%
branch  1 taken 84% (fallthrough)
branch  2 taken 16%
        -: 3149:    // Fail if the expression is not pure.
      859: 3150:    if (!resultExpr.isPureAffine())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     278*: 3151:      return failure();
        -: 3152:
      859: 3153:    SimpleAffineExprFlattener flattener(map.getNumDims(), map.getNumSymbols());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      859: 3154:    flattener.walkPostOrder(resultExpr);
call    0 returned 100%
        -: 3155:
        -: 3156:    // Fail if the flattened expression has local variables.
      859: 3157:    if (flattener.operandExprStack.back().size() !=
call    0 returned 100%
      859: 3158:        map.getNumDims() + map.getNumSymbols() + 1)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 32% (fallthrough)
branch  3 taken 68%
      278: 3159:      return failure();
call    0 returned 100%
        -: 3160:
      581: 3161:    flattenedExprs.emplace_back(flattener.operandExprStack.back().begin(),
call    0 returned 100%
      581: 3162:                                flattener.operandExprStack.back().end());
call    0 returned 100%
call    1 returned 100%
        -: 3163:  }
        -: 3164:
        -: 3165:  // Fail if sorting is not necessary.
      160: 3166:  if (llvm::is_sorted(flattenedExprs))
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
      132: 3167:    return failure();
        -: 3168:
        -: 3169:  // Reorder the result expressions according to their flattened form.
       28: 3170:  SmallVector<unsigned> resultPermutation =
      466: 3171:      llvm::to_vector(llvm::seq<unsigned>(0, map.getNumResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
function _ZZL31canonicalizeMapExprAndTermOrderRN4mlir9AffineMapEENKUljjE_clEjj.isra.0 called 143 returned 100% blocks executed 67%
       28: 3172:  llvm::sort(resultPermutation, [&](unsigned lhs, unsigned rhs) {
call    0 returned 100%
      143: 3173:    return flattenedExprs[lhs] < flattenedExprs[rhs];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -: 3174:  });
       56: 3175:  SmallVector<AffineExpr> newExprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      118: 3176:  for (unsigned idx : resultPermutation)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
       90: 3177:    newExprs.push_back(map.getResult(idx));
call    0 returned 100%
call    1 returned 100%
        -: 3178:
       28: 3179:  map = AffineMap::get(map.getNumDims(), map.getNumSymbols(), newExprs,
       28: 3180:                       map.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       28: 3181:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3182:}
        -: 3183:
        -: 3184:/// Canonicalize the affine map result expression order of an affine min/max
        -: 3185:/// operation.
        -: 3186:///
        -: 3187:/// The pattern calls `canonicalizeMapExprAndTermOrder` to order the result
        -: 3188:/// expressions and replaces the operation if the order changed.
        -: 3189:///
        -: 3190:/// For example, the following operation:
        -: 3191:///
        -: 3192:///   %0 = affine.min affine_map<(d0, d1) -> (d0 + d1, d1 + 16, 32)> (%i0, %i1)
        -: 3193:///
        -: 3194:/// Turns into:
        -: 3195:///
        -: 3196:///   %0 = affine.min affine_map<(d0, d1) -> (32, d1 + 16, d0 + d1)> (%i0, %i1)
        -: 3197:template <typename T>
        -: 3198:struct CanonicalizeAffineMinMaxOpExprAndTermOrder : public OpRewritePattern<T> {
        -: 3199:  using OpRewritePattern<T>::OpRewritePattern;
        -: 3200:
      438: 3201:  LogicalResult matchAndRewrite(T affineOp,
        -: 3202:                                PatternRewriter &rewriter) const override {
      438: 3203:    AffineMap map = affineOp.getAffineMap();
      438: 3204:    if (failed(canonicalizeMapExprAndTermOrder(map)))
      438: 3205:      return failure();
        -: 3206:
       28: 3207:    rewriter.replaceOpWithNewOp<T>(affineOp, map, affineOp.getMapOperands());
      438: 3208:    return success();
        -: 3209:  }
------------------
_ZNK42CanonicalizeAffineMinMaxOpExprAndTermOrderIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK42CanonicalizeAffineMinMaxOpExprAndTermOrderIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 292 returned 100% blocks executed 100%
      292: 3201:  LogicalResult matchAndRewrite(T affineOp,
        -: 3202:                                PatternRewriter &rewriter) const override {
      292: 3203:    AffineMap map = affineOp.getAffineMap();
call    0 returned 100%
      292: 3204:    if (failed(canonicalizeMapExprAndTermOrder(map)))
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
      292: 3205:      return failure();
        -: 3206:
       26: 3207:    rewriter.replaceOpWithNewOp<T>(affineOp, map, affineOp.getMapOperands());
call    0 returned 100%
call    1 returned 100%
      292: 3208:    return success();
        -: 3209:  }
------------------
_ZNK42CanonicalizeAffineMinMaxOpExprAndTermOrderIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK42CanonicalizeAffineMinMaxOpExprAndTermOrderIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 146 returned 100% blocks executed 100%
      146: 3201:  LogicalResult matchAndRewrite(T affineOp,
        -: 3202:                                PatternRewriter &rewriter) const override {
      146: 3203:    AffineMap map = affineOp.getAffineMap();
call    0 returned 100%
      146: 3204:    if (failed(canonicalizeMapExprAndTermOrder(map)))
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
      146: 3205:      return failure();
        -: 3206:
        2: 3207:    rewriter.replaceOpWithNewOp<T>(affineOp, map, affineOp.getMapOperands());
call    0 returned 100%
call    1 returned 100%
      146: 3208:    return success();
        -: 3209:  }
------------------
        -: 3210:};
        -: 3211:
        -: 3212:template <typename T>
        -: 3213:struct CanonicalizeSingleResultAffineMinMaxOp : public OpRewritePattern<T> {
        -: 3214:  using OpRewritePattern<T>::OpRewritePattern;
        -: 3215:
      857: 3216:  LogicalResult matchAndRewrite(T affineOp,
        -: 3217:                                PatternRewriter &rewriter) const override {
      857: 3218:    if (affineOp.getMap().getNumResults() != 1)
      857: 3219:      return failure();
      138: 3220:    rewriter.replaceOpWithNewOp<AffineApplyOp>(affineOp, affineOp.getMap(),
        -: 3221:                                               affineOp.getOperands());
      857: 3222:    return success();
        -: 3223:  }
------------------
_ZNK38CanonicalizeSingleResultAffineMinMaxOpIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK38CanonicalizeSingleResultAffineMinMaxOpIN4mlir11AffineMinOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 520 returned 100% blocks executed 100%
      520: 3216:  LogicalResult matchAndRewrite(T affineOp,
call    0 returned 100%
        -: 3217:                                PatternRewriter &rewriter) const override {
      520: 3218:    if (affineOp.getMap().getNumResults() != 1)
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
      520: 3219:      return failure();
       80: 3220:    rewriter.replaceOpWithNewOp<AffineApplyOp>(affineOp, affineOp.getMap(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3221:                                               affineOp.getOperands());
      520: 3222:    return success();
        -: 3223:  }
------------------
_ZNK38CanonicalizeSingleResultAffineMinMaxOpIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE:
function _ZNK38CanonicalizeSingleResultAffineMinMaxOpIN4mlir11AffineMaxOpEE15matchAndRewriteES1_RNS0_15PatternRewriterE called 337 returned 100% blocks executed 100%
      337: 3216:  LogicalResult matchAndRewrite(T affineOp,
call    0 returned 100%
        -: 3217:                                PatternRewriter &rewriter) const override {
      337: 3218:    if (affineOp.getMap().getNumResults() != 1)
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
      337: 3219:      return failure();
       58: 3220:    rewriter.replaceOpWithNewOp<AffineApplyOp>(affineOp, affineOp.getMap(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3221:                                               affineOp.getOperands());
      337: 3222:    return success();
        -: 3223:  }
------------------
        -: 3224:};
        -: 3225:
        -: 3226://===----------------------------------------------------------------------===//
        -: 3227:// AffineMinOp
        -: 3228://===----------------------------------------------------------------------===//
        -: 3229://
        -: 3230://   %0 = affine.min (d0) -> (1000, d0 + 512) (%i0)
        -: 3231://
        -: 3232:
function _ZN4mlir11AffineMinOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
  247515*: 3233:OpFoldResult AffineMinOp::fold(ArrayRef<Attribute> operands) {
  247515*: 3234:  return foldMinMaxOp(*this, operands);
call    0 returned 100%
call    1 never executed
        -: 3235:}
        -: 3236:
function _ZN4mlir11AffineMinOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1261 returned 100% blocks executed 100%
     1261: 3237:void AffineMinOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 3238:                                              MLIRContext *context) {
     1261: 3239:  patterns.add<CanonicalizeSingleResultAffineMinMaxOp<AffineMinOp>,
        -: 3240:               DeduplicateAffineMinMaxExpressions<AffineMinOp>,
        -: 3241:               MergeAffineMinMaxOp<AffineMinOp>, SimplifyAffineOp<AffineMinOp>,
        -: 3242:               CanonicalizeAffineMinMaxOpExprAndTermOrder<AffineMinOp>>(
     1261: 3243:      context);
call    0 returned 100%
     1261: 3244:}
        -: 3245:
function _ZN4mlir11AffineMinOp6verifyEv called 0 returned 0% blocks executed 0%
47085487*: 3246:LogicalResult AffineMinOp::verify() { return verifyAffineMinMaxOp(*this); }
call    0 returned 100%
call    1 never executed
call    2 never executed
        -: 3247:
function _ZN4mlir11AffineMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1224197 returned 100% blocks executed 100%
  1224197: 3248:ParseResult AffineMinOp::parse(OpAsmParser &parser, OperationState &result) {
  1224197: 3249:  return parseAffineMinMaxOp<AffineMinOp>(parser, result);
call    0 returned 100%
        -: 3250:}
        -: 3251:
function _ZN4mlir11AffineMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
 1551146*: 3252:void AffineMinOp::print(OpAsmPrinter &p) { printAffineMinMaxOp(p, *this); }
call    0 returned 100%
call    1 never executed
        -: 3253:
        -: 3254://===----------------------------------------------------------------------===//
        -: 3255:// AffineMaxOp
        -: 3256://===----------------------------------------------------------------------===//
        -: 3257://
        -: 3258://   %0 = affine.max (d0) -> (1000, d0 + 512) (%i0)
        -: 3259://
        -: 3260:
function _ZN4mlir11AffineMaxOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
  254064*: 3261:OpFoldResult AffineMaxOp::fold(ArrayRef<Attribute> operands) {
  254064*: 3262:  return foldMinMaxOp(*this, operands);
call    0 returned 100%
call    1 never executed
        -: 3263:}
        -: 3264:
function _ZN4mlir11AffineMaxOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1261 returned 100% blocks executed 100%
     1261: 3265:void AffineMaxOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 3266:                                              MLIRContext *context) {
     1261: 3267:  patterns.add<CanonicalizeSingleResultAffineMinMaxOp<AffineMaxOp>,
        -: 3268:               DeduplicateAffineMinMaxExpressions<AffineMaxOp>,
        -: 3269:               MergeAffineMinMaxOp<AffineMaxOp>, SimplifyAffineOp<AffineMaxOp>,
        -: 3270:               CanonicalizeAffineMinMaxOpExprAndTermOrder<AffineMaxOp>>(
     1261: 3271:      context);
call    0 returned 100%
     1261: 3272:}
        -: 3273:
function _ZN4mlir11AffineMaxOp6verifyEv called 0 returned 0% blocks executed 0%
48002360*: 3274:LogicalResult AffineMaxOp::verify() { return verifyAffineMinMaxOp(*this); }
call    0 returned 100%
call    1 never executed
call    2 never executed
        -: 3275:
function _ZN4mlir11AffineMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 1251084 returned 100% blocks executed 100%
  1251084: 3276:ParseResult AffineMaxOp::parse(OpAsmParser &parser, OperationState &result) {
  1251084: 3277:  return parseAffineMinMaxOp<AffineMaxOp>(parser, result);
call    0 returned 100%
        -: 3278:}
        -: 3279:
function _ZN4mlir11AffineMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
 1571193*: 3280:void AffineMaxOp::print(OpAsmPrinter &p) { printAffineMinMaxOp(p, *this); }
call    0 returned 100%
call    1 never executed
        -: 3281:
        -: 3282://===----------------------------------------------------------------------===//
        -: 3283:// AffinePrefetchOp
        -: 3284://===----------------------------------------------------------------------===//
        -: 3285:
        -: 3286://
        -: 3287:// affine.prefetch %0[%i, %j + 5], read, locality<3>, data : memref<400x400xi32>
        -: 3288://
function _ZN4mlir16AffinePrefetchOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3289:ParseResult AffinePrefetchOp::parse(OpAsmParser &parser,
        -: 3290:                                    OperationState &result) {
    #####: 3291:  auto &builder = parser.getBuilder();
call    0 never executed
    #####: 3292:  auto indexTy = builder.getIndexType();
call    0 never executed
        -: 3293:
    #####: 3294:  MemRefType type;
    #####: 3295:  OpAsmParser::UnresolvedOperand memrefInfo;
call    0 never executed
    #####: 3296:  IntegerAttr hintInfo;
    #####: 3297:  auto i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####: 3298:  StringRef readOrWrite, cacheType;
        -: 3299:
    #####: 3300:  AffineMapAttr mapAttr;
    #####: 3301:  SmallVector<OpAsmParser::UnresolvedOperand, 1> mapOperands;
call    0 never executed
    #####: 3302:  if (parser.parseOperand(memrefInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3303:      parser.parseAffineMapOfSSAIds(mapOperands, mapAttr,
        -: 3304:                                    AffinePrefetchOp::getMapAttrStrName(),
    #####: 3305:                                    result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3306:      parser.parseComma() || parser.parseKeyword(&readOrWrite) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3307:      parser.parseComma() || parser.parseKeyword("locality") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3308:      parser.parseLess() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3309:      parser.parseAttribute(hintInfo, i32Type,
        -: 3310:                            AffinePrefetchOp::getLocalityHintAttrStrName(),
    #####: 3311:                            result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3312:      parser.parseGreater() || parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3313:      parser.parseKeyword(&cacheType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3314:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3315:      parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3316:      parser.resolveOperand(memrefInfo, type, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 3317:      parser.resolveOperands(mapOperands, indexTy, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3318:    return failure();
        -: 3319:
    #####: 3320:  if (!readOrWrite.equals("read") && !readOrWrite.equals("write"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3321:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3322:                            "rw specifier has to be 'read' or 'write'");
call    0 never executed
call    1 never executed
    #####: 3323:  result.addAttribute(
call    0 never executed
        -: 3324:      AffinePrefetchOp::getIsWriteAttrStrName(),
    #####: 3325:      parser.getBuilder().getBoolAttr(readOrWrite.equals("write")));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3326:
    #####: 3327:  if (!cacheType.equals("data") && !cacheType.equals("instr"))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3328:    return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3329:                            "cache type has to be 'data' or 'instr'");
call    0 never executed
call    1 never executed
        -: 3330:
    #####: 3331:  result.addAttribute(
call    0 never executed
        -: 3332:      AffinePrefetchOp::getIsDataCacheAttrStrName(),
    #####: 3333:      parser.getBuilder().getBoolAttr(cacheType.equals("data")));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3334:
    #####: 3335:  return success();
        -: 3336:}
        -: 3337:
function _ZN4mlir16AffinePrefetchOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3338:void AffinePrefetchOp::print(OpAsmPrinter &p) {
    #####: 3339:  p << " " << getMemref() << '[';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3340:  AffineMapAttr mapAttr =
    #####: 3341:      (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName());
call    0 never executed
    #####: 3342:  if (mapAttr)
branch  0 never executed
branch  1 never executed
    #####: 3343:    p.printAffineMapOfSSAIds(mapAttr, getMapOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3344:  p << ']' << ", " << (getIsWrite() ? "write" : "read") << ", "
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 3345:    << "locality<" << getLocalityHint() << ">, "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3346:    << (getIsDataCache() ? "data" : "instr");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3347:  p.printOptionalAttrDict(
call    0 never executed
        -: 3348:      (*this)->getAttrs(),
    #####: 3349:      /*elidedAttrs=*/{getMapAttrStrName(), getLocalityHintAttrStrName(),
call    0 never executed
    #####: 3350:                       getIsDataCacheAttrStrName(), getIsWriteAttrStrName()});
call    0 never executed
    #####: 3351:  p << " : " << getMemRefType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3352:}
        -: 3353:
function _ZN4mlir16AffinePrefetchOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3354:LogicalResult AffinePrefetchOp::verify() {
    #####: 3355:  auto mapAttr = (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName());
call    0 never executed
    #####: 3356:  if (mapAttr) {
branch  0 never executed
branch  1 never executed
    #####: 3357:    AffineMap map = mapAttr.getValue();
call    0 never executed
    #####: 3358:    if (map.getNumResults() != getMemRefType().getRank())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3359:      return emitOpError("affine.prefetch affine map num results must equal"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3360:                         " memref rank");
call    0 never executed
    #####: 3361:    if (map.getNumInputs() + 1 != getNumOperands())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3362:      return emitOpError("too few operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3363:  } else {
    #####: 3364:    if (getNumOperands() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3365:      return emitOpError("too few operands");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3366:  }
        -: 3367:
    #####: 3368:  Region *scope = getAffineScope(*this);
call    0 never executed
    #####: 3369:  for (auto idx : getMapOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3370:    if (!isValidAffineIndexOperand(idx, scope))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3371:      return emitOpError("index must be a dimension or symbol identifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3372:  }
    #####: 3373:  return success();
        -: 3374:}
        -: 3375:
function _ZN4mlir16AffinePrefetchOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 3376:void AffinePrefetchOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 3377:                                                   MLIRContext *context) {
        -: 3378:  // prefetch(memrefcast) -> prefetch
     1235: 3379:  results.add<SimplifyAffineOp<AffinePrefetchOp>>(context);
call    0 returned 100%
     1235: 3380:}
        -: 3381:
function _ZN4mlir16AffinePrefetchOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 3382:LogicalResult AffinePrefetchOp::fold(ArrayRef<Attribute> cstOperands,
        -: 3383:                                     SmallVectorImpl<OpFoldResult> &results) {
        -: 3384:  /// prefetch(memrefcast) -> prefetch
    #####: 3385:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 3386:}
        -: 3387:
        -: 3388://===----------------------------------------------------------------------===//
        -: 3389:// AffineParallelOp
        -: 3390://===----------------------------------------------------------------------===//
        -: 3391:
function _ZN4mlir16AffineParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm8ArrayRefINS_5arith13AtomicRMWKindEEENS7_IlEE called 0 returned 0% blocks executed 0%
    #####: 3392:void AffineParallelOp::build(OpBuilder &builder, OperationState &result,
        -: 3393:                             TypeRange resultTypes,
        -: 3394:                             ArrayRef<arith::AtomicRMWKind> reductions,
        -: 3395:                             ArrayRef<int64_t> ranges) {
    #####: 3396:  SmallVector<AffineMap> lbs(ranges.size(), builder.getConstantAffineMap(0));
call    0 never executed
call    1 never executed
    #####: 3397:  auto ubs = llvm::to_vector<4>(llvm::map_range(ranges, [&](int64_t value) {
        -: 3398:    return builder.getConstantAffineMap(value);
    #####: 3399:  }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3400:  SmallVector<int64_t> steps(ranges.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3401:  build(builder, result, resultTypes, reductions, lbs, /*lbArgs=*/{}, ubs,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3402:        /*ubArgs=*/{}, steps);
    #####: 3403:}
        -: 3404:
function _ZN4mlir16AffineParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm8ArrayRefINS_5arith13AtomicRMWKindEEENS7_INS_9AffineMapEEENS_10ValueRangeESC_SD_NS7_IlEE called 1086 returned 100% blocks executed 82%
     1086: 3405:void AffineParallelOp::build(OpBuilder &builder, OperationState &result,
        -: 3406:                             TypeRange resultTypes,
        -: 3407:                             ArrayRef<arith::AtomicRMWKind> reductions,
        -: 3408:                             ArrayRef<AffineMap> lbMaps, ValueRange lbArgs,
        -: 3409:                             ArrayRef<AffineMap> ubMaps, ValueRange ubArgs,
        -: 3410:                             ArrayRef<int64_t> steps) {
function _ZZN4mlir16AffineParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm8ArrayRefINS_5arith13AtomicRMWKindEEENS7_INS_9AffineMapEEENS_10ValueRangeESC_SD_NS7_IlEEENKUlSB_E_clESB_ called 1086 returned 100% blocks executed 75%
    2172*: 3411:  assert(llvm::all_of(lbMaps,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
call   10 returned 100%
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
call   13 returned 100%
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
        -: 3412:                      [lbMaps](AffineMap m) {
        -: 3413:                        return m.getNumDims() == lbMaps[0].getNumDims() &&
        -: 3414:                               m.getNumSymbols() == lbMaps[0].getNumSymbols();
        -: 3415:                      }) &&
        -: 3416:         "expected all lower bounds maps to have the same number of dimensions "
        -: 3417:         "and symbols");
function _ZZN4mlir16AffineParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm8ArrayRefINS_5arith13AtomicRMWKindEEENS7_INS_9AffineMapEEENS_10ValueRangeESC_SD_NS7_IlEEENKUlSB_E0_clESB_ called 1086 returned 100% blocks executed 75%
    2172*: 3418:  assert(llvm::all_of(ubMaps,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 returned 100%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
call   10 returned 100%
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
call   13 returned 100%
branch 14 taken 0% (fallthrough)
branch 15 taken 100%
        -: 3419:                      [ubMaps](AffineMap m) {
        -: 3420:                        return m.getNumDims() == ubMaps[0].getNumDims() &&
        -: 3421:                               m.getNumSymbols() == ubMaps[0].getNumSymbols();
        -: 3422:                      }) &&
        -: 3423:         "expected all upper bounds maps to have the same number of dimensions "
        -: 3424:         "and symbols");
    1086*: 3425:  assert((lbMaps.empty() || lbMaps[0].getNumInputs() == lbArgs.size()) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -: 3426:         "expected lower bound maps to have as many inputs as lower bound "
        -: 3427:         "operands");
    1086*: 3428:  assert((ubMaps.empty() || ubMaps[0].getNumInputs() == ubArgs.size()) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -: 3429:         "expected upper bound maps to have as many inputs as upper bound "
        -: 3430:         "operands");
        -: 3431:
     1086: 3432:  result.addTypes(resultTypes);
call    0 returned 100%
        -: 3433:
        -: 3434:  // Convert the reductions to integer attributes.
     1086: 3435:  SmallVector<Attribute, 4> reductionAttrs;
    1086*: 3436:  for (arith::AtomicRMWKind reduction : reductions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3437:    reductionAttrs.push_back(
call    0 never executed
    #####: 3438:        builder.getI64IntegerAttr(static_cast<int64_t>(reduction)));
call    0 never executed
     1086: 3439:  result.addAttribute(getReductionsAttrStrName(),
call    0 returned 100%
     1086: 3440:                      builder.getArrayAttr(reductionAttrs));
call    0 returned 100%
        -: 3441:
        -: 3442:  // Concatenates maps defined in the same input space (same dimensions and
        -: 3443:  // symbols), assumes there is at least one map.
function _ZZN4mlir16AffineParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeEN4llvm8ArrayRefINS_5arith13AtomicRMWKindEEENS7_INS_9AffineMapEEENS_10ValueRangeESC_SD_NS7_IlEEENKUlSC_RNS6_15SmallVectorImplIiEEE1_clESC_SH_.isra.0 called 2172 returned 100% blocks executed 75%
     2172: 3444:  auto concatMapsSameInput = [&builder](ArrayRef<AffineMap> maps,
    #####: 3445:                                        SmallVectorImpl<int32_t> &groups) {
     2172: 3446:    if (maps.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3447:      return AffineMap::get(builder.getContext());
call    0 never executed
     2172: 3448:    SmallVector<AffineExpr> exprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2172: 3449:    groups.reserve(groups.size() + maps.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2172: 3450:    exprs.reserve(maps.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     4344: 3451:    for (AffineMap m : maps) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     2172: 3452:      llvm::append_range(exprs, m.getResults());
call    0 returned 100%
call    1 returned 100%
     2172: 3453:      groups.push_back(m.getNumResults());
call    0 returned 100%
call    1 returned 100%
        -: 3454:    }
     2172: 3455:    return AffineMap::get(maps[0].getNumDims(), maps[0].getNumSymbols(), exprs,
call    0 returned 100%
call    1 returned 100%
     2172: 3456:                          maps[0].getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     1086: 3457:  };
        -: 3458:
        -: 3459:  // Set up the bounds.
     2172: 3460:  SmallVector<int32_t> lbGroups, ubGroups;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     1086: 3461:  AffineMap lbMap = concatMapsSameInput(lbMaps, lbGroups);
call    0 returned 100%
     1086: 3462:  AffineMap ubMap = concatMapsSameInput(ubMaps, ubGroups);
call    0 returned 100%
     1086: 3463:  result.addAttribute(getLowerBoundsMapAttrStrName(),
call    0 returned 100%
     1086: 3464:                      AffineMapAttr::get(lbMap));
call    0 returned 100%
     1086: 3465:  result.addAttribute(getLowerBoundsGroupsAttrStrName(),
call    0 returned 100%
     1086: 3466:                      builder.getI32TensorAttr(lbGroups));
call    0 returned 100%
     1086: 3467:  result.addAttribute(getUpperBoundsMapAttrStrName(),
call    0 returned 100%
     1086: 3468:                      AffineMapAttr::get(ubMap));
call    0 returned 100%
     1086: 3469:  result.addAttribute(getUpperBoundsGroupsAttrStrName(),
call    0 returned 100%
     1086: 3470:                      builder.getI32TensorAttr(ubGroups));
call    0 returned 100%
     1086: 3471:  result.addAttribute(getStepsAttrStrName(), builder.getI64ArrayAttr(steps));
call    0 returned 100%
call    1 returned 100%
     1086: 3472:  result.addOperands(lbArgs);
call    0 returned 100%
     1086: 3473:  result.addOperands(ubArgs);
call    0 returned 100%
        -: 3474:
        -: 3475:  // Create a region and a block for the body.
     1086: 3476:  auto *bodyRegion = result.addRegion();
call    0 returned 100%
     1086: 3477:  auto *body = new Block();
call    0 returned 100%
call    1 returned 100%
        -: 3478:  // Add all the block arguments.
     2172: 3479:  for (unsigned i = 0, e = steps.size(); i < e; ++i)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1086: 3480:    body->addArgument(IndexType::get(builder.getContext()), result.location);
call    0 returned 100%
call    1 returned 100%
     1086: 3481:  bodyRegion->push_back(body);
call    0 returned 100%
     1086: 3482:  if (resultTypes.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1086: 3483:    ensureTerminator(*bodyRegion, builder, result.location);
call    0 returned 100%
     1086: 3484:}
        -: 3485:
function _ZN4mlir16AffineParallelOp11getLoopBodyEv called 0 returned 0% blocks executed 0%
    #####: 3486:Region &AffineParallelOp::getLoopBody() { return getRegion(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3487:
function _ZN4mlir16AffineParallelOp10getNumDimsEv called 5100 returned 100% blocks executed 75%
     5100: 3488:unsigned AffineParallelOp::getNumDims() { return getSteps().size(); }
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3489:
function _ZN4mlir16AffineParallelOp22getLowerBoundsOperandsEv called 7036 returned 100% blocks executed 100%
     7036: 3490:AffineParallelOp::operand_range AffineParallelOp::getLowerBoundsOperands() {
    14072: 3491:  return getOperands().take_front(getLowerBoundsMap().getNumInputs());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 3492:}
        -: 3493:
function _ZN4mlir16AffineParallelOp22getUpperBoundsOperandsEv called 7036 returned 100% blocks executed 100%
     7036: 3494:AffineParallelOp::operand_range AffineParallelOp::getUpperBoundsOperands() {
    14072: 3495:  return getOperands().drop_front(getLowerBoundsMap().getNumInputs());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 3496:}
        -: 3497:
function _ZN4mlir16AffineParallelOp16getLowerBoundMapEj called 0 returned 0% blocks executed 0%
    #####: 3498:AffineMap AffineParallelOp::getLowerBoundMap(unsigned pos) {
    #####: 3499:  auto values = getLowerBoundsGroups().getValues<int32_t>();
call    0 never executed
call    1 never executed
    #####: 3500:  unsigned start = 0;
    #####: 3501:  for (unsigned i = 0; i < pos; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3502:    start += values[i];
branch  0 never executed
branch  1 never executed
    #####: 3503:  return getLowerBoundsMap().getSliceMap(start, values[pos]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3504:}
        -: 3505:
function _ZN4mlir16AffineParallelOp16getUpperBoundMapEj called 0 returned 0% blocks executed 0%
    #####: 3506:AffineMap AffineParallelOp::getUpperBoundMap(unsigned pos) {
    #####: 3507:  auto values = getUpperBoundsGroups().getValues<int32_t>();
call    0 never executed
call    1 never executed
    #####: 3508:  unsigned start = 0;
    #####: 3509:  for (unsigned i = 0; i < pos; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3510:    start += values[i];
branch  0 never executed
branch  1 never executed
    #####: 3511:  return getUpperBoundsMap().getSliceMap(start, values[pos]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3512:}
        -: 3513:
function _ZN4mlir16AffineParallelOp22getLowerBoundsValueMapEv called 73 returned 100% blocks executed 100%
       73: 3514:AffineValueMap AffineParallelOp::getLowerBoundsValueMap() {
      146: 3515:  return AffineValueMap(getLowerBoundsMap(), getLowerBoundsOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 3516:}
        -: 3517:
function _ZN4mlir16AffineParallelOp22getUpperBoundsValueMapEv called 73 returned 100% blocks executed 100%
       73: 3518:AffineValueMap AffineParallelOp::getUpperBoundsValueMap() {
      146: 3519:  return AffineValueMap(getUpperBoundsMap(), getUpperBoundsOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 3520:}
        -: 3521:
function _ZN4mlir16AffineParallelOp17getConstantRangesEv called 0 returned 0% blocks executed 0%
    #####: 3522:Optional<SmallVector<int64_t, 8>> AffineParallelOp::getConstantRanges() {
    #####: 3523:  if (hasMinMaxBounds())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3524:    return llvm::None;
        -: 3525:
        -: 3526:  // Try to convert all the ranges to constant expressions.
    #####: 3527:  SmallVector<int64_t, 8> out;
call    0 never executed
    #####: 3528:  AffineValueMap rangesValueMap;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3529:  AffineValueMap::difference(getUpperBoundsValueMap(), getLowerBoundsValueMap(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3530:                             &rangesValueMap);
    #####: 3531:  out.reserve(rangesValueMap.getNumResults());
branch  0 never executed
branch  1 never executed
    #####: 3532:  for (unsigned i = 0, e = rangesValueMap.getNumResults(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 3533:    auto expr = rangesValueMap.getResult(i);
call    0 never executed
    #####: 3534:    auto cst = expr.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####: 3535:    if (!cst)
branch  0 never executed
branch  1 never executed
    #####: 3536:      return llvm::None;
    #####: 3537:    out.push_back(cst.getValue());
call    0 never executed
call    1 never executed
        -: 3538:  }
    #####: 3539:  return out;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3540:}
        -: 3541:
function _ZN4mlir16AffineParallelOp7getBodyEv called 9135 returned 100% blocks executed 100%
     9135: 3542:Block *AffineParallelOp::getBody() { return &getRegion().front(); }
call    0 returned 100%
call    1 returned 100%
        -: 3543:
function _ZN4mlir16AffineParallelOp14getBodyBuilderEv called 0 returned 0% blocks executed 0%
    #####: 3544:OpBuilder AffineParallelOp::getBodyBuilder() {
    #####: 3545:  return OpBuilder(getBody(), std::prev(getBody()->end()));
call    0 never executed
call    1 never executed
        -: 3546:}
        -: 3547:
function _ZN4mlir16AffineParallelOp14setLowerBoundsENS_10ValueRangeENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 3548:void AffineParallelOp::setLowerBounds(ValueRange lbOperands, AffineMap map) {
    #####: 3549:  assert(lbOperands.size() == map.getNumInputs() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3550:         "operands to map must match number of inputs");
        -: 3551:
    #####: 3552:  auto ubOperands = getUpperBoundsOperands();
call    0 never executed
        -: 3553:
    #####: 3554:  SmallVector<Value, 4> newOperands(lbOperands);
call    0 never executed
    #####: 3555:  newOperands.append(ubOperands.begin(), ubOperands.end());
call    0 never executed
    #####: 3556:  (*this)->setOperands(newOperands);
call    0 never executed
call    1 never executed
        -: 3557:
    #####: 3558:  setLowerBoundsMapAttr(AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3559:}
        -: 3560:
function _ZN4mlir16AffineParallelOp14setUpperBoundsENS_10ValueRangeENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 3561:void AffineParallelOp::setUpperBounds(ValueRange ubOperands, AffineMap map) {
    #####: 3562:  assert(ubOperands.size() == map.getNumInputs() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3563:         "operands to map must match number of inputs");
        -: 3564:
    #####: 3565:  SmallVector<Value, 4> newOperands(getLowerBoundsOperands());
call    0 never executed
call    1 never executed
    #####: 3566:  newOperands.append(ubOperands.begin(), ubOperands.end());
call    0 never executed
    #####: 3567:  (*this)->setOperands(newOperands);
call    0 never executed
call    1 never executed
        -: 3568:
    #####: 3569:  setUpperBoundsMapAttr(AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3570:}
        -: 3571:
function _ZN4mlir16AffineParallelOp8setStepsEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 3572:void AffineParallelOp::setSteps(ArrayRef<int64_t> newSteps) {
    #####: 3573:  setStepsAttr(getBodyBuilder().getI64ArrayAttr(newSteps));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3574:}
        -: 3575:
function _ZN4mlir16AffineParallelOp6verifyEv called 5094 returned 100% blocks executed 52%
     5094: 3576:LogicalResult AffineParallelOp::verify() {
     5094: 3577:  auto numDims = getNumDims();
call    0 returned 100%
    10188: 3578:  if (getLowerBoundsGroups().getNumElements() != numDims ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    10188: 3579:      getUpperBoundsGroups().getNumElements() != numDims ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   20376*: 3580:      getSteps().size() != numDims || getBody()->getNumArguments() != numDims) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
call    6 returned 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 never executed
branch 10 never executed
branch 11 taken 0% (fallthrough)
branch 12 taken 100%
    #####: 3581:    return emitOpError() << "the number of region arguments ("
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3582:                         << getBody()->getNumArguments()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3583:                         << ") and the number of map groups for lower ("
call    0 never executed
    #####: 3584:                         << getLowerBoundsGroups().getNumElements()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3585:                         << ") and upper bound ("
call    0 never executed
    #####: 3586:                         << getUpperBoundsGroups().getNumElements()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3587:                         << "), and the number of steps (" << getSteps().size()
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 3588:                         << ") must all match";
call    0 never executed
        -: 3589:  }
        -: 3590:
     5094: 3591:  unsigned expectedNumLBResults = 0;
    20376: 3592:  for (APInt v : getLowerBoundsGroups())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
     5094: 3593:    expectedNumLBResults += v.getZExtValue();
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    10188: 3594:  if (expectedNumLBResults != getLowerBoundsMap().getNumResults())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
    #####: 3595:    return emitOpError() << "expected lower bounds map to have "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 3596:                         << expectedNumLBResults << " results";
call    0 never executed
call    1 never executed
     5094: 3597:  unsigned expectedNumUBResults = 0;
    20376: 3598:  for (APInt v : getUpperBoundsGroups())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
     5094: 3599:    expectedNumUBResults += v.getZExtValue();
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    10188: 3600:  if (expectedNumUBResults != getUpperBoundsMap().getNumResults())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
    #####: 3601:    return emitOpError() << "expected upper bounds map to have "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 3602:                         << expectedNumUBResults << " results";
call    0 never executed
call    1 never executed
        -: 3603:
     5094: 3604:  if (getReductions().size() != getNumResults())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3605:    return emitOpError("a reduction must be specified for each output");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3606:
        -: 3607:  // Verify reduction  ops are all valid
    5094*: 3608:  for (Attribute attr : getReductions()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 3609:    auto intAttr = attr.dyn_cast<IntegerAttr>();
call    0 never executed
    #####: 3610:    if (!intAttr || !arith::symbolizeAtomicRMWKind(intAttr.getInt()))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3611:      return emitOpError("invalid reduction attribute");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3612:  }
        -: 3613:
        -: 3614:  // Verify that the bound operands are valid dimension/symbols.
        -: 3615:  /// Lower bounds.
    10188: 3616:  if (failed(verifyDimAndSymbolIdentifiers(*this, getLowerBoundsOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    10188: 3617:                                           getLowerBoundsMap().getNumDims())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3618:    return failure();
        -: 3619:  /// Upper bounds.
    10188: 3620:  if (failed(verifyDimAndSymbolIdentifiers(*this, getUpperBoundsOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    10188: 3621:                                           getUpperBoundsMap().getNumDims())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3622:    return failure();
     5094: 3623:  return success();
        -: 3624:}
        -: 3625:
function _ZN4mlir14AffineValueMap12canonicalizeEv called 146 returned 100% blocks executed 60%
      146: 3626:LogicalResult AffineValueMap::canonicalize() {
      146: 3627:  SmallVector<Value, 4> newOperands{operands};
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      146: 3628:  auto newMap = getAffineMap();
call    0 returned 100%
      146: 3629:  composeAffineMapAndOperands(&newMap, &newOperands);
call    0 returned 100%
     292*: 3630:  if (newMap == getAffineMap() && newOperands == operands)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      146: 3631:    return failure();
    #####: 3632:  reset(newMap, newOperands);
call    0 never executed
call    1 never executed
call    2 never executed
     146*: 3633:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3634:}
        -: 3635:
        -: 3636:/// Canonicalize the bounds of the given loop.
function _ZL22canonicalizeLoopBoundsN4mlir16AffineParallelOpE called 73 returned 100% blocks executed 41%
       73: 3637:static LogicalResult canonicalizeLoopBounds(AffineParallelOp op) {
      146: 3638:  AffineValueMap lb = op.getLowerBoundsValueMap();
call    0 returned 100%
call    1 returned 100%
       73: 3639:  bool lbCanonicalized = succeeded(lb.canonicalize());
call    0 returned 100%
        -: 3640:
       73: 3641:  AffineValueMap ub = op.getUpperBoundsValueMap();
call    0 returned 100%
       73: 3642:  bool ubCanonicalized = succeeded(ub.canonicalize());
call    0 returned 100%
        -: 3643:
        -: 3644:  // Any canonicalization change always leads to updated map(s).
       73: 3645:  if (!lbCanonicalized && !ubCanonicalized)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       73: 3646:    return failure();
        -: 3647:
    #####: 3648:  if (lbCanonicalized)
branch  0 never executed
branch  1 never executed
    #####: 3649:    op.setLowerBounds(lb.getOperands(), lb.getAffineMap());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3650:  if (ubCanonicalized)
branch  0 never executed
branch  1 never executed
    #####: 3651:    op.setUpperBounds(ub.getOperands(), ub.getAffineMap());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3652:
      73*: 3653:  return success();
call    0 returned 100%
        -: 3654:}
        -: 3655:
function _ZN4mlir16AffineParallelOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 3656:LogicalResult AffineParallelOp::fold(ArrayRef<Attribute> operands,
        -: 3657:                                     SmallVectorImpl<OpFoldResult> &results) {
    #####: 3658:  return canonicalizeLoopBounds(*this);
call    0 never executed
        -: 3659:}
        -: 3660:
        -: 3661:/// Prints a lower(upper) bound of an affine parallel loop with max(min)
        -: 3662:/// conditions in it. `mapAttr` is a flat list of affine expressions and `group`
        -: 3663:/// identifies which of the those expressions form max/min groups. `operands`
        -: 3664:/// are the SSA values of dimensions and symbols and `keyword` is either "min"
        -: 3665:/// or "max".
function _ZL16printMinMaxBoundRN4mlir12OpAsmPrinterENS_13AffineMapAttrENS_20DenseIntElementsAttrENS_10ValueRangeEN4llvm9StringRefE called 3738 returned 100% blocks executed 62%
     3738: 3666:static void printMinMaxBound(OpAsmPrinter &p, AffineMapAttr mapAttr,
        -: 3667:                             DenseIntElementsAttr group, ValueRange operands,
        -: 3668:                             StringRef keyword) {
     3738: 3669:  AffineMap map = mapAttr.getValue();
call    0 returned 100%
     3738: 3670:  unsigned numDims = map.getNumDims();
call    0 returned 100%
     3738: 3671:  ValueRange dimOperands = operands.take_front(numDims);
call    0 returned 100%
     3738: 3672:  ValueRange symOperands = operands.drop_front(numDims);
call    0 returned 100%
     3738: 3673:  unsigned start = 0;
    14952: 3674:  for (llvm::APInt groupSize : group) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
     3738: 3675:    if (start != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3676:      p << ", ";
call    0 never executed
        -: 3677:
     3738: 3678:    unsigned size = groupSize.getZExtValue();
call    0 returned 100%
     3738: 3679:    if (size == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3738: 3680:      p.printAffineExprOfSSAIds(map.getResult(start), dimOperands, symOperands);
call    0 returned 100%
call    1 returned 100%
     3738: 3681:      ++start;
        -: 3682:    } else {
    #####: 3683:      p << keyword << '(';
call    0 never executed
call    1 never executed
    #####: 3684:      AffineMap submap = map.getSliceMap(start, size);
call    0 never executed
    #####: 3685:      p.printAffineMapOfSSAIds(AffineMapAttr::get(submap), operands);
call    0 never executed
call    1 never executed
    #####: 3686:      p << ')';
call    0 never executed
    #####: 3687:      start += size;
        -: 3688:    }
        -: 3689:  }
     3738: 3690:}
        -: 3691:
function _ZN4mlir16AffineParallelOp5printERNS_12OpAsmPrinterE called 1869 returned 100% blocks executed 60%
     1869: 3692:void AffineParallelOp::print(OpAsmPrinter &p) {
     3738: 3693:  p << " (" << getBody()->getArguments() << ") = (";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1869: 3694:  printMinMaxBound(p, getLowerBoundsMapAttr(), getLowerBoundsGroupsAttr(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 3695:                   getLowerBoundsOperands(), "max");
     1869: 3696:  p << ") to (";
call    0 returned 100%
     1869: 3697:  printMinMaxBound(p, getUpperBoundsMapAttr(), getUpperBoundsGroupsAttr(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 3698:                   getUpperBoundsOperands(), "min");
     1869: 3699:  p << ')';
call    0 returned 100%
     1869: 3700:  SmallVector<int64_t, 8> steps = getSteps();
call    0 returned 100%
     1869: 3701:  bool elideSteps = llvm::all_of(steps, [](int64_t step) { return step == 1; });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1869: 3702:  if (!elideSteps) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3703:    p << " step (";
call    0 never executed
    #####: 3704:    llvm::interleaveComma(steps, p);
call    0 never executed
    #####: 3705:    p << ')';
call    0 never executed
        -: 3706:  }
     1869: 3707:  if (getNumResults()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3708:    p << " reduce (";
call    0 never executed
function _ZZN4mlir16AffineParallelOp5printERNS_12OpAsmPrinterEENKUlRT_E0_clIKNS_9AttributeEEEDaS4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3709:    llvm::interleaveComma(getReductions(), p, [&](auto &attr) {
call    0 never executed
call    1 never executed
    #####: 3710:      arith::AtomicRMWKind sym = *arith::symbolizeAtomicRMWKind(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3711:          attr.template cast<IntegerAttr>().getInt());
call    0 never executed
    #####: 3712:      p << "\"" << arith::stringifyAtomicRMWKind(sym) << "\"";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3713:    });
    #####: 3714:    p << ") -> (" << getResultTypes() << ")";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -: 3715:  }
        -: 3716:
     1869: 3717:  p << ' ';
call    0 returned 100%
     1869: 3718:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
call    0 returned 100%
     1869: 3719:                /*printBlockTerminators=*/getNumResults());
call    0 returned 100%
     1869: 3720:  p.printOptionalAttrDict(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3721:      (*this)->getAttrs(),
     1869: 3722:      /*elidedAttrs=*/{AffineParallelOp::getReductionsAttrStrName(),
call    0 returned 100%
     1869: 3723:                       AffineParallelOp::getLowerBoundsMapAttrStrName(),
call    0 returned 100%
     1869: 3724:                       AffineParallelOp::getLowerBoundsGroupsAttrStrName(),
call    0 returned 100%
     1869: 3725:                       AffineParallelOp::getUpperBoundsMapAttrStrName(),
call    0 returned 100%
     1869: 3726:                       AffineParallelOp::getUpperBoundsGroupsAttrStrName(),
call    0 returned 100%
     1869: 3727:                       AffineParallelOp::getStepsAttrStrName()});
call    0 returned 100%
     1869: 3728:}
        -: 3729:
        -: 3730:/// Given a list of lists of parsed operands, populates `uniqueOperands` with
        -: 3731:/// unique operands. Also populates `replacements with affine expressions of
        -: 3732:/// `kind` that can be used to update affine maps previously accepting a
        -: 3733:/// `operands` to accept `uniqueOperands` instead.
function _ZL29deduplicateAndResolveOperandsRN4mlir11OpAsmParserEN4llvm8ArrayRefINS2_11SmallVectorINS0_17UnresolvedOperandELj1EEEEERNS2_15SmallVectorImplINS_5ValueEEERNS8_INS_10AffineExprEEENS_14AffineExprKindE called 0 returned 0% blocks executed 0%
    #####: 3734:static ParseResult deduplicateAndResolveOperands(
        -: 3735:    OpAsmParser &parser,
        -: 3736:    ArrayRef<SmallVector<OpAsmParser::UnresolvedOperand>> operands,
        -: 3737:    SmallVectorImpl<Value> &uniqueOperands,
        -: 3738:    SmallVectorImpl<AffineExpr> &replacements, AffineExprKind kind) {
    #####: 3739:  assert((kind == AffineExprKind::DimId || kind == AffineExprKind::SymbolId) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3740:         "expected operands to be dim or symbol expression");
        -: 3741:
    #####: 3742:  Type indexType = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####: 3743:  for (const auto &list : operands) {
branch  0 never executed
branch  1 never executed
    #####: 3744:    SmallVector<Value> valueOperands;
call    0 never executed
    #####: 3745:    if (parser.resolveOperands(list, indexType, valueOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3746:      return failure();
branch  0 never executed
branch  1 never executed
    #####: 3747:    for (Value operand : valueOperands) {
branch  0 never executed
branch  1 never executed
    #####: 3748:      unsigned pos = std::distance(uniqueOperands.begin(),
branch  0 never executed
branch  1 never executed
    #####: 3749:                                   llvm::find(uniqueOperands, operand));
    #####: 3750:      if (pos == uniqueOperands.size())
branch  0 never executed
branch  1 never executed
    #####: 3751:        uniqueOperands.push_back(operand);
call    0 never executed
    #####: 3752:      replacements.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3753:          kind == AffineExprKind::DimId
    #####: 3754:              ? getAffineDimExpr(pos, parser.getContext())
call    0 never executed
call    1 never executed
    #####: 3755:              : getAffineSymbolExpr(pos, parser.getContext()));
call    0 never executed
call    1 never executed
        -: 3756:    }
        -: 3757:  }
    #####: 3758:  return success();
        -: 3759:}
        -: 3760:
        -: 3761:namespace {
        -: 3762:enum class MinMaxKind { Min, Max };
        -: 3763:} // namespace
        -: 3764:
        -: 3765:/// Parses an affine map that can contain a min/max for groups of its results,
        -: 3766:/// e.g., max(expr-1, expr-2), expr-3, max(expr-4, expr-5, expr-6). Populates
        -: 3767:/// `result` attributes with the map (flat list of expressions) and the grouping
        -: 3768:/// (list of integers that specify how many expressions to put into each
        -: 3769:/// min/max) attributes. Deduplicates repeated operands.
        -: 3770:///
        -: 3771:/// parallel-bound       ::= `(` parallel-group-list `)`
        -: 3772:/// parallel-group-list  ::= parallel-group (`,` parallel-group-list)?
        -: 3773:/// parallel-group       ::= simple-group | min-max-group
        -: 3774:/// simple-group         ::= expr-of-ssa-ids
        -: 3775:/// min-max-group        ::= ( `min` | `max` ) `(` expr-of-ssa-ids-list `)`
        -: 3776:/// expr-of-ssa-ids-list ::= expr-of-ssa-ids (`,` expr-of-ssa-id-list)?
        -: 3777:///
        -: 3778:/// Examples:
        -: 3779:///   (%0, min(%1 + %2, %3), %4, min(%5 floordiv 32, %6))
        -: 3780:///   (%0, max(%1 - 2 * %2))
function _ZL24parseAffineMapWithMinMaxRN4mlir11OpAsmParserERNS_14OperationStateEN12_GLOBAL__N_110MinMaxKindE called 0 returned 0% blocks executed 0%
    #####: 3781:static ParseResult parseAffineMapWithMinMax(OpAsmParser &parser,
        -: 3782:                                            OperationState &result,
        -: 3783:                                            MinMaxKind kind) {
        -: 3784:  // Using `const` not `constexpr` below to workaround a MSVC optimizer bug,
        -: 3785:  // see: https://reviews.llvm.org/D134227#3821753
    #####: 3786:  const llvm::StringLiteral tmpAttrStrName = "__pseudo_bound_map";
        -: 3787:
    #####: 3788:  StringRef mapName = kind == MinMaxKind::Min
    #####: 3789:                          ? AffineParallelOp::getUpperBoundsMapAttrStrName()
    #####: 3790:                          : AffineParallelOp::getLowerBoundsMapAttrStrName();
branch  0 never executed
branch  1 never executed
    #####: 3791:  StringRef groupsName =
        -: 3792:      kind == MinMaxKind::Min
    #####: 3793:          ? AffineParallelOp::getUpperBoundsGroupsAttrStrName()
    #####: 3794:          : AffineParallelOp::getLowerBoundsGroupsAttrStrName();
branch  0 never executed
branch  1 never executed
        -: 3795:
    #####: 3796:  if (failed(parser.parseLParen()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3797:    return failure();
        -: 3798:
    #####: 3799:  if (succeeded(parser.parseOptionalRParen())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3800:    result.addAttribute(
call    0 never executed
    #####: 3801:        mapName, AffineMapAttr::get(parser.getBuilder().getEmptyAffineMap()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3802:    result.addAttribute(groupsName, parser.getBuilder().getI32TensorAttr({}));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3803:    return success();
        -: 3804:  }
        -: 3805:
    #####: 3806:  SmallVector<AffineExpr> flatExprs;
call    0 never executed
    #####: 3807:  SmallVector<SmallVector<OpAsmParser::UnresolvedOperand>> flatDimOperands;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3808:  SmallVector<SmallVector<OpAsmParser::UnresolvedOperand>> flatSymOperands;
    #####: 3809:  SmallVector<int32_t> numMapsPerGroup;
call    0 never executed
    #####: 3810:  SmallVector<OpAsmParser::UnresolvedOperand> mapOperands;
branch  0 never executed
branch  1 never executed
function _ZZL24parseAffineMapWithMinMaxRN4mlir11OpAsmParserERNS_14OperationStateEN12_GLOBAL__N_110MinMaxKindEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####: 3811:  auto parseOperands = [&]() {
    #####: 3812:    if (succeeded(parser.parseOptionalKeyword(
    #####: 3813:            kind == MinMaxKind::Min ? "min" : "max"))) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3814:      mapOperands.clear();
call    0 never executed
    #####: 3815:      AffineMapAttr map;
    #####: 3816:      if (failed(parser.parseAffineMapOfSSAIds(mapOperands, map, tmpAttrStrName,
branch  0 never executed
branch  1 never executed
    #####: 3817:                                               result.attributes,
    #####: 3818:                                               OpAsmParser::Delimiter::Paren)))
call    0 never executed
    #####: 3819:        return failure();
    #####: 3820:      result.attributes.erase(tmpAttrStrName);
call    0 never executed
    #####: 3821:      llvm::append_range(flatExprs, map.getValue().getResults());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3822:      auto operandsRef = llvm::makeArrayRef(mapOperands);
call    0 never executed
    #####: 3823:      auto dimsRef = operandsRef.take_front(map.getValue().getNumDims());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3824:      SmallVector<OpAsmParser::UnresolvedOperand> dims(dimsRef.begin(),
    #####: 3825:                                                       dimsRef.end());
call    0 never executed
    #####: 3826:      auto symsRef = operandsRef.drop_front(map.getValue().getNumDims());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3827:      SmallVector<OpAsmParser::UnresolvedOperand> syms(symsRef.begin(),
    #####: 3828:                                                       symsRef.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3829:      flatDimOperands.append(map.getValue().getNumResults(), dims);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3830:      flatSymOperands.append(map.getValue().getNumResults(), syms);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3831:      numMapsPerGroup.push_back(map.getValue().getNumResults());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3832:    } else {
    #####: 3833:      if (failed(parser.parseAffineExprOfSSAIds(flatDimOperands.emplace_back(),
branch  0 never executed
branch  1 never executed
    #####: 3834:                                                flatSymOperands.emplace_back(),
call    0 never executed
    #####: 3835:                                                flatExprs.emplace_back())))
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3836:        return failure();
    #####: 3837:      numMapsPerGroup.push_back(1);
call    0 never executed
        -: 3838:    }
    #####: 3839:    return success();
    #####: 3840:  };
    #####: 3841:  if (parser.parseCommaSeparatedList(parseOperands) || parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3842:    return failure();
        -: 3843:
    #####: 3844:  unsigned totalNumDims = 0;
    #####: 3845:  unsigned totalNumSyms = 0;
    #####: 3846:  for (unsigned i = 0, e = flatExprs.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 3847:    unsigned numDims = flatDimOperands[i].size();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3848:    unsigned numSyms = flatSymOperands[i].size();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3849:    flatExprs[i] = flatExprs[i]
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3850:                       .shiftDims(numDims, totalNumDims)
call    0 never executed
    #####: 3851:                       .shiftSymbols(numSyms, totalNumSyms);
call    0 never executed
    #####: 3852:    totalNumDims += numDims;
    #####: 3853:    totalNumSyms += numSyms;
        -: 3854:  }
        -: 3855:
        -: 3856:  // Deduplicate map operands.
    #####: 3857:  SmallVector<Value> dimOperands, symOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3858:  SmallVector<AffineExpr> dimRplacements, symRepacements;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3859:  if (deduplicateAndResolveOperands(parser, flatDimOperands, dimOperands,
call    0 never executed
    #####: 3860:                                    dimRplacements, AffineExprKind::DimId) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3861:      deduplicateAndResolveOperands(parser, flatSymOperands, symOperands,
    #####: 3862:                                    symRepacements, AffineExprKind::SymbolId))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3863:    return failure();
        -: 3864:
    #####: 3865:  result.operands.append(dimOperands.begin(), dimOperands.end());
call    0 never executed
    #####: 3866:  result.operands.append(symOperands.begin(), symOperands.end());
call    0 never executed
        -: 3867:
    #####: 3868:  Builder &builder = parser.getBuilder();
call    0 never executed
    #####: 3869:  auto flatMap = AffineMap::get(totalNumDims, totalNumSyms, flatExprs,
    #####: 3870:                                parser.getContext());
call    0 never executed
call    1 never executed
    #####: 3871:  flatMap = flatMap.replaceDimsAndSymbols(
    #####: 3872:      dimRplacements, symRepacements, dimOperands.size(), symOperands.size());
call    0 never executed
        -: 3873:
    #####: 3874:  result.addAttribute(mapName, AffineMapAttr::get(flatMap));
call    0 never executed
call    1 never executed
    #####: 3875:  result.addAttribute(groupsName, builder.getI32TensorAttr(numMapsPerGroup));
call    0 never executed
call    1 never executed
    #####: 3876:  return success();
        -: 3877:}
        -: 3878:
        -: 3879://
        -: 3880:// operation ::= `affine.parallel` `(` ssa-ids `)` `=` parallel-bound
        -: 3881://               `to` parallel-bound steps? region attr-dict?
        -: 3882:// steps     ::= `steps` `(` integer-literals `)`
        -: 3883://
function _ZN4mlir16AffineParallelOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3884:ParseResult AffineParallelOp::parse(OpAsmParser &parser,
        -: 3885:                                    OperationState &result) {
    #####: 3886:  auto &builder = parser.getBuilder();
call    0 never executed
    #####: 3887:  auto indexType = builder.getIndexType();
call    0 never executed
    #####: 3888:  SmallVector<OpAsmParser::Argument, 4> ivs;
call    0 never executed
    #####: 3889:  if (parser.parseArgumentList(ivs, OpAsmParser::Delimiter::Paren) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3890:      parser.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3891:      parseAffineMapWithMinMax(parser, result, MinMaxKind::Max) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3892:      parser.parseKeyword("to") ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 3893:      parseAffineMapWithMinMax(parser, result, MinMaxKind::Min))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3894:    return failure();
        -: 3895:
    #####: 3896:  AffineMapAttr stepsMapAttr;
    #####: 3897:  NamedAttrList stepsAttrs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3898:  SmallVector<OpAsmParser::UnresolvedOperand, 4> stepsMapOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3899:  if (failed(parser.parseOptionalKeyword("step"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3900:    SmallVector<int64_t, 4> steps(ivs.size(), 1);
call    0 never executed
    #####: 3901:    result.addAttribute(AffineParallelOp::getStepsAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 3902:                        builder.getI64ArrayAttr(steps));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3903:  } else {
    #####: 3904:    if (parser.parseAffineMapOfSSAIds(stepsMapOperands, stepsMapAttr,
branch  0 never executed
branch  1 never executed
        -: 3905:                                      AffineParallelOp::getStepsAttrStrName(),
        -: 3906:                                      stepsAttrs,
    #####: 3907:                                      OpAsmParser::Delimiter::Paren))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3908:      return failure();
        -: 3909:
        -: 3910:    // Convert steps from an AffineMap into an I64ArrayAttr.
    #####: 3911:    SmallVector<int64_t, 4> steps;
call    0 never executed
    #####: 3912:    auto stepsMap = stepsMapAttr.getValue();
call    0 never executed
    #####: 3913:    for (const auto &result : stepsMap.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3914:      auto constExpr = result.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####: 3915:      if (!constExpr)
branch  0 never executed
branch  1 never executed
    #####: 3916:        return parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3917:                                "steps must be constant integers");
call    0 never executed
call    1 never executed
    #####: 3918:      steps.push_back(constExpr.getValue());
call    0 never executed
call    1 never executed
        -: 3919:    }
    #####: 3920:    result.addAttribute(AffineParallelOp::getStepsAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 3921:                        builder.getI64ArrayAttr(steps));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3922:  }
        -: 3923:
        -: 3924:  // Parse optional clause of the form: `reduce ("addf", "maxf")`, where the
        -: 3925:  // quoted strings are a member of the enum AtomicRMWKind.
    #####: 3926:  SmallVector<Attribute, 4> reductions;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3927:  if (succeeded(parser.parseOptionalKeyword("reduce"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3928:    if (parser.parseLParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3929:      return failure();
function _ZZN4mlir16AffineParallelOp5parseERNS_11OpAsmParserERNS_14OperationStateEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####: 3930:    auto parseAttributes = [&]() -> ParseResult {
        -: 3931:      // Parse a single quoted string via the attribute parsing, and then
        -: 3932:      // verify it is a member of the enum and convert to it's integer
        -: 3933:      // representation.
    #####: 3934:      StringAttr attrVal;
    #####: 3935:      NamedAttrList attrStorage;
call    0 never executed
    #####: 3936:      auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 3937:      if (parser.parseAttribute(attrVal, builder.getNoneType(), "reduce",
branch  0 never executed
branch  1 never executed
    #####: 3938:                                attrStorage))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3939:        return failure();
    #####: 3940:      llvm::Optional<arith::AtomicRMWKind> reduction =
    #####: 3941:          arith::symbolizeAtomicRMWKind(attrVal.getValue());
call    0 never executed
call    1 never executed
    #####: 3942:      if (!reduction)
branch  0 never executed
branch  1 never executed
    #####: 3943:        return parser.emitError(loc, "invalid reduction value: ") << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 3944:      reductions.push_back(
call    0 never executed
call    1 never executed
    #####: 3945:          builder.getI64IntegerAttr(static_cast<int64_t>(reduction.value())));
call    0 never executed
        -: 3946:      // While we keep getting commas, keep parsing.
    #####: 3947:      return success();
    #####: 3948:    };
    #####: 3949:    if (parser.parseCommaSeparatedList(parseAttributes) || parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3950:      return failure();
        -: 3951:  }
    #####: 3952:  result.addAttribute(AffineParallelOp::getReductionsAttrStrName(),
call    0 never executed
call    1 never executed
    #####: 3953:                      builder.getArrayAttr(reductions));
call    0 never executed
        -: 3954:
        -: 3955:  // Parse return types of reductions (if any)
    #####: 3956:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3957:    return failure();
        -: 3958:
        -: 3959:  // Now parse the body.
    #####: 3960:  Region *body = result.addRegion();
call    0 never executed
    #####: 3961:  for (auto &iv : ivs)
branch  0 never executed
branch  1 never executed
    #####: 3962:    iv.type = indexType;
    #####: 3963:  if (parser.parseRegion(*body, ivs) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3964:      parser.parseOptionalAttrDict(result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3965:    return failure();
        -: 3966:
        -: 3967:  // Add a terminator if none was parsed.
    #####: 3968:  AffineParallelOp::ensureTerminator(*body, builder, result.location);
call    0 never executed
    #####: 3969:  return success();
        -: 3970:}
        -: 3971:
        -: 3972://===----------------------------------------------------------------------===//
        -: 3973:// AffineYieldOp
        -: 3974://===----------------------------------------------------------------------===//
        -: 3975:
function _ZN4mlir13AffineYieldOp6verifyEv called 59487072 returned 100% blocks executed 47%
 59487072: 3976:LogicalResult AffineYieldOp::verify() {
 59487072: 3977:  auto *parentOp = (*this)->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 59487072: 3978:  auto results = parentOp->getResults();
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
 59487072: 3979:  auto operands = getOperands();
call    0 returned 100%
        -: 3980:
 59487072: 3981:  if (!isa<AffineParallelOp, AffineIfOp, AffineForOp>(parentOp))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3982:    return emitOpError() << "only terminates affine.if/for/parallel regions";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 59487072: 3983:  if (parentOp->getNumResults() != getNumOperands())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3984:    return emitOpError() << "parent of yield must have same number of "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3985:                            "results as the yield operands";
call    0 never executed
108622777: 3986:  for (auto it : llvm::zip(results, operands)) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
 49135705: 3987:    if (std::get<0>(it).getType() != std::get<1>(it).getType())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3988:      return emitOpError() << "types mismatch between yield op and its parent";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3989:  }
        -: 3990:
 59487072: 3991:  return success();
        -: 3992:}
        -: 3993:
        -: 3994://===----------------------------------------------------------------------===//
        -: 3995:// AffineVectorLoadOp
        -: 3996://===----------------------------------------------------------------------===//
        -: 3997:
function _ZN4mlir18AffineVectorLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 3998:void AffineVectorLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 3999:                               VectorType resultType, AffineMap map,
        -: 4000:                               ValueRange operands) {
    #####: 4001:  assert(operands.size() == 1 + map.getNumInputs() && "inconsistent operands");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 4002:  result.addOperands(operands);
call    0 never executed
    #####: 4003:  if (map)
branch  0 never executed
branch  1 never executed
    #####: 4004:    result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 never executed
call    1 never executed
    #####: 4005:  result.types.push_back(resultType);
call    0 never executed
    #####: 4006:}
        -: 4007:
function _ZN4mlir18AffineVectorLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_9AffineMapENS_10ValueRangeE called 1598 returned 100% blocks executed 90%
     1598: 4008:void AffineVectorLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 4009:                               VectorType resultType, Value memref,
        -: 4010:                               AffineMap map, ValueRange mapOperands) {
    1598*: 4011:  assert(map.getNumInputs() == mapOperands.size() && "inconsistent index info");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     1598: 4012:  result.addOperands(memref);
call    0 returned 100%
call    1 returned 100%
     1598: 4013:  result.addOperands(mapOperands);
call    0 returned 100%
     1598: 4014:  result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
     1598: 4015:  result.types.push_back(resultType);
call    0 returned 100%
     1598: 4016:}
        -: 4017:
function _ZN4mlir18AffineVectorLoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10VectorTypeENS_5ValueENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 4018:void AffineVectorLoadOp::build(OpBuilder &builder, OperationState &result,
        -: 4019:                               VectorType resultType, Value memref,
        -: 4020:                               ValueRange indices) {
    #####: 4021:  auto memrefType = memref.getType().cast<MemRefType>();
call    0 never executed
    #####: 4022:  int64_t rank = memrefType.getRank();
call    0 never executed
        -: 4023:  // Create identity map for memrefs with at least one dimension or () -> ()
        -: 4024:  // for zero-dimensional memrefs.
    #####: 4025:  auto map =
    #####: 4026:      rank ? builder.getMultiDimIdentityMap(rank) : builder.getEmptyAffineMap();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 4027:  build(builder, result, resultType, memref, map, indices);
call    0 never executed
    #####: 4028:}
        -: 4029:
function _ZN4mlir18AffineVectorLoadOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4030:void AffineVectorLoadOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 4031:                                                     MLIRContext *context) {
     1235: 4032:  results.add<SimplifyAffineOp<AffineVectorLoadOp>>(context);
call    0 returned 100%
     1235: 4033:}
        -: 4034:
function _ZN4mlir18AffineVectorLoadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 183184 returned 100% blocks executed 100%
   183184: 4035:ParseResult AffineVectorLoadOp::parse(OpAsmParser &parser,
        -: 4036:                                      OperationState &result) {
   183184: 4037:  auto &builder = parser.getBuilder();
call    0 returned 100%
   183184: 4038:  auto indexTy = builder.getIndexType();
call    0 returned 100%
        -: 4039:
   183184: 4040:  MemRefType memrefType;
   183184: 4041:  VectorType resultType;
   183184: 4042:  OpAsmParser::UnresolvedOperand memrefInfo;
call    0 returned 100%
   183184: 4043:  AffineMapAttr mapAttr;
   183184: 4044:  SmallVector<OpAsmParser::UnresolvedOperand, 1> mapOperands;
call    0 returned 100%
   183184: 4045:  return failure(
   366368: 4046:      parser.parseOperand(memrefInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   183184: 4047:      parser.parseAffineMapOfSSAIds(mapOperands, mapAttr,
        -: 4048:                                    AffineVectorLoadOp::getMapAttrStrName(),
   366368: 4049:                                    result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4050:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4051:      parser.parseColonType(memrefType) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
   366368: 4052:      parser.parseType(resultType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4053:      parser.resolveOperand(memrefInfo, memrefType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   549552: 4054:      parser.resolveOperands(mapOperands, indexTy, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 61% (fallthrough)
branch  6 taken 39%
   183184: 4055:      parser.addTypeToList(resultType, result.types));
call    0 returned 100%
branch  1 taken 61% (fallthrough)
branch  2 taken 39%
        -: 4056:}
        -: 4057:
function _ZN4mlir18AffineVectorLoadOp5printERNS_12OpAsmPrinterE called 307939 returned 100% blocks executed 100%
   307939: 4058:void AffineVectorLoadOp::print(OpAsmPrinter &p) {
   615878: 4059:  p << " " << getMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   307939: 4060:  if (AffineMapAttr mapAttr =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   307939: 4061:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   307939: 4062:    p.printAffineMapOfSSAIds(mapAttr, getMapOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   307939: 4063:  p << ']';
call    0 returned 100%
   307939: 4064:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
   307939: 4065:                          /*elidedAttrs=*/{getMapAttrStrName()});
call    0 returned 100%
   923817: 4066:  p << " : " << getMemRefType() << ", " << getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
   307939: 4067:}
        -: 4068:
        -: 4069:/// Verify common invariants of affine.vector_load and affine.vector_store.
function _ZL20verifyVectorMemoryOpPN4mlir9OperationENS_10MemRefTypeENS_10VectorTypeE called 13739955 returned 100% blocks executed 50%
 13739955: 4070:static LogicalResult verifyVectorMemoryOp(Operation *op, MemRefType memrefType,
        -: 4071:                                          VectorType vectorType) {
        -: 4072:  // Check that memref and vector element types match.
 13739955: 4073:  if (memrefType.getElementType() != vectorType.getElementType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4074:    return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4075:        "requires memref and vector types of the same elemental type");
call    0 never executed
 13739955: 4076:  return success();
        -: 4077:}
        -: 4078:
function _ZN4mlir18AffineVectorLoadOp6verifyEv called 6870702 returned 100% blocks executed 92%
  6870702: 4079:LogicalResult AffineVectorLoadOp::verify() {
  6870702: 4080:  MemRefType memrefType = getMemRefType();
call    0 returned 100%
  6870702: 4081:  if (failed(verifyMemoryOpIndexing(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        -: 4082:          getOperation(),
        -: 4083:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()),
        -: 4084:          getMapOperands(), memrefType,
  6870702: 4085:          /*numIndexOperands=*/getNumOperands() - 1)))
call    0 returned 100%
      694: 4086:    return failure();
        -: 4087:
  6870008: 4088:  if (failed(verifyVectorMemoryOp(getOperation(), memrefType, getVectorType())))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4089:    return failure();
        -: 4090:
  6870008: 4091:  return success();
        -: 4092:}
        -: 4093:
        -: 4094://===----------------------------------------------------------------------===//
        -: 4095:// AffineVectorStoreOp
        -: 4096://===----------------------------------------------------------------------===//
        -: 4097:
function _ZN4mlir19AffineVectorStoreOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES5_NS_9AffineMapENS_10ValueRangeE called 1585 returned 100% blocks executed 91%
     1585: 4098:void AffineVectorStoreOp::build(OpBuilder &builder, OperationState &result,
        -: 4099:                                Value valueToStore, Value memref, AffineMap map,
        -: 4100:                                ValueRange mapOperands) {
    1585*: 4101:  assert(map.getNumInputs() == mapOperands.size() && "inconsistent index info");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     1585: 4102:  result.addOperands(valueToStore);
call    0 returned 100%
call    1 returned 100%
     1585: 4103:  result.addOperands(memref);
call    0 returned 100%
call    1 returned 100%
     1585: 4104:  result.addOperands(mapOperands);
call    0 returned 100%
     1585: 4105:  result.addAttribute(getMapAttrStrName(), AffineMapAttr::get(map));
call    0 returned 100%
call    1 returned 100%
     1585: 4106:}
        -: 4107:
        -: 4108:// Use identity map.
function _ZN4mlir19AffineVectorStoreOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES5_NS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 4109:void AffineVectorStoreOp::build(OpBuilder &builder, OperationState &result,
        -: 4110:                                Value valueToStore, Value memref,
        -: 4111:                                ValueRange indices) {
    #####: 4112:  auto memrefType = memref.getType().cast<MemRefType>();
call    0 never executed
    #####: 4113:  int64_t rank = memrefType.getRank();
call    0 never executed
        -: 4114:  // Create identity map for memrefs with at least one dimension or () -> ()
        -: 4115:  // for zero-dimensional memrefs.
    #####: 4116:  auto map =
    #####: 4117:      rank ? builder.getMultiDimIdentityMap(rank) : builder.getEmptyAffineMap();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 4118:  build(builder, result, valueToStore, memref, map, indices);
call    0 never executed
    #####: 4119:}
function _ZN4mlir19AffineVectorStoreOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 4120:void AffineVectorStoreOp::getCanonicalizationPatterns(
        -: 4121:    RewritePatternSet &results, MLIRContext *context) {
     1235: 4122:  results.add<SimplifyAffineOp<AffineVectorStoreOp>>(context);
call    0 returned 100%
     1235: 4123:}
        -: 4124:
function _ZN4mlir19AffineVectorStoreOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 183184 returned 100% blocks executed 96%
   183184: 4125:ParseResult AffineVectorStoreOp::parse(OpAsmParser &parser,
        -: 4126:                                       OperationState &result) {
   183184: 4127:  auto indexTy = parser.getBuilder().getIndexType();
call    0 returned 100%
call    1 returned 100%
        -: 4128:
   183184: 4129:  MemRefType memrefType;
   183184: 4130:  VectorType resultType;
   183184: 4131:  OpAsmParser::UnresolvedOperand storeValueInfo;
call    0 returned 100%
   183184: 4132:  OpAsmParser::UnresolvedOperand memrefInfo;
   183184: 4133:  AffineMapAttr mapAttr;
   183184: 4134:  SmallVector<OpAsmParser::UnresolvedOperand, 1> mapOperands;
call    0 returned 100%
   183184: 4135:  return failure(
   366368: 4136:      parser.parseOperand(storeValueInfo) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
   366368: 4137:      parser.parseOperand(memrefInfo) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   183184: 4138:      parser.parseAffineMapOfSSAIds(mapOperands, mapAttr,
        -: 4139:                                    AffineVectorStoreOp::getMapAttrStrName(),
   366368: 4140:                                    result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4141:      parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4142:      parser.parseColonType(memrefType) || parser.parseComma() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
   366368: 4143:      parser.parseType(resultType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   366368: 4144:      parser.resolveOperand(storeValueInfo, resultType, result.operands) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   549552: 4145:      parser.resolveOperand(memrefInfo, memrefType, result.operands) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 65% (fallthrough)
branch  8 taken 35%
   183184: 4146:      parser.resolveOperands(mapOperands, indexTy, result.operands));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 65% (fallthrough)
branch  4 taken 35%
        -: 4147:}
        -: 4148:
function _ZN4mlir19AffineVectorStoreOp5printERNS_12OpAsmPrinterE called 307939 returned 100% blocks executed 100%
   307939: 4149:void AffineVectorStoreOp::print(OpAsmPrinter &p) {
   615878: 4150:  p << " " << getValueToStore();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   615878: 4151:  p << ", " << getMemRef() << '[';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   307939: 4152:  if (AffineMapAttr mapAttr =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   307939: 4153:          (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   307939: 4154:    p.printAffineMapOfSSAIds(mapAttr, getMapOperands());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   307939: 4155:  p << ']';
call    0 returned 100%
   307939: 4156:  p.printOptionalAttrDict((*this)->getAttrs(),
call    0 returned 100%
   307939: 4157:                          /*elidedAttrs=*/{getMapAttrStrName()});
call    0 returned 100%
   923817: 4158:  p << " : " << getMemRefType() << ", " << getValueToStore().getType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
   307939: 4159:}
        -: 4160:
function _ZN4mlir19AffineVectorStoreOp6verifyEv called 6870008 returned 100% blocks executed 92%
  6870008: 4161:LogicalResult AffineVectorStoreOp::verify() {
  6870008: 4162:  MemRefType memrefType = getMemRefType();
call    0 returned 100%
  6870008: 4163:  if (failed(verifyMemoryOpIndexing(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        -: 4164:          *this, (*this)->getAttrOfType<AffineMapAttr>(getMapAttrStrName()),
        -: 4165:          getMapOperands(), memrefType,
  6870008: 4166:          /*numIndexOperands=*/getNumOperands() - 2)))
call    0 returned 100%
       61: 4167:    return failure();
        -: 4168:
  6869947: 4169:  if (failed(verifyVectorMemoryOp(*this, memrefType, getVectorType())))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 4170:    return failure();
        -: 4171:
  6869947: 4172:  return success();
        -: 4173:}
        -: 4174:
        -: 4175://===----------------------------------------------------------------------===//
        -: 4176:// DelinearizeIndexOp
        -: 4177://===----------------------------------------------------------------------===//
        -: 4178:
function _ZN4mlir24AffineDelinearizeIndexOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 4179:void AffineDelinearizeIndexOp::build(OpBuilder &builder, OperationState &result,
        -: 4180:                                     Value linearIndex,
        -: 4181:                                     ArrayRef<OpFoldResult> basis) {
    #####: 4182:  result.addTypes(SmallVector<Type>(basis.size(), builder.getIndexType()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4183:  result.addOperands(linearIndex);
call    0 never executed
call    1 never executed
    #####: 4184:  SmallVector<Value> basisValues =
function _ZZN4mlir24AffineDelinearizeIndexOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEEENKUlS8_E_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 4185:      llvm::to_vector(llvm::map_range(basis, [&](OpFoldResult ofr) -> Value {
    #####: 4186:        Optional<int64_t> staticDim = getConstantIntValue(ofr);
call    0 never executed
    #####: 4187:        if (staticDim.has_value())
branch  0 never executed
branch  1 never executed
    #####: 4188:          return builder.create<arith::ConstantIndexOp>(result.location,
call    0 never executed
    #####: 4189:                                                        *staticDim);
call    0 never executed
    #####: 4190:        return ofr.dyn_cast<Value>();
branch  0 never executed
branch  1 never executed
    #####: 4191:      }));
call    0 never executed
    #####: 4192:  result.addOperands(basisValues);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4193:}
        -: 4194:
function _ZN4mlir24AffineDelinearizeIndexOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4195:LogicalResult AffineDelinearizeIndexOp::verify() {
    #####: 4196:  if (getBasis().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4197:    return emitOpError("basis should not be empty");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4198:  if (getNumResults() != getBasis().size())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4199:    return emitOpError("should return an index for each basis element");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4200:  return success();
        -: 4201:}
        -: 4202:
        -: 4203://===----------------------------------------------------------------------===//
        -: 4204:// TableGen'd op method definitions
        -: 4205://===----------------------------------------------------------------------===//
        -: 4206:
        -: 4207:#define GET_OP_CLASSES
        -: 4208:#include "mlir/Dialect/Affine/IR/AffineOps.cpp.inc"
