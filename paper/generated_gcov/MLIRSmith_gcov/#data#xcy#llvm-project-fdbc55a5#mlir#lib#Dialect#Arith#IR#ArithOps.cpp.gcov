        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/Arith/IR/ArithOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcda
        -:    0:Runs:116157
        -:    1://===- ArithOps.cpp - MLIR Arith dialect ops implementation -----===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include <cassert>
        -:   10:#include <utility>
        -:   11:
        -:   12:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   13:#include "mlir/Dialect/CommonFolders.h"
        -:   14:#include "mlir/IR/Builders.h"
        -:   15:#include "mlir/IR/Matchers.h"
        -:   16:#include "mlir/IR/OpImplementation.h"
        -:   17:#include "mlir/IR/PatternMatch.h"
        -:   18:#include "mlir/IR/TypeUtilities.h"
        -:   19:
        -:   20:#include "llvm/ADT/APSInt.h"
        -:   21:#include "llvm/ADT/SmallString.h"
        -:   22:
        -:   23:using namespace mlir;
        -:   24:using namespace mlir::arith;
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// Floating point op parse/print helpers
        -:   28://===----------------------------------------------------------------------===//
function _ZL22parseArithFastMathAttrRN4mlir11OpAsmParserERNS_9AttributeE called 10582425 returned 100% blocks executed 67%
 10582425:   29:static ParseResult parseArithFastMathAttr(OpAsmParser &parser,
        -:   30:                                          Attribute &attr) {
 21164850:   31:  if (succeeded(
 10582425:   32:          parser.parseOptionalKeyword(FastMathFlagsAttr::getMnemonic()))) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   33:    attr = FastMathFlagsAttr::parse(parser, Type{});
call    0 never executed
    #####:   34:    return success(static_cast<bool>(attr));
        -:   35:  } else {
        -:   36:    // No fastmath attribute mnemonic present - defer attribute creation and use
        -:   37:    // the default value.
 10582425:   38:    return success();
        -:   39:  }
        -:   40:}
        -:   41:
        -:   42:static void printArithFastMathAttr(OpAsmPrinter &printer, Operation *op,
        -:   43:                                   FastMathFlagsAttr fmAttr) {
        -:   44:  // Elide printing the fastmath attribute when fastmath=none
        -:   45:  if (fmAttr && (fmAttr.getValue() != FastMathFlags::none)) {
        -:   46:    printer << " " << FastMathFlagsAttr::getMnemonic();
        -:   47:    fmAttr.print(printer);
        -:   48:  }
        -:   49:}
        -:   50:
        -:   51://===----------------------------------------------------------------------===//
        -:   52:// Pattern helpers
        -:   53://===----------------------------------------------------------------------===//
        -:   54:
function _ZL15addIntegerAttrsRN4mlir15PatternRewriterENS_5ValueENS_9AttributeES3_ called 0 returned 0% blocks executed 0%
    #####:   55:static IntegerAttr addIntegerAttrs(PatternRewriter &builder, Value res,
        -:   56:                                   Attribute lhs, Attribute rhs) {
    #####:   57:  return builder.getIntegerAttr(res.getType(),
    #####:   58:                                lhs.cast<IntegerAttr>().getInt() +
call    0 never executed
call    1 never executed
    #####:   59:                                    rhs.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   60:}
        -:   61:
function _ZL15subIntegerAttrsRN4mlir15PatternRewriterENS_5ValueENS_9AttributeES3_ called 0 returned 0% blocks executed 0%
    #####:   62:static IntegerAttr subIntegerAttrs(PatternRewriter &builder, Value res,
        -:   63:                                   Attribute lhs, Attribute rhs) {
    #####:   64:  return builder.getIntegerAttr(res.getType(),
    #####:   65:                                lhs.cast<IntegerAttr>().getInt() -
call    0 never executed
call    1 never executed
    #####:   66:                                    rhs.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   67:}
        -:   68:
        -:   69:/// Invert an integer comparison predicate.
function _ZN4mlir5arith15invertPredicateENS0_13CmpIPredicateE called 1518 returned 100% blocks executed 100%
    1518*:   70:arith::CmpIPredicate arith::invertPredicate(arith::CmpIPredicate pred) {
    1518*:   71:  switch (pred) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   72:  case arith::CmpIPredicate::eq:
        -:   73:    return arith::CmpIPredicate::ne;
        -:   74:  case arith::CmpIPredicate::ne:
        -:   75:    return arith::CmpIPredicate::eq;
        -:   76:  case arith::CmpIPredicate::slt:
        -:   77:    return arith::CmpIPredicate::sge;
        -:   78:  case arith::CmpIPredicate::sle:
        -:   79:    return arith::CmpIPredicate::sgt;
        -:   80:  case arith::CmpIPredicate::sgt:
        -:   81:    return arith::CmpIPredicate::sle;
        -:   82:  case arith::CmpIPredicate::sge:
        -:   83:    return arith::CmpIPredicate::slt;
        -:   84:  case arith::CmpIPredicate::ult:
        -:   85:    return arith::CmpIPredicate::uge;
        -:   86:  case arith::CmpIPredicate::ule:
        -:   87:    return arith::CmpIPredicate::ugt;
        -:   88:  case arith::CmpIPredicate::ugt:
        -:   89:    return arith::CmpIPredicate::ule;
        -:   90:  case arith::CmpIPredicate::uge:
        -:   91:    return arith::CmpIPredicate::ult;
        -:   92:  }
    #####:   93:  llvm_unreachable("unknown cmpi predicate kind");
        -:   94:}
        -:   95:
function _ZL15invertPredicateN4mlir5arith17CmpIPredicateAttrE called 0 returned 0% blocks executed 0%
    #####:   96:static arith::CmpIPredicateAttr invertPredicate(arith::CmpIPredicateAttr pred) {
    #####:   97:  return arith::CmpIPredicateAttr::get(pred.getContext(),
call    0 never executed
    #####:   98:                                       invertPredicate(pred.getValue()));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:   99:}
        -:  100:
        -:  101://===----------------------------------------------------------------------===//
        -:  102:// TableGen'd canonicalization patterns
        -:  103://===----------------------------------------------------------------------===//
        -:  104:
        -:  105:namespace {
        -:  106:#include "ArithCanonicalization.inc"
        -:  107:} // namespace
        -:  108:
        -:  109://===----------------------------------------------------------------------===//
        -:  110:// ConstantOp
        -:  111://===----------------------------------------------------------------------===//
        -:  112:
function _ZN4mlir5arith10ConstantOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 305132812 returned 100% blocks executed 87%
305132812:  113:void arith::ConstantOp::getAsmResultNames(
        -:  114:    function_ref<void(Value, StringRef)> setNameFn) {
305132812:  115:  auto type = getType();
call    0 returned 100%
305132812:  116:  if (auto intCst = getValue().dyn_cast<IntegerAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 72% (fallthrough)
branch  3 taken 28%
219962234:  117:    auto intType = type.dyn_cast<IntegerType>();
call    0 returned 100%
        -:  118:
        -:  119:    // Sugar i1 constants with 'true' and 'false'.
219962234:  120:    if (intType && intType.getWidth() == 1)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
call    2 returned 100%
branch  3 taken 23% (fallthrough)
branch  4 taken 77%
 58163960:  121:      return setNameFn(getResult(), (intCst.getInt() ? "true" : "false"));
call    0 returned 100%
branch  1 taken 59%
branch  2 taken 41%
call    3 returned 100%
call    4 returned 100%
        -:  122:
        -:  123:    // Otherwise, build a complex name with the value and type.
366728462:  124:    SmallString<32> specialNameBuffer;
call    0 returned 100%
366728462:  125:    llvm::raw_svector_ostream specialName(specialNameBuffer);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
366728462:  126:    specialName << 'c' << intCst.getValue();
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
183364231:  127:    if (intType)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
249641724:  128:      specialName << '_' << type;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
183364231:  129:    setNameFn(getResult(), specialName.str());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  130:  } else {
 85170578:  131:    setNameFn(getResult(), "cst");
call    0 returned 100%
call    1 returned 100%
        -:  132:  }
        -:  133:}
        -:  134:
        -:  135:/// TODO: disallow arith.constant to return anything other than signless integer
        -:  136:/// or float like.
function _ZN4mlir5arith10ConstantOp6verifyEv called 322473478 returned 100% blocks executed 38%
322473478:  137:LogicalResult arith::ConstantOp::verify() {
322473478:  138:  auto type = getType();
call    0 returned 100%
        -:  139:  // The value's type must match the return type.
322473478:  140:  if (getValue().getType() != type) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  141:    return emitOpError() << "value type " << getValue().getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  142:                         << " must match return type: " << type;
call    0 never executed
call    1 never executed
        -:  143:  }
        -:  144:  // Integer values must be signless.
492061614*:  145:  if (type.isa<IntegerType>() && !type.cast<IntegerType>().isSignless())
call    0 returned 100%
branch  1 taken 53% (fallthrough)
branch  2 taken 47%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  146:    return emitOpError("integer return type must be signless");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  147:  // Any float or elements attribute are acceptable.
322475755:  148:  if (!getValue().isa<IntegerAttr, FloatAttr, ElementsAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  149:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  150:        "value must be an integer, float, or elements attribute");
call    0 never executed
        -:  151:  }
322475770:  152:  return success();
        -:  153:}
        -:  154:
function _ZN4mlir5arith10ConstantOp15isBuildableWithENS_9AttributeENS_4TypeE called 516301 returned 100% blocks executed 86%
   516301:  155:bool arith::ConstantOp::isBuildableWith(Attribute value, Type type) {
        -:  156:  // The value's type must be the same as the provided type.
   516301:  157:  auto typedAttr = value.dyn_cast<TypedAttr>();
call    0 returned 100%
  516301*:  158:  if (!typedAttr || typedAttr.getType() != type)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  159:    return false;
        -:  160:  // Integer values must be signless.
  517394*:  161:  if (type.isa<IntegerType>() && !type.cast<IntegerType>().isSignless())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####:  162:    return false;
        -:  163:  // Integer, float, and element attributes are buildable.
   516301:  164:  return value.isa<IntegerAttr, FloatAttr, ElementsAttr>();
call    0 returned 100%
        -:  165:}
        -:  166:
function _ZN4mlir5arith10ConstantOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 81579367 returned 100% blocks executed 100%
 81579367:  167:OpFoldResult arith::ConstantOp::fold(ArrayRef<Attribute> operands) {
 81579367:  168:  return getValue();
call    0 returned 100%
call    1 returned 100%
        -:  169:}
        -:  170:
function _ZN4mlir5arith13ConstantIntOp5buildERNS_9OpBuilderERNS_14OperationStateElj called 0 returned 0% blocks executed 0%
    #####:  171:void arith::ConstantIntOp::build(OpBuilder &builder, OperationState &result,
        -:  172:                                 int64_t value, unsigned width) {
    #####:  173:  auto type = builder.getIntegerType(width);
call    0 never executed
    #####:  174:  arith::ConstantOp::build(builder, result, type,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  175:                           builder.getIntegerAttr(type, value));
    #####:  176:}
        -:  177:
function _ZN4mlir5arith13ConstantIntOp5buildERNS_9OpBuilderERNS_14OperationStateElNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  178:void arith::ConstantIntOp::build(OpBuilder &builder, OperationState &result,
        -:  179:                                 int64_t value, Type type) {
    #####:  180:  assert(type.isSignlessInteger() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  181:         "ConstantIntOp can only have signless integer type values");
    #####:  182:  arith::ConstantOp::build(builder, result, type,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  183:                           builder.getIntegerAttr(type, value));
    #####:  184:}
        -:  185:
function _ZN4mlir5arith13ConstantIntOp7classofEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  186:bool arith::ConstantIntOp::classof(Operation *op) {
    #####:  187:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  188:    return constOp.getType().isSignlessInteger();
call    0 never executed
        -:  189:  return false;
        -:  190:}
        -:  191:
function _ZN4mlir5arith15ConstantFloatOp5buildERNS_9OpBuilderERNS_14OperationStateERKN4llvm7APFloatENS_9FloatTypeE called 2478 returned 100% blocks executed 100%
     2478:  192:void arith::ConstantFloatOp::build(OpBuilder &builder, OperationState &result,
        -:  193:                                   const APFloat &value, FloatType type) {
     2478:  194:  arith::ConstantOp::build(builder, result, type,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  195:                           builder.getFloatAttr(type, value));
     2478:  196:}
        -:  197:
function _ZN4mlir5arith15ConstantFloatOp7classofEPNS_9OperationE called 2478 returned 100% blocks executed 100%
     2478:  198:bool arith::ConstantFloatOp::classof(Operation *op) {
     4956:  199:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2478:  200:    return constOp.getType().isa<FloatType>();
call    0 returned 100%
        -:  201:  return false;
        -:  202:}
        -:  203:
function _ZN4mlir5arith15ConstantIndexOp5buildERNS_9OpBuilderERNS_14OperationStateEl called 185467 returned 100% blocks executed 100%
   185467:  204:void arith::ConstantIndexOp::build(OpBuilder &builder, OperationState &result,
        -:  205:                                   int64_t value) {
   185467:  206:  arith::ConstantOp::build(builder, result, builder.getIndexType(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  207:                           builder.getIndexAttr(value));
   185478:  208:}
        -:  209:
function _ZN4mlir5arith15ConstantIndexOp7classofEPNS_9OperationE called 12225164 returned 100% blocks executed 100%
 12225164:  210:bool arith::ConstantIndexOp::classof(Operation *op) {
 24450326:  211:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
 12044323:  212:    return constOp.getType().isIndex();
call    0 returned 100%
        -:  213:  return false;
        -:  214:}
        -:  215:
        -:  216://===----------------------------------------------------------------------===//
        -:  217:// AddIOp
        -:  218://===----------------------------------------------------------------------===//
        -:  219:
function _ZN4mlir5arith6AddIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 279962 returned 100% blocks executed 68%
   279962:  220:OpFoldResult arith::AddIOp::fold(ArrayRef<Attribute> operands) {
        -:  221:  // addi(x, 0) -> x
   279962:  222:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 13% (fallthrough)
branch  3 taken 87%
    37593:  223:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  224:
        -:  225:  // addi(subi(a, b), b) -> a
   242370:  226:  if (auto sub = getLhs().getDefiningOp<SubIOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        1:  227:    if (getRhs() == sub.getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  228:      return sub.getLhs();
call    0 never executed
call    1 never executed
        -:  229:
        -:  230:  // addi(b, subi(a, b)) -> a
   242370:  231:  if (auto sub = getRhs().getDefiningOp<SubIOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  232:    if (getLhs() == sub.getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  233:      return sub.getLhs();
call    0 never executed
call    1 never executed
        -:  234:
   242370:  235:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6AddIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 97571 returned 100% blocks executed 67%
   339941:  236:      operands, [](APInt a, const APInt &b) { return std::move(a) + b; });
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  237:}
        -:  238:
function _ZN4mlir5arith6AddIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  239:void arith::AddIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  240:                                                MLIRContext *context) {
     1235:  241:  patterns.add<AddIAddConstant, AddISubConstantRHS, AddISubConstantLHS>(
     1235:  242:      context);
call    0 returned 100%
     1235:  243:}
        -:  244:
        -:  245://===----------------------------------------------------------------------===//
        -:  246:// AddUICarryOp
        -:  247://===----------------------------------------------------------------------===//
        -:  248:
function _ZN4mlir5arith12AddUICarryOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####:  249:Optional<SmallVector<int64_t, 4>> arith::AddUICarryOp::getShapeForUnroll() {
    #####:  250:  if (auto vt = getType(0).dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  251:    return llvm::to_vector<4>(vt.getShape());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  252:  return None;
        -:  253:}
        -:  254:
        -:  255:// Returns the carry bit, assuming that `sum` is the result of addition of
        -:  256:// `operand` and another number.
function _ZL14calculateCarryRKN4llvm5APIntES2_ called 0 returned 0% blocks executed 0%
    #####:  257:static APInt calculateCarry(const APInt &sum, const APInt &operand) {
    #####:  258:  return sum.ult(operand) ? APInt::getAllOnes(1) : APInt::getZero(1);
branch  0 never executed
branch  1 never executed
        -:  259:}
        -:  260:
        -:  261:LogicalResult
function _ZN4mlir5arith12AddUICarryOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:  262:arith::AddUICarryOp::fold(ArrayRef<Attribute> operands,
        -:  263:                          SmallVectorImpl<OpFoldResult> &results) {
    #####:  264:  auto carryTy = getCarry().getType();
call    0 never executed
call    1 never executed
        -:  265:  // addui_carry(x, 0) -> x, false
    #####:  266:  if (matchPattern(getRhs(), m_Zero())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  267:    auto carryZero = APInt::getZero(1);
call    0 never executed
    #####:  268:    Builder builder(getContext());
call    0 never executed
call    1 never executed
    #####:  269:    auto falseValue = builder.getZeroAttr(carryTy);
call    0 never executed
        -:  270:
    #####:  271:    results.push_back(getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  272:    results.push_back(falseValue);
call    0 never executed
call    1 never executed
    #####:  273:    return success();
branch  0 never executed
branch  1 never executed
        -:  274:  }
        -:  275:
        -:  276:  // addui_carry(constant_a, constant_b) -> constant_sum, constant_carry
        -:  277:  // Let the `constFoldBinaryOp` utility attempt to fold the sum of both
        -:  278:  // operands. If that succeeds, calculate the carry boolean based on the sum
        -:  279:  // and the first (constant) operand, `lhs`. Note that we cannot simply call
        -:  280:  // `constFoldBinaryOp` again to calculate the carry (bit) because the
        -:  281:  // constructed attribute is of the same element type as both operands.
    #####:  282:  if (Attribute sumAttr = constFoldBinaryOp<IntegerAttr>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir5arith12AddUICarryOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEENKUlNS2_5APIntERKSA_E_clESA_SC_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  283:          operands, [](APInt a, const APInt &b) { return std::move(a) + b; })) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  284:    Attribute carryAttr;
    #####:  285:    if (auto lhs = operands[0].dyn_cast<IntegerAttr>()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  286:      // Both arguments are scalars, calculate the scalar carry value.
    #####:  287:      auto sum = sumAttr.cast<IntegerAttr>();
call    0 never executed
    #####:  288:      carryAttr = IntegerAttr::get(
branch  0 never executed
branch  1 never executed
    #####:  289:          carryTy, calculateCarry(sum.getValue(), lhs.getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  290:    } else if (auto lhs = operands[0].dyn_cast<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:      // Both arguments are splats, calculate the splat carry value.
    #####:  292:      auto sum = sumAttr.cast<SplatElementsAttr>();
call    0 never executed
    #####:  293:      APInt carry = calculateCarry(sum.getSplatValue<APInt>(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:                                   lhs.getSplatValue<APInt>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  295:      carryAttr = SplatElementsAttr::get(carryTy, carry);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  296:    } else if (auto lhs = operands[0].dyn_cast<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  297:      // Othwerwise calculate element-wise carry values.
    #####:  298:      auto sum = sumAttr.cast<ElementsAttr>();
call    0 never executed
    #####:  299:      const auto numElems = static_cast<size_t>(sum.getNumElements());
call    0 never executed
    #####:  300:      SmallVector<APInt> carryValues;
branch  0 never executed
branch  1 never executed
    #####:  301:      carryValues.reserve(numElems);
branch  0 never executed
branch  1 never executed
        -:  302:
    #####:  303:      auto sumIt = sum.value_begin<APInt>();
call    0 never executed
call    1 never executed
    #####:  304:      auto lhsIt = lhs.value_begin<APInt>();
branch  0 never executed
branch  1 never executed
    #####:  305:      for (size_t i = 0, e = numElems; i != e; ++i, ++sumIt, ++lhsIt)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  306:        carryValues.push_back(calculateCarry(*sumIt, *lhsIt));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  307:
    #####:  308:      carryAttr = DenseElementsAttr::get(carryTy, carryValues);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  309:    } else {
    #####:  310:      return failure();
        -:  311:    }
        -:  312:
    #####:  313:    results.push_back(sumAttr);
call    0 never executed
call    1 never executed
    #####:  314:    results.push_back(carryAttr);
call    0 never executed
call    1 never executed
    #####:  315:    return success();
        -:  316:  }
        -:  317:
    #####:  318:  return failure();
        -:  319:}
        -:  320:
        -:  321://===----------------------------------------------------------------------===//
        -:  322:// SubIOp
        -:  323://===----------------------------------------------------------------------===//
        -:  324:
function _ZN4mlir5arith6SubIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 158938 returned 100% blocks executed 79%
   158938:  325:OpFoldResult arith::SubIOp::fold(ArrayRef<Attribute> operands) {
        -:  326:  // subi(x,x) -> 0
   158938:  327:  if (getOperand(0) == getOperand(1))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
    38697:  328:    return Builder(getContext()).getZeroAttr(getType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  329:  // subi(x,0) -> x
   120241:  330:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
    23941:  331:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  332:
    96300:  333:  if (auto add = getLhs().getDefiningOp<AddIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        -:  334:    // subi(addi(a, b), b) -> a
       26:  335:    if (getRhs() == add.getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  336:      return add.getLhs();
call    0 never executed
call    1 never executed
        -:  337:    // subi(addi(a, b), a) -> b
       26:  338:    if (getRhs() == add.getLhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  339:      return add.getRhs();
call    0 never executed
call    1 never executed
        -:  340:  }
        -:  341:
    96300:  342:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6SubIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 66918 returned 100% blocks executed 67%
   163218:  343:      operands, [](APInt a, const APInt &b) { return std::move(a) - b; });
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  344:}
        -:  345:
function _ZN4mlir5arith6SubIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  346:void arith::SubIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  347:                                                MLIRContext *context) {
     1235:  348:  patterns.add<SubIRHSAddConstant, SubILHSAddConstant, SubIRHSSubConstantRHS,
        -:  349:               SubIRHSSubConstantLHS, SubILHSSubConstantRHS,
     1235:  350:               SubILHSSubConstantLHS, SubISubILHSRHSLHS>(context);
call    0 returned 100%
     1235:  351:}
        -:  352:
        -:  353://===----------------------------------------------------------------------===//
        -:  354:// MulIOp
        -:  355://===----------------------------------------------------------------------===//
        -:  356:
function _ZN4mlir5arith6MulIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 283047 returned 100% blocks executed 100%
   283047:  357:OpFoldResult arith::MulIOp::fold(ArrayRef<Attribute> operands) {
        -:  358:  // muli(x, 0) -> 0
   283047:  359:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    35111:  360:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  361:  // muli(x, 1) -> x
   247936:  362:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
    25594:  363:    return getOperand(0);
call    0 returned 100%
call    1 returned 100%
        -:  364:  // TODO: Handle the overflow case.
        -:  365:
        -:  366:  // default folder
   222342:  367:  return constFoldBinaryOp<IntegerAttr>(
   300115:  368:      operands, [](const APInt &a, const APInt &b) { return a * b; });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  369:}
        -:  370:
        -:  371://===----------------------------------------------------------------------===//
        -:  372:// DivUIOp
        -:  373://===----------------------------------------------------------------------===//
        -:  374:
function _ZN4mlir5arith7DivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 128551 returned 100% blocks executed 100%
   128551:  375:OpFoldResult arith::DivUIOp::fold(ArrayRef<Attribute> operands) {
        -:  376:  // divui (x, 1) -> x.
   128551:  377:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 15% (fallthrough)
branch  3 taken 85%
    19026:  378:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  379:
        -:  380:  // Don't fold if it would require a division by zero.
   109525:  381:  bool div0 = false;
   109525:  382:  auto result =
function _ZZN4mlir5arith7DivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 75288 returned 100% blocks executed 88%
    75288:  383:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   150576:  384:        if (div0 || !b) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
    17966:  385:          div0 = true;
    17966:  386:          return a;
        -:  387:        }
    57322:  388:        return a.udiv(b);
call    0 returned 100%
   109525:  389:      });
call    0 returned 100%
        -:  390:
   201084:  391:  return div0 ? Attribute() : result;
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
call    2 returned 100%
        -:  392:}
        -:  393:
        -:  394://===----------------------------------------------------------------------===//
        -:  395:// DivSIOp
        -:  396://===----------------------------------------------------------------------===//
        -:  397:
function _ZN4mlir5arith7DivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 186599 returned 100% blocks executed 100%
   186599:  398:OpFoldResult arith::DivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  399:  // divsi (x, 1) -> x.
   186599:  400:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    23151:  401:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  402:
        -:  403:  // Don't fold if it would overflow or if it requires a division by zero.
   163448:  404:  bool overflowOrDiv0 = false;
   163448:  405:  auto result =
function _ZZN4mlir5arith7DivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 120754 returned 100% blocks executed 88%
   120754:  406:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   241508:  407:        if (overflowOrDiv0 || !b) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 35% (fallthrough)
branch  3 taken 65%
    42381:  408:          overflowOrDiv0 = true;
    42381:  409:          return a;
        -:  410:        }
    78373:  411:        return a.sdiv_ov(b, overflowOrDiv0);
call    0 returned 100%
   163448:  412:      });
call    0 returned 100%
        -:  413:
   284512:  414:  return overflowOrDiv0 ? Attribute() : result;
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
call    2 returned 100%
        -:  415:}
        -:  416:
        -:  417://===----------------------------------------------------------------------===//
        -:  418:// Ceil and floor division folding helpers
        -:  419://===----------------------------------------------------------------------===//
        -:  420:
function _ZL22signedCeilNonnegInputsRKN4llvm5APIntES2_Rb called 75047 returned 100% blocks executed 56%
    75047:  421:static APInt signedCeilNonnegInputs(const APInt &a, const APInt &b,
        -:  422:                                    bool &overflow) {
        -:  423:  // Returns (a-1)/b + 1
    75047:  424:  APInt one(a.getBitWidth(), 1, true); // Signed value 1.
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   150094:  425:  APInt val = a.ssub_ov(one, overflow).sdiv_ov(b, overflow);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    75047:  426:  return val.sadd_ov(one, overflow);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  427:}
        -:  428:
        -:  429://===----------------------------------------------------------------------===//
        -:  430:// CeilDivUIOp
        -:  431://===----------------------------------------------------------------------===//
        -:  432:
function _ZN4mlir5arith11CeilDivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  433:OpFoldResult arith::CeilDivUIOp::fold(ArrayRef<Attribute> operands) {
        -:  434:  // ceildivui (x, 1) -> x.
    #####:  435:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  436:    return getLhs();
call    0 never executed
call    1 never executed
        -:  437:
    #####:  438:  bool overflowOrDiv0 = false;
    #####:  439:  auto result =
function _ZZN4mlir5arith11CeilDivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  440:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  441:        if (overflowOrDiv0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  442:          overflowOrDiv0 = true;
    #####:  443:          return a;
        -:  444:        }
    #####:  445:        APInt quotient = a.udiv(b);
call    0 never executed
    #####:  446:        if (!a.urem(b))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  447:          return quotient;
    #####:  448:        APInt one(a.getBitWidth(), 1, true);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  449:        return quotient.uadd_ov(one, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  450:      });
call    0 never executed
        -:  451:
    #####:  452:  return overflowOrDiv0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  453:}
        -:  454:
        -:  455://===----------------------------------------------------------------------===//
        -:  456:// CeilDivSIOp
        -:  457://===----------------------------------------------------------------------===//
        -:  458:
function _ZN4mlir5arith11CeilDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 190070 returned 100% blocks executed 100%
   190070:  459:OpFoldResult arith::CeilDivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  460:  // ceildivsi (x, 1) -> x.
   190070:  461:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 13% (fallthrough)
branch  3 taken 87%
    24072:  462:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  463:
        -:  464:  // Don't fold if it would overflow or if it requires a division by zero.
   165998:  465:  bool overflowOrDiv0 = false;
   165998:  466:  auto result =
function _ZZN4mlir5arith11CeilDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 121571 returned 100% blocks executed 69%
   121571:  467:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   243142:  468:        if (overflowOrDiv0 || !b) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
    40185:  469:          overflowOrDiv0 = true;
    40185:  470:          return a;
        -:  471:        }
   162772:  472:        if (!a)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
     2016:  473:          return a;
        -:  474:        // After this point we know that neither a or b are zero.
    79370:  475:        unsigned bits = a.getBitWidth();
call    0 returned 100%
    79370:  476:        APInt zero = APInt::getZero(bits);
call    0 returned 100%
    79370:  477:        bool aGtZero = a.sgt(zero);
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
    79370:  478:        bool bGtZero = b.sgt(zero);
    79370:  479:        if (aGtZero && bGtZero) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
        -:  480:          // Both positive, return ceil(a, b).
    62175:  481:          return signedCeilNonnegInputs(a, b, overflowOrDiv0);
call    0 returned 100%
        -:  482:        }
    17195:  483:        if (!aGtZero && !bGtZero) {
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
        -:  484:          // Both negative, return ceil(-a, -b).
    12864:  485:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 returned 100%
    12864:  486:          APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     6432:  487:          return signedCeilNonnegInputs(posA, posB, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  488:        }
    10763:  489:        if (!aGtZero && bGtZero) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -:  490:          // A is negative, b is positive, return - ( -a / b).
     8926:  491:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 returned 100%
     8926:  492:          APInt div = posA.sdiv_ov(b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     4463:  493:          return zero.ssub_ov(div, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  494:        }
        -:  495:        // A is positive, b is negative, return - (a / -b).
    85670:  496:        APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    12600:  497:        APInt div = a.sdiv_ov(posB, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     6300:  498:        return zero.ssub_ov(div, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   165998:  499:      });
call    0 returned 100%
        -:  500:
   291811:  501:  return overflowOrDiv0 ? Attribute() : result;
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
call    2 returned 100%
        -:  502:}
        -:  503:
        -:  504://===----------------------------------------------------------------------===//
        -:  505:// FloorDivSIOp
        -:  506://===----------------------------------------------------------------------===//
        -:  507:
function _ZN4mlir5arith12FloorDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 129566 returned 100% blocks executed 100%
   129566:  508:OpFoldResult arith::FloorDivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  509:  // floordivsi (x, 1) -> x.
   129566:  510:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 15% (fallthrough)
branch  3 taken 85%
    18957:  511:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  512:
        -:  513:  // Don't fold if it would overflow or if it requires a division by zero.
   110609:  514:  bool overflowOrDiv0 = false;
   110609:  515:  auto result =
function _ZZN4mlir5arith12FloorDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 80949 returned 100% blocks executed 69%
    80949:  516:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   161898:  517:        if (overflowOrDiv0 || !b) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 28% (fallthrough)
branch  3 taken 72%
    22275:  518:          overflowOrDiv0 = true;
    22275:  519:          return a;
        -:  520:        }
   117348:  521:        if (!a)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
     2287:  522:          return a;
        -:  523:        // After this point we know that neither a or b are zero.
    56387:  524:        unsigned bits = a.getBitWidth();
call    0 returned 100%
    56387:  525:        APInt zero = APInt::getZero(bits);
call    0 returned 100%
    56387:  526:        bool aGtZero = a.sgt(zero);
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
    56387:  527:        bool bGtZero = b.sgt(zero);
    56387:  528:        if (aGtZero && bGtZero) {
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
        -:  529:          // Both positive, return a / b.
    40385:  530:          return a.sdiv_ov(b, overflowOrDiv0);
call    0 returned 100%
        -:  531:        }
    16002:  532:        if (!aGtZero && !bGtZero) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  533:          // Both negative, return -a / -b.
    19124:  534:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 returned 100%
    19124:  535:          APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     9562:  536:          return posA.sdiv_ov(posB, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  537:        }
     6440:  538:        if (!aGtZero && bGtZero) {
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
        -:  539:          // A is negative, b is positive, return - ceil(-a, b).
     7562:  540:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 returned 100%
     7562:  541:          APInt ceil = signedCeilNonnegInputs(posA, b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3781:  542:          return zero.ssub_ov(ceil, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  543:        }
        -:  544:        // A is positive, b is negative, return - ceil(a, -b).
    59046:  545:        APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     5318:  546:        APInt ceil = signedCeilNonnegInputs(a, posB, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2659:  547:        return zero.ssub_ov(ceil, overflowOrDiv0);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   110609:  548:      });
call    0 returned 100%
        -:  549:
   198938:  550:  return overflowOrDiv0 ? Attribute() : result;
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
call    2 returned 100%
        -:  551:}
        -:  552:
        -:  553://===----------------------------------------------------------------------===//
        -:  554:// RemUIOp
        -:  555://===----------------------------------------------------------------------===//
        -:  556:
function _ZN4mlir5arith7RemUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 176937 returned 100% blocks executed 100%
   176937:  557:OpFoldResult arith::RemUIOp::fold(ArrayRef<Attribute> operands) {
        -:  558:  // remui (x, 1) -> 0.
   176937:  559:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 16% (fallthrough)
branch  3 taken 84%
    27929:  560:    return Builder(getContext()).getZeroAttr(getType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  561:
        -:  562:  // Don't fold if it would require a division by zero.
   149008:  563:  bool div0 = false;
   149008:  564:  auto result =
function _ZZN4mlir5arith7RemUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 103318 returned 100% blocks executed 88%
   103318:  565:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   206636:  566:        if (div0 || b.isNullValue()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 30% (fallthrough)
branch  3 taken 70%
    30753:  567:          div0 = true;
    30753:  568:          return a;
        -:  569:        }
    72565:  570:        return a.urem(b);
call    0 returned 100%
   149008:  571:      });
call    0 returned 100%
        -:  572:
   267263:  573:  return div0 ? Attribute() : result;
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
call    2 returned 100%
        -:  574:}
        -:  575:
        -:  576://===----------------------------------------------------------------------===//
        -:  577:// RemSIOp
        -:  578://===----------------------------------------------------------------------===//
        -:  579:
function _ZN4mlir5arith7RemSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 161318 returned 100% blocks executed 100%
   161318:  580:OpFoldResult arith::RemSIOp::fold(ArrayRef<Attribute> operands) {
        -:  581:  // remsi (x, 1) -> 0.
   161318:  582:  if (matchPattern(getRhs(), m_One()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    18657:  583:    return Builder(getContext()).getZeroAttr(getType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  584:
        -:  585:  // Don't fold if it would require a division by zero.
   142662:  586:  bool div0 = false;
   142662:  587:  auto result =
function _ZZN4mlir5arith7RemSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 93431 returned 100% blocks executed 88%
    93431:  588:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
   186862:  589:        if (div0 || b.isNullValue()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
    23700:  590:          div0 = true;
    23700:  591:          return a;
        -:  592:        }
    69731:  593:        return a.srem(b);
call    0 returned 100%
   142662:  594:      });
call    0 returned 100%
        -:  595:
   261624:  596:  return div0 ? Attribute() : result;
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
call    2 returned 100%
        -:  597:}
        -:  598:
        -:  599://===----------------------------------------------------------------------===//
        -:  600:// AndIOp
        -:  601://===----------------------------------------------------------------------===//
        -:  602:
function _ZN4mlir5arith6AndIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 200631 returned 100% blocks executed 73%
   200631:  603:OpFoldResult arith::AndIOp::fold(ArrayRef<Attribute> operands) {
        -:  604:  /// and(x, 0) -> 0
   200631:  605:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 13% (fallthrough)
branch  3 taken 87%
    25965:  606:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  607:  /// and(x, allOnes) -> x
   174666:  608:  APInt intValue;
call    0 returned 100%
   174666:  609:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isAllOnes())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 64% (fallthrough)
branch  3 taken 36%
branch  4 taken 16% (fallthrough)
branch  5 taken 84%
    18254:  610:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  611:  /// and(x, not(x)) -> 0
  156412*:  612:  if (matchPattern(getRhs(), m_Op<XOrIOp>(matchers::m_Val(getLhs()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  156412*:  613:                                          m_ConstantInt(&intValue))) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  614:      intValue.isAllOnes())
branch  0 never executed
branch  1 never executed
    #####:  615:    return IntegerAttr::get(getType(), 0);
call    0 never executed
call    1 never executed
        -:  616:  /// and(not(x), x) -> 0
  156412*:  617:  if (matchPattern(getLhs(), m_Op<XOrIOp>(matchers::m_Val(getRhs()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  156412*:  618:                                          m_ConstantInt(&intValue))) &&
branch  0 taken 0%
branch  1 taken 100%
    #####:  619:      intValue.isAllOnes())
branch  0 never executed
branch  1 never executed
    #####:  620:    return IntegerAttr::get(getType(), 0);
call    0 never executed
call    1 never executed
        -:  621:
   156412:  622:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6AndIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 82605 returned 100% blocks executed 67%
   239017:  623:      operands, [](APInt a, const APInt &b) { return std::move(a) & b; });
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  624:}
        -:  625:
        -:  626://===----------------------------------------------------------------------===//
        -:  627:// OrIOp
        -:  628://===----------------------------------------------------------------------===//
        -:  629:
function _ZN4mlir5arith5OrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 200165 returned 100% blocks executed 87%
   200165:  630:OpFoldResult arith::OrIOp::fold(ArrayRef<Attribute> operands) {
        -:  631:  /// or(x, 0) -> x
   200165:  632:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 17% (fallthrough)
branch  3 taken 83%
    33209:  633:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  634:  /// or(x, <all ones>) -> <all ones>
   274934:  635:  if (auto rhsAttr = operands[1].dyn_cast_or_null<IntegerAttr>())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 65% (fallthrough)
branch  3 taken 35%
branch  4 taken 65% (fallthrough)
branch  5 taken 35%
   107978:  636:    if (rhsAttr.getValue().isAllOnes())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 20% (fallthrough)
branch  4 taken 80%
    21690:  637:      return rhsAttr;
call    0 returned 100%
        -:  638:
   145266:  639:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith5OrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 79397 returned 100% blocks executed 67%
   224663:  640:      operands, [](APInt a, const APInt &b) { return std::move(a) | b; });
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  641:}
        -:  642:
        -:  643://===----------------------------------------------------------------------===//
        -:  644:// XOrIOp
        -:  645://===----------------------------------------------------------------------===//
        -:  646:
function _ZN4mlir5arith6XOrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 126909 returned 100% blocks executed 47%
   126909:  647:OpFoldResult arith::XOrIOp::fold(ArrayRef<Attribute> operands) {
        -:  648:  /// xor(x, 0) -> x
   126909:  649:  if (matchPattern(getRhs(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 19% (fallthrough)
branch  3 taken 81%
    23771:  650:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  651:  /// xor(x, x) -> 0
   103138:  652:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 27% (fallthrough)
branch  3 taken 73%
    27709:  653:    return Builder(getContext()).getZeroAttr(getType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  654:  /// xor(xor(x, a), a) -> x
        -:  655:  /// xor(xor(a, x), a) -> x
    75429:  656:  if (arith::XOrIOp prev = getLhs().getDefiningOp<arith::XOrIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  657:    if (prev.getRhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  658:      return prev.getLhs();
call    0 never executed
call    1 never executed
    #####:  659:    if (prev.getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  660:      return prev.getRhs();
call    0 never executed
call    1 never executed
        -:  661:  }
        -:  662:  /// xor(a, xor(x, a)) -> x
        -:  663:  /// xor(a, xor(a, x)) -> x
    75429:  664:  if (arith::XOrIOp prev = getRhs().getDefiningOp<arith::XOrIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
    #####:  665:    if (prev.getRhs() == getLhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  666:      return prev.getLhs();
call    0 never executed
call    1 never executed
    #####:  667:    if (prev.getLhs() == getLhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  668:      return prev.getRhs();
call    0 never executed
call    1 never executed
        -:  669:  }
        -:  670:
    75429:  671:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6XOrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 49213 returned 100% blocks executed 67%
   124642:  672:      operands, [](APInt a, const APInt &b) { return std::move(a) ^ b; });
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
        -:  673:}
        -:  674:
function _ZN4mlir5arith6XOrIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  675:void arith::XOrIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  676:                                                MLIRContext *context) {
     1235:  677:  patterns.add<XOrINotCmpI>(context);
call    0 returned 100%
     1235:  678:}
        -:  679:
        -:  680://===----------------------------------------------------------------------===//
        -:  681:// NegFOp
        -:  682://===----------------------------------------------------------------------===//
        -:  683:
function _ZN4mlir5arith6NegFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 168981 returned 100% blocks executed 70%
   168981:  684:OpFoldResult arith::NegFOp::fold(ArrayRef<Attribute> operands) {
        -:  685:  /// negf(negf(x)) -> x
   168981:  686:  if (auto op = this->getOperand().getDefiningOp<arith::NegFOp>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  687:    return op.getOperand();
call    0 never executed
call    1 never executed
   168981:  688:  return constFoldUnaryOp<FloatAttr>(operands,
   440277:  689:                                     [](const APFloat &a) { return -a; });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  690:}
        -:  691:
        -:  692://===----------------------------------------------------------------------===//
        -:  693:// AddFOp
        -:  694://===----------------------------------------------------------------------===//
        -:  695:
function _ZN4mlir5arith6AddFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 212701 returned 100% blocks executed 70%
   212701:  696:OpFoldResult arith::AddFOp::fold(ArrayRef<Attribute> operands) {
        -:  697:  // addf(x, -0) -> x
   212701:  698:  if (matchPattern(getRhs(), m_NegZeroFloat()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  699:    return getLhs();
call    0 never executed
call    1 never executed
        -:  700:
   212701:  701:  return constFoldBinaryOp<FloatAttr>(
   450767:  702:      operands, [](const APFloat &a, const APFloat &b) { return a + b; });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  703:}
        -:  704:
        -:  705://===----------------------------------------------------------------------===//
        -:  706:// SubFOp
        -:  707://===----------------------------------------------------------------------===//
        -:  708:
function _ZN4mlir5arith6SubFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  709:OpFoldResult arith::SubFOp::fold(ArrayRef<Attribute> operands) {
        -:  710:  // subf(x, +0) -> x
    #####:  711:  if (matchPattern(getRhs(), m_PosZeroFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  712:    return getLhs();
call    0 never executed
call    1 never executed
        -:  713:
    #####:  714:  return constFoldBinaryOp<FloatAttr>(
    #####:  715:      operands, [](const APFloat &a, const APFloat &b) { return a - b; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  716:}
        -:  717:
        -:  718://===----------------------------------------------------------------------===//
        -:  719:// MaxFOp
        -:  720://===----------------------------------------------------------------------===//
        -:  721:
function _ZN4mlir5arith6MaxFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 188851 returned 100% blocks executed 78%
   188851:  722:OpFoldResult arith::MaxFOp::fold(ArrayRef<Attribute> operands) {
  188851*:  723:  assert(operands.size() == 2 && "maxf takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  724:
        -:  725:  // maxf(x,x) -> x
   188851:  726:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
    49708:  727:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  728:
        -:  729:  // maxf(x, -inf) -> x
   139143:  730:  if (matchPattern(getRhs(), m_NegInfFloat()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  731:    return getLhs();
call    0 never executed
call    1 never executed
        -:  732:
   139143:  733:  return constFoldBinaryOp<FloatAttr>(
        -:  734:      operands,
   228491:  735:      [](const APFloat &a, const APFloat &b) { return llvm::maximum(a, b); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  736:}
        -:  737:
        -:  738://===----------------------------------------------------------------------===//
        -:  739:// MaxSIOp
        -:  740://===----------------------------------------------------------------------===//
        -:  741:
function _ZN4mlir5arith7MaxSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 188363 returned 100% blocks executed 91%
   188363:  742:OpFoldResult MaxSIOp::fold(ArrayRef<Attribute> operands) {
  188363*:  743:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  744:
        -:  745:  // maxsi(x,x) -> x
   188363:  746:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 24% (fallthrough)
branch  3 taken 76%
    45723:  747:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  748:
   142640:  749:  APInt intValue;
call    0 returned 100%
        -:  750:  // maxsi(x,MAX_INT) -> MAX_INT
   262422:  751:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 84% (fallthrough)
branch  3 taken 16%
branch  4 taken 24% (fallthrough)
branch  5 taken 76%
   119782:  752:      intValue.isMaxSignedValue())
call    0 returned 100%
    29036:  753:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  754:
        -:  755:  // maxsi(x, MIN_INT) -> x
   204350:  756:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
branch  4 taken 78% (fallthrough)
branch  5 taken 22%
    90746:  757:      intValue.isMinSignedValue())
call    0 returned 100%
    19853:  758:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  759:
    93751:  760:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MaxSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 59602 returned 100% blocks executed 83%
    59602:  761:                                        [](const APInt &a, const APInt &b) {
    84371:  762:                                          return llvm::APIntOps::smax(a, b);
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    93751:  763:                                        });
call    0 returned 100%
call    1 returned 100%
        -:  764:}
        -:  765:
        -:  766://===----------------------------------------------------------------------===//
        -:  767:// MaxUIOp
        -:  768://===----------------------------------------------------------------------===//
        -:  769:
function _ZN4mlir5arith7MaxUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 168365 returned 100% blocks executed 88%
   168365:  770:OpFoldResult MaxUIOp::fold(ArrayRef<Attribute> operands) {
  168365*:  771:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  772:
        -:  773:  // maxui(x,x) -> x
   168365:  774:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
    49432:  775:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  776:
   118933:  777:  APInt intValue;
call    0 returned 100%
        -:  778:  // maxui(x,MAX_INT) -> MAX_INT
   118933:  779:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMaxValue())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
branch  4 taken 17% (fallthrough)
branch  5 taken 83%
    17569:  780:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  781:
        -:  782:  // maxui(x, MIN_INT) -> x
   186414:  783:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMinValue())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 84% (fallthrough)
branch  3 taken 16%
branch  4 taken 73% (fallthrough)
branch  5 taken 27%
    22869:  784:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  785:
    78495:  786:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MaxUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 53296 returned 100% blocks executed 83%
    53296:  787:                                        [](const APInt &a, const APInt &b) {
    78884:  788:                                          return llvm::APIntOps::umax(a, b);
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    78495:  789:                                        });
call    0 returned 100%
call    1 returned 100%
        -:  790:}
        -:  791:
        -:  792://===----------------------------------------------------------------------===//
        -:  793:// MinFOp
        -:  794://===----------------------------------------------------------------------===//
        -:  795:
function _ZN4mlir5arith6MinFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 162747 returned 100% blocks executed 78%
   162747:  796:OpFoldResult arith::MinFOp::fold(ArrayRef<Attribute> operands) {
  162747*:  797:  assert(operands.size() == 2 && "minf takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  798:
        -:  799:  // minf(x,x) -> x
   162747:  800:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 32% (fallthrough)
branch  3 taken 68%
    52273:  801:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  802:
        -:  803:  // minf(x, +inf) -> x
   110474:  804:  if (matchPattern(getRhs(), m_PosInfFloat()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  805:    return getLhs();
call    0 never executed
call    1 never executed
        -:  806:
   110474:  807:  return constFoldBinaryOp<FloatAttr>(
        -:  808:      operands,
   183771:  809:      [](const APFloat &a, const APFloat &b) { return llvm::minimum(a, b); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  810:}
        -:  811:
        -:  812://===----------------------------------------------------------------------===//
        -:  813:// MinSIOp
        -:  814://===----------------------------------------------------------------------===//
        -:  815:
function _ZN4mlir5arith7MinSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 152645 returned 100% blocks executed 91%
   152645:  816:OpFoldResult MinSIOp::fold(ArrayRef<Attribute> operands) {
  152645*:  817:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  818:
        -:  819:  // minsi(x,x) -> x
   152645:  820:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 27% (fallthrough)
branch  3 taken 73%
    40766:  821:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  822:
   111879:  823:  APInt intValue;
call    0 returned 100%
        -:  824:  // minsi(x,MIN_INT) -> MIN_INT
   199890:  825:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
branch  4 taken 18% (fallthrough)
branch  5 taken 82%
    88011:  826:      intValue.isMinSignedValue())
call    0 returned 100%
    15509:  827:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  828:
        -:  829:  // minsi(x, MAX_INT) -> x
   168872:  830:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 75% (fallthrough)
branch  3 taken 25%
branch  4 taken 77% (fallthrough)
branch  5 taken 23%
    72502:  831:      intValue.isMaxSignedValue())
call    0 returned 100%
    16999:  832:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  833:
    79371:  834:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MinSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 46181 returned 100% blocks executed 83%
    46181:  835:                                        [](const APInt &a, const APInt &b) {
    68686:  836:                                          return llvm::APIntOps::smin(a, b);
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    79371:  837:                                        });
call    0 returned 100%
call    1 returned 100%
        -:  838:}
        -:  839:
        -:  840://===----------------------------------------------------------------------===//
        -:  841:// MinUIOp
        -:  842://===----------------------------------------------------------------------===//
        -:  843:
function _ZN4mlir5arith7MinUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 148841 returned 100% blocks executed 88%
   148841:  844:OpFoldResult MinUIOp::fold(ArrayRef<Attribute> operands) {
  148841*:  845:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  846:
        -:  847:  // minui(x,x) -> x
   148841:  848:  if (getLhs() == getRhs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
    38878:  849:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  850:
   109963:  851:  APInt intValue;
call    0 returned 100%
        -:  852:  // minui(x,MIN_INT) -> MIN_INT
   200383:  853:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMinValue())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
branch  4 taken 25% (fallthrough)
branch  5 taken 75%
    22778:  854:    return getRhs();
call    0 returned 100%
call    1 returned 100%
        -:  855:
        -:  856:  // minui(x, MAX_INT) -> x
    87185:  857:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMaxValue())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 78% (fallthrough)
branch  3 taken 22%
branch  4 taken 82% (fallthrough)
branch  5 taken 18%
    12090:  858:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  859:
    75095:  860:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MinUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 45630 returned 100% blocks executed 83%
    45630:  861:                                        [](const APInt &a, const APInt &b) {
    68099:  862:                                          return llvm::APIntOps::umin(a, b);
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    75095:  863:                                        });
call    0 returned 100%
call    1 returned 100%
        -:  864:}
        -:  865:
        -:  866://===----------------------------------------------------------------------===//
        -:  867:// MulFOp
        -:  868://===----------------------------------------------------------------------===//
        -:  869:
function _ZN4mlir5arith6MulFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 215096 returned 100% blocks executed 100%
   215096:  870:OpFoldResult arith::MulFOp::fold(ArrayRef<Attribute> operands) {
        -:  871:  // mulf(x, 1) -> x
   215096:  872:  if (matchPattern(getRhs(), m_OneFloat()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
     6444:  873:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  874:
   208652:  875:  return constFoldBinaryOp<FloatAttr>(
   427544:  876:      operands, [](const APFloat &a, const APFloat &b) { return a * b; });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  877:}
        -:  878:
function _ZN4mlir5arith6MulFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  879:void arith::MulFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  880:                                                MLIRContext *context) {
     1235:  881:  patterns.add<MulFOfNegF>(context);
call    0 returned 100%
     1235:  882:}
        -:  883:
        -:  884://===----------------------------------------------------------------------===//
        -:  885:// DivFOp
        -:  886://===----------------------------------------------------------------------===//
        -:  887:
function _ZN4mlir5arith6DivFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 160677 returned 100% blocks executed 100%
   160677:  888:OpFoldResult arith::DivFOp::fold(ArrayRef<Attribute> operands) {
        -:  889:  // divf(x, 1) -> x
   160677:  890:  if (matchPattern(getRhs(), m_OneFloat()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
    10424:  891:    return getLhs();
call    0 returned 100%
call    1 returned 100%
        -:  892:
   150253:  893:  return constFoldBinaryOp<FloatAttr>(
   366991:  894:      operands, [](const APFloat &a, const APFloat &b) { return a / b; });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  895:}
        -:  896:
function _ZN4mlir5arith6DivFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  897:void arith::DivFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  898:                                                MLIRContext *context) {
     1235:  899:  patterns.add<DivFOfNegF>(context);
call    0 returned 100%
     1235:  900:}
        -:  901:
        -:  902://===----------------------------------------------------------------------===//
        -:  903:// RemFOp
        -:  904://===----------------------------------------------------------------------===//
        -:  905:
function _ZN4mlir5arith6RemFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 338142 returned 100% blocks executed 100%
   338142:  906:OpFoldResult arith::RemFOp::fold(ArrayRef<Attribute> operands) {
   338142:  907:  return constFoldBinaryOp<FloatAttr>(operands,
   242514:  908:                                      [](const APFloat &a, const APFloat &b) {
   242514:  909:                                        APFloat result(a);
call    0 returned 100%
   242514:  910:                                        (void)result.remainder(b);
call    0 returned 100%
   242514:  911:                                        return result;
call    0 returned 100%
   338142:  912:                                      });
call    0 returned 100%
call    1 returned 100%
        -:  913:}
        -:  914:
        -:  915://===----------------------------------------------------------------------===//
        -:  916:// Utility functions for verifying cast ops
        -:  917://===----------------------------------------------------------------------===//
        -:  918:
        -:  919:template <typename... Types>
        -:  920:using type_list = std::tuple<Types...> *;
        -:  921:
        -:  922:/// Returns a non-null type only if the provided type is one of the allowed
        -:  923:/// types or one of the allowed shaped types of the allowed types. Returns the
        -:  924:/// element type if a valid shaped type is provided.
        -:  925:template <typename... ShapedTypes, typename... ElementTypes>
        -:  926:static Type getUnderlyingType(Type type, type_list<ShapedTypes...>,
        -:  927:                              type_list<ElementTypes...>) {
        -:  928:  if (type.isa<ShapedType>() && !type.isa<ShapedTypes...>())
        -:  929:    return {};
        -:  930:
        -:  931:  auto underlyingType = getElementTypeOrSelf(type);
        -:  932:  if (!underlyingType.isa<ElementTypes...>())
        -:  933:    return {};
        -:  934:
        -:  935:  return underlyingType;
        -:  936:}
        -:  937:
        -:  938:/// Get allowed underlying types for vectors and tensors.
        -:  939:template <typename... ElementTypes>
320927392*:  940:static Type getTypeIfLike(Type type) {
320927392*:  941:  return getUnderlyingType(type, type_list<VectorType, TensorType>(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 returned 100%
call   11 returned 100%
        -:  942:                           type_list<ElementTypes...>());
        -:  943:}
        -:  944:
        -:  945:/// Get allowed underlying types for vectors, tensors, and memrefs.
        -:  946:template <typename... ElementTypes>
   69142*:  947:static Type getTypeIfLikeOrMemRef(Type type) {
   69142*:  948:  return getUnderlyingType(type,
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
        -:  949:                           type_list<VectorType, TensorType, MemRefType>(),
        -:  950:                           type_list<ElementTypes...>());
        -:  951:}
        -:  952:
function _ZL28areValidCastInputsAndOutputsN4mlir9TypeRangeES0_ called 160498267 returned 100% blocks executed 90%
160498267:  953:static bool areValidCastInputsAndOutputs(TypeRange inputs, TypeRange outputs) {
160498267:  954:  return inputs.size() == 1 && outputs.size() == 1 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
160498267:  955:         succeeded(verifyCompatibleShapes(inputs.front(), outputs.front()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  956:}
        -:  957:
        -:  958://===----------------------------------------------------------------------===//
        -:  959:// Verifiers for integer and floating point extension/truncation ops
        -:  960://===----------------------------------------------------------------------===//
        -:  961:
        -:  962:// Extend ops can only extend to a wider type.
        -:  963:template <typename ValType, typename Op>
160463696*:  964:static LogicalResult verifyExtOp(Op op) {
160463696*:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
160463696*:  966:  Type dstType = getElementTypeOrSelf(op.getType());
        -:  967:
160463696*:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
        -:  971:
160463696*:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir9FloatTypeENS0_5arith6ExtFOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir9FloatTypeENS0_5arith6ExtFOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  964:static LogicalResult verifyExtOp(Op op) {
call    0 never executed
    #####:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
    #####:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtSIOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtSIOpEENS0_13LogicalResultET0_ called 33977097 returned 100% blocks executed 56%
 33977097:  964:static LogicalResult verifyExtOp(Op op) {
call    0 returned 100%
 33977097:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 returned 100%
call    1 returned 100%
 33977097:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 returned 100%
call    1 returned 100%
        -:  967:
 33977097:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
 33977097:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtUIOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtUIOpEENS0_13LogicalResultET0_ called 126486599 returned 100% blocks executed 56%
126486599:  964:static LogicalResult verifyExtOp(Op op) {
call    0 returned 100%
126486599:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 returned 100%
call    1 returned 100%
126486599:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 returned 100%
call    1 returned 100%
        -:  967:
126486599:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
126486599:  972:  return success();
        -:  973:}
------------------
        -:  974:
        -:  975:// Truncate ops can only truncate to a shorter type.
        -:  976:template <typename ValType, typename Op>
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
_Z16verifyTruncateOpIN4mlir9FloatTypeENS0_5arith8TruncFOpEENS0_13LogicalResultET0_:
function _Z16verifyTruncateOpIN4mlir9FloatTypeENS0_5arith8TruncFOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
call    0 never executed
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
_Z16verifyTruncateOpIN4mlir11IntegerTypeENS0_5arith8TruncIOpEENS0_13LogicalResultET0_:
function _Z16verifyTruncateOpIN4mlir11IntegerTypeENS0_5arith8TruncIOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
call    0 never executed
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
        -:  987:
        -:  988:/// Validate a cast that changes the width of a type.
        -:  989:template <template <typename> class WidthComparator, typename... ElementTypes>
160463696*:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
160463696*:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
        -:  992:    return false;
        -:  993:
160463696*:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
160463696*:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
160463696*:  996:  if (!srcType || !dstType)
        -:  997:    return false;
        -:  998:
160463696*:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt4lessJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt4lessJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt4lessJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt4lessJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt7greaterJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt7greaterJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt7greaterJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt7greaterJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_ called 160463696 returned 100% blocks executed 100%
160463696:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
160463696:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  992:    return false;
        -:  993:
160463696:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 returned 100%
160463696:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 returned 100%
160463696:  996:  if (!srcType || !dstType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  997:    return false;
        -:  998:
160463696:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 returned 100%
call    1 returned 100%
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
        -: 1002:
        -: 1003://===----------------------------------------------------------------------===//
        -: 1004:// ExtUIOp
        -: 1005://===----------------------------------------------------------------------===//
        -: 1006:
function _ZN4mlir5arith7ExtUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 887403 returned 100% blocks executed 50%
   887403: 1007:OpFoldResult arith::ExtUIOp::fold(ArrayRef<Attribute> operands) {
   887403: 1008:  if (auto lhs = getIn().getDefiningOp<ExtUIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1009:    getInMutable().assign(lhs.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1010:    return getResult();
call    0 never executed
        -: 1011:  }
   887403: 1012:  Type resType = getType();
call    0 returned 100%
   887403: 1013:  unsigned bitWidth;
   887403: 1014:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1015:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1016:  else
   887403: 1017:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 returned 100%
   887403: 1018:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    2381*: 1019:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    2381*: 1020:        return a.zext(bitWidth);
call    0 returned 100%
call    1 never executed
call    2 never executed
   887403: 1021:      });
call    0 returned 100%
call    1 returned 100%
        -: 1022:}
        -: 1023:
function _ZN4mlir5arith7ExtUIOp17areCastCompatibleENS_9TypeRangeES2_ called 126486599 returned 100% blocks executed 100%
126486599: 1024:bool arith::ExtUIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
126486599: 1025:  return checkWidthChangeCast<std::greater, IntegerType>(inputs, outputs);
call    0 returned 100%
        -: 1026:}
        -: 1027:
function _ZN4mlir5arith7ExtUIOp6verifyEv called 126486599 returned 100% blocks executed 100%
126486599*: 1028:LogicalResult arith::ExtUIOp::verify() {
126486599*: 1029:  return verifyExtOp<IntegerType>(*this);
call    0 never executed
call    1 returned 100%
        -: 1030:}
        -: 1031:
        -: 1032://===----------------------------------------------------------------------===//
        -: 1033:// ExtSIOp
        -: 1034://===----------------------------------------------------------------------===//
        -: 1035:
function _ZN4mlir5arith7ExtSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 604130 returned 100% blocks executed 50%
   604130: 1036:OpFoldResult arith::ExtSIOp::fold(ArrayRef<Attribute> operands) {
   604130: 1037:  if (auto lhs = getIn().getDefiningOp<ExtSIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1038:    getInMutable().assign(lhs.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1039:    return getResult();
call    0 never executed
        -: 1040:  }
   604130: 1041:  Type resType = getType();
call    0 returned 100%
   604130: 1042:  unsigned bitWidth;
   604130: 1043:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1044:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1045:  else
   604130: 1046:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 returned 100%
   604130: 1047:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    2794*: 1048:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    2794*: 1049:        return a.sext(bitWidth);
call    0 returned 100%
call    1 never executed
call    2 never executed
   604130: 1050:      });
call    0 returned 100%
call    1 returned 100%
        -: 1051:}
        -: 1052:
function _ZN4mlir5arith7ExtSIOp17areCastCompatibleENS_9TypeRangeES2_ called 33977097 returned 100% blocks executed 100%
 33977097: 1053:bool arith::ExtSIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
 33977097: 1054:  return checkWidthChangeCast<std::greater, IntegerType>(inputs, outputs);
call    0 returned 100%
        -: 1055:}
        -: 1056:
function _ZN4mlir5arith7ExtSIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1057:void arith::ExtSIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1058:                                                 MLIRContext *context) {
     1235: 1059:  patterns.add<ExtSIOfExtUI>(context);
call    0 returned 100%
     1235: 1060:}
        -: 1061:
function _ZN4mlir5arith7ExtSIOp6verifyEv called 33977097 returned 100% blocks executed 100%
33977097*: 1062:LogicalResult arith::ExtSIOp::verify() {
33977097*: 1063:  return verifyExtOp<IntegerType>(*this);
call    0 never executed
call    1 returned 100%
        -: 1064:}
        -: 1065:
        -: 1066://===----------------------------------------------------------------------===//
        -: 1067:// ExtFOp
        -: 1068://===----------------------------------------------------------------------===//
        -: 1069:
function _ZN4mlir5arith6ExtFOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1070:bool arith::ExtFOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1071:  return checkWidthChangeCast<std::greater, FloatType>(inputs, outputs);
call    0 never executed
        -: 1072:}
        -: 1073:
function _ZN4mlir5arith6ExtFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1074:LogicalResult arith::ExtFOp::verify() { return verifyExtOp<FloatType>(*this); }
call    0 never executed
call    1 never executed
        -: 1075:
        -: 1076://===----------------------------------------------------------------------===//
        -: 1077:// TruncIOp
        -: 1078://===----------------------------------------------------------------------===//
        -: 1079:
function _ZN4mlir5arith8TruncIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1080:OpFoldResult arith::TruncIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1081:  assert(operands.size() == 1 && "unary operation takes one operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1082:
        -: 1083:  // trunci(zexti(a)) -> a
        -: 1084:  // trunci(sexti(a)) -> a
    #####: 1085:  if (matchPattern(getOperand(), m_Op<arith::ExtUIOp>()) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1086:      matchPattern(getOperand(), m_Op<arith::ExtSIOp>()))
call    0 never executed
call    1 never executed
    #####: 1087:    return getOperand().getDefiningOp()->getOperand(0);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1088:
        -: 1089:  // trunci(trunci(a)) -> trunci(a))
    #####: 1090:  if (matchPattern(getOperand(), m_Op<arith::TruncIOp>())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1091:    setOperand(getOperand().getDefiningOp()->getOperand(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1092:    return getResult();
call    0 never executed
        -: 1093:  }
        -: 1094:
    #####: 1095:  Type resType = getType();
call    0 never executed
    #####: 1096:  unsigned bitWidth;
    #####: 1097:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1098:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1099:  else
    #####: 1100:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 never executed
        -: 1101:
    #####: 1102:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    #####: 1103:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    #####: 1104:        return a.trunc(bitWidth);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1105:      });
call    0 never executed
call    1 never executed
        -: 1106:}
        -: 1107:
function _ZN4mlir5arith8TruncIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1108:bool arith::TruncIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1109:  return checkWidthChangeCast<std::less, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1110:}
        -: 1111:
function _ZN4mlir5arith8TruncIOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1112:LogicalResult arith::TruncIOp::verify() {
    #####: 1113:  return verifyTruncateOp<IntegerType>(*this);
call    0 never executed
call    1 never executed
        -: 1114:}
        -: 1115:
        -: 1116://===----------------------------------------------------------------------===//
        -: 1117:// TruncFOp
        -: 1118://===----------------------------------------------------------------------===//
        -: 1119:
        -: 1120:/// Perform safe const propagation for truncf, i.e. only propagate if FP value
        -: 1121:/// can be represented without precision loss or rounding.
function _ZN4mlir5arith8TruncFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1122:OpFoldResult arith::TruncFOp::fold(ArrayRef<Attribute> operands) {
    #####: 1123:  assert(operands.size() == 1 && "unary operation takes one operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1124:
    #####: 1125:  auto constOperand = operands.front();
branch  0 never executed
branch  1 never executed
    #####: 1126:  if (!constOperand || !constOperand.isa<FloatAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1127:    return {};
        -: 1128:
        -: 1129:  // Convert to target type via 'double'.
    #####: 1130:  double sourceValue =
call    0 never executed
    #####: 1131:      constOperand.dyn_cast<FloatAttr>().getValue().convertToDouble();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1132:  auto targetAttr = FloatAttr::get(getType(), sourceValue);
call    0 never executed
        -: 1133:
        -: 1134:  // Propagate if constant's value does not change after truncation.
    #####: 1135:  if (sourceValue == targetAttr.getValue().convertToDouble())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1136:    return targetAttr;
call    0 never executed
        -: 1137:
    #####: 1138:  return {};
        -: 1139:}
        -: 1140:
function _ZN4mlir5arith8TruncFOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1141:bool arith::TruncFOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1142:  return checkWidthChangeCast<std::less, FloatType>(inputs, outputs);
call    0 never executed
        -: 1143:}
        -: 1144:
function _ZN4mlir5arith8TruncFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1145:LogicalResult arith::TruncFOp::verify() {
    #####: 1146:  return verifyTruncateOp<FloatType>(*this);
call    0 never executed
call    1 never executed
        -: 1147:}
        -: 1148:
        -: 1149://===----------------------------------------------------------------------===//
        -: 1150:// AndIOp
        -: 1151://===----------------------------------------------------------------------===//
        -: 1152:
function _ZN4mlir5arith6AndIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1153:void arith::AndIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1154:                                                MLIRContext *context) {
     1235: 1155:  patterns.add<AndOfExtUI, AndOfExtSI>(context);
call    0 returned 100%
     1235: 1156:}
        -: 1157:
        -: 1158://===----------------------------------------------------------------------===//
        -: 1159:// OrIOp
        -: 1160://===----------------------------------------------------------------------===//
        -: 1161:
function _ZN4mlir5arith5OrIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1162:void arith::OrIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1163:                                               MLIRContext *context) {
     1235: 1164:  patterns.add<OrOfExtUI, OrOfExtSI>(context);
call    0 returned 100%
     1235: 1165:}
        -: 1166:
        -: 1167://===----------------------------------------------------------------------===//
        -: 1168:// Verifiers for casts between integers and floats.
        -: 1169://===----------------------------------------------------------------------===//
        -: 1170:
        -: 1171:template <typename From, typename To>
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
        -: 1178:
    #####: 1179:  return srcType && dstType;
        -: 1180:}
------------------
_Z17checkIntFloatCastIN4mlir9FloatTypeENS0_11IntegerTypeEEbNS0_9TypeRangeES3_:
function _Z17checkIntFloatCastIN4mlir9FloatTypeENS0_11IntegerTypeEEbNS0_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
call    0 never executed
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
call    0 never executed
        -: 1178:
    #####: 1179:  return srcType && dstType;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1180:}
------------------
_Z17checkIntFloatCastIN4mlir11IntegerTypeENS0_9FloatTypeEEbNS0_9TypeRangeES3_:
function _Z17checkIntFloatCastIN4mlir11IntegerTypeENS0_9FloatTypeEEbNS0_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
call    0 never executed
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
call    0 never executed
        -: 1178:
    #####: 1179:  return srcType && dstType;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1180:}
------------------
        -: 1181:
        -: 1182://===----------------------------------------------------------------------===//
        -: 1183:// UIToFPOp
        -: 1184://===----------------------------------------------------------------------===//
        -: 1185:
function _ZN4mlir5arith8UIToFPOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1186:bool arith::UIToFPOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1187:  return checkIntFloatCast<IntegerType, FloatType>(inputs, outputs);
call    0 never executed
        -: 1188:}
        -: 1189:
function _ZN4mlir5arith8UIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1190:OpFoldResult arith::UIToFPOp::fold(ArrayRef<Attribute> operands) {
    #####: 1191:  Type resType = getType();
call    0 never executed
    #####: 1192:  Type resEleType;
    #####: 1193:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1194:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1195:  else
    #####: 1196:    resEleType = resType;
    #####: 1197:  return constFoldCastOp<IntegerAttr, FloatAttr>(
function _ZZN4mlir5arith8UIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1198:      operands, getType(), [&resEleType](const APInt &a, bool &castStatus) {
    #####: 1199:        FloatType floatTy = resEleType.cast<FloatType>();
call    0 never executed
    #####: 1200:        APFloat apf(floatTy.getFloatSemantics(),
    #####: 1201:                    APInt::getZero(floatTy.getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1202:        apf.convertFromAPInt(a, /*IsSigned=*/false,
call    0 never executed
        -: 1203:                             APFloat::rmNearestTiesToEven);
    #####: 1204:        return apf;
    #####: 1205:      });
call    0 never executed
call    1 never executed
        -: 1206:}
        -: 1207:
        -: 1208://===----------------------------------------------------------------------===//
        -: 1209:// SIToFPOp
        -: 1210://===----------------------------------------------------------------------===//
        -: 1211:
function _ZN4mlir5arith8SIToFPOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1212:bool arith::SIToFPOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1213:  return checkIntFloatCast<IntegerType, FloatType>(inputs, outputs);
call    0 never executed
        -: 1214:}
        -: 1215:
function _ZN4mlir5arith8SIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 826 returned 100% blocks executed 86%
      826: 1216:OpFoldResult arith::SIToFPOp::fold(ArrayRef<Attribute> operands) {
      826: 1217:  Type resType = getType();
call    0 returned 100%
      826: 1218:  Type resEleType;
      826: 1219:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1220:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1221:  else
      826: 1222:    resEleType = resType;
      826: 1223:  return constFoldCastOp<IntegerAttr, FloatAttr>(
function _ZZN4mlir5arith8SIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntERbE_clES8_S9_.isra.0 called 413 returned 100% blocks executed 82%
      413: 1224:      operands, getType(), [&resEleType](const APInt &a, bool &castStatus) {
      413: 1225:        FloatType floatTy = resEleType.cast<FloatType>();
call    0 returned 100%
      413: 1226:        APFloat apf(floatTy.getFloatSemantics(),
      413: 1227:                    APInt::getZero(floatTy.getWidth()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
      413: 1228:        apf.convertFromAPInt(a, /*IsSigned=*/true,
call    0 returned 100%
        -: 1229:                             APFloat::rmNearestTiesToEven);
      413: 1230:        return apf;
      826: 1231:      });
call    0 returned 100%
call    1 returned 100%
        -: 1232:}
        -: 1233://===----------------------------------------------------------------------===//
        -: 1234:// FPToUIOp
        -: 1235://===----------------------------------------------------------------------===//
        -: 1236:
function _ZN4mlir5arith8FPToUIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1237:bool arith::FPToUIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1238:  return checkIntFloatCast<FloatType, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1239:}
        -: 1240:
function _ZN4mlir5arith8FPToUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1241:OpFoldResult arith::FPToUIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1242:  Type resType = getType();
call    0 never executed
    #####: 1243:  Type resEleType;
    #####: 1244:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1245:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1246:  else
    #####: 1247:    resEleType = resType;
    #####: 1248:  return constFoldCastOp<FloatAttr, IntegerAttr>(
function _ZZN4mlir5arith8FPToUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_7APFloatERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1249:      operands, getType(), [&resEleType](const APFloat &a, bool &castStatus) {
    #####: 1250:        IntegerType intTy = resEleType.cast<IntegerType>();
call    0 never executed
    #####: 1251:        bool ignored;
    #####: 1252:        APSInt api(intTy.getWidth(), /*isUnsigned=*/true);
call    0 never executed
call    1 never executed
    #####: 1253:        castStatus = APFloat::opInvalidOp !=
    #####: 1254:                     a.convertToInteger(api, APFloat::rmTowardZero, &ignored);
call    0 never executed
    #####: 1255:        return api;
    #####: 1256:      });
call    0 never executed
call    1 never executed
        -: 1257:}
        -: 1258:
        -: 1259://===----------------------------------------------------------------------===//
        -: 1260:// FPToSIOp
        -: 1261://===----------------------------------------------------------------------===//
        -: 1262:
function _ZN4mlir5arith8FPToSIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1263:bool arith::FPToSIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1264:  return checkIntFloatCast<FloatType, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1265:}
        -: 1266:
function _ZN4mlir5arith8FPToSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 826 returned 100% blocks executed 86%
      826: 1267:OpFoldResult arith::FPToSIOp::fold(ArrayRef<Attribute> operands) {
      826: 1268:  Type resType = getType();
call    0 returned 100%
      826: 1269:  Type resEleType;
      826: 1270:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1271:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1272:  else
      826: 1273:    resEleType = resType;
      826: 1274:  return constFoldCastOp<FloatAttr, IntegerAttr>(
function _ZZN4mlir5arith8FPToSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_7APFloatERbE_clES8_S9_.isra.0 called 413 returned 100% blocks executed 100%
      413: 1275:      operands, getType(), [&resEleType](const APFloat &a, bool &castStatus) {
      413: 1276:        IntegerType intTy = resEleType.cast<IntegerType>();
call    0 returned 100%
      413: 1277:        bool ignored;
      413: 1278:        APSInt api(intTy.getWidth(), /*isUnsigned=*/false);
call    0 returned 100%
call    1 returned 100%
      826: 1279:        castStatus = APFloat::opInvalidOp !=
      413: 1280:                     a.convertToInteger(api, APFloat::rmTowardZero, &ignored);
call    0 returned 100%
      413: 1281:        return api;
      826: 1282:      });
call    0 returned 100%
call    1 returned 100%
        -: 1283:}
        -: 1284:
        -: 1285://===----------------------------------------------------------------------===//
        -: 1286:// IndexCastOp
        -: 1287://===----------------------------------------------------------------------===//
        -: 1288:
function _ZL22areIndexCastCompatibleN4mlir9TypeRangeES0_ called 34571 returned 100% blocks executed 72%
    34571: 1289:static bool areIndexCastCompatible(TypeRange inputs, TypeRange outputs) {
    34571: 1290:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1291:    return false;
        -: 1292:
    34571: 1293:  auto srcType = getTypeIfLikeOrMemRef<IntegerType, IndexType>(inputs.front());
call    0 returned 100%
    34571: 1294:  auto dstType = getTypeIfLikeOrMemRef<IntegerType, IndexType>(outputs.front());
call    0 returned 100%
    34571: 1295:  if (!srcType || !dstType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1296:    return false;
        -: 1297:
   34571*: 1298:  return (srcType.isIndex() && dstType.isSignlessInteger()) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 never executed
branch  7 never executed
    #####: 1299:         (srcType.isSignlessInteger() && dstType.isIndex());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1300:}
        -: 1301:
function _ZN4mlir5arith11IndexCastOp17areCastCompatibleENS_9TypeRangeES2_ called 34571 returned 100% blocks executed 100%
    34571: 1302:bool arith::IndexCastOp::areCastCompatible(TypeRange inputs,
        -: 1303:                                           TypeRange outputs) {
    34571: 1304:  return areIndexCastCompatible(inputs, outputs);
call    0 returned 100%
        -: 1305:}
        -: 1306:
function _ZN4mlir5arith11IndexCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 1321 returned 100% blocks executed 92%
     1321: 1307:OpFoldResult arith::IndexCastOp::fold(ArrayRef<Attribute> operands) {
        -: 1308:  // index_cast(constant) -> constant
        -: 1309:  // A little hack because we go through int. Otherwise, the size of the
        -: 1310:  // constant might need to change.
     2168: 1311:  if (auto value = operands[0].dyn_cast_or_null<IntegerAttr>())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 64% (fallthrough)
branch  3 taken 36%
branch  4 taken 64% (fallthrough)
branch  5 taken 36%
      847: 1312:    return IntegerAttr::get(getType(), value.getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1313:
      474: 1314:  return {};
        -: 1315:}
        -: 1316:
function _ZN4mlir5arith11IndexCastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1317:void arith::IndexCastOp::getCanonicalizationPatterns(
        -: 1318:    RewritePatternSet &patterns, MLIRContext *context) {
     1235: 1319:  patterns.add<IndexCastOfIndexCast, IndexCastOfExtSI>(context);
call    0 returned 100%
     1235: 1320:}
        -: 1321:
        -: 1322://===----------------------------------------------------------------------===//
        -: 1323:// IndexCastUIOp
        -: 1324://===----------------------------------------------------------------------===//
        -: 1325:
function _ZN4mlir5arith13IndexCastUIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1326:bool arith::IndexCastUIOp::areCastCompatible(TypeRange inputs,
        -: 1327:                                             TypeRange outputs) {
    #####: 1328:  return areIndexCastCompatible(inputs, outputs);
call    0 never executed
        -: 1329:}
        -: 1330:
function _ZN4mlir5arith13IndexCastUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1331:OpFoldResult arith::IndexCastUIOp::fold(ArrayRef<Attribute> operands) {
        -: 1332:  // index_castui(constant) -> constant
        -: 1333:  // A little hack because we go through int. Otherwise, the size of the
        -: 1334:  // constant might need to change.
    #####: 1335:  if (auto value = operands[0].dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1336:    return IntegerAttr::get(getType(), value.getValue().getZExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1337:
    #####: 1338:  return {};
        -: 1339:}
        -: 1340:
function _ZN4mlir5arith13IndexCastUIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1341:void arith::IndexCastUIOp::getCanonicalizationPatterns(
        -: 1342:    RewritePatternSet &patterns, MLIRContext *context) {
     1235: 1343:  patterns.add<IndexCastUIOfIndexCastUI, IndexCastUIOfExtUI>(context);
call    0 returned 100%
     1235: 1344:}
        -: 1345:
        -: 1346://===----------------------------------------------------------------------===//
        -: 1347:// BitcastOp
        -: 1348://===----------------------------------------------------------------------===//
        -: 1349:
function _ZN4mlir5arith9BitcastOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1350:bool arith::BitcastOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1351:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1352:    return false;
        -: 1353:
    #####: 1354:  auto srcType =
    #####: 1355:      getTypeIfLikeOrMemRef<IntegerType, IndexType, FloatType>(inputs.front());
call    0 never executed
    #####: 1356:  auto dstType =
    #####: 1357:      getTypeIfLikeOrMemRef<IntegerType, IndexType, FloatType>(outputs.front());
call    0 never executed
    #####: 1358:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1359:    return false;
        -: 1360:
    #####: 1361:  return srcType.getIntOrFloatBitWidth() == dstType.getIntOrFloatBitWidth();
call    0 never executed
call    1 never executed
        -: 1362:}
        -: 1363:
function _ZN4mlir5arith9BitcastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1364:OpFoldResult arith::BitcastOp::fold(ArrayRef<Attribute> operands) {
    #####: 1365:  assert(operands.size() == 1 && "bitcast op expects 1 operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1366:
    #####: 1367:  auto resType = getType();
branch  0 never executed
branch  1 never executed
    #####: 1368:  auto operand = operands[0];
branch  0 never executed
branch  1 never executed
    #####: 1369:  if (!operand)
branch  0 never executed
branch  1 never executed
    #####: 1370:    return {};
        -: 1371:
        -: 1372:  /// Bitcast dense elements.
    #####: 1373:  if (auto denseAttr = operand.dyn_cast_or_null<DenseElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1374:    return denseAttr.bitcast(resType.cast<ShapedType>().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1375:  /// Other shaped types unhandled.
    #####: 1376:  if (resType.isa<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1377:    return {};
        -: 1378:
        -: 1379:  /// Bitcast integer or float to integer or float.
    #####: 1380:  APInt bits = operand.isa<FloatAttr>()
call    0 never executed
    #####: 1381:                   ? operand.cast<FloatAttr>().getValue().bitcastToAPInt()
call    0 never executed
    #####: 1382:                   : operand.cast<IntegerAttr>().getValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1383:
    #####: 1384:  if (auto resFloatType = resType.dyn_cast<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1385:    return FloatAttr::get(resType,
    #####: 1386:                          APFloat(resFloatType.getFloatSemantics(), bits));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1387:  return IntegerAttr::get(resType, bits);
call    0 never executed
call    1 never executed
        -: 1388:}
        -: 1389:
function _ZN4mlir5arith9BitcastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1390:void arith::BitcastOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1391:                                                   MLIRContext *context) {
     1235: 1392:  patterns.add<BitcastOfBitcast>(context);
call    0 returned 100%
     1235: 1393:}
        -: 1394:
        -: 1395://===----------------------------------------------------------------------===//
        -: 1396:// Helpers for compare ops
        -: 1397://===----------------------------------------------------------------------===//
        -: 1398:
        -: 1399:/// Return the type of the same shape (scalar, vector or tensor) containing i1.
function _ZL14getI1SameShapeN4mlir4TypeE called 116869820 returned 100% blocks executed 74%
116869820: 1400:static Type getI1SameShape(Type type) {
116869820: 1401:  auto i1Type = IntegerType::get(type.getContext(), 1);
call    0 returned 100%
call    1 returned 100%
116869822: 1402:  if (auto tensorType = type.dyn_cast<RankedTensorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1403:    return RankedTensorType::get(tensorType.getShape(), i1Type);
call    0 never executed
call    1 never executed
116869822: 1404:  if (type.isa<UnrankedTensorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1405:    return UnrankedTensorType::get(i1Type);
call    0 never executed
116869822: 1406:  if (auto vectorType = type.dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
    75114: 1407:    return VectorType::get(vectorType.getShape(), i1Type,
    37557: 1408:                           vectorType.getNumScalableDims());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
116832265: 1409:  return i1Type;
        -: 1410:}
        -: 1411:
        -: 1412://===----------------------------------------------------------------------===//
        -: 1413:// CmpIOp
        -: 1414://===----------------------------------------------------------------------===//
        -: 1415:
        -: 1416:/// Compute `lhs` `pred` `rhs`, where `pred` is one of the known integer
        -: 1417:/// comparison predicates.
function _ZN4mlir5arith17applyCmpPredicateENS0_13CmpIPredicateERKN4llvm5APIntES5_ called 121074 returned 100% blocks executed 93%
   121074: 1418:bool mlir::arith::applyCmpPredicate(arith::CmpIPredicate predicate,
        -: 1419:                                    const APInt &lhs, const APInt &rhs) {
   121074: 1420:  switch (predicate) {
branch  0 taken 9%
branch  1 taken 8%
branch  2 taken 13%
branch  3 taken 8%
branch  4 taken 17%
branch  5 taken 9%
branch  6 taken 7%
branch  7 taken 8%
branch  8 taken 12%
branch  9 taken 9%
branch 10 taken 0%
    10607: 1421:  case arith::CmpIPredicate::eq:
    10607: 1422:    return lhs.eq(rhs);
call    0 returned 100%
     9438: 1423:  case arith::CmpIPredicate::ne:
     9438: 1424:    return lhs.ne(rhs);
call    0 returned 100%
    15493: 1425:  case arith::CmpIPredicate::slt:
    15493: 1426:    return lhs.slt(rhs);
    10210: 1427:  case arith::CmpIPredicate::sle:
    10210: 1428:    return lhs.sle(rhs);
    20883: 1429:  case arith::CmpIPredicate::sgt:
    20883: 1430:    return lhs.sgt(rhs);
    11423: 1431:  case arith::CmpIPredicate::sge:
    11423: 1432:    return lhs.sge(rhs);
     8096: 1433:  case arith::CmpIPredicate::ult:
     8096: 1434:    return lhs.ult(rhs);
     9894: 1435:  case arith::CmpIPredicate::ule:
     9894: 1436:    return lhs.ule(rhs);
    13937: 1437:  case arith::CmpIPredicate::ugt:
    13937: 1438:    return lhs.ugt(rhs);
    11093: 1439:  case arith::CmpIPredicate::uge:
    11093: 1440:    return lhs.uge(rhs);
        -: 1441:  }
    #####: 1442:  llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1443:}
        -: 1444:
        -: 1445:/// Returns true if the predicate is true for two equal operands.
function _ZL32applyCmpPredicateToEqualOperandsN4mlir5arith13CmpIPredicateE called 49270 returned 100% blocks executed 75%
    49270: 1446:static bool applyCmpPredicateToEqualOperands(arith::CmpIPredicate predicate) {
    49270: 1447:  switch (predicate) {
branch  0 taken 53%
branch  1 taken 0%
branch  2 taken 47%
        -: 1448:  case arith::CmpIPredicate::eq:
        -: 1449:  case arith::CmpIPredicate::sle:
        -: 1450:  case arith::CmpIPredicate::sge:
        -: 1451:  case arith::CmpIPredicate::ule:
        -: 1452:  case arith::CmpIPredicate::uge:
        -: 1453:    return true;
    25956: 1454:  case arith::CmpIPredicate::ne:
    25956: 1455:  case arith::CmpIPredicate::slt:
    25956: 1456:  case arith::CmpIPredicate::sgt:
    25956: 1457:  case arith::CmpIPredicate::ult:
    25956: 1458:  case arith::CmpIPredicate::ugt:
    25956: 1459:    return false;
        -: 1460:  }
    #####: 1461:  llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1462:}
        -: 1463:
function _ZL16getBoolAttributeN4mlir4TypeEPNS_11MLIRContextEb called 49270 returned 100% blocks executed 78%
    49270: 1464:static Attribute getBoolAttribute(Type type, MLIRContext *ctx, bool value) {
    49270: 1465:  auto boolAttr = BoolAttr::get(ctx, value);
call    0 returned 100%
    49270: 1466:  ShapedType shapedType = type.dyn_cast_or_null<ShapedType>();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    49270: 1467:  if (!shapedType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    49270: 1468:    return boolAttr;
    #####: 1469:  return DenseElementsAttr::get(shapedType, boolAttr);
call    0 never executed
        -: 1470:}
        -: 1471:
function _ZN4mlir5arith6CmpIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 234352 returned 100% blocks executed 66%
   234352: 1472:OpFoldResult arith::CmpIOp::fold(ArrayRef<Attribute> operands) {
  234352*: 1473:  assert(operands.size() == 2 && "cmpi takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1474:
        -: 1475:  // cmpi(pred, x, x)
   234352: 1476:  if (getLhs() == getRhs()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 21% (fallthrough)
branch  3 taken 79%
    98540: 1477:    auto val = applyCmpPredicateToEqualOperands(getPredicate());
call    0 returned 100%
call    1 returned 100%
    49270: 1478:    return getBoolAttribute(getType(), getContext(), val);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1479:  }
        -: 1480:
   185082: 1481:  if (matchPattern(getRhs(), m_Zero())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 23% (fallthrough)
branch  3 taken 77%
    43031: 1482:    if (auto extOp = getLhs().getDefiningOp<ExtSIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1483:      // extsi(%x : i1 -> iN) != 0  ->  %x
    #####: 1484:      if (extOp.getOperand().getType().cast<IntegerType>().getWidth() == 1 &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1485:          getPredicate() == arith::CmpIPredicate::ne)
branch  0 never executed
branch  1 never executed
    #####: 1486:        return extOp.getOperand();
call    0 never executed
call    1 never executed
        -: 1487:    }
    43031: 1488:    if (auto extOp = getLhs().getDefiningOp<ExtUIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1489:      // extui(%x : i1 -> iN) != 0  ->  %x
    #####: 1490:      if (extOp.getOperand().getType().cast<IntegerType>().getWidth() == 1 &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1491:          getPredicate() == arith::CmpIPredicate::ne)
branch  0 never executed
branch  1 never executed
    #####: 1492:        return extOp.getOperand();
call    0 never executed
call    1 never executed
        -: 1493:    }
        -: 1494:  }
        -: 1495:
        -: 1496:  // Move constant to the right side.
   185081: 1497:  if (operands[0] && !operands[1]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 74% (fallthrough)
branch  3 taken 26%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 85% (fallthrough)
branch  7 taken 15%
        -: 1498:    // Do not use invertPredicate, as it will change eq to ne and vice versa.
    20051: 1499:    using Pred = CmpIPredicate;
    20051: 1500:    const std::pair<Pred, Pred> invPreds[] = {
        -: 1501:        {Pred::slt, Pred::sgt}, {Pred::sgt, Pred::slt}, {Pred::sle, Pred::sge},
        -: 1502:        {Pred::sge, Pred::sle}, {Pred::ult, Pred::ugt}, {Pred::ugt, Pred::ult},
        -: 1503:        {Pred::ule, Pred::uge}, {Pred::uge, Pred::ule}, {Pred::eq, Pred::eq},
        -: 1504:        {Pred::ne, Pred::ne},
        -: 1505:    };
    20051: 1506:    Pred origPred = getPredicate();
call    0 returned 100%
    80597: 1507:    for (auto pred : invPreds) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    80597: 1508:      if (origPred == pred.first) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
    20051: 1509:        setPredicate(pred.second);
call    0 returned 100%
    20051: 1510:        Value lhs = getLhs();
call    0 returned 100%
    20051: 1511:        Value rhs = getRhs();
call    0 returned 100%
    20051: 1512:        getLhsMutable().assign(rhs);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    20051: 1513:        getRhsMutable().assign(lhs);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    20051: 1514:        return getResult();
call    0 returned 100%
call    1 returned 100%
        -: 1515:      }
        -: 1516:    }
    #####: 1517:    llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1518:  }
        -: 1519:
   165030: 1520:  auto lhs = operands.front().dyn_cast_or_null<IntegerAttr>();
branch  0 taken 71%
branch  1 taken 29%
   165030: 1521:  if (!lhs)
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
    48629: 1522:    return {};
        -: 1523:
        -: 1524:  // We are moving constants to the right side; So if lhs is constant rhs is
        -: 1525:  // guaranteed to be a constant.
   116401: 1526:  auto rhs = operands.back().cast<IntegerAttr>();
call    0 returned 100%
call    1 returned 100%
        -: 1527:
   232802: 1528:  auto val = applyCmpPredicate(getPredicate(), lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
   116401: 1529:  return BoolAttr::get(getContext(), val);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1530:}
        -: 1531:
function _ZN4mlir5arith6CmpIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1532:void arith::CmpIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1533:                                                MLIRContext *context) {
     1235: 1534:  patterns.insert<CmpIExtSI, CmpIExtUI>(context);
call    0 returned 100%
     1235: 1535:}
        -: 1536:
        -: 1537://===----------------------------------------------------------------------===//
        -: 1538:// CmpFOp
        -: 1539://===----------------------------------------------------------------------===//
        -: 1540:
        -: 1541:/// Compute `lhs` `pred` `rhs`, where `pred` is one of the known floating point
        -: 1542:/// comparison predicates.
function _ZN4mlir5arith17applyCmpPredicateENS0_13CmpFPredicateERKN4llvm7APFloatES5_ called 119643 returned 100% blocks executed 95%
   119643: 1543:bool mlir::arith::applyCmpPredicate(arith::CmpFPredicate predicate,
        -: 1544:                                    const APFloat &lhs, const APFloat &rhs) {
   119643: 1545:  auto cmpResult = lhs.compare(rhs);
call    0 returned 100%
   119643: 1546:  switch (predicate) {
branch  0 taken 4%
branch  1 taken 8%
branch  2 taken 4%
branch  3 taken 7%
branch  4 taken 5%
branch  5 taken 8%
branch  6 taken 6%
branch  7 taken 6%
branch  8 taken 6%
branch  9 taken 7%
branch 10 taken 7%
branch 11 taken 5%
branch 12 taken 6%
branch 13 taken 6%
branch 14 taken 6%
branch 15 taken 0%
branch 16 taken 7%
        -: 1547:  case arith::CmpFPredicate::AlwaysFalse:
        -: 1548:    return false;
     4706: 1549:  case arith::CmpFPredicate::OEQ:
     4706: 1550:    return cmpResult == APFloat::cmpEqual;
     9640: 1551:  case arith::CmpFPredicate::OGT:
     9640: 1552:    return cmpResult == APFloat::cmpGreaterThan;
     5237: 1553:  case arith::CmpFPredicate::OGE:
     5237: 1554:    return cmpResult == APFloat::cmpGreaterThan ||
     5237: 1555:           cmpResult == APFloat::cmpEqual;
     8266: 1556:  case arith::CmpFPredicate::OLT:
     8266: 1557:    return cmpResult == APFloat::cmpLessThan;
     5701: 1558:  case arith::CmpFPredicate::OLE:
     5701: 1559:    return cmpResult == APFloat::cmpLessThan || cmpResult == APFloat::cmpEqual;
     9276: 1560:  case arith::CmpFPredicate::ONE:
     9276: 1561:    return cmpResult != APFloat::cmpUnordered && cmpResult != APFloat::cmpEqual;
     7305: 1562:  case arith::CmpFPredicate::ORD:
     7305: 1563:    return cmpResult != APFloat::cmpUnordered;
     6696: 1564:  case arith::CmpFPredicate::UEQ:
     6696: 1565:    return cmpResult == APFloat::cmpUnordered || cmpResult == APFloat::cmpEqual;
     7208: 1566:  case arith::CmpFPredicate::UGT:
     7208: 1567:    return cmpResult == APFloat::cmpUnordered ||
     7208: 1568:           cmpResult == APFloat::cmpGreaterThan;
     8868: 1569:  case arith::CmpFPredicate::UGE:
     8868: 1570:    return cmpResult == APFloat::cmpUnordered ||
     8868: 1571:           cmpResult == APFloat::cmpGreaterThan ||
     8868: 1572:           cmpResult == APFloat::cmpEqual;
     8770: 1573:  case arith::CmpFPredicate::ULT:
     8770: 1574:    return cmpResult == APFloat::cmpUnordered ||
     8770: 1575:           cmpResult == APFloat::cmpLessThan;
     6290: 1576:  case arith::CmpFPredicate::ULE:
     6290: 1577:    return cmpResult == APFloat::cmpUnordered ||
     6290: 1578:           cmpResult == APFloat::cmpLessThan || cmpResult == APFloat::cmpEqual;
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
branch  2 taken 55% (fallthrough)
branch  3 taken 45%
     7743: 1579:  case arith::CmpFPredicate::UNE:
     7743: 1580:    return cmpResult != APFloat::cmpEqual;
     7372: 1581:  case arith::CmpFPredicate::UNO:
     7372: 1582:    return cmpResult == APFloat::cmpUnordered;
     7678: 1583:  case arith::CmpFPredicate::AlwaysTrue:
     7678: 1584:    return true;
        -: 1585:  }
    #####: 1586:  llvm_unreachable("unknown cmpf predicate kind");
call    0 never executed
        -: 1587:}
        -: 1588:
function _ZN4mlir5arith6CmpFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 155349 returned 100% blocks executed 88%
   155349: 1589:OpFoldResult arith::CmpFOp::fold(ArrayRef<Attribute> operands) {
  155349*: 1590:  assert(operands.size() == 2 && "cmpf takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1591:
   155349: 1592:  auto lhs = operands.front().dyn_cast_or_null<FloatAttr>();
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
   155349: 1593:  auto rhs = operands.back().dyn_cast_or_null<FloatAttr>();
call    0 returned 100%
branch  1 taken 86% (fallthrough)
branch  2 taken 14%
        -: 1594:
        -: 1595:  // If one operand is NaN, making them both NaN does not change the result.
   287278: 1596:  if (lhs && lhs.getValue().isNaN())
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 85% (fallthrough)
branch  8 taken 15%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
    #####: 1597:    rhs = lhs;
   288246: 1598:  if (rhs && rhs.getValue().isNaN())
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 86% (fallthrough)
branch  8 taken 14%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
    #####: 1599:    lhs = rhs;
        -: 1600:
   155349: 1601:  if (!lhs || !rhs)
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
    35706: 1602:    return {};
        -: 1603:
   239286: 1604:  auto val = applyCmpPredicate(getPredicate(), lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
   119643: 1605:  return BoolAttr::get(getContext(), val);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1606:}
        -: 1607:
        -: 1608:class CmpFIntToFPConst final : public OpRewritePattern<CmpFOp> {
        -: 1609:public:
        -: 1610:  using OpRewritePattern<CmpFOp>::OpRewritePattern;
        -: 1611:
function _ZN16CmpFIntToFPConst25convertToIntegerPredicateEN4mlir5arith13CmpFPredicateEb called 0 returned 0% blocks executed 0%
    #####: 1612:  static CmpIPredicate convertToIntegerPredicate(CmpFPredicate pred,
        -: 1613:                                                 bool isUnsigned) {
    #####: 1614:    using namespace arith;
    #####: 1615:    switch (pred) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1616:    case CmpFPredicate::UEQ:
        -: 1617:    case CmpFPredicate::OEQ:
        -: 1618:      return CmpIPredicate::eq;
    #####: 1619:    case CmpFPredicate::UGT:
    #####: 1620:    case CmpFPredicate::OGT:
    #####: 1621:      return isUnsigned ? CmpIPredicate::ugt : CmpIPredicate::sgt;
branch  0 never executed
branch  1 never executed
    #####: 1622:    case CmpFPredicate::UGE:
    #####: 1623:    case CmpFPredicate::OGE:
    #####: 1624:      return isUnsigned ? CmpIPredicate::uge : CmpIPredicate::sge;
branch  0 never executed
branch  1 never executed
    #####: 1625:    case CmpFPredicate::ULT:
    #####: 1626:    case CmpFPredicate::OLT:
    #####: 1627:      return isUnsigned ? CmpIPredicate::ult : CmpIPredicate::slt;
branch  0 never executed
branch  1 never executed
    #####: 1628:    case CmpFPredicate::ULE:
    #####: 1629:    case CmpFPredicate::OLE:
    #####: 1630:      return isUnsigned ? CmpIPredicate::ule : CmpIPredicate::sle;
branch  0 never executed
branch  1 never executed
    #####: 1631:    case CmpFPredicate::UNE:
    #####: 1632:    case CmpFPredicate::ONE:
    #####: 1633:      return CmpIPredicate::ne;
    #####: 1634:    default:
    #####: 1635:      llvm_unreachable("Unexpected predicate!");
call    0 never executed
        -: 1636:    }
        -: 1637:  }
        -: 1638:
function _ZNK16CmpFIntToFPConst15matchAndRewriteEN4mlir5arith6CmpFOpERNS0_15PatternRewriterE called 9 returned 100% blocks executed 10%
        9: 1639:  LogicalResult matchAndRewrite(CmpFOp op,
        -: 1640:                                PatternRewriter &rewriter) const override {
        9: 1641:    FloatAttr flt;
        9: 1642:    if (!matchPattern(op.getRhs(), m_Constant(&flt)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1643:      return failure();
        -: 1644:
        9: 1645:    const APFloat &rhs = flt.getValue();
call    0 returned 100%
        -: 1646:
        -: 1647:    // Don't attempt to fold a nan.
        9: 1648:    if (rhs.isNaN())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1649:      return failure();
        -: 1650:
        -: 1651:    // Get the width of the mantissa.  We don't want to hack on conversions that
        -: 1652:    // might lose information from the integer, e.g. "i64 -> float"
        9: 1653:    FloatType floatTy = op.getRhs().getType().cast<FloatType>();
call    0 returned 100%
call    1 returned 100%
        9: 1654:    int mantissaWidth = floatTy.getFPMantissaWidth();
call    0 returned 100%
        9: 1655:    if (mantissaWidth <= 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1656:      return failure();
        -: 1657:
        9: 1658:    bool isUnsigned;
        9: 1659:    Value intVal;
        -: 1660:
        9: 1661:    if (auto si = op.getLhs().getDefiningOp<SIToFPOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1662:      isUnsigned = false;
    #####: 1663:      intVal = si.getIn();
call    0 never executed
        9: 1664:    } else if (auto ui = op.getLhs().getDefiningOp<UIToFPOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1665:      isUnsigned = true;
    #####: 1666:      intVal = ui.getIn();
call    0 never executed
        -: 1667:    } else {
        9: 1668:      return failure();
        -: 1669:    }
        -: 1670:
        -: 1671:    // Check to see that the input is converted from an integer type that is
        -: 1672:    // small enough that preserves all bits.
    #####: 1673:    auto intTy = intVal.getType().cast<IntegerType>();
call    0 never executed
    #####: 1674:    auto intWidth = intTy.getWidth();
call    0 never executed
        -: 1675:
        -: 1676:    // Number of bits representing values, as opposed to the sign
    #####: 1677:    auto valueBits = isUnsigned ? intWidth : (intWidth - 1);
branch  0 never executed
branch  1 never executed
        -: 1678:
        -: 1679:    // Following test does NOT adjust intWidth downwards for signed inputs,
        -: 1680:    // because the most negative value still requires all the mantissa bits
        -: 1681:    // to distinguish it from one less than that value.
    #####: 1682:    if ((int)intWidth > mantissaWidth) {
branch  0 never executed
branch  1 never executed
        -: 1683:      // Conversion would lose accuracy. Check if loss can impact comparison.
    #####: 1684:      int exponent = ilogb(rhs);
call    0 never executed
    #####: 1685:      if (exponent == APFloat::IEK_Inf) {
branch  0 never executed
branch  1 never executed
    #####: 1686:        int maxExponent = ilogb(APFloat::getLargest(rhs.getSemantics()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1687:        if (maxExponent < (int)valueBits) {
branch  0 never executed
branch  1 never executed
        -: 1688:          // Conversion could create infinity.
    #####: 1689:          return failure();
        -: 1690:        }
        -: 1691:      } else {
        -: 1692:        // Note that if rhs is zero or NaN, then Exp is negative
        -: 1693:        // and first condition is trivially false.
    #####: 1694:        if (mantissaWidth <= exponent && exponent <= (int)valueBits) {
branch  0 never executed
branch  1 never executed
        -: 1695:          // Conversion could affect comparison.
    #####: 1696:          return failure();
        -: 1697:        }
        -: 1698:      }
        -: 1699:    }
        -: 1700:
        -: 1701:    // Convert to equivalent cmpi predicate
    #####: 1702:    CmpIPredicate pred;
    #####: 1703:    switch (op.getPredicate()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1704:    case CmpFPredicate::ORD:
        -: 1705:      // Int to fp conversion doesn't create a nan (ord checks neither is a nan)
    #####: 1706:      rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1707:                                                 /*width=*/1);
call    0 never executed
    #####: 1708:      return success();
    #####: 1709:    case CmpFPredicate::UNO:
        -: 1710:      // Int to fp conversion doesn't create a nan (uno checks either is a nan)
    #####: 1711:      rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1712:                                                 /*width=*/1);
call    0 never executed
    #####: 1713:      return success();
    #####: 1714:    default:
    #####: 1715:      pred = convertToIntegerPredicate(op.getPredicate(), isUnsigned);
call    0 never executed
call    1 never executed
    #####: 1716:      break;
        -: 1717:    }
        -: 1718:
    #####: 1719:    if (!isUnsigned) {
branch  0 never executed
branch  1 never executed
        -: 1720:      // If the rhs value is > SignedMax, fold the comparison.  This handles
        -: 1721:      // +INF and large values.
    #####: 1722:      APFloat signedMax(rhs.getSemantics());
call    0 never executed
    #####: 1723:      signedMax.convertFromAPInt(APInt::getSignedMaxValue(intWidth), true,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1724:                                 APFloat::rmNearestTiesToEven);
    #####: 1725:      if (signedMax < rhs) { // smax < 13123.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1726:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::slt ||
branch  0 never executed
branch  1 never executed
        -: 1727:            pred == CmpIPredicate::sle)
    #####: 1728:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1729:                                                     /*width=*/1);
call    0 never executed
        -: 1730:        else
    #####: 1731:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1732:                                                     /*width=*/1);
call    0 never executed
    #####: 1733:        return success();
call    0 never executed
        -: 1734:      }
        -: 1735:    } else {
        -: 1736:      // If the rhs value is > UnsignedMax, fold the comparison. This handles
        -: 1737:      // +INF and large values.
    #####: 1738:      APFloat unsignedMax(rhs.getSemantics());
call    0 never executed
    #####: 1739:      unsignedMax.convertFromAPInt(APInt::getMaxValue(intWidth), false,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1740:                                   APFloat::rmNearestTiesToEven);
    #####: 1741:      if (unsignedMax < rhs) { // umax < 13123.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1742:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::ult ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1743:            pred == CmpIPredicate::ule)
    #####: 1744:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1745:                                                     /*width=*/1);
call    0 never executed
        -: 1746:        else
    #####: 1747:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1748:                                                     /*width=*/1);
call    0 never executed
    #####: 1749:        return success();
call    0 never executed
        -: 1750:      }
        -: 1751:    }
        -: 1752:
    #####: 1753:    if (!isUnsigned) {
branch  0 never executed
branch  1 never executed
        -: 1754:      // See if the rhs value is < SignedMin.
    #####: 1755:      APFloat signedMin(rhs.getSemantics());
call    0 never executed
    #####: 1756:      signedMin.convertFromAPInt(APInt::getSignedMinValue(intWidth), true,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1757:                                 APFloat::rmNearestTiesToEven);
    #####: 1758:      if (signedMin > rhs) { // smin > 12312.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1759:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::sgt ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1760:            pred == CmpIPredicate::sge)
    #####: 1761:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1762:                                                     /*width=*/1);
call    0 never executed
        -: 1763:        else
    #####: 1764:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1765:                                                     /*width=*/1);
call    0 never executed
    #####: 1766:        return success();
call    0 never executed
        -: 1767:      }
        -: 1768:    } else {
        -: 1769:      // See if the rhs value is < UnsignedMin.
    #####: 1770:      APFloat unsignedMin(rhs.getSemantics());
call    0 never executed
    #####: 1771:      unsignedMin.convertFromAPInt(APInt::getMinValue(intWidth), false,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1772:                                   APFloat::rmNearestTiesToEven);
    #####: 1773:      if (unsignedMin > rhs) { // umin > 12312.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1774:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::ugt ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1775:            pred == CmpIPredicate::uge)
    #####: 1776:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1777:                                                     /*width=*/1);
call    0 never executed
        -: 1778:        else
    #####: 1779:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1780:                                                     /*width=*/1);
call    0 never executed
    #####: 1781:        return success();
call    0 never executed
        -: 1782:      }
        -: 1783:    }
        -: 1784:
        -: 1785:    // Okay, now we know that the FP constant fits in the range [SMIN, SMAX] or
        -: 1786:    // [0, UMAX], but it may still be fractional.  See if it is fractional by
        -: 1787:    // casting the FP value to the integer value and back, checking for
        -: 1788:    // equality. Don't do this for zero, because -0.0 is not fractional.
    #####: 1789:    bool ignored;
       9*: 1790:    APSInt rhsInt(intWidth, isUnsigned);
call    0 never executed
call    1 returned 100%
    #####: 1791:    if (APFloat::opInvalidOp ==
branch  0 never executed
branch  1 never executed
    #####: 1792:        rhs.convertToInteger(rhsInt, APFloat::rmTowardZero, &ignored)) {
call    0 never executed
        -: 1793:      // Undefined behavior invoked - the destination type can't represent
        -: 1794:      // the input constant.
    #####: 1795:      return failure();
        -: 1796:    }
        -: 1797:
    #####: 1798:    if (!rhs.isZero()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1799:      APFloat apf(floatTy.getFloatSemantics(),
    #####: 1800:                  APInt::getZero(floatTy.getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1801:      apf.convertFromAPInt(rhsInt, !isUnsigned, APFloat::rmNearestTiesToEven);
call    0 never executed
        -: 1802:
    #####: 1803:      bool equal = apf == rhs;
call    0 never executed
    #####: 1804:      if (!equal) {
branch  0 never executed
branch  1 never executed
        -: 1805:        // If we had a comparison against a fractional value, we have to adjust
        -: 1806:        // the compare predicate and sometimes the value.  rhsInt is rounded
        -: 1807:        // towards zero at this point.
    #####: 1808:        switch (pred) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1809:        case CmpIPredicate::ne: // (float)int != 4.4   --> true
    #####: 1810:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1811:                                                     /*width=*/1);
call    0 never executed
    #####: 1812:          return success();
    #####: 1813:        case CmpIPredicate::eq: // (float)int == 4.4   --> false
    #####: 1814:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1815:                                                     /*width=*/1);
call    0 never executed
    #####: 1816:          return success();
    #####: 1817:        case CmpIPredicate::ule:
        -: 1818:          // (float)int <= 4.4   --> int <= 4
        -: 1819:          // (float)int <= -4.4  --> false
    #####: 1820:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1821:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1822:                                                       /*width=*/1);
call    0 never executed
    #####: 1823:            return success();
        -: 1824:          }
        -: 1825:          break;
    #####: 1826:        case CmpIPredicate::sle:
        -: 1827:          // (float)int <= 4.4   --> int <= 4
        -: 1828:          // (float)int <= -4.4  --> int < -4
    #####: 1829:          if (rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1830:            pred = CmpIPredicate::slt;
        -: 1831:          break;
    #####: 1832:        case CmpIPredicate::ult:
        -: 1833:          // (float)int < -4.4   --> false
        -: 1834:          // (float)int < 4.4    --> int <= 4
    #####: 1835:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1836:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1837:                                                       /*width=*/1);
call    0 never executed
    #####: 1838:            return success();
        -: 1839:          }
    #####: 1840:          pred = CmpIPredicate::ule;
    #####: 1841:          break;
    #####: 1842:        case CmpIPredicate::slt:
        -: 1843:          // (float)int < -4.4   --> int < -4
        -: 1844:          // (float)int < 4.4    --> int <= 4
    #####: 1845:          if (!rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1846:            pred = CmpIPredicate::sle;
        -: 1847:          break;
    #####: 1848:        case CmpIPredicate::ugt:
        -: 1849:          // (float)int > 4.4    --> int > 4
        -: 1850:          // (float)int > -4.4   --> true
    #####: 1851:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1852:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1853:                                                       /*width=*/1);
call    0 never executed
    #####: 1854:            return success();
        -: 1855:          }
        -: 1856:          break;
    #####: 1857:        case CmpIPredicate::sgt:
        -: 1858:          // (float)int > 4.4    --> int > 4
        -: 1859:          // (float)int > -4.4   --> int >= -4
    #####: 1860:          if (rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1861:            pred = CmpIPredicate::sge;
        -: 1862:          break;
    #####: 1863:        case CmpIPredicate::uge:
        -: 1864:          // (float)int >= -4.4   --> true
        -: 1865:          // (float)int >= 4.4    --> int > 4
    #####: 1866:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1867:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1868:                                                       /*width=*/1);
call    0 never executed
    #####: 1869:            return success();
call    0 never executed
        -: 1870:          }
    #####: 1871:          pred = CmpIPredicate::ugt;
    #####: 1872:          break;
    #####: 1873:        case CmpIPredicate::sge:
        -: 1874:          // (float)int >= -4.4   --> int >= -4
        -: 1875:          // (float)int >= 4.4    --> int > 4
    #####: 1876:          if (!rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1877:            pred = CmpIPredicate::sgt;
        -: 1878:          break;
        -: 1879:        }
        -: 1880:      }
        -: 1881:    }
        -: 1882:
        -: 1883:    // Lower this FP comparison into an appropriate integer version of the
        -: 1884:    // comparison.
    #####: 1885:    rewriter.replaceOpWithNewOp<CmpIOp>(
        -: 1886:        op, pred, intVal,
    #####: 1887:        rewriter.create<ConstantOp>(
    #####: 1888:            op.getLoc(), intVal.getType(),
call    0 never executed
    #####: 1889:            rewriter.getIntegerAttr(intVal.getType(), rhsInt)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1890:    return success();
branch  0 never executed
branch  1 never executed
        -: 1891:  }
        -: 1892:};
        -: 1893:
function _ZN4mlir5arith6CmpFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1894:void arith::CmpFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1895:                                                MLIRContext *context) {
     1235: 1896:  patterns.insert<CmpFIntToFPConst>(context);
call    0 returned 100%
     1235: 1897:}
        -: 1898:
        -: 1899://===----------------------------------------------------------------------===//
        -: 1900:// SelectOp
        -: 1901://===----------------------------------------------------------------------===//
        -: 1902:
        -: 1903:// Transforms a select of a boolean to arithmetic operations
        -: 1904://
        -: 1905://  arith.select %arg, %x, %y : i1
        -: 1906://
        -: 1907://  becomes
        -: 1908://
        -: 1909://  and(%arg, %x) or and(!%arg, %y)
        -: 1910:struct SelectI1Simplify : public OpRewritePattern<arith::SelectOp> {
        -: 1911:  using OpRewritePattern<arith::SelectOp>::OpRewritePattern;
        -: 1912:
function _ZNK16SelectI1Simplify15matchAndRewriteEN4mlir5arith8SelectOpERNS0_15PatternRewriterE called 75 returned 100% blocks executed 29%
       75: 1913:  LogicalResult matchAndRewrite(arith::SelectOp op,
        -: 1914:                                PatternRewriter &rewriter) const override {
       75: 1915:    if (!op.getType().isInteger(1))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       75: 1916:      return failure();
        -: 1917:
    #####: 1918:    Value falseConstant =
    #####: 1919:        rewriter.create<arith::ConstantIntOp>(op.getLoc(), true, 1);
call    0 never executed
call    1 never executed
    #####: 1920:    Value notCondition = rewriter.create<arith::XOrIOp>(
    #####: 1921:        op.getLoc(), op.getCondition(), falseConstant);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1922:
    #####: 1923:    Value trueVal = rewriter.create<arith::AndIOp>(
    #####: 1924:        op.getLoc(), op.getCondition(), op.getTrueValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1925:    Value falseVal = rewriter.create<arith::AndIOp>(op.getLoc(), notCondition,
    #####: 1926:                                                    op.getFalseValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1927:    rewriter.replaceOpWithNewOp<arith::OrIOp>(op, trueVal, falseVal);
call    0 never executed
    #####: 1928:    return success();
        -: 1929:  }
        -: 1930:};
        -: 1931:
        -: 1932://  select %arg, %c1, %c0 => extui %arg
        -: 1933:struct SelectToExtUI : public OpRewritePattern<arith::SelectOp> {
        -: 1934:  using OpRewritePattern<arith::SelectOp>::OpRewritePattern;
        -: 1935:
function _ZNK13SelectToExtUI15matchAndRewriteEN4mlir5arith8SelectOpERNS0_15PatternRewriterE called 75 returned 100% blocks executed 57%
       75: 1936:  LogicalResult matchAndRewrite(arith::SelectOp op,
        -: 1937:                                PatternRewriter &rewriter) const override {
        -: 1938:    // Cannot extui i1 to i1, or i1 to f32
       75: 1939:    if (!op.getType().isa<IntegerType>() || op.getType().isInteger(1))
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       53: 1940:      return failure();
        -: 1941:
        -: 1942:    // select %x, c1, %c0 => extui %arg
      25*: 1943:    if (matchPattern(op.getTrueValue(), m_One()) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       3*: 1944:        matchPattern(op.getFalseValue(), m_Zero())) {
call    0 returned 100%
call    1 returned 100%
    #####: 1945:      rewriter.replaceOpWithNewOp<arith::ExtUIOp>(op, op.getType(),
call    0 never executed
    #####: 1946:                                                  op.getCondition());
call    0 never executed
call    1 never executed
    #####: 1947:      return success();
        -: 1948:    }
        -: 1949:
        -: 1950:    // select %x, c0, %c1 => extui (xor %arg, true)
      22*: 1951:    if (matchPattern(op.getTrueValue(), m_Zero()) &&
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####: 1952:        matchPattern(op.getFalseValue(), m_One())) {
call    0 never executed
call    1 never executed
    #####: 1953:      rewriter.replaceOpWithNewOp<arith::ExtUIOp>(
    #####: 1954:          op, op.getType(),
call    0 never executed
    #####: 1955:          rewriter.create<arith::XOrIOp>(
    #####: 1956:              op.getLoc(), op.getCondition(),
    #####: 1957:              rewriter.create<arith::ConstantIntOp>(
    #####: 1958:                  op.getLoc(), 1, op.getCondition().getType())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1959:      return success();
        -: 1960:    }
        -: 1961:
       22: 1962:    return failure();
        -: 1963:  }
        -: 1964:};
        -: 1965:
function _ZN4mlir5arith8SelectOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 1966:void arith::SelectOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1967:                                                  MLIRContext *context) {
     1235: 1968:  results.add<SelectI1Simplify, SelectToExtUI>(context);
call    0 returned 100%
     1235: 1969:}
        -: 1970:
function _ZN4mlir5arith8SelectOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 50693 returned 100% blocks executed 84%
    50693: 1971:OpFoldResult arith::SelectOp::fold(ArrayRef<Attribute> operands) {
    50693: 1972:  Value trueVal = getTrueValue();
call    0 returned 100%
    50693: 1973:  Value falseVal = getFalseValue();
call    0 returned 100%
    50693: 1974:  if (trueVal == falseVal)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      198: 1975:    return trueVal;
call    0 returned 100%
        -: 1976:
    50495: 1977:  Value condition = getCondition();
call    0 returned 100%
        -: 1978:
        -: 1979:  // select true, %0, %1 => %0
    50495: 1980:  if (matchPattern(condition, m_One()))
call    0 returned 100%
branch  1 taken 13% (fallthrough)
branch  2 taken 87%
     6398: 1981:    return trueVal;
call    0 returned 100%
        -: 1982:
        -: 1983:  // select false, %0, %1 => %1
    44097: 1984:  if (matchPattern(condition, m_Zero()))
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
     7320: 1985:    return falseVal;
call    0 returned 100%
        -: 1986:
        -: 1987:  // select %x, true, false => %x
   36873*: 1988:  if (getType().isInteger(1) && matchPattern(getTrueValue(), m_One()) &&
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 45% (fallthrough)
branch  6 taken 55%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
      96*: 1989:      matchPattern(getFalseValue(), m_Zero()))
call    0 returned 100%
call    1 returned 100%
    #####: 1990:    return condition;
call    0 never executed
        -: 1991:
    73554: 1992:  if (auto cmp = dyn_cast_or_null<arith::CmpIOp>(condition.getDefiningOp())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 98% (fallthrough)
branch  4 taken 2%
    36105: 1993:    auto pred = cmp.getPredicate();
call    0 returned 100%
    36105: 1994:    if (pred == arith::CmpIPredicate::eq || pred == arith::CmpIPredicate::ne) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
     1604: 1995:      auto cmpLhs = cmp.getLhs();
call    0 returned 100%
     1604: 1996:      auto cmpRhs = cmp.getRhs();
call    0 returned 100%
        -: 1997:
        -: 1998:      // %0 = arith.cmpi eq, %arg0, %arg1
        -: 1999:      // %1 = arith.select %0, %arg0, %arg1 => %arg1
        -: 2000:
        -: 2001:      // %0 = arith.cmpi ne, %arg0, %arg1
        -: 2002:      // %1 = arith.select %0, %arg0, %arg1 => %arg0
        -: 2003:
    1604*: 2004:      if ((cmpLhs == trueVal && cmpRhs == falseVal) ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
     1604: 2005:          (cmpRhs == trueVal && cmpLhs == falseVal))
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2006:        return pred == arith::CmpIPredicate::ne ? trueVal : falseVal;
branch  0 never executed
branch  1 never executed
        -: 2007:    }
        -: 2008:  }
    36777: 2009:  return nullptr;
        -: 2010:}
        -: 2011:
function _ZN4mlir5arith8SelectOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2012:ParseResult SelectOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2013:  Type conditionType, resultType;
    #####: 2014:  SmallVector<OpAsmParser::UnresolvedOperand, 3> operands;
call    0 never executed
    #####: 2015:  if (parser.parseOperandList(operands, /*requiredOperandCount=*/3) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2016:      parser.parseOptionalAttrDict(result.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2017:      parser.parseColonType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2018:    return failure();
        -: 2019:
        -: 2020:  // Check for the explicit condition type if this is a masked tensor or vector.
    #####: 2021:  if (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2022:    conditionType = resultType;
    #####: 2023:    if (parser.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2024:      return failure();
        -: 2025:  } else {
    #####: 2026:    conditionType = parser.getBuilder().getI1Type();
call    0 never executed
call    1 never executed
        -: 2027:  }
        -: 2028:
    #####: 2029:  result.addTypes(resultType);
call    0 never executed
    #####: 2030:  return parser.resolveOperands(operands,
        -: 2031:                                {conditionType, resultType, resultType},
    #####: 2032:                                parser.getNameLoc(), result.operands);
call    0 never executed
call    1 never executed
        -: 2033:}
        -: 2034:
function _ZN4mlir5arith8SelectOp5printERNS_12OpAsmPrinterE called 72445 returned 100% blocks executed 76%
    72445: 2035:void arith::SelectOp::print(OpAsmPrinter &p) {
   144890: 2036:  p << " " << getOperands();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    72445: 2037:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
    72445: 2038:  p << " : ";
call    0 returned 100%
    72445: 2039:  if (ShapedType condType = getCondition().getType().dyn_cast<ShapedType>())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2040:    p << condType << ", ";
call    0 never executed
call    1 never executed
    72445: 2041:  p << getType();
call    0 returned 100%
    72445: 2042:}
        -: 2043:
function _ZN4mlir5arith8SelectOp6verifyEv called 2193335 returned 100% blocks executed 19%
  2193335: 2044:LogicalResult arith::SelectOp::verify() {
  2193335: 2045:  Type conditionType = getCondition().getType();
call    0 returned 100%
call    1 returned 100%
  2193335: 2046:  if (conditionType.isSignlessInteger(1))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2193335: 2047:    return success();
        -: 2048:
        -: 2049:  // If the result type is a vector or tensor, the type can be a mask with the
        -: 2050:  // same elements.
    #####: 2051:  Type resultType = getType();
call    0 never executed
    #####: 2052:  if (!resultType.isa<TensorType, VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2053:    return emitOpError() << "expected condition to be a signless i1, but got "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2054:                         << conditionType;
call    0 never executed
    #####: 2055:  Type shapedConditionType = getI1SameShape(resultType);
call    0 never executed
    #####: 2056:  if (conditionType != shapedConditionType) {
branch  0 never executed
branch  1 never executed
    #####: 2057:    return emitOpError() << "expected condition type to have the same shape "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2058:                            "as the result type, expected "
call    0 never executed
    #####: 2059:                         << shapedConditionType << ", but got "
call    0 never executed
call    1 never executed
    #####: 2060:                         << conditionType;
call    0 never executed
        -: 2061:  }
    #####: 2062:  return success();
        -: 2063:}
        -: 2064://===----------------------------------------------------------------------===//
        -: 2065:// ShLIOp
        -: 2066://===----------------------------------------------------------------------===//
        -: 2067:
function _ZN4mlir5arith6ShLIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 161217 returned 100% blocks executed 100%
   161217: 2068:OpFoldResult arith::ShLIOp::fold(ArrayRef<Attribute> operands) {
        -: 2069:  // Don't fold if shifting more than the bit width.
   161217: 2070:  bool bounded = false;
   161217: 2071:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6ShLIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 120326 returned 100% blocks executed 100%
   120326: 2072:      operands, [&](const APInt &a, const APInt &b) {
   120326: 2073:        bounded = b.ule(b.getBitWidth());
call    0 returned 100%
   120326: 2074:        return a.shl(b);
call    0 returned 100%
   161217: 2075:      });
call    0 returned 100%
   161217: 2076:  return bounded ? result : Attribute();
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
call    2 returned 100%
        -: 2077:}
        -: 2078:
        -: 2079://===----------------------------------------------------------------------===//
        -: 2080:// ShRUIOp
        -: 2081://===----------------------------------------------------------------------===//
        -: 2082:
function _ZN4mlir5arith7ShRUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 138652 returned 100% blocks executed 100%
   138652: 2083:OpFoldResult arith::ShRUIOp::fold(ArrayRef<Attribute> operands) {
        -: 2084:  // Don't fold if shifting more than the bit width.
   138652: 2085:  bool bounded = false;
   138652: 2086:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith7ShRUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 105198 returned 100% blocks executed 100%
   105198: 2087:      operands, [&](const APInt &a, const APInt &b) {
   105198: 2088:        bounded = b.ule(b.getBitWidth());
call    0 returned 100%
   105198: 2089:        return a.lshr(b);
call    0 returned 100%
   138652: 2090:      });
call    0 returned 100%
   138652: 2091:  return bounded ? result : Attribute();
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
call    2 returned 100%
        -: 2092:}
        -: 2093:
        -: 2094://===----------------------------------------------------------------------===//
        -: 2095:// ShRSIOp
        -: 2096://===----------------------------------------------------------------------===//
        -: 2097:
function _ZN4mlir5arith7ShRSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 197772 returned 100% blocks executed 100%
   197772: 2098:OpFoldResult arith::ShRSIOp::fold(ArrayRef<Attribute> operands) {
        -: 2099:  // Don't fold if shifting more than the bit width.
   197772: 2100:  bool bounded = false;
   197772: 2101:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith7ShRSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 150321 returned 100% blocks executed 100%
   150321: 2102:      operands, [&](const APInt &a, const APInt &b) {
   150321: 2103:        bounded = b.ule(b.getBitWidth());
call    0 returned 100%
   150321: 2104:        return a.ashr(b);
call    0 returned 100%
   197772: 2105:      });
call    0 returned 100%
   197772: 2106:  return bounded ? result : Attribute();
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
call    2 returned 100%
        -: 2107:}
        -: 2108:
        -: 2109://===----------------------------------------------------------------------===//
        -: 2110:// Atomic Enum
        -: 2111://===----------------------------------------------------------------------===//
        -: 2112:
        -: 2113:/// Returns the identity value attribute associated with an AtomicRMWKind op.
function _ZN4mlir5arith20getIdentityValueAttrENS0_13AtomicRMWKindENS_4TypeERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 2114:Attribute mlir::arith::getIdentityValueAttr(AtomicRMWKind kind, Type resultType,
        -: 2115:                                            OpBuilder &builder, Location loc) {
    #####: 2116:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 2117:  case AtomicRMWKind::maxf:
    #####: 2118:    return builder.getFloatAttr(
        -: 2119:        resultType,
    #####: 2120:        APFloat::getInf(resultType.cast<FloatType>().getFloatSemantics(),
call    0 never executed
call    1 never executed
    #####: 2121:                        /*Negative=*/true));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2122:  case AtomicRMWKind::addf:
    #####: 2123:  case AtomicRMWKind::addi:
    #####: 2124:  case AtomicRMWKind::maxu:
    #####: 2125:  case AtomicRMWKind::ori:
    #####: 2126:    return builder.getZeroAttr(resultType);
call    0 never executed
    #####: 2127:  case AtomicRMWKind::andi:
    #####: 2128:    return builder.getIntegerAttr(
        -: 2129:        resultType,
    #####: 2130:        APInt::getAllOnes(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2131:  case AtomicRMWKind::maxs:
    #####: 2132:    return builder.getIntegerAttr(
        -: 2133:        resultType,
    #####: 2134:        APInt::getSignedMinValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2135:  case AtomicRMWKind::minf:
    #####: 2136:    return builder.getFloatAttr(
        -: 2137:        resultType,
    #####: 2138:        APFloat::getInf(resultType.cast<FloatType>().getFloatSemantics(),
call    0 never executed
call    1 never executed
    #####: 2139:                        /*Negative=*/false));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2140:  case AtomicRMWKind::mins:
    #####: 2141:    return builder.getIntegerAttr(
        -: 2142:        resultType,
    #####: 2143:        APInt::getSignedMaxValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2144:  case AtomicRMWKind::minu:
    #####: 2145:    return builder.getIntegerAttr(
        -: 2146:        resultType,
    #####: 2147:        APInt::getMaxValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2148:  case AtomicRMWKind::muli:
    #####: 2149:    return builder.getIntegerAttr(resultType, 1);
call    0 never executed
    #####: 2150:  case AtomicRMWKind::mulf:
    #####: 2151:    return builder.getFloatAttr(resultType, 1);
call    0 never executed
        -: 2152:  // TODO: Add remaining reduction operations.
    #####: 2153:  default:
    #####: 2154:    (void)emitOptionalError(loc, "Reduction operation type not supported");
call    0 never executed
    #####: 2155:    break;
        -: 2156:  }
    #####: 2157:  return nullptr;
        -: 2158:}
        -: 2159:
        -: 2160:/// Returns the identity value associated with an AtomicRMWKind op.
function _ZN4mlir5arith16getIdentityValueENS0_13AtomicRMWKindENS_4TypeERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 2161:Value mlir::arith::getIdentityValue(AtomicRMWKind op, Type resultType,
        -: 2162:                                    OpBuilder &builder, Location loc) {
    #####: 2163:  Attribute attr = getIdentityValueAttr(op, resultType, builder, loc);
call    0 never executed
    #####: 2164:  return builder.create<arith::ConstantOp>(loc, attr);
call    0 never executed
        -: 2165:}
        -: 2166:
        -: 2167:/// Return the value obtained by applying the reduction operation kind
        -: 2168:/// associated with a binary AtomicRMWKind op to `lhs` and `rhs`.
function _ZN4mlir5arith14getReductionOpENS0_13AtomicRMWKindERNS_9OpBuilderENS_8LocationENS_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####: 2169:Value mlir::arith::getReductionOp(AtomicRMWKind op, OpBuilder &builder,
        -: 2170:                                  Location loc, Value lhs, Value rhs) {
    #####: 2171:  switch (op) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 2172:  case AtomicRMWKind::addf:
    #####: 2173:    return builder.create<arith::AddFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2174:  case AtomicRMWKind::addi:
    #####: 2175:    return builder.create<arith::AddIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2176:  case AtomicRMWKind::mulf:
    #####: 2177:    return builder.create<arith::MulFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2178:  case AtomicRMWKind::muli:
    #####: 2179:    return builder.create<arith::MulIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2180:  case AtomicRMWKind::maxf:
    #####: 2181:    return builder.create<arith::MaxFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2182:  case AtomicRMWKind::minf:
    #####: 2183:    return builder.create<arith::MinFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2184:  case AtomicRMWKind::maxs:
    #####: 2185:    return builder.create<arith::MaxSIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2186:  case AtomicRMWKind::mins:
    #####: 2187:    return builder.create<arith::MinSIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2188:  case AtomicRMWKind::maxu:
    #####: 2189:    return builder.create<arith::MaxUIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2190:  case AtomicRMWKind::minu:
    #####: 2191:    return builder.create<arith::MinUIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2192:  case AtomicRMWKind::ori:
    #####: 2193:    return builder.create<arith::OrIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2194:  case AtomicRMWKind::andi:
    #####: 2195:    return builder.create<arith::AndIOp>(loc, lhs, rhs);
call    0 never executed
        -: 2196:  // TODO: Add remaining reduction operations.
    #####: 2197:  default:
    #####: 2198:    (void)emitOptionalError(loc, "Reduction operation type not supported");
call    0 never executed
    #####: 2199:    break;
        -: 2200:  }
    #####: 2201:  return nullptr;
        -: 2202:}
        -: 2203:
        -: 2204://===----------------------------------------------------------------------===//
        -: 2205:// TableGen'd op method definitions
        -: 2206://===----------------------------------------------------------------------===//
        -: 2207:
        -: 2208:#define GET_OP_CLASSES
        -: 2209:#include "mlir/Dialect/Arith/IR/ArithOps.cpp.inc"
        -: 2210:
        -: 2211://===----------------------------------------------------------------------===//
        -: 2212:// TableGen'd enum attribute definitions
        -: 2213://===----------------------------------------------------------------------===//
        -: 2214:
        -: 2215:#include "mlir/Dialect/Arith/IR/ArithOpsEnums.cpp.inc"
