        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/Dialect/SCF/IR/SCF.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SCF/IR/CMakeFiles/obj.MLIRSCFDialect.dir/SCF.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SCF/IR/CMakeFiles/obj.MLIRSCFDialect.dir/SCF.cpp.gcda
        -:    0:Runs:116161
        -:    1://===- SCF.cpp - Structured Control Flow Operations -----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   10:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   11:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   12:#include "mlir/Dialect/Bufferization/IR/Bufferization.h"
        -:   13:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
        -:   14:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   15:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   16:#include "mlir/IR/BlockAndValueMapping.h"
        -:   17:#include "mlir/IR/FunctionInterfaces.h"
        -:   18:#include "mlir/IR/Matchers.h"
        -:   19:#include "mlir/IR/PatternMatch.h"
        -:   20:#include "mlir/Support/MathExtras.h"
        -:   21:#include "mlir/Transforms/InliningUtils.h"
        -:   22:
        -:   23:using namespace mlir;
        -:   24:using namespace mlir::scf;
        -:   25:
        -:   26:#include "mlir/Dialect/SCF/IR/SCFOpsDialect.cpp.inc"
        -:   27:
        -:   28://===----------------------------------------------------------------------===//
        -:   29:// SCFDialect Dialect Interfaces
        -:   30://===----------------------------------------------------------------------===//
        -:   31:
        -:   32:namespace {
        -:   33:struct SCFInlinerInterface : public DialectInlinerInterface {
        -:   34:  using DialectInlinerInterface::DialectInlinerInterface;
        -:   35:  // We don't have any special restrictions on what can be inlined into
        -:   36:  // destination regions (e.g. while/conditional bodies). Always allow it.
function _ZNK12_GLOBAL__N_119SCFInlinerInterface15isLegalToInlineEPN4mlir6RegionES3_bRNS1_20BlockAndValueMappingE called 3 returned 100% blocks executed 100%
        3:   37:  bool isLegalToInline(Region *dest, Region *src, bool wouldBeCloned,
        -:   38:                       BlockAndValueMapping &valueMapping) const final {
        3:   39:    return true;
        -:   40:  }
        -:   41:  // Operations in scf dialect are always legal to inline since they are
        -:   42:  // pure.
function _ZNK12_GLOBAL__N_119SCFInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 10 returned 100% blocks executed 100%
       10:   43:  bool isLegalToInline(Operation *, Region *, bool,
        -:   44:                       BlockAndValueMapping &) const final {
       10:   45:    return true;
        -:   46:  }
        -:   47:  // Handle the given inlined terminator by replacing it with a new operation
        -:   48:  // as necessary. Required when the region has only one block.
function _ZNK12_GLOBAL__N_119SCFInlinerInterface16handleTerminatorEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:   49:  void handleTerminator(Operation *op,
        -:   50:                        ArrayRef<Value> valuesToRepl) const final {
    #####:   51:    auto retValOp = dyn_cast<scf::YieldOp>(op);
call    0 never executed
    #####:   52:    if (!retValOp)
branch  0 never executed
branch  1 never executed
    #####:   53:      return;
        -:   54:
    #####:   55:    for (auto retValue : llvm::zip(valuesToRepl, retValOp.getOperands())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   56:      std::get<0>(retValue).replaceAllUsesWith(std::get<1>(retValue));
call    0 never executed
        -:   57:    }
        -:   58:  }
        -:   59:};
        -:   60:} // namespace
        -:   61:
        -:   62://===----------------------------------------------------------------------===//
        -:   63:// SCFDialect
        -:   64://===----------------------------------------------------------------------===//
        -:   65:
function _ZN4mlir3scf10SCFDialect10initializeEv called 0 returned 0% blocks executed 0%
   91593*:   66:void SCFDialect::initialize() {
   91593*:   67:  addOperations<
        -:   68:#define GET_OP_LIST
        -:   69:#include "mlir/Dialect/SCF/IR/SCFOps.cpp.inc"
   91593*:   70:      >();
call    0 never executed
call    1 returned 100%
   91593*:   71:  addInterfaces<SCFInlinerInterface>();
call    0 never executed
call    1 returned 100%
    #####:   72:}
        -:   73:
        -:   74:/// Default callback for IfOp builders. Inserts a yield without arguments.
function _ZN4mlir3scf19buildTerminatedBodyERNS_9OpBuilderENS_8LocationE called 1428 returned 100% blocks executed 100%
     1428:   75:void mlir::scf::buildTerminatedBody(OpBuilder &builder, Location loc) {
     1428:   76:  builder.create<scf::YieldOp>(loc);
call    0 returned 100%
     1428:   77:}
        -:   78:
        -:   79://===----------------------------------------------------------------------===//
        -:   80:// ExecuteRegionOp
        -:   81://===----------------------------------------------------------------------===//
        -:   82:
        -:   83:/// Replaces the given op with the contents of the given single-block region,
        -:   84:/// using the operands of the block terminator to replace operation results.
function _ZL19replaceOpWithRegionRN4mlir15PatternRewriterEPNS_9OperationERNS_6RegionENS_10ValueRangeE called 6497 returned 100% blocks executed 100%
     6497:   85:static void replaceOpWithRegion(PatternRewriter &rewriter, Operation *op,
        -:   86:                                Region &region, ValueRange blockArgs = {}) {
    6497*:   87:  assert(llvm::hasSingleElement(region) && "expected single-region block");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     6497:   88:  Block *block = &region.front();
call    0 returned 100%
     6497:   89:  Operation *terminator = block->getTerminator();
call    0 returned 100%
     6497:   90:  ValueRange results = terminator->getOperands();
call    0 returned 100%
call    1 returned 100%
     6497:   91:  rewriter.mergeBlockBefore(block, op, blockArgs);
call    0 returned 100%
     6497:   92:  rewriter.replaceOp(op, results);
call    0 returned 100%
     6497:   93:  rewriter.eraseOp(terminator);
call    0 returned 100%
     6497:   94:}
        -:   95:
        -:   96:///
        -:   97:/// (ssa-id `=`)? `execute_region` `->` function-result-type `{`
        -:   98:///    block+
        -:   99:/// `}`
        -:  100:///
        -:  101:/// Example:
        -:  102:///   scf.execute_region -> i32 {
        -:  103:///     %idx = load %rI[%i] : memref<128xi32>
        -:  104:///     return %idx : i32
        -:  105:///   }
        -:  106:///
function _ZN4mlir3scf15ExecuteRegionOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 618778 returned 100% blocks executed 82%
   618778:  107:ParseResult ExecuteRegionOp::parse(OpAsmParser &parser,
        -:  108:                                   OperationState &result) {
   618778:  109:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  110:    return failure();
        -:  111:
        -:  112:  // Introduce the body region and parse it.
   618778:  113:  Region *body = result.addRegion();
call    0 returned 100%
 1237556*:  114:  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  618778*:  115:      parser.parseOptionalAttrDict(result.attributes))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  116:    return failure();
        -:  117:
   618778:  118:  return success();
        -:  119:}
        -:  120:
function _ZN4mlir3scf15ExecuteRegionOp5printERNS_12OpAsmPrinterE called 1000181 returned 100% blocks executed 100%
  1000181:  121:void ExecuteRegionOp::print(OpAsmPrinter &p) {
  2000362:  122:  p.printOptionalArrowTypeList(getResultTypes());
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  123:
  1000181:  124:  p << ' ';
call    0 returned 100%
  1000181:  125:  p.printRegion(getRegion(),
call    0 returned 100%
        -:  126:                /*printEntryBlockArgs=*/false,
  1000181:  127:                /*printBlockTerminators=*/true);
call    0 returned 100%
        -:  128:
  1000181:  129:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
  1000181:  130:}
        -:  131:
function _ZN4mlir3scf15ExecuteRegionOp6verifyEv called 25034059 returned 100% blocks executed 69%
 25034059:  132:LogicalResult ExecuteRegionOp::verify() {
 25034059:  133:  if (getRegion().empty())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
     1066:  134:    return emitOpError("region needs to have at least one block");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 25032993:  135:  if (getRegion().front().getNumArguments() > 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  136:    return emitOpError("region cannot have any arguments");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 25032993:  137:  return success();
        -:  138:}
        -:  139:
        -:  140:// Inline an ExecuteRegionOp if it only contains one block.
        -:  141://     "test.foo"() : () -> ()
        -:  142://      %v = scf.execute_region -> i64 {
        -:  143://        %x = "test.val"() : () -> i64
        -:  144://        scf.yield %x : i64
        -:  145://      }
        -:  146://      "test.bar"(%v) : (i64) -> ()
        -:  147://
        -:  148://  becomes
        -:  149://
        -:  150://     "test.foo"() : () -> ()
        -:  151://     %x = "test.val"() : () -> i64
        -:  152://     "test.bar"(%x) : (i64) -> ()
        -:  153://
        -:  154:struct SingleBlockExecuteInliner : public OpRewritePattern<ExecuteRegionOp> {
        -:  155:  using OpRewritePattern<ExecuteRegionOp>::OpRewritePattern;
        -:  156:
function _ZNK25SingleBlockExecuteInliner15matchAndRewriteEN4mlir3scf15ExecuteRegionOpERNS0_15PatternRewriterE called 3980 returned 100% blocks executed 89%
     3980:  157:  LogicalResult matchAndRewrite(ExecuteRegionOp op,
        -:  158:                                PatternRewriter &rewriter) const override {
    3980*:  159:    if (!llvm::hasSingleElement(op.getRegion()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  160:      return failure();
     3980:  161:    replaceOpWithRegion(rewriter, op, op.getRegion());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3980:  162:    return success();
        -:  163:  }
        -:  164:};
        -:  165:
        -:  166:// Inline an ExecuteRegionOp if its parent can contain multiple blocks.
        -:  167:// TODO generalize the conditions for operations which can be inlined into.
        -:  168:// func @func_execute_region_elim() {
        -:  169://     "test.foo"() : () -> ()
        -:  170://     %v = scf.execute_region -> i64 {
        -:  171://       %c = "test.cmp"() : () -> i1
        -:  172://       cf.cond_br %c, ^bb2, ^bb3
        -:  173://     ^bb2:
        -:  174://       %x = "test.val1"() : () -> i64
        -:  175://       cf.br ^bb4(%x : i64)
        -:  176://     ^bb3:
        -:  177://       %y = "test.val2"() : () -> i64
        -:  178://       cf.br ^bb4(%y : i64)
        -:  179://     ^bb4(%z : i64):
        -:  180://       scf.yield %z : i64
        -:  181://     }
        -:  182://     "test.bar"(%v) : (i64) -> ()
        -:  183://   return
        -:  184:// }
        -:  185://
        -:  186://  becomes
        -:  187://
        -:  188:// func @func_execute_region_elim() {
        -:  189://    "test.foo"() : () -> ()
        -:  190://    %c = "test.cmp"() : () -> i1
        -:  191://    cf.cond_br %c, ^bb1, ^bb2
        -:  192://  ^bb1:  // pred: ^bb0
        -:  193://    %x = "test.val1"() : () -> i64
        -:  194://    cf.br ^bb3(%x : i64)
        -:  195://  ^bb2:  // pred: ^bb0
        -:  196://    %y = "test.val2"() : () -> i64
        -:  197://    cf.br ^bb3(%y : i64)
        -:  198://  ^bb3(%z: i64):  // 2 preds: ^bb1, ^bb2
        -:  199://    "test.bar"(%z) : (i64) -> ()
        -:  200://    return
        -:  201://  }
        -:  202://
        -:  203:struct MultiBlockExecuteInliner : public OpRewritePattern<ExecuteRegionOp> {
        -:  204:  using OpRewritePattern<ExecuteRegionOp>::OpRewritePattern;
        -:  205:
function _ZNK24MultiBlockExecuteInliner15matchAndRewriteEN4mlir3scf15ExecuteRegionOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  206:  LogicalResult matchAndRewrite(ExecuteRegionOp op,
        -:  207:                                PatternRewriter &rewriter) const override {
    #####:  208:    if (!isa<FunctionOpInterface, ExecuteRegionOp>(op->getParentOp()))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  209:      return failure();
        -:  210:
    #####:  211:    Block *prevBlock = op->getBlock();
call    0 never executed
    #####:  212:    Block *postBlock = rewriter.splitBlock(prevBlock, op->getIterator());
call    0 never executed
    #####:  213:    rewriter.setInsertionPointToEnd(prevBlock);
call    0 never executed
        -:  214:
    #####:  215:    rewriter.create<cf::BranchOp>(op.getLoc(), &op.getRegion().front());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  216:
    #####:  217:    for (Block &blk : op.getRegion()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  218:      if (YieldOp yieldOp = dyn_cast<YieldOp>(blk.getTerminator())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  219:        rewriter.setInsertionPoint(yieldOp);
call    0 never executed
    #####:  220:        rewriter.create<cf::BranchOp>(yieldOp.getLoc(), postBlock,
    #####:  221:                                      yieldOp.getResults());
call    0 never executed
call    1 never executed
    #####:  222:        rewriter.eraseOp(yieldOp);
call    0 never executed
        -:  223:      }
        -:  224:    }
        -:  225:
    #####:  226:    rewriter.inlineRegionBefore(op.getRegion(), postBlock);
call    0 never executed
call    1 never executed
    #####:  227:    SmallVector<Value> blockArgs;
branch  0 never executed
branch  1 never executed
        -:  228:
    #####:  229:    for (auto res : op.getResults())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  230:      blockArgs.push_back(postBlock->addArgument(res.getType(), res.getLoc()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  231:
    #####:  232:    rewriter.replaceOp(op, blockArgs);
call    0 never executed
call    1 never executed
    #####:  233:    return success();
branch  0 never executed
branch  1 never executed
        -:  234:  }
        -:  235:};
        -:  236:
function _ZN4mlir3scf15ExecuteRegionOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235:  237:void ExecuteRegionOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  238:                                                  MLIRContext *context) {
     1235:  239:  results.add<SingleBlockExecuteInliner, MultiBlockExecuteInliner>(context);
call    0 returned 100%
     1235:  240:}
        -:  241:
        -:  242:/// Given the region at `index`, or the parent operation if `index` is None,
        -:  243:/// return the successor regions. These are the regions that may be selected
        -:  244:/// during the flow of control. `operands` is a set of optional attributes that
        -:  245:/// correspond to a constant value for each operand, or null if that operand is
        -:  246:/// not a constant.
function _ZN4mlir3scf15ExecuteRegionOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 50096721 returned 100% blocks executed 100%
 50096721:  247:void ExecuteRegionOp::getSuccessorRegions(
        -:  248:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -:  249:    SmallVectorImpl<RegionSuccessor> &regions) {
        -:  250:  // If the predecessor is the ExecuteRegionOp, branch into the body.
 50096721:  251:  if (!index) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
 25048259:  252:    regions.push_back(RegionSuccessor(&getRegion()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 25048259:  253:    return;
        -:  254:  }
        -:  255:
        -:  256:  // Otherwise, the region branches back to the parent operation.
 39277831:  257:  regions.push_back(RegionSuccessor(getResults()));
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
call    2 returned 100%
call    3 returned 100%
        -:  258:}
        -:  259:
        -:  260://===----------------------------------------------------------------------===//
        -:  261:// ConditionOp
        -:  262://===----------------------------------------------------------------------===//
        -:  263:
        -:  264:MutableOperandRange
function _ZN4mlir3scf11ConditionOp27getMutableSuccessorOperandsEN4llvm8OptionalIjEE called 0 returned 0% blocks executed 0%
47020540*:  265:ConditionOp::getMutableSuccessorOperands(Optional<unsigned> index) {
        -:  266:  // Pass all operands except the condition to the successor region.
47020540*:  267:  return getArgsMutable();
call    0 returned 100%
call    1 never executed
        -:  268:}
        -:  269:
        -:  270://===----------------------------------------------------------------------===//
        -:  271:// ForOp
        -:  272://===----------------------------------------------------------------------===//
        -:  273:
function _ZN4mlir3scf5ForOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_NS_10ValueRangeEN4llvm12function_refIFvS3_NS_8LocationES6_S7_EEE called 4743 returned 100% blocks executed 97%
     4743:  274:void ForOp::build(OpBuilder &builder, OperationState &result, Value lb,
        -:  275:                  Value ub, Value step, ValueRange iterArgs,
        -:  276:                  BodyBuilderFn bodyBuilder) {
     4743:  277:  result.addOperands({lb, ub, step});
call    0 returned 100%
call    1 returned 100%
     4743:  278:  result.addOperands(iterArgs);
call    0 returned 100%
     7955:  279:  for (Value v : iterArgs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     1606:  280:    result.addTypes(v.getType());
call    0 returned 100%
     4743:  281:  Region *bodyRegion = result.addRegion();
call    0 returned 100%
     4743:  282:  bodyRegion->push_back(new Block);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     4743:  283:  Block &bodyBlock = bodyRegion->front();
call    0 returned 100%
     4743:  284:  bodyBlock.addArgument(builder.getIndexType(), result.location);
call    0 returned 100%
call    1 returned 100%
     7955:  285:  for (Value v : iterArgs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     1606:  286:    bodyBlock.addArgument(v.getType(), v.getLoc());
call    0 returned 100%
call    1 returned 100%
        -:  287:
        -:  288:  // Create the default terminator if the builder is not provided and if the
        -:  289:  // iteration arguments are not provided. Otherwise, leave this to the caller
        -:  290:  // because we don't know which values to return from the loop.
     4743:  291:  if (iterArgs.empty() && !bodyBuilder) {
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
branch  2 taken 43% (fallthrough)
branch  3 taken 57%
     1776:  292:    ForOp::ensureTerminator(*bodyRegion, builder, result.location);
call    0 returned 100%
     2967:  293:  } else if (bodyBuilder) {
branch  0 taken 46%
branch  1 taken 54%
     2722:  294:    OpBuilder::InsertionGuard guard(builder);
call    0 returned 100%
     1361:  295:    builder.setInsertionPointToStart(&bodyBlock);
call    0 returned 100%
     2722:  296:    bodyBuilder(builder, result.location, bodyBlock.getArgument(0),
call    0 returned 100%
call    1 returned 100%
     2722:  297:                bodyBlock.getArguments().drop_front());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  298:  }
     4743:  299:}
        -:  300:
function _ZN4mlir3scf5ForOp6verifyEv called 90740 returned 100% blocks executed 52%
    90740:  301:LogicalResult ForOp::verify() {
    90740:  302:  IntegerAttr step;
   90740*:  303:  if (matchPattern(getStep(), m_Constant(&step)) && step.getInt() <= 0)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
    #####:  304:    return emitOpError("constant step operand must be positive");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  305:
    90740:  306:  auto opNumResults = getNumResults();
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    90740:  307:  if (opNumResults == 0)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    52589:  308:    return success();
        -:  309:  // If ForOp defines values, check that the number and types of
        -:  310:  // the defined values match ForOp initial iter operands and backedge
        -:  311:  // basic block arguments.
    38151:  312:  if (getNumIterOperands() != opNumResults)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  313:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  314:        "mismatch in number of loop-carried values and defined values");
call    0 never executed
    38151:  315:  return success();
        -:  316:}
        -:  317:
function _ZN4mlir3scf5ForOp13verifyRegionsEv called 90751 returned 100% blocks executed 40%
    90751:  318:LogicalResult ForOp::verifyRegions() {
        -:  319:  // Check that the body defines as single block argument for the induction
        -:  320:  // variable.
    90751:  321:  auto *body = getBody();
call    0 returned 100%
    90749:  322:  if (!body->getArgument(0).getType().isIndex())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  323:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  324:        "expected body first argument to be an index argument for "
    #####:  325:        "the induction variable");
call    0 never executed
        -:  326:
    90748:  327:  auto opNumResults = getNumResults();
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    90748:  328:  if (opNumResults == 0)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    52597:  329:    return success();
        -:  330:
    38151:  331:  if (getNumRegionIterArgs() != opNumResults)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  332:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  333:        "mismatch in number of basic block args and defined values");
call    0 never executed
        -:  334:
    38151:  335:  auto iterOperands = getIterOperands();
call    0 returned 100%
    38151:  336:  auto iterArgs = getRegionIterArgs();
call    0 returned 100%
    38151:  337:  auto opResults = getResults();
call    0 returned 100%
    38151:  338:  unsigned i = 0;
    76302:  339:  for (auto e : llvm::zip(iterOperands, iterArgs, opResults)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    38151:  340:    if (std::get<0>(e).getType() != std::get<2>(e).getType())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  341:      return emitOpError() << "types mismatch between " << i
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  342:                           << "th iter operand and defined value";
call    0 never executed
    38151:  343:    if (std::get<1>(e).getType() != std::get<2>(e).getType())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  344:      return emitOpError() << "types mismatch between " << i
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  345:                           << "th iter region arg and defined value";
call    0 never executed
        -:  346:
    38151:  347:    i++;
        -:  348:  }
    38151:  349:  return success();
        -:  350:}
        -:  351:
function _ZN4mlir3scf5ForOp21getSingleInductionVarEv called 0 returned 0% blocks executed 0%
    #####:  352:Optional<Value> ForOp::getSingleInductionVar() { return getInductionVar(); }
call    0 never executed
call    1 never executed
        -:  353:
function _ZN4mlir3scf5ForOp19getSingleLowerBoundEv called 0 returned 0% blocks executed 0%
    #####:  354:Optional<OpFoldResult> ForOp::getSingleLowerBound() {
    #####:  355:  return OpFoldResult(getLowerBound());
call    0 never executed
call    1 never executed
        -:  356:}
        -:  357:
function _ZN4mlir3scf5ForOp13getSingleStepEv called 0 returned 0% blocks executed 0%
    #####:  358:Optional<OpFoldResult> ForOp::getSingleStep() {
    #####:  359:  return OpFoldResult(getStep());
call    0 never executed
call    1 never executed
        -:  360:}
        -:  361:
function _ZN4mlir3scf5ForOp19getSingleUpperBoundEv called 0 returned 0% blocks executed 0%
    #####:  362:Optional<OpFoldResult> ForOp::getSingleUpperBound() {
    #####:  363:  return OpFoldResult(getUpperBound());
call    0 never executed
call    1 never executed
        -:  364:}
        -:  365:
        -:  366:/// Prints the initialization list in the form of
        -:  367:///   <prefix>(%inner = %outer, %inner2 = %outer2, <...>)
        -:  368:/// where 'inner' values are assumed to be region arguments and 'outer' values
        -:  369:/// are regular SSA values.
function _ZL23printInitializationListRN4mlir12OpAsmPrinterEN4llvm15MutableArrayRefINS_13BlockArgumentEEENS_10ValueRangeENS2_9StringRefE called 935651 returned 100% blocks executed 91%
   935651:  370:static void printInitializationList(OpAsmPrinter &p,
        -:  371:                                    Block::BlockArgListType blocksArgs,
        -:  372:                                    ValueRange initializers,
        -:  373:                                    StringRef prefix = "") {
  935651*:  374:  assert(blocksArgs.size() == initializers.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  375:         "expected same length of arguments and initializers");
   935651:  376:  if (initializers.empty())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  377:    return;
        -:  378:
  1857090:  379:  p << prefix << '(';
call    0 returned 100%
call    1 returned 100%
function _ZZL23printInitializationListRN4mlir12OpAsmPrinterEN4llvm15MutableArrayRefINS_13BlockArgumentEEENS_10ValueRangeENS2_9StringRefEENKUlT_E_clISt5tupleIJRS4_NS_5ValueEEEEEDaS8_.isra.0 called 929408 returned 100% blocks executed 100%
  1857953:  380:  llvm::interleaveComma(llvm::zip(blocksArgs, initializers), p, [&](auto it) {
call    0 returned 100%
  1858816:  381:    p << std::get<0>(it) << " = " << std::get<1>(it);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   929408:  382:  });
   928545:  383:  p << ")";
call    0 returned 100%
        -:  384:}
        -:  385:
function _ZN4mlir3scf5ForOp5printERNS_12OpAsmPrinterE called 6030 returned 100% blocks executed 100%
     6030:  386:void ForOp::print(OpAsmPrinter &p) {
    18090:  387:  p << " " << getInductionVar() << " = " << getLowerBound() << " to "
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
    12060:  388:    << getUpperBound() << " step " << getStep();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  389:
     6030:  390:  printInitializationList(p, getRegionIterArgs(), getIterOperands(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  391:                          " iter_args");
     6030:  392:  if (!getIterOperands().empty())
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
     3420:  393:    p << " -> (" << getIterOperands().getTypes() << ')';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
     6030:  394:  p << ' ';
call    0 returned 100%
     6030:  395:  p.printRegion(getRegion(),
call    0 returned 100%
call    1 returned 100%
        -:  396:                /*printEntryBlockArgs=*/false,
     6030:  397:                /*printBlockTerminators=*/hasIterOperands());
call    0 returned 100%
     6030:  398:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
     6030:  399:}
        -:  400:
function _ZN4mlir3scf5ForOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  401:ParseResult ForOp::parse(OpAsmParser &parser, OperationState &result) {
    #####:  402:  auto &builder = parser.getBuilder();
call    0 never executed
    #####:  403:  Type indexType = builder.getIndexType();
call    0 never executed
        -:  404:
    #####:  405:  OpAsmParser::Argument inductionVariable;
call    0 never executed
    #####:  406:  inductionVariable.type = indexType;
    #####:  407:  OpAsmParser::UnresolvedOperand lb, ub, step;
        -:  408:
        -:  409:  // Parse the induction variable followed by '='.
    #####:  410:  if (parser.parseArgument(inductionVariable) || parser.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  411:      // Parse loop bounds.
    #####:  412:      parser.parseOperand(lb) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  413:      parser.resolveOperand(lb, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  414:      parser.parseKeyword("to") || parser.parseOperand(ub) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  415:      parser.resolveOperand(ub, indexType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  416:      parser.parseKeyword("step") || parser.parseOperand(step) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  417:      parser.resolveOperand(step, indexType, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:    return failure();
        -:  419:
        -:  420:  // Parse the optional initial iteration arguments.
    #####:  421:  SmallVector<OpAsmParser::Argument, 4> regionArgs;
call    0 never executed
    #####:  422:  SmallVector<OpAsmParser::UnresolvedOperand, 4> operands;
branch  0 never executed
branch  1 never executed
    #####:  423:  regionArgs.push_back(inductionVariable);
call    0 never executed
        -:  424:
    #####:  425:  if (succeeded(parser.parseOptionalKeyword("iter_args"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  426:    // Parse assignment list and results type list.
    #####:  427:    if (parser.parseAssignmentList(regionArgs, operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  428:        parser.parseArrowTypeList(result.types))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  429:      return failure();
        -:  430:
        -:  431:    // Resolve input operands.
    #####:  432:    for (auto argOperandType :
    #####:  433:         llvm::zip(llvm::drop_begin(regionArgs), operands, result.types)) {
branch  0 never executed
branch  1 never executed
    #####:  434:      Type type = std::get<2>(argOperandType);
call    0 never executed
    #####:  435:      std::get<0>(argOperandType).type = type;
call    0 never executed
    #####:  436:      if (parser.resolveOperand(std::get<1>(argOperandType), type,
branch  0 never executed
branch  1 never executed
    #####:  437:                                result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  438:        return failure();
        -:  439:    }
        -:  440:  }
        -:  441:
    #####:  442:  if (regionArgs.size() != result.types.size() + 1)
branch  0 never executed
branch  1 never executed
    #####:  443:    return parser.emitError(
call    0 never executed
call    1 never executed
    #####:  444:        parser.getNameLoc(),
call    0 never executed
    #####:  445:        "mismatch in number of loop-carried values and defined values");
call    0 never executed
call    1 never executed
        -:  446:
        -:  447:  // Parse the body region.
    #####:  448:  Region *body = result.addRegion();
call    0 never executed
    #####:  449:  if (parser.parseRegion(*body, regionArgs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  450:    return failure();
        -:  451:
    #####:  452:  ForOp::ensureTerminator(*body, builder, result.location);
call    0 never executed
        -:  453:
        -:  454:  // Parse the optional attribute list.
    #####:  455:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  456:    return failure();
        -:  457:
    #####:  458:  return success();
        -:  459:}
        -:  460:
function _ZN4mlir3scf5ForOp11getLoopBodyEv called 0 returned 0% blocks executed 0%
      15*:  461:Region &ForOp::getLoopBody() { return getRegion(); }
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
        -:  462:
function _ZN4mlir3scf23getForInductionVarOwnerENS_5ValueE called 1826 returned 100% blocks executed 33%
     1826:  463:ForOp mlir::scf::getForInductionVarOwner(Value val) {
     1826:  464:  auto ivArg = val.dyn_cast<BlockArgument>();
call    0 returned 100%
     1826:  465:  if (!ivArg)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1826:  466:    return ForOp();
    #####:  467:  assert(ivArg.getOwner() && "unlinked block argument");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  468:  auto *containingOp = ivArg.getOwner()->getParentOp();
call    0 never executed
    #####:  469:  return dyn_cast_or_null<ForOp>(containingOp);
branch  0 never executed
branch  1 never executed
        -:  470:}
        -:  471:
        -:  472:/// Return operands used when entering the region at 'index'. These operands
        -:  473:/// correspond to the loop iterator operands, i.e., those excluding the
        -:  474:/// induction variable. LoopOp only has one region, so 0 is the only valid value
        -:  475:/// for `index`.
function _ZN4mlir3scf5ForOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 90805 returned 100% blocks executed 80%
    90805:  476:OperandRange ForOp::getSuccessorEntryOperands(Optional<unsigned> index) {
   90805*:  477:  assert(index && *index == 0 && "invalid region index");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  478:
        -:  479:  // The initial operands map to the loop arguments after the induction
        -:  480:  // variable.
    90805:  481:  return getInitArgs();
call    0 returned 100%
        -:  482:}
        -:  483:
        -:  484:/// Given the region at `index`, or the parent operation if `index` is None,
        -:  485:/// return the successor regions. These are the regions that may be selected
        -:  486:/// during the flow of control. `operands` is a set of optional attributes that
        -:  487:/// correspond to a constant value for each operand, or null if that operand is
        -:  488:/// not a constant.
function _ZN4mlir3scf5ForOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 181596 returned 100% blocks executed 94%
   181596:  489:void ForOp::getSuccessorRegions(Optional<unsigned> index,
        -:  490:                                ArrayRef<Attribute> operands,
        -:  491:                                SmallVectorImpl<RegionSuccessor> &regions) {
        -:  492:  // If the predecessor is the ForOp, branch into the body using the iterator
        -:  493:  // arguments.
   181596:  494:  if (!index) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    90798:  495:    regions.push_back(RegionSuccessor(&getLoopBody(), getRegionIterArgs()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    90803:  496:    return;
        -:  497:  }
        -:  498:
        -:  499:  // Otherwise, the loop may branch back to itself or the parent operation.
   90798*:  500:  assert(*index == 0 && "expected loop region");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    90798:  501:  regions.push_back(RegionSuccessor(&getLoopBody(), getRegionIterArgs()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    90801:  502:  regions.push_back(RegionSuccessor(getResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  503:}
        -:  504:
function _ZN4mlir3scf13buildLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_S4_N4llvm12function_refIFSt6vectorINS_5ValueESaIS8_EES2_S3_S4_S4_EEE called 9 returned 100% blocks executed 62%
        9:  505:LoopNest mlir::scf::buildLoopNest(
        -:  506:    OpBuilder &builder, Location loc, ValueRange lbs, ValueRange ubs,
        -:  507:    ValueRange steps, ValueRange iterArgs,
        -:  508:    function_ref<ValueVector(OpBuilder &, Location, ValueRange, ValueRange)>
        -:  509:        bodyBuilder) {
       9*:  510:  assert(lbs.size() == ubs.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  511:         "expected the same number of lower and upper bounds");
       9*:  512:  assert(lbs.size() == steps.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  513:         "expected the same number of lower bounds and steps");
        -:  514:
        -:  515:  // If there are no bounds, call the body-building function and return early.
        9:  516:  if (lbs.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  517:    ValueVector results =
        -:  518:        bodyBuilder ? bodyBuilder(builder, loc, ValueRange(), iterArgs)
    #####:  519:                    : ValueVector();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  520:    assert(results.size() == iterArgs.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  521:           "loop nest body must return as many values as loop has iteration "
        -:  522:           "arguments");
    #####:  523:    return LoopNest();
branch  0 never executed
branch  1 never executed
        -:  524:  }
        -:  525:
        -:  526:  // First, create the loop structure iteratively using the body-builder
        -:  527:  // callback of `ForOp::build`. Do not create `YieldOp`s yet.
        9:  528:  OpBuilder::InsertionGuard guard(builder);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       18:  529:  SmallVector<scf::ForOp, 4> loops;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        9:  530:  SmallVector<Value, 4> ivs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        9:  531:  loops.reserve(lbs.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        9:  532:  ivs.reserve(lbs.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        9:  533:  ValueRange currentIterArgs = iterArgs;
        9:  534:  Location currentLoc = loc;
       30:  535:  for (unsigned i = 0, e = lbs.size(); i < e; ++i) {
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
       21:  536:    auto loop = builder.create<scf::ForOp>(
       21:  537:        currentLoc, lbs[i], ubs[i], steps[i], currentIterArgs,
call    0 returned 100%
call    1 returned 100%
       21:  538:        [&](OpBuilder &nestedBuilder, Location nestedLoc, Value iv,
        -:  539:            ValueRange args) {
       21:  540:          ivs.push_back(iv);
call    0 returned 100%
        -:  541:          // It is safe to store ValueRange args because it points to block
        -:  542:          // arguments of a loop operation that we also own.
       21:  543:          currentIterArgs = args;
       21:  544:          currentLoc = nestedLoc;
       42:  545:        });
call    0 returned 100%
call    1 returned 100%
        -:  546:    // Set the builder to point to the body of the newly created loop. We don't
        -:  547:    // do this in the callback because the builder is reset when the callback
        -:  548:    // returns.
       21:  549:    builder.setInsertionPointToStart(loop.getBody());
call    0 returned 100%
call    1 returned 100%
       21:  550:    loops.push_back(loop);
call    0 returned 100%
        -:  551:  }
        -:  552:
        -:  553:  // For all loops but the innermost, yield the results of the nested loop.
       21:  554:  for (unsigned i = 0, e = loops.size() - 1; i < e; ++i) {
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
       12:  555:    builder.setInsertionPointToEnd(loops[i].getBody());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
       12:  556:    builder.create<scf::YieldOp>(loc, loops[i + 1].getResults());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -:  557:  }
        -:  558:
        -:  559:  // In the body of the innermost loop, call the body building function if any
        -:  560:  // and yield its results.
        9:  561:  builder.setInsertionPointToStart(loops.back().getBody());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        9:  562:  ValueVector results = bodyBuilder
        -:  563:                            ? bodyBuilder(builder, currentLoc, ivs,
        9:  564:                                          loops.back().getRegionIterArgs())
call    0 returned 100%
call    1 returned 100%
      27*:  565:                            : ValueVector();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
       9*:  566:  assert(results.size() == iterArgs.size() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  567:         "loop nest body must return as many values as loop has iteration "
        -:  568:         "arguments");
        9:  569:  builder.setInsertionPointToEnd(loops.back().getBody());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        9:  570:  builder.create<scf::YieldOp>(loc, results);
call    0 returned 100%
        -:  571:
        -:  572:  // Return the loops.
        9:  573:  LoopNest res;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        9:  574:  res.loops.assign(loops.begin(), loops.end());
call    0 returned 100%
        9:  575:  return res;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  576:}
        -:  577:
function _ZN4mlir3scf13buildLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm12function_refIFvS2_S3_S4_EEE called 0 returned 0% blocks executed 0%
    #####:  578:LoopNest mlir::scf::buildLoopNest(
        -:  579:    OpBuilder &builder, Location loc, ValueRange lbs, ValueRange ubs,
        -:  580:    ValueRange steps,
        -:  581:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilder) {
        -:  582:  // Delegate to the main function by wrapping the body builder.
    #####:  583:  return buildLoopNest(builder, loc, lbs, ubs, steps, llvm::None,
    #####:  584:                       [&bodyBuilder](OpBuilder &nestedBuilder,
        -:  585:                                      Location nestedLoc, ValueRange ivs,
        -:  586:                                      ValueRange) -> ValueVector {
    #####:  587:                         if (bodyBuilder)
branch  0 never executed
branch  1 never executed
    #####:  588:                           bodyBuilder(nestedBuilder, nestedLoc, ivs);
call    0 never executed
    #####:  589:                         return {};
    #####:  590:                       });
call    0 never executed
call    1 never executed
        -:  591:}
        -:  592:
        -:  593:namespace {
        -:  594:// Fold away ForOp iter arguments when:
        -:  595:// 1) The op yields the iter arguments.
        -:  596:// 2) The iter arguments have no use and the corresponding outer region
        -:  597:// iterators (inputs) are yielded.
        -:  598:// 3) The iter arguments have no use and the corresponding (operation) results
        -:  599:// have no use.
        -:  600://
        -:  601:// These arguments must be defined outside of
        -:  602:// the ForOp region and can just be forwarded after simplifying the op inits,
        -:  603:// yields and returns.
        -:  604://
        -:  605:// The implementation uses `mergeBlockBefore` to steal the content of the
        -:  606:// original ForOp and avoid cloning.
        -:  607:struct ForOpIterArgsFolder : public OpRewritePattern<scf::ForOp> {
        -:  608:  using OpRewritePattern<scf::ForOp>::OpRewritePattern;
        -:  609:
function _ZNK12_GLOBAL__N_119ForOpIterArgsFolder15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterE called 25 returned 100% blocks executed 24%
       25:  610:  LogicalResult matchAndRewrite(scf::ForOp forOp,
        -:  611:                                PatternRewriter &rewriter) const final {
       25:  612:    bool canonicalize = false;
       25:  613:    Block &block = forOp.getRegion().front();
call    0 returned 100%
call    1 returned 100%
       25:  614:    auto yieldOp = cast<scf::YieldOp>(block.getTerminator());
call    0 returned 100%
call    1 returned 100%
        -:  615:
        -:  616:    // An internal flat vector of block transfer
        -:  617:    // arguments `newBlockTransferArgs` keeps the 1-1 mapping of original to
        -:  618:    // transformed block argument mappings. This plays the role of a
        -:  619:    // BlockAndValueMapping for the particular use case of calling into
        -:  620:    // `mergeBlockBefore`.
       25:  621:    SmallVector<bool, 4> keepMask;
call    0 returned 100%
       25:  622:    keepMask.reserve(yieldOp.getNumOperands());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       50:  623:    SmallVector<Value, 4> newBlockTransferArgs, newIterArgs, newYieldValues,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
       25:  624:        newResultValues;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       25:  625:    newBlockTransferArgs.reserve(1 + forOp.getNumIterOperands());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       25:  626:    newBlockTransferArgs.push_back(Value()); // iv placeholder with null value
call    0 returned 100%
       25:  627:    newIterArgs.reserve(forOp.getNumIterOperands());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       25:  628:    newYieldValues.reserve(yieldOp.getNumOperands());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       25:  629:    newResultValues.reserve(forOp.getNumResults());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      50*:  630:    for (auto it : llvm::zip(forOp.getIterOperands(),   // iter from outside
call    0 returned 100%
call    1 returned 100%
       50:  631:                             forOp.getRegionIterArgs(), // iter inside region
       25:  632:                             forOp.getResults(),        // op results
call    0 returned 100%
       50:  633:                             yieldOp.getOperands()      // iter yield
call    0 returned 100%
      25*:  634:                             )) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  635:      // Forwarded is `true` when:
        -:  636:      // 1) The region `iter` argument is yielded.
        -:  637:      // 2) The region `iter` argument has no use, and the corresponding iter
        -:  638:      // operand (input) is yielded.
        -:  639:      // 3) The region `iter` argument has no use, and the corresponding op
        -:  640:      // result has no use.
    #####:  641:      bool forwarded = ((std::get<1>(it) == std::get<3>(it)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  642:                        (std::get<1>(it).use_empty() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  643:                         (std::get<0>(it) == std::get<3>(it) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  644:                          std::get<2>(it).use_empty())));
branch  0 never executed
branch  1 never executed
    #####:  645:      keepMask.push_back(!forwarded);
call    0 never executed
    #####:  646:      canonicalize |= forwarded;
    #####:  647:      if (forwarded) {
branch  0 never executed
branch  1 never executed
    #####:  648:        newBlockTransferArgs.push_back(std::get<0>(it));
call    0 never executed
    #####:  649:        newResultValues.push_back(std::get<0>(it));
call    0 never executed
    #####:  650:        continue;
        -:  651:      }
    #####:  652:      newIterArgs.push_back(std::get<0>(it));
call    0 never executed
    #####:  653:      newYieldValues.push_back(std::get<3>(it));
call    0 never executed
    #####:  654:      newBlockTransferArgs.push_back(Value()); // placeholder with null value
call    0 never executed
    #####:  655:      newResultValues.push_back(Value());      // placeholder with null value
call    0 never executed
        -:  656:    }
        -:  657:
       25:  658:    if (!canonicalize)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25:  659:      return failure();
        -:  660:
    #####:  661:    scf::ForOp newForOp = rewriter.create<scf::ForOp>(
    #####:  662:        forOp.getLoc(), forOp.getLowerBound(), forOp.getUpperBound(),
call    0 never executed
call    1 never executed
    #####:  663:        forOp.getStep(), newIterArgs);
call    0 never executed
call    1 never executed
    #####:  664:    newForOp->setAttrs(forOp->getAttrs());
call    0 never executed
call    1 never executed
    #####:  665:    Block &newBlock = newForOp.getRegion().front();
call    0 never executed
call    1 never executed
        -:  666:
        -:  667:    // Replace the null placeholders with newly constructed values.
    #####:  668:    newBlockTransferArgs[0] = newBlock.getArgument(0); // iv
branch  0 never executed
branch  1 never executed
    #####:  669:    for (unsigned idx = 0, collapsedIdx = 0, e = newResultValues.size();
    #####:  670:         idx != e; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  671:      Value &blockTransferArg = newBlockTransferArgs[1 + idx];
branch  0 never executed
branch  1 never executed
    #####:  672:      Value &newResultVal = newResultValues[idx];
branch  0 never executed
branch  1 never executed
    #####:  673:      assert((blockTransferArg && newResultVal) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -:  674:             (!blockTransferArg && !newResultVal));
    #####:  675:      if (!blockTransferArg) {
branch  0 never executed
branch  1 never executed
    #####:  676:        blockTransferArg = newForOp.getRegionIterArgs()[collapsedIdx];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  677:        newResultVal = newForOp.getResult(collapsedIdx++);
branch  0 never executed
branch  1 never executed
        -:  678:      }
        -:  679:    }
        -:  680:
    #####:  681:    Block &oldBlock = forOp.getRegion().front();
call    0 never executed
call    1 never executed
    #####:  682:    assert(oldBlock.getNumArguments() == newBlockTransferArgs.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  683:           "unexpected argument size mismatch");
        -:  684:
        -:  685:    // No results case: the scf::ForOp builder already created a zero
        -:  686:    // result terminator. Merge before this terminator and just get rid of the
        -:  687:    // original terminator that has been merged in.
    #####:  688:    if (newIterArgs.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  689:      auto newYieldOp = cast<scf::YieldOp>(newBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####:  690:      rewriter.mergeBlockBefore(&oldBlock, newYieldOp, newBlockTransferArgs);
call    0 never executed
call    1 never executed
    #####:  691:      rewriter.eraseOp(newBlock.getTerminator()->getPrevNode());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  692:      rewriter.replaceOp(forOp, newResultValues);
call    0 never executed
call    1 never executed
    #####:  693:      return success();
        -:  694:    }
        -:  695:
        -:  696:    // No terminator case: merge and rewrite the merged terminator.
function _ZZNK12_GLOBAL__N_119ForOpIterArgsFolder15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterEENKUlNS2_7YieldOpEE_clES6_ called 0 returned 0% blocks executed 0%
    #####:  697:    auto cloneFilteredTerminator = [&](scf::YieldOp mergedTerminator) {
    #####:  698:      OpBuilder::InsertionGuard g(rewriter);
call    0 never executed
    #####:  699:      rewriter.setInsertionPoint(mergedTerminator);
call    0 never executed
    #####:  700:      SmallVector<Value, 4> filteredOperands;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  701:      filteredOperands.reserve(newResultValues.size());
branch  0 never executed
branch  1 never executed
    #####:  702:      for (unsigned idx = 0, e = keepMask.size(); idx < e; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  703:        if (keepMask[idx])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  704:          filteredOperands.push_back(mergedTerminator.getOperand(idx));
call    0 never executed
call    1 never executed
    #####:  705:      rewriter.create<scf::YieldOp>(mergedTerminator.getLoc(),
    #####:  706:                                    filteredOperands);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  707:    };
        -:  708:
    #####:  709:    rewriter.mergeBlocks(&oldBlock, &newBlock, newBlockTransferArgs);
call    0 never executed
call    1 never executed
    #####:  710:    auto mergedYieldOp = cast<scf::YieldOp>(newBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####:  711:    cloneFilteredTerminator(mergedYieldOp);
call    0 never executed
    #####:  712:    rewriter.eraseOp(mergedYieldOp);
call    0 never executed
    #####:  713:    rewriter.replaceOp(forOp, newResultValues);
call    0 never executed
call    1 never executed
      25*:  714:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  715:  }
        -:  716:};
        -:  717:
        -:  718:/// Util function that tries to compute a constant diff between u and l.
        -:  719:/// Returns llvm::None when the difference between two AffineValueMap is
        -:  720:/// dynamic.
function _ZN12_GLOBAL__N_1L16computeConstDiffEN4mlir5ValueES1_ called 25 returned 100% blocks executed 64%
       25:  721:static Optional<int64_t> computeConstDiff(Value l, Value u) {
       25:  722:  IntegerAttr clb, cub;
       25:  723:  if (matchPattern(l, m_Constant(&clb)) && matchPattern(u, m_Constant(&cub))) {
call    0 returned 100%
branch  1 taken 16% (fallthrough)
branch  2 taken 84%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        8:  724:    llvm::APInt lbValue = clb.getValue();
call    0 returned 100%
        8:  725:    llvm::APInt ubValue = cub.getValue();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        8:  726:    return (ubValue - lbValue).getSExtValue();
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
        -:  727:  }
        -:  728:
        -:  729:  // Else a simple pattern match for x + c or c + x
       21:  730:  llvm::APInt diff;
call    0 returned 100%
       21:  731:  if (matchPattern(
call    0 returned 100%
      42*:  732:          u, m_Op<arith::AddIOp>(matchers::m_Val(l), m_ConstantInt(&diff))) ||
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
       21:  733:      matchPattern(
call    0 returned 100%
      21*:  734:          u, m_Op<arith::AddIOp>(m_ConstantInt(&diff), matchers::m_Val(l))))
call    0 returned 100%
    #####:  735:    return diff.getSExtValue();
call    0 never executed
       21:  736:  return llvm::None;
        -:  737:}
        -:  738:
        -:  739:/// Rewriting pattern that erases loops that are known not to iterate, replaces
        -:  740:/// single-iteration loops with their bodies, and removes empty loops that
        -:  741:/// iterate at least once and only return values defined outside of the loop.
        -:  742:struct SimplifyTrivialLoops : public OpRewritePattern<ForOp> {
        -:  743:  using OpRewritePattern<ForOp>::OpRewritePattern;
        -:  744:
function _ZNK12_GLOBAL__N_120SimplifyTrivialLoops15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterE called 25 returned 100% blocks executed 60%
       25:  745:  LogicalResult matchAndRewrite(ForOp op,
        -:  746:                                PatternRewriter &rewriter) const override {
        -:  747:    // If the upper bound is the same as the lower bound, the loop does not
        -:  748:    // iterate, just remove it.
       25:  749:    if (op.getLowerBound() == op.getUpperBound()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  750:      rewriter.replaceOp(op, op.getIterOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  751:      return success();
        -:  752:    }
        -:  753:
       25:  754:    Optional<int64_t> diff =
       25:  755:        computeConstDiff(op.getLowerBound(), op.getUpperBound());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       25:  756:    if (!diff)
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
       21:  757:      return failure();
        -:  758:
        -:  759:    // If the loop is known to have 0 iterations, remove it.
        4:  760:    if (*diff <= 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  761:      rewriter.replaceOp(op, op.getIterOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  762:      return success();
        -:  763:    }
        -:  764:
        4:  765:    llvm::Optional<llvm::APInt> maybeStepValue = op.getConstantStep();
call    0 returned 100%
        4:  766:    if (!maybeStepValue)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  767:      return failure();
        -:  768:
        -:  769:    // If the loop is known to have 1 iteration, inline its body and remove the
        -:  770:    // loop.
        8:  771:    llvm::APInt stepValue = *maybeStepValue;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        4:  772:    if (stepValue.sge(*diff)) {
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        2:  773:      SmallVector<Value, 4> blockArgs;
call    0 returned 100%
        1:  774:      blockArgs.reserve(op.getNumIterOperands() + 1);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:  775:      blockArgs.push_back(op.getLowerBound());
call    0 returned 100%
call    1 returned 100%
        1:  776:      llvm::append_range(blockArgs, op.getIterOperands());
call    0 returned 100%
call    1 returned 100%
        1:  777:      replaceOpWithRegion(rewriter, op, op.getLoopBody(), blockArgs);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        1:  778:      return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  779:    }
        -:  780:
        -:  781:    // Now we are left with loops that have more than 1 iterations.
        3:  782:    Block &block = op.getRegion().front();
call    0 returned 100%
call    1 returned 100%
       3*:  783:    if (!llvm::hasSingleElement(block))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  784:      return failure();
        -:  785:    // If the loop is empty, iterates at least once, and only returns values
        -:  786:    // defined outside of the loop, remove it and replace it with yield values.
    #####:  787:    auto yieldOp = cast<scf::YieldOp>(block.getTerminator());
call    0 never executed
call    1 never executed
    #####:  788:    auto yieldOperands = yieldOp.getOperands();
call    0 never executed
    #####:  789:    if (llvm::any_of(yieldOperands,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  790:                     [&](Value v) { return !op.isDefinedOutsideOfLoop(v); }))
    #####:  791:      return failure();
    #####:  792:    rewriter.replaceOp(op, yieldOperands);
call    0 never executed
call    1 never executed
       4*:  793:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  794:  }
        -:  795:};
        -:  796:
        -:  797:/// Perform a replacement of one iter OpOperand of an scf.for to the
        -:  798:/// `replacement` value which is expected to be the source of a tensor.cast.
        -:  799:/// tensor.cast ops are inserted inside the block to account for the type cast.
function _ZN12_GLOBAL__N_1L29replaceTensorCastForOpIterArgERN4mlir15PatternRewriterERNS0_9OpOperandENS0_5ValueE called 0 returned 0% blocks executed 0%
    #####:  800:static ForOp replaceTensorCastForOpIterArg(PatternRewriter &rewriter,
        -:  801:                                           OpOperand &operand,
        -:  802:                                           Value replacement) {
    #####:  803:  Type oldType = operand.get().getType(), newType = replacement.getType();
call    0 never executed
    #####:  804:  assert(oldType.isa<RankedTensorType>() && newType.isa<RankedTensorType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  805:         "expected ranked tensor types");
        -:  806:
        -:  807:  // 1. Create new iter operands, exactly 1 is replaced.
    #####:  808:  ForOp forOp = cast<ForOp>(operand.getOwner());
call    0 never executed
    #####:  809:  assert(operand.getOperandNumber() >= forOp.getNumControlOperands() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  810:         "expected an iter OpOperand");
    #####:  811:  if (operand.get().getType() == replacement.getType())
branch  0 never executed
branch  1 never executed
    #####:  812:    return forOp;
    #####:  813:  SmallVector<Value> newIterOperands;
call    0 never executed
    #####:  814:  for (OpOperand &opOperand : forOp.getIterOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  815:    if (opOperand.getOperandNumber() == operand.getOperandNumber()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  816:      newIterOperands.push_back(replacement);
call    0 never executed
    #####:  817:      continue;
        -:  818:    }
    #####:  819:    newIterOperands.push_back(opOperand.get());
call    0 never executed
        -:  820:  }
        -:  821:
        -:  822:  // 2. Create the new forOp shell.
    #####:  823:  scf::ForOp newForOp = rewriter.create<scf::ForOp>(
    #####:  824:      forOp.getLoc(), forOp.getLowerBound(), forOp.getUpperBound(),
call    0 never executed
call    1 never executed
    #####:  825:      forOp.getStep(), newIterOperands);
call    0 never executed
call    1 never executed
    #####:  826:  newForOp->setAttrs(forOp->getAttrs());
call    0 never executed
call    1 never executed
    #####:  827:  Block &newBlock = newForOp.getRegion().front();
call    0 never executed
call    1 never executed
    #####:  828:  SmallVector<Value, 4> newBlockTransferArgs(newBlock.getArguments().begin(),
call    0 never executed
    #####:  829:                                             newBlock.getArguments().end());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  830:
        -:  831:  // 3. Inject an incoming cast op at the beginning of the block for the bbArg
        -:  832:  // corresponding to the `replacement` value.
    #####:  833:  OpBuilder::InsertionGuard g(rewriter);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  834:  rewriter.setInsertionPoint(&newBlock, newBlock.begin());
call    0 never executed
    #####:  835:  BlockArgument newRegionIterArg = newForOp.getRegionIterArgForOpOperand(
    #####:  836:      newForOp->getOpOperand(operand.getOperandNumber()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  837:  Value castIn = rewriter.create<tensor::CastOp>(newForOp.getLoc(), oldType,
    #####:  838:                                                 newRegionIterArg);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  839:  newBlockTransferArgs[newRegionIterArg.getArgNumber()] = castIn;
branch  0 never executed
branch  1 never executed
        -:  840:
        -:  841:  // 4. Steal the old block ops, mapping to the newBlockTransferArgs.
    #####:  842:  Block &oldBlock = forOp.getRegion().front();
call    0 never executed
call    1 never executed
    #####:  843:  rewriter.mergeBlocks(&oldBlock, &newBlock, newBlockTransferArgs);
call    0 never executed
call    1 never executed
        -:  844:
        -:  845:  // 5. Inject an outgoing cast op at the end of the block and yield it instead.
    #####:  846:  auto clonedYieldOp = cast<scf::YieldOp>(newBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####:  847:  rewriter.setInsertionPoint(clonedYieldOp);
call    0 never executed
    #####:  848:  unsigned yieldIdx =
call    0 never executed
    #####:  849:      newRegionIterArg.getArgNumber() - forOp.getNumInductionVars();
call    0 never executed
    #####:  850:  Value castOut = rewriter.create<tensor::CastOp>(
    #####:  851:      newForOp.getLoc(), newType, clonedYieldOp.getOperand(yieldIdx));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  852:  SmallVector<Value> newYieldOperands = clonedYieldOp.getOperands();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  853:  newYieldOperands[yieldIdx] = castOut;
branch  0 never executed
branch  1 never executed
    #####:  854:  rewriter.create<scf::YieldOp>(newForOp.getLoc(), newYieldOperands);
call    0 never executed
    #####:  855:  rewriter.eraseOp(clonedYieldOp);
call    0 never executed
        -:  856:
        -:  857:  // 6. Inject an outgoing cast op after the forOp.
    #####:  858:  rewriter.setInsertionPointAfter(newForOp);
call    0 never executed
    #####:  859:  SmallVector<Value> newResults = newForOp.getResults();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  860:  newResults[yieldIdx] = rewriter.create<tensor::CastOp>(
branch  0 never executed
branch  1 never executed
    #####:  861:      newForOp.getLoc(), oldType, newResults[yieldIdx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  862:
    #####:  863:  return newForOp;
branch  0 never executed
branch  1 never executed
        -:  864:}
        -:  865:
        -:  866:/// Fold scf.for iter_arg/result pairs that go through incoming/ougoing
        -:  867:/// a tensor.cast op pair so as to pull the tensor.cast inside the scf.for:
        -:  868:///
        -:  869:/// ```
        -:  870:///   %0 = tensor.cast %t0 : tensor<32x1024xf32> to tensor<?x?xf32>
        -:  871:///   %1 = scf.for %i = %c0 to %c1024 step %c32 iter_args(%iter_t0 = %0)
        -:  872:///      -> (tensor<?x?xf32>) {
        -:  873:///     %2 = call @do(%iter_t0) : (tensor<?x?xf32>) -> tensor<?x?xf32>
        -:  874:///     scf.yield %2 : tensor<?x?xf32>
        -:  875:///   }
        -:  876:///   %2 = tensor.cast %1 : tensor<?x?xf32> to tensor<32x1024xf32>
        -:  877:///   use_of(%2)
        -:  878:/// ```
        -:  879:///
        -:  880:/// folds into:
        -:  881:///
        -:  882:/// ```
        -:  883:///   %0 = scf.for %arg2 = %c0 to %c1024 step %c32 iter_args(%arg3 = %arg0)
        -:  884:///       -> (tensor<32x1024xf32>) {
        -:  885:///     %2 = tensor.cast %arg3 : tensor<32x1024xf32> to tensor<?x?xf32>
        -:  886:///     %3 = call @do(%2) : (tensor<?x?xf32>) -> tensor<?x?xf32>
        -:  887:///     %4 = tensor.cast %3 : tensor<?x?xf32> to tensor<32x1024xf32>
        -:  888:///     scf.yield %4 : tensor<32x1024xf32>
        -:  889:///   }
        -:  890:///   use_of(%0)
        -:  891:/// ```
        -:  892:struct ForOpTensorCastFolder : public OpRewritePattern<ForOp> {
        -:  893:  using OpRewritePattern<ForOp>::OpRewritePattern;
        -:  894:
function _ZNK12_GLOBAL__N_121ForOpTensorCastFolder15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterE called 24 returned 100% blocks executed 15%
       24:  895:  LogicalResult matchAndRewrite(ForOp op,
        -:  896:                                PatternRewriter &rewriter) const override {
      24*:  897:    for (auto it : llvm::zip(op.getIterOpOperands(), op.getResults())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  898:      OpOperand &iterOpOperand = std::get<0>(it);
call    0 never executed
    #####:  899:      auto incomingCast = iterOpOperand.get().getDefiningOp<tensor::CastOp>();
call    0 never executed
    #####:  900:      if (!incomingCast)
branch  0 never executed
branch  1 never executed
    #####:  901:        continue;
    #####:  902:      if (!std::get<1>(it).hasOneUse())
branch  0 never executed
branch  1 never executed
    #####:  903:        continue;
    #####:  904:      auto outgoingCastOp =
call    0 never executed
    #####:  905:          dyn_cast<tensor::CastOp>(*std::get<1>(it).user_begin());
call    0 never executed
    #####:  906:      if (!outgoingCastOp)
branch  0 never executed
branch  1 never executed
    #####:  907:        continue;
        -:  908:
        -:  909:      // Must be a tensor.cast op pair with matching types.
    #####:  910:      if (outgoingCastOp.getResult().getType() !=
branch  0 never executed
branch  1 never executed
    #####:  911:          incomingCast.getSource().getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  912:        continue;
        -:  913:
        -:  914:      // Create a new ForOp with that iter operand replaced.
    #####:  915:      auto newForOp = replaceTensorCastForOpIterArg(rewriter, iterOpOperand,
    #####:  916:                                                    incomingCast.getSource());
call    0 never executed
call    1 never executed
        -:  917:
        -:  918:      // Insert outgoing cast and use it to replace the corresponding result.
    #####:  919:      rewriter.setInsertionPointAfter(newForOp);
call    0 never executed
    #####:  920:      SmallVector<Value> replacements = newForOp.getResults();
call    0 never executed
call    1 never executed
    #####:  921:      unsigned returnIdx =
    #####:  922:          iterOpOperand.getOperandNumber() - op.getNumControlOperands();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  923:      replacements[returnIdx] = rewriter.create<tensor::CastOp>(
branch  0 never executed
branch  1 never executed
    #####:  924:          op.getLoc(), incomingCast.getDest().getType(),
call    0 never executed
    #####:  925:          replacements[returnIdx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  926:      rewriter.replaceOp(op, replacements);
call    0 never executed
call    1 never executed
    #####:  927:      return success();
branch  0 never executed
branch  1 never executed
        -:  928:    }
       24:  929:    return failure();
        -:  930:  }
        -:  931:};
        -:  932:
        -:  933:/// Canonicalize the iter_args of an scf::ForOp that involve a
        -:  934:/// `bufferization.to_tensor` and for which only the last loop iteration is
        -:  935:/// actually visible outside of the loop. The canonicalization looks for a
        -:  936:/// pattern such as:
        -:  937:/// ```
        -:  938:///    %t0 = ... : tensor_type
        -:  939:///    %0 = scf.for ... iter_args(%bb0 : %t0) -> (tensor_type) {
        -:  940:///      ...
        -:  941:///      // %m is either buffer_cast(%bb00) or defined above the loop
        -:  942:///      %m... : memref_type
        -:  943:///      ... // uses of %m with potential inplace updates
        -:  944:///      %new_tensor = bufferization.to_tensor %m : memref_type
        -:  945:///      ...
        -:  946:///      scf.yield %new_tensor : tensor_type
        -:  947:///    }
        -:  948:/// ```
        -:  949:///
        -:  950:/// `%bb0` may have either 0 or 1 use. If it has 1 use it must be exactly a
        -:  951:/// `%m = buffer_cast %bb0` op that feeds into the yielded
        -:  952:/// `bufferization.to_tensor` op.
        -:  953:///
        -:  954:/// If no aliasing write to the memref `%m`, from which `%new_tensor`is loaded,
        -:  955:/// occurs between `bufferization.to_tensor and yield then the value %0
        -:  956:/// visible outside of the loop is the last `bufferization.to_tensor`
        -:  957:/// produced in the loop.
        -:  958:///
        -:  959:/// For now, we approximate the absence of aliasing by only supporting the case
        -:  960:/// when the bufferization.to_tensor is the operation immediately preceding
        -:  961:/// the yield.
        -:  962://
        -:  963:/// The canonicalization rewrites the pattern as:
        -:  964:/// ```
        -:  965:///    // %m is either a buffer_cast or defined above
        -:  966:///    %m... : memref_type
        -:  967:///    scf.for ... iter_args(%bb0 : %t0) -> (tensor_type) {
        -:  968:///      ... // uses of %m with potential inplace updates
        -:  969:///      scf.yield %bb0: tensor_type
        -:  970:///    }
        -:  971:///    %0 = bufferization.to_tensor %m : memref_type
        -:  972:/// ```
        -:  973:///
        -:  974:/// A later bbArg canonicalization will further rewrite as:
        -:  975:/// ```
        -:  976:///    // %m is either a buffer_cast or defined above
        -:  977:///    %m... : memref_type
        -:  978:///    scf.for ... { // no iter_args
        -:  979:///      ... // uses of %m with potential inplace updates
        -:  980:///    }
        -:  981:///    %0 = bufferization.to_tensor %m : memref_type
        -:  982:/// ```
        -:  983:struct LastTensorLoadCanonicalization : public OpRewritePattern<ForOp> {
        -:  984:  using OpRewritePattern<ForOp>::OpRewritePattern;
        -:  985:
function _ZNK12_GLOBAL__N_130LastTensorLoadCanonicalization15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterE called 24 returned 100% blocks executed 17%
       24:  986:  LogicalResult matchAndRewrite(ForOp forOp,
        -:  987:                                PatternRewriter &rewriter) const override {
      48*:  988:    assert(std::next(forOp.getRegion().begin()) == forOp.getRegion().end() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  989:           "unexpected multiple blocks");
        -:  990:
       24:  991:    Location loc = forOp.getLoc();
call    0 returned 100%
       24:  992:    DenseMap<Value, Value> replacements;
call    0 returned 100%
      24*:  993:    for (BlockArgument bbArg : forOp.getRegionIterArgs()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  994:      unsigned idx = bbArg.getArgNumber() - /*numIv=*/1;
call    0 never executed
    #####:  995:      auto yieldOp =
call    0 never executed
    #####:  996:          cast<scf::YieldOp>(forOp.getRegion().front().getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  997:      Value yieldVal = yieldOp->getOperand(idx);
call    0 never executed
    #####:  998:      auto tensorLoadOp = yieldVal.getDefiningOp<bufferization::ToTensorOp>();
call    0 never executed
    #####:  999:      bool isTensor = bbArg.getType().isa<TensorType>();
call    0 never executed
        -: 1000:
    #####: 1001:      bufferization::ToMemrefOp tensorToMemref;
branch  0 never executed
branch  1 never executed
        -: 1002:      // Either bbArg has no use or it has a single buffer_cast use.
    #####: 1003:      if (bbArg.hasOneUse())
branch  0 never executed
branch  1 never executed
    #####: 1004:        tensorToMemref =
call    0 never executed
    #####: 1005:            dyn_cast<bufferization::ToMemrefOp>(*bbArg.getUsers().begin());
call    0 never executed
    #####: 1006:      if (!isTensor || !tensorLoadOp || (!bbArg.use_empty() && !tensorToMemref))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1007:        continue;
        -: 1008:      // If tensorToMemref is present, it must feed into the `ToTensorOp`.
    #####: 1009:      if (tensorToMemref && tensorLoadOp.getMemref() != tensorToMemref)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1010:        continue;
        -: 1011:      // TODO: Any aliasing write of tensorLoadOp.memref() nested under `forOp`
        -: 1012:      // must be before `ToTensorOp` in the block so that the lastWrite
        -: 1013:      // property is not subject to additional side-effects.
        -: 1014:      // For now, we only support the case when ToTensorOp appears
        -: 1015:      // immediately before the terminator.
    #####: 1016:      if (tensorLoadOp->getNextNode() != yieldOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1017:        continue;
        -: 1018:
        -: 1019:      // Clone the optional tensorToMemref before forOp.
    #####: 1020:      if (tensorToMemref) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        rewriter.setInsertionPoint(forOp);
call    0 never executed
    #####: 1022:        rewriter.replaceOpWithNewOp<bufferization::ToMemrefOp>(
    #####: 1023:            tensorToMemref, tensorToMemref.getMemref().getType(),
call    0 never executed
call    1 never executed
    #####: 1024:            tensorToMemref.getTensor());
call    0 never executed
call    1 never executed
        -: 1025:      }
        -: 1026:
        -: 1027:      // Clone the tensorLoad after forOp.
    #####: 1028:      rewriter.setInsertionPointAfter(forOp);
call    0 never executed
    #####: 1029:      Value newTensorLoad = rewriter.create<bufferization::ToTensorOp>(
    #####: 1030:          loc, tensorLoadOp.getMemref());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1031:      Value forOpResult = forOp.getResult(bbArg.getArgNumber() - /*iv=*/1);
branch  0 never executed
branch  1 never executed
    #####: 1032:      replacements.insert(std::make_pair(forOpResult, newTensorLoad));
call    0 never executed
        -: 1033:
        -: 1034:      // Make the terminator just yield the bbArg, the old tensorLoadOp + the
        -: 1035:      // old bbArg (that is now directly yielded) will canonicalize away.
    #####: 1036:      rewriter.startRootUpdate(yieldOp);
call    0 never executed
    #####: 1037:      yieldOp.setOperand(idx, bbArg);
call    0 never executed
    #####: 1038:      rewriter.finalizeRootUpdate(yieldOp);
call    0 never executed
        -: 1039:    }
       24: 1040:    if (replacements.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       24: 1041:      return failure();
        -: 1042:
        -: 1043:    // We want to replace a subset of the results of `forOp`. rewriter.replaceOp
        -: 1044:    // replaces the whole op and erase it unconditionally. This is wrong for
        -: 1045:    // `forOp` as it generally contains ops with side effects.
        -: 1046:    // Instead, use `rewriter.replaceOpWithIf`.
      24*: 1047:    SmallVector<Value> newResults;
branch  0 never executed
branch  1 never executed
call    2 returned 100%
    #####: 1048:    newResults.reserve(forOp.getNumResults());
branch  0 never executed
branch  1 never executed
    #####: 1049:    for (Value v : forOp.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1050:      auto it = replacements.find(v);
call    0 never executed
    #####: 1051:      newResults.push_back((it != replacements.end()) ? it->second : v);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 1052:    }
    #####: 1053:    unsigned idx = 0;
function _ZZNK12_GLOBAL__N_130LastTensorLoadCanonicalization15matchAndRewriteEN4mlir3scf5ForOpERNS1_15PatternRewriterEENKUlRNS1_9OpOperandEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1054:    rewriter.replaceOpWithIf(forOp, newResults, [&](OpOperand &op) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1055:      return op.get() != newResults[idx++];
branch  0 never executed
branch  1 never executed
        -: 1056:    });
    #####: 1057:    return success();
branch  0 never executed
branch  1 never executed
        -: 1058:  }
        -: 1059:};
        -: 1060:} // namespace
        -: 1061:
function _ZN4mlir3scf5ForOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1819 returned 100% blocks executed 100%
     1819: 1062:void ForOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1063:                                        MLIRContext *context) {
     1819: 1064:  results.add<ForOpIterArgsFolder, SimplifyTrivialLoops,
     1819: 1065:              LastTensorLoadCanonicalization, ForOpTensorCastFolder>(context);
call    0 returned 100%
     1819: 1066:}
        -: 1067:
function _ZN4mlir3scf5ForOp15getConstantStepEv called 4 returned 100% blocks executed 86%
        4: 1068:Optional<APInt> ForOp::getConstantStep() {
        4: 1069:  IntegerAttr step;
        4: 1070:  if (matchPattern(getStep(), m_Constant(&step)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        4: 1071:    return step.getValue();
call    0 returned 100%
    #####: 1072:  return {};
        -: 1073:}
        -: 1074:
function _ZN4mlir3scf5ForOp18getSpeculatabilityEv called 0 returned 0% blocks executed 0%
    #####: 1075:Speculation::Speculatability ForOp::getSpeculatability() {
        -: 1076:  // `scf.for (I = Start; I < End; I += 1)` terminates for all values of Start
        -: 1077:  // and End.
    #####: 1078:  if (auto constantStep = getConstantStep())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1079:    if (*constantStep == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1080:      return Speculation::RecursivelySpeculatable;
call    0 never executed
        -: 1081:
        -: 1082:  // For Step != 1, the loop may not terminate.  We can add more smarts here if
        -: 1083:  // needed.
    #####: 1084:  return Speculation::NotSpeculatable;
        -: 1085:}
        -: 1086:
        -: 1087://===----------------------------------------------------------------------===//
        -: 1088:// ForeachThreadOp
        -: 1089://===----------------------------------------------------------------------===//
        -: 1090:
function _ZN4mlir3scf15ForeachThreadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1091:LogicalResult ForeachThreadOp::verify() {
        -: 1092:  // Call terminator's verify to produce most informative error messages.
    #####: 1093:  if (failed(getTerminator().verify()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1094:    return failure();
        -: 1095:
        -: 1096:  // Check number of outputs.
    #####: 1097:  if (getNumResults() != getOutputs().size())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1098:    return emitOpError("produces ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1099:           << getNumResults() << " results, but has only "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1100:           << getOutputs().size() << " outputs";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1101:
        -: 1102:  // Check that the body defines block arguments for thread indices and outputs.
    #####: 1103:  auto *body = getBody();
call    0 never executed
    #####: 1104:  if (body->getNumArguments() != getRank() + getOutputs().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1105:    return emitOpError("region expects ") << getRank() << " arguments";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1106:  for (int64_t i = 0; i < getRank(); ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1107:    if (!body->getArgument(i).getType().isIndex())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1108:      return emitOpError("expects ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1109:             << i << "-th block argument to be an index";
call    0 never executed
call    1 never executed
    #####: 1110:  for (unsigned i = 0; i < getOutputs().size(); ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1111:    if (body->getArgument(i + getRank()).getType() != getOutputs()[i].getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1112:      return emitOpError("type mismatch between ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1113:             << i << "-th output and corresponding block argument";
call    0 never executed
call    1 never executed
        -: 1114:
    #####: 1115:  return success();
        -: 1116:}
        -: 1117:
function _ZN4mlir3scf15ForeachThreadOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1118:void ForeachThreadOp::print(OpAsmPrinter &p) {
    #####: 1119:  p << " (";
call    0 never executed
    #####: 1120:  llvm::interleaveComma(getThreadIndices(), p);
call    0 never executed
call    1 never executed
    #####: 1121:  p << ") in (";
call    0 never executed
    #####: 1122:  llvm::interleaveComma(getNumThreads(), p);
call    0 never executed
call    1 never executed
    #####: 1123:  p << ")";
call    0 never executed
    #####: 1124:  printInitializationList(p, getRegionOutArgs(), getOutputs(), " shared_outs");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1125:  p << " ";
call    0 never executed
    #####: 1126:  if (!getRegionOutArgs().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1127:    p << "-> (" << getResultTypes() << ") ";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####: 1128:  p.printRegion(getRegion(),
call    0 never executed
        -: 1129:                /*printEntryBlockArgs=*/false,
    #####: 1130:                /*printBlockTerminators=*/getNumResults() > 0);
call    0 never executed
    #####: 1131:  p.printOptionalAttrDict(getOperation()->getAttrs(),
call    0 never executed
    #####: 1132:                          {"operand_segment_sizes"});
call    0 never executed
    #####: 1133:}
        -: 1134:
function _ZN4mlir3scf15ForeachThreadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1135:ParseResult ForeachThreadOp::parse(OpAsmParser &parser,
        -: 1136:                                   OperationState &result) {
    #####: 1137:  auto &builder = parser.getBuilder();
call    0 never executed
        -: 1138:  // Parse an opening `(` followed by thread index variables followed by `)`
        -: 1139:  // TODO: when we can refer to such "induction variable"-like handles from the
        -: 1140:  // declarative assembly format, we can implement the parser as a custom hook.
    #####: 1141:  SmallVector<OpAsmParser::Argument, 4> threadIndices;
call    0 never executed
    #####: 1142:  if (parser.parseArgumentList(threadIndices, OpAsmParser::Delimiter::Paren))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1143:    return failure();
        -: 1144:
        -: 1145:  // Parse `in` threadNums.
    #####: 1146:  SmallVector<OpAsmParser::UnresolvedOperand, 4> threadNums;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1147:  if (parser.parseKeyword("in") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1148:      parser.parseOperandList(threadNums, threadIndices.size(),
call    0 never executed
    #####: 1149:                              OpAsmParser::Delimiter::Paren) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1150:      parser.resolveOperands(threadNums, builder.getIndexType(),
    #####: 1151:                             result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1152:    return failure();
        -: 1153:
        -: 1154:  // Parse out operands and results.
    #####: 1155:  SmallVector<OpAsmParser::Argument, 4> regionOutArgs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1156:  SmallVector<OpAsmParser::UnresolvedOperand, 4> outOperands;
branch  0 never executed
branch  1 never executed
    #####: 1157:  SMLoc outOperandsLoc = parser.getCurrentLocation();
call    0 never executed
    #####: 1158:  if (succeeded(parser.parseOptionalKeyword("shared_outs"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1159:    if (outOperands.size() != result.types.size())
branch  0 never executed
branch  1 never executed
    #####: 1160:      return parser.emitError(outOperandsLoc,
call    0 never executed
call    1 never executed
    #####: 1161:                              "mismatch between out operands and types");
call    0 never executed
call    1 never executed
    #####: 1162:    if (parser.parseAssignmentList(regionOutArgs, outOperands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1163:        parser.parseOptionalArrowTypeList(result.types) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1164:        parser.resolveOperands(outOperands, result.types, outOperandsLoc,
    #####: 1165:                               result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1166:      return failure();
        -: 1167:  }
        -: 1168:
        -: 1169:  // Parse region.
    #####: 1170:  SmallVector<OpAsmParser::Argument, 4> regionArgs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1171:  std::unique_ptr<Region> region = std::make_unique<Region>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1172:  for (auto &idx : threadIndices) {
branch  0 never executed
branch  1 never executed
    #####: 1173:    idx.type = builder.getIndexType();
call    0 never executed
    #####: 1174:    regionArgs.push_back(idx);
call    0 never executed
        -: 1175:  }
    #####: 1176:  for (const auto &it : llvm::enumerate(regionOutArgs)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1177:    auto &out = it.value();
branch  0 never executed
branch  1 never executed
    #####: 1178:    out.type = result.types[it.index()];
branch  0 never executed
branch  1 never executed
    #####: 1179:    regionArgs.push_back(out);
call    0 never executed
        -: 1180:  }
    #####: 1181:  if (parser.parseRegion(*region, regionArgs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1182:    return failure();
        -: 1183:
        -: 1184:  // Ensure terminator and move region.
    #####: 1185:  OpBuilder b(builder.getContext());
call    0 never executed
    #####: 1186:  ForeachThreadOp::ensureTerminator(*region, b, result.location);
call    0 never executed
    #####: 1187:  result.addRegion(std::move(region));
call    0 never executed
        -: 1188:
        -: 1189:  // Parse the optional attribute list.
    #####: 1190:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1191:    return failure();
    #####: 1192:  result.addAttribute("operand_segment_sizes",
call    0 never executed
    #####: 1193:                      parser.getBuilder().getDenseI32ArrayAttr(
call    0 never executed
    #####: 1194:                          {static_cast<int32_t>(threadNums.size()),
call    0 never executed
    #####: 1195:                           static_cast<int32_t>(outOperands.size())}));
call    0 never executed
call    1 never executed
    #####: 1196:  return success();
        -: 1197:}
        -: 1198:
        -: 1199:// Bodyless builder, outputs must be specified.
function _ZN4mlir3scf15ForeachThreadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeES6_N4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1200:void ForeachThreadOp::build(mlir::OpBuilder &builder,
        -: 1201:                            mlir::OperationState &result, ValueRange outputs,
        -: 1202:                            ValueRange numThreads,
        -: 1203:                            ArrayRef<int64_t> threadDimMapping) {
    #####: 1204:  result.addOperands(numThreads);
call    0 never executed
    #####: 1205:  result.addOperands(outputs);
call    0 never executed
    #####: 1206:  result.addAttribute(ForeachThreadOp::getThreadDimMappingAttrName(result.name),
call    0 never executed
    #####: 1207:                      builder.getI64ArrayAttr(threadDimMapping));
call    0 never executed
    #####: 1208:  result.addAttribute(
call    0 never executed
        -: 1209:      "operand_segment_sizes",
    #####: 1210:      builder.getDenseI32ArrayAttr({static_cast<int32_t>(numThreads.size()),
call    0 never executed
    #####: 1211:                                    static_cast<int32_t>(outputs.size())}));
call    0 never executed
call    1 never executed
    #####: 1212:  result.addTypes(TypeRange(outputs));
call    0 never executed
call    1 never executed
        -: 1213:
    #####: 1214:  Region *bodyRegion = result.addRegion();
call    0 never executed
    #####: 1215:  OpBuilder::InsertionGuard g(builder);
call    0 never executed
        -: 1216:  // createBlock sets the IP inside the block.
        -: 1217:  // Generally we would guard against that but the default ensureTerminator impl
        -: 1218:  // expects it ..
    #####: 1219:  builder.createBlock(bodyRegion);
call    0 never executed
call    1 never executed
    #####: 1220:  Block &bodyBlock = bodyRegion->front();
call    0 never executed
        -: 1221:  // Add block arguments for indices and outputs.
    #####: 1222:  bodyBlock.addArguments(
    #####: 1223:      SmallVector<Type>(numThreads.size(), builder.getIndexType()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1224:      SmallVector<Location>(numThreads.size(), result.location));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1225:  bodyBlock.addArguments(
        -: 1226:      TypeRange(outputs),
    #####: 1227:      SmallVector<Location>(outputs.size(), result.location));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1228:  ForeachThreadOp::ensureTerminator(*bodyRegion, builder, result.location);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1229:}
        -: 1230:
        -: 1231:// Builder that takes a bodyBuilder lambda.
function _ZN4mlir3scf15ForeachThreadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeES6_N4llvm8ArrayRefIlEENS7_12function_refIFvS3_NS_8LocationES6_EEE called 0 returned 0% blocks executed 0%
    #####: 1232:void ForeachThreadOp::build(
        -: 1233:    mlir::OpBuilder &builder, mlir::OperationState &result, ValueRange outputs,
        -: 1234:    ValueRange numThreads, ArrayRef<int64_t> threadDimMapping,
        -: 1235:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilder) {
    #####: 1236:  result.addOperands(numThreads);
call    0 never executed
    #####: 1237:  result.addOperands(outputs);
call    0 never executed
    #####: 1238:  result.addAttribute(ForeachThreadOp::getThreadDimMappingAttrName(result.name),
call    0 never executed
    #####: 1239:                      builder.getI64ArrayAttr(threadDimMapping));
call    0 never executed
    #####: 1240:  result.addAttribute(
call    0 never executed
        -: 1241:      "operand_segment_sizes",
    #####: 1242:      builder.getDenseI32ArrayAttr({static_cast<int32_t>(numThreads.size()),
call    0 never executed
    #####: 1243:                                    static_cast<int32_t>(outputs.size())}));
call    0 never executed
call    1 never executed
    #####: 1244:  result.addTypes(TypeRange(outputs));
call    0 never executed
call    1 never executed
        -: 1245:
    #####: 1246:  Region *bodyRegion = result.addRegion();
call    0 never executed
    #####: 1247:  OpBuilder::InsertionGuard g(builder);
call    0 never executed
    #####: 1248:  builder.createBlock(bodyRegion);
call    0 never executed
call    1 never executed
    #####: 1249:  Block &bodyBlock = bodyRegion->front();
call    0 never executed
        -: 1250:  // Add block arguments for indices and outputs.
    #####: 1251:  bodyBlock.addArguments(
    #####: 1252:      SmallVector<Type>(numThreads.size(), builder.getIndexType()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1253:      SmallVector<Location>(numThreads.size(), result.location));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1254:  bodyBlock.addArguments(
        -: 1255:      TypeRange(outputs),
    #####: 1256:      SmallVector<Location>(outputs.size(), result.location));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1257:
    #####: 1258:  builder.setInsertionPointToStart(&bodyBlock);
call    0 never executed
    #####: 1259:  bodyBuilder(builder, result.location, bodyBlock.getArguments());
call    0 never executed
call    1 never executed
        -: 1260:#ifndef NDEBUG
    #####: 1261:  auto terminator =
    #####: 1262:      llvm::dyn_cast<PerformConcurrentlyOp>(bodyBlock.getTerminator());
call    0 never executed
call    1 never executed
    #####: 1263:  assert(terminator &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1264:         "expected bodyBuilder to create PerformConcurrentlyOp terminator");
        -: 1265:#endif // NDEBUG
    #####: 1266:}
        -: 1267:
        -: 1268:// The ensureTerminator method generated by SingleBlockImplicitTerminator is
        -: 1269:// unaware of the fact that our terminator also needs a region to be
        -: 1270:// well-formed. We override it here to ensure that we do the right thing.
function _ZN4mlir3scf15ForeachThreadOp16ensureTerminatorERNS_6RegionERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 1271:void ForeachThreadOp::ensureTerminator(Region &region, OpBuilder &builder,
        -: 1272:                                       Location loc) {
    #####: 1273:  OpTrait::SingleBlockImplicitTerminator<PerformConcurrentlyOp>::Impl<
call    0 never executed
    #####: 1274:      ForeachThreadOp>::ensureTerminator(region, builder, loc);
    #####: 1275:  auto terminator =
call    0 never executed
    #####: 1276:      llvm::dyn_cast<PerformConcurrentlyOp>(region.front().getTerminator());
call    0 never executed
call    1 never executed
    #####: 1277:  if (terminator.getRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1278:    builder.createBlock(&terminator.getRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1279:}
        -: 1280:
function _ZN4mlir3scf15ForeachThreadOp13getTerminatorEv called 0 returned 0% blocks executed 0%
    #####: 1281:PerformConcurrentlyOp ForeachThreadOp::getTerminator() {
    #####: 1282:  return cast<PerformConcurrentlyOp>(getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1283:}
        -: 1284:
        -: 1285:template <typename T>
    #####: 1286:static FailureOr<SmallVector<T>> permute(const SmallVector<T> &vals,
        -: 1287:                                         ArrayRef<int64_t> perm) {
    #####: 1288:  if (vals.size() != perm.size())
    #####: 1289:    return failure();
    #####: 1290:  SmallVector<T> result(vals.size());
    #####: 1291:  SmallVector<bool> seen(vals.size());
    #####: 1292:  for (auto [idx, val] : llvm::zip(perm, vals)) {
        -: 1293:    // Already seen, invalid thread_dim_mapping.
    #####: 1294:    if (seen[idx])
    #####: 1295:      return failure();
    #####: 1296:    result[idx] = val;
    #####: 1297:    seen[idx] = true;
        -: 1298:  }
        -: 1299:  // Some not seen, invalid thread_dim_mapping.
    #####: 1300:  if (!llvm::all_of(seen, [](bool b) { return b; }))
    #####: 1301:    return failure();
    #####: 1302:  return result;
        -: 1303:}
------------------
_Z7permuteIN4mlir12OpFoldResultEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEERKS8_NS3_8ArrayRefIlEE:
function _Z7permuteIN4mlir12OpFoldResultEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEERKS8_NS3_8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1286:static FailureOr<SmallVector<T>> permute(const SmallVector<T> &vals,
        -: 1287:                                         ArrayRef<int64_t> perm) {
    #####: 1288:  if (vals.size() != perm.size())
branch  0 never executed
branch  1 never executed
    #####: 1289:    return failure();
    #####: 1290:  SmallVector<T> result(vals.size());
call    0 never executed
    #####: 1291:  SmallVector<bool> seen(vals.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1292:  for (auto [idx, val] : llvm::zip(perm, vals)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1293:    // Already seen, invalid thread_dim_mapping.
    #####: 1294:    if (seen[idx])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1295:      return failure();
    #####: 1296:    result[idx] = val;
branch  0 never executed
branch  1 never executed
    #####: 1297:    seen[idx] = true;
branch  0 never executed
branch  1 never executed
        -: 1298:  }
        -: 1299:  // Some not seen, invalid thread_dim_mapping.
    #####: 1300:  if (!llvm::all_of(seen, [](bool b) { return b; }))
branch  0 never executed
branch  1 never executed
    #####: 1301:    return failure();
    #####: 1302:  return result;
branch  0 never executed
branch  1 never executed
        -: 1303:}
------------------
_Z7permuteIN4mlir5ValueEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEERKS8_NS3_8ArrayRefIlEE:
function _Z7permuteIN4mlir5ValueEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEERKS8_NS3_8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####: 1286:static FailureOr<SmallVector<T>> permute(const SmallVector<T> &vals,
        -: 1287:                                         ArrayRef<int64_t> perm) {
    #####: 1288:  if (vals.size() != perm.size())
branch  0 never executed
branch  1 never executed
    #####: 1289:    return failure();
    #####: 1290:  SmallVector<T> result(vals.size());
call    0 never executed
    #####: 1291:  SmallVector<bool> seen(vals.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1292:  for (auto [idx, val] : llvm::zip(perm, vals)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1293:    // Already seen, invalid thread_dim_mapping.
    #####: 1294:    if (seen[idx])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1295:      return failure();
    #####: 1296:    result[idx] = val;
branch  0 never executed
branch  1 never executed
    #####: 1297:    seen[idx] = true;
        -: 1298:  }
        -: 1299:  // Some not seen, invalid thread_dim_mapping.
    #####: 1300:  if (!llvm::all_of(seen, [](bool b) { return b; }))
branch  0 never executed
branch  1 never executed
    #####: 1301:    return failure();
    #####: 1302:  return result;
branch  0 never executed
branch  1 never executed
        -: 1303:}
------------------
        -: 1304:
        -: 1305:/// Helper to get apply the `thread_dim_mapping` permutation of a
        -: 1306:/// `foreachThreadOp` to `values`.
        -: 1307:template <typename T>
        -: 1308:static FailureOr<SmallVector<T>>
    #####: 1309:getValuesPermutedByThreadMapping(scf::ForeachThreadOp foreachThreadOp,
        -: 1310:                                 const SmallVector<T> &values) {
        -: 1311:  // Apply mapping permutation if specified.
    #####: 1312:  auto mapping = foreachThreadOp.getThreadDimMapping();
    #####: 1313:  if (mapping && !mapping.empty()) {
    #####: 1314:    auto maybePermuted = permute(values, extractFromI64ArrayAttr(mapping));
    #####: 1315:    if (failed(maybePermuted))
    #####: 1316:      return foreachThreadOp->emitError("invalid permutation");
    #####: 1317:    return *maybePermuted;
        -: 1318:  }
    #####: 1319:  return values;
        -: 1320:}
------------------
_Z32getValuesPermutedByThreadMappingIN4mlir12OpFoldResultEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEENS0_3scf15ForeachThreadOpERKS8_:
function _Z32getValuesPermutedByThreadMappingIN4mlir12OpFoldResultEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEENS0_3scf15ForeachThreadOpERKS8_ called 0 returned 0% blocks executed 0%
    #####: 1309:getValuesPermutedByThreadMapping(scf::ForeachThreadOp foreachThreadOp,
call    0 never executed
        -: 1310:                                 const SmallVector<T> &values) {
        -: 1311:  // Apply mapping permutation if specified.
    #####: 1312:  auto mapping = foreachThreadOp.getThreadDimMapping();
    #####: 1313:  if (mapping && !mapping.empty()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1314:    auto maybePermuted = permute(values, extractFromI64ArrayAttr(mapping));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1315:    if (failed(maybePermuted))
branch  0 never executed
branch  1 never executed
    #####: 1316:      return foreachThreadOp->emitError("invalid permutation");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1317:    return *maybePermuted;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1318:  }
    #####: 1319:  return values;
        -: 1320:}
------------------
_Z32getValuesPermutedByThreadMappingIN4mlir5ValueEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEENS0_3scf15ForeachThreadOpERKS8_:
function _Z32getValuesPermutedByThreadMappingIN4mlir5ValueEENS0_9FailureOrIN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEEEENS0_3scf15ForeachThreadOpERKS8_ called 0 returned 0% blocks executed 0%
    #####: 1309:getValuesPermutedByThreadMapping(scf::ForeachThreadOp foreachThreadOp,
call    0 never executed
        -: 1310:                                 const SmallVector<T> &values) {
        -: 1311:  // Apply mapping permutation if specified.
    #####: 1312:  auto mapping = foreachThreadOp.getThreadDimMapping();
    #####: 1313:  if (mapping && !mapping.empty()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1314:    auto maybePermuted = permute(values, extractFromI64ArrayAttr(mapping));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1315:    if (failed(maybePermuted))
branch  0 never executed
branch  1 never executed
    #####: 1316:      return foreachThreadOp->emitError("invalid permutation");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1317:    return *maybePermuted;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1318:  }
    #####: 1319:  return values;
        -: 1320:}
------------------
        -: 1321:
        -: 1322:/// Return the thread indices in the order specified by the thread_dim_mapping
        -: 1323:/// attribute. Return failure is thread_dim_mapping is not a valid permutation.
function _ZN4mlir3scf15ForeachThreadOp24getPermutedThreadIndicesEv called 0 returned 0% blocks executed 0%
    #####: 1324:FailureOr<SmallVector<Value>> ForeachThreadOp::getPermutedThreadIndices() {
    #####: 1325:  SmallVector<Value> threadCountValues = this->getThreadIndices();
call    0 never executed
call    1 never executed
    #####: 1326:  threadCountValues.resize(3, Value());
call    0 never executed
    #####: 1327:  return getValuesPermutedByThreadMapping(*this, threadCountValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1328:}
        -: 1329:
        -: 1330:/// Return the number of threads in the order specified by the
        -: 1331:/// thread_dim_mapping attribute.
        -: 1332:/// Return failure is thread_dim_mapping is not a valid permutation.
        -: 1333:FailureOr<SmallVector<OpFoldResult>>
function _ZN4mlir3scf15ForeachThreadOp21getPermutedNumThreadsERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####: 1334:ForeachThreadOp::getPermutedNumThreads(OpBuilder &b) {
    #####: 1335:  SmallVector<OpFoldResult> threadCountValues = this->getNumThreads();
call    0 never executed
call    1 never executed
    #####: 1336:  threadCountValues.resize(3, b.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1337:  return getValuesPermutedByThreadMapping(*this, threadCountValues);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1338:}
        -: 1339:
function _ZN4mlir3scf34getForeachThreadOpThreadIndexOwnerENS_5ValueE called 1826 returned 100% blocks executed 50%
     1826: 1340:ForeachThreadOp mlir::scf::getForeachThreadOpThreadIndexOwner(Value val) {
     1826: 1341:  auto tidxArg = val.dyn_cast<BlockArgument>();
call    0 returned 100%
     1826: 1342:  if (!tidxArg)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1826: 1343:    return ForeachThreadOp();
    #####: 1344:  assert(tidxArg.getOwner() && "unlinked block argument");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1345:  auto *containingOp = tidxArg.getOwner()->getParentOp();
call    0 never executed
    #####: 1346:  return dyn_cast<ForeachThreadOp>(containingOp);
call    0 never executed
        -: 1347:}
        -: 1348:
        -: 1349://===----------------------------------------------------------------------===//
        -: 1350:// PerformConcurrentlyOp
        -: 1351://===----------------------------------------------------------------------===//
        -: 1352:
        -: 1353:// Build a PerformConcurrentlyOp with mixed static and dynamic entries.
function _ZN4mlir3scf21PerformConcurrentlyOp5buildERNS_9OpBuilderERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1354:void PerformConcurrentlyOp::build(OpBuilder &b, OperationState &result) {
    #####: 1355:  OpBuilder::InsertionGuard g(b);
call    0 never executed
    #####: 1356:  Region *bodyRegion = result.addRegion();
call    0 never executed
    #####: 1357:  b.createBlock(bodyRegion);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1358:}
        -: 1359:
function _ZN4mlir3scf21PerformConcurrentlyOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1360:LogicalResult PerformConcurrentlyOp::verify() {
    #####: 1361:  scf::ForeachThreadOp foreachThreadOp =
    #####: 1362:      dyn_cast<scf::ForeachThreadOp>(getOperation()->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1363:  if (!foreachThreadOp)
branch  0 never executed
branch  1 never executed
    #####: 1364:    return this->emitOpError("expected foreach_thread op parent");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1365:
        -: 1366:  // TODO: PerformConcurrentlyOpInterface.
    #####: 1367:  for (Operation &op : getRegion().front().getOperations()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1368:    if (!isa<tensor::ParallelInsertSliceOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1369:      return this->emitOpError("expected only ")
call    0 never executed
call    1 never executed
    #####: 1370:             << tensor::ParallelInsertSliceOp::getOperationName() << " ops";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1371:    }
        -: 1372:
        -: 1373:    // Verify that inserts are into out block arguments.
    #####: 1374:    Value dest = cast<tensor::ParallelInsertSliceOp>(op).getDest();
call    0 never executed
call    1 never executed
    #####: 1375:    ArrayRef<BlockArgument> regionOutArgs = foreachThreadOp.getRegionOutArgs();
call    0 never executed
    #####: 1376:    if (llvm::find(regionOutArgs, dest) == regionOutArgs.end())
branch  0 never executed
branch  1 never executed
    #####: 1377:      return op.emitOpError("may only insert into an output block argument");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1378:  }
    #####: 1379:  return success();
        -: 1380:}
        -: 1381:
function _ZN4mlir3scf21PerformConcurrentlyOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1382:void PerformConcurrentlyOp::print(OpAsmPrinter &p) {
    #####: 1383:  p << " ";
call    0 never executed
    #####: 1384:  p.printRegion(getRegion(),
call    0 never executed
        -: 1385:                /*printEntryBlockArgs=*/false,
    #####: 1386:                /*printBlockTerminators=*/false);
call    0 never executed
    #####: 1387:  p.printOptionalAttrDict(getOperation()->getAttrs());
call    0 never executed
call    1 never executed
    #####: 1388:}
        -: 1389:
function _ZN4mlir3scf21PerformConcurrentlyOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1390:ParseResult PerformConcurrentlyOp::parse(OpAsmParser &parser,
        -: 1391:                                         OperationState &result) {
    #####: 1392:  auto &builder = parser.getBuilder();
call    0 never executed
        -: 1393:
    #####: 1394:  SmallVector<OpAsmParser::Argument, 8> regionOperands;
call    0 never executed
    #####: 1395:  std::unique_ptr<Region> region = std::make_unique<Region>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1396:  if (parser.parseRegion(*region, regionOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1397:    return failure();
        -: 1398:
    #####: 1399:  if (region->empty())
branch  0 never executed
branch  1 never executed
    #####: 1400:    OpBuilder(builder.getContext()).createBlock(region.get());
call    0 never executed
call    1 never executed
    #####: 1401:  result.addRegion(std::move(region));
call    0 never executed
        -: 1402:
        -: 1403:  // Parse the optional attribute list.
    #####: 1404:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1405:    return failure();
    #####: 1406:  return success();
        -: 1407:}
        -: 1408:
function _ZN4mlir3scf21PerformConcurrentlyOp15getParentResultEl called 0 returned 0% blocks executed 0%
    #####: 1409:OpResult PerformConcurrentlyOp::getParentResult(int64_t idx) {
    #####: 1410:  return getOperation()->getParentOp()->getResult(idx);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1411:}
        -: 1412:
function _ZN4mlir3scf21PerformConcurrentlyOp8getDestsEv called 0 returned 0% blocks executed 0%
    #####: 1413:SmallVector<BlockArgument> PerformConcurrentlyOp::getDests() {
    #####: 1414:  return llvm::to_vector<4>(
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZN4mlir3scf21PerformConcurrentlyOp8getDestsEvENKUlRNS_9OperationEE_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1415:      llvm::map_range(getYieldingOps(), [](Operation &op) {
call    0 never executed
        -: 1416:        // Add new ops here as needed.
    #####: 1417:        auto insertSliceOp = cast<tensor::ParallelInsertSliceOp>(&op);
call    0 never executed
    #####: 1418:        return insertSliceOp.getDest().cast<BlockArgument>();
call    0 never executed
call    1 never executed
    #####: 1419:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1420:}
        -: 1421:
function _ZN4mlir3scf21PerformConcurrentlyOp14getYieldingOpsEv called 0 returned 0% blocks executed 0%
    #####: 1422:llvm::iterator_range<Block::iterator> PerformConcurrentlyOp::getYieldingOps() {
    #####: 1423:  return getRegion().front().getOperations();
call    0 never executed
call    1 never executed
        -: 1424:}
        -: 1425:
        -: 1426://===----------------------------------------------------------------------===//
        -: 1427:// IfOp
        -: 1428://===----------------------------------------------------------------------===//
        -: 1429:
function _ZN4mlir3scf31insideMutuallyExclusiveBranchesEPNS_9OperationES2_ called 0 returned 0% blocks executed 0%
    #####: 1430:bool mlir::scf::insideMutuallyExclusiveBranches(Operation *a, Operation *b) {
    #####: 1431:  assert(a && "expected non-empty operation");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1432:  assert(b && "expected non-empty operation");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1433:
    #####: 1434:  IfOp ifOp = a->getParentOfType<IfOp>();
call    0 never executed
    #####: 1435:  while (ifOp) {
branch  0 never executed
branch  1 never executed
        -: 1436:    // Check if b is inside ifOp. (We already know that a is.)
    #####: 1437:    if (ifOp->isProperAncestor(b))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1438:      // b is contained in ifOp. a and b are in mutually exclusive branches if
        -: 1439:      // they are in different blocks of ifOp.
    #####: 1440:      return static_cast<bool>(ifOp.thenBlock()->findAncestorOpInBlock(*a)) !=
call    0 never executed
call    1 never executed
    #####: 1441:             static_cast<bool>(ifOp.thenBlock()->findAncestorOpInBlock(*b));
call    0 never executed
call    1 never executed
        -: 1442:    // Check next enclosing IfOp.
    #####: 1443:    ifOp = ifOp->getParentOfType<IfOp>();
call    0 never executed
        -: 1444:  }
        -: 1445:
        -: 1446:  // Could not find a common IfOp among a's and b's ancestors.
        -: 1447:  return false;
        -: 1448:}
        -: 1449:
function _ZN4mlir3scf4IfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEb called 4 returned 100% blocks executed 100%
        4: 1450:void IfOp::build(OpBuilder &builder, OperationState &result, Value cond,
        -: 1451:                 bool withElseRegion) {
        4: 1452:  build(builder, result, /*resultTypes=*/llvm::None, cond, withElseRegion);
call    0 returned 100%
call    1 returned 100%
        4: 1453:}
        -: 1454:
function _ZN4mlir3scf4IfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_5ValueEb called 2189 returned 100% blocks executed 100%
     2189: 1455:void IfOp::build(OpBuilder &builder, OperationState &result,
        -: 1456:                 TypeRange resultTypes, Value cond, bool withElseRegion) {
function _ZZN4mlir3scf4IfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_5ValueEbENKUlS3_NS_8LocationEE_clES3_S8_.isra.0 called 4375 returned 100% blocks executed 100%
     4375: 1457:  auto addTerminator = [&](OpBuilder &nested, Location loc) {
     4375: 1458:    if (resultTypes.empty())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        8: 1459:      IfOp::ensureTerminator(*nested.getInsertionBlock()->getParent(), nested,
call    0 returned 100%
call    1 returned 100%
        -: 1460:                             loc);
     6564: 1461:  };
        -: 1462:
     2189: 1463:  build(builder, result, resultTypes, cond, addTerminator,
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
        -: 1464:        withElseRegion ? addTerminator
        -: 1465:                       : function_ref<void(OpBuilder &, Location)>());
     2189: 1466:}
        -: 1467:
function _ZN4mlir3scf4IfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_9TypeRangeENS_5ValueEN4llvm12function_refIFvS3_NS_8LocationEEEESC_ called 5140 returned 100% blocks executed 87%
     5140: 1468:void IfOp::build(OpBuilder &builder, OperationState &result,
        -: 1469:                 TypeRange resultTypes, Value cond,
        -: 1470:                 function_ref<void(OpBuilder &, Location)> thenBuilder,
        -: 1471:                 function_ref<void(OpBuilder &, Location)> elseBuilder) {
    5140*: 1472:  assert(thenBuilder && "the builder callback for 'then' must be present");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1473:
     5140: 1474:  result.addOperands(cond);
call    0 returned 100%
call    1 returned 100%
     5140: 1475:  result.addTypes(resultTypes);
call    0 returned 100%
        -: 1476:
     8849: 1477:  OpBuilder::InsertionGuard guard(builder);
call    0 returned 100%
     5140: 1478:  Region *thenRegion = result.addRegion();
call    0 returned 100%
     5140: 1479:  builder.createBlock(thenRegion);
call    0 returned 100%
call    1 returned 100%
     5140: 1480:  thenBuilder(builder, result.location);
call    0 returned 100%
        -: 1481:
     5140: 1482:  Region *elseRegion = result.addRegion();
call    0 returned 100%
     5140: 1483:  if (!elseBuilder)
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
     2862: 1484:    return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1485:
     3709: 1486:  builder.createBlock(elseRegion);
call    0 returned 100%
call    1 returned 100%
     3709: 1487:  elseBuilder(builder, result.location);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1488:}
        -: 1489:
function _ZN4mlir3scf4IfOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm12function_refIFvS3_NS_8LocationEEEESB_ called 0 returned 0% blocks executed 0%
    #####: 1490:void IfOp::build(OpBuilder &builder, OperationState &result, Value cond,
        -: 1491:                 function_ref<void(OpBuilder &, Location)> thenBuilder,
        -: 1492:                 function_ref<void(OpBuilder &, Location)> elseBuilder) {
    #####: 1493:  build(builder, result, TypeRange(), cond, thenBuilder, elseBuilder);
call    0 never executed
call    1 never executed
    #####: 1494:}
        -: 1495:
function _ZN4mlir3scf4IfOp6verifyEv called 26829163 returned 100% blocks executed 50%
 26829163: 1496:LogicalResult IfOp::verify() {
 41479198: 1497:  if (getNumResults() != 0 && getElseRegion().empty())
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1498:    return emitOpError("must have an else block if defining values");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 26829163: 1499:  return success();
        -: 1500:}
        -: 1501:
function _ZN4mlir3scf4IfOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 636632 returned 100% blocks executed 84%
   636632: 1502:ParseResult IfOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 1503:  // Create the regions for 'then'.
   636632: 1504:  result.regions.reserve(2);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   636632: 1505:  Region *thenRegion = result.addRegion();
call    0 returned 100%
   636632: 1506:  Region *elseRegion = result.addRegion();
call    0 returned 100%
        -: 1507:
   636632: 1508:  auto &builder = parser.getBuilder();
call    0 returned 100%
   636632: 1509:  OpAsmParser::UnresolvedOperand cond;
call    0 returned 100%
   636632: 1510:  Type i1Type = builder.getIntegerType(1);
call    0 returned 100%
 1273264*: 1511:  if (parser.parseOperand(cond) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  636632*: 1512:      parser.resolveOperand(cond, i1Type, result.operands))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 1513:    return failure();
        -: 1514:  // Parse optional results type list.
   636632: 1515:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1516:    return failure();
        -: 1517:  // Parse the 'then' region.
   636632: 1518:  if (parser.parseRegion(*thenRegion, /*arguments=*/{}, /*argTypes=*/{}))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1519:    return failure();
   636632: 1520:  IfOp::ensureTerminator(*thenRegion, parser.getBuilder(), result.location);
call    0 returned 100%
call    1 returned 100%
        -: 1521:
        -: 1522:  // If we find an 'else' keyword then parse the 'else' region.
   636632: 1523:  if (!parser.parseOptionalKeyword("else")) {
call    0 returned 100%
branch  1 taken 72% (fallthrough)
branch  2 taken 28%
   459837: 1524:    if (parser.parseRegion(*elseRegion, /*arguments=*/{}, /*argTypes=*/{}))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1525:      return failure();
   459837: 1526:    IfOp::ensureTerminator(*elseRegion, parser.getBuilder(), result.location);
call    0 returned 100%
call    1 returned 100%
        -: 1527:  }
        -: 1528:
        -: 1529:  // Parse the optional attribute list.
   636632: 1530:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1531:    return failure();
   636632: 1532:  return success();
        -: 1533:}
        -: 1534:
function _ZN4mlir3scf4IfOp5printERNS_12OpAsmPrinterE called 981161 returned 100% blocks executed 100%
   981161: 1535:void IfOp::print(OpAsmPrinter &p) {
   981161: 1536:  bool printBlockTerminators = false;
        -: 1537:
  1962322: 1538:  p << " " << getCondition();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   981161: 1539:  if (!getResults().empty()) {
call    0 returned 100%
branch  1 taken 55% (fallthrough)
branch  2 taken 45%
  1613178: 1540:    p << " -> (" << getResultTypes() << ")";
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
call    4 returned 100%
        -: 1541:    // Print yield explicitly if the op defines values.
   537726: 1542:    printBlockTerminators = true;
        -: 1543:  }
   981161: 1544:  p << ' ';
call    0 returned 100%
   981161: 1545:  p.printRegion(getThenRegion(),
call    0 returned 100%
        -: 1546:                /*printEntryBlockArgs=*/false,
   981161: 1547:                /*printBlockTerminators=*/printBlockTerminators);
call    0 returned 100%
        -: 1548:
        -: 1549:  // Print the 'else' regions if it exists and has a block.
   981161: 1550:  auto &elseRegion = getElseRegion();
call    0 returned 100%
   981161: 1551:  if (!elseRegion.empty()) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
   723809: 1552:    p << " else ";
call    0 returned 100%
   723809: 1553:    p.printRegion(elseRegion,
        -: 1554:                  /*printEntryBlockArgs=*/false,
   723809: 1555:                  /*printBlockTerminators=*/printBlockTerminators);
call    0 returned 100%
        -: 1556:  }
        -: 1557:
   981161: 1558:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
   981161: 1559:}
        -: 1560:
        -: 1561:/// Given the region at `index`, or the parent operation if `index` is None,
        -: 1562:/// return the successor regions. These are the regions that may be selected
        -: 1563:/// during the flow of control. `operands` is a set of optional attributes that
        -: 1564:/// correspond to a constant value for each operand, or null if that operand is
        -: 1565:/// not a constant.
function _ZN4mlir3scf4IfOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 80535600 returned 100% blocks executed 89%
 80535600: 1566:void IfOp::getSuccessorRegions(Optional<unsigned> index,
        -: 1567:                               ArrayRef<Attribute> operands,
        -: 1568:                               SmallVectorImpl<RegionSuccessor> &regions) {
        -: 1569:  // The `then` and the `else` region branch back to the parent operation.
 80535600: 1570:  if (index) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
 53689356: 1571:    regions.push_back(RegionSuccessor(getResults()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
 53689359: 1572:    return;
        -: 1573:  }
        -: 1574:
        -: 1575:  // Don't consider the else region if it is empty.
 26846244: 1576:  Region *elseRegion = &this->getElseRegion();
call    0 returned 100%
 26846244: 1577:  if (elseRegion->empty())
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
  7515374: 1578:    elseRegion = nullptr;
        -: 1579:
        -: 1580:  // Otherwise, the successor is dependent on the condition.
 26846244: 1581:  bool condition;
 26849290: 1582:  if (auto condAttr = operands.front().dyn_cast_or_null<IntegerAttr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
     6092: 1583:    condition = condAttr.getValue().isOneValue();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1584:  } else {
        -: 1585:    // If the condition isn't constant, both regions may be executed.
 26843198: 1586:    regions.push_back(RegionSuccessor(&getThenRegion()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1587:    // If the else region does not exist, it is not a viable successor.
 26843202: 1588:    if (elseRegion)
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
 19328652: 1589:      regions.push_back(RegionSuccessor(elseRegion));
call    0 returned 100%
call    1 returned 100%
 26843202: 1590:    return;
        -: 1591:  }
        -: 1592:
        -: 1593:  // Add the successor regions using the condition.
     6092: 1594:  regions.push_back(RegionSuccessor(condition ? &getThenRegion() : elseRegion));
branch  0 taken 35%
branch  1 taken 65%
call    2 returned 100%
call    3 returned 100%
        -: 1595:}
        -: 1596:
function _ZN4mlir3scf4IfOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 281067 returned 100% blocks executed 32%
   281067: 1597:LogicalResult IfOp::fold(ArrayRef<Attribute> operands,
        -: 1598:                         SmallVectorImpl<OpFoldResult> &results) {
        -: 1599:  // if (!c) then A() else B() -> if c then B() else A()
   281067: 1600:  if (getElseRegion().empty())
call    0 returned 100%
branch  1 taken 21% (fallthrough)
branch  2 taken 79%
    58415: 1601:    return failure();
        -: 1602:
   222652: 1603:  arith::XOrIOp xorStmt = getCondition().getDefiningOp<arith::XOrIOp>();
call    0 returned 100%
call    1 returned 100%
   222652: 1604:  if (!xorStmt)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   222652: 1605:    return failure();
        -: 1606:
    #####: 1607:  if (!matchPattern(xorStmt.getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1608:    return failure();
        -: 1609:
    #####: 1610:  getConditionMutable().assign(xorStmt.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1611:  Block *thenBlock = &getThenRegion().front();
call    0 never executed
call    1 never executed
        -: 1612:  // It would be nicer to use iplist::swap, but that has no implemented
        -: 1613:  // callbacks See: https://llvm.org/doxygen/ilist_8h_source.html#l00224
    #####: 1614:  getThenRegion().getBlocks().splice(getThenRegion().getBlocks().begin(),
call    0 never executed
call    1 never executed
    #####: 1615:                                     getElseRegion().getBlocks());
call    0 never executed
    #####: 1616:  getElseRegion().getBlocks().splice(getElseRegion().getBlocks().begin(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1617:                                     getThenRegion().getBlocks(), thenBlock);
call    0 never executed
    #####: 1618:  return success();
        -: 1619:}
        -: 1620:
function _ZN4mlir3scf4IfOp25getRegionInvocationBoundsEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_16InvocationBoundsEEE called 2792 returned 100% blocks executed 94%
     2792: 1621:void IfOp::getRegionInvocationBounds(
        -: 1622:    ArrayRef<Attribute> operands,
        -: 1623:    SmallVectorImpl<InvocationBounds> &invocationBounds) {
     2792: 1624:  if (auto cond = operands[0].dyn_cast_or_null<BoolAttr>()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 91% (fallthrough)
branch  4 taken 9%
        -: 1625:    // If the condition is known, then one region is known to be executed once
        -: 1626:    // and the other zero times.
     4155: 1627:    invocationBounds.emplace_back(0, cond.getValue() ? 1 : 0);
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
call    3 returned 100%
     4155: 1628:    invocationBounds.emplace_back(0, cond.getValue() ? 0 : 1);
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
call    3 returned 100%
        -: 1629:  } else {
        -: 1630:    // Non-constant condition. Each region may be executed 0 or 1 times.
      245: 1631:    invocationBounds.assign(2, {0, 1});
call    0 returned 100%
        -: 1632:  }
     2792: 1633:}
        -: 1634:
        -: 1635:namespace {
        -: 1636:// Pattern to remove unused IfOp results.
        -: 1637:struct RemoveUnusedResults : public OpRewritePattern<IfOp> {
        -: 1638:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1639:
        -: 1640:  void transferBody(Block *source, Block *dest, ArrayRef<OpResult> usedResults,
        -: 1641:                    PatternRewriter &rewriter) const {
        -: 1642:    // Move all operations to the destination block.
        -: 1643:    rewriter.mergeBlocks(source, dest);
        -: 1644:    // Replace the yield op by one that returns only the used values.
        -: 1645:    auto yieldOp = cast<scf::YieldOp>(dest->getTerminator());
        -: 1646:    SmallVector<Value, 4> usedOperands;
        -: 1647:    llvm::transform(usedResults, std::back_inserter(usedOperands),
function _ZZNK12_GLOBAL__N_119RemoveUnusedResults12transferBodyEPN4mlir5BlockES3_N4llvm8ArrayRefINS1_8OpResultEEERNS1_15PatternRewriterEENKUlS6_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1648:                    [&](OpResult result) {
    #####: 1649:                      return yieldOp.getOperand(result.getResultNumber());
call    0 never executed
call    1 never executed
        -: 1650:                    });
        -: 1651:    rewriter.updateRootInPlace(yieldOp,
function _ZZNK12_GLOBAL__N_119RemoveUnusedResults12transferBodyEPN4mlir5BlockES3_N4llvm8ArrayRefINS1_8OpResultEEERNS1_15PatternRewriterEENKUlvE0_clEv.isra.0 called 158 returned 100% blocks executed 100%
      158: 1652:                               [&]() { yieldOp->setOperands(usedOperands); });
call    0 returned 100%
call    1 returned 100%
        -: 1653:  }
        -: 1654:
function _ZNK12_GLOBAL__N_119RemoveUnusedResults15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 543 returned 100% blocks executed 70%
      543: 1655:  LogicalResult matchAndRewrite(IfOp op,
        -: 1656:                                PatternRewriter &rewriter) const override {
        -: 1657:    // Compute the list of used results.
      543: 1658:    SmallVector<OpResult, 4> usedResults;
call    0 returned 100%
      543: 1659:    llvm::copy_if(op.getResults(), std::back_inserter(usedResults),
call    0 returned 100%
      543: 1660:                  [](OpResult result) { return !result.use_empty(); });
call    0 returned 100%
call    1 returned 100%
        -: 1661:
        -: 1662:    // Replace the operation if only a subset of its results have uses.
      543: 1663:    if (usedResults.size() == op.getNumResults())
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
      464: 1664:      return failure();
        -: 1665:
        -: 1666:    // Compute the result types of the replacement operation.
      622: 1667:    SmallVector<Type, 4> newTypes;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       79: 1668:    llvm::transform(usedResults, std::back_inserter(newTypes),
call    0 returned 100%
       79: 1669:                    [](OpResult result) { return result.getType(); });
call    0 returned 100%
        -: 1670:
        -: 1671:    // Create a replacement operation with empty then and else regions.
      237: 1672:    auto emptyBuilder = [](OpBuilder &, Location) {};
      158: 1673:    auto newOp = rewriter.create<IfOp>(op.getLoc(), newTypes, op.getCondition(),
       79: 1674:                                       emptyBuilder, emptyBuilder);
call    0 returned 100%
call    1 returned 100%
        -: 1675:
        -: 1676:    // Move the bodies and replace the terminators (note there is a then and
        -: 1677:    // an else region since the operation returns results).
       79: 1678:    transferBody(op.getBody(0), newOp.getBody(0), usedResults, rewriter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       79: 1679:    transferBody(op.getBody(1), newOp.getBody(1), usedResults, rewriter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1680:
        -: 1681:    // Replace the operation by the new one.
      158: 1682:    SmallVector<Value, 4> repResults(op.getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      79*: 1683:    for (const auto &en : llvm::enumerate(usedResults))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1684:      repResults[en.value().getResultNumber()] = newOp.getResult(en.index());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
       79: 1685:    rewriter.replaceOp(op, repResults);
call    0 returned 100%
call    1 returned 100%
       79: 1686:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1687:  }
        -: 1688:};
        -: 1689:
        -: 1690:struct RemoveStaticCondition : public OpRewritePattern<IfOp> {
        -: 1691:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1692:
function _ZNK12_GLOBAL__N_121RemoveStaticCondition15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 3402 returned 100% blocks executed 100%
     3402: 1693:  LogicalResult matchAndRewrite(IfOp op,
        -: 1694:                                PatternRewriter &rewriter) const override {
     3402: 1695:    BoolAttr condition;
     3402: 1696:    if (!matchPattern(op.getCondition(), m_Constant(&condition)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 16% (fallthrough)
branch  3 taken 84%
      543: 1697:      return failure();
        -: 1698:
     2859: 1699:    if (condition.getValue())
call    0 returned 100%
branch  1 taken 34% (fallthrough)
branch  2 taken 66%
      982: 1700:      replaceOpWithRegion(rewriter, op, op.getThenRegion());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1877: 1701:    else if (!op.getElseRegion().empty())
call    0 returned 100%
branch  1 taken 82% (fallthrough)
branch  2 taken 18%
     1534: 1702:      replaceOpWithRegion(rewriter, op, op.getElseRegion());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1703:    else
      343: 1704:      rewriter.eraseOp(op);
call    0 returned 100%
        -: 1705:
     2859: 1706:    return success();
        -: 1707:  }
        -: 1708:};
        -: 1709:
        -: 1710:/// Hoist any yielded results whose operands are defined outside
        -: 1711:/// the if, to a select instruction.
        -: 1712:struct ConvertTrivialIfToSelect : public OpRewritePattern<IfOp> {
        -: 1713:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1714:
function _ZNK12_GLOBAL__N_124ConvertTrivialIfToSelect15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 5043 returned 100% blocks executed 81%
     5043: 1715:  LogicalResult matchAndRewrite(IfOp op,
        -: 1716:                                PatternRewriter &rewriter) const override {
     5043: 1717:    if (op->getNumResults() == 0)
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
     3083: 1718:      return failure();
        -: 1719:
     1960: 1720:    auto cond = op.getCondition();
call    0 returned 100%
     1960: 1721:    auto thenYieldArgs = op.thenYield().getOperands();
call    0 returned 100%
call    1 returned 100%
     1960: 1722:    auto elseYieldArgs = op.elseYield().getOperands();
call    0 returned 100%
call    1 returned 100%
        -: 1723:
     1960: 1724:    SmallVector<Type> nonHoistable;
     1960: 1725:    for (const auto &it :
     5880: 1726:         llvm::enumerate(llvm::zip(thenYieldArgs, elseYieldArgs))) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1960: 1727:      Value trueVal = std::get<0>(it.value());
call    0 returned 100%
     1960: 1728:      Value falseVal = std::get<1>(it.value());
call    0 returned 100%
     3395: 1729:      if (&op.getThenRegion() == trueVal.getParentRegion() ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 73% (fallthrough)
branch  3 taken 27%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
     1435: 1730:          &op.getElseRegion() == falseVal.getParentRegion())
call    0 returned 100%
      532: 1731:        nonHoistable.push_back(trueVal.getType());
call    0 returned 100%
        -: 1732:    }
        -: 1733:    // Early exit if there aren't any yielded values we can
        -: 1734:    // hoist outside the if.
     1960: 1735:    if (nonHoistable.size() == op->getNumResults())
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      532: 1736:      return failure();
        -: 1737:
     1428: 1738:    IfOp replacement = rewriter.create<IfOp>(op.getLoc(), nonHoistable, cond);
call    0 returned 100%
     1428: 1739:    if (replacement.thenBlock())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1428: 1740:      rewriter.eraseBlock(replacement.thenBlock());
call    0 returned 100%
     1428: 1741:    replacement.getThenRegion().takeBody(op.getThenRegion());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1428: 1742:    replacement.getElseRegion().takeBody(op.getElseRegion());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1743:
     3388: 1744:    SmallVector<Value> results(op->getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    1428*: 1745:    assert(thenYieldArgs.size() == results.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    1428*: 1746:    assert(elseYieldArgs.size() == results.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1747:
     2856: 1748:    SmallVector<Value> trueYields;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1428: 1749:    SmallVector<Value> falseYields;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1428: 1750:    rewriter.setInsertionPoint(replacement);
call    0 returned 100%
     1428: 1751:    for (const auto &it :
     4284: 1752:         llvm::enumerate(llvm::zip(thenYieldArgs, elseYieldArgs))) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1428: 1753:      Value trueVal = std::get<0>(it.value());
call    0 returned 100%
     1428: 1754:      Value falseVal = std::get<1>(it.value());
call    0 returned 100%
     2856: 1755:      if (&replacement.getThenRegion() == trueVal.getParentRegion() ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     1428: 1756:          &replacement.getElseRegion() == falseVal.getParentRegion()) {
call    0 returned 100%
    #####: 1757:        results[it.index()] = replacement.getResult(trueYields.size());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1758:        trueYields.push_back(trueVal);
call    0 never executed
    #####: 1759:        falseYields.push_back(falseVal);
call    0 never executed
     1428: 1760:      } else if (trueVal == falseVal)
branch  0 taken 60%
branch  1 taken 40%
      850: 1761:        results[it.index()] = trueVal;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1762:      else
      578: 1763:        results[it.index()] = rewriter.create<arith::SelectOp>(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      578: 1764:            op.getLoc(), cond, trueVal, falseVal);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1765:    }
        -: 1766:
     1428: 1767:    rewriter.setInsertionPointToEnd(replacement.thenBlock());
call    0 returned 100%
call    1 returned 100%
     1428: 1768:    rewriter.replaceOpWithNewOp<YieldOp>(replacement.thenYield(), trueYields);
call    0 returned 100%
call    1 returned 100%
        -: 1769:
     1428: 1770:    rewriter.setInsertionPointToEnd(replacement.elseBlock());
call    0 returned 100%
call    1 returned 100%
     1428: 1771:    rewriter.replaceOpWithNewOp<YieldOp>(replacement.elseYield(), falseYields);
call    0 returned 100%
call    1 returned 100%
        -: 1772:
     1428: 1773:    rewriter.replaceOp(op, results);
call    0 returned 100%
call    1 returned 100%
     1428: 1774:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1775:  }
        -: 1776:};
        -: 1777:
        -: 1778:/// Allow the true region of an if to assume the condition is true
        -: 1779:/// and vice versa. For example:
        -: 1780:///
        -: 1781:///   scf.if %cmp {
        -: 1782:///      print(%cmp)
        -: 1783:///   }
        -: 1784:///
        -: 1785:///  becomes
        -: 1786:///
        -: 1787:///   scf.if %cmp {
        -: 1788:///      print(true)
        -: 1789:///   }
        -: 1790:///
        -: 1791:struct ConditionPropagation : public OpRewritePattern<IfOp> {
        -: 1792:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1793:
function _ZNK12_GLOBAL__N_120ConditionPropagation15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 5090 returned 100% blocks executed 95%
     5090: 1794:  LogicalResult matchAndRewrite(IfOp op,
        -: 1795:                                PatternRewriter &rewriter) const override {
        -: 1796:    // Early exit if the condition is constant since replacing a constant
        -: 1797:    // in the body with another constant isn't a simplification.
     5090: 1798:    if (matchPattern(op.getCondition(), m_Constant()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 85% (fallthrough)
branch  3 taken 15%
     4320: 1799:      return failure();
        -: 1800:
      770: 1801:    bool changed = false;
      770: 1802:    mlir::Type i1Ty = rewriter.getI1Type();
call    0 returned 100%
        -: 1803:
        -: 1804:    // These variables serve to prevent creating duplicate constants
        -: 1805:    // and hold constant true or false values.
      770: 1806:    Value constantTrue = nullptr;
      770: 1807:    Value constantFalse = nullptr;
        -: 1808:
    19743: 1809:    for (OpOperand &use :
    19743: 1810:         llvm::make_early_inc_range(op.getCondition().getUses())) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 96% (fallthrough)
branch  4 taken 4%
call    5 returned 100%
    37946: 1811:      if (op.getThenRegion().isAncestor(use.getOwner()->getParentRegion())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
       60: 1812:        changed = true;
        -: 1813:
       60: 1814:        if (!constantTrue)
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
       32: 1815:          constantTrue = rewriter.create<arith::ConstantOp>(
       32: 1816:              op.getLoc(), i1Ty, rewriter.getIntegerAttr(i1Ty, 1));
call    0 returned 100%
call    1 returned 100%
        -: 1817:
       60: 1818:        rewriter.updateRootInPlace(use.getOwner(),
call    0 returned 100%
      120: 1819:                                   [&]() { use.set(constantTrue); });
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
    56799: 1820:      } else if (op.getElseRegion().isAncestor(
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -: 1821:                     use.getOwner()->getParentRegion())) {
       21: 1822:        changed = true;
        -: 1823:
       21: 1824:        if (!constantFalse)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       18: 1825:          constantFalse = rewriter.create<arith::ConstantOp>(
       18: 1826:              op.getLoc(), i1Ty, rewriter.getIntegerAttr(i1Ty, 0));
call    0 returned 100%
call    1 returned 100%
        -: 1827:
       21: 1828:        rewriter.updateRootInPlace(use.getOwner(),
call    0 returned 100%
       42: 1829:                                   [&]() { use.set(constantFalse); });
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 1830:      }
        -: 1831:    }
        -: 1832:
      770: 1833:    return success(changed);
        -: 1834:  }
        -: 1835:};
        -: 1836:
        -: 1837:/// Remove any statements from an if that are equivalent to the condition
        -: 1838:/// or its negation. For example:
        -: 1839:///
        -: 1840:///    %res:2 = scf.if %cmp {
        -: 1841:///       yield something(), true
        -: 1842:///    } else {
        -: 1843:///       yield something2(), false
        -: 1844:///    }
        -: 1845:///    print(%res#1)
        -: 1846:///
        -: 1847:///  becomes
        -: 1848:///    %res = scf.if %cmp {
        -: 1849:///       yield something()
        -: 1850:///    } else {
        -: 1851:///       yield something2()
        -: 1852:///    }
        -: 1853:///    print(%cmp)
        -: 1854:///
        -: 1855:/// Additionally if both branches yield the same value, replace all uses
        -: 1856:/// of the result with the yielded value.
        -: 1857:///
        -: 1858:///    %res:2 = scf.if %cmp {
        -: 1859:///       yield something(), %arg1
        -: 1860:///    } else {
        -: 1861:///       yield something2(), %arg1
        -: 1862:///    }
        -: 1863:///    print(%res#1)
        -: 1864:///
        -: 1865:///  becomes
        -: 1866:///    %res = scf.if %cmp {
        -: 1867:///       yield something()
        -: 1868:///    } else {
        -: 1869:///       yield something2()
        -: 1870:///    }
        -: 1871:///    print(%arg1)
        -: 1872:///
        -: 1873:struct ReplaceIfYieldWithConditionOrValue : public OpRewritePattern<IfOp> {
        -: 1874:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1875:
function _ZNK12_GLOBAL__N_134ReplaceIfYieldWithConditionOrValue15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 464 returned 100% blocks executed 50%
      464: 1876:  LogicalResult matchAndRewrite(IfOp op,
        -: 1877:                                PatternRewriter &rewriter) const override {
        -: 1878:    // Early exit if there are no results that could be replaced.
      464: 1879:    if (op.getNumResults() == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
      462: 1880:      return failure();
        -: 1881:
        2: 1882:    auto trueYield =
call    0 returned 100%
        2: 1883:        cast<scf::YieldOp>(op.getThenRegion().back().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        2: 1884:    auto falseYield =
call    0 returned 100%
        2: 1885:        cast<scf::YieldOp>(op.getElseRegion().back().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1886:
        2: 1887:    rewriter.setInsertionPoint(op->getBlock(),
        2: 1888:                               op.getOperation()->getIterator());
call    0 returned 100%
        2: 1889:    bool changed = false;
        2: 1890:    Type i1Ty = rewriter.getI1Type();
call    0 returned 100%
        6: 1891:    for (auto [trueResult, falseResult, opResult] :
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        2: 1892:         llvm::zip(trueYield.getResults(), falseYield.getResults(),
call    0 returned 100%
        8: 1893:                   op.getResults())) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
       2*: 1894:      if (trueResult == falseResult) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1895:        if (!opResult.use_empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1896:          opResult.replaceAllUsesWith(trueResult);
call    0 never executed
    #####: 1897:          changed = true;
        -: 1898:        }
       2*: 1899:        continue;
        -: 1900:      }
        -: 1901:
        2: 1902:      BoolAttr trueYield, falseYield;
       2*: 1903:      if (!matchPattern(trueResult, m_Constant(&trueYield)) ||
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
    #####: 1904:          !matchPattern(falseResult, m_Constant(&falseYield)))
call    0 never executed
        2: 1905:        continue;
        -: 1906:
    #####: 1907:      bool trueVal = trueYield.getValue();
call    0 never executed
    #####: 1908:      bool falseVal = falseYield.getValue();
call    0 never executed
    #####: 1909:      if (!trueVal && falseVal) {
branch  0 never executed
branch  1 never executed
    #####: 1910:        if (!opResult.use_empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1911:          Dialect *constDialect = trueResult.getDefiningOp()->getDialect();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1912:          Value notCond = rewriter.create<arith::XOrIOp>(
    #####: 1913:              op.getLoc(), op.getCondition(),
call    0 never executed
        -: 1914:              constDialect
        -: 1915:                  ->materializeConstant(rewriter,
    #####: 1916:                                        rewriter.getIntegerAttr(i1Ty, 1), i1Ty,
call    0 never executed
    #####: 1917:                                        op.getLoc())
    #####: 1918:                  ->getResult(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1919:          opResult.replaceAllUsesWith(notCond);
call    0 never executed
    #####: 1920:          changed = true;
        -: 1921:        }
        -: 1922:      }
    #####: 1923:      if (trueVal && !falseVal) {
branch  0 never executed
branch  1 never executed
    #####: 1924:        if (!opResult.use_empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1925:          opResult.replaceAllUsesWith(op.getCondition());
call    0 never executed
call    1 never executed
    #####: 1926:          changed = true;
        -: 1927:        }
        -: 1928:      }
        -: 1929:    }
        2: 1930:    return success(changed);
        -: 1931:  }
        -: 1932:};
        -: 1933:
        -: 1934:/// Merge any consecutive scf.if's with the same condition.
        -: 1935:///
        -: 1936:///    scf.if %cond {
        -: 1937:///       firstCodeTrue();...
        -: 1938:///    } else {
        -: 1939:///       firstCodeFalse();...
        -: 1940:///    }
        -: 1941:///    %res = scf.if %cond {
        -: 1942:///       secondCodeTrue();...
        -: 1943:///    } else {
        -: 1944:///       secondCodeFalse();...
        -: 1945:///    }
        -: 1946:///
        -: 1947:///  becomes
        -: 1948:///    %res = scf.if %cmp {
        -: 1949:///       firstCodeTrue();...
        -: 1950:///       secondCodeTrue();...
        -: 1951:///    } else {
        -: 1952:///       firstCodeFalse();...
        -: 1953:///       secondCodeFalse();...
        -: 1954:///    }
        -: 1955:struct CombineIfs : public OpRewritePattern<IfOp> {
        -: 1956:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 1957:
function _ZNK12_GLOBAL__N_110CombineIfs15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 5093 returned 100% blocks executed 60%
     5093: 1958:  LogicalResult matchAndRewrite(IfOp nextIf,
        -: 1959:                                PatternRewriter &rewriter) const override {
     5093: 1960:    Block *parent = nextIf->getBlock();
call    0 returned 100%
     5093: 1961:    if (nextIf == &parent->front())
call    0 returned 100%
branch  1 taken 23% (fallthrough)
branch  2 taken 77%
     1165: 1962:      return failure();
        -: 1963:
     7856: 1964:    auto prevIf = dyn_cast<IfOp>(nextIf->getPrevNode());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     3928: 1965:    if (!prevIf)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3915: 1966:      return failure();
        -: 1967:
        -: 1968:    // Determine the logical then/else blocks when prevIf's
        -: 1969:    // condition is used. Null means the block does not exist
        -: 1970:    // in that case (e.g. empty else). If neither of these
        -: 1971:    // are set, the two conditions cannot be compared.
       13: 1972:    Block *nextThen = nullptr;
       13: 1973:    Block *nextElse = nullptr;
       13: 1974:    if (nextIf.getCondition() == prevIf.getCondition()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 23% (fallthrough)
branch  3 taken 77%
        3: 1975:      nextThen = nextIf.thenBlock();
call    0 returned 100%
        3: 1976:      if (!nextIf.getElseRegion().empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3: 1977:        nextElse = nextIf.elseBlock();
call    0 returned 100%
        -: 1978:    }
       13: 1979:    if (arith::XOrIOp notv =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       13: 1980:            nextIf.getCondition().getDefiningOp<arith::XOrIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1981:      if (notv.getLhs() == prevIf.getCondition() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1982:          matchPattern(notv.getRhs(), m_One())) {
call    0 never executed
call    1 never executed
    #####: 1983:        nextElse = nextIf.thenBlock();
call    0 never executed
    #####: 1984:        if (!nextIf.getElseRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1985:          nextThen = nextIf.elseBlock();
call    0 never executed
        -: 1986:      }
        -: 1987:    }
       13: 1988:    if (arith::XOrIOp notv =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       13: 1989:            prevIf.getCondition().getDefiningOp<arith::XOrIOp>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1990:      if (notv.getLhs() == nextIf.getCondition() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1991:          matchPattern(notv.getRhs(), m_One())) {
call    0 never executed
call    1 never executed
    #####: 1992:        nextElse = nextIf.thenBlock();
call    0 never executed
    #####: 1993:        if (!nextIf.getElseRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1994:          nextThen = nextIf.elseBlock();
call    0 never executed
        -: 1995:      }
        -: 1996:    }
        -: 1997:
       13: 1998:    if (!nextThen && !nextElse)
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
       10: 1999:      return failure();
        -: 2000:
        3: 2001:    SmallVector<Value> prevElseYielded;
call    0 returned 100%
        3: 2002:    if (!prevIf.getElseRegion().empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3: 2003:      prevElseYielded = prevIf.elseYield().getOperands();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 2004:    // Replace all uses of return values of op within nextIf with the
        -: 2005:    // corresponding yields
    #####: 2006:    for (auto it : llvm::zip(prevIf.getResults(),
       3*: 2007:                             prevIf.thenYield().getOperands(), prevElseYielded))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2008:      for (OpOperand &use :
    #####: 2009:           llvm::make_early_inc_range(std::get<0>(it).getUses())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 2010:        if (nextThen && nextThen->getParent()->isAncestor(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2011:                            use.getOwner()->getParentRegion())) {
    #####: 2012:          rewriter.startRootUpdate(use.getOwner());
call    0 never executed
    #####: 2013:          use.set(std::get<1>(it));
branch  0 never executed
branch  1 never executed
    #####: 2014:          rewriter.finalizeRootUpdate(use.getOwner());
call    0 never executed
    #####: 2015:        } else if (nextElse && nextElse->getParent()->isAncestor(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 2016:                                   use.getOwner()->getParentRegion())) {
    #####: 2017:          rewriter.startRootUpdate(use.getOwner());
call    0 never executed
    #####: 2018:          use.set(std::get<2>(it));
branch  0 never executed
branch  1 never executed
    #####: 2019:          rewriter.finalizeRootUpdate(use.getOwner());
call    0 never executed
        -: 2020:        }
        -: 2021:      }
        -: 2022:
        9: 2023:    SmallVector<Type> mergedTypes(prevIf.getResultTypes());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        6: 2024:    llvm::append_range(mergedTypes, nextIf.getResultTypes());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 2025:
        3: 2026:    IfOp combinedIf = rewriter.create<IfOp>(
        3: 2027:        nextIf.getLoc(), mergedTypes, prevIf.getCondition(), /*hasElse=*/false);
call    0 returned 100%
call    1 returned 100%
        3: 2028:    rewriter.eraseBlock(&combinedIf.getThenRegion().back());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2029:
        3: 2030:    rewriter.inlineRegionBefore(prevIf.getThenRegion(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2031:                                combinedIf.getThenRegion(),
        3: 2032:                                combinedIf.getThenRegion().begin());
call    0 returned 100%
call    1 returned 100%
        -: 2033:
        3: 2034:    if (nextThen) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 2035:      YieldOp thenYield = combinedIf.thenYield();
call    0 returned 100%
        3: 2036:      YieldOp thenYield2 = cast<YieldOp>(nextThen->getTerminator());
call    0 returned 100%
call    1 returned 100%
        3: 2037:      rewriter.mergeBlocks(nextThen, combinedIf.thenBlock());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        3: 2038:      rewriter.setInsertionPointToEnd(combinedIf.thenBlock());
call    0 returned 100%
call    1 returned 100%
        -: 2039:
        6: 2040:      SmallVector<Value> mergedYields(thenYield.getOperands());
call    0 returned 100%
call    1 returned 100%
        3: 2041:      llvm::append_range(mergedYields, thenYield2.getOperands());
call    0 returned 100%
call    1 returned 100%
        3: 2042:      rewriter.create<YieldOp>(thenYield2.getLoc(), mergedYields);
call    0 returned 100%
        3: 2043:      rewriter.eraseOp(thenYield);
call    0 returned 100%
        3: 2044:      rewriter.eraseOp(thenYield2);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2045:    }
        -: 2046:
        3: 2047:    rewriter.inlineRegionBefore(prevIf.getElseRegion(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2048:                                combinedIf.getElseRegion(),
        3: 2049:                                combinedIf.getElseRegion().begin());
call    0 returned 100%
call    1 returned 100%
        -: 2050:
        3: 2051:    if (nextElse) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 2052:      if (combinedIf.getElseRegion().empty()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2053:        rewriter.inlineRegionBefore(*nextElse->getParent(),
call    0 never executed
call    1 never executed
        -: 2054:                                    combinedIf.getElseRegion(),
    #####: 2055:                                    combinedIf.getElseRegion().begin());
call    0 never executed
        -: 2056:      } else {
        3: 2057:        YieldOp elseYield = combinedIf.elseYield();
call    0 returned 100%
        3: 2058:        YieldOp elseYield2 = cast<YieldOp>(nextElse->getTerminator());
call    0 returned 100%
call    1 returned 100%
        3: 2059:        rewriter.mergeBlocks(nextElse, combinedIf.elseBlock());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2060:
        3: 2061:        rewriter.setInsertionPointToEnd(combinedIf.elseBlock());
call    0 returned 100%
call    1 returned 100%
        -: 2062:
        6: 2063:        SmallVector<Value> mergedElseYields(elseYield.getOperands());
call    0 returned 100%
call    1 returned 100%
        3: 2064:        llvm::append_range(mergedElseYields, elseYield2.getOperands());
call    0 returned 100%
call    1 returned 100%
        -: 2065:
        3: 2066:        rewriter.create<YieldOp>(elseYield2.getLoc(), mergedElseYields);
call    0 returned 100%
        3: 2067:        rewriter.eraseOp(elseYield);
call    0 returned 100%
        3: 2068:        rewriter.eraseOp(elseYield2);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2069:      }
        -: 2070:    }
        -: 2071:
        6: 2072:    SmallVector<Value> prevValues;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        3: 2073:    SmallVector<Value> nextValues;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        9: 2074:    for (const auto &pair : llvm::enumerate(combinedIf.getResults())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 100%
call    5 returned 100%
        3: 2075:      if (pair.index() < prevIf.getNumResults())
branch  0 taken 0%
branch  1 taken 100%
    #####: 2076:        prevValues.push_back(pair.value());
call    0 never executed
call    1 never executed
        -: 2077:      else
        3: 2078:        nextValues.push_back(pair.value());
call    0 returned 100%
call    1 returned 100%
        -: 2079:    }
        3: 2080:    rewriter.replaceOp(prevIf, prevValues);
call    0 returned 100%
call    1 returned 100%
        3: 2081:    rewriter.replaceOp(nextIf, nextValues);
call    0 returned 100%
call    1 returned 100%
        3: 2082:    return success();
branch  0 taken 0%
branch  1 taken 100%
        -: 2083:  }
        -: 2084:};
        -: 2085:
        -: 2086:/// Pattern to remove an empty else branch.
        -: 2087:struct RemoveEmptyElseBranch : public OpRewritePattern<IfOp> {
        -: 2088:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 2089:
function _ZNK12_GLOBAL__N_121RemoveEmptyElseBranch15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 3615 returned 100% blocks executed 100%
     3615: 2090:  LogicalResult matchAndRewrite(IfOp ifOp,
        -: 2091:                                PatternRewriter &rewriter) const override {
        -: 2092:    // Cannot remove else region when there are operation results.
     3615: 2093:    if (ifOp.getNumResults())
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
      532: 2094:      return failure();
     3083: 2095:    Block *elseBlock = ifOp.elseBlock();
call    0 returned 100%
     3083: 2096:    if (!elseBlock || !llvm::hasSingleElement(*elseBlock))
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
     2870: 2097:      return failure();
      213: 2098:    auto newIfOp = rewriter.cloneWithoutRegions(ifOp);
call    0 returned 100%
      213: 2099:    rewriter.inlineRegionBefore(ifOp.getThenRegion(), newIfOp.getThenRegion(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      213: 2100:                                newIfOp.getThenRegion().begin());
call    0 returned 100%
call    1 returned 100%
      213: 2101:    rewriter.eraseOp(ifOp);
call    0 returned 100%
      213: 2102:    return success();
        -: 2103:  }
        -: 2104:};
        -: 2105:
        -: 2106:/// Convert nested `if`s into `arith.andi` + single `if`.
        -: 2107:///
        -: 2108:///    scf.if %arg0 {
        -: 2109:///      scf.if %arg1 {
        -: 2110:///        ...
        -: 2111:///        scf.yield
        -: 2112:///      }
        -: 2113:///      scf.yield
        -: 2114:///    }
        -: 2115:///  becomes
        -: 2116:///
        -: 2117:///    %0 = arith.andi %arg0, %arg1
        -: 2118:///    scf.if %0 {
        -: 2119:///      ...
        -: 2120:///      scf.yield
        -: 2121:///    }
        -: 2122:struct CombineNestedIfs : public OpRewritePattern<IfOp> {
        -: 2123:  using OpRewritePattern<IfOp>::OpRewritePattern;
        -: 2124:
function _ZNK12_GLOBAL__N_116CombineNestedIfs15matchAndRewriteEN4mlir3scf4IfOpERNS1_15PatternRewriterE called 5090 returned 100% blocks executed 16%
     5090: 2125:  LogicalResult matchAndRewrite(IfOp op,
        -: 2126:                                PatternRewriter &rewriter) const override {
     5090: 2127:    auto nestedOps = op.thenBlock()->without_terminator();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2128:    // Nested `if` must be the only op in block.
     5090: 2129:    if (!llvm::hasSingleElement(nestedOps))
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
     4646: 2130:      return failure();
        -: 2131:
        -: 2132:    // If there is an else block, it can only yield
      444: 2133:    if (op.elseBlock() && !llvm::hasSingleElement(*op.elseBlock()))
call    0 returned 100%
branch  1 taken 63%
branch  2 taken 37%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
      160: 2134:      return failure();
        -: 2135:
      284: 2136:    auto nestedIf = dyn_cast<IfOp>(*nestedOps.begin());
call    0 returned 100%
call    1 returned 100%
      284: 2137:    if (!nestedIf)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      284: 2138:      return failure();
        -: 2139:
    #####: 2140:    if (nestedIf.elseBlock() && !llvm::hasSingleElement(*nestedIf.elseBlock()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2141:      return failure();
        -: 2142:
    #####: 2143:    SmallVector<Value> thenYield(op.thenYield().getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2144:    SmallVector<Value> elseYield;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2145:    if (op.elseBlock())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2146:      llvm::append_range(elseYield, op.elseYield().getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2147:
        -: 2148:    // A list of indices for which we should upgrade the value yielded
        -: 2149:    // in the else to a select.
    #####: 2150:    SmallVector<unsigned> elseYieldsToUpgradeToSelect;
branch  0 never executed
branch  1 never executed
        -: 2151:
        -: 2152:    // If the outer scf.if yields a value produced by the inner scf.if,
        -: 2153:    // only permit combining if the value yielded when the condition
        -: 2154:    // is false in the outer scf.if is the same value yielded when the
        -: 2155:    // inner scf.if condition is false.
        -: 2156:    // Note that the array access to elseYield will not go out of bounds
        -: 2157:    // since it must have the same length as thenYield, since they both
        -: 2158:    // come from the same scf.if.
    #####: 2159:    for (const auto &tup : llvm::enumerate(thenYield)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2160:      if (tup.value().getDefiningOp() == nestedIf) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2161:        auto nestedIdx = tup.value().cast<OpResult>().getResultNumber();
call    0 never executed
call    1 never executed
    #####: 2162:        if (nestedIf.elseYield().getOperand(nestedIdx) !=
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2163:            elseYield[tup.index()]) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2164:          return failure();
        -: 2165:        }
        -: 2166:        // If the correctness test passes, we will yield
        -: 2167:        // corresponding value from the inner scf.if
    #####: 2168:        thenYield[tup.index()] = nestedIf.thenYield().getOperand(nestedIdx);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2169:        continue;
        -: 2170:      }
        -: 2171:
        -: 2172:      // Otherwise, we need to ensure the else block of the combined
        -: 2173:      // condition still returns the same value when the outer condition is
        -: 2174:      // true and the inner condition is false. This can be accomplished if
        -: 2175:      // the then value is defined outside the outer scf.if and we replace the
        -: 2176:      // value with a select that considers just the outer condition. Since
        -: 2177:      // the else region contains just the yield, its yielded value is
        -: 2178:      // defined outside the scf.if, by definition.
        -: 2179:
        -: 2180:      // If the then value is defined within the scf.if, bail.
    #####: 2181:      if (tup.value().getParentRegion() == &op.getThenRegion()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2182:        return failure();
        -: 2183:      }
    #####: 2184:      elseYieldsToUpgradeToSelect.push_back(tup.index());
call    0 never executed
        -: 2185:    }
        -: 2186:
    #####: 2187:    Location loc = op.getLoc();
call    0 never executed
    #####: 2188:    Value newCondition = rewriter.create<arith::AndIOp>(
    #####: 2189:        loc, op.getCondition(), nestedIf.getCondition());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2190:    auto newIf = rewriter.create<IfOp>(loc, op.getResultTypes(), newCondition);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2191:
    #####: 2192:    SmallVector<Value> results;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2193:    llvm::append_range(results, newIf.getResults());
call    0 never executed
call    1 never executed
    #####: 2194:    rewriter.setInsertionPoint(newIf);
call    0 never executed
        -: 2195:
    #####: 2196:    for (auto idx : elseYieldsToUpgradeToSelect)
branch  0 never executed
branch  1 never executed
    #####: 2197:      results[idx] = rewriter.create<arith::SelectOp>(
branch  0 never executed
branch  1 never executed
    #####: 2198:          op.getLoc(), op.getCondition(), thenYield[idx], elseYield[idx]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
        -: 2199:
    #####: 2200:    Block *newIfBlock = newIf.thenBlock();
call    0 never executed
    #####: 2201:    if (newIfBlock)
branch  0 never executed
branch  1 never executed
    #####: 2202:      rewriter.eraseOp(newIfBlock->getTerminator());
call    0 never executed
call    1 never executed
        -: 2203:    else
    #####: 2204:      newIfBlock = rewriter.createBlock(&newIf.getThenRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2205:    rewriter.mergeBlocks(nestedIf.thenBlock(), newIfBlock);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2206:    rewriter.setInsertionPointToEnd(newIf.thenBlock());
call    0 never executed
call    1 never executed
    #####: 2207:    rewriter.replaceOpWithNewOp<YieldOp>(newIf.thenYield(), thenYield);
call    0 never executed
call    1 never executed
    #####: 2208:    if (!elseYield.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2209:      rewriter.createBlock(&newIf.getElseRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2210:      rewriter.setInsertionPointToEnd(newIf.elseBlock());
call    0 never executed
call    1 never executed
    #####: 2211:      rewriter.create<YieldOp>(loc, elseYield);
call    0 never executed
        -: 2212:    }
    #####: 2213:    rewriter.replaceOp(op, results);
call    0 never executed
call    1 never executed
    #####: 2214:    return success();
branch  0 never executed
branch  1 never executed
        -: 2215:  }
        -: 2216:};
        -: 2217:
        -: 2218:} // namespace
        -: 2219:
function _ZN4mlir3scf4IfOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 2220:void IfOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2221:                                       MLIRContext *context) {
     1235: 2222:  results.add<CombineIfs, CombineNestedIfs, ConditionPropagation,
        -: 2223:              ConvertTrivialIfToSelect, RemoveEmptyElseBranch,
        -: 2224:              RemoveStaticCondition, RemoveUnusedResults,
     1235: 2225:              ReplaceIfYieldWithConditionOrValue>(context);
call    0 returned 100%
     1235: 2226:}
        -: 2227:
function _ZN4mlir3scf4IfOp9thenBlockEv called 11349 returned 100% blocks executed 100%
    11349: 2228:Block *IfOp::thenBlock() { return &getThenRegion().back(); }
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir3scf4IfOp9thenYieldEv called 3394 returned 100% blocks executed 100%
     3394: 2229:YieldOp IfOp::thenYield() { return cast<YieldOp>(&thenBlock()->back()); }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function _ZN4mlir3scf4IfOp9elseBlockEv called 8358 returned 100% blocks executed 100%
     8358: 2230:Block *IfOp::elseBlock() {
     8358: 2231:  Region &r = getElseRegion();
call    0 returned 100%
     8358: 2232:  if (r.empty())
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
        -: 2233:    return nullptr;
     7286: 2234:  return &r.back();
call    0 returned 100%
        -: 2235:}
function _ZN4mlir3scf4IfOp9elseYieldEv called 3394 returned 100% blocks executed 100%
     3394: 2236:YieldOp IfOp::elseYield() { return cast<YieldOp>(&elseBlock()->back()); }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2237:
        -: 2238://===----------------------------------------------------------------------===//
        -: 2239:// ParallelOp
        -: 2240://===----------------------------------------------------------------------===//
        -: 2241:
function _ZN4mlir3scf10ParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeES6_S6_S6_N4llvm12function_refIFvS3_NS_8LocationES6_S6_EEE called 1048 returned 100% blocks executed 88%
     1048: 2242:void ParallelOp::build(
        -: 2243:    OpBuilder &builder, OperationState &result, ValueRange lowerBounds,
        -: 2244:    ValueRange upperBounds, ValueRange steps, ValueRange initVals,
        -: 2245:    function_ref<void(OpBuilder &, Location, ValueRange, ValueRange)>
        -: 2246:        bodyBuilderFn) {
     1048: 2247:  result.addOperands(lowerBounds);
call    0 returned 100%
     1048: 2248:  result.addOperands(upperBounds);
call    0 returned 100%
     1048: 2249:  result.addOperands(steps);
call    0 returned 100%
     1048: 2250:  result.addOperands(initVals);
call    0 returned 100%
     1048: 2251:  result.addAttribute(
call    0 returned 100%
        -: 2252:      ParallelOp::getOperandSegmentSizeAttr(),
     2096: 2253:      builder.getDenseI32ArrayAttr({static_cast<int32_t>(lowerBounds.size()),
     1048: 2254:                                    static_cast<int32_t>(upperBounds.size()),
     1048: 2255:                                    static_cast<int32_t>(steps.size()),
call    0 returned 100%
     1048: 2256:                                    static_cast<int32_t>(initVals.size())}));
call    0 returned 100%
     1048: 2257:  result.addTypes(initVals.getTypes());
call    0 returned 100%
call    1 returned 100%
        -: 2258:
     1048: 2259:  OpBuilder::InsertionGuard guard(builder);
call    0 returned 100%
     1048: 2260:  unsigned numIVs = steps.size();
call    0 returned 100%
     2096: 2261:  SmallVector<Type, 8> argTypes(numIVs, builder.getIndexType());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2096: 2262:  SmallVector<Location, 8> argLocs(numIVs, result.location);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1048: 2263:  Region *bodyRegion = result.addRegion();
call    0 returned 100%
     1048: 2264:  Block *bodyBlock = builder.createBlock(bodyRegion, {}, argTypes, argLocs);
call    0 returned 100%
call    1 returned 100%
        -: 2265:
     1048: 2266:  if (bodyBuilderFn) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        5: 2267:    builder.setInsertionPointToStart(bodyBlock);
call    0 returned 100%
       15: 2268:    bodyBuilderFn(builder, result.location,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       10: 2269:                  bodyBlock->getArguments().take_front(numIVs),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       10: 2270:                  bodyBlock->getArguments().drop_front(numIVs));
call    0 returned 100%
call    1 returned 100%
        -: 2271:  }
     1048: 2272:  ParallelOp::ensureTerminator(*bodyRegion, builder, result.location);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1048: 2273:}
        -: 2274:
function _ZN4mlir3scf10ParallelOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeES6_S6_N4llvm12function_refIFvS3_NS_8LocationES6_EEE called 941 returned 100% blocks executed 100%
      941: 2275:void ParallelOp::build(
        -: 2276:    OpBuilder &builder, OperationState &result, ValueRange lowerBounds,
        -: 2277:    ValueRange upperBounds, ValueRange steps,
        -: 2278:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn) {
        -: 2279:  // Only pass a non-null wrapper if bodyBuilderFn is non-null itself. Make sure
        -: 2280:  // we don't capture a reference to a temporary by constructing the lambda at
        -: 2281:  // function level.
      944: 2282:  auto wrappedBuilderFn = [&bodyBuilderFn](OpBuilder &nestedBuilder,
        -: 2283:                                           Location nestedLoc, ValueRange ivs,
        -: 2284:                                           ValueRange) {
        3: 2285:    bodyBuilderFn(nestedBuilder, nestedLoc, ivs);
call    0 returned 100%
      941: 2286:  };
      941: 2287:  function_ref<void(OpBuilder &, Location, ValueRange, ValueRange)> wrapper;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      941: 2288:  if (bodyBuilderFn)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        3: 2289:    wrapper = wrappedBuilderFn;
        -: 2290:
      941: 2291:  build(builder, result, lowerBounds, upperBounds, steps, ValueRange(),
call    0 returned 100%
call    1 returned 100%
        -: 2292:        wrapper);
      941: 2293:}
        -: 2294:
function _ZN4mlir3scf10ParallelOp6verifyEv called 6886940 returned 100% blocks executed 46%
  6886940: 2295:LogicalResult ParallelOp::verify() {
        -: 2296:  // Check that there is at least one value in lowerBound, upperBound and step.
        -: 2297:  // It is sufficient to test only step, because it is ensured already that the
        -: 2298:  // number of elements in lowerBound, upperBound and step are the same.
  6886940: 2299:  Operation::operand_range stepValues = getStep();
call    0 returned 100%
  6886940: 2300:  if (stepValues.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2301:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2302:        "needs at least one tuple element for lowerBound, upperBound and step");
call    0 never executed
        -: 2303:
        -: 2304:  // Check whether all constant step values are positive.
 18496475: 2305:  for (Value stepValue : stepValues)
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
call    2 returned 100%
 11609535: 2306:    if (auto cst = stepValue.getDefiningOp<arith::ConstantIndexOp>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
 11596111: 2307:      if (cst.value() <= 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2308:        return emitOpError("constant step operand must be positive");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2309:
        -: 2310:  // Check that the body defines the same number of block arguments as the
        -: 2311:  // number of tuple elements in step.
  6886940: 2312:  Block *body = getBody();
call    0 returned 100%
  6886940: 2313:  if (body->getNumArguments() != stepValues.size())
branch  0 taken 0%
branch  1 taken 100%
    #####: 2314:    return emitOpError() << "expects the same number of induction variables: "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2315:                         << body->getNumArguments()
call    0 never executed
call    1 never executed
    #####: 2316:                         << " as bound and step values: " << stepValues.size();
call    0 never executed
call    1 never executed
call    2 never executed
 18496475: 2317:  for (auto arg : body->getArguments())
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
 11609535: 2318:    if (!arg.getType().isIndex())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2319:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2320:          "expects arguments for the induction variable to be of index type");
call    0 never executed
        -: 2321:
        -: 2322:  // Check that the yield has no results
  6886940: 2323:  Operation *yield = body->getTerminator();
call    0 returned 100%
 13773880: 2324:  if (yield->getNumOperands() != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2325:    return yield->emitOpError() << "not allowed to have operands inside '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2326:                                << ParallelOp::getOperationName() << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2327:
        -: 2328:  // Check that the number of results is the same as the number of ReduceOps.
  6886940: 2329:  SmallVector<ReduceOp, 4> reductions(body->getOps<ReduceOp>());
call    0 returned 100%
call    1 returned 100%
  6886940: 2330:  auto resultsSize = getResults().size();
call    0 returned 100%
call    1 returned 100%
  6886940: 2331:  auto reductionsSize = reductions.size();
call    0 returned 100%
  6886940: 2332:  auto initValsSize = getInitVals().size();
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
  6886940: 2333:  if (resultsSize != reductionsSize)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       36: 2334:    return emitOpError() << "expects number of results: " << resultsSize
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
       18: 2335:                         << " to be the same as number of reductions: "
call    0 returned 100%
       18: 2336:                         << reductionsSize;
call    0 returned 100%
  6886922: 2337:  if (resultsSize != initValsSize)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2338:    return emitOpError() << "expects number of results: " << resultsSize
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2339:                         << " to be the same as number of initial values: "
call    0 never executed
    #####: 2340:                         << initValsSize;
call    0 never executed
        -: 2341:
        -: 2342:  // Check that the types of the results and reductions are the same.
  9805289: 2343:  for (auto resultAndReduce : llvm::zip(getResults(), reductions)) {
call    0 returned 100%
branch  1 taken 30% (fallthrough)
branch  2 taken 70%
  2918367: 2344:    auto resultType = std::get<0>(resultAndReduce).getType();
call    0 returned 100%
  2918367: 2345:    auto reduceOp = std::get<1>(resultAndReduce);
call    0 returned 100%
  2918367: 2346:    auto reduceType = reduceOp.getOperand().getType();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  2918367: 2347:    if (resultType != reduceType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2348:      return reduceOp.emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2349:             << "expects type of reduce: " << reduceType
call    0 never executed
call    1 never executed
    #####: 2350:             << " to be the same as result type: " << resultType;
call    0 never executed
call    1 never executed
        -: 2351:  }
  6886940: 2352:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2353:}
        -: 2354:
function _ZN4mlir3scf10ParallelOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 183186 returned 100% blocks executed 81%
   183186: 2355:ParseResult ParallelOp::parse(OpAsmParser &parser, OperationState &result) {
   183186: 2356:  auto &builder = parser.getBuilder();
call    0 returned 100%
        -: 2357:  // Parse an opening `(` followed by induction variables followed by `)`
   183186: 2358:  SmallVector<OpAsmParser::Argument, 4> ivs;
call    0 returned 100%
   183186: 2359:  if (parser.parseArgumentList(ivs, OpAsmParser::Delimiter::Paren))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2360:    return failure();
        -: 2361:
        -: 2362:  // Parse loop bounds.
   366372: 2363:  SmallVector<OpAsmParser::UnresolvedOperand, 4> lower;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  366372*: 2364:  if (parser.parseEqual() ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   183186: 2365:      parser.parseOperandList(lower, ivs.size(),
call    0 returned 100%
   366372: 2366:                              OpAsmParser::Delimiter::Paren) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
  183186*: 2367:      parser.resolveOperands(lower, builder.getIndexType(), result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2368:    return failure();
        -: 2369:
   366372: 2370:  SmallVector<OpAsmParser::UnresolvedOperand, 4> upper;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  366372*: 2371:  if (parser.parseKeyword("to") ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   183186: 2372:      parser.parseOperandList(upper, ivs.size(),
call    0 returned 100%
   366372: 2373:                              OpAsmParser::Delimiter::Paren) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
  183186*: 2374:      parser.resolveOperands(upper, builder.getIndexType(), result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 2375:    return failure();
        -: 2376:
        -: 2377:  // Parse step values.
   366372: 2378:  SmallVector<OpAsmParser::UnresolvedOperand, 4> steps;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  366372*: 2379:  if (parser.parseKeyword("step") ||
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   183186: 2380:      parser.parseOperandList(steps, ivs.size(),
call    0 returned 100%
   366372: 2381:                              OpAsmParser::Delimiter::Paren) ||
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
  183186*: 2382:      parser.resolveOperands(steps, builder.getIndexType(), result.operands))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####: 2383:    return failure();
        -: 2384:
        -: 2385:  // Parse init values.
   366372: 2386:  SmallVector<OpAsmParser::UnresolvedOperand, 4> initVals;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   183186: 2387:  if (succeeded(parser.parseOptionalKeyword("init"))) {
call    0 returned 100%
branch  1 taken 43%
branch  2 taken 57%
    78033: 2388:    if (parser.parseOperandList(initVals, OpAsmParser::Delimiter::Paren))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2389:      return failure();
        -: 2390:  }
        -: 2391:
        -: 2392:  // Parse optional results in case there is a reduce.
   183186: 2393:  if (parser.parseOptionalArrowTypeList(result.types))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2394:    return failure();
        -: 2395:
        -: 2396:  // Now parse the body.
   183186: 2397:  Region *body = result.addRegion();
call    0 returned 100%
   483634: 2398:  for (auto &iv : ivs)
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
   300448: 2399:    iv.type = builder.getIndexType();
call    0 returned 100%
   183186: 2400:  if (parser.parseRegion(*body, ivs))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2401:    return failure();
        -: 2402:
        -: 2403:  // Set `operand_segment_sizes` attribute.
   183186: 2404:  result.addAttribute(
call    0 returned 100%
        -: 2405:      ParallelOp::getOperandSegmentSizeAttr(),
   183186: 2406:      builder.getDenseI32ArrayAttr({static_cast<int32_t>(lower.size()),
call    0 returned 100%
   183186: 2407:                                    static_cast<int32_t>(upper.size()),
   183186: 2408:                                    static_cast<int32_t>(steps.size()),
   183186: 2409:                                    static_cast<int32_t>(initVals.size())}));
call    0 returned 100%
        -: 2410:
        -: 2411:  // Parse attributes.
  366372*: 2412:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  549558*: 2413:      parser.resolveOperands(initVals, result.types, parser.getNameLoc(),
   183186: 2414:                             result.operands))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 2415:    return failure();
        -: 2416:
        -: 2417:  // Add a terminator if none was parsed.
   183186: 2418:  ForOp::ensureTerminator(*body, builder, result.location);
call    0 returned 100%
   183186: 2419:  return success();
        -: 2420:}
        -: 2421:
function _ZN4mlir3scf10ParallelOp5printERNS_12OpAsmPrinterE called 300740 returned 100% blocks executed 100%
   300740: 2422:void ParallelOp::print(OpAsmPrinter &p) {
   902220: 2423:  p << " (" << getBody()->getArguments() << ") = (" << getLowerBound()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
   902220: 2424:    << ") to (" << getUpperBound() << ") step (" << getStep() << ")";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
   300740: 2425:  if (!getInitVals().empty())
call    0 returned 100%
branch  1 taken 43% (fallthrough)
branch  2 taken 57%
   261112: 2426:    p << " init (" << getInitVals() << ")";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
   601480: 2427:  p.printOptionalArrowTypeList(getResultTypes());
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   300740: 2428:  p << ' ';
call    0 returned 100%
   300740: 2429:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false);
call    0 returned 100%
call    1 returned 100%
   300740: 2430:  p.printOptionalAttrDict(
call    0 returned 100%
        -: 2431:      (*this)->getAttrs(),
   300740: 2432:      /*elidedAttrs=*/ParallelOp::getOperandSegmentSizeAttr());
call    0 returned 100%
   300740: 2433:}
        -: 2434:
function _ZN4mlir3scf10ParallelOp11getLoopBodyEv called 865 returned 100% blocks executed 100%
    27966: 2435:Region &ParallelOp::getLoopBody() { return getRegion(); }
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2436:
function _ZN4mlir3scf31getParallelForInductionVarOwnerENS_5ValueE called 1826 returned 100% blocks executed 50%
     1826: 2437:ParallelOp mlir::scf::getParallelForInductionVarOwner(Value val) {
     1826: 2438:  auto ivArg = val.dyn_cast<BlockArgument>();
call    0 returned 100%
     1826: 2439:  if (!ivArg)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1826: 2440:    return ParallelOp();
    #####: 2441:  assert(ivArg.getOwner() && "unlinked block argument");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2442:  auto *containingOp = ivArg.getOwner()->getParentOp();
call    0 never executed
    #####: 2443:  return dyn_cast<ParallelOp>(containingOp);
call    0 never executed
        -: 2444:}
        -: 2445:
        -: 2446:namespace {
        -: 2447:// Collapse loop dimensions that perform a single iteration.
        -: 2448:struct CollapseSingleIterationLoops : public OpRewritePattern<ParallelOp> {
        -: 2449:  using OpRewritePattern<ParallelOp>::OpRewritePattern;
        -: 2450:
function _ZNK12_GLOBAL__N_128CollapseSingleIterationLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterE called 3480 returned 100% blocks executed 90%
     3480: 2451:  LogicalResult matchAndRewrite(ParallelOp op,
        -: 2452:                                PatternRewriter &rewriter) const override {
     3480: 2453:    BlockAndValueMapping mapping;
call    0 returned 100%
        -: 2454:    // Compute new loop bounds that omit all single-iteration loop dimensions.
     6960: 2455:    SmallVector<Value, 2> newLowerBounds;
call    0 returned 100%
call    1 returned 100%
     3480: 2456:    SmallVector<Value, 2> newUpperBounds;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3480: 2457:    SmallVector<Value, 2> newSteps;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3480: 2458:    newLowerBounds.reserve(op.getLowerBound().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3480: 2459:    newUpperBounds.reserve(op.getUpperBound().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3480: 2460:    newSteps.reserve(op.getStep().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    10818: 2461:    for (auto [lowerBound, upperBound, step, iv] :
call    0 returned 100%
     3480: 2462:         llvm::zip(op.getLowerBound(), op.getUpperBound(), op.getStep(),
call    0 returned 100%
call    1 returned 100%
    17778: 2463:                   op.getInductionVars())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 61% (fallthrough)
branch  3 taken 39%
call    4 returned 100%
        -: 2464:      // Collect the statically known loop bounds.
     5409: 2465:      auto lowerBoundConstant =
     5409: 2466:          dyn_cast_or_null<arith::ConstantIndexOp>(lowerBound.getDefiningOp());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     5409: 2467:      auto upperBoundConstant =
     5409: 2468:          dyn_cast_or_null<arith::ConstantIndexOp>(upperBound.getDefiningOp());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     5409: 2469:      auto stepConstant =
     5409: 2470:          dyn_cast_or_null<arith::ConstantIndexOp>(step.getDefiningOp());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2471:      // Replace the loop induction variable by the lower bound if the loop
        -: 2472:      // performs a single iteration. Otherwise, copy the loop bounds.
     5409: 2473:      if (lowerBoundConstant && upperBoundConstant && stepConstant &&
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
branch  2 taken 70% (fallthrough)
branch  3 taken 30%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
     9143: 2474:          (upperBoundConstant.value() - lowerBoundConstant.value()) > 0 &&
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 26% (fallthrough)
branch  5 taken 74%
branch  6 taken 34% (fallthrough)
branch  7 taken 66%
      772: 2475:          (upperBoundConstant.value() - lowerBoundConstant.value()) <=
call    0 returned 100%
call    1 returned 100%
      772: 2476:              stepConstant.value()) {
call    0 returned 100%
      265: 2477:        mapping.map(iv, lowerBound);
call    0 returned 100%
        -: 2478:      } else {
     5144: 2479:        newLowerBounds.push_back(lowerBound);
call    0 returned 100%
     5144: 2480:        newUpperBounds.push_back(upperBound);
call    0 returned 100%
     5144: 2481:        newSteps.push_back(step);
call    0 returned 100%
        -: 2482:      }
        -: 2483:    }
        -: 2484:    // Exit if none of the loop dimensions perform a single iteration.
     3480: 2485:    if (newLowerBounds.size() == op.getLowerBound().size())
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
     3246: 2486:      return failure();
        -: 2487:
      234: 2488:    if (newLowerBounds.empty()) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
        -: 2489:      // All of the loop dimensions perform a single iteration. Inline
        -: 2490:      // loop body and nested ReduceOp's
      258: 2491:      SmallVector<Value> results;
call    0 returned 100%
      129: 2492:      results.reserve(op.getInitVals().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2583: 2493:      for (auto &bodyOp : op.getLoopBody().front().without_terminator()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 95% (fallthrough)
branch  5 taken 5%
call    6 returned 100%
     2325: 2494:        auto reduce = dyn_cast<ReduceOp>(bodyOp);
call    0 returned 100%
     2325: 2495:        if (!reduce) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
     2281: 2496:          rewriter.clone(bodyOp, mapping);
call    0 returned 100%
     2281: 2497:          continue;
        -: 2498:        }
       44: 2499:        Block &reduceBlock = reduce.getReductionOperator().front();
call    0 returned 100%
call    1 returned 100%
       44: 2500:        auto initValIndex = results.size();
call    0 returned 100%
       44: 2501:        mapping.map(reduceBlock.getArgument(0), op.getInitVals()[initValIndex]);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       44: 2502:        mapping.map(reduceBlock.getArgument(1),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2503:                    mapping.lookupOrDefault(reduce.getOperand()));
      476: 2504:        for (auto &reduceBodyOp : reduceBlock.without_terminator())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 90% (fallthrough)
branch  3 taken 10%
call    4 returned 100%
      388: 2505:          rewriter.clone(reduceBodyOp, mapping);
call    0 returned 100%
        -: 2506:
       44: 2507:        auto result = mapping.lookupOrDefault(
       44: 2508:            cast<ReduceReturnOp>(reduceBlock.getTerminator()).getResult());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       44: 2509:        results.push_back(result);
call    0 returned 100%
        -: 2510:      }
      129: 2511:      rewriter.replaceOp(op, results);
call    0 returned 100%
call    1 returned 100%
      129: 2512:      return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2513:    }
        -: 2514:    // Replace the parallel loop by lower-dimensional parallel loop.
      105: 2515:    auto newOp =
        -: 2516:        rewriter.create<ParallelOp>(op.getLoc(), newLowerBounds, newUpperBounds,
      105: 2517:                                    newSteps, op.getInitVals(), nullptr);
call    0 returned 100%
call    1 returned 100%
        -: 2518:    // Clone the loop body and remap the block arguments of the collapsed loops
        -: 2519:    // (inlining does not support a cancellable block argument mapping).
      105: 2520:    rewriter.cloneRegionBefore(op.getRegion(), newOp.getRegion(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      105: 2521:                               newOp.getRegion().begin(), mapping);
call    0 returned 100%
call    1 returned 100%
      105: 2522:    rewriter.replaceOp(op, newOp.getResults());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3480: 2523:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2524:  }
        -: 2525:};
        -: 2526:
        -: 2527:/// Removes parallel loops in which at least one lower/upper bound pair consists
        -: 2528:/// of the same values - such loops have an empty iteration domain.
        -: 2529:struct RemoveEmptyParallelLoops : public OpRewritePattern<ParallelOp> {
        -: 2530:  using OpRewritePattern<ParallelOp>::OpRewritePattern;
        -: 2531:
function _ZNK12_GLOBAL__N_124RemoveEmptyParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterE called 3246 returned 100% blocks executed 100%
     3246: 2532:  LogicalResult matchAndRewrite(ParallelOp op,
        -: 2533:                                PatternRewriter &rewriter) const override {
     7904: 2534:    for (auto dim : llvm::zip(op.getLowerBound(), op.getUpperBound())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 62% (fallthrough)
branch  3 taken 38%
     4880: 2535:      if (std::get<0>(dim) == std::get<1>(dim)) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
      222: 2536:        rewriter.replaceOp(op, op.getInitVals());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      222: 2537:        return success();
        -: 2538:      }
        -: 2539:    }
     3024: 2540:    return failure();
        -: 2541:  }
        -: 2542:};
        -: 2543:
        -: 2544:struct MergeNestedParallelLoops : public OpRewritePattern<ParallelOp> {
        -: 2545:  using OpRewritePattern<ParallelOp>::OpRewritePattern;
        -: 2546:
function _ZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterE called 3024 returned 100% blocks executed 90%
     3024: 2547:  LogicalResult matchAndRewrite(ParallelOp op,
        -: 2548:                                PatternRewriter &rewriter) const override {
     3024: 2549:    Block &outerBody = op.getLoopBody().front();
call    0 returned 100%
call    1 returned 100%
     6048: 2550:    if (!llvm::hasSingleElement(outerBody.without_terminator()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     2687: 2551:      return failure();
        -: 2552:
      337: 2553:    auto innerOp = dyn_cast<ParallelOp>(outerBody.front());
call    0 returned 100%
call    1 returned 100%
      337: 2554:    if (!innerOp)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
      335: 2555:      return failure();
        -: 2556:
        4: 2557:    for (auto val : outerBody.getArguments())
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       4*: 2558:      if (llvm::is_contained(innerOp.getLowerBound(), val) ||
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       6*: 2559:          llvm::is_contained(innerOp.getUpperBound(), val) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
       4*: 2560:          llvm::is_contained(innerOp.getStep(), val))
call    0 returned 100%
    #####: 2561:        return failure();
        -: 2562:
        -: 2563:    // Reductions are not supported yet.
        4: 2564:    if (!op.getInitVals().empty() || !innerOp.getInitVals().empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 2565:      return failure();
        -: 2566:
function _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRNS1_9OpBuilderENS1_8LocationENS1_10ValueRangeES9_E_clES7_S8_S9_S9_.isra.0 called 2 returned 100% blocks executed 90%
        4: 2567:    auto bodyBuilder = [&](OpBuilder &builder, Location /*loc*/,
        -: 2568:                           ValueRange iterVals, ValueRange) {
        2: 2569:      Block &innerBody = innerOp.getLoopBody().front();
call    0 returned 100%
call    1 returned 100%
       4*: 2570:      assert(iterVals.size() ==
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -: 2571:             (outerBody.getNumArguments() + innerBody.getNumArguments()));
        4: 2572:      BlockAndValueMapping mapping;
call    0 returned 100%
call    1 returned 100%
        2: 2573:      mapping.map(outerBody.getArguments(),
call    0 returned 100%
call    1 returned 100%
        2: 2574:                  iterVals.take_front(outerBody.getNumArguments()));
call    0 returned 100%
        4: 2575:      mapping.map(innerBody.getArguments(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        4: 2576:                  iterVals.take_back(innerBody.getNumArguments()));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       29: 2577:      for (Operation &op : innerBody.without_terminator())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 93% (fallthrough)
branch  3 taken 7%
call    4 returned 100%
       25: 2578:        builder.clone(op, mapping);
call    0 returned 100%
        4: 2579:    };
        -: 2580:
function _ZZNK12_GLOBAL__N_124MergeNestedParallelLoops15matchAndRewriteEN4mlir3scf10ParallelOpERNS1_15PatternRewriterEENKUlRKT_RKT0_E0_clINS1_12OperandRangeESE_EEDaS8_SB_.isra.0 called 6 returned 100% blocks executed 71%
        6: 2581:    auto concatValues = [](const auto &first, const auto &second) {
        6: 2582:      SmallVector<Value> ret;
        6: 2583:      ret.reserve(first.size() + second.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        6: 2584:      ret.assign(first.begin(), first.end());
call    0 returned 100%
        6: 2585:      ret.append(second.begin(), second.end());
call    0 returned 100%
        6: 2586:      return ret;
        -: 2587:    };
        -: 2588:
        2: 2589:    auto newLowerBounds =
call    0 returned 100%
        2: 2590:        concatValues(op.getLowerBound(), innerOp.getLowerBound());
call    0 returned 100%
call    1 returned 100%
        2: 2591:    auto newUpperBounds =
call    0 returned 100%
        4: 2592:        concatValues(op.getUpperBound(), innerOp.getUpperBound());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        4: 2593:    auto newSteps = concatValues(op.getStep(), innerOp.getStep());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 2594:
        2: 2595:    rewriter.replaceOpWithNewOp<ParallelOp>(op, newLowerBounds, newUpperBounds,
        2: 2596:                                            newSteps, llvm::None, bodyBuilder);
call    0 returned 100%
        2: 2597:    return success();
branch  0 taken 0%
branch  1 taken 100%
        -: 2598:  }
        -: 2599:};
        -: 2600:
        -: 2601:} // namespace
        -: 2602:
function _ZN4mlir3scf10ParallelOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1261 returned 100% blocks executed 100%
     1261: 2603:void ParallelOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 2604:                                             MLIRContext *context) {
     1261: 2605:  results.add<CollapseSingleIterationLoops, RemoveEmptyParallelLoops,
     1261: 2606:              MergeNestedParallelLoops>(context);
call    0 returned 100%
     1261: 2607:}
        -: 2608:
        -: 2609://===----------------------------------------------------------------------===//
        -: 2610:// ReduceOp
        -: 2611://===----------------------------------------------------------------------===//
        -: 2612:
function _ZN4mlir3scf8ReduceOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm12function_refIFvS3_NS_8LocationES6_S6_EEE called 0 returned 0% blocks executed 0%
    #####: 2613:void ReduceOp::build(
        -: 2614:    OpBuilder &builder, OperationState &result, Value operand,
        -: 2615:    function_ref<void(OpBuilder &, Location, Value, Value)> bodyBuilderFn) {
    #####: 2616:  auto type = operand.getType();
call    0 never executed
    #####: 2617:  result.addOperands(operand);
call    0 never executed
call    1 never executed
        -: 2618:
    #####: 2619:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 2620:  Region *bodyRegion = result.addRegion();
call    0 never executed
    #####: 2621:  Block *body = builder.createBlock(bodyRegion, {}, ArrayRef<Type>{type, type},
call    0 never executed
call    1 never executed
        -: 2622:                                    {result.location, result.location});
    #####: 2623:  if (bodyBuilderFn)
branch  0 never executed
branch  1 never executed
    #####: 2624:    bodyBuilderFn(builder, result.location, body->getArgument(0),
call    0 never executed
    #####: 2625:                  body->getArgument(1));
call    0 never executed
    #####: 2626:}
        -: 2627:
function _ZN4mlir3scf8ReduceOp13verifyRegionsEv called 2918698 returned 100% blocks executed 39%
  2918698: 2628:LogicalResult ReduceOp::verifyRegions() {
        -: 2629:  // The region of a ReduceOp has two arguments of the same type as its operand.
  2918698: 2630:  auto type = getOperand().getType();
call    0 returned 100%
call    1 returned 100%
  2918698: 2631:  Block &block = getReductionOperator().front();
call    0 returned 100%
call    1 returned 100%
  2918698: 2632:  if (block.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2633:    return emitOpError("the block inside reduce should not be empty");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
  2918698: 2634:  if (block.getNumArguments() != 2 ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  2918698: 2635:      llvm::any_of(block.getArguments(), [&](const BlockArgument &arg) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2636:        return arg.getType() != type;
        -: 2637:      }))
    #####: 2638:    return emitOpError() << "expects two arguments to reduce block of type "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2639:                         << type;
call    0 never executed
        -: 2640:
        -: 2641:  // Check that the block is terminated by a ReduceReturnOp.
  2918698: 2642:  if (!isa<ReduceReturnOp>(block.getTerminator()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2643:    return emitOpError("the block inside reduce should be terminated with a "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2644:                       "'scf.reduce.return' op");
call    0 never executed
        -: 2645:
  2918698: 2646:  return success();
        -: 2647:}
        -: 2648:
function _ZN4mlir3scf8ReduceOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 78033 returned 100% blocks executed 83%
    78033: 2649:ParseResult ReduceOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 2650:  // Parse an opening `(` followed by the reduced value followed by `)`
    78033: 2651:  OpAsmParser::UnresolvedOperand operand;
call    0 returned 100%
  156066*: 2652:  if (parser.parseLParen() || parser.parseOperand(operand) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
   78033*: 2653:      parser.parseRParen())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2654:    return failure();
        -: 2655:
    78033: 2656:  Type resultType;
        -: 2657:  // Parse the type of the operand (and also what reduce computes on).
  156066*: 2658:  if (parser.parseColonType(resultType) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
   78033*: 2659:      parser.resolveOperand(operand, resultType, result.operands))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####: 2660:    return failure();
        -: 2661:
        -: 2662:  // Now parse the body.
    78033: 2663:  Region *body = result.addRegion();
call    0 returned 100%
    78033: 2664:  if (parser.parseRegion(*body, /*arguments=*/{}, /*argTypes=*/{}))
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####: 2665:    return failure();
        -: 2666:
    78033: 2667:  return success();
        -: 2668:}
        -: 2669:
function _ZN4mlir3scf8ReduceOp5printERNS_12OpAsmPrinterE called 131512 returned 100% blocks executed 100%
   131512: 2670:void ReduceOp::print(OpAsmPrinter &p) {
   263024: 2671:  p << "(" << getOperand() << ") ";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   263024: 2672:  p << " : " << getOperand().getType() << ' ';
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   131512: 2673:  p.printRegion(getReductionOperator());
call    0 returned 100%
call    1 returned 100%
   131512: 2674:}
        -: 2675:
        -: 2676://===----------------------------------------------------------------------===//
        -: 2677:// ReduceReturnOp
        -: 2678://===----------------------------------------------------------------------===//
        -: 2679:
function _ZN4mlir3scf14ReduceReturnOp6verifyEv called 2918698 returned 100% blocks executed 50%
  2918698: 2680:LogicalResult ReduceReturnOp::verify() {
        -: 2681:  // The type of the return value should be the same type as the type of the
        -: 2682:  // operand of the enclosing ReduceOp.
  5837396: 2683:  auto reduceOp = cast<ReduceOp>((*this)->getParentOp());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
  2918698: 2684:  Type reduceType = reduceOp.getOperand().getType();
call    0 returned 100%
call    1 returned 100%
  2918698: 2685:  if (reduceType != getResult().getType())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2686:    return emitOpError() << "needs to have type " << reduceType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2687:                         << " (the type of the enclosing ReduceOp)";
call    0 never executed
  2918698: 2688:  return success();
        -: 2689:}
        -: 2690:
        -: 2691://===----------------------------------------------------------------------===//
        -: 2692:// WhileOp
        -: 2693://===----------------------------------------------------------------------===//
        -: 2694:
function _ZN4mlir3scf7WhileOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 23507617 returned 100% blocks executed 80%
 23507617: 2695:OperandRange WhileOp::getSuccessorEntryOperands(Optional<unsigned> index) {
23507617*: 2696:  assert(index && *index == 0 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 2697:         "WhileOp is expected to branch only to the first region");
        -: 2698:
 23507617: 2699:  return getInits();
call    0 returned 100%
        -: 2700:}
        -: 2701:
function _ZN4mlir3scf7WhileOp14getConditionOpEv called 56470 returned 100% blocks executed 100%
    56470: 2702:ConditionOp WhileOp::getConditionOp() {
    56470: 2703:  return cast<ConditionOp>(getBefore().front().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2704:}
        -: 2705:
function _ZN4mlir3scf7WhileOp10getYieldOpEv called 893 returned 100% blocks executed 100%
      893: 2706:YieldOp WhileOp::getYieldOp() {
      893: 2707:  return cast<YieldOp>(getAfter().front().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2708:}
        -: 2709:
function _ZN4mlir3scf7WhileOp18getBeforeArgumentsEv called 15385 returned 100% blocks executed 100%
    15385: 2710:Block::BlockArgListType WhileOp::getBeforeArguments() {
    15385: 2711:  return getBefore().front().getArguments();
call    0 returned 100%
call    1 returned 100%
        -: 2712:}
        -: 2713:
function _ZN4mlir3scf7WhileOp17getAfterArgumentsEv called 22898 returned 100% blocks executed 100%
    22898: 2714:Block::BlockArgListType WhileOp::getAfterArguments() {
    22898: 2715:  return getAfter().front().getArguments();
call    0 returned 100%
call    1 returned 100%
        -: 2716:}
        -: 2717:
function _ZN4mlir3scf7WhileOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 70525762 returned 100% blocks executed 94%
 70525762: 2718:void WhileOp::getSuccessorRegions(Optional<unsigned> index,
        -: 2719:                                  ArrayRef<Attribute> operands,
        -: 2720:                                  SmallVectorImpl<RegionSuccessor> &regions) {
        -: 2721:  // The parent op always branches to the condition region.
 70525762: 2722:  if (!index) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
 23508566: 2723:    regions.emplace_back(&getBefore(), getBefore().getArguments());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 47015028: 2724:    return;
        -: 2725:  }
        -: 2726:
47017196*: 2727:  assert(*index < 2 && "there are only two regions in a WhileOp");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 2728:  // The body region always branches back to the condition region.
 47017196: 2729:  if (*index == 1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
 23506470: 2730:    regions.emplace_back(&getBefore(), getBefore().getArguments());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 23506462: 2731:    return;
        -: 2732:  }
        -: 2733:
        -: 2734:  // Try to narrow the successor to the condition region.
23510726*: 2735:  assert(!operands.empty() && "expected at least one operand");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 23510726: 2736:  auto cond = operands[0].dyn_cast_or_null<BoolAttr>();
call    0 returned 100%
 23510726: 2737:  if (!cond || !cond.getValue())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 67% (fallthrough)
branch  4 taken 33%
 23509023: 2738:    regions.emplace_back(getResults());
call    0 returned 100%
call    1 returned 100%
 23510725: 2739:  if (!cond || cond.getValue())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 33% (fallthrough)
branch  4 taken 67%
 23507221: 2740:    regions.emplace_back(&getAfter(), getAfter().getArguments());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2741:}
        -: 2742:
        -: 2743:/// Parses a `while` op.
        -: 2744:///
        -: 2745:/// op ::= `scf.while` assignments `:` function-type region `do` region
        -: 2746:///         `attributes` attribute-dict
        -: 2747:/// initializer ::= /* empty */ | `(` assignment-list `)`
        -: 2748:/// assignment-list ::= assignment | assignment `,` assignment-list
        -: 2749:/// assignment ::= ssa-value `=` ssa-value
function _ZN4mlir3scf7WhileOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 583741 returned 100% blocks executed 63%
   583741: 2750:ParseResult scf::WhileOp::parse(OpAsmParser &parser, OperationState &result) {
   583741: 2751:  SmallVector<OpAsmParser::Argument, 4> regionArgs;
call    0 returned 100%
   583741: 2752:  SmallVector<OpAsmParser::UnresolvedOperand, 4> operands;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   583741: 2753:  Region *before = result.addRegion();
call    0 returned 100%
   583741: 2754:  Region *after = result.addRegion();
call    0 returned 100%
        -: 2755:
   583741: 2756:  OptionalParseResult listResult =
   583741: 2757:      parser.parseOptionalAssignmentList(regionArgs, operands);
call    0 returned 100%
   583741: 2758:  if (listResult.has_value() && failed(listResult.value()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2759:    return failure();
        -: 2760:
   583741: 2761:  FunctionType functionType;
   583741: 2762:  SMLoc typeLoc = parser.getCurrentLocation();
call    0 returned 100%
   583741: 2763:  if (failed(parser.parseColonType(functionType)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2764:    return failure();
        -: 2765:
   583741: 2766:  result.addTypes(functionType.getResults());
call    0 returned 100%
call    1 returned 100%
        -: 2767:
   583741: 2768:  if (functionType.getNumInputs() != operands.size()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2769:    return parser.emitError(typeLoc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2770:           << "expected as many input types as operands "
call    0 never executed
    #####: 2771:           << "(expected " << operands.size() << " got "
call    0 never executed
call    1 never executed
    #####: 2772:           << functionType.getNumInputs() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2773:  }
        -: 2774:
        -: 2775:  // Resolve input operands.
  1167482: 2776:  if (failed(parser.resolveOperands(operands, functionType.getInputs(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   583741: 2777:                                    parser.getCurrentLocation(),
  1167482: 2778:                                    result.operands)))
call    0 returned 100%
call    1 returned 100%
    #####: 2779:    return failure();
        -: 2780:
        -: 2781:  // Propagate the types into the region arguments.
  1167482: 2782:  for (size_t i = 0, e = regionArgs.size(); i != e; ++i)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   583741: 2783:    regionArgs[i].type = functionType.getInput(i);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2784:
  1167482: 2785:  return failure(parser.parseRegion(*before, regionArgs) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
  1167482: 2786:                 parser.parseKeyword("do") || parser.parseRegion(*after) ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
   583741: 2787:                 parser.parseOptionalAttrDictWithKeyword(result.attributes));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2788:}
        -: 2789:
        -: 2790:/// Prints a `while` op.
function _ZN4mlir3scf7WhileOp5printERNS_12OpAsmPrinterE called 929621 returned 100% blocks executed 100%
   929621: 2791:void scf::WhileOp::print(OpAsmPrinter &p) {
   929621: 2792:  printInitializationList(p, getBefore().front().getArguments(), getInits(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -: 2793:                          " ");
   929621: 2794:  p << " : ";
call    0 returned 100%
   929621: 2795:  p.printFunctionalType(getInits().getTypes(), getResults().getTypes());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
   929621: 2796:  p << ' ';
call    0 returned 100%
   929621: 2797:  p.printRegion(getBefore(), /*printEntryBlockArgs=*/false);
call    0 returned 100%
call    1 returned 100%
   929621: 2798:  p << " do ";
call    0 returned 100%
   929621: 2799:  p.printRegion(getAfter());
call    0 returned 100%
call    1 returned 100%
   929621: 2800:  p.printOptionalAttrDictWithKeyword((*this)->getAttrs());
call    0 returned 100%
call    1 returned 100%
   929621: 2801:}
        -: 2802:
        -: 2803:/// Verifies that two ranges of types match, i.e. have the same number of
        -: 2804:/// entries and that types are pairwise equals. Reports errors on the given
        -: 2805:/// operation in case of mismatch.
        -: 2806:template <typename OpTy>
        -: 2807:static LogicalResult verifyTypeRangesMatch(OpTy op, TypeRange left,
        -: 2808:                                           TypeRange right, StringRef message) {
        -: 2809:  if (left.size() != right.size())
        -: 2810:    return op.emitOpError("expects the same number of ") << message;
        -: 2811:
        -: 2812:  for (unsigned i = 0, e = left.size(); i < e; ++i) {
        -: 2813:    if (left[i] != right[i]) {
        -: 2814:      InFlightDiagnostic diag = op.emitOpError("expects the same types for ")
        -: 2815:                                << message;
        -: 2816:      diag.attachNote() << "for argument " << i << ", found " << left[i]
        -: 2817:                        << " and " << right[i];
        -: 2818:      return diag;
        -: 2819:    }
        -: 2820:  }
        -: 2821:
        -: 2822:  return success();
        -: 2823:}
        -: 2824:
        -: 2825:/// Verifies that the first block of the given `region` is terminated by a
        -: 2826:/// YieldOp. Reports errors on the given operation if it is not the case.
        -: 2827:template <typename TerminatorTy>
 46985313: 2828:static TerminatorTy verifyAndGetTerminator(scf::WhileOp op, Region &region,
        -: 2829:                                           StringRef errorMessage) {
 46985314: 2830:  Operation *terminatorOperation = region.front().getTerminator();
 46985311: 2831:  if (auto yield = dyn_cast_or_null<TerminatorTy>(terminatorOperation))
 46985311: 2832:    return yield;
        -: 2833:
    #####: 2834:  auto diag = op.emitOpError(errorMessage);
    #####: 2835:  if (terminatorOperation)
    #####: 2836:    diag.attachNote(terminatorOperation->getLoc()) << "terminator here";
    #####: 2837:  return nullptr;
        -: 2838:}
------------------
_Z22verifyAndGetTerminatorIN4mlir3scf7YieldOpEET_NS1_7WhileOpERNS0_6RegionEN4llvm9StringRefE:
function _Z22verifyAndGetTerminatorIN4mlir3scf7YieldOpEET_NS1_7WhileOpERNS0_6RegionEN4llvm9StringRefE called 23492654 returned 100% blocks executed 56%
 23492654: 2828:static TerminatorTy verifyAndGetTerminator(scf::WhileOp op, Region &region,
call    0 returned 100%
        -: 2829:                                           StringRef errorMessage) {
 23492654: 2830:  Operation *terminatorOperation = region.front().getTerminator();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
 23492657: 2831:  if (auto yield = dyn_cast_or_null<TerminatorTy>(terminatorOperation))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 23492657: 2832:    return yield;
        -: 2833:
    #####: 2834:  auto diag = op.emitOpError(errorMessage);
call    0 never executed
call    1 never executed
    #####: 2835:  if (terminatorOperation)
branch  0 never executed
branch  1 never executed
    #####: 2836:    diag.attachNote(terminatorOperation->getLoc()) << "terminator here";
call    0 never executed
call    1 never executed
    #####: 2837:  return nullptr;
call    0 never executed
        -: 2838:}
------------------
_Z22verifyAndGetTerminatorIN4mlir3scf11ConditionOpEET_NS1_7WhileOpERNS0_6RegionEN4llvm9StringRefE:
function _Z22verifyAndGetTerminatorIN4mlir3scf11ConditionOpEET_NS1_7WhileOpERNS0_6RegionEN4llvm9StringRefE called 23492659 returned 100% blocks executed 56%
 23492659: 2828:static TerminatorTy verifyAndGetTerminator(scf::WhileOp op, Region &region,
call    0 returned 100%
        -: 2829:                                           StringRef errorMessage) {
 23492660: 2830:  Operation *terminatorOperation = region.front().getTerminator();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken -0%
 23492654: 2831:  if (auto yield = dyn_cast_or_null<TerminatorTy>(terminatorOperation))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 23492654: 2832:    return yield;
        -: 2833:
    #####: 2834:  auto diag = op.emitOpError(errorMessage);
call    0 never executed
call    1 never executed
    #####: 2835:  if (terminatorOperation)
branch  0 never executed
branch  1 never executed
    #####: 2836:    diag.attachNote(terminatorOperation->getLoc()) << "terminator here";
call    0 never executed
call    1 never executed
    #####: 2837:  return nullptr;
call    0 never executed
        -: 2838:}
------------------
        -: 2839:
function _ZN4mlir3scf7WhileOp6verifyEv called 23492659 returned 100% blocks executed 88%
 23492659: 2840:LogicalResult scf::WhileOp::verify() {
 23492659: 2841:  auto beforeTerminator = verifyAndGetTerminator<scf::ConditionOp>(
call    0 returned 100%
        -: 2842:      *this, getBefore(),
 23492659: 2843:      "expects the 'before' region to terminate with 'scf.condition'");
call    0 returned 100%
call    1 returned 100%
 23492654: 2844:  if (!beforeTerminator)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2845:    return failure();
        -: 2846:
 23492654: 2847:  auto afterTerminator = verifyAndGetTerminator<scf::YieldOp>(
call    0 returned 100%
        -: 2848:      *this, getAfter(),
 23492654: 2849:      "expects the 'after' region to terminate with 'scf.yield'");
call    0 returned 100%
call    1 returned 100%
 23492657: 2850:  return success(afterTerminator != nullptr);
        -: 2851:}
        -: 2852:
        -: 2853:namespace {
        -: 2854:/// Replace uses of the condition within the do block with true, since otherwise
        -: 2855:/// the block would not be evaluated.
        -: 2856:///
        -: 2857:/// scf.while (..) : (i1, ...) -> ... {
        -: 2858:///  %condition = call @evaluate_condition() : () -> i1
        -: 2859:///  scf.condition(%condition) %condition : i1, ...
        -: 2860:/// } do {
        -: 2861:/// ^bb0(%arg0: i1, ...):
        -: 2862:///    use(%arg0)
        -: 2863:///    ...
        -: 2864:///
        -: 2865:/// becomes
        -: 2866:/// scf.while (..) : (i1, ...) -> ... {
        -: 2867:///  %condition = call @evaluate_condition() : () -> i1
        -: 2868:///  scf.condition(%condition) %condition : i1, ...
        -: 2869:/// } do {
        -: 2870:/// ^bb0(%arg0: i1, ...):
        -: 2871:///    use(%true)
        -: 2872:///    ...
        -: 2873:struct WhileConditionTruth : public OpRewritePattern<WhileOp> {
        -: 2874:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -: 2875:
function _ZNK12_GLOBAL__N_119WhileConditionTruth15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 9381 returned 100% blocks executed 50%
     9381: 2876:  LogicalResult matchAndRewrite(WhileOp op,
        -: 2877:                                PatternRewriter &rewriter) const override {
     9381: 2878:    auto term = op.getConditionOp();
call    0 returned 100%
        -: 2879:
        -: 2880:    // These variables serve to prevent creating duplicate constants
        -: 2881:    // and hold constant true or false values.
     9381: 2882:    Value constantTrue = nullptr;
        -: 2883:
     9381: 2884:    bool replaced = false;
      121: 2885:    for (auto yieldedAndBlockArgs :
     9502: 2886:         llvm::zip(term.getArgs(), op.getAfterArguments())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
      121: 2887:      if (std::get<0>(yieldedAndBlockArgs) == term.getCondition()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2888:        if (!std::get<1>(yieldedAndBlockArgs).use_empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2889:          if (!constantTrue)
branch  0 never executed
branch  1 never executed
    #####: 2890:            constantTrue = rewriter.create<arith::ConstantOp>(
    #####: 2891:                op.getLoc(), term.getCondition().getType(),
call    0 never executed
call    1 never executed
    #####: 2892:                rewriter.getBoolAttr(true));
call    0 never executed
call    1 never executed
        -: 2893:
    #####: 2894:          std::get<1>(yieldedAndBlockArgs).replaceAllUsesWith(constantTrue);
call    0 never executed
    #####: 2895:          replaced = true;
        -: 2896:        }
        -: 2897:      }
        -: 2898:    }
     9381: 2899:    return success(replaced);
        -: 2900:  }
        -: 2901:};
        -: 2902:
        -: 2903:/// Remove loop invariant arguments from `before` block of scf.while.
        -: 2904:/// A before block argument is considered loop invariant if :-
        -: 2905:///   1. i-th yield operand is equal to the i-th while operand.
        -: 2906:///   2. i-th yield operand is k-th after block argument which is (k+1)-th
        -: 2907:///      condition operand AND this (k+1)-th condition operand is equal to i-th
        -: 2908:///      iter argument/while operand.
        -: 2909:/// For the arguments which are removed, their uses inside scf.while
        -: 2910:/// are replaced with their corresponding initial value.
        -: 2911:///
        -: 2912:/// Eg:
        -: 2913:///    INPUT :-
        -: 2914:///    %res = scf.while <...> iter_args(%arg0_before = %a, %arg1_before = %b,
        -: 2915:///                                     ..., %argN_before = %N)
        -: 2916:///           {
        -: 2917:///                ...
        -: 2918:///                scf.condition(%cond) %arg1_before, %arg0_before,
        -: 2919:///                                     %arg2_before, %arg0_before, ...
        -: 2920:///           } do {
        -: 2921:///             ^bb0(%arg1_after, %arg0_after_1, %arg2_after, %arg0_after_2,
        -: 2922:///                  ..., %argK_after):
        -: 2923:///                ...
        -: 2924:///                scf.yield %arg0_after_2, %b, %arg1_after, ..., %argN
        -: 2925:///           }
        -: 2926:///
        -: 2927:///    OUTPUT :-
        -: 2928:///    %res = scf.while <...> iter_args(%arg2_before = %c, ..., %argN_before =
        -: 2929:///                                     %N)
        -: 2930:///           {
        -: 2931:///                ...
        -: 2932:///                scf.condition(%cond) %b, %a, %arg2_before, %a, ...
        -: 2933:///           } do {
        -: 2934:///             ^bb0(%arg1_after, %arg0_after_1, %arg2_after, %arg0_after_2,
        -: 2935:///                  ..., %argK_after):
        -: 2936:///                ...
        -: 2937:///                scf.yield %arg1_after, ..., %argN
        -: 2938:///           }
        -: 2939:///
        -: 2940:///    EXPLANATION:
        -: 2941:///      We iterate over each yield operand.
        -: 2942:///        1. 0-th yield operand %arg0_after_2 is 4-th condition operand
        -: 2943:///           %arg0_before, which in turn is the 0-th iter argument. So we
        -: 2944:///           remove 0-th before block argument and yield operand, and replace
        -: 2945:///           all uses of the 0-th before block argument with its initial value
        -: 2946:///           %a.
        -: 2947:///        2. 1-th yield operand %b is equal to the 1-th iter arg's initial
        -: 2948:///           value. So we remove this operand and the corresponding before
        -: 2949:///           block argument and replace all uses of 1-th before block argument
        -: 2950:///           with %b.
        -: 2951:struct RemoveLoopInvariantArgsFromBeforeBlock
        -: 2952:    : public OpRewritePattern<WhileOp> {
        -: 2953:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -: 2954:
function _ZNK12_GLOBAL__N_138RemoveLoopInvariantArgsFromBeforeBlock15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 14651 returned 100% blocks executed 90%
    14651: 2955:  LogicalResult matchAndRewrite(WhileOp op,
        -: 2956:                                PatternRewriter &rewriter) const override {
    14651: 2957:    Block &afterBlock = op.getAfter().front();
call    0 returned 100%
call    1 returned 100%
    14651: 2958:    Block::BlockArgListType beforeBlockArgs = op.getBeforeArguments();
call    0 returned 100%
    14651: 2959:    ConditionOp condOp = op.getConditionOp();
call    0 returned 100%
    14651: 2960:    OperandRange condOpArgs = condOp.getArgs();
call    0 returned 100%
    14651: 2961:    Operation *yieldOp = afterBlock.getTerminator();
call    0 returned 100%
    14651: 2962:    ValueRange yieldOpArgs = yieldOp->getOperands();
call    0 returned 100%
call    1 returned 100%
        -: 2963:
    14651: 2964:    bool canSimplify = false;
    14651: 2965:    for (const auto &it :
call    0 returned 100%
    26677: 2966:         llvm::enumerate(llvm::zip(op.getOperands(), yieldOpArgs))) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
call    2 returned 100%
     7881: 2967:      auto index = static_cast<unsigned>(it.index());
call    0 returned 100%
     7881: 2968:      auto [initVal, yieldOpArg] = it.value();
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
        -: 2969:      // If i-th yield operand is equal to the i-th operand of the scf.while,
        -: 2970:      // the i-th before block argument is a loop invariant.
     7881: 2971:      if (yieldOpArg == initVal) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 2972:        canSimplify = true;
     1868: 2973:        break;
        -: 2974:      }
        -: 2975:      // If the i-th yield operand is k-th after block argument, then we check
        -: 2976:      // if the (k+1)-th condition op operand is equal to either the i-th before
        -: 2977:      // block argument or the initial value of i-th before block argument. If
        -: 2978:      // the comparison results `true`, i-th before block argument is a loop
        -: 2979:      // invariant.
     6297: 2980:      auto yieldOpBlockArg = yieldOpArg.dyn_cast<BlockArgument>();
call    0 returned 100%
     6297: 2981:      if (yieldOpBlockArg && yieldOpBlockArg.getOwner() == &afterBlock) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      508: 2982:        Value condOpArg = condOpArgs[yieldOpBlockArg.getArgNumber()];
call    0 returned 100%
      508: 2983:        if (condOpArg == beforeBlockArgs[index] || condOpArg == initVal) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
branch  4 taken 54% (fallthrough)
branch  5 taken 46%
        -: 2984:          canSimplify = true;
     1868: 2985:          break;
        -: 2986:        }
        -: 2987:      }
        -: 2988:    }
        -: 2989:
    14651: 2990:    if (!canSimplify)
    12783: 2991:      return failure();
        -: 2992:
     3736: 2993:    SmallVector<Value> newInitArgs, newYieldOpArgs;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3736: 2994:    DenseMap<unsigned, Value> beforeBlockInitValMap;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3736: 2995:    SmallVector<Location> newBeforeBlockArgLocs;
call    0 returned 100%
call    1 returned 100%
     3740: 2996:    for (const auto &it :
call    0 returned 100%
     5612: 2997:         llvm::enumerate(llvm::zip(op.getOperands(), yieldOpArgs))) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     1872: 2998:      auto index = static_cast<unsigned>(it.index());
call    0 returned 100%
     1872: 2999:      auto [initVal, yieldOpArg] = it.value();
call    0 returned 100%
branch  1 taken 85% (fallthrough)
branch  2 taken 15%
        -: 3000:
        -: 3001:      // If i-th yield operand is equal to the i-th operand of the scf.while,
        -: 3002:      // the i-th before block argument is a loop invariant.
     1872: 3003:      if (yieldOpArg == initVal) {
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
     1584: 3004:        beforeBlockInitValMap.insert({index, initVal});
call    0 returned 100%
     1868: 3005:        continue;
        -: 3006:      } else {
        -: 3007:        // If the i-th yield operand is k-th after block argument, then we check
        -: 3008:        // if the (k+1)-th condition op operand is equal to either the i-th
        -: 3009:        // before block argument or the initial value of i-th before block
        -: 3010:        // argument. If the comparison results `true`, i-th before block
        -: 3011:        // argument is a loop invariant.
      288: 3012:        auto yieldOpBlockArg = yieldOpArg.dyn_cast<BlockArgument>();
call    0 returned 100%
      288: 3013:        if (yieldOpBlockArg && yieldOpBlockArg.getOwner() == &afterBlock) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      284: 3014:          Value condOpArg = condOpArgs[yieldOpBlockArg.getArgNumber()];
call    0 returned 100%
      284: 3015:          if (condOpArg == beforeBlockArgs[index] || condOpArg == initVal) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 68% (fallthrough)
branch  3 taken 32%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      284: 3016:            beforeBlockInitValMap.insert({index, initVal});
call    0 returned 100%
      284: 3017:            continue;
        -: 3018:          }
        -: 3019:        }
        -: 3020:      }
        4: 3021:      newInitArgs.emplace_back(initVal);
call    0 returned 100%
        4: 3022:      newYieldOpArgs.emplace_back(yieldOpArg);
call    0 returned 100%
        4: 3023:      newBeforeBlockArgLocs.emplace_back(beforeBlockArgs[index].getLoc());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 3024:    }
        -: 3025:
     1868: 3026:    {
     1868: 3027:      OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
     1868: 3028:      rewriter.setInsertionPoint(yieldOp);
call    0 returned 100%
     1868: 3029:      rewriter.replaceOpWithNewOp<YieldOp>(yieldOp, newYieldOpArgs);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 3030:    }
        -: 3031:
     1868: 3032:    auto newWhile =
     3736: 3033:        rewriter.create<WhileOp>(op.getLoc(), op.getResultTypes(), newInitArgs);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 3034:
     3736: 3035:    Block &newBeforeBlock = *rewriter.createBlock(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1868: 3036:        &newWhile.getBefore(), /*insertPt*/ {},
call    0 returned 100%
     1868: 3037:        ValueRange(newYieldOpArgs).getTypes(), newBeforeBlockArgLocs);
call    0 returned 100%
        -: 3038:
     1868: 3039:    Block &beforeBlock = op.getBefore().front();
call    0 returned 100%
call    1 returned 100%
     3736: 3040:    SmallVector<Value> newBeforeBlockArgs(beforeBlock.getNumArguments());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3041:    // For each i-th before block argument we find it's replacement value as :-
        -: 3042:    //   1. If i-th before block argument is a loop invariant, we fetch it's
        -: 3043:    //      initial value from `beforeBlockInitValMap` by querying for key `i`.
        -: 3044:    //   2. Else we fetch j-th new before block argument as the replacement
        -: 3045:    //      value of i-th before block argument.
     3740: 3046:    for (unsigned i = 0, j = 0, n = beforeBlock.getNumArguments(); i < n; i++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 3047:      // If the index 'i' argument was a loop invariant we fetch it's initial
        -: 3048:      // value from `beforeBlockInitValMap`.
     1872: 3049:      if (beforeBlockInitValMap.count(i) != 0)
call    0 returned 100%
     1868: 3050:        newBeforeBlockArgs[i] = beforeBlockInitValMap[i];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 3051:      else
        4: 3052:        newBeforeBlockArgs[i] = newBeforeBlock.getArgument(j++);
branch  0 taken 0%
branch  1 taken 100%
        -: 3053:    }
        -: 3054:
     1868: 3055:    rewriter.mergeBlocks(&beforeBlock, &newBeforeBlock, newBeforeBlockArgs);
call    0 returned 100%
call    1 returned 100%
     1868: 3056:    rewriter.inlineRegionBefore(op.getAfter(), newWhile.getAfter(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1868: 3057:                                newWhile.getAfter().begin());
call    0 returned 100%
call    1 returned 100%
        -: 3058:
     1868: 3059:    rewriter.replaceOp(op, newWhile.getResults());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1868: 3060:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3061:  }
        -: 3062:};
        -: 3063:
        -: 3064:/// Remove loop invariant value from result (condition op) of scf.while.
        -: 3065:/// A value is considered loop invariant if the final value yielded by
        -: 3066:/// scf.condition is defined outside of the `before` block. We remove the
        -: 3067:/// corresponding argument in `after` block and replace the use with the value.
        -: 3068:/// We also replace the use of the corresponding result of scf.while with the
        -: 3069:/// value.
        -: 3070:///
        -: 3071:/// Eg:
        -: 3072:///    INPUT :-
        -: 3073:///    %res_input:K = scf.while <...> iter_args(%arg0_before = , ...,
        -: 3074:///                                             %argN_before = %N) {
        -: 3075:///                ...
        -: 3076:///                scf.condition(%cond) %arg0_before, %a, %b, %arg1_before, ...
        -: 3077:///           } do {
        -: 3078:///             ^bb0(%arg0_after, %arg1_after, %arg2_after, ..., %argK_after):
        -: 3079:///                ...
        -: 3080:///                some_func(%arg1_after)
        -: 3081:///                ...
        -: 3082:///                scf.yield %arg0_after, %arg2_after, ..., %argN_after
        -: 3083:///           }
        -: 3084:///
        -: 3085:///    OUTPUT :-
        -: 3086:///    %res_output:M = scf.while <...> iter_args(%arg0 = , ..., %argN = %N) {
        -: 3087:///                ...
        -: 3088:///                scf.condition(%cond) %arg0, %arg1, ..., %argM
        -: 3089:///           } do {
        -: 3090:///             ^bb0(%arg0, %arg3, ..., %argM):
        -: 3091:///                ...
        -: 3092:///                some_func(%a)
        -: 3093:///                ...
        -: 3094:///                scf.yield %arg0, %b, ..., %argN
        -: 3095:///           }
        -: 3096:///
        -: 3097:///     EXPLANATION:
        -: 3098:///       1. The 1-th and 2-th operand of scf.condition are defined outside the
        -: 3099:///          before block of scf.while, so they get removed.
        -: 3100:///       2. %res_input#1's uses are replaced by %a and %res_input#2's uses are
        -: 3101:///          replaced by %b.
        -: 3102:///       3. The corresponding after block argument %arg1_after's uses are
        -: 3103:///          replaced by %a and %arg2_after's uses are replaced by %b.
        -: 3104:struct RemoveLoopInvariantValueYielded : public OpRewritePattern<WhileOp> {
        -: 3105:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -: 3106:
function _ZNK12_GLOBAL__N_131RemoveLoopInvariantValueYielded15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 12783 returned 100% blocks executed 87%
    12783: 3107:  LogicalResult matchAndRewrite(WhileOp op,
        -: 3108:                                PatternRewriter &rewriter) const override {
    12783: 3109:    Block &beforeBlock = op.getBefore().front();
call    0 returned 100%
call    1 returned 100%
    12783: 3110:    ConditionOp condOp = op.getConditionOp();
call    0 returned 100%
    12783: 3111:    OperandRange condOpArgs = condOp.getArgs();
call    0 returned 100%
        -: 3112:
    12783: 3113:    bool canSimplify = false;
    12904: 3114:    for (Value condOpArg : condOpArgs) {
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
call    2 returned 100%
        -: 3115:      // Those values not defined within `before` block will be considered as
        -: 3116:      // loop invariant values. We map the corresponding `index` with their
        -: 3117:      // value.
     3523: 3118:      if (condOpArg.getParentBlock() != &beforeBlock) {
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
        -: 3119:        canSimplify = true;
        -: 3120:        break;
        -: 3121:      }
        -: 3122:    }
        -: 3123:
    12783: 3124:    if (!canSimplify)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
     9381: 3125:      return failure();
        -: 3126:
     3402: 3127:    Block::BlockArgListType afterBlockArgs = op.getAfterArguments();
call    0 returned 100%
        -: 3128:
     3402: 3129:    SmallVector<Value> newCondOpArgs;
call    0 returned 100%
     3402: 3130:    SmallVector<Type> newAfterBlockType;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     6804: 3131:    DenseMap<unsigned, Value> condOpInitValMap;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     6804: 3132:    SmallVector<Location> newAfterBlockArgLocs;
call    0 returned 100%
    10214: 3133:    for (const auto &it : llvm::enumerate(condOpArgs)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
     3406: 3134:      auto index = static_cast<unsigned>(it.index());
call    0 returned 100%
     3406: 3135:      Value condOpArg = it.value();
call    0 returned 100%
        -: 3136:      // Those values not defined within `before` block will be considered as
        -: 3137:      // loop invariant values. We map the corresponding `index` with their
        -: 3138:      // value.
     3406: 3139:      if (condOpArg.getParentBlock() != &beforeBlock) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 1%
     3402: 3140:        condOpInitValMap.insert({index, condOpArg});
call    0 returned 100%
        -: 3141:      } else {
        4: 3142:        newCondOpArgs.emplace_back(condOpArg);
call    0 returned 100%
        4: 3143:        newAfterBlockType.emplace_back(condOpArg.getType());
call    0 returned 100%
        4: 3144:        newAfterBlockArgLocs.emplace_back(afterBlockArgs[index].getLoc());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -: 3145:      }
        -: 3146:    }
        -: 3147:
     3402: 3148:    {
     3402: 3149:      OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
     3402: 3150:      rewriter.setInsertionPoint(condOp);
call    0 returned 100%
     3402: 3151:      rewriter.replaceOpWithNewOp<ConditionOp>(condOp, condOp.getCondition(),
branch  0 taken 100%
branch  1 taken 0%
     3402: 3152:                                               newCondOpArgs);
call    0 returned 100%
call    1 returned 100%
        -: 3153:    }
        -: 3154:
     3402: 3155:    auto newWhile = rewriter.create<WhileOp>(op.getLoc(), newAfterBlockType,
     3402: 3156:                                             op.getOperands());
call    0 returned 100%
call    1 returned 100%
        -: 3157:
     3402: 3158:    Block &newAfterBlock =
     3402: 3159:        *rewriter.createBlock(&newWhile.getAfter(), /*insertPt*/ {},
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 3160:                              newAfterBlockType, newAfterBlockArgLocs);
        -: 3161:
     3402: 3162:    Block &afterBlock = op.getAfter().front();
call    0 returned 100%
call    1 returned 100%
        -: 3163:    // Since a new scf.condition op was created, we need to fetch the new
        -: 3164:    // `after` block arguments which will be used while replacing operations of
        -: 3165:    // previous scf.while's `after` blocks. We'd also be fetching new result
        -: 3166:    // values too.
     6804: 3167:    SmallVector<Value> newAfterBlockArgs(afterBlock.getNumArguments());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     6804: 3168:    SmallVector<Value> newWhileResults(afterBlock.getNumArguments());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     6808: 3169:    for (unsigned i = 0, j = 0, n = afterBlock.getNumArguments(); i < n; i++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3406: 3170:      Value afterBlockArg, result;
        -: 3171:      // If index 'i' argument was loop invariant we fetch it's value from the
        -: 3172:      // `condOpInitMap` map.
     3406: 3173:      if (condOpInitValMap.count(i) != 0) {
call    0 returned 100%
     3402: 3174:        afterBlockArg = condOpInitValMap[i];
call    0 returned 100%
     3402: 3175:        result = afterBlockArg;
        -: 3176:      } else {
        4: 3177:        afterBlockArg = newAfterBlock.getArgument(j);
branch  0 taken 100%
branch  1 taken 0%
        4: 3178:        result = newWhile.getResult(j);
branch  0 taken 100%
branch  1 taken 0%
        4: 3179:        j++;
        -: 3180:      }
     3406: 3181:      newAfterBlockArgs[i] = afterBlockArg;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3406: 3182:      newWhileResults[i] = result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3183:    }
        -: 3184:
     3402: 3185:    rewriter.mergeBlocks(&afterBlock, &newAfterBlock, newAfterBlockArgs);
call    0 returned 100%
call    1 returned 100%
     3402: 3186:    rewriter.inlineRegionBefore(op.getBefore(), newWhile.getBefore(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3402: 3187:                                newWhile.getBefore().begin());
call    0 returned 100%
call    1 returned 100%
        -: 3188:
     3402: 3189:    rewriter.replaceOp(op, newWhileResults);
call    0 returned 100%
call    1 returned 100%
     3402: 3190:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3191:  }
        -: 3192:};
        -: 3193:
        -: 3194:/// Remove WhileOp results that are also unused in 'after' block.
        -: 3195:///
        -: 3196:///  %0:2 = scf.while () : () -> (i32, i64) {
        -: 3197:///    %condition = "test.condition"() : () -> i1
        -: 3198:///    %v1 = "test.get_some_value"() : () -> i32
        -: 3199:///    %v2 = "test.get_some_value"() : () -> i64
        -: 3200:///    scf.condition(%condition) %v1, %v2 : i32, i64
        -: 3201:///  } do {
        -: 3202:///  ^bb0(%arg0: i32, %arg1: i64):
        -: 3203:///    "test.use"(%arg0) : (i32) -> ()
        -: 3204:///    scf.yield
        -: 3205:///  }
        -: 3206:///  return %0#0 : i32
        -: 3207:///
        -: 3208:/// becomes
        -: 3209:///  %0 = scf.while () : () -> (i32) {
        -: 3210:///    %condition = "test.condition"() : () -> i1
        -: 3211:///    %v1 = "test.get_some_value"() : () -> i32
        -: 3212:///    %v2 = "test.get_some_value"() : () -> i64
        -: 3213:///    scf.condition(%condition) %v1 : i32
        -: 3214:///  } do {
        -: 3215:///  ^bb0(%arg0: i32):
        -: 3216:///    "test.use"(%arg0) : (i32) -> ()
        -: 3217:///    scf.yield
        -: 3218:///  }
        -: 3219:///  return %0 : i32
        -: 3220:struct WhileUnusedResult : public OpRewritePattern<WhileOp> {
        -: 3221:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -: 3222:
function _ZNK12_GLOBAL__N_117WhileUnusedResult15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 9381 returned 100% blocks executed 78%
     9381: 3223:  LogicalResult matchAndRewrite(WhileOp op,
        -: 3224:                                PatternRewriter &rewriter) const override {
     9381: 3225:    auto term = op.getConditionOp();
call    0 returned 100%
     9381: 3226:    auto afterArgs = op.getAfterArguments();
call    0 returned 100%
     9381: 3227:    auto termArgs = term.getArgs();
call    0 returned 100%
        -: 3228:
        -: 3229:    // Collect results mapping, new terminator args and new result types.
     9381: 3230:    SmallVector<unsigned> newResultsIndices;
call    0 returned 100%
     9381: 3231:    SmallVector<Type> newResultTypes;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     9381: 3232:    SmallVector<Value> newTermArgs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     9381: 3233:    SmallVector<Location> newArgLocs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     9381: 3234:    bool needUpdate = false;
     9381: 3235:    for (const auto &it :
call    0 returned 100%
     9623: 3236:         llvm::enumerate(llvm::zip(op.getResults(), afterArgs, termArgs))) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
      121: 3237:      auto i = static_cast<unsigned>(it.index());
call    0 returned 100%
      121: 3238:      Value result = std::get<0>(it.value());
call    0 returned 100%
call    1 returned 100%
      121: 3239:      Value afterArg = std::get<1>(it.value());
call    0 returned 100%
call    1 returned 100%
      121: 3240:      Value termArg = std::get<2>(it.value());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      121: 3241:      if (result.use_empty() && afterArg.use_empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
        -: 3242:        needUpdate = true;
        -: 3243:      } else {
       40: 3244:        newResultsIndices.emplace_back(i);
call    0 returned 100%
       40: 3245:        newTermArgs.emplace_back(termArg);
call    0 returned 100%
       40: 3246:        newResultTypes.emplace_back(result.getType());
call    0 returned 100%
       40: 3247:        newArgLocs.emplace_back(result.getLoc());
call    0 returned 100%
call    1 returned 100%
        -: 3248:      }
        -: 3249:    }
        -: 3250:
     9381: 3251:    if (!needUpdate)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     9300: 3252:      return failure();
        -: 3253:
       81: 3254:    {
       81: 3255:      OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
       81: 3256:      rewriter.setInsertionPoint(term);
call    0 returned 100%
       81: 3257:      rewriter.replaceOpWithNewOp<ConditionOp>(term, term.getCondition(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       81: 3258:                                               newTermArgs);
call    0 returned 100%
call    1 returned 100%
        -: 3259:    }
        -: 3260:
       81: 3261:    auto newWhile =
       81: 3262:        rewriter.create<WhileOp>(op.getLoc(), newResultTypes, op.getInits());
call    0 returned 100%
call    1 returned 100%
        -: 3263:
       81: 3264:    Block &newAfterBlock = *rewriter.createBlock(
call    0 returned 100%
call    1 returned 100%
       81: 3265:        &newWhile.getAfter(), /*insertPt*/ {}, newResultTypes, newArgLocs);
call    0 returned 100%
        -: 3266:
        -: 3267:    // Build new results list and new after block args (unused entries will be
        -: 3268:    // null).
     9462: 3269:    SmallVector<Value> newResults(op.getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      162: 3270:    SmallVector<Value> newAfterBlockArgs(op.getNumResults());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      81*: 3271:    for (const auto &it : llvm::enumerate(newResultsIndices)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3272:      newResults[it.value()] = newWhile.getResult(it.index());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3273:      newAfterBlockArgs[it.value()] = newAfterBlock.getArgument(it.index());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3274:    }
        -: 3275:
       81: 3276:    rewriter.inlineRegionBefore(op.getBefore(), newWhile.getBefore(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       81: 3277:                                newWhile.getBefore().begin());
call    0 returned 100%
call    1 returned 100%
        -: 3278:
       81: 3279:    Block &afterBlock = op.getAfter().front();
call    0 returned 100%
call    1 returned 100%
       81: 3280:    rewriter.mergeBlocks(&afterBlock, &newAfterBlock, newAfterBlockArgs);
call    0 returned 100%
call    1 returned 100%
        -: 3281:
       81: 3282:    rewriter.replaceOp(op, newResults);
call    0 returned 100%
call    1 returned 100%
       81: 3283:    return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3284:  }
        -: 3285:};
        -: 3286:
        -: 3287:/// Replace operations equivalent to the condition in the do block with true,
        -: 3288:/// since otherwise the block would not be evaluated.
        -: 3289:///
        -: 3290:/// scf.while (..) : (i32, ...) -> ... {
        -: 3291:///  %z = ... : i32
        -: 3292:///  %condition = cmpi pred %z, %a
        -: 3293:///  scf.condition(%condition) %z : i32, ...
        -: 3294:/// } do {
        -: 3295:/// ^bb0(%arg0: i32, ...):
        -: 3296:///    %condition2 = cmpi pred %arg0, %a
        -: 3297:///    use(%condition2)
        -: 3298:///    ...
        -: 3299:///
        -: 3300:/// becomes
        -: 3301:/// scf.while (..) : (i32, ...) -> ... {
        -: 3302:///  %z = ... : i32
        -: 3303:///  %condition = cmpi pred %z, %a
        -: 3304:///  scf.condition(%condition) %z : i32, ...
        -: 3305:/// } do {
        -: 3306:/// ^bb0(%arg0: i32, ...):
        -: 3307:///    use(%true)
        -: 3308:///    ...
        -: 3309:struct WhileCmpCond : public OpRewritePattern<scf::WhileOp> {
        -: 3310:  using OpRewritePattern<scf::WhileOp>::OpRewritePattern;
        -: 3311:
function _ZNK12_GLOBAL__N_112WhileCmpCond15matchAndRewriteEN4mlir3scf7WhileOpERNS1_15PatternRewriterE called 9381 returned 100% blocks executed 40%
     9381: 3312:  LogicalResult matchAndRewrite(scf::WhileOp op,
        -: 3313:                                PatternRewriter &rewriter) const override {
     9381: 3314:    using namespace scf;
     9381: 3315:    auto cond = op.getConditionOp();
call    0 returned 100%
     9381: 3316:    auto cmp = cond.getCondition().getDefiningOp<arith::CmpIOp>();
call    0 returned 100%
call    1 returned 100%
     9381: 3317:    if (!cmp)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     9369: 3318:      return failure();
       12: 3319:    bool changed = false;
       24: 3320:    for (auto tup :
call    0 returned 100%
       24: 3321:         llvm::zip(cond.getArgs(), op.getAfter().front().getArguments())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
       36: 3322:      for (size_t opIdx = 0; opIdx < 2; opIdx++) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       24: 3323:        if (std::get<0>(tup) != cmp.getOperand(opIdx))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       24: 3324:          continue;
    #####: 3325:        for (OpOperand &u :
branch  0 never executed
branch  1 never executed
    #####: 3326:             llvm::make_early_inc_range(std::get<1>(tup).getUses())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3327:          auto cmp2 = dyn_cast<arith::CmpIOp>(u.getOwner());
call    0 never executed
    #####: 3328:          if (!cmp2)
branch  0 never executed
branch  1 never executed
    #####: 3329:            continue;
        -: 3330:          // For a binary operator 1-opIdx gets the other side.
    #####: 3331:          if (cmp2.getOperand(1 - opIdx) != cmp.getOperand(1 - opIdx))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3332:            continue;
    #####: 3333:          bool samePredicate;
    #####: 3334:          if (cmp2.getPredicate() == cmp.getPredicate())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3335:            samePredicate = true;
    #####: 3336:          else if (cmp2.getPredicate() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3337:                   arith::invertPredicate(cmp.getPredicate()))
call    0 never executed
call    1 never executed
    #####: 3338:            samePredicate = false;
        -: 3339:          else
    #####: 3340:            continue;
        -: 3341:
    #####: 3342:          rewriter.replaceOpWithNewOp<arith::ConstantIntOp>(cmp2, samePredicate,
    #####: 3343:                                                            1);
call    0 never executed
    #####: 3344:          changed = true;
        -: 3345:        }
        -: 3346:      }
        -: 3347:    }
       12: 3348:    return success(changed);
        -: 3349:  }
        -: 3350:};
        -: 3351:
        -: 3352:struct WhileUnusedArg : public OpRewritePattern<WhileOp> {
        -: 3353:  using OpRewritePattern<WhileOp>::OpRewritePattern;
        -: 3354:
        -: 3355:  LogicalResult matchAndRewrite(WhileOp op,
        -: 3356:                                PatternRewriter &rewriter) const override {
        -: 3357:
        -: 3358:    if (!llvm::any_of(op.getBeforeArguments(),
        -: 3359:                      [](Value arg) { return arg.use_empty(); }))
        -: 3360:      return failure();
        -: 3361:
        -: 3362:    YieldOp yield = op.getYieldOp();
        -: 3363:
        -: 3364:    // Collect results mapping, new terminator args and new result types.
        -: 3365:    SmallVector<Value> newYields;
        -: 3366:    SmallVector<Value> newInits;
        -: 3367:    llvm::BitVector argsToErase(op.getBeforeArguments().size());
        -: 3368:    for (const auto &it : llvm::enumerate(llvm::zip(
        -: 3369:             op.getBeforeArguments(), yield.getOperands(), op.getInits()))) {
        -: 3370:      Value beforeArg = std::get<0>(it.value());
        -: 3371:      Value yieldValue = std::get<1>(it.value());
        -: 3372:      Value initValue = std::get<2>(it.value());
        -: 3373:      if (beforeArg.use_empty()) {
        -: 3374:        argsToErase.set(it.index());
        -: 3375:      } else {
        -: 3376:        newYields.emplace_back(yieldValue);
        -: 3377:        newInits.emplace_back(initValue);
        -: 3378:      }
        -: 3379:    }
        -: 3380:
        -: 3381:    if (argsToErase.none())
        -: 3382:      return failure();
        -: 3383:
        -: 3384:    rewriter.startRootUpdate(op);
        -: 3385:    op.getBefore().front().eraseArguments(argsToErase);
        -: 3386:    rewriter.finalizeRootUpdate(op);
        -: 3387:
        -: 3388:    WhileOp replacement =
        -: 3389:        rewriter.create<WhileOp>(op.getLoc(), op.getResultTypes(), newInits);
        -: 3390:    replacement.getBefore().takeBody(op.getBefore());
        -: 3391:    replacement.getAfter().takeBody(op.getAfter());
        -: 3392:    rewriter.replaceOp(op, replacement.getResults());
        -: 3393:
        -: 3394:    rewriter.setInsertionPoint(yield);
        -: 3395:    rewriter.replaceOpWithNewOp<YieldOp>(yield, newYields);
        -: 3396:    return success();
        -: 3397:  }
        -: 3398:};
        -: 3399:} // namespace
        -: 3400:
function _ZN4mlir3scf7WhileOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 1235 returned 100% blocks executed 100%
     1235: 3401:void WhileOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 3402:                                          MLIRContext *context) {
     1235: 3403:  results.add<RemoveLoopInvariantArgsFromBeforeBlock,
        -: 3404:              RemoveLoopInvariantValueYielded, WhileConditionTruth,
     1235: 3405:              WhileCmpCond, WhileUnusedResult>(context);
call    0 returned 100%
     1235: 3406:}
        -: 3407:
        -: 3408://===----------------------------------------------------------------------===//
        -: 3409:// IndexSwitchOp
        -: 3410://===----------------------------------------------------------------------===//
        -: 3411:
        -: 3412:/// Parse the case regions and values.
        -: 3413:static ParseResult
function _ZL16parseSwitchCasesRN4mlir11OpAsmParserERNS_6detail18DenseArrayAttrImplIlEERN4llvm15SmallVectorImplISt10unique_ptrINS_6RegionESt14default_deleteIS9_EEEE called 607616 returned 100% blocks executed 85%
   607616: 3414:parseSwitchCases(OpAsmParser &p, DenseI64ArrayAttr &cases,
        -: 3415:                 SmallVectorImpl<std::unique_ptr<Region>> &caseRegions) {
   607616: 3416:  SmallVector<int64_t> caseValues;
  2061143: 3417:  while (succeeded(p.parseOptionalKeyword("case"))) {
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
  1453527: 3418:    int64_t value;
  1453527: 3419:    Region &region =
  1453527: 3420:        *caseRegions.emplace_back(std::make_unique<Region>()).get();
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
 1453527*: 3421:    if (p.parseInteger(value) || p.parseRegion(region, /*arguments=*/{}))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 3422:      return failure();
  1453527: 3423:    caseValues.push_back(value);
call    0 returned 100%
        -: 3424:  }
   607616: 3425:  cases = p.getBuilder().getDenseI64ArrayAttr(caseValues);
call    0 returned 100%
call    1 returned 100%
   607616: 3426:  return success();
        -: 3427:}
        -: 3428:
        -: 3429:/// Print the case regions and values.
        -: 3430:static void printSwitchCases(OpAsmPrinter &p, Operation *op,
        -: 3431:                             DenseI64ArrayAttr cases, RegionRange caseRegions) {
        -: 3432:  for (auto [value, region] : llvm::zip(cases.asArrayRef(), caseRegions)) {
        -: 3433:    p.printNewline();
        -: 3434:    p << "case " << value << ' ';
        -: 3435:    p.printRegion(*region, /*printEntryBlockArgs=*/false);
        -: 3436:  }
        -: 3437:}
        -: 3438:
function _ZN4mlir3scf13IndexSwitchOp6verifyEv called 25854095 returned 100% blocks executed 58%
 25854095: 3439:LogicalResult scf::IndexSwitchOp::verify() {
 51708190: 3440:  if (getCases().size() != getCaseRegions().size()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 3441:    return emitOpError("has ")
call    0 never executed
call    1 never executed
    #####: 3442:           << getCaseRegions().size() << " case regions but "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3443:           << getCases().size() << " case values";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3444:  }
        -: 3445:
 25854095: 3446:  DenseSet<int64_t> valueSet;
call    0 returned 100%
114353136: 3447:  for (int64_t value : getCases())
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
 62644946: 3448:    if (!valueSet.insert(value).second)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3449:      return emitOpError("has duplicate case value: ") << value;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3450:
function _ZZN4mlir3scf13IndexSwitchOp6verifyEvENKUlRNS_6RegionERKN4llvm5TwineEE_clES3_S7_.isra.0 called 88499041 returned 100% blocks executed 40%
114353136: 3451:  auto verifyRegion = [&](Region &region, const Twine &name) -> LogicalResult {
 88499041: 3452:    auto yield = cast<YieldOp>(region.front().getTerminator());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
88499041*: 3453:    if (yield.getNumOperands() != getNumResults()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    #####: 3454:      return (emitOpError("expected each region to return ")
call    0 never executed
call    1 never executed
    #####: 3455:              << getNumResults() << " values, but " << name << " returns "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3456:              << yield.getNumOperands())
call    0 never executed
call    1 never executed
    #####: 3457:                 .attachNote(yield.getLoc())
call    0 never executed
call    1 never executed
    #####: 3458:             << "see yield operation here";
call    0 never executed
call    1 never executed
        -: 3459:    }
132299475: 3460:    for (auto [idx, result, operand] :
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 88499041: 3461:         llvm::zip(llvm::seq<unsigned>(0, getNumResults()), getResultTypes(),
call    0 returned 100%
264598950: 3462:                   yield.getOperandTypes())) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 33% (fallthrough)
branch  3 taken 67%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
 43800434: 3463:      if (result == operand)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 43800434: 3464:        continue;
call    0 returned 100%
    #####: 3465:      return (emitOpError("expected result #")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3466:              << idx << " of each region to be " << result)
call    0 never executed
call    1 never executed
    #####: 3467:                 .attachNote(yield.getLoc())
call    0 never executed
call    1 never executed
    #####: 3468:             << name << " returns " << operand << " here";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3469:    }
 88499041: 3470:    return success();
 25854095: 3471:  };
        -: 3472:
 25854095: 3473:  if (failed(verifyRegion(getDefaultRegion(), "default region")))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 3474:    return failure();
 88499041: 3475:  for (auto &[idx, caseRegion] : llvm::enumerate(getCaseRegions()))
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
call    3 returned 100%
call    4 returned 100%
 62644946: 3476:    if (failed(verifyRegion(caseRegion, "case region #" + Twine(idx))))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 3477:      return failure();
        -: 3478:
 25854095: 3479:  return success();
call    0 returned 100%
        -: 3480:}
        -: 3481:
function _ZN4mlir3scf13IndexSwitchOp11getNumCasesEv called 0 returned 0% blocks executed 0%
    #####: 3482:unsigned scf::IndexSwitchOp::getNumCases() { return getCases().size(); }
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 3483:
function _ZN4mlir3scf13IndexSwitchOp15getDefaultBlockEv called 0 returned 0% blocks executed 0%
    #####: 3484:Block &scf::IndexSwitchOp::getDefaultBlock() {
    #####: 3485:  return getDefaultRegion().front();
call    0 never executed
call    1 never executed
        -: 3486:}
        -: 3487:
function _ZN4mlir3scf13IndexSwitchOp12getCaseBlockEj called 0 returned 0% blocks executed 0%
    #####: 3488:Block &scf::IndexSwitchOp::getCaseBlock(unsigned idx) {
    #####: 3489:  assert(idx < getNumCases() && "case index out-of-bounds");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3490:  return getCaseRegions()[idx].front();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3491:}
        -: 3492:
function _ZN4mlir3scf13IndexSwitchOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 114447961 returned 100% blocks executed 97%
114447961: 3493:void IndexSwitchOp::getSuccessorRegions(
        -: 3494:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -: 3495:    SmallVectorImpl<RegionSuccessor> &successors) {
        -: 3496:  // All regions branch back to the parent op.
114447961: 3497:  if (index) {
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
 88571772: 3498:    successors.emplace_back(getResults());
call    0 returned 100%
call    1 returned 100%
114445067: 3499:    return;
        -: 3500:  }
        -: 3501:
        -: 3502:  // If a constant was not provided, all regions are possible successors.
 25876189: 3503:  auto operandValue = operands.front().dyn_cast_or_null<IntegerAttr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
 25876189: 3504:  if (!operandValue) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
 88567901: 3505:    for (Region &caseRegion : getCaseRegions())
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
 62694879: 3506:      successors.emplace_back(&caseRegion);
call    0 returned 100%
 25873022: 3507:    successors.emplace_back(&getDefaultRegion());
call    0 returned 100%
call    1 returned 100%
 25873022: 3508:    return;
        -: 3509:  }
        -: 3510:
        -: 3511:  // Otherwise, try to find a case with a matching value. If not, the default
        -: 3512:  // region is the only successor.
    12749: 3513:  for (auto [caseValue, caseRegion] : llvm::zip(getCases(), getCaseRegions())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 70% (fallthrough)
branch  3 taken 30%
call    4 returned 100%
     6688: 3514:    if (caseValue == operandValue.getInt()) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
      273: 3515:      successors.emplace_back(&caseRegion);
call    0 returned 100%
      273: 3516:      return;
        -: 3517:    }
        -: 3518:  }
     2894: 3519:  successors.emplace_back(&getDefaultRegion());
call    0 returned 100%
call    1 returned 100%
        -: 3520:}
        -: 3521:
function _ZN4mlir3scf13IndexSwitchOp25getRegionInvocationBoundsEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_16InvocationBoundsEEE called 2844 returned 100% blocks executed 96%
     2844: 3522:void IndexSwitchOp::getRegionInvocationBounds(
        -: 3523:    ArrayRef<Attribute> operands, SmallVectorImpl<InvocationBounds> &bounds) {
     2844: 3524:  auto operandValue = operands.front().dyn_cast_or_null<IntegerAttr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 59% (fallthrough)
branch  3 taken 41%
     2844: 3525:  if (!operandValue) {
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -: 3526:    // All regions are invoked at most once.
     1171: 3527:    bounds.append(getNumRegions(), InvocationBounds(/*lb=*/0, /*ub=*/1));
call    0 returned 100%
     1171: 3528:    return;
        -: 3529:  }
        -: 3530:
     1673: 3531:  unsigned liveIndex = getNumRegions() - 1;
call    0 returned 100%
     3346: 3532:  auto it = llvm::find(getCases(), operandValue.getInt());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3346: 3533:  if (it != getCases().end())
call    0 returned 100%
branch  1 taken 13% (fallthrough)
branch  2 taken 87%
      448: 3534:    liveIndex = std::distance(getCases().begin(), it);
call    0 returned 100%
     7355: 3535:  for (unsigned i = 0, e = getNumRegions(); i < e; ++i)
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
     5682: 3536:    bounds.emplace_back(/*lb=*/0, /*ub=*/i == liveIndex);
call    0 returned 100%
        -: 3537:}
        -: 3538:
        -: 3539://===----------------------------------------------------------------------===//
        -: 3540:// TableGen'd op method definitions
        -: 3541://===----------------------------------------------------------------------===//
        -: 3542:
        -: 3543:#define GET_OP_CLASSES
        -: 3544:#include "mlir/Dialect/SCF/IR/SCFOps.cpp.inc"
