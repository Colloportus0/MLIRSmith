        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/include/mlir/Dialect/CommonFolders.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcda
        -:    0:Runs:116157
        -:    1://===- CommonFolders.h - Common Operation Folders----------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This header file declares various common operation folders. These folders
        -:   10:// are intended to be used by dialects to support common folding behavior
        -:   11:// without requiring each dialect to provide its own implementation.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef MLIR_DIALECT_COMMONFOLDERS_H
        -:   16:#define MLIR_DIALECT_COMMONFOLDERS_H
        -:   17:
        -:   18:#include "mlir/IR/BuiltinAttributes.h"
        -:   19:#include "mlir/IR/BuiltinTypes.h"
        -:   20:#include "llvm/ADT/ArrayRef.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:
        -:   23:namespace mlir {
        -:   24:/// Performs constant folding `calculate` with element-wise behavior on the two
        -:   25:/// attributes in `operands` and returns the result if possible.
        -:   26:template <
        -:   27:    class AttrElementT, class ElementValueT = typename AttrElementT::ValueType,
        -:   28:    class CalculationT =
        -:   29:        function_ref<Optional<ElementValueT>(ElementValueT, ElementValueT)>>
 1338891*:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
 1338891*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
 1338891*:   33:  if (!operands[0] || !operands[1])
  367735*:   34:    return {};
        -:   35:
  971156*:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
  971156*:   37:    auto lhs = operands[0].cast<AttrElementT>();
  971156*:   38:    auto rhs = operands[1].cast<AttrElementT>();
  971156*:   39:    if (lhs.getType() != rhs.getType())
    #####:   40:      return {};
        -:   41:
 1942312*:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
        -:   43:
  971156*:   44:    if (!calRes)
    #####:   45:      return {};
        -:   46:
  971156*:   47:    return AttrElementT::get(lhs.getType(), *calRes);
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
    #####:   56:    if (lhs.getType() != rhs.getType())
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
    #####:   66:             operands[1].isa<ElementsAttr>()) {
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
    #####:   71:    if (lhs.getType() != rhs.getType())
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
    #####:   77:    elementResults.reserve(lhs.getNumElements());
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
    #####:   80:      if (!elementResult)
    #####:   81:        return {};
    #####:   82:      elementResults.push_back(*elementResult);
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 197772 returned 100% blocks executed 24%
   197772:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  197772*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   197772:   33:  if (!operands[0] || !operands[1])
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    47451:   34:    return {};
        -:   35:
   150321:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   150321:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   150321:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   150321:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   300642:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   150321:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   150321:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 138652 returned 100% blocks executed 24%
   138652:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  138652*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   138652:   33:  if (!operands[0] || !operands[1])
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
    33454:   34:    return {};
        -:   35:
   105198:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   105198:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   105198:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   105198:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   210396:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   105198:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   105198:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 161217 returned 100% blocks executed 24%
   161217:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  161217*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   161217:   33:  if (!operands[0] || !operands[1])
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    40891:   34:    return {};
        -:   35:
   120326:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   120326:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   120326:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   120326:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   240652:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   120326:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   120326:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 142662 returned 100% blocks executed 24%
   142662:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  142662*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   142662:   33:  if (!operands[0] || !operands[1])
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
branch  2 taken 15% (fallthrough)
branch  3 taken 85%
    49231:   34:    return {};
        -:   35:
    93431:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    93431:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
    93431:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
    93431:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   186862:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
    93431:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
    93431:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 149008 returned 100% blocks executed 24%
   149008:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  149008*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   149008:   33:  if (!operands[0] || !operands[1])
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 16% (fallthrough)
branch  3 taken 84%
    45690:   34:    return {};
        -:   35:
   103318:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   103318:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   103318:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   103318:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   206636:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   103318:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   103318:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 110609 returned 100% blocks executed 24%
   110609:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  110609*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   110609:   33:  if (!operands[0] || !operands[1])
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
    29660:   34:    return {};
        -:   35:
    80949:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    80949:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
    80949:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
    80949:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   161898:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
    80949:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
    80949:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 165998 returned 100% blocks executed 24%
   165998:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  165998*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   165998:   33:  if (!operands[0] || !operands[1])
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
    44427:   34:    return {};
        -:   35:
   121571:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   121571:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   121571:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   121571:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   243142:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   121571:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   121571:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 163448 returned 100% blocks executed 24%
   163448:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  163448*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   163448:   33:  if (!operands[0] || !operands[1])
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
    42694:   34:    return {};
        -:   35:
   120754:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
   120754:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
   120754:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
   120754:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   241508:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
   120754:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
   120754:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 109525 returned 100% blocks executed 24%
   109525:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
  109525*:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   109525:   33:  if (!operands[0] || !operands[1])
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
    34237:   34:    return {};
        -:   35:
    75288:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    75288:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 returned 100%
    75288:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 returned 100%
    75288:   39:    if (lhs.getType() != rhs.getType())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   40:      return {};
        -:   41:
   150576:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
        -:   43:
    75288:   44:    if (!calRes)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:      return {};
        -:   46:
    75288:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 returned 100%
call    1 returned 100%
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
        -:   89:
        -:   90:template <class AttrElementT,
        -:   91:          class ElementValueT = typename AttrElementT::ValueType,
        -:   92:          class CalculationT =
        -:   93:              function_ref<ElementValueT(ElementValueT, ElementValueT)>>
 3763087*:   94:Attribute constFoldBinaryOp(ArrayRef<Attribute> operands,
        -:   95:                            const CalculationT &calculate) {
 3763087*:   96:  return constFoldBinaryOpConditional<AttrElementT>(
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
call    3 returned 100%
branch  4 taken 69% (fallthrough)
branch  5 taken 31%
call    6 returned 100%
branch  7 taken 72% (fallthrough)
branch  8 taken 28%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
call   14 returned 100%
call   15 returned 100%
call   16 returned 100%
call   17 returned 100%
call   18 never executed
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
branch 24 taken 83% (fallthrough)
branch 25 taken 17%
call   26 returned 100%
branch 27 taken 79% (fallthrough)
branch 28 taken 21%
call   29 returned 100%
branch 30 taken 80% (fallthrough)
branch 31 taken 20%
call   32 returned 100%
branch 33 taken 76% (fallthrough)
branch 34 taken 24%
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 returned 100%
branch 39 taken 74% (fallthrough)
branch 40 taken 26%
call   41 returned 100%
branch 42 taken 84% (fallthrough)
branch 43 taken 16%
call   44 returned 100%
call   45 returned 100%
call   46 never executed
call   47 returned 100%
        -:   97:      operands,
 2371349*:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6XOrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6XOrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 49213 returned 100% blocks executed 62%
    49213:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AddIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AddIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 97571 returned 100% blocks executed 62%
    97571:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12AddUICarryOp4foldENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12AddUICarryOp4foldENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6SubIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6SubIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 66918 returned 100% blocks executed 62%
    66918:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6MulIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6MulIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 77773 returned 100% blocks executed 100%
    77773:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 75288 returned 100% blocks executed 62%
    75288:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 120754 returned 100% blocks executed 62%
   120754:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 121571 returned 100% blocks executed 62%
   121571:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 80949 returned 100% blocks executed 62%
    80949:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 103318 returned 100% blocks executed 62%
   103318:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 93431 returned 100% blocks executed 62%
    93431:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AndIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AndIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 82605 returned 100% blocks executed 62%
    82605:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith5OrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith5OrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 79397 returned 100% blocks executed 62%
    79397:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MinFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MinFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 73297 returned 100% blocks executed 100%
    73297:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 59602 returned 100% blocks executed 100%
    59602:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 53296 returned 100% blocks executed 100%
    53296:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 46181 returned 100% blocks executed 100%
    46181:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 45630 returned 100% blocks executed 100%
    45630:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 120326 returned 100% blocks executed 100%
   120326:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 105198 returned 100% blocks executed 100%
   105198:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 150321 returned 100% blocks executed 100%
   150321:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6AddFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6AddFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 119033 returned 100% blocks executed 100%
   119033:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6SubFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6SubFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MulFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MulFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 109446 returned 100% blocks executed 100%
   109446:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6DivFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6DivFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 108369 returned 100% blocks executed 100%
   108369:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6RemFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6RemFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 242514 returned 100% blocks executed 100%
   242514:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MaxFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MaxFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 89348 returned 100% blocks executed 100%
    89348:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
 2950711*:   99:        return calculate(a, b);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 never executed
call   14 never executed
call   15 never executed
call   16 returned 100%
call   17 returned 100%
call   18 returned 100%
call   19 returned 100%
call   20 returned 100%
call   21 returned 100%
call   22 returned 100%
call   23 returned 100%
call   24 returned 100%
call   25 returned 100%
call   26 returned 100%
branch 27 taken 0% (fallthrough)
branch 28 taken 100%
call   29 returned 100%
branch 30 taken 0% (fallthrough)
branch 31 taken 100%
call   32 returned 100%
branch 33 taken 0% (fallthrough)
branch 34 taken 100%
call   35 returned 100%
branch 36 taken 0% (fallthrough)
branch 37 taken 100%
call   38 returned 100%
branch 39 taken 0% (fallthrough)
branch 40 taken 100%
call   41 returned 100%
branch 42 taken 0% (fallthrough)
branch 43 taken 100%
call   44 returned 100%
branch 45 taken 0% (fallthrough)
branch 46 taken 100%
call   47 never executed
branch 48 never executed
branch 49 never executed
call   50 returned 100%
branch 51 taken 0% (fallthrough)
branch 52 taken 100%
call   53 returned 100%
branch 54 taken 0% (fallthrough)
branch 55 taken 100%
call   56 returned 100%
call   57 returned 100%
branch 58 taken 0% (fallthrough)
branch 59 taken 100%
call   60 never executed
branch 61 never executed
branch 62 never executed
call   63 returned 100%
branch 64 taken 0% (fallthrough)
branch 65 taken 100%
        -:  100:      });
        -:  101:}
        -:  102:
        -:  103:/// Performs constant folding `calculate` with element-wise behavior on the one
        -:  104:/// attributes in `operands` and returns the result if possible.
        -:  105:template <
        -:  106:    class AttrElementT, class ElementValueT = typename AttrElementT::ValueType,
        -:  107:    class CalculationT = function_ref<Optional<ElementValueT>(ElementValueT)>>
        -:  108:Attribute constFoldUnaryOpConditional(ArrayRef<Attribute> operands,
        -:  109:                                      const CalculationT &&calculate) {
        -:  110:  assert(operands.size() == 1 && "unary op takes one operands");
        -:  111:  if (!operands[0])
        -:  112:    return {};
        -:  113:
        -:  114:  if (operands[0].isa<AttrElementT>()) {
        -:  115:    auto op = operands[0].cast<AttrElementT>();
        -:  116:
        -:  117:    auto res = calculate(op.getValue());
        -:  118:    if (!res)
        -:  119:      return {};
        -:  120:    return AttrElementT::get(op.getType(), *res);
        -:  121:  }
        -:  122:  if (operands[0].isa<SplatElementsAttr>()) {
        -:  123:    // Both operands are splats so we can avoid expanding the values out and
        -:  124:    // just fold based on the splat value.
        -:  125:    auto op = operands[0].cast<SplatElementsAttr>();
        -:  126:
        -:  127:    auto elementResult = calculate(op.getSplatValue<ElementValueT>());
        -:  128:    if (!elementResult)
        -:  129:      return {};
        -:  130:    return DenseElementsAttr::get(op.getType(), *elementResult);
        -:  131:  } else if (operands[0].isa<ElementsAttr>()) {
        -:  132:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:  133:    // expanding the values.
        -:  134:    auto op = operands[0].cast<ElementsAttr>();
        -:  135:
        -:  136:    auto opIt = op.value_begin<ElementValueT>();
        -:  137:    SmallVector<ElementValueT> elementResults;
        -:  138:    elementResults.reserve(op.getNumElements());
        -:  139:    for (size_t i = 0, e = op.getNumElements(); i < e; ++i, ++opIt) {
        -:  140:      auto elementResult = calculate(*opIt);
        -:  141:      if (!elementResult)
        -:  142:        return {};
        -:  143:      elementResults.push_back(*elementResult);
        -:  144:    }
        -:  145:    return DenseElementsAttr::get(op.getType(), elementResults);
        -:  146:  }
        -:  147:  return {};
        -:  148:}
        -:  149:
        -:  150:template <class AttrElementT,
        -:  151:          class ElementValueT = typename AttrElementT::ValueType,
        -:  152:          class CalculationT = function_ref<ElementValueT(ElementValueT)>>
   168981:  153:Attribute constFoldUnaryOp(ArrayRef<Attribute> operands,
        -:  154:                           const CalculationT &&calculate) {
   168981:  155:  return constFoldUnaryOpConditional<AttrElementT>(
call    0 returned 100%
        -:  156:      operands,
function _ZZN4mlir16constFoldUnaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6NegFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_E_EES7_S8_OKT1_ENKUlS3_E_clES3_.isra.0 called 135648 returned 100% blocks executed 100%
   271296:  157:      [&](ElementValueT a) -> Optional<ElementValueT> { return calculate(a); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  158:}
        -:  159:
        -:  160:template <
        -:  161:    class AttrElementT, class TargetAttrElementT,
        -:  162:    class ElementValueT = typename AttrElementT::ValueType,
        -:  163:    class TargetElementValueT = typename TargetAttrElementT::ValueType,
        -:  164:    class CalculationT = function_ref<TargetElementValueT(ElementValueT, bool)>>
 1493185*:  165:Attribute constFoldCastOp(ArrayRef<Attribute> operands, Type resType,
        -:  166:                          const CalculationT &calculate) {
 1493185*:  167:  assert(operands.size() == 1 && "Cast op takes one operand");
 1493185*:  168:  if (!operands[0])
 1487184*:  169:    return {};
        -:  170:
    6001*:  171:  if (operands[0].isa<AttrElementT>()) {
    6001*:  172:    auto op = operands[0].cast<AttrElementT>();
    6001*:  173:    bool castStatus = true;
   12002*:  174:    auto res = calculate(op.getValue(), castStatus);
     413*:  175:    if (!castStatus)
    #####:  176:      return {};
    6001*:  177:    return TargetAttrElementT::get(resType, res);
        -:  178:  }
    #####:  179:  if (operands[0].isa<SplatElementsAttr>()) {
        -:  180:    // The operand is a splat so we can avoid expanding the values out and
        -:  181:    // just fold based on the splat value.
    #####:  182:    auto op = operands[0].cast<SplatElementsAttr>();
    #####:  183:    bool castStatus = true;
    #####:  184:    auto elementResult =
        -:  185:        calculate(op.getSplatValue<ElementValueT>(), castStatus);
    #####:  186:    if (!castStatus)
    #####:  187:      return {};
    #####:  188:    return DenseElementsAttr::get(resType, elementResult);
        -:  189:  }
    #####:  190:  if (operands[0].isa<ElementsAttr>()) {
        -:  191:    // Operand is ElementsAttr-derived; perform an element-wise fold by
        -:  192:    // expanding the value.
    #####:  193:    auto op = operands[0].cast<ElementsAttr>();
    #####:  194:    bool castStatus = true;
    #####:  195:    auto opIt = op.value_begin<ElementValueT>();
    #####:  196:    SmallVector<TargetElementValueT> elementResults;
    #####:  197:    elementResults.reserve(op.getNumElements());
    #####:  198:    for (size_t i = 0, e = op.getNumElements(); i < e; ++i, ++opIt) {
    #####:  199:      auto elt = calculate(*opIt, castStatus);
    #####:  200:      if (!castStatus)
    #####:  201:        return {};
    #####:  202:      elementResults.push_back(elt);
        -:  203:    }
        -:  204:
    #####:  205:    return DenseElementsAttr::get(resType, elementResults);
        -:  206:  }
    #####:  207:  return {};
        -:  208:}
        -:  209:
        -:  210:} // namespace mlir
        -:  211:
        -:  212:#endif // MLIR_DIALECT_COMMONFOLDERS_H
