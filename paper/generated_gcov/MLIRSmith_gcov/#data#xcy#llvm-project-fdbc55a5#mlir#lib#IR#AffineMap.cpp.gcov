        -:    0:Source:/data/xcy/llvm-project-fdbc55a5/mlir/lib/IR/AffineMap.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineMap.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineMap.cpp.gcda
        -:    0:Runs:116163
        -:    1://===- AffineMap.cpp - MLIR Affine Map Classes ----------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/AffineMap.h"
        -:   10:#include "AffineMapDetail.h"
        -:   11:#include "mlir/IR/BuiltinAttributes.h"
        -:   12:#include "mlir/IR/BuiltinTypes.h"
        -:   13:#include "mlir/Support/LogicalResult.h"
        -:   14:#include "mlir/Support/MathExtras.h"
        -:   15:#include "llvm/ADT/SmallBitVector.h"
        -:   16:#include "llvm/ADT/SmallSet.h"
        -:   17:#include "llvm/ADT/StringRef.h"
        -:   18:#include "llvm/Support/raw_ostream.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23:namespace {
        -:   24:
        -:   25:// AffineExprConstantFolder evaluates an affine expression using constant
        -:   26:// operands passed in 'operandConsts'. Returns an IntegerAttr attribute
        -:   27:// representing the constant value of the affine expression evaluated on
        -:   28:// constant 'operandConsts', or nullptr if it can't be folded.
        -:   29:class AffineExprConstantFolder {
        -:   30:public:
   680621:   31:  AffineExprConstantFolder(unsigned numDims, ArrayRef<Attribute> operandConsts)
   680621:   32:      : numDims(numDims), operandConsts(operandConsts) {}
        -:   33:
        -:   34:  /// Attempt to constant fold the specified affine expr, or return null on
        -:   35:  /// failure.
function _ZN12_GLOBAL__N_124AffineExprConstantFolder12constantFoldEN4mlir10AffineExprE called 1416609 returned 100% blocks executed 100%
  1416609:   36:  IntegerAttr constantFold(AffineExpr expr) {
  1416609:   37:    if (auto result = constantFoldImpl(expr))
call    0 returned 100%
branch  1 taken 58% (fallthrough)
branch  2 taken 42%
   827244:   38:      return IntegerAttr::get(IndexType::get(expr.getContext()), *result);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   589365:   39:    return nullptr;
        -:   40:  }
        -:   41:
        -:   42:private:
function _ZN12_GLOBAL__N_124AffineExprConstantFolder16constantFoldImplEN4mlir10AffineExprE called 5028414 returned 100% blocks executed 91%
  5028414:   43:  Optional<int64_t> constantFoldImpl(AffineExpr expr) {
  5028414:   44:    switch (expr.getKind()) {
call    0 returned 100%
branch  1 taken 18%
branch  2 taken 12%
branch  3 taken 5%
branch  4 taken 5%
branch  5 taken 5%
branch  6 taken 25%
branch  7 taken 29%
branch  8 taken 1%
branch  9 taken 0%
   911451:   45:    case AffineExprKind::Add:
   911451:   46:      return constantFoldBinExpr(
   911451:   47:          expr, [](int64_t lhs, int64_t rhs) { return lhs + rhs; });
call    0 returned 100%
   626056:   48:    case AffineExprKind::Mul:
   626056:   49:      return constantFoldBinExpr(
   626056:   50:          expr, [](int64_t lhs, int64_t rhs) { return lhs * rhs; });
call    0 returned 100%
   263807:   51:    case AffineExprKind::Mod:
   263807:   52:      return constantFoldBinExpr(
   263807:   53:          expr, [](int64_t lhs, int64_t rhs) { return mod(lhs, rhs); });
call    0 returned 100%
   232274:   54:    case AffineExprKind::FloorDiv:
   232274:   55:      return constantFoldBinExpr(
   232274:   56:          expr, [](int64_t lhs, int64_t rhs) { return floorDiv(lhs, rhs); });
call    0 returned 100%
   249891:   57:    case AffineExprKind::CeilDiv:
   249891:   58:      return constantFoldBinExpr(
   249891:   59:          expr, [](int64_t lhs, int64_t rhs) { return ceilDiv(lhs, rhs); });
call    0 returned 100%
  1267555:   60:    case AffineExprKind::Constant:
  1267555:   61:      return expr.cast<AffineConstantExpr>().getValue();
call    0 returned 100%
call    1 returned 100%
  1476135:   62:    case AffineExprKind::DimId:
  1476135:   63:      if (auto attr = operandConsts[expr.cast<AffineDimExpr>().getPosition()]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 60% (fallthrough)
branch  5 taken 40%
  1476135:   64:                          .dyn_cast_or_null<IntegerAttr>())
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
   887945:   65:        return attr.getInt();
call    0 returned 100%
   588190:   66:      return llvm::None;
     1245:   67:    case AffineExprKind::SymbolId:
     1245:   68:      if (auto attr = operandConsts[numDims +
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
     1245:   69:                                    expr.cast<AffineSymbolExpr>().getPosition()]
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 6% (fallthrough)
branch  5 taken 94%
     1245:   70:                          .dyn_cast_or_null<IntegerAttr>())
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       70:   71:        return attr.getInt();
call    0 returned 100%
     1175:   72:      return llvm::None;
        -:   73:    }
    #####:   74:    llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:   75:  }
        -:   76:
        -:   77:  // TODO: Change these to operate on APInts too.
function _ZN12_GLOBAL__N_124AffineExprConstantFolder19constantFoldBinExprEN4mlir10AffineExprEPFlllE called 2283479 returned 100% blocks executed 100%
  2283479:   78:  Optional<int64_t> constantFoldBinExpr(AffineExpr expr,
        -:   79:                                        int64_t (*op)(int64_t, int64_t)) {
  2283479:   80:    auto binOpExpr = expr.cast<AffineBinaryOpExpr>();
call    0 returned 100%
  2283479:   81:    if (auto lhs = constantFoldImpl(binOpExpr.getLHS()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 58% (fallthrough)
branch  3 taken 42%
  1328326:   82:      if (auto rhs = constantFoldImpl(binOpExpr.getRHS()))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
  1283506:   83:        return op(*lhs, *rhs);
call    0 returned 100%
   999973:   84:    return llvm::None;
        -:   85:  }
        -:   86:
        -:   87:  // The number of dimension operands in AffineMap containing this expression.
        -:   88:  unsigned numDims;
        -:   89:  // The constant valued operands used to evaluate this AffineExpr.
        -:   90:  ArrayRef<Attribute> operandConsts;
        -:   91:};
        -:   92:
        -:   93:} // namespace
        -:   94:
        -:   95:/// Returns a single constant result affine map.
function _ZN4mlir9AffineMap14getConstantMapElPNS_11MLIRContextE called 8476 returned 100% blocks executed 100%
     8476:   96:AffineMap AffineMap::getConstantMap(int64_t val, MLIRContext *context) {
     8476:   97:  return get(/*dimCount=*/0, /*symbolCount=*/0,
     8476:   98:             {getAffineConstantExpr(val, context)});
call    0 returned 100%
call    1 returned 100%
        -:   99:}
        -:  100:
        -:  101:/// Returns an identity affine map (d0, ..., dn) -> (dp, ..., dn) on the most
        -:  102:/// minor dimensions.
function _ZN4mlir9AffineMap19getMinorIdentityMapEjjPNS_11MLIRContextE called 5886223 returned 100% blocks executed 78%
  5886223:  103:AffineMap AffineMap::getMinorIdentityMap(unsigned dims, unsigned results,
        -:  104:                                         MLIRContext *context) {
 5886223*:  105:  assert(dims >= results && "Dimension mismatch");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  5886223:  106:  auto id = AffineMap::getMultiDimIdentityMap(dims, context);
call    0 returned 100%
 11772446:  107:  return AffineMap::get(dims, 0, id.getResults().take_back(results), context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  108:}
        -:  109:
function _ZNK4mlir9AffineMap15isMinorIdentityEv called 3866984 returned 100% blocks executed 82%
  3866984:  110:bool AffineMap::isMinorIdentity() const {
  7733968:  111:  return getNumDims() >= getNumResults() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
  3866984:  112:         *this ==
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
  3866984:  113:             getMinorIdentityMap(getNumDims(), getNumResults(), getContext());
        -:  114:}
        -:  115:
        -:  116:/// Returns true if this affine map is a minor identity up to broadcasted
        -:  117:/// dimensions which are indicated by value 0 in the result.
function _ZNK4mlir9AffineMap31isMinorIdentityWithBroadcastingEPN4llvm15SmallVectorImplIjEE called 4651 returned 100% blocks executed 93%
     4651:  118:bool AffineMap::isMinorIdentityWithBroadcasting(
        -:  119:    SmallVectorImpl<unsigned> *broadcastedDims) const {
     4651:  120:  if (broadcastedDims)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     4651:  121:    broadcastedDims->clear();
     4651:  122:  if (getNumDims() < getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  123:    return false;
    13953:  124:  unsigned suffixStart = getNumDims() - getNumResults();
     5738:  125:  for (const auto &idxAndExpr : llvm::enumerate(getResults())) {
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
call    3 returned 100%
     1468:  126:    unsigned resIdx = idxAndExpr.index();
call    0 returned 100%
     1468:  127:    AffineExpr expr = idxAndExpr.value();
call    0 returned 100%
     1468:  128:    if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
        -:  129:      // Each result may be either a constant 0 (broadcasted dimension).
      378:  130:      if (constExpr.getValue() != 0)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      381:  131:        return false;
      378:  132:      if (broadcastedDims)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      378:  133:        broadcastedDims->push_back(resIdx);
call    0 returned 100%
     1090:  134:    } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  135:      // Or it may be the input dimension corresponding to this result position.
     1090:  136:      if (dimExpr.getPosition() != suffixStart + resIdx)
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
      381:  137:        return false;
        -:  138:    } else {
        -:  139:      return false;
        -:  140:    }
        -:  141:  }
     4270:  142:  return true;
        -:  143:}
        -:  144:
        -:  145:/// Return true if this affine map can be converted to a minor identity with
        -:  146:/// broadcast by doing a permute. Return a permutation (there may be
        -:  147:/// several) to apply to get to a minor identity with broadcasts.
        -:  148:/// Ex:
        -:  149:///  * (d0, d1, d2) -> (0, d1) maps to minor identity (d1, 0 = d2) with
        -:  150:///  perm = [1, 0] and broadcast d2
        -:  151:///  * (d0, d1, d2) -> (d0, 0) cannot be mapped to a minor identity by
        -:  152:///  permutation + broadcast
        -:  153:///  * (d0, d1, d2, d3) -> (0, d1, d3) maps to minor identity (d1, 0 = d2, d3)
        -:  154:///  with perm = [1, 0, 2] and broadcast d2
        -:  155:///  * (d0, d1) -> (d1, 0, 0, d0) maps to minor identity (d0, d1) with extra
        -:  156:///  leading broadcat dimensions. The map returned would be (0, 0, d0, d1) with
        -:  157:///  perm = [3, 0, 1, 2]
function _ZNK4mlir9AffineMap44isPermutationOfMinorIdentityWithBroadcastingERN4llvm15SmallVectorImplIjEE called 1190 returned 100% blocks executed 49%
     1190:  158:bool AffineMap::isPermutationOfMinorIdentityWithBroadcasting(
        -:  159:    SmallVectorImpl<unsigned> &permutedDims) const {
     1190:  160:  unsigned projectionStart =
     2380:  161:      getNumResults() < getNumInputs() ? getNumInputs() - getNumResults() : 0;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1190:  162:  permutedDims.clear();
call    0 returned 100%
     1190:  163:  SmallVector<unsigned> broadcastDims;
call    0 returned 100%
     1190:  164:  permutedDims.resize(getNumResults(), 0);
        -:  165:  // If there are more results than input dimensions we want the new map to
        -:  166:  // start with broadcast dimensions in order to be a minor identity with
        -:  167:  // broadcasting.
     1190:  168:  unsigned leadingBroadcast =
    1190*:  169:      getNumResults() > getNumInputs() ? getNumResults() - getNumInputs() : 0;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     1190:  170:  llvm::SmallBitVector dimFound(std::max(getNumInputs(), getNumResults()),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2380:  171:                                false);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    1190*:  172:  for (const auto &idxAndExpr : llvm::enumerate(getResults())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
     1190:  173:    unsigned resIdx = idxAndExpr.index();
call    0 returned 100%
     1190:  174:    AffineExpr expr = idxAndExpr.value();
call    0 returned 100%
        -:  175:    // Each result may be either a constant 0 (broadcast dimension) or a
        -:  176:    // dimension.
     1190:  177:    if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  178:      if (constExpr.getValue() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
     1190:  179:        return false;
    #####:  180:      broadcastDims.push_back(resIdx);
call    0 never executed
     1190:  181:    } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1190:  182:      if (dimExpr.getPosition() < projectionStart)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     1190:  183:        return false;
    #####:  184:      unsigned newPosition =
    #####:  185:          dimExpr.getPosition() - projectionStart + leadingBroadcast;
call    0 never executed
    #####:  186:      permutedDims[resIdx] = newPosition;
branch  0 never executed
branch  1 never executed
    #####:  187:      dimFound[newPosition] = true;
call    0 never executed
call    1 never executed
        -:  188:    } else {
        -:  189:      return false;
        -:  190:    }
        -:  191:  }
        -:  192:  // Find a permuation for the broadcast dimension. Since they are broadcasted
        -:  193:  // any valid permutation is acceptable. We just permute the dim into a slot
        -:  194:  // without an existing dimension.
    #####:  195:  unsigned pos = 0;
    #####:  196:  for (auto dim : broadcastDims) {
branch  0 never executed
branch  1 never executed
    #####:  197:    while (pos < dimFound.size() && dimFound[pos]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  198:      pos++;
        -:  199:    }
    #####:  200:    permutedDims[dim] = pos++;
branch  0 never executed
branch  1 never executed
        -:  201:  }
        -:  202:  return true;
        -:  203:}
        -:  204:
        -:  205:/// Returns an AffineMap representing a permutation.
function _ZN4mlir9AffineMap17getPermutationMapEN4llvm8ArrayRefIjEEPNS_11MLIRContextE called 46504522 returned 100% blocks executed 90%
 46504522:  206:AffineMap AffineMap::getPermutationMap(ArrayRef<unsigned> permutation,
        -:  207:                                       MLIRContext *context) {
46504522*:  208:  assert(!permutation.empty() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  209:         "Cannot create permutation map from empty permutation vector");
 46504522:  210:  SmallVector<AffineExpr, 4> affExprs;
137965699:  211:  for (auto index : permutation)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
 91461175:  212:    affExprs.push_back(getAffineDimExpr(index, context));
call    0 returned 100%
call    1 returned 100%
 46504524:  213:  const auto *m = std::max_element(permutation.begin(), permutation.end());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 46504524:  214:  auto permutationMap = AffineMap::get(*m + 1, 0, affExprs, context);
call    0 returned 100%
46504517*:  215:  assert(permutationMap.isPermutation() && "Invalid permutation vector");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
 46504504:  216:  return permutationMap;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  217:}
        -:  218:
        -:  219:template <typename AffineExprContainer>
        -:  220:static SmallVector<AffineMap, 4>
49918505*:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
49918505*:  222:  assert(!exprsList.empty());
49918505*:  223:  assert(!exprsList[0].empty());
49918505*:  224:  auto context = exprsList[0][0].getContext();
49918505*:  225:  int64_t maxDim = -1, maxSym = -1;
49918505*:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
49918505*:  227:  SmallVector<AffineMap, 4> maps;
49918505*:  228:  maps.reserve(exprsList.size());
99837010*:  229:  for (const auto &exprs : exprsList)
49918505*:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
49918505*:  232:  return maps;
        -:  233:}
------------------
_Z17inferFromExprListIN4llvm11SmallVectorIN4mlir10AffineExprELj4EEEENS1_INS2_9AffineMapELj4EEENS0_8ArrayRefIT_EE:
function _Z17inferFromExprListIN4llvm11SmallVectorIN4mlir10AffineExprELj4EEEENS1_INS2_9AffineMapELj4EEENS0_8ArrayRefIT_EE called 0 returned 0% blocks executed 0%
    #####:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
    #####:  222:  assert(!exprsList.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  223:  assert(!exprsList[0].empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  224:  auto context = exprsList[0][0].getContext();
call    0 never executed
    #####:  225:  int64_t maxDim = -1, maxSym = -1;
    #####:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  227:  SmallVector<AffineMap, 4> maps;
    #####:  228:  maps.reserve(exprsList.size());
branch  0 never executed
branch  1 never executed
    #####:  229:  for (const auto &exprs : exprsList)
branch  0 never executed
branch  1 never executed
    #####:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
call    0 never executed
call    1 never executed
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
    #####:  232:  return maps;
        -:  233:}
------------------
_Z17inferFromExprListIN4llvm8ArrayRefIN4mlir10AffineExprEEEENS0_11SmallVectorINS2_9AffineMapELj4EEENS1_IT_EE:
function _Z17inferFromExprListIN4llvm8ArrayRefIN4mlir10AffineExprEEEENS0_11SmallVectorINS2_9AffineMapELj4EEENS1_IT_EE called 49918505 returned 100% blocks executed 73%
 49918505:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
49918505*:  222:  assert(!exprsList.empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
49918505*:  223:  assert(!exprsList[0].empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 49918505:  224:  auto context = exprsList[0][0].getContext();
call    0 returned 100%
 49918505:  225:  int64_t maxDim = -1, maxSym = -1;
 49918505:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 49918505:  227:  SmallVector<AffineMap, 4> maps;
 49918505:  228:  maps.reserve(exprsList.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 99837010:  229:  for (const auto &exprs : exprsList)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
 49918505:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
call    0 returned 100%
call    1 returned 100%
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
 49918505:  232:  return maps;
        -:  233:}
------------------
        -:  234:
        -:  235:SmallVector<AffineMap, 4>
function _ZN4mlir9AffineMap17inferFromExprListEN4llvm8ArrayRefINS2_INS_10AffineExprEEEEE called 49918505 returned 100% blocks executed 100%
 49918505:  236:AffineMap::inferFromExprList(ArrayRef<ArrayRef<AffineExpr>> exprsList) {
 49918505:  237:  return ::inferFromExprList(exprsList);
call    0 returned 100%
        -:  238:}
        -:  239:
        -:  240:SmallVector<AffineMap, 4>
function _ZN4mlir9AffineMap17inferFromExprListEN4llvm8ArrayRefINS1_11SmallVectorINS_10AffineExprELj4EEEEE called 0 returned 0% blocks executed 0%
    #####:  241:AffineMap::inferFromExprList(ArrayRef<SmallVector<AffineExpr, 4>> exprsList) {
    #####:  242:  return ::inferFromExprList(exprsList);
call    0 never executed
call    1 never executed
        -:  243:}
        -:  244:
function _ZN4mlir9AffineMap32getLargestKnownDivisorOfMapExprsEv called 0 returned 0% blocks executed 0%
    #####:  245:uint64_t AffineMap::getLargestKnownDivisorOfMapExprs() {
    #####:  246:  uint64_t gcd = 0;
    #####:  247:  for (AffineExpr resultExpr : getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  248:    uint64_t thisGcd = resultExpr.getLargestKnownDivisor();
call    0 never executed
    #####:  249:    gcd = std::gcd(gcd, thisGcd);
        -:  250:  }
    #####:  251:  if (gcd == 0)
branch  0 never executed
branch  1 never executed
    #####:  252:    gcd = std::numeric_limits<uint64_t>::max();
    #####:  253:  return gcd;
        -:  254:}
        -:  255:
function _ZN4mlir9AffineMap22getMultiDimIdentityMapEjPNS_11MLIRContextE called 182574259 returned 100% blocks executed 100%
182574259:  256:AffineMap AffineMap::getMultiDimIdentityMap(unsigned numDims,
        -:  257:                                            MLIRContext *context) {
182574259:  258:  SmallVector<AffineExpr, 4> dimExprs;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
182574259:  259:  dimExprs.reserve(numDims);
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
533062711:  260:  for (unsigned i = 0; i < numDims; ++i)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
350488446:  261:    dimExprs.push_back(mlir::getAffineDimExpr(i, context));
call    0 returned 100%
call    1 returned 100%
182574265:  262:  return get(/*dimCount=*/numDims, /*symbolCount=*/0, dimExprs, context);
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  263:}
        -:  264:
function _ZNK4mlir9AffineMap10getContextEv called 1152274594 returned 100% blocks executed 100%
4558529042*:  265:MLIRContext *AffineMap::getContext() const { return map->context; }
        -:  266:
function _ZNK4mlir9AffineMap10isIdentityEv called 456396812 returned 100% blocks executed 83%
456396812:  267:bool AffineMap::isIdentity() const {
456396813:  268:  if (getNumDims() != getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  269:    return false;
456396774:  270:  ArrayRef<AffineExpr> results = getResults();
call    0 returned 100%
1310104415:  271:  for (unsigned i = 0, numDims = getNumDims(); i < numDims; ++i) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
853707737:  272:    auto expr = results[i].dyn_cast<AffineDimExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
853707649:  273:    if (!expr || expr.getPosition() != i)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 100%
        2:  274:      return false;
        -:  275:  }
        -:  276:  return true;
        -:  277:}
        -:  278:
function _ZNK4mlir9AffineMap7isEmptyEv called 265277440 returned 100% blocks executed 75%
265277440:  279:bool AffineMap::isEmpty() const {
  1414746:  280:  return getNumDims() == 0 && getNumSymbols() == 0 && getNumResults() == 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  281:}
        -:  282:
function _ZNK4mlir9AffineMap16isSingleConstantEv called 163909988 returned 100% blocks executed 100%
163909988:  283:bool AffineMap::isSingleConstant() const {
163909988:  284:  return getNumResults() == 1 && getResult(0).isa<AffineConstantExpr>();
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 1% (fallthrough)
branch  5 taken 100%
        -:  285:}
        -:  286:
function _ZNK4mlir9AffineMap10isConstantEv called 3 returned 100% blocks executed 100%
        3:  287:bool AffineMap::isConstant() const {
        3:  288:  return llvm::all_of(getResults(), [](AffineExpr expr) {
call    0 returned 100%
call    1 returned 100%
        -:  289:    return expr.isa<AffineConstantExpr>();
        3:  290:  });
        -:  291:}
        -:  292:
function _ZNK4mlir9AffineMap23getSingleConstantResultEv called 81861999 returned 100% blocks executed 86%
 81861999:  293:int64_t AffineMap::getSingleConstantResult() const {
81861999*:  294:  assert(isSingleConstant() && "map must have a single constant result");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
 81861999:  295:  return getResult(0).cast<AffineConstantExpr>().getValue();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  296:}
        -:  297:
function _ZNK4mlir9AffineMap18getConstantResultsEv called 0 returned 0% blocks executed 0%
    #####:  298:SmallVector<int64_t> AffineMap::getConstantResults() const {
    #####:  299:  assert(isConstant() && "map must have only constant results");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  300:  SmallVector<int64_t> result;
call    0 never executed
    #####:  301:  for (auto expr : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  302:    result.emplace_back(expr.cast<AffineConstantExpr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  303:  return result;
        -:  304:}
        -:  305:
function _ZNK4mlir9AffineMap10getNumDimsEv called 1541122336 returned 100% blocks executed 67%
6047574978*:  306:unsigned AffineMap::getNumDims() const {
2726936635*:  307:  assert(map && "uninitialized map storage");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
branch 17 taken 0% (fallthrough)
branch 18 taken 100%
call   19 never executed
branch 20 taken 0% (fallthrough)
branch 21 taken 100%
call   22 never executed
branch 23 taken 0% (fallthrough)
branch 24 taken 100%
call   25 never executed
branch 26 taken 0% (fallthrough)
branch 27 taken 100%
call   28 never executed
branch 29 taken 0% (fallthrough)
branch 30 taken 100%
call   31 never executed
branch 32 taken 0% (fallthrough)
branch 33 taken 100%
call   34 never executed
branch 35 taken 0% (fallthrough)
branch 36 taken 100%
call   37 never executed
branch 38 taken 0% (fallthrough)
branch 39 taken 100%
call   40 never executed
989403844*:  308:  return map->numDims;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
call    3 returned 100%
        -:  309:}
function _ZNK4mlir9AffineMap13getNumSymbolsEv called 1226957743 returned 100% blocks executed 67%
6928344542*:  310:unsigned AffineMap::getNumSymbols() const {
1226957743*:  311:  assert(map && "uninitialized map storage");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
call   15 never executed
45275805*:  312:  return map->numSymbols;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  313:}
function _ZNK4mlir9AffineMap13getNumResultsEv called 1367449293 returned 100% blocks executed 100%
6142525234*:  314:unsigned AffineMap::getNumResults() const { return getResults().size(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 returned 100%
call    4 returned 100%
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
branch 20 taken 100% (fallthrough)
branch 21 taken 0%
call   22 returned 100%
branch 23 taken 1% (fallthrough)
branch 24 taken 100%
branch 25 taken 0% (fallthrough)
branch 26 taken 100%
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 taken 1% (fallthrough)
branch 32 taken 100%
branch 33 taken 1% (fallthrough)
branch 34 taken 99%
branch 35 taken 1% (fallthrough)
branch 36 taken 100%
call   37 returned 100%
call   38 returned 100%
branch 39 taken 100% (fallthrough)
branch 40 taken 1%
call   41 returned 100%
branch 42 taken 0% (fallthrough)
branch 43 taken 100%
call   44 returned 100%
branch 45 taken 100% (fallthrough)
branch 46 taken 1%
call   47 returned 100%
call   48 returned 100%
call   49 returned 100%
call   50 returned 100%
call   51 returned 100%
call   52 returned 100%
call   53 returned 100%
call   54 never executed
call   55 never executed
call   56 returned 100%
call   57 returned 100%
call   58 returned 100%
branch 59 taken 100% (fallthrough)
branch 60 taken 0%
call   61 returned 100%
call   62 returned 100%
call   63 returned 100%
branch 64 taken 100% (fallthrough)
branch 65 taken 0%
call   66 returned 100%
branch 67 taken 0% (fallthrough)
branch 68 taken 100%
function _ZNK4mlir9AffineMap12getNumInputsEv called 1124171880 returned 100% blocks executed 67%
1124171880:  315:unsigned AffineMap::getNumInputs() const {
1124171880*:  316:  assert(map && "uninitialized map storage");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
1124171880:  317:  return map->numDims + map->numSymbols;
        -:  318:}
function _ZNK4mlir9AffineMap10getResultsEv called 18078960672 returned 100% blocks executed 67%
18078960672:  319:ArrayRef<AffineExpr> AffineMap::getResults() const {
18078960672*:  320:  assert(map && "uninitialized map storage");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
18078960672:  321:  return map->results();
        -:  322:}
function _ZNK4mlir9AffineMap9getResultEj called 1790644184 returned 100% blocks executed 75%
1790644184:  323:AffineExpr AffineMap::getResult(unsigned idx) const {
1790644184:  324:  return getResults()[idx];
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  325:}
        -:  326:
function _ZNK4mlir9AffineMap14getDimPositionEj called 171657217 returned 100% blocks executed 100%
171657217:  327:unsigned AffineMap::getDimPosition(unsigned idx) const {
171657217:  328:  return getResult(idx).cast<AffineDimExpr>().getPosition();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  329:}
        -:  330:
function _ZNK4mlir9AffineMap19getPermutedPositionEj called 0 returned 0% blocks executed 0%
    #####:  331:unsigned AffineMap::getPermutedPosition(unsigned input) const {
    #####:  332:  assert(isPermutation() && "invalid permutation request");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  333:  for (unsigned i = 0, numResults = getNumResults(); i < numResults; i++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  334:    if (getDimPosition(i) == input)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:      return i;
    #####:  336:  llvm_unreachable("incorrect permutation request");
        -:  337:}
        -:  338:
        -:  339:/// Folds the results of the application of an affine map on the provided
        -:  340:/// operands to a constant if possible. Returns false if the folding happens,
        -:  341:/// true otherwise.
        -:  342:LogicalResult
function _ZNK4mlir9AffineMap12constantFoldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplIS3_EE called 178978 returned 100% blocks executed 88%
   178978:  343:AffineMap::constantFold(ArrayRef<Attribute> operandConstants,
        -:  344:                        SmallVectorImpl<Attribute> &results) const {
        -:  345:  // Attempt partial folding.
   178978:  346:  SmallVector<int64_t, 2> integers;
call    0 returned 100%
   178978:  347:  partialConstantFold(operandConstants, &integers);
call    0 returned 100%
        -:  348:
        -:  349:  // If all expressions folded to a constant, populate results with attributes
        -:  350:  // containing those constants.
   178978:  351:  if (integers.empty())
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
    79932:  352:    return failure();
        -:  353:
function _ZZNK4mlir9AffineMap12constantFoldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplIS3_EEENKUllE_clEl.isra.0 called 99046 returned 100% blocks executed 100%
    99046:  354:  auto range = llvm::map_range(integers, [this](int64_t i) {
    99046:  355:    return IntegerAttr::get(IndexType::get(getContext()), i);
call    0 returned 100%
call    1 returned 100%
    99046:  356:  });
call    0 returned 100%
    99046:  357:  results.append(range.begin(), range.end());
call    0 returned 100%
   178978:  358:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  359:}
        -:  360:
        -:  361:AffineMap
function _ZNK4mlir9AffineMap19partialConstantFoldEN4llvm8ArrayRefINS_9AttributeEEEPNS1_15SmallVectorImplIlEE called 680621 returned 100% blocks executed 93%
   680621:  362:AffineMap::partialConstantFold(ArrayRef<Attribute> operandConstants,
        -:  363:                               SmallVectorImpl<int64_t> *results) const {
  680621*:  364:  assert(getNumInputs() == operandConstants.size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  365:
        -:  366:  // Fold each of the result expressions.
   680621:  367:  AffineExprConstantFolder exprFolder(getNumDims(), operandConstants);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   680621:  368:  SmallVector<AffineExpr, 4> exprs;
call    0 returned 100%
   680621:  369:  exprs.reserve(getNumResults());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  370:
  2097230:  371:  for (auto expr : getResults()) {
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
  1416609:  372:    auto folded = exprFolder.constantFold(expr);
call    0 returned 100%
        -:  373:    // If did not fold to a constant, keep the original expression, and clear
        -:  374:    // the integer results vector.
  1416609:  375:    if (folded) {
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
   827244:  376:      exprs.push_back(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  377:          getAffineConstantExpr(folded.getInt(), folded.getContext()));
   827244:  378:      if (results)
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
   721957:  379:        results->push_back(folded.getInt());
call    0 returned 100%
call    1 returned 100%
        -:  380:    } else {
   589365:  381:      exprs.push_back(expr);
call    0 returned 100%
   589365:  382:      if (results) {
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
   345331:  383:        results->clear();
   345331:  384:        results = nullptr;
        -:  385:      }
        -:  386:    }
        -:  387:  }
        -:  388:
   680621:  389:  return get(getNumDims(), getNumSymbols(), exprs, getContext());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  390:}
        -:  391:
        -:  392:/// Walk all of the AffineExpr's in this mapping. Each node in an expression
        -:  393:/// tree is visited in postorder.
function _ZNK4mlir9AffineMap9walkExprsEN4llvm12function_refIFvNS_10AffineExprEEEE called 78927 returned 100% blocks executed 88%
    78927:  394:void AffineMap::walkExprs(llvm::function_ref<void(AffineExpr)> callback) const {
   230234:  395:  for (auto expr : getResults())
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
   151308:  396:    expr.walk(callback);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    78926:  397:}
        -:  398:
        -:  399:/// This method substitutes any uses of dimensions and symbols (e.g.
        -:  400:/// dim#0 with dimReplacements[0]) in subexpressions and returns the modified
        -:  401:/// expression mapping.  Because this can be used to eliminate dims and
        -:  402:/// symbols, the client needs to specify the number of dims and symbols in
        -:  403:/// the result.  The returned map always has the same number of results.
function _ZNK4mlir9AffineMap21replaceDimsAndSymbolsEN4llvm8ArrayRefINS_10AffineExprEEES4_jj called 914593918 returned 100% blocks executed 100%
914593918:  404:AffineMap AffineMap::replaceDimsAndSymbols(ArrayRef<AffineExpr> dimReplacements,
        -:  405:                                           ArrayRef<AffineExpr> symReplacements,
        -:  406:                                           unsigned numResultDims,
        -:  407:                                           unsigned numResultSyms) const {
914593918:  408:  SmallVector<AffineExpr, 8> results;
call    0 returned 100%
914593918:  409:  results.reserve(getNumResults());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
3710746467:  410:  for (auto expr : getResults())
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
2796152559:  411:    results.push_back(
call    0 returned 100%
call    1 returned 100%
        -:  412:        expr.replaceDimsAndSymbols(dimReplacements, symReplacements));
914593885:  413:  return get(numResultDims, numResultSyms, results, getContext());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        -:  414:}
        -:  415:
        -:  416:/// Sparse replace method. Apply AffineExpr::replace(`expr`, `replacement`) to
        -:  417:/// each of the results and return a new AffineMap with the new results and
        -:  418:/// with the specified number of dims and symbols.
function _ZNK4mlir9AffineMap7replaceENS_10AffineExprES1_jj called 4006 returned 100% blocks executed 100%
     4006:  419:AffineMap AffineMap::replace(AffineExpr expr, AffineExpr replacement,
        -:  420:                             unsigned numResultDims,
        -:  421:                             unsigned numResultSyms) const {
     4006:  422:  SmallVector<AffineExpr, 4> newResults;
call    0 returned 100%
     4006:  423:  newResults.reserve(getNumResults());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
    13423:  424:  for (AffineExpr e : getResults())
call    0 returned 100%
branch  1 taken 70% (fallthrough)
branch  2 taken 30%
     9417:  425:    newResults.push_back(e.replace(expr, replacement));
call    0 returned 100%
call    1 returned 100%
     4006:  426:  return AffineMap::get(numResultDims, numResultSyms, newResults, getContext());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  427:}
        -:  428:
        -:  429:/// Sparse replace method. Apply AffineExpr::replace(`map`) to each of the
        -:  430:/// results and return a new AffineMap with the new results and with the
        -:  431:/// specified number of dims and symbols.
function _ZNK4mlir9AffineMap7replaceERKN4llvm8DenseMapINS_10AffineExprES3_NS1_12DenseMapInfoIS3_vEENS1_6detail12DenseMapPairIS3_S3_EEEEjj called 0 returned 0% blocks executed 0%
    #####:  432:AffineMap AffineMap::replace(const DenseMap<AffineExpr, AffineExpr> &map,
        -:  433:                             unsigned numResultDims,
        -:  434:                             unsigned numResultSyms) const {
    #####:  435:  SmallVector<AffineExpr, 4> newResults;
call    0 never executed
    #####:  436:  newResults.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  437:  for (AffineExpr e : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  438:    newResults.push_back(e.replace(map));
call    0 never executed
call    1 never executed
    #####:  439:  return AffineMap::get(numResultDims, numResultSyms, newResults, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  440:}
        -:  441:
        -:  442:AffineMap
function _ZNK4mlir9AffineMap7replaceERKN4llvm8DenseMapINS_10AffineExprES3_NS1_12DenseMapInfoIS3_vEENS1_6detail12DenseMapPairIS3_S3_EEEE called 0 returned 0% blocks executed 0%
    #####:  443:AffineMap::replace(const DenseMap<AffineExpr, AffineExpr> &map) const {
    #####:  444:  SmallVector<AffineExpr, 4> newResults;
call    0 never executed
    #####:  445:  newResults.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  446:  for (AffineExpr e : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  447:    newResults.push_back(e.replace(map));
call    0 never executed
call    1 never executed
    #####:  448:  return AffineMap::inferFromExprList(newResults).front();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  449:}
        -:  450:
function _ZNK4mlir9AffineMap7composeES0_ called 909722940 returned 100% blocks executed 74%
909722940:  451:AffineMap AffineMap::compose(AffineMap map) const {
909722940*:  452:  assert(getNumDims() == map.getNumResults() && "Number of results mismatch");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  453:  // Prepare `map` by concatenating the symbols and rewriting its exprs.
909722934:  454:  unsigned numDims = map.getNumDims();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
909722934:  455:  unsigned numSymbolsThisMap = getNumSymbols();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
909722934:  456:  unsigned numSymbols = numSymbolsThisMap + map.getNumSymbols();
909722934:  457:  SmallVector<AffineExpr, 8> newDims(numDims);
call    0 returned 100%
1043131579:  458:  for (unsigned idx = 0; idx < numDims; ++idx) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
133408656:  459:    newDims[idx] = getAffineDimExpr(idx, getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  460:  }
1819445865:  461:  SmallVector<AffineExpr, 8> newSymbols(numSymbols - numSymbolsThisMap);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
909722892:  462:  for (unsigned idx = numSymbolsThisMap; idx < numSymbols; ++idx) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        4:  463:    newSymbols[idx - numSymbolsThisMap] =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        6:  464:        getAffineSymbolExpr(idx, getContext());
call    0 returned 67%
        -:  465:  }
909722886:  466:  auto newMap =
call    0 returned 100%
909722886:  467:      map.replaceDimsAndSymbols(newDims, newSymbols, numDims, numSymbols);
call    0 returned 100%
1819445827:  468:  SmallVector<AffineExpr, 8> exprs;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
909722885:  469:  exprs.reserve(getResults().size());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
2799042295:  470:  for (auto expr : getResults())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
1889319444:  471:    exprs.push_back(expr.compose(newMap));
call    0 returned 100%
call    1 returned 100%
909722840:  472:  return AffineMap::get(numDims, numSymbols, exprs, map.getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  473:}
        -:  474:
function _ZNK4mlir9AffineMap7composeEN4llvm8ArrayRefIlEE called 871474251 returned 100% blocks executed 93%
871474251:  475:SmallVector<int64_t, 4> AffineMap::compose(ArrayRef<int64_t> values) const {
871474251*:  476:  assert(getNumSymbols() == 0 && "Expected symbol-less map");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
871474251:  477:  SmallVector<AffineExpr, 4> exprs;
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
871474251:  478:  exprs.reserve(values.size());
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
871474251:  479:  MLIRContext *ctx = getContext();
3525042694:  480:  for (auto v : values)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
2653568427:  481:    exprs.push_back(getAffineConstantExpr(v, ctx));
call    0 returned 100%
call    1 returned 100%
871474267:  482:  auto resMap = compose(AffineMap::get(0, 0, exprs, ctx));
call    0 returned 100%
call    1 returned 100%
871474264:  483:  SmallVector<int64_t, 4> res;
call    0 returned 100%
871474264:  484:  res.reserve(resMap.getNumResults());
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
2665633937:  485:  for (auto e : resMap.getResults())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
1794159710:  486:    res.push_back(e.cast<AffineConstantExpr>().getValue());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
871474217:  487:  return res;
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:  488:}
        -:  489:
function _ZNK4mlir9AffineMap22isProjectedPermutationEb called 402645891 returned 100% blocks executed 65%
402645891:  490:bool AffineMap::isProjectedPermutation(bool allowZeroInResults) const {
402645891:  491:  if (getNumSymbols() > 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
        -:  492:    return false;
        -:  493:
        -:  494:  // Having more results than inputs means that results have duplicated dims or
        -:  495:  // zeros that can't be mapped to input dims.
402645892:  496:  if (getNumResults() > getNumInputs())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
        -:  497:    return false;
        -:  498:
402645883:  499:  SmallVector<bool, 8> seen(getNumInputs(), false);
call    0 returned 100%
        -:  500:  // A projected permutation can have, at most, only one instance of each input
        -:  501:  // dimension in the result expressions. Zeros are allowed as long as the
        -:  502:  // number of result expressions is lower or equal than the number of input
        -:  503:  // expressions.
1146118023:  504:  for (auto expr : getResults()) {
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
743472156:  505:    if (auto dim = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
743472143:  506:      if (seen[dim.getPosition()])
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####:  507:        return false;
743472143:  508:      seen[dim.getPosition()] = true;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  509:    } else {
    #####:  510:      auto constExpr = expr.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####:  511:      if (!allowZeroInResults || !constExpr || constExpr.getValue() != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  512:        return false;
        -:  513:    }
        -:  514:  }
        -:  515:
        -:  516:  // Results are either dims or zeros and zeros can be mapped to input dims.
402645868:  517:  return true;
        -:  518:}
        -:  519:
function _ZNK4mlir9AffineMap13isPermutationEv called 46504517 returned 100% blocks executed 83%
 46504517:  520:bool AffineMap::isPermutation() const {
 46504517:  521:  if (getNumDims() != getNumResults())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  522:    return false;
 46504518:  523:  return isProjectedPermutation();
call    0 returned 100%
        -:  524:}
        -:  525:
function _ZNK4mlir9AffineMap9getSubMapEN4llvm8ArrayRefIjEE called 652 returned 100% blocks executed 75%
      652:  526:AffineMap AffineMap::getSubMap(ArrayRef<unsigned> resultPos) const {
      652:  527:  SmallVector<AffineExpr, 4> exprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      652:  528:  exprs.reserve(resultPos.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1304:  529:  for (auto idx : resultPos)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      652:  530:    exprs.push_back(getResult(idx));
call    0 returned 100%
call    1 returned 100%
      652:  531:  return AffineMap::get(getNumDims(), getNumSymbols(), exprs, getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  532:}
        -:  533:
function _ZNK4mlir9AffineMap11getSliceMapEjj called 16 returned 100% blocks executed 83%
       16:  534:AffineMap AffineMap::getSliceMap(unsigned start, unsigned length) const {
       16:  535:  return AffineMap::get(getNumDims(), getNumSymbols(),
       16:  536:                        getResults().slice(start, length), getContext());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -:  537:}
        -:  538:
function _ZNK4mlir9AffineMap14getMajorSubMapEj called 0 returned 0% blocks executed 0%
    #####:  539:AffineMap AffineMap::getMajorSubMap(unsigned numResults) const {
    #####:  540:  if (numResults == 0)
branch  0 never executed
branch  1 never executed
    #####:  541:    return AffineMap();
    #####:  542:  if (numResults > getNumResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  543:    return *this;
    #####:  544:  return getSliceMap(0, numResults);
call    0 never executed
        -:  545:}
        -:  546:
function _ZNK4mlir9AffineMap14getMinorSubMapEj called 0 returned 0% blocks executed 0%
    #####:  547:AffineMap AffineMap::getMinorSubMap(unsigned numResults) const {
    #####:  548:  if (numResults == 0)
branch  0 never executed
branch  1 never executed
    #####:  549:    return AffineMap();
    #####:  550:  if (numResults > getNumResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  551:    return *this;
    #####:  552:  return getSliceMap(getNumResults() - numResults, numResults);
call    0 never executed
call    1 never executed
        -:  553:}
        -:  554:
function _ZN4mlir12compressDimsENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  555:AffineMap mlir::compressDims(AffineMap map,
        -:  556:                             const llvm::SmallBitVector &unusedDims) {
    #####:  557:  unsigned numDims = 0;
    #####:  558:  SmallVector<AffineExpr> dimReplacements;
branch  0 never executed
branch  1 never executed
    #####:  559:  dimReplacements.reserve(map.getNumDims());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:  MLIRContext *context = map.getContext();
    #####:  561:  for (unsigned dim = 0, e = map.getNumDims(); dim < e; ++dim) {
branch  0 never executed
branch  1 never executed
    #####:  562:    if (unusedDims.test(dim))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  563:      dimReplacements.push_back(getAffineConstantExpr(0, context));
call    0 never executed
call    1 never executed
        -:  564:    else
    #####:  565:      dimReplacements.push_back(getAffineDimExpr(numDims++, context));
call    0 never executed
call    1 never executed
        -:  566:  }
    #####:  567:  SmallVector<AffineExpr> resultExprs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  568:  resultExprs.reserve(map.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  569:  for (auto e : map.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  570:    resultExprs.push_back(e.replaceDims(dimReplacements));
call    0 never executed
call    1 never executed
    #####:  571:  return AffineMap::get(numDims, map.getNumSymbols(), resultExprs, context);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  572:}
        -:  573:
function _ZN4mlir18compressUnusedDimsENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  574:AffineMap mlir::compressUnusedDims(AffineMap map) {
    #####:  575:  return compressDims(map, getUnusedDimsBitVector({map}));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  576:}
        -:  577:
        -:  578:static SmallVector<AffineMap>
function _ZL18compressUnusedImplN4llvm8ArrayRefIN4mlir9AffineMapEEENS_12function_refIFS2_S2_EEE called 0 returned 0% blocks executed 0%
    #####:  579:compressUnusedImpl(ArrayRef<AffineMap> maps,
        -:  580:                   llvm::function_ref<AffineMap(AffineMap)> compressionFun) {
    #####:  581:  if (maps.empty())
branch  0 never executed
branch  1 never executed
    #####:  582:    return SmallVector<AffineMap>();
    #####:  583:  SmallVector<AffineExpr> allExprs;
call    0 never executed
    #####:  584:  allExprs.reserve(maps.size() * maps.front().getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  585:  unsigned numDims = maps.front().getNumDims(),
branch  0 never executed
branch  1 never executed
    #####:  586:           numSymbols = maps.front().getNumSymbols();
    #####:  587:  for (auto m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  588:    assert(numDims == m.getNumDims() && numSymbols == m.getNumSymbols() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  589:           "expected maps with same num dims and symbols");
    #####:  590:    llvm::append_range(allExprs, m.getResults());
call    0 never executed
call    1 never executed
        -:  591:  }
    #####:  592:  AffineMap unifiedMap = compressionFun(
call    0 never executed
    #####:  593:      AffineMap::get(numDims, numSymbols, allExprs, maps.front().getContext()));
call    0 never executed
call    1 never executed
    #####:  594:  unsigned unifiedNumDims = unifiedMap.getNumDims(),
branch  0 never executed
branch  1 never executed
    #####:  595:           unifiedNumSymbols = unifiedMap.getNumSymbols();
    #####:  596:  ArrayRef<AffineExpr> unifiedResults = unifiedMap.getResults();
call    0 never executed
    #####:  597:  SmallVector<AffineMap> res;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  598:  res.reserve(maps.size());
branch  0 never executed
branch  1 never executed
    #####:  599:  for (auto m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  600:    res.push_back(AffineMap::get(unifiedNumDims, unifiedNumSymbols,
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  601:                                 unifiedResults.take_front(m.getNumResults()),
branch  0 never executed
branch  1 never executed
        -:  602:                                 m.getContext()));
    #####:  603:    unifiedResults = unifiedResults.drop_front(m.getNumResults());
call    0 never executed
call    1 never executed
        -:  604:  }
    #####:  605:  return res;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  606:}
        -:  607:
function _ZN4mlir18compressUnusedDimsEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  608:SmallVector<AffineMap> mlir::compressUnusedDims(ArrayRef<AffineMap> maps) {
    #####:  609:  return compressUnusedImpl(maps,
    #####:  610:                            [](AffineMap m) { return compressUnusedDims(m); });
call    0 never executed
call    1 never executed
        -:  611:}
        -:  612:
function _ZN4mlir15compressSymbolsENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  613:AffineMap mlir::compressSymbols(AffineMap map,
        -:  614:                                const llvm::SmallBitVector &unusedSymbols) {
    #####:  615:  unsigned numSymbols = 0;
    #####:  616:  SmallVector<AffineExpr> symReplacements;
branch  0 never executed
branch  1 never executed
    #####:  617:  symReplacements.reserve(map.getNumSymbols());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  618:  MLIRContext *context = map.getContext();
    #####:  619:  for (unsigned sym = 0, e = map.getNumSymbols(); sym < e; ++sym) {
branch  0 never executed
branch  1 never executed
    #####:  620:    if (unusedSymbols.test(sym))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  621:      symReplacements.push_back(getAffineConstantExpr(0, context));
call    0 never executed
call    1 never executed
        -:  622:    else
    #####:  623:      symReplacements.push_back(getAffineSymbolExpr(numSymbols++, context));
call    0 never executed
call    1 never executed
        -:  624:  }
    #####:  625:  SmallVector<AffineExpr> resultExprs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  626:  resultExprs.reserve(map.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  627:  for (auto e : map.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  628:    resultExprs.push_back(e.replaceSymbols(symReplacements));
call    0 never executed
call    1 never executed
    #####:  629:  return AffineMap::get(map.getNumDims(), numSymbols, resultExprs, context);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  630:}
        -:  631:
function _ZN4mlir21compressUnusedSymbolsENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  632:AffineMap mlir::compressUnusedSymbols(AffineMap map) {
    #####:  633:  llvm::SmallBitVector unusedSymbols(map.getNumSymbols(), true);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
function _ZZN4mlir21compressUnusedSymbolsENS_9AffineMapEENKUlNS_10AffineExprEE_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  634:  map.walkExprs([&](AffineExpr expr) {
call    0 never executed
    #####:  635:    if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  636:      unusedSymbols.reset(symExpr.getPosition());
call    0 never executed
call    1 never executed
    #####:  637:  });
    #####:  638:  return compressSymbols(map, unusedSymbols);
call    0 never executed
        -:  639:}
        -:  640:
function _ZN4mlir21compressUnusedSymbolsEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  641:SmallVector<AffineMap> mlir::compressUnusedSymbols(ArrayRef<AffineMap> maps) {
    #####:  642:  return compressUnusedImpl(
    #####:  643:      maps, [](AffineMap m) { return compressUnusedSymbols(m); });
call    0 never executed
call    1 never executed
        -:  644:}
        -:  645:
function _ZN4mlir17simplifyAffineMapENS_9AffineMapE called 42998016 returned 100% blocks executed 83%
 42998016:  646:AffineMap mlir::simplifyAffineMap(AffineMap map) {
 42998016:  647:  SmallVector<AffineExpr, 8> exprs;
call    0 returned 100%
147100951:  648:  for (auto e : map.getResults()) {
call    0 returned 100%
branch  1 taken 71% (fallthrough)
branch  2 taken 29%
104102935:  649:    exprs.push_back(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -:  650:        simplifyAffineExpr(e, map.getNumDims(), map.getNumSymbols()));
        -:  651:  }
 42998016:  652:  return AffineMap::get(map.getNumDims(), map.getNumSymbols(), exprs,
 42998016:  653:                        map.getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  654:}
        -:  655:
function _ZN4mlir20removeDuplicateExprsENS_9AffineMapE called 181770 returned 100% blocks executed 88%
   181770:  656:AffineMap mlir::removeDuplicateExprs(AffineMap map) {
   181770:  657:  auto results = map.getResults();
call    0 returned 100%
   181770:  658:  SmallVector<AffineExpr, 4> uniqueExprs(results.begin(), results.end());
call    0 returned 100%
   181770:  659:  uniqueExprs.erase(std::unique(uniqueExprs.begin(), uniqueExprs.end()),
call    0 returned 100%
call    1 returned 100%
   181770:  660:                    uniqueExprs.end());
call    0 returned 100%
   181770:  661:  return AffineMap::get(map.getNumDims(), map.getNumSymbols(), uniqueExprs,
   181770:  662:                        map.getContext());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  663:}
        -:  664:
function _ZN4mlir18inversePermutationENS_9AffineMapE called 265277389 returned 100% blocks executed 88%
265277389:  665:AffineMap mlir::inversePermutation(AffineMap map) {
265277389:  666:  if (map.isEmpty())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
  1414746:  667:    return map;
263862643*:  668:  assert(map.getNumSymbols() == 0 && "expected map without symbols");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
263862643:  669:  SmallVector<AffineExpr, 4> exprs(map.getNumDims());
call    0 returned 100%
1718372422:  670:  for (const auto &en : llvm::enumerate(map.getResults())) {
call    0 returned 100%
branch  1 taken 85% (fallthrough)
branch  2 taken 15%
call    3 returned 100%
1454509673:  671:    auto expr = en.value();
call    0 returned 100%
        -:  672:    // Skip non-permutations.
1454509673:  673:    if (auto d = expr.dyn_cast<AffineDimExpr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
1454509661:  674:      if (exprs[d.getPosition()])
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 53% (fallthrough)
branch  4 taken 47%
771179896:  675:        continue;
683329862:  676:      exprs[d.getPosition()] = getAffineDimExpr(en.index(), d.getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  677:    }
        -:  678:  }
527725281:  679:  SmallVector<AffineExpr, 4> seenExprs;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
263862627:  680:  seenExprs.reserve(map.getNumDims());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
947192517:  681:  for (auto expr : exprs)
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
683329893:  682:    if (expr)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
683329893:  683:      seenExprs.push_back(expr);
call    0 returned 100%
263862624:  684:  if (seenExprs.size() != map.getNumInputs())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  685:    return AffineMap();
263862625:  686:  return AffineMap::get(map.getNumResults(), 0, seenExprs, map.getContext());
call    0 returned 100%
call    1 returned 100%
        -:  687:}
        -:  688:
function _ZN4mlir39inverseAndBroadcastProjectedPermutationENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  689:AffineMap mlir::inverseAndBroadcastProjectedPermutation(AffineMap map) {
    #####:  690:  assert(map.isProjectedPermutation(/*allowZeroInResults=*/true));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  691:  MLIRContext *context = map.getContext();
    #####:  692:  AffineExpr zero = mlir::getAffineConstantExpr(0, context);
call    0 never executed
        -:  693:  // Start with all the results as 0.
    #####:  694:  SmallVector<AffineExpr, 4> exprs(map.getNumInputs(), zero);
call    0 never executed
call    1 never executed
    #####:  695:  for (unsigned i : llvm::seq(unsigned(0), map.getNumResults())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  696:    // Skip zeros from input map. 'exprs' is already initialized to zero.
    #####:  697:    if (auto constExpr = map.getResult(i).dyn_cast<AffineConstantExpr>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  698:      assert(constExpr.getValue() == 0 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  699:             "Unexpected constant in projected permutation");
    #####:  700:      (void)constExpr;
    #####:  701:      continue;
        -:  702:    }
        -:  703:
        -:  704:    // Reverse each dimension existing in the original map result.
    #####:  705:    exprs[map.getDimPosition(i)] = getAffineDimExpr(i, context);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  706:  }
    #####:  707:  return AffineMap::get(map.getNumResults(), /*symbolCount=*/0, exprs, context);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  708:}
        -:  709:
function _ZN4mlir16concatAffineMapsEN4llvm8ArrayRefINS_9AffineMapEEE called 265277427 returned 100% blocks executed 86%
265277427:  710:AffineMap mlir::concatAffineMaps(ArrayRef<AffineMap> maps) {
265277427:  711:  unsigned numResults = 0, numDims = 0, numSymbols = 0;
1005263182:  712:  for (auto m : maps)
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
739985763:  713:    numResults += m.getNumResults();
call    0 returned 100%
265277419:  714:  SmallVector<AffineExpr, 8> results;
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
265277419:  715:  results.reserve(numResults);
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
1005263159:  716:  for (auto m : maps) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
2194495739:  717:    for (auto res : m.getResults())
call    0 returned 100%
branch  1 taken 66% (fallthrough)
branch  2 taken 34%
1454509997:  718:      results.push_back(res.shiftSymbols(m.getNumSymbols(), numSymbols));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -:  719:
739985740:  720:    numSymbols += m.getNumSymbols();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
739985740:  721:    numDims = std::max(m.getNumDims(), numDims);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  722:  }
265277421:  723:  return AffineMap::get(numDims, numSymbols, results,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
265277421:  724:                        maps.front().getContext());
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
        -:  725:}
        -:  726:
function _ZN4mlir15getProjectedMapENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  727:AffineMap mlir::getProjectedMap(AffineMap map,
        -:  728:                                const llvm::SmallBitVector &unusedDims) {
    #####:  729:  return compressUnusedSymbols(compressDims(map, unusedDims));
call    0 never executed
call    1 never executed
        -:  730:}
        -:  731:
function _ZN4mlir22getUnusedDimsBitVectorEN4llvm8ArrayRefINS_9AffineMapEEE called 38248658 returned 100% blocks executed 87%
 38248658:  732:llvm::SmallBitVector mlir::getUnusedDimsBitVector(ArrayRef<AffineMap> maps) {
 38248658:  733:  unsigned numDims = maps[0].getNumDims();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
 38248658:  734:  llvm::SmallBitVector numDimsBitVector(numDims, true);
call    0 returned 100%
114745974:  735:  for (const auto &m : maps) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
343314432:  736:    for (unsigned i = 0; i < numDims; ++i) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
266817116:  737:      if (m.isFunctionOfDim(i))
call    0 returned 100%
branch  1 taken 64% (fallthrough)
branch  2 taken 36%
171657216:  738:        numDimsBitVector.reset(i);
call    0 returned 100%
        -:  739:    }
        -:  740:  }
 38248658:  741:  return numDimsBitVector;
        -:  742:}
        -:  743:
        -:  744://===----------------------------------------------------------------------===//
        -:  745:// MutableAffineMap.
        -:  746://===----------------------------------------------------------------------===//
        -:  747:
function _ZN4mlir16MutableAffineMapC2ENS_9AffineMapE called 18602 returned 100% blocks executed 83%
    18602:  748:MutableAffineMap::MutableAffineMap(AffineMap map)
    18602:  749:    : results(map.getResults().begin(), map.getResults().end()),
call    0 returned 100%
    18602:  750:      numDims(map.getNumDims()), numSymbols(map.getNumSymbols()),
    18602:  751:      context(map.getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  752:
function _ZN4mlir16MutableAffineMap5resetENS_9AffineMapE called 65051 returned 100% blocks executed 80%
    65051:  753:void MutableAffineMap::reset(AffineMap map) {
    65051:  754:  results.clear();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    65051:  755:  numDims = map.getNumDims();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    65051:  756:  numSymbols = map.getNumSymbols();
    65051:  757:  context = map.getContext();
    65051:  758:  llvm::append_range(results, map.getResults());
call    0 returned 100%
call    1 returned 100%
    65051:  759:}
        -:  760:
function _ZNK4mlir16MutableAffineMap12isMultipleOfEjl called 0 returned 0% blocks executed 0%
    #####:  761:bool MutableAffineMap::isMultipleOf(unsigned idx, int64_t factor) const {
    #####:  762:  if (results[idx].isMultipleOf(factor))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  763:    return true;
        -:  764:
        -:  765:  // TODO: use simplifyAffineExpr and FlatAffineConstraints to
        -:  766:  // complete this (for a more powerful analysis).
        -:  767:  return false;
        -:  768:}
        -:  769:
        -:  770:// Simplifies the result affine expressions of this map. The expressions have to
        -:  771:// be pure for the simplification implemented.
function _ZN4mlir16MutableAffineMap8simplifyEv called 18442 returned 100% blocks executed 88%
    18442:  772:void MutableAffineMap::simplify() {
        -:  773:  // Simplify each of the results if possible.
        -:  774:  // TODO: functional-style map
    52549:  775:  for (unsigned i = 0, e = getNumResults(); i < e; i++) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
    34107:  776:    results[i] = simplifyAffineExpr(getResult(i), numDims, numSymbols);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  777:  }
    18442:  778:}
        -:  779:
function _ZNK4mlir16MutableAffineMap12getAffineMapEv called 113271 returned 100% blocks executed 100%
   113271:  780:AffineMap MutableAffineMap::getAffineMap() const {
   113271:  781:  return AffineMap::get(numDims, numSymbols, results, context);
call    0 returned 100%
        -:  782:}
