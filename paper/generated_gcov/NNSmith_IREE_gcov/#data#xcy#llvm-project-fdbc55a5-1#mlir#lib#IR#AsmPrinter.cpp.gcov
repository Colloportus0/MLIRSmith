        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/AsmPrinter.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AsmPrinter.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AsmPrinter.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- AsmPrinter.cpp - MLIR Assembly Printer Implementation --------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the MLIR AsmPrinter class, which is used to implement
        -:   10:// the various print() methods on the core IR objects.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/AffineExpr.h"
        -:   15:#include "mlir/IR/AffineMap.h"
        -:   16:#include "mlir/IR/AsmState.h"
        -:   17:#include "mlir/IR/Attributes.h"
        -:   18:#include "mlir/IR/Builders.h"
        -:   19:#include "mlir/IR/BuiltinDialect.h"
        -:   20:#include "mlir/IR/BuiltinTypes.h"
        -:   21:#include "mlir/IR/Dialect.h"
        -:   22:#include "mlir/IR/DialectImplementation.h"
        -:   23:#include "mlir/IR/DialectResourceBlobManager.h"
        -:   24:#include "mlir/IR/IntegerSet.h"
        -:   25:#include "mlir/IR/MLIRContext.h"
        -:   26:#include "mlir/IR/OpImplementation.h"
        -:   27:#include "mlir/IR/Operation.h"
        -:   28:#include "mlir/IR/SubElementInterfaces.h"
        -:   29:#include "mlir/IR/Verifier.h"
        -:   30:#include "llvm/ADT/APFloat.h"
        -:   31:#include "llvm/ADT/DenseMap.h"
        -:   32:#include "llvm/ADT/MapVector.h"
        -:   33:#include "llvm/ADT/STLExtras.h"
        -:   34:#include "llvm/ADT/ScopeExit.h"
        -:   35:#include "llvm/ADT/ScopedHashTable.h"
        -:   36:#include "llvm/ADT/SetVector.h"
        -:   37:#include "llvm/ADT/SmallString.h"
        -:   38:#include "llvm/ADT/StringExtras.h"
        -:   39:#include "llvm/ADT/StringSet.h"
        -:   40:#include "llvm/ADT/TypeSwitch.h"
        -:   41:#include "llvm/Support/CommandLine.h"
        -:   42:#include "llvm/Support/Debug.h"
        -:   43:#include "llvm/Support/Endian.h"
        -:   44:#include "llvm/Support/Regex.h"
        -:   45:#include "llvm/Support/SaveAndRestore.h"
        -:   46:#include "llvm/Support/Threading.h"
        -:   47:
        -:   48:#include <tuple>
        -:   49:
        -:   50:using namespace mlir;
        -:   51:using namespace mlir::detail;
        -:   52:
        -:   53:#define DEBUG_TYPE "mlir-asm-printer"
        -:   54:
function _ZNK4mlir13OperationName5printERN4llvm11raw_ostreamE called 152077 returned 100% blocks executed 100%
   152077:   55:void OperationName::print(raw_ostream &os) const { os << getStringRef(); }
call    0 returned 100%
call    1 returned 100%
        -:   56:
function _ZNK4mlir13OperationName4dumpEv called 0 returned 0% blocks executed 0%
    #####:   57:void OperationName::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -:   58:
        -:   59://===--------------------------------------------------------------------===//
        -:   60:// AsmParser
        -:   61://===--------------------------------------------------------------------===//
        -:   62:
        -:   63:AsmParser::~AsmParser() = default;
        -:   64:DialectAsmParser::~DialectAsmParser() = default;
        -:   65:OpAsmParser::~OpAsmParser() = default;
        -:   66:
function _ZNK4mlir9AsmParser10getContextEv called 1144196 returned 100% blocks executed 100%
  1144196:   67:MLIRContext *AsmParser::getContext() const { return getBuilder().getContext(); }
call    0 returned 100%
        -:   68:
        -:   69://===----------------------------------------------------------------------===//
        -:   70:// DialectAsmPrinter
        -:   71://===----------------------------------------------------------------------===//
        -:   72:
        -:   73:DialectAsmPrinter::~DialectAsmPrinter() = default;
        -:   74:
        -:   75://===----------------------------------------------------------------------===//
        -:   76:// OpAsmPrinter
        -:   77://===----------------------------------------------------------------------===//
        -:   78:
        -:   79:OpAsmPrinter::~OpAsmPrinter() = default;
        -:   80:
function _ZN4mlir12OpAsmPrinter19printFunctionalTypeEPNS_9OperationE called 1822702 returned 100% blocks executed 96%
  1822702:   81:void OpAsmPrinter::printFunctionalType(Operation *op) {
  1822702:   82:  auto &os = getStream();
call    0 returned 100%
  1822702:   83:  os << '(';
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
  1822700:   84:  llvm::interleaveComma(op->getOperands(), os, [&](Value operand) {
call    0 returned 100%
call    1 returned 100%
        -:   85:    // Print the types of null values as <<NULL TYPE>>.
  2098320:   86:    *this << (operand ? operand.getType() : Type());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:   87:  });
  1822700:   88:  os << ") -> ";
call    0 returned 100%
        -:   89:
        -:   90:  // Print the result list.  We don't parenthesize single result types unless
        -:   91:  // it is a function (avoiding a grammar ambiguity).
  1822701:   92:  bool wrapped = op->getNumResults() != 1;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  1822701:   93:  if (!wrapped && op->getResult(0).getType() &&
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
 1804086*:   94:      op->getResult(0).getType().isa<FunctionType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   95:    wrapped = true;
        -:   96:
 1822701*:   97:  if (wrapped)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    18615:   98:    os << '(';
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -:   99:
 3626786*:  100:  llvm::interleaveComma(op->getResults(), os, [&](const OpResult &result) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
        -:  101:    // Print the types of null values as <<NULL TYPE>>.
 1804086*:  102:    *this << (result ? result.getType() : Type());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  103:  });
        -:  104:
  1822700:  105:  if (wrapped)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    18614:  106:    os << ')';
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  1822700:  107:}
        -:  108:
        -:  109://===----------------------------------------------------------------------===//
        -:  110:// Operation OpAsm interface.
        -:  111://===----------------------------------------------------------------------===//
        -:  112:
        -:  113:/// The OpAsmOpInterface, see OpAsmInterface.td for more details.
        -:  114:#include "mlir/IR/OpAsmInterface.cpp.inc"
        -:  115:
        -:  116:LogicalResult
function _ZNK4mlir21OpAsmDialectInterface13parseResourceERNS_22AsmParsedResourceEntryE called 0 returned 0% blocks executed 0%
    #####:  117:OpAsmDialectInterface::parseResource(AsmParsedResourceEntry &entry) const {
    #####:  118:  return entry.emitError() << "unknown 'resource' key '" << entry.getKey()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  119:                           << "' for dialect '" << getDialect()->getNamespace()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  120:                           << "'";
call    0 never executed
        -:  121:}
        -:  122:
        -:  123://===----------------------------------------------------------------------===//
        -:  124:// OpPrintingFlags
        -:  125://===----------------------------------------------------------------------===//
        -:  126:
        -:  127:namespace {
        -:  128:/// This struct contains command line options that can be used to initialize
        -:  129:/// various bits of the AsmPrinter. This uses a struct wrapper to avoid the need
        -:  130:/// for global command line options.
        -:  131:struct AsmPrinterOptions {
        -:  132:  llvm::cl::opt<int64_t> printElementsAttrWithHexIfLarger{
        -:  133:      "mlir-print-elementsattrs-with-hex-if-larger",
        -:  134:      llvm::cl::desc(
        -:  135:          "Print DenseElementsAttrs with a hex string that have "
        -:  136:          "more elements than the given upper limit (use -1 to disable)")};
        -:  137:
        -:  138:  llvm::cl::opt<unsigned> elideElementsAttrIfLarger{
        -:  139:      "mlir-elide-elementsattrs-if-larger",
        -:  140:      llvm::cl::desc("Elide ElementsAttrs with \"...\" that have "
        -:  141:                     "more elements than the given upper limit")};
        -:  142:
        -:  143:  llvm::cl::opt<bool> printDebugInfoOpt{
        -:  144:      "mlir-print-debuginfo", llvm::cl::init(false),
        -:  145:      llvm::cl::desc("Print debug info in MLIR output")};
        -:  146:
        -:  147:  llvm::cl::opt<bool> printPrettyDebugInfoOpt{
        -:  148:      "mlir-pretty-debuginfo", llvm::cl::init(false),
        -:  149:      llvm::cl::desc("Print pretty debug info in MLIR output")};
        -:  150:
        -:  151:  // Use the generic op output form in the operation printer even if the custom
        -:  152:  // form is defined.
        -:  153:  llvm::cl::opt<bool> printGenericOpFormOpt{
        -:  154:      "mlir-print-op-generic", llvm::cl::init(false),
        -:  155:      llvm::cl::desc("Print the generic op form"), llvm::cl::Hidden};
        -:  156:
        -:  157:  llvm::cl::opt<bool> assumeVerifiedOpt{
        -:  158:      "mlir-print-assume-verified", llvm::cl::init(false),
        -:  159:      llvm::cl::desc("Skip op verification when using custom printers"),
        -:  160:      llvm::cl::Hidden};
        -:  161:
        -:  162:  llvm::cl::opt<bool> printLocalScopeOpt{
        -:  163:      "mlir-print-local-scope", llvm::cl::init(false),
        -:  164:      llvm::cl::desc("Print with local scope and inline information (eliding "
        -:  165:                     "aliases for attributes, types, and locations")};
        -:  166:
        -:  167:  llvm::cl::opt<bool> printValueUsers{
        -:  168:      "mlir-print-value-users", llvm::cl::init(false),
        -:  169:      llvm::cl::desc(
        -:  170:          "Print users of operation results and block arguments as a comment")};
        -:  171:};
        -:  172:} // namespace
        -:  173:
        -:  174:static llvm::ManagedStatic<AsmPrinterOptions> clOptions;
        -:  175:
        -:  176:/// Register a set of useful command-line options that can be used to configure
        -:  177:/// various flags within the AsmPrinter.
function _ZN4mlir27registerAsmPrinterCLOptionsEv called 325564 returned 100% blocks executed 100%
   325564:  178:void mlir::registerAsmPrinterCLOptions() {
        -:  179:  // Make sure that the options struct has been initialized.
   325564:  180:  *clOptions;
call    0 returned 100%
   325564:  181:}
        -:  182:
        -:  183:/// Initialize the printing flags with default supplied by the cl::opts above.
function _ZN4mlir15OpPrintingFlagsC2Ev called 687390 returned 100% blocks executed 73%
   687390:  184:OpPrintingFlags::OpPrintingFlags()
        -:  185:    : printDebugInfoFlag(false), printDebugInfoPrettyFormFlag(false),
        -:  186:      printGenericOpFormFlag(false), assumeVerifiedFlag(false),
   687390:  187:      printLocalScope(false), printValueUsersFlag(false) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -:  188:  // Initialize based upon command line options, if they are available.
   687390:  189:  if (!clOptions.isConstructed())
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -:  190:    return;
   361825:  191:  if (clOptions->elideElementsAttrIfLarger.getNumOccurrences())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  192:    elementsAttrElementLimit = clOptions->elideElementsAttrIfLarger;
call    0 never executed
branch  1 never executed
branch  2 never executed
   361824:  193:  printDebugInfoFlag = clOptions->printDebugInfoOpt;
call    0 returned 100%
call    1 returned 100%
   361824:  194:  printDebugInfoPrettyFormFlag = clOptions->printPrettyDebugInfoOpt;
call    0 returned 100%
call    1 returned 100%
   361824:  195:  printGenericOpFormFlag = clOptions->printGenericOpFormOpt;
call    0 returned 100%
call    1 returned 100%
   361822:  196:  assumeVerifiedFlag = clOptions->assumeVerifiedOpt;
call    0 returned 100%
call    1 returned 100%
   361820:  197:  printLocalScope = clOptions->printLocalScopeOpt;
call    0 returned 100%
call    1 returned 100%
   361819:  198:  printValueUsersFlag = clOptions->printValueUsers;
call    0 returned 100%
        -:  199:}
        -:  200:
        -:  201:/// Enable the elision of large elements attributes, by printing a '...'
        -:  202:/// instead of the element data, when the number of elements is greater than
        -:  203:/// `largeElementLimit`. Note: The IR generated with this option is not
        -:  204:/// parsable.
        -:  205:OpPrintingFlags &
function _ZN4mlir15OpPrintingFlags23elideLargeElementsAttrsEl called 124367 returned 100% blocks executed 75%
   124367:  206:OpPrintingFlags::elideLargeElementsAttrs(int64_t largeElementLimit) {
   124367:  207:  elementsAttrElementLimit = largeElementLimit;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   124367:  208:  return *this;
        -:  209:}
        -:  210:
        -:  211:/// Enable printing of debug information. If 'prettyForm' is set to true,
        -:  212:/// debug information is printed in a more readable 'pretty' form.
function _ZN4mlir15OpPrintingFlags15enableDebugInfoEb called 0 returned 0% blocks executed 0%
    #####:  213:OpPrintingFlags &OpPrintingFlags::enableDebugInfo(bool prettyForm) {
    #####:  214:  printDebugInfoFlag = true;
    #####:  215:  printDebugInfoPrettyFormFlag = prettyForm;
    #####:  216:  return *this;
        -:  217:}
        -:  218:
        -:  219:/// Always print operations in the generic form.
function _ZN4mlir15OpPrintingFlags18printGenericOpFormEv called 83843 returned 100% blocks executed 100%
    83843:  220:OpPrintingFlags &OpPrintingFlags::printGenericOpForm() {
    83843:  221:  printGenericOpFormFlag = true;
    83843:  222:  return *this;
        -:  223:}
        -:  224:
        -:  225:/// Do not verify the operation when using custom operation printers.
function _ZN4mlir15OpPrintingFlags14assumeVerifiedEv called 0 returned 0% blocks executed 0%
    #####:  226:OpPrintingFlags &OpPrintingFlags::assumeVerified() {
    #####:  227:  assumeVerifiedFlag = true;
    #####:  228:  return *this;
        -:  229:}
        -:  230:
        -:  231:/// Use local scope when printing the operation. This allows for using the
        -:  232:/// printer in a more localized and thread-safe setting, but may not necessarily
        -:  233:/// be identical of what the IR will look like when dumping the full module.
function _ZN4mlir15OpPrintingFlags13useLocalScopeEv called 128507 returned 100% blocks executed 100%
  128507*:  234:OpPrintingFlags &OpPrintingFlags::useLocalScope() {
  128507*:  235:  printLocalScope = true;
  128507*:  236:  return *this;
        -:  237:}
        -:  238:
        -:  239:/// Print users of values as comments.
function _ZN4mlir15OpPrintingFlags15printValueUsersEv called 0 returned 0% blocks executed 0%
    #####:  240:OpPrintingFlags &OpPrintingFlags::printValueUsers() {
    #####:  241:  printValueUsersFlag = true;
    #####:  242:  return *this;
        -:  243:}
        -:  244:
        -:  245:/// Return if the given ElementsAttr should be elided.
function _ZNK4mlir15OpPrintingFlags23shouldElideElementsAttrENS_12ElementsAttrE called 536289 returned 100% blocks executed 86%
   536289:  246:bool OpPrintingFlags::shouldElideElementsAttr(ElementsAttr attr) const {
   590986:  247:  return elementsAttrElementLimit &&
   536289:  248:         *elementsAttrElementLimit < int64_t(attr.getNumElements()) &&
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 taken 9% (fallthrough)
branch  4 taken 91%
     4667:  249:         !attr.isa<SplatElementsAttr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  250:}
        -:  251:
        -:  252:/// Return the size limit for printing large ElementsAttr.
function _ZNK4mlir15OpPrintingFlags25getLargeElementsAttrLimitEv called 9763 returned 100% blocks executed 100%
     9763:  253:Optional<int64_t> OpPrintingFlags::getLargeElementsAttrLimit() const {
     9763:  254:  return elementsAttrElementLimit;
        -:  255:}
        -:  256:
        -:  257:/// Return if debug information should be printed.
function _ZNK4mlir15OpPrintingFlags20shouldPrintDebugInfoEv called 0 returned 0% blocks executed 0%
 5029035*:  258:bool OpPrintingFlags::shouldPrintDebugInfo() const {
 5029035*:  259:  return printDebugInfoFlag;
        -:  260:}
        -:  261:
        -:  262:/// Return if debug information should be printed in the pretty form.
function _ZNK4mlir15OpPrintingFlags30shouldPrintDebugInfoPrettyFormEv called 0 returned 0% blocks executed 0%
   31891*:  263:bool OpPrintingFlags::shouldPrintDebugInfoPrettyForm() const {
   31891*:  264:  return printDebugInfoPrettyFormFlag;
        -:  265:}
        -:  266:
        -:  267:/// Return if operations should be printed in the generic form.
function _ZNK4mlir15OpPrintingFlags24shouldPrintGenericOpFormEv called 0 returned 0% blocks executed 0%
10996802*:  268:bool OpPrintingFlags::shouldPrintGenericOpForm() const {
10996802*:  269:  return printGenericOpFormFlag;
        -:  270:}
        -:  271:
        -:  272:/// Return if operation verification should be skipped.
function _ZNK4mlir15OpPrintingFlags20shouldAssumeVerifiedEv called 0 returned 0% blocks executed 0%
  206630*:  273:bool OpPrintingFlags::shouldAssumeVerified() const {
  206630*:  274:  return assumeVerifiedFlag;
        -:  275:}
        -:  276:
        -:  277:/// Return if the printer should use local scope when dumping the IR.
function _ZNK4mlir15OpPrintingFlags19shouldUseLocalScopeEv called 0 returned 0% blocks executed 0%
  291514*:  278:bool OpPrintingFlags::shouldUseLocalScope() const { return printLocalScope; }
        -:  279:
        -:  280:/// Return if the printer should print users of values.
function _ZNK4mlir15OpPrintingFlags21shouldPrintValueUsersEv called 0 returned 0% blocks executed 0%
 3431474*:  281:bool OpPrintingFlags::shouldPrintValueUsers() const {
 3431474*:  282:  return printValueUsersFlag;
        -:  283:}
        -:  284:
        -:  285:/// Returns true if an ElementsAttr with the given number of elements should be
        -:  286:/// printed with hex.
function _ZL30shouldPrintElementsAttrWithHexl called 250234 returned 100% blocks executed 56%
   250234:  287:static bool shouldPrintElementsAttrWithHex(int64_t numElements) {
        -:  288:  // Check to see if a command line option was provided for the limit.
   250234:  289:  if (clOptions.isConstructed()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   250234:  290:    if (clOptions->printElementsAttrWithHexIfLarger.getNumOccurrences()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  291:      // -1 is used to disable hex printing.
    #####:  292:      if (clOptions->printElementsAttrWithHexIfLarger == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:        return false;
    #####:  294:      return numElements > clOptions->printElementsAttrWithHexIfLarger;
call    0 never executed
        -:  295:    }
        -:  296:  }
        -:  297:
        -:  298:  // Otherwise, default to printing with hex if the number of elements is >100.
   250234:  299:  return numElements > 100;
        -:  300:}
        -:  301:
        -:  302://===----------------------------------------------------------------------===//
        -:  303:// NewLineCounter
        -:  304://===----------------------------------------------------------------------===//
        -:  305:
        -:  306:namespace {
        -:  307:/// This class is a simple formatter that emits a new line when inputted into a
        -:  308:/// stream, that enables counting the number of newlines emitted. This class
        -:  309:/// should be used whenever emitting newlines in the printer.
  356114*:  310:struct NewLineCounter {
        -:  311:  unsigned curLine = 1;
        -:  312:};
        -:  313:
        -:  314:static raw_ostream &operator<<(raw_ostream &os, NewLineCounter &newLine) {
        -:  315:  ++newLine.curLine;
        -:  316:  return os << '\n';
        -:  317:}
        -:  318:} // namespace
        -:  319:
        -:  320://===----------------------------------------------------------------------===//
        -:  321:// AsmPrinter::Impl
        -:  322://===----------------------------------------------------------------------===//
        -:  323:
        -:  324:namespace mlir {
        -:  325:class AsmPrinter::Impl {
        -:  326:public:
        -:  327:  Impl(raw_ostream &os, AsmStateImpl &state);
        -:  328:  explicit Impl(Impl &other) : Impl(other.os, other.state) {}
        -:  329:
        -:  330:  /// Returns the output stream of the printer.
 5205805*:  331:  raw_ostream &getStream() { return os; }
        -:  332:
        -:  333:  template <typename Container, typename UnaryFunctor>
 3790115*:  334:  inline void interleaveComma(const Container &c, UnaryFunctor eachFn) const {
   21333*:  335:    llvm::interleaveComma(c, os, eachFn);
call    0 returned 100%
call    1 returned 100%
        -:  336:  }
        -:  337:
        -:  338:  /// This enum describes the different kinds of elision for the type of an
        -:  339:  /// attribute when printing it.
        -:  340:  enum class AttrTypeElision {
        -:  341:    /// The type must not be elided,
        -:  342:    Never,
        -:  343:    /// The type may be elided when it matches the default used in the parser
        -:  344:    /// (for example i64 is the default for integer attributes).
        -:  345:    May,
        -:  346:    /// The type must be elided.
        -:  347:    Must
        -:  348:  };
        -:  349:
        -:  350:  /// Print the given attribute or an alias.
        -:  351:  void printAttribute(Attribute attr,
        -:  352:                      AttrTypeElision typeElision = AttrTypeElision::Never);
        -:  353:  /// Print the given attribute without considering an alias.
        -:  354:  void printAttributeImpl(Attribute attr,
        -:  355:                          AttrTypeElision typeElision = AttrTypeElision::Never);
        -:  356:
        -:  357:  /// Print the alias for the given attribute, return failure if no alias could
        -:  358:  /// be printed.
        -:  359:  LogicalResult printAlias(Attribute attr);
        -:  360:
        -:  361:  /// Print the given type or an alias.
        -:  362:  void printType(Type type);
        -:  363:  /// Print the given type.
        -:  364:  void printTypeImpl(Type type);
        -:  365:
        -:  366:  /// Print the alias for the given type, return failure if no alias could
        -:  367:  /// be printed.
        -:  368:  LogicalResult printAlias(Type type);
        -:  369:
        -:  370:  /// Print the given location to the stream. If `allowAlias` is true, this
        -:  371:  /// allows for the internal location to use an attribute alias.
        -:  372:  void printLocation(LocationAttr loc, bool allowAlias = false);
        -:  373:
        -:  374:  /// Print a reference to the given resource that is owned by the given
        -:  375:  /// dialect.
        -:  376:  void printResourceHandle(const AsmDialectResourceHandle &resource);
        -:  377:
        -:  378:  void printAffineMap(AffineMap map);
        -:  379:  void
        -:  380:  printAffineExpr(AffineExpr expr,
        -:  381:                  function_ref<void(unsigned, bool)> printValueName = nullptr);
        -:  382:  void printAffineConstraint(AffineExpr expr, bool isEq);
        -:  383:  void printIntegerSet(IntegerSet set);
        -:  384:
        -:  385:protected:
        -:  386:  void printOptionalAttrDict(ArrayRef<NamedAttribute> attrs,
        -:  387:                             ArrayRef<StringRef> elidedAttrs = {},
        -:  388:                             bool withKeyword = false);
        -:  389:  void printNamedAttribute(NamedAttribute attr);
        -:  390:  void printTrailingLocation(Location loc, bool allowAlias = true);
        -:  391:  void printLocationInternal(LocationAttr loc, bool pretty = false);
        -:  392:
        -:  393:  /// Print a dense elements attribute. If 'allowHex' is true, a hex string is
        -:  394:  /// used instead of individual elements when the elements attr is large.
        -:  395:  void printDenseElementsAttr(DenseElementsAttr attr, bool allowHex);
        -:  396:
        -:  397:  /// Print a dense string elements attribute.
        -:  398:  void printDenseStringElementsAttr(DenseStringElementsAttr attr);
        -:  399:
        -:  400:  /// Print a dense elements attribute. If 'allowHex' is true, a hex string is
        -:  401:  /// used instead of individual elements when the elements attr is large.
        -:  402:  void printDenseIntOrFPElementsAttr(DenseIntOrFPElementsAttr attr,
        -:  403:                                     bool allowHex);
        -:  404:
        -:  405:  /// Print a dense array attribute.
        -:  406:  void printDenseArrayAttr(DenseArrayAttr attr);
        -:  407:
        -:  408:  void printDialectAttribute(Attribute attr);
        -:  409:  void printDialectType(Type type);
        -:  410:
        -:  411:  /// Print an escaped string, wrapped with "".
        -:  412:  void printEscapedString(StringRef str);
        -:  413:
        -:  414:  /// Print a hex string, wrapped with "".
        -:  415:  void printHexString(StringRef str);
        -:  416:  void printHexString(ArrayRef<char> data);
        -:  417:
        -:  418:  /// This enum is used to represent the binding strength of the enclosing
        -:  419:  /// context that an AffineExprStorage is being printed in, so we can
        -:  420:  /// intelligently produce parens.
        -:  421:  enum class BindingStrength {
        -:  422:    Weak,   // + and -
        -:  423:    Strong, // All other binary operators.
        -:  424:  };
        -:  425:  void printAffineExprInternal(
        -:  426:      AffineExpr expr, BindingStrength enclosingTightness,
        -:  427:      function_ref<void(unsigned, bool)> printValueName = nullptr);
        -:  428:
        -:  429:  /// The output stream for the printer.
        -:  430:  raw_ostream &os;
        -:  431:
        -:  432:  /// An underlying assembly printer state.
        -:  433:  AsmStateImpl &state;
        -:  434:
        -:  435:  /// A set of flags to control the printer's behavior.
        -:  436:  OpPrintingFlags printerFlags;
        -:  437:
        -:  438:  /// A tracker for the number of new lines emitted during printing.
        -:  439:  NewLineCounter newLine;
        -:  440:};
        -:  441:} // namespace mlir
        -:  442:
        -:  443://===----------------------------------------------------------------------===//
        -:  444:// AliasInitializer
        -:  445://===----------------------------------------------------------------------===//
        -:  446:
        -:  447:namespace {
        -:  448:/// This class represents a specific instance of a symbol Alias.
        -:  449:class SymbolAlias {
        -:  450:public:
   13010*:  451:  SymbolAlias(StringRef name, uint32_t suffixIndex, bool isDeferrable)
   13010*:  452:      : name(name), suffixIndex(suffixIndex), isDeferrable(isDeferrable) {}
        -:  453:
        -:  454:  /// Print this alias to the given stream.
function _ZNK12_GLOBAL__N_111SymbolAlias5printERN4llvm11raw_ostreamE called 24626 returned 100% blocks executed 100%
    24626:  455:  void print(raw_ostream &os) const {
    24626:  456:    os << name;
call    0 returned 100%
    24626:  457:    if (suffixIndex)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
    22483:  458:      os << suffixIndex;
call    0 returned 100%
    24626:  459:  }
        -:  460:
        -:  461:  /// Returns true if this alias supports deferred resolution when parsing.
   26020*:  462:  bool canBeDeferred() const { return isDeferrable; }
        -:  463:
        -:  464:private:
        -:  465:  /// The main name of the alias.
        -:  466:  StringRef name;
        -:  467:  /// The suffix index of the alias.
        -:  468:  uint32_t suffixIndex : 31;
        -:  469:  /// A flag indicating whether this alias may be deferred or not.
        -:  470:  bool isDeferrable : 1;
        -:  471:};
        -:  472:
        -:  473:/// This class represents a utility that initializes the set of attribute and
        -:  474:/// type aliases, without the need to store the extra information within the
        -:  475:/// main AliasState class or pass it around via function arguments.
        -:  476:class AliasInitializer {
        -:  477:public:
function _ZN12_GLOBAL__N_116AliasInitializerC2ERN4mlir26DialectInterfaceCollectionINS1_21OpAsmDialectInterfaceEEERN4llvm20BumpPtrAllocatorImplINS6_15MallocAllocatorELm4096ELm4096ELm128EEE called 155501 returned 100% blocks executed 100%
   155501:  478:  AliasInitializer(
        -:  479:      DialectInterfaceCollection<OpAsmDialectInterface> &interfaces,
        -:  480:      llvm::BumpPtrAllocator &aliasAllocator)
   155501:  481:      : interfaces(interfaces), aliasAllocator(aliasAllocator),
   155501:  482:        aliasOS(aliasBuffer) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  483:
        -:  484:  void initialize(Operation *op, const OpPrintingFlags &printerFlags,
        -:  485:                  llvm::MapVector<Attribute, SymbolAlias> &attrToAlias,
        -:  486:                  llvm::MapVector<Type, SymbolAlias> &typeToAlias);
        -:  487:
        -:  488:  /// Visit the given attribute to see if it has an alias. `canBeDeferred` is
        -:  489:  /// set to true if the originator of this attribute can resolve the alias
        -:  490:  /// after parsing has completed (e.g. in the case of operation locations).
        -:  491:  /// Returns the maximum alias depth of the attribute.
 2308110*:  492:  size_t visit(Attribute attr, bool canBeDeferred = false) {
   13525*:  493:    return visitImpl(attr, attrAliases, canBeDeferred);
call    0 returned 100%
call    1 never executed
call    2 returned 100%
        -:  494:  }
        -:  495:
        -:  496:  /// Visit the given type to see if it has an alias. Returns the maximum alias
        -:  497:  /// depth of the type.
 5203550*:  498:  size_t visit(Type type) { return visitImpl(type, typeAliases); }
        -:  499:
        -:  500:private:
        -:  501:  struct InProgressAliasInfo {
  7511658:  502:    InProgressAliasInfo() : aliasDepth(0), canBeDeferred(false) {}
   13010*:  503:    InProgressAliasInfo(StringRef alias, bool canBeDeferred)
   13010*:  504:        : alias(alias), aliasDepth(0), canBeDeferred(canBeDeferred) {}
        -:  505:
        -:  506:    bool operator<(const InProgressAliasInfo &rhs) const {
        -:  507:      // Order first by depth, and then by name.
        -:  508:      if (aliasDepth != rhs.aliasDepth)
        -:  509:        return aliasDepth < rhs.aliasDepth;
        -:  510:      return alias < rhs.alias;
        -:  511:    }
        -:  512:
        -:  513:    /// The alias for the attribute or type, or None if the value has no alias.
        -:  514:    Optional<StringRef> alias;
        -:  515:    /// The alias depth of this attribute or type, i.e. an indication of the
        -:  516:    /// relative ordering of when to print this alias.
        -:  517:    unsigned aliasDepth : 31;
        -:  518:    /// If this alias can be deferred or not.
        -:  519:    bool canBeDeferred : 1;
        -:  520:  };
        -:  521:
        -:  522:  /// Visit the given attribute or type to see if it has an alias.
        -:  523:  /// `canBeDeferred` is set to true if the originator of this value can resolve
        -:  524:  /// the alias after parsing has completed (e.g. in the case of operation
        -:  525:  /// locations). Returns the maximum alias depth of the value.
        -:  526:  template <typename T>
        -:  527:  size_t visitImpl(T value, llvm::MapVector<T, InProgressAliasInfo> &aliases,
        -:  528:                   bool canBeDeferred = false);
        -:  529:
        -:  530:  /// Try to generate an alias for the provided symbol. If an alias is
        -:  531:  /// generated, the provided alias mapping and reverse mapping are updated.
        -:  532:  /// Returns success if an alias was generated, failure otherwise.
        -:  533:  template <typename T>
        -:  534:  LogicalResult generateAlias(T symbol, InProgressAliasInfo &alias,
        -:  535:                              bool canBeDeferred);
        -:  536:
        -:  537:  /// Given a collection of aliases and symbols, initialize a mapping from a
        -:  538:  /// symbol to a given alias.
        -:  539:  template <typename T>
        -:  540:  static void
        -:  541:  initializeAliases(llvm::MapVector<T, InProgressAliasInfo> &visitedSymbols,
        -:  542:                    llvm::MapVector<T, SymbolAlias> &symbolToAlias);
        -:  543:
        -:  544:  /// The set of asm interfaces within the context.
        -:  545:  DialectInterfaceCollection<OpAsmDialectInterface> &interfaces;
        -:  546:
        -:  547:  /// An allocator used for alias names.
        -:  548:  llvm::BumpPtrAllocator &aliasAllocator;
        -:  549:
        -:  550:  /// The set of built aliases.
        -:  551:  llvm::MapVector<Attribute, InProgressAliasInfo> attrAliases;
        -:  552:  llvm::MapVector<Type, InProgressAliasInfo> typeAliases;
        -:  553:
        -:  554:  /// Storage and stream used when generating an alias.
        -:  555:  SmallString<32> aliasBuffer;
        -:  556:  llvm::raw_svector_ostream aliasOS;
        -:  557:};
        -:  558:
        -:  559:/// This class implements a dummy OpAsmPrinter that doesn't print any output,
        -:  560:/// and merely collects the attributes and types that *would* be printed in a
        -:  561:/// normal print invocation so that we can generate proper aliases. This allows
        -:  562:/// for us to generate aliases only for the attributes and types that would be
        -:  563:/// in the output, and trims down unnecessary output.
   311002:  564:class DummyAliasOperationPrinter : private OpAsmPrinter {
        -:  565:public:
   155501:  566:  explicit DummyAliasOperationPrinter(const OpPrintingFlags &printerFlags,
        -:  567:                                      AliasInitializer &initializer)
   155501:  568:      : printerFlags(printerFlags), initializer(initializer) {}
        -:  569:
        -:  570:  /// Prints the entire operation with the custom assembly form, if available,
        -:  571:  /// or the generic assembly form, otherwise.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter22printCustomOrGenericOpEPN4mlir9OperationE called 2045912 returned 100% blocks executed 85%
  2045912:  572:  void printCustomOrGenericOp(Operation *op) override {
        -:  573:    // Visit the operation location.
  2045912:  574:    if (printerFlags.shouldPrintDebugInfo())
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    11773:  575:      initializer.visit(op->getLoc(), /*canBeDeferred=*/true);
call    0 returned 100%
        -:  576:
        -:  577:    // If requested, always print the generic form.
  2045912:  578:    if (!printerFlags.shouldPrintGenericOpForm()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  579:      // Check to see if this is a known operation.  If so, use the registered
        -:  580:      // custom printer hook.
  4091798:  581:      if (auto opInfo = op->getRegisteredInfo()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  2045899:  582:        opInfo->printAssembly(op, *this, /*defaultDialect=*/"");
call    0 returned 100%
  2045899:  583:        return;
        -:  584:      }
        -:  585:    }
        -:  586:
        -:  587:    // Otherwise print with the generic assembly form.
       13:  588:    printGenericOp(op);
call    0 returned 100%
        -:  589:  }
        -:  590:
        -:  591:private:
        -:  592:  /// Print the given operation in the generic form.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter14printGenericOpEPN4mlir9OperationEb called 1548739 returned 100% blocks executed 100%
  1548739:  593:  void printGenericOp(Operation *op, bool printOpName = true) override {
        -:  594:    // Consider nested operations for aliases.
  1548739:  595:    if (op->getNumRegions() != 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       18:  596:      for (Region &region : op->getRegions())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        6:  597:        printRegion(region, /*printEntryBlockArgs=*/true,
call    0 returned 100%
        -:  598:                    /*printBlockTerminators=*/true);
        -:  599:    }
        -:  600:
        -:  601:    // Visit all the types used in the operation.
  5142253:  602:    for (Type type : op->getOperandTypes())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
  3593514:  603:      printType(type);
  6194938:  604:    for (Type type : op->getResultTypes())
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
  3097460:  605:      printType(type);
        -:  606:
        -:  607:    // Consider the attributes of the operation for aliases.
  2570012:  608:    for (const NamedAttribute &attr : op->getAttrs())
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
  1021273:  609:      printAttribute(attr.getValue());
call    0 returned 100%
  1548739:  610:  }
        -:  611:
        -:  612:  /// Print the given block. If 'printBlockArgs' is false, the arguments of the
        -:  613:  /// block are not printed. If 'printBlockTerminator' is false, the terminator
        -:  614:  /// operation of the block is not printed.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter5printEPN4mlir5BlockEbb called 312852 returned 100% blocks executed 86%
   312852:  615:  void print(Block *block, bool printBlockArgs = true,
        -:  616:             bool printBlockTerminator = true) {
        -:  617:    // Consider the types of the block arguments for aliases if 'printBlockArgs'
        -:  618:    // is set to true.
   312852:  619:    if (printBlockArgs) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   156337:  620:      for (BlockArgument arg : block->getArguments()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        4:  621:        printType(arg.getType());
call    0 returned 100%
        -:  622:
        -:  623:        // Visit the argument location.
        4:  624:        if (printerFlags.shouldPrintDebugInfo())
        -:  625:          // TODO: Allow deferring argument locations.
    #####:  626:          initializer.visit(arg.getLoc(), /*canBeDeferred=*/false);
call    0 never executed
        -:  627:      }
        -:  628:    }
        -:  629:
        -:  630:    // Consider the operations within this block, ignoring the terminator if
        -:  631:    // requested.
   312852:  632:    bool hasTerminator =
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   624866:  633:        !block->empty() && block->back().hasTrait<OpTrait::IsTerminator>();
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
   312852:  634:    auto range = llvm::make_range(
        -:  635:        block->begin(),
        -:  636:        std::prev(block->end(),
   625704:  637:                  (!hasTerminator || printBlockTerminator) ? 0 : 1));
  2203263:  638:    for (Operation &op : range)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
  1890411:  639:      printCustomOrGenericOp(&op);
call    0 returned 100%
   312852:  640:  }
        -:  641:
        -:  642:  /// Print the given region.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter11printRegionERN4mlir6RegionEbbb called 312852 returned 100% blocks executed 69%
   312852:  643:  void printRegion(Region &region, bool printEntryBlockArgs,
        -:  644:                   bool printBlockTerminators,
        -:  645:                   bool printEmptyBlock = false) override {
   312852:  646:    if (region.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  647:      return;
        -:  648:
   312852:  649:    auto *entryBlock = &region.front();
call    0 returned 100%
   312852:  650:    print(entryBlock, printEntryBlockArgs, printBlockTerminators);
call    0 returned 100%
  625704*:  651:    for (Block &b : llvm::drop_begin(region, 1))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  652:      print(&b);
call    0 never executed
        -:  653:  }
        -:  654:
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter19printRegionArgumentEN4mlir13BlockArgumentEN4llvm8ArrayRefINS1_14NamedAttributeEEEb called 311960 returned 100% blocks executed 100%
   311960:  655:  void printRegionArgument(BlockArgument arg, ArrayRef<NamedAttribute> argAttrs,
        -:  656:                           bool omitType) override {
   311960:  657:    printType(arg.getType());
call    0 returned 100%
        -:  658:    // Visit the argument location.
   311960:  659:    if (printerFlags.shouldPrintDebugInfo())
        -:  660:      // TODO: Allow deferring argument locations.
     1752:  661:      initializer.visit(arg.getLoc(), /*canBeDeferred=*/false);
call    0 returned 100%
   311960:  662:  }
        -:  663:
        -:  664:  /// Consider the given type to be printed for an alias.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter9printTypeEN4mlir4TypeE called 746137 returned 100% blocks executed 100%
  4403588:  665:  void printType(Type type) override { initializer.visit(type); }
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 returned 100%
call    8 returned 100%
        -:  666:
        -:  667:  /// Consider the given attribute to be printed for an alias.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter14printAttributeEN4mlir9AttributeE called 4408 returned 100% blocks executed 100%
 1383047*:  668:  void printAttribute(Attribute attr) override { initializer.visit(attr); }
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 returned 100%
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter25printAttributeWithoutTypeEN4mlir9AttributeE called 108 returned 100% blocks executed 100%
      108:  669:  void printAttributeWithoutType(Attribute attr) override {
      108:  670:    printAttribute(attr);
call    0 returned 100%
      108:  671:  }
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter10printAliasEN4mlir9AttributeE called 554 returned 100% blocks executed 100%
      554:  672:  LogicalResult printAlias(Attribute attr) override {
      554:  673:    initializer.visit(attr);
call    0 returned 100%
      554:  674:    return success();
        -:  675:  }
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter10printAliasEN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:  676:  LogicalResult printAlias(Type type) override {
    #####:  677:    initializer.visit(type);
call    0 never executed
    #####:  678:    return success();
        -:  679:  }
        -:  680:
        -:  681:  /// Consider the given location to be printed for an alias.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter30printOptionalLocationSpecifierEN4mlir8LocationE called 0 returned 0% blocks executed 0%
    #####:  682:  void printOptionalLocationSpecifier(Location loc) override {
    #####:  683:    printAttribute(loc);
call    0 never executed
    #####:  684:  }
        -:  685:
        -:  686:  /// Print the given set of attributes with names not included within
        -:  687:  /// 'elidedAttrs'.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter21printOptionalAttrDictEN4llvm8ArrayRefIN4mlir14NamedAttributeEEENS2_INS1_9StringRefEEE called 851000 returned 100% blocks executed 100%
   851000:  688:  void printOptionalAttrDict(ArrayRef<NamedAttribute> attrs,
        -:  689:                             ArrayRef<StringRef> elidedAttrs = {}) override {
   851000:  690:    if (attrs.empty())
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
   668859:  691:      return;
   535981:  692:    if (elidedAttrs.empty()) {
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
   707680:  693:      for (const NamedAttribute &attr : attrs)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   353840:  694:        printAttribute(attr.getValue());
call    0 returned 100%
        -:  695:      return;
        -:  696:    }
   364282:  697:    llvm::SmallDenseSet<StringRef> elidedAttrsSet(elidedAttrs.begin(),
   364282:  698:                                                  elidedAttrs.end());
call    0 returned 100%
   873937:  699:    for (const NamedAttribute &attr : attrs)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
   691796:  700:      if (!elidedAttrsSet.contains(attr.getName().strref()))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 1% (fallthrough)
branch  4 taken 99%
     3526:  701:        printAttribute(attr.getValue());
call    0 returned 100%
        -:  702:  }
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter32printOptionalAttrDictWithKeywordEN4llvm8ArrayRefIN4mlir14NamedAttributeEEENS2_INS1_9StringRefEEE called 331656 returned 100% blocks executed 100%
   331656:  703:  void printOptionalAttrDictWithKeyword(
        -:  704:      ArrayRef<NamedAttribute> attrs,
        -:  705:      ArrayRef<StringRef> elidedAttrs = {}) override {
   331656:  706:    printOptionalAttrDict(attrs, elidedAttrs);
call    0 returned 100%
   331656:  707:  }
        -:  708:
        -:  709:  /// Return a null stream as the output stream, this will ignore any data fed
        -:  710:  /// to it.
function _ZNK12_GLOBAL__N_126DummyAliasOperationPrinter9getStreamEv called 2867646 returned 100% blocks executed 100%
  2867646:  711:  raw_ostream &getStream() const override { return os; }
        -:  712:
        -:  713:  /// The following are hooks of `OpAsmPrinter` that are not necessary for
        -:  714:  /// determining potential aliases.
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter10printFloatERKN4llvm7APFloatE called 0 returned 0% blocks executed 0%
    #####:  715:  void printFloat(const APFloat &value) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter22printAffineMapOfSSAIdsEN4mlir13AffineMapAttrENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  716:  void printAffineMapOfSSAIds(AffineMapAttr, ValueRange) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter23printAffineExprOfSSAIdsEN4mlir10AffineExprENS1_10ValueRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  717:  void printAffineExprOfSSAIds(AffineExpr, ValueRange, ValueRange) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter12printNewlineEv called 0 returned 0% blocks executed 0%
    #####:  718:  void printNewline() override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter14increaseIndentEv called 0 returned 0% blocks executed 0%
    #####:  719:  void increaseIndent() override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter14decreaseIndentEv called 0 returned 0% blocks executed 0%
    #####:  720:  void decreaseIndent() override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter12printOperandEN4mlir5ValueE called 359059 returned 100% blocks executed 100%
   359059:  721:  void printOperand(Value) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter12printOperandEN4mlir5ValueERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  722:  void printOperand(Value, raw_ostream &os) override {
        -:  723:    // Users expect the output string to have at least the prefixed % to signal
        -:  724:    // a value name. To maintain this invariant, emit a name even if it is
        -:  725:    // guaranteed to go unused.
    #####:  726:    os << "%";
call    0 never executed
    #####:  727:  }
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter20printKeywordOrStringEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  728:  void printKeywordOrString(StringRef) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter15printSymbolNameEN4llvm9StringRefE called 176393 returned 100% blocks executed 100%
   176393:  729:  void printSymbolName(StringRef) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter14printSuccessorEPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  730:  void printSuccessor(Block *) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter24printSuccessorAndUseListEPN4mlir5BlockENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  731:  void printSuccessorAndUseList(Block *, ValueRange) override {}
function _ZN12_GLOBAL__N_126DummyAliasOperationPrinter16shadowRegionArgsERN4mlir6RegionENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  732:  void shadowRegionArgs(Region &, ValueRange) override {}
        -:  733:
        -:  734:  /// The printer flags to use when determining potential aliases.
        -:  735:  const OpPrintingFlags &printerFlags;
        -:  736:
        -:  737:  /// The initializer to use when identifying aliases.
        -:  738:  AliasInitializer &initializer;
        -:  739:
        -:  740:  /// A dummy output stream.
        -:  741:  mutable llvm::raw_null_ostream os;
        -:  742:};
        -:  743:} // namespace
        -:  744:
        -:  745:/// Sanitize the given name such that it can be used as a valid identifier. If
        -:  746:/// the string needs to be modified in any way, the provided buffer is used to
        -:  747:/// store the new copy,
function _ZL18sanitizeIdentifierN4llvm9StringRefERNS_11SmallStringILj16EEES0_b called 519955 returned 100% blocks executed 59%
   519955:  748:static StringRef sanitizeIdentifier(StringRef name, SmallString<16> &buffer,
        -:  749:                                    StringRef allowedPunctChars = "$._-",
        -:  750:                                    bool allowTrailingDigit = true) {
  519955*:  751:  assert(!name.empty() && "Shouldn't have an empty name here");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  752:
function _ZZL18sanitizeIdentifierN4llvm9StringRefERNS_11SmallStringILj16EEES0_bENKUlvE_clEv called 0 returned 0% blocks executed 0%
  519955*:  753:  auto copyNameToBuffer = [&] {
    #####:  754:    for (char ch : name) {
branch  0 never executed
branch  1 never executed
    #####:  755:      if (llvm::isAlnum(ch) || allowedPunctChars.contains(ch))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  756:        buffer.push_back(ch);
call    0 never executed
    #####:  757:      else if (ch == ' ')
branch  0 never executed
branch  1 never executed
    #####:  758:        buffer.push_back('_');
call    0 never executed
        -:  759:      else
    #####:  760:        buffer.append(llvm::utohexstr((unsigned char)ch));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  761:    }
  519955*:  762:  };
        -:  763:
        -:  764:  // Check to see if this name is valid. If it starts with a digit, then it
        -:  765:  // could conflict with the autogenerated numeric ID's, so add an underscore
        -:  766:  // prefix to avoid problems.
   519955:  767:  if (isdigit(name[0])) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  768:    buffer.push_back('_');
call    0 never executed
    #####:  769:    copyNameToBuffer();
call    0 never executed
    #####:  770:    return buffer;
        -:  771:  }
        -:  772:
        -:  773:  // If the name ends with a trailing digit, add a '_' to avoid potential
        -:  774:  // conflicts with autogenerated ID's.
   519955:  775:  if (!allowTrailingDigit && isdigit(name.back())) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  776:    copyNameToBuffer();
call    0 never executed
    #####:  777:    buffer.push_back('_');
call    0 never executed
    #####:  778:    return buffer;
        -:  779:  }
        -:  780:
        -:  781:  // Check to see that the name consists of only valid identifier characters.
  2579525:  782:  for (char ch : name) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
  2564556:  783:    if (!llvm::isAlnum(ch) && !allowedPunctChars.contains(ch)) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####:  784:      copyNameToBuffer();
call    0 never executed
    #####:  785:      return buffer;
        -:  786:    }
        -:  787:  }
        -:  788:
        -:  789:  // If there are no invalid characters, return the original name.
   519955:  790:  return name;
        -:  791:}
        -:  792:
        -:  793:/// Given a collection of aliases and symbols, initialize a mapping from a
        -:  794:/// symbol to a given alias.
        -:  795:template <typename T>
   311002:  796:void AliasInitializer::initializeAliases(
        -:  797:    llvm::MapVector<T, InProgressAliasInfo> &visitedSymbols,
        -:  798:    llvm::MapVector<T, SymbolAlias> &symbolToAlias) {
   622004:  799:  std::vector<std::pair<T, InProgressAliasInfo>> unprocessedAliases =
        -:  800:      visitedSymbols.takeVector();
   311002:  801:  llvm::stable_sort(unprocessedAliases, [](const auto &lhs, const auto &rhs) {
        -:  802:    return lhs.second < rhs.second;
        -:  803:  });
        -:  804:
   311002:  805:  llvm::StringMap<unsigned> nameCounts;
  2775839:  806:  for (auto &[symbol, aliasInfo] : unprocessedAliases) {
  2464837:  807:    if (!aliasInfo.alias)
  2451827:  808:      continue;
   13010*:  809:    StringRef alias = *aliasInfo.alias;
   13010*:  810:    unsigned nameIndex = nameCounts[alias]++;
   13010*:  811:    symbolToAlias.insert(
   13010*:  812:        {symbol, SymbolAlias(alias, nameIndex, aliasInfo.canBeDeferred)});
        -:  813:  }
   311002:  814:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer17initializeAliasesIN4mlir4TypeEEEvRN4llvm9MapVectorIT_NS0_19InProgressAliasInfoENS4_8DenseMapIS6_jNS4_12DenseMapInfoIS6_vEENS4_6detail12DenseMapPairIS6_jEEEESt6vectorISt4pairIS6_S7_ESaISH_EEEERNS5_IS6_NS_11SymbolAliasESE_SF_ISG_IS6_SM_ESaISN_EEEE:
function _ZN12_GLOBAL__N_116AliasInitializer17initializeAliasesIN4mlir4TypeEEEvRN4llvm9MapVectorIT_NS0_19InProgressAliasInfoENS4_8DenseMapIS6_jNS4_12DenseMapInfoIS6_vEENS4_6detail12DenseMapPairIS6_jEEEESt6vectorISt4pairIS6_S7_ESaISH_EEEERNS5_IS6_NS_11SymbolAliasESE_SF_ISG_IS6_SM_ESaISN_EEEE called 155501 returned 100% blocks executed 80%
   155501:  796:void AliasInitializer::initializeAliases(
call    0 returned 100%
        -:  797:    llvm::MapVector<T, InProgressAliasInfo> &visitedSymbols,
        -:  798:    llvm::MapVector<T, SymbolAlias> &symbolToAlias) {
   311002:  799:  std::vector<std::pair<T, InProgressAliasInfo>> unprocessedAliases =
        -:  800:      visitedSymbols.takeVector();
   155501:  801:  llvm::stable_sort(unprocessedAliases, [](const auto &lhs, const auto &rhs) {
call    0 returned 100%
        -:  802:    return lhs.second < rhs.second;
        -:  803:  });
        -:  804:
   155501:  805:  llvm::StringMap<unsigned> nameCounts;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
  1192561:  806:  for (auto &[symbol, aliasInfo] : unprocessedAliases) {
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  1037060:  807:    if (!aliasInfo.alias)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1037060:  808:      continue;
    #####:  809:    StringRef alias = *aliasInfo.alias;
call    0 never executed
    #####:  810:    unsigned nameIndex = nameCounts[alias]++;
    #####:  811:    symbolToAlias.insert(
    #####:  812:        {symbol, SymbolAlias(alias, nameIndex, aliasInfo.canBeDeferred)});
call    0 never executed
        -:  813:  }
   155501:  814:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer17initializeAliasesIN4mlir9AttributeEEEvRN4llvm9MapVectorIT_NS0_19InProgressAliasInfoENS4_8DenseMapIS6_jNS4_12DenseMapInfoIS6_vEENS4_6detail12DenseMapPairIS6_jEEEESt6vectorISt4pairIS6_S7_ESaISH_EEEERNS5_IS6_NS_11SymbolAliasESE_SF_ISG_IS6_SM_ESaISN_EEEE:
function _ZN12_GLOBAL__N_116AliasInitializer17initializeAliasesIN4mlir9AttributeEEEvRN4llvm9MapVectorIT_NS0_19InProgressAliasInfoENS4_8DenseMapIS6_jNS4_12DenseMapInfoIS6_vEENS4_6detail12DenseMapPairIS6_jEEEESt6vectorISt4pairIS6_S7_ESaISH_EEEERNS5_IS6_NS_11SymbolAliasESE_SF_ISG_IS6_SM_ESaISN_EEEE called 155501 returned 100% blocks executed 100%
   155501:  796:void AliasInitializer::initializeAliases(
call    0 returned 100%
        -:  797:    llvm::MapVector<T, InProgressAliasInfo> &visitedSymbols,
        -:  798:    llvm::MapVector<T, SymbolAlias> &symbolToAlias) {
   311002:  799:  std::vector<std::pair<T, InProgressAliasInfo>> unprocessedAliases =
        -:  800:      visitedSymbols.takeVector();
   155501:  801:  llvm::stable_sort(unprocessedAliases, [](const auto &lhs, const auto &rhs) {
call    0 returned 100%
        -:  802:    return lhs.second < rhs.second;
        -:  803:  });
        -:  804:
   155501:  805:  llvm::StringMap<unsigned> nameCounts;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
  1583278:  806:  for (auto &[symbol, aliasInfo] : unprocessedAliases) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
  1427777:  807:    if (!aliasInfo.alias)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  1414767:  808:      continue;
    13010:  809:    StringRef alias = *aliasInfo.alias;
call    0 returned 100%
    13010:  810:    unsigned nameIndex = nameCounts[alias]++;
    13010:  811:    symbolToAlias.insert(
    13010:  812:        {symbol, SymbolAlias(alias, nameIndex, aliasInfo.canBeDeferred)});
call    0 returned 100%
        -:  813:  }
   155501:  814:}
------------------
        -:  815:
function _ZN12_GLOBAL__N_116AliasInitializer10initializeEPN4mlir9OperationERKNS1_15OpPrintingFlagsERN4llvm9MapVectorINS1_9AttributeENS_11SymbolAliasENS7_8DenseMapIS9_jNS7_12DenseMapInfoIS9_vEENS7_6detail12DenseMapPairIS9_jEEEESt6vectorISt4pairIS9_SA_ESaISK_EEEERNS8_INS1_4TypeESA_NSB_ISP_jNSC_ISP_vEENSF_ISP_jEEEESI_ISJ_ISP_SA_ESaIST_EEEE called 155501 returned 100% blocks executed 100%
   155501:  816:void AliasInitializer::initialize(
        -:  817:    Operation *op, const OpPrintingFlags &printerFlags,
        -:  818:    llvm::MapVector<Attribute, SymbolAlias> &attrToAlias,
        -:  819:    llvm::MapVector<Type, SymbolAlias> &typeToAlias) {
        -:  820:  // Use a dummy printer when walking the IR so that we can collect the
        -:  821:  // attributes/types that will actually be used during printing when
        -:  822:  // considering aliases.
   155501:  823:  DummyAliasOperationPrinter aliasPrinter(printerFlags, *this);
call    0 returned 100%
   155501:  824:  aliasPrinter.printCustomOrGenericOp(op);
call    0 returned 100%
        -:  825:
        -:  826:  // Initialize the aliases sorted by name.
   155501:  827:  initializeAliases(attrAliases, attrToAlias);
call    0 returned 100%
   155501:  828:  initializeAliases(typeAliases, typeToAlias);
call    0 returned 100%
call    1 returned 100%
   155501:  829:}
        -:  830:
        -:  831:template <typename T>
        -:  832:size_t
  7511658:  833:AliasInitializer::visitImpl(T value,
        -:  834:                            llvm::MapVector<T, InProgressAliasInfo> &aliases,
        -:  835:                            bool canBeDeferred) {
  7511658:  836:  auto [it, inserted] = aliases.insert({value, InProgressAliasInfo()});
  7511658:  837:  if (!inserted) {
        -:  838:    // Make sure that the alias isn't deferred if we don't permit it.
  5046821:  839:    if (!canBeDeferred)
  5046259:  840:      it->second.canBeDeferred = false;
  5046821:  841:    return it->second.aliasDepth;
        -:  842:  }
        -:  843:
        -:  844:  // Try to generate an alias for this attribute.
  2464837:  845:  bool hasAlias = succeeded(generateAlias(value, it->second, canBeDeferred));
  2464837:  846:  size_t aliasIndex = std::distance(aliases.begin(), it);
        -:  847:
        -:  848:  // Check for any sub elements.
        -:  849:  using SubElementInterfaceT =
        -:  850:      std::conditional_t<std::is_same_v<T, Type>, SubElementTypeInterface,
        -:  851:                         SubElementAttrInterface>;
  2464837:  852:  if (auto subElementInterface = dyn_cast<SubElementInterfaceT>(value)) {
  1032609:  853:    size_t maxAliasDepth = 0;
  2743447:  854:    auto visitSubElement = [&](auto element) {
  1710838:  855:      if (Optional<size_t> depth = visit(element))
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 41% (fallthrough)
branch  3 taken 59%
branch  4 taken 26% (fallthrough)
branch  5 taken 74%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
  1710838:  856:        maxAliasDepth = std::max(maxAliasDepth, *depth + 1);
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 41% (fallthrough)
branch  3 taken 59%
branch  4 taken 26% (fallthrough)
branch  5 taken 74%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -:  857:    };
  1032609:  858:    subElementInterface.walkSubElements(visitSubElement, visitSubElement);
        -:  859:
        -:  860:    // Make sure to recompute `it` in case the map was reallocated.
  1032609:  861:    it = std::next(aliases.begin(), aliasIndex);
        -:  862:
        -:  863:    // If we had sub elements and an alias, update our main alias to account for
        -:  864:    // the depth.
  1032609:  865:    if (maxAliasDepth && hasAlias)
     289*:  866:      it->second.aliasDepth = maxAliasDepth;
        -:  867:  }
        -:  868:
        -:  869:  // Propagate the alias depth of the value.
  2464837:  870:  return it->second.aliasDepth;
        -:  871:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer9visitImplIN4mlir4TypeEEEmT_RN4llvm9MapVectorIS4_NS0_19InProgressAliasInfoENS5_8DenseMapIS4_jNS5_12DenseMapInfoIS4_vEENS5_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S7_ESaISH_EEEEb:
function _ZN12_GLOBAL__N_116AliasInitializer9visitImplIN4mlir4TypeEEEmT_RN4llvm9MapVectorIS4_NS0_19InProgressAliasInfoENS5_8DenseMapIS4_jNS5_12DenseMapInfoIS4_vEENS5_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S7_ESaISH_EEEEb called 5203548 returned 100% blocks executed 77%
  5203548:  833:AliasInitializer::visitImpl(T value,
call    0 returned 100%
        -:  834:                            llvm::MapVector<T, InProgressAliasInfo> &aliases,
        -:  835:                            bool canBeDeferred) {
  5203548:  836:  auto [it, inserted] = aliases.insert({value, InProgressAliasInfo()});
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
  5203548:  837:  if (!inserted) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  838:    // Make sure that the alias isn't deferred if we don't permit it.
  4166488:  839:    if (!canBeDeferred)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  4166488:  840:      it->second.canBeDeferred = false;
  4166488:  841:    return it->second.aliasDepth;
        -:  842:  }
        -:  843:
        -:  844:  // Try to generate an alias for this attribute.
  1037060:  845:  bool hasAlias = succeeded(generateAlias(value, it->second, canBeDeferred));
call    0 returned 100%
call    1 returned 100%
  1037060:  846:  size_t aliasIndex = std::distance(aliases.begin(), it);
call    0 returned 100%
        -:  847:
        -:  848:  // Check for any sub elements.
        -:  849:  using SubElementInterfaceT =
        -:  850:      std::conditional_t<std::is_same_v<T, Type>, SubElementTypeInterface,
        -:  851:                         SubElementAttrInterface>;
  1037060:  852:  if (auto subElementInterface = dyn_cast<SubElementInterfaceT>(value)) {
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23%
   794684:  853:    size_t maxAliasDepth = 0;
   794684:  854:    auto visitSubElement = [&](auto element) {
        -:  855:      if (Optional<size_t> depth = visit(element))
        -:  856:        maxAliasDepth = std::max(maxAliasDepth, *depth + 1);
        -:  857:    };
   794684:  858:    subElementInterface.walkSubElements(visitSubElement, visitSubElement);
call    0 returned 100%
        -:  859:
        -:  860:    // Make sure to recompute `it` in case the map was reallocated.
   794684:  861:    it = std::next(aliases.begin(), aliasIndex);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  862:
        -:  863:    // If we had sub elements and an alias, update our main alias to account for
        -:  864:    // the depth.
   794684:  865:    if (maxAliasDepth && hasAlias)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  866:      it->second.aliasDepth = maxAliasDepth;
        -:  867:  }
        -:  868:
        -:  869:  // Propagate the alias depth of the value.
  1037060:  870:  return it->second.aliasDepth;
        -:  871:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer9visitImplIN4mlir9AttributeEEEmT_RN4llvm9MapVectorIS4_NS0_19InProgressAliasInfoENS5_8DenseMapIS4_jNS5_12DenseMapInfoIS4_vEENS5_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S7_ESaISH_EEEEb:
function _ZN12_GLOBAL__N_116AliasInitializer9visitImplIN4mlir9AttributeEEEmT_RN4llvm9MapVectorIS4_NS0_19InProgressAliasInfoENS5_8DenseMapIS4_jNS5_12DenseMapInfoIS4_vEENS5_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S7_ESaISH_EEEEb called 2308110 returned 100% blocks executed 82%
  2308110:  833:AliasInitializer::visitImpl(T value,
call    0 returned 100%
        -:  834:                            llvm::MapVector<T, InProgressAliasInfo> &aliases,
        -:  835:                            bool canBeDeferred) {
  2308110:  836:  auto [it, inserted] = aliases.insert({value, InProgressAliasInfo()});
call    0 returned 100%
branch  1 taken 38% (fallthrough)
branch  2 taken 62%
  2308110:  837:  if (!inserted) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        -:  838:    // Make sure that the alias isn't deferred if we don't permit it.
   880333:  839:    if (!canBeDeferred)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   879771:  840:      it->second.canBeDeferred = false;
   880333:  841:    return it->second.aliasDepth;
        -:  842:  }
        -:  843:
        -:  844:  // Try to generate an alias for this attribute.
  1427777:  845:  bool hasAlias = succeeded(generateAlias(value, it->second, canBeDeferred));
call    0 returned 100%
call    1 returned 100%
  1427777:  846:  size_t aliasIndex = std::distance(aliases.begin(), it);
call    0 returned 100%
        -:  847:
        -:  848:  // Check for any sub elements.
        -:  849:  using SubElementInterfaceT =
        -:  850:      std::conditional_t<std::is_same_v<T, Type>, SubElementTypeInterface,
        -:  851:                         SubElementAttrInterface>;
  1427777:  852:  if (auto subElementInterface = dyn_cast<SubElementInterfaceT>(value)) {
call    0 returned 100%
branch  1 taken 17% (fallthrough)
branch  2 taken 83%
   237925:  853:    size_t maxAliasDepth = 0;
   237925:  854:    auto visitSubElement = [&](auto element) {
        -:  855:      if (Optional<size_t> depth = visit(element))
        -:  856:        maxAliasDepth = std::max(maxAliasDepth, *depth + 1);
        -:  857:    };
   237925:  858:    subElementInterface.walkSubElements(visitSubElement, visitSubElement);
call    0 returned 100%
        -:  859:
        -:  860:    // Make sure to recompute `it` in case the map was reallocated.
   237925:  861:    it = std::next(aliases.begin(), aliasIndex);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  862:
        -:  863:    // If we had sub elements and an alias, update our main alias to account for
        -:  864:    // the depth.
   237925:  865:    if (maxAliasDepth && hasAlias)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
      289:  866:      it->second.aliasDepth = maxAliasDepth;
        -:  867:  }
        -:  868:
        -:  869:  // Propagate the alias depth of the value.
  1427777:  870:  return it->second.aliasDepth;
        -:  871:}
------------------
        -:  872:
        -:  873:template <typename T>
  2464837:  874:LogicalResult AliasInitializer::generateAlias(T symbol,
        -:  875:                                              InProgressAliasInfo &alias,
        -:  876:                                              bool canBeDeferred) {
  4929674:  877:  SmallString<32> nameBuffer;
  5311472:  878:  for (const auto &interface : interfaces) {
  2846635:  879:    OpAsmDialectInterface::AliasResult result =
        -:  880:        interface.getAlias(symbol, aliasOS);
  2846635:  881:    if (result == OpAsmDialectInterface::AliasResult::NoAlias)
  2833625:  882:      continue;
   13010*:  883:    nameBuffer = std::move(aliasBuffer);
   13010*:  884:    assert(!nameBuffer.empty() && "expected valid alias name");
   13010*:  885:    if (result == OpAsmDialectInterface::AliasResult::FinalAlias)
        -:  886:      break;
        -:  887:  }
        -:  888:
  2464837:  889:  if (nameBuffer.empty())
  2464837:  890:    return failure();
        -:  891:
 2477847*:  892:  SmallString<16> tempBuffer;
        -:  893:  StringRef name =
   13010*:  894:      sanitizeIdentifier(nameBuffer, tempBuffer, /*allowedPunctChars=*/"$_-",
        -:  895:                         /*allowTrailingDigit=*/false);
   13010*:  896:  name = name.copy(aliasAllocator);
   13010*:  897:  alias = InProgressAliasInfo(name, canBeDeferred);
   13010*:  898:  return success();
        -:  899:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer13generateAliasIN4mlir4TypeEEENS2_13LogicalResultET_RNS0_19InProgressAliasInfoEb:
function _ZN12_GLOBAL__N_116AliasInitializer13generateAliasIN4mlir4TypeEEENS2_13LogicalResultET_RNS0_19InProgressAliasInfoEb called 1037060 returned 100% blocks executed 50%
  1037060:  874:LogicalResult AliasInitializer::generateAlias(T symbol,
        -:  875:                                              InProgressAliasInfo &alias,
        -:  876:                                              bool canBeDeferred) {
  2074120:  877:  SmallString<32> nameBuffer;
  2237236:  878:  for (const auto &interface : interfaces) {
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
  1200176:  879:    OpAsmDialectInterface::AliasResult result =
call    0 returned 100%
        -:  880:        interface.getAlias(symbol, aliasOS);
  1200176:  881:    if (result == OpAsmDialectInterface::AliasResult::NoAlias)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1200176:  882:      continue;
    #####:  883:    nameBuffer = std::move(aliasBuffer);
call    0 never executed
    #####:  884:    assert(!nameBuffer.empty() && "expected valid alias name");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  885:    if (result == OpAsmDialectInterface::AliasResult::FinalAlias)
branch  0 never executed
branch  1 never executed
        -:  886:      break;
        -:  887:  }
        -:  888:
  1037060:  889:  if (nameBuffer.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1037060:  890:    return failure();
        -:  891:
 1037060*:  892:  SmallString<16> tempBuffer;
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  893:  StringRef name =
    #####:  894:      sanitizeIdentifier(nameBuffer, tempBuffer, /*allowedPunctChars=*/"$_-",
call    0 never executed
        -:  895:                         /*allowTrailingDigit=*/false);
    #####:  896:  name = name.copy(aliasAllocator);
call    0 never executed
    #####:  897:  alias = InProgressAliasInfo(name, canBeDeferred);
branch  0 never executed
branch  1 never executed
    #####:  898:  return success();
branch  0 never executed
branch  1 never executed
        -:  899:}
------------------
_ZN12_GLOBAL__N_116AliasInitializer13generateAliasIN4mlir9AttributeEEENS2_13LogicalResultET_RNS0_19InProgressAliasInfoEb:
function _ZN12_GLOBAL__N_116AliasInitializer13generateAliasIN4mlir9AttributeEEENS2_13LogicalResultET_RNS0_19InProgressAliasInfoEb called 1427777 returned 100% blocks executed 85%
  1427777:  874:LogicalResult AliasInitializer::generateAlias(T symbol,
        -:  875:                                              InProgressAliasInfo &alias,
        -:  876:                                              bool canBeDeferred) {
  2855554:  877:  SmallString<32> nameBuffer;
  3074236:  878:  for (const auto &interface : interfaces) {
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
  1646459:  879:    OpAsmDialectInterface::AliasResult result =
call    0 returned 100%
        -:  880:        interface.getAlias(symbol, aliasOS);
  1646459:  881:    if (result == OpAsmDialectInterface::AliasResult::NoAlias)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  1633449:  882:      continue;
    13010:  883:    nameBuffer = std::move(aliasBuffer);
call    0 returned 100%
   13010*:  884:    assert(!nameBuffer.empty() && "expected valid alias name");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    13010:  885:    if (result == OpAsmDialectInterface::AliasResult::FinalAlias)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  886:      break;
        -:  887:  }
        -:  888:
  1427777:  889:  if (nameBuffer.empty())
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  1427777:  890:    return failure();
        -:  891:
  1440787:  892:  SmallString<16> tempBuffer;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  893:  StringRef name =
    13010:  894:      sanitizeIdentifier(nameBuffer, tempBuffer, /*allowedPunctChars=*/"$_-",
call    0 returned 100%
        -:  895:                         /*allowTrailingDigit=*/false);
    13010:  896:  name = name.copy(aliasAllocator);
call    0 returned 100%
    13010:  897:  alias = InProgressAliasInfo(name, canBeDeferred);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    13010:  898:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  899:}
------------------
        -:  900:
        -:  901://===----------------------------------------------------------------------===//
        -:  902:// AliasState
        -:  903://===----------------------------------------------------------------------===//
        -:  904:
        -:  905:namespace {
        -:  906:/// This class manages the state for type and attribute aliases.
        -:  907:class AliasState {
        -:  908:public:
        -:  909:  // Initialize the internal aliases.
        -:  910:  void
        -:  911:  initialize(Operation *op, const OpPrintingFlags &printerFlags,
        -:  912:             DialectInterfaceCollection<OpAsmDialectInterface> &interfaces);
        -:  913:
        -:  914:  /// Get an alias for the given attribute if it has one and print it in `os`.
        -:  915:  /// Returns success if an alias was printed, failure otherwise.
        -:  916:  LogicalResult getAlias(Attribute attr, raw_ostream &os) const;
        -:  917:
        -:  918:  /// Get an alias for the given type if it has one and print it in `os`.
        -:  919:  /// Returns success if an alias was printed, failure otherwise.
        -:  920:  LogicalResult getAlias(Type ty, raw_ostream &os) const;
        -:  921:
        -:  922:  /// Print all of the referenced aliases that can not be resolved in a deferred
        -:  923:  /// manner.
   155501:  924:  void printNonDeferredAliases(AsmPrinter::Impl &p, NewLineCounter &newLine) {
   155501:  925:    printAliases(p, newLine, /*isDeferred=*/false);
        -:  926:  }
        -:  927:
        -:  928:  /// Print all of the referenced aliases that support deferred resolution.
   155501:  929:  void printDeferredAliases(AsmPrinter::Impl &p, NewLineCounter &newLine) {
   155501:  930:    printAliases(p, newLine, /*isDeferred=*/true);
        -:  931:  }
        -:  932:
        -:  933:private:
        -:  934:  /// Print all of the referenced aliases that support the provided resolution
        -:  935:  /// behavior.
        -:  936:  void printAliases(AsmPrinter::Impl &p, NewLineCounter &newLine,
        -:  937:                    bool isDeferred);
        -:  938:
        -:  939:  /// Mapping between attribute and alias.
        -:  940:  llvm::MapVector<Attribute, SymbolAlias> attrToAlias;
        -:  941:  /// Mapping between type and alias.
        -:  942:  llvm::MapVector<Type, SymbolAlias> typeToAlias;
        -:  943:
        -:  944:  /// An allocator used for alias names.
        -:  945:  llvm::BumpPtrAllocator aliasAllocator;
        -:  946:};
        -:  947:} // namespace
        -:  948:
function _ZN12_GLOBAL__N_110AliasState10initializeEPN4mlir9OperationERKNS1_15OpPrintingFlagsERNS1_26DialectInterfaceCollectionINS1_21OpAsmDialectInterfaceEEE called 155501 returned 100% blocks executed 100%
   155501:  949:void AliasState::initialize(
        -:  950:    Operation *op, const OpPrintingFlags &printerFlags,
        -:  951:    DialectInterfaceCollection<OpAsmDialectInterface> &interfaces) {
   311002:  952:  AliasInitializer initializer(interfaces, aliasAllocator);
call    0 returned 100%
call    1 returned 100%
   155501:  953:  initializer.initialize(op, printerFlags, attrToAlias, typeToAlias);
call    0 returned 100%
   155501:  954:}
        -:  955:
function _ZNK12_GLOBAL__N_110AliasState8getAliasEN4mlir9AttributeERN4llvm11raw_ostreamE called 3821100 returned 100% blocks executed 100%
  3821100:  956:LogicalResult AliasState::getAlias(Attribute attr, raw_ostream &os) const {
  3821100:  957:  auto it = attrToAlias.find(attr);
call    0 returned 100%
  3821102:  958:  if (it == attrToAlias.end())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  3809486:  959:    return failure();
    23232:  960:  it->second.print(os << '#');
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
    11616:  961:  return success();
        -:  962:}
        -:  963:
function _ZNK12_GLOBAL__N_110AliasState8getAliasEN4mlir4TypeERN4llvm11raw_ostreamE called 11808405 returned 100% blocks executed 44%
 11808405:  964:LogicalResult AliasState::getAlias(Type ty, raw_ostream &os) const {
 11808405:  965:  auto it = typeToAlias.find(ty);
call    0 returned 100%
 11808404:  966:  if (it == typeToAlias.end())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 11808404:  967:    return failure();
        -:  968:
    #####:  969:  it->second.print(os << '!');
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  970:  return success();
        -:  971:}
        -:  972:
function _ZN12_GLOBAL__N_110AliasState12printAliasesERN4mlir10AsmPrinter4ImplERNS_14NewLineCounterEb called 311002 returned 100% blocks executed 56%
   311002:  973:void AliasState::printAliases(AsmPrinter::Impl &p, NewLineCounter &newLine,
        -:  974:                              bool isDeferred) {
  337022*:  975:  auto filterFn = [=](const auto &aliasIt) {
   26020*:  976:    return aliasIt.second.canBeDeferred() == isDeferred;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
   311002:  977:  };
   648024:  978:  for (auto &[attr, alias] : llvm::make_filter_range(attrToAlias, filterFn)) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
branch  2 taken 15% (fallthrough)
branch  3 taken 85%
    26020:  979:    alias.print(p.getStream() << '#');
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
call    2 returned 100%
    13010:  980:    p.getStream() << " = ";
call    0 returned 100%
        -:  981:
        -:  982:    // TODO: Support nested aliases in mutable attributes.
    13010:  983:    if (attr.hasTrait<AttributeTrait::IsMutable>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  984:      p.getStream() << attr;
call    0 never executed
        -:  985:    else
    13010:  986:      p.printAttributeImpl(attr);
call    0 returned 100%
        -:  987:
    13010:  988:    p.getStream() << newLine;
call    0 returned 100%
        -:  989:  }
  622004*:  990:  for (auto &[type, alias] : llvm::make_filter_range(typeToAlias, filterFn)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  991:    alias.print(p.getStream() << '!');
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  992:    p.getStream() << " = ";
call    0 never executed
        -:  993:
        -:  994:    // TODO: Support nested aliases in mutable types.
    #####:  995:    if (type.hasTrait<TypeTrait::IsMutable>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  996:      p.getStream() << type;
call    0 never executed
        -:  997:    else
    #####:  998:      p.printTypeImpl(type);
call    0 never executed
        -:  999:
    #####: 1000:    p.getStream() << newLine;
call    0 never executed
        -: 1001:  }
   311002: 1002:}
        -: 1003:
        -: 1004://===----------------------------------------------------------------------===//
        -: 1005:// SSANameState
        -: 1006://===----------------------------------------------------------------------===//
        -: 1007:
        -: 1008:namespace {
        -: 1009:/// Info about block printing: a number which is its position in the visitation
        -: 1010:/// order, and a name that is used to print reference to it, e.g. ^bb42.
    #####: 1011:struct BlockInfo {
        -: 1012:  int ordering;
        -: 1013:  StringRef name;
        -: 1014:};
        -: 1015:
        -: 1016:/// This class manages the state of SSA value names.
        -: 1017:class SSANameState {
        -: 1018:public:
        -: 1019:  /// A sentinel value used for values with names set.
        -: 1020:  enum : unsigned { NameSentinel = ~0U };
        -: 1021:
        -: 1022:  SSANameState(Operation *op, const OpPrintingFlags &printerFlags);
function _ZN12_GLOBAL__N_112SSANameStateC2Ev called 31746 returned 100% blocks executed 100%
    31746: 1023:  SSANameState() = default;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
        -: 1024:
        -: 1025:  /// Print the SSA identifier for the given value to 'stream'. If
        -: 1026:  /// 'printResultNo' is true, it also presents the result number ('#' number)
        -: 1027:  /// of this value.
        -: 1028:  void printValueID(Value value, bool printResultNo, raw_ostream &stream) const;
        -: 1029:
        -: 1030:  /// Print the operation identifier.
        -: 1031:  void printOperationID(Operation *op, raw_ostream &stream) const;
        -: 1032:
        -: 1033:  /// Return the result indices for each of the result groups registered by this
        -: 1034:  /// operation, or empty if none exist.
        -: 1035:  ArrayRef<int> getOpResultGroups(Operation *op);
        -: 1036:
        -: 1037:  /// Get the info for the given block.
        -: 1038:  BlockInfo getBlockInfo(Block *block);
        -: 1039:
        -: 1040:  /// Renumber the arguments for the specified region to the same names as the
        -: 1041:  /// SSA values in namesToUse. See OperationPrinter::shadowRegionArgs for
        -: 1042:  /// details.
        -: 1043:  void shadowRegionArgs(Region &region, ValueRange namesToUse);
        -: 1044:
        -: 1045:private:
        -: 1046:  /// Number the SSA values within the given IR unit.
        -: 1047:  void numberValuesInRegion(Region &region);
        -: 1048:  void numberValuesInBlock(Block &block);
        -: 1049:  void numberValuesInOp(Operation &op);
        -: 1050:
        -: 1051:  /// Given a result of an operation 'result', find the result group head
        -: 1052:  /// 'lookupValue' and the result of 'result' within that group in
        -: 1053:  /// 'lookupResultNo'. 'lookupResultNo' is only filled in if the result group
        -: 1054:  /// has more than 1 result.
        -: 1055:  void getResultIDAndNumber(OpResult result, Value &lookupValue,
        -: 1056:                            Optional<int> &lookupResultNo) const;
        -: 1057:
        -: 1058:  /// Set a special value name for the given value.
        -: 1059:  void setValueName(Value value, StringRef name);
        -: 1060:
        -: 1061:  /// Uniques the given value name within the printer. If the given name
        -: 1062:  /// conflicts, it is automatically renamed.
        -: 1063:  StringRef uniqueValueName(StringRef name);
        -: 1064:
        -: 1065:  /// This is the value ID for each SSA value. If this returns NameSentinel,
        -: 1066:  /// then the valueID has an entry in valueNames.
        -: 1067:  DenseMap<Value, unsigned> valueIDs;
        -: 1068:  DenseMap<Value, StringRef> valueNames;
        -: 1069:
        -: 1070:  /// When printing users of values, an operation without a result might
        -: 1071:  /// be the user. This map holds ids for such operations.
        -: 1072:  DenseMap<Operation *, unsigned> operationIDs;
        -: 1073:
        -: 1074:  /// This is a map of operations that contain multiple named result groups,
        -: 1075:  /// i.e. there may be multiple names for the results of the operation. The
        -: 1076:  /// value of this map are the result numbers that start a result group.
        -: 1077:  DenseMap<Operation *, SmallVector<int, 1>> opResultGroups;
        -: 1078:
        -: 1079:  /// This maps blocks to there visitation number in the current region as well
        -: 1080:  /// as the string representing their name.
        -: 1081:  DenseMap<Block *, BlockInfo> blockNames;
        -: 1082:
        -: 1083:  /// This keeps track of all of the non-numeric names that are in flight,
        -: 1084:  /// allowing us to check for duplicates.
        -: 1085:  /// Note: the value of the map is unused.
        -: 1086:  llvm::ScopedHashTable<StringRef, char> usedNames;
        -: 1087:  llvm::BumpPtrAllocator usedNameAllocator;
        -: 1088:
        -: 1089:  /// This is the next value ID to assign in numbering.
        -: 1090:  unsigned nextValueID = 0;
        -: 1091:  /// This is the next ID to assign to a region entry block argument.
        -: 1092:  unsigned nextArgumentID = 0;
        -: 1093:  /// This is the next ID to assign when a name conflict is detected.
        -: 1094:  unsigned nextConflictID = 0;
        -: 1095:
        -: 1096:  /// These are the printing flags.  They control, eg., whether to print in
        -: 1097:  /// generic form.
        -: 1098:  OpPrintingFlags printerFlags;
        -: 1099:};
        -: 1100:} // namespace
        -: 1101:
function _ZN12_GLOBAL__N_112SSANameStateC2EPN4mlir9OperationERKNS1_15OpPrintingFlagsE called 290479 returned 100% blocks executed 96%
   290479: 1102:SSANameState::SSANameState(Operation *op, const OpPrintingFlags &printerFlags)
   290479: 1103:    : printerFlags(printerFlags) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
   290480: 1104:  llvm::SaveAndRestore<unsigned> valueIDSaver(nextValueID);
call    0 returned 100%
   580966: 1105:  llvm::SaveAndRestore<unsigned> argumentIDSaver(nextArgumentID);
   580966: 1106:  llvm::SaveAndRestore<unsigned> conflictIDSaver(nextConflictID);
        -: 1107:
        -: 1108:  // The naming context includes `nextValueID`, `nextArgumentID`,
        -: 1109:  // `nextConflictID` and `usedNames` scoped HashTable. This information is
        -: 1110:  // carried from the parent region.
   290480: 1111:  using UsedNamesScopeTy = llvm::ScopedHashTable<StringRef, char>::ScopeTy;
   290480: 1112:  using NamingContext =
        -: 1113:      std::tuple<Region *, unsigned, unsigned, unsigned, UsedNamesScopeTy *>;
        -: 1114:
        -: 1115:  // Allocator for UsedNamesScopeTy
   871449: 1116:  llvm::BumpPtrAllocator allocator;
        -: 1117:
        -: 1118:  // Add a scope for the top level operation.
   290480: 1119:  auto *topLevelNamesScope =
call    0 returned 100%
   290485: 1120:      new (allocator.Allocate<UsedNamesScopeTy>()) UsedNamesScopeTy(usedNames);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1121:
   580968: 1122:  SmallVector<NamingContext, 8> nameContext;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
   871455: 1123:  for (Region &region : op->getRegions())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
   290485: 1124:    nameContext.push_back(std::make_tuple(&region, nextValueID, nextArgumentID,
   290485: 1125:                                          nextConflictID, topLevelNamesScope));
call    0 returned 100%
        -: 1126:
   290485: 1127:  numberValuesInOp(*op);
call    0 returned 100%
        -: 1128:
   765476: 1129:  while (!nameContext.empty()) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
   474990: 1130:    Region *region;
   474990: 1131:    UsedNamesScopeTy *parentScope;
   474988: 1132:    std::tie(region, nextValueID, nextArgumentID, nextConflictID, parentScope) =
   474990: 1133:        nameContext.pop_back_val();
call    0 returned 100%
        -: 1134:
        -: 1135:    // When we switch from one subtree to another, pop the scopes(needless)
        -: 1136:    // until the parent scope.
   497693: 1137:    while (usedNames.getCurScope() != parentScope) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
    22705: 1138:      usedNames.getCurScope()->~UsedNamesScopeTy();
call    0 returned 100%
   22705*: 1139:      assert((usedNames.getCurScope() != nullptr || parentScope == nullptr) &&
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1140:             "top level parentScope must be a nullptr");
        -: 1141:    }
        -: 1142:
        -: 1143:    // Add a scope for the current region.
   474988: 1144:    auto *curNamesScope = new (allocator.Allocate<UsedNamesScopeTy>())
call    0 returned 100%
   474987: 1145:        UsedNamesScopeTy(usedNames);
call    0 returned 100%
        -: 1146:
   474987: 1147:    numberValuesInRegion(*region);
call    0 returned 100%
        -: 1148:
  6032033: 1149:    for (Operation &op : region->getOps())
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
call    3 returned 100%
  7577248: 1150:      for (Region &region : op.getRegions())
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
   184506: 1151:        nameContext.push_back(std::make_tuple(&region, nextValueID,
   184506: 1152:                                              nextArgumentID, nextConflictID,
call    0 returned 100%
        -: 1153:                                              curNamesScope));
        -: 1154:  }
        -: 1155:
        -: 1156:  // Manually remove all the scopes.
  1033248: 1157:  while (usedNames.getCurScope() != nullptr)
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
   742765: 1158:    usedNames.getCurScope()->~UsedNamesScopeTy();
call    0 returned 100%
   290486: 1159:}
        -: 1160:
function _ZNK12_GLOBAL__N_112SSANameState12printValueIDEN4mlir5ValueEbRN4llvm11raw_ostreamE called 4641535 returned 100% blocks executed 69%
  4641535: 1161:void SSANameState::printValueID(Value value, bool printResultNo,
        -: 1162:                                raw_ostream &stream) const {
  4641535: 1163:  if (!value) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1164:    stream << "<<NULL VALUE>>";
    #####: 1165:    return;
call    0 never executed
        -: 1166:  }
        -: 1167:
  4641535: 1168:  Optional<int> resultNo;
  4641535: 1169:  auto lookupValue = value;
        -: 1170:
        -: 1171:  // If this is an operation result, collect the head lookup value of the result
        -: 1172:  // group and the result number of 'result' within that group.
  4641535: 1173:  if (OpResult result = dyn_cast<OpResult>(value))
call    0 returned 100%
branch  1 taken 81% (fallthrough)
branch  2 taken 19%
  3772898: 1174:    getResultIDAndNumber(result, lookupValue, resultNo);
call    0 returned 100%
        -: 1175:
  4641535: 1176:  auto it = valueIDs.find(lookupValue);
call    0 returned 100%
  4641535: 1177:  if (it == valueIDs.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1178:    stream << "<<UNKNOWN SSA VALUE>>";
    #####: 1179:    return;
call    0 never executed
        -: 1180:  }
        -: 1181:
  4641535: 1182:  stream << '%';
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
  4641535: 1183:  if (it->second != NameSentinel) {
call    0 returned 100%
branch  1 taken 81% (fallthrough)
branch  2 taken 19%
  3765623: 1184:    stream << it->second;
call    0 returned 100%
        -: 1185:  } else {
   875912: 1186:    auto nameIt = valueNames.find(lookupValue);
call    0 returned 100%
  875912*: 1187:    assert(nameIt != valueNames.end() && "Didn't have a name entry?");
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
   875912: 1188:    stream << nameIt->second;
call    0 returned 100%
call    1 returned 100%
        -: 1189:  }
        -: 1190:
 4641535*: 1191:  if (resultNo && printResultNo)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1192:    stream << '#' << resultNo;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1193:}
        -: 1194:
function _ZNK12_GLOBAL__N_112SSANameState16printOperationIDEPN4mlir9OperationERN4llvm11raw_ostreamE called 4368 returned 100% blocks executed 91%
     4368: 1195:void SSANameState::printOperationID(Operation *op, raw_ostream &stream) const {
     4368: 1196:  auto it = operationIDs.find(op);
call    0 returned 100%
     4368: 1197:  if (it == operationIDs.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1198:    stream << "<<UNKOWN OPERATION>>";
call    0 never executed
        -: 1199:  } else {
     8736: 1200:    stream << '%' << it->second;
branch  0 taken 37% (fallthrough)
branch  1 taken 63%
call    2 returned 100%
call    3 returned 100%
        -: 1201:  }
     4368: 1202:}
        -: 1203:
function _ZN12_GLOBAL__N_112SSANameState17getOpResultGroupsEPN4mlir9OperationE called 1813578 returned 100% blocks executed 75%
  1813578: 1204:ArrayRef<int> SSANameState::getOpResultGroups(Operation *op) {
  1813578: 1205:  auto it = opResultGroups.find(op);
call    0 returned 100%
 1813578*: 1206:  return it == opResultGroups.end() ? ArrayRef<int>() : it->second;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 never executed
        -: 1207:}
        -: 1208:
function _ZN12_GLOBAL__N_112SSANameState12getBlockInfoEPN4mlir5BlockE called 12378 returned 100% blocks executed 100%
    12378: 1209:BlockInfo SSANameState::getBlockInfo(Block *block) {
    12378: 1210:  auto it = blockNames.find(block);
call    0 returned 100%
    12378: 1211:  BlockInfo invalidBlock{-1, "INVALIDBLOCK"};
call    0 returned 100%
    12378: 1212:  return it != blockNames.end() ? it->second : invalidBlock;
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
        -: 1213:}
        -: 1214:
function _ZN12_GLOBAL__N_112SSANameState16shadowRegionArgsERN4mlir6RegionENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1215:void SSANameState::shadowRegionArgs(Region &region, ValueRange namesToUse) {
    #####: 1216:  assert(!region.empty() && "cannot shadow arguments of an empty region");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1217:  assert(region.getNumArguments() == namesToUse.size() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1218:         "incorrect number of names passed in");
    #####: 1219:  assert(region.getParentOp()->hasTrait<OpTrait::IsIsolatedFromAbove>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1220:         "only KnownIsolatedFromAbove ops can shadow names");
        -: 1221:
    #####: 1222:  SmallVector<char, 16> nameStr;
    #####: 1223:  for (unsigned i = 0, e = namesToUse.size(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1224:    auto nameToUse = namesToUse[i];
call    0 never executed
    #####: 1225:    if (nameToUse == nullptr)
branch  0 never executed
branch  1 never executed
    #####: 1226:      continue;
    #####: 1227:    auto nameToReplace = region.getArgument(i);
call    0 never executed
        -: 1228:
    #####: 1229:    nameStr.clear();
call    0 never executed
    #####: 1230:    llvm::raw_svector_ostream nameStream(nameStr);
call    0 never executed
    #####: 1231:    printValueID(nameToUse, /*printResultNo=*/true, nameStream);
call    0 never executed
        -: 1232:
        -: 1233:    // Entry block arguments should already have a pretty "arg" name.
    #####: 1234:    assert(valueIDs[nameToReplace] == NameSentinel);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1235:
        -: 1236:    // Use the name without the leading %.
    #####: 1237:    auto name = StringRef(nameStream.str()).drop_front();
call    0 never executed
        -: 1238:
        -: 1239:    // Overwrite the name.
    #####: 1240:    valueNames[nameToReplace] = name.copy(usedNameAllocator);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1241:  }
    #####: 1242:}
        -: 1243:
function _ZN12_GLOBAL__N_112SSANameState20numberValuesInRegionERN4mlir6RegionE called 474988 returned 100% blocks executed 89%
   474988: 1244:void SSANameState::numberValuesInRegion(Region &region) {
function _ZZN12_GLOBAL__N_112SSANameState20numberValuesInRegionERN4mlir6RegionEENKUlNS1_5ValueEN4llvm9StringRefEE_clES4_S6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1245:  auto setBlockArgNameFn = [&](Value arg, StringRef name) {
    #####: 1246:    assert(!valueIDs.count(arg) && "arg numbered multiple times");
call    0 never executed
call    1 never executed
    #####: 1247:    assert(arg.cast<BlockArgument>().getOwner()->getParent() == &region &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1248:           "arg not defined in current region");
    #####: 1249:    setValueName(arg, name);
call    0 never executed
  474988*: 1250:  };
        -: 1251:
   474988: 1252:  if (!printerFlags.shouldPrintGenericOpForm()) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
   384909: 1253:    if (Operation *op = region.getParentOp()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   384909: 1254:      if (auto asmInterface = dyn_cast<OpAsmOpInterface>(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   383332: 1255:        asmInterface.getAsmBlockArgumentNames(region, setBlockArgNameFn);
call    0 returned 100%
        -: 1256:    }
        -: 1257:  }
        -: 1258:
        -: 1259:  // Number the values within this region in a breadth-first order.
   474988: 1260:  unsigned nextBlockID = 0;
   926587: 1261:  for (auto &block : region) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1262:    // Each block gets a unique ID, and all of the operations within it get
        -: 1263:    // numbered as well.
   451600: 1264:    auto blockInfoIt = blockNames.insert({&block, {-1, ""}});
call    0 returned 100%
   451600: 1265:    if (blockInfoIt.second) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1266:      // This block hasn't been named through `getAsmBlockArgumentNames`, use
        -: 1267:      // default `^bbNNN` format.
   903200: 1268:      std::string name;
call    0 returned 100%
   451600: 1269:      llvm::raw_string_ostream(name) << "^bb" << nextBlockID;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   451600: 1270:      blockInfoIt.first->second.name = StringRef(name).copy(usedNameAllocator);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1271:    }
   451600: 1272:    blockInfoIt.first->second.ordering = nextBlockID++;
call    0 returned 100%
        -: 1273:
   451600: 1274:    numberValuesInBlock(block);
call    0 returned 100%
        -: 1275:  }
   474987: 1276:}
        -: 1277:
function _ZN12_GLOBAL__N_112SSANameState19numberValuesInBlockERN4mlir5BlockE called 451600 returned 100% blocks executed 88%
   451600: 1278:void SSANameState::numberValuesInBlock(Block &block) {
        -: 1279:  // Number the block arguments. We give entry block arguments a special name
        -: 1280:  // 'arg'.
   451600: 1281:  bool isEntryBlock = block.isEntryBlock();
call    0 returned 100%
   451600: 1282:  SmallString<32> specialNameBuffer(isEntryBlock ? "arg" : "");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
   903200: 1283:  llvm::raw_svector_ostream specialName(specialNameBuffer);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   951705: 1284:  for (auto arg : block.getArguments()) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
  500105*: 1285:    if (valueIDs.count(arg))
call    0 returned 100%
    #####: 1286:      continue;
   500105: 1287:    if (isEntryBlock) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   500105: 1288:      specialNameBuffer.resize(strlen("arg"));
call    0 returned 100%
   500105: 1289:      specialName << nextArgumentID++;
call    0 returned 100%
        -: 1290:    }
   500105: 1291:    setValueName(arg, specialName.str());
call    0 returned 100%
        -: 1292:  }
        -: 1293:
        -: 1294:  // Number the operations in this block.
  6008646: 1295:  for (auto &op : block)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
call    2 returned 100%
  5557046: 1296:    numberValuesInOp(op);
call    0 returned 100%
   451600: 1297:}
        -: 1298:
function _ZN12_GLOBAL__N_112SSANameState16numberValuesInOpERN4mlir9OperationE called 5847525 returned 100% blocks executed 78%
  5847525: 1299:void SSANameState::numberValuesInOp(Operation &op) {
        -: 1300:  // Function used to set the special result names for the operation.
 10930331: 1301:  SmallVector<int, 2> resultGroups(/*Size=*/1, /*Value=*/0);
call    0 returned 100%
function _ZZN12_GLOBAL__N_112SSANameState16numberValuesInOpERN4mlir9OperationEENKUlNS1_5ValueEN4llvm9StringRefEE_clES4_S6_ called 6840 returned 100% blocks executed 75%
  5854370: 1302:  auto setResultNameFn = [&](Value result, StringRef name) {
    6840*: 1303:    assert(!valueIDs.count(result) && "result numbered multiple times");
call    0 returned 100%
call    1 never executed
    6840*: 1304:    assert(result.getDefiningOp() == &op && "result not defined by 'op'");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     6840: 1305:    setValueName(result, name);
call    0 returned 100%
        -: 1306:
        -: 1307:    // Record the result number for groups not anchored at 0.
     6840: 1308:    if (int resultNo = result.cast<OpResult>().getResultNumber())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1309:      resultGroups.push_back(resultNo);
call    0 never executed
  5854370: 1310:  };
        -: 1311:  // Operations can customize the printing of block names in OpAsmOpInterface.
function _ZZN12_GLOBAL__N_112SSANameState16numberValuesInOpERN4mlir9OperationEENKUlPNS1_5BlockEN4llvm9StringRefEE0_clES5_S7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1312:  auto setBlockNameFn = [&](Block *block, StringRef name) {
    #####: 1313:    assert(block->getParentOp() == &op &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1314:           "getAsmBlockArgumentNames callback invoked on a block not directly "
        -: 1315:           "nested under the current operation");
    #####: 1316:    assert(!blockNames.count(block) && "block numbered multiple times");
call    0 never executed
call    1 never executed
    #####: 1317:    SmallString<16> tmpBuffer{"^"};
call    0 never executed
    #####: 1318:    name = sanitizeIdentifier(name, tmpBuffer);
call    0 never executed
    #####: 1319:    if (name.data() != tmpBuffer.data()) {
branch  0 never executed
branch  1 never executed
    #####: 1320:      tmpBuffer.append(name);
call    0 never executed
    #####: 1321:      name = tmpBuffer.str();
        -: 1322:    }
    #####: 1323:    name = name.copy(usedNameAllocator);
call    0 never executed
    #####: 1324:    blockNames[block] = {-1, name};
call    0 never executed
branch  1 never executed
branch  2 never executed
 5847530*: 1325:  };
        -: 1326:
  5847530: 1327:  if (!printerFlags.shouldPrintGenericOpForm()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
  2943079: 1328:    if (OpAsmOpInterface asmInterface = dyn_cast<OpAsmOpInterface>(&op)) {
call    0 returned 100%
branch  1 taken 13% (fallthrough)
branch  2 taken 87%
   390172: 1329:      asmInterface.getAsmBlockNames(setBlockNameFn);
call    0 returned 100%
   390172: 1330:      asmInterface.getAsmResultNames(setResultNameFn);
call    0 returned 100%
        -: 1331:    }
        -: 1332:  }
        -: 1333:
  5847530: 1334:  unsigned numResults = op.getNumResults();
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
  5847530: 1335:  if (numResults == 0) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
        -: 1336:    // If value users should be printed, operations with no result need an id.
   764724: 1337:    if (printerFlags.shouldPrintValueUsers()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     6478: 1338:      if (operationIDs.try_emplace(&op, nextValueID).second)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     6478: 1339:        ++nextValueID;
        -: 1340:    }
   764724: 1341:    return;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1342:  }
  5082806: 1343:  Value resultBegin = op.getResult(0);
call    0 returned 100%
        -: 1344:
        -: 1345:  // If the first result wasn't numbered, give it a default number.
  5082806: 1346:  if (valueIDs.try_emplace(resultBegin, nextValueID).second)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
  5075966: 1347:    ++nextValueID;
        -: 1348:
        -: 1349:  // If this operation has multiple result groups, mark it.
  5082806: 1350:  if (resultGroups.size() != 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1351:    llvm::array_pod_sort(resultGroups.begin(), resultGroups.end());
branch  0 never executed
branch  1 never executed
    #####: 1352:    opResultGroups.try_emplace(&op, std::move(resultGroups));
call    0 never executed
        -: 1353:  }
        -: 1354:}
        -: 1355:
function _ZNK12_GLOBAL__N_112SSANameState20getResultIDAndNumberEN4mlir8OpResultERNS1_5ValueERN4llvm8OptionalIiEE called 3772898 returned 100% blocks executed 11%
  3772898: 1356:void SSANameState::getResultIDAndNumber(OpResult result, Value &lookupValue,
        -: 1357:                                        Optional<int> &lookupResultNo) const {
  3772898: 1358:  Operation *owner = result.getOwner();
call    0 returned 100%
  3772898: 1359:  if (owner->getNumResults() == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  3772898: 1360:    return;
    #####: 1361:  int resultNo = result.getResultNumber();
call    0 never executed
        -: 1362:
        -: 1363:  // If this operation has multiple result groups, we will need to find the
        -: 1364:  // one corresponding to this result.
    #####: 1365:  auto resultGroupIt = opResultGroups.find(owner);
call    0 never executed
    #####: 1366:  if (resultGroupIt == opResultGroups.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1367:    // If not, just use the first result.
    #####: 1368:    lookupResultNo = resultNo;
branch  0 never executed
branch  1 never executed
    #####: 1369:    lookupValue = owner->getResult(0);
    #####: 1370:    return;
        -: 1371:  }
        -: 1372:
        -: 1373:  // Find the correct index using a binary search, as the groups are ordered.
    #####: 1374:  ArrayRef<int> resultGroups = resultGroupIt->second;
call    0 never executed
    #####: 1375:  const auto *it = llvm::upper_bound(resultGroups, resultNo);
    #####: 1376:  int groupResultNo = 0, groupSize = 0;
        -: 1377:
        -: 1378:  // If there are no smaller elements, the last result group is the lookup.
    #####: 1379:  if (it == resultGroups.end()) {
branch  0 never executed
branch  1 never executed
    #####: 1380:    groupResultNo = resultGroups.back();
call    0 never executed
    #####: 1381:    groupSize = static_cast<int>(owner->getNumResults()) - resultGroups.back();
        -: 1382:  } else {
        -: 1383:    // Otherwise, the previous element is the lookup.
    #####: 1384:    groupResultNo = *std::prev(it);
    #####: 1385:    groupSize = *it - groupResultNo;
        -: 1386:  }
        -: 1387:
        -: 1388:  // We only record the result number for a group of size greater than 1.
    #####: 1389:  if (groupSize != 1)
branch  0 never executed
branch  1 never executed
    #####: 1390:    lookupResultNo = resultNo - groupResultNo;
branch  0 never executed
branch  1 never executed
    #####: 1391:  lookupValue = owner->getResult(groupResultNo);
branch  0 never executed
branch  1 never executed
        -: 1392:}
        -: 1393:
function _ZN12_GLOBAL__N_112SSANameState12setValueNameEN4mlir5ValueEN4llvm9StringRefE called 506945 returned 100% blocks executed 75%
   506945: 1394:void SSANameState::setValueName(Value value, StringRef name) {
        -: 1395:  // If the name is empty, the value uses the default numbering.
   506945: 1396:  if (name.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1397:    valueIDs[value] = nextValueID++;
call    0 never executed
    #####: 1398:    return;
        -: 1399:  }
        -: 1400:
   506945: 1401:  valueIDs[value] = NameSentinel;
call    0 returned 100%
   506945: 1402:  valueNames[value] = uniqueValueName(name);
call    0 returned 100%
call    1 returned 100%
        -: 1403:}
        -: 1404:
function _ZN12_GLOBAL__N_112SSANameState15uniqueValueNameEN4llvm9StringRefE called 506945 returned 100% blocks executed 77%
   506945: 1405:StringRef SSANameState::uniqueValueName(StringRef name) {
   506945: 1406:  SmallString<16> tmpBuffer;
call    0 returned 100%
   506945: 1407:  name = sanitizeIdentifier(name, tmpBuffer);
call    0 returned 100%
        -: 1408:
        -: 1409:  // Check to see if this name is already unique.
   506945: 1410:  if (!usedNames.count(name)) {
call    0 returned 100%
   503672: 1411:    name = name.copy(usedNameAllocator);
call    0 returned 100%
        -: 1412:  } else {
        -: 1413:    // Otherwise, we had a conflict - probe until we find a unique name. This
        -: 1414:    // is guaranteed to terminate (and usually in a single iteration) because it
        -: 1415:    // generates new names by incrementing nextConflictID.
     6546: 1416:    SmallString<64> probeName(name);
call    0 returned 100%
     3273: 1417:    probeName.push_back('_');
call    0 returned 100%
     3273: 1418:    while (true) {
     3273: 1419:      probeName += llvm::utostr(nextConflictID++);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    3273*: 1420:      if (!usedNames.count(probeName)) {
call    0 returned 100%
     3273: 1421:        name = probeName.str().copy(usedNameAllocator);
call    0 returned 100%
     3273: 1422:        break;
branch  0 taken 0%
branch  1 taken 100%
        -: 1423:      }
    3273*: 1424:      probeName.resize(name.size() + 1);
call    0 returned 100%
call    1 never executed
        -: 1425:    }
        -: 1426:  }
        -: 1427:
   506945: 1428:  usedNames.insert(name, char());
call    0 returned 100%
   506945: 1429:  return name;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1430:}
        -: 1431:
        -: 1432://===----------------------------------------------------------------------===//
        -: 1433:// Resources
        -: 1434://===----------------------------------------------------------------------===//
        -: 1435:
        -: 1436:AsmParsedResourceEntry::~AsmParsedResourceEntry() = default;
        -: 1437:AsmResourceBuilder::~AsmResourceBuilder() = default;
        -: 1438:AsmResourceParser::~AsmResourceParser() = default;
        -: 1439:AsmResourcePrinter::~AsmResourcePrinter() = default;
        -: 1440:
function _ZN4mlir8toStringENS_20AsmResourceEntryKindE called 0 returned 0% blocks executed 0%
    #####: 1441:StringRef mlir::toString(AsmResourceEntryKind kind) {
    #####: 1442:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1443:  case AsmResourceEntryKind::Blob:
    #####: 1444:    return "blob";
    #####: 1445:  case AsmResourceEntryKind::Bool:
    #####: 1446:    return "bool";
    #####: 1447:  case AsmResourceEntryKind::String:
    #####: 1448:    return "string";
        -: 1449:  }
    #####: 1450:  llvm_unreachable("unknown AsmResourceEntryKind");
call    0 never executed
        -: 1451:}
        -: 1452:
function _ZN4mlir22FallbackAsmResourceMap12getParserForEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1453:AsmResourceParser &FallbackAsmResourceMap::getParserFor(StringRef key) {
    #####: 1454:  std::unique_ptr<ResourceCollection> &collection = keyToResources[key.str()];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1455:  if (!collection)
branch  0 never executed
branch  1 never executed
    #####: 1456:    collection = std::make_unique<ResourceCollection>(key);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1457:  return *collection;
        -: 1458:}
        -: 1459:
        -: 1460:std::vector<std::unique_ptr<AsmResourcePrinter>>
function _ZN4mlir22FallbackAsmResourceMap11getPrintersEv called 152427 returned 100% blocks executed 33%
   152427: 1461:FallbackAsmResourceMap::getPrinters() {
   152427: 1462:  std::vector<std::unique_ptr<AsmResourcePrinter>> printers;
  152427*: 1463:  for (auto &it : keyToResources) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    #####: 1464:    ResourceCollection *collection = it.second.get();
call    0 never executed
    #####: 1465:    auto buildValues = [=](Operation *op, AsmResourceBuilder &builder) {
    #####: 1466:      return collection->buildResources(op, builder);
call    0 never executed
    #####: 1467:    };
    #####: 1468:    printers.emplace_back(
    #####: 1469:        AsmResourcePrinter::fromCallable(collection->getName(), buildValues));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1470:  }
   152427: 1471:  return printers;
        -: 1472:}
        -: 1473:
function _ZN4mlir22FallbackAsmResourceMap18ResourceCollection13parseResourceERNS_22AsmParsedResourceEntryE called 0 returned 0% blocks executed 0%
    #####: 1474:LogicalResult FallbackAsmResourceMap::ResourceCollection::parseResource(
        -: 1475:    AsmParsedResourceEntry &entry) {
    #####: 1476:  switch (entry.getKind()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1477:  case AsmResourceEntryKind::Blob: {
    #####: 1478:    FailureOr<AsmResourceBlob> blob = entry.parseAsBlob();
call    0 never executed
    #####: 1479:    if (failed(blob))
branch  0 never executed
branch  1 never executed
    #####: 1480:      return failure();
    #####: 1481:    resources.emplace_back(entry.getKey(), std::move(*blob));
call    0 never executed
call    1 never executed
    #####: 1482:    return success();
branch  0 never executed
branch  1 never executed
        -: 1483:  }
    #####: 1484:  case AsmResourceEntryKind::Bool: {
    #####: 1485:    FailureOr<bool> value = entry.parseAsBool();
call    0 never executed
    #####: 1486:    if (failed(value))
branch  0 never executed
branch  1 never executed
    #####: 1487:      return failure();
    #####: 1488:    resources.emplace_back(entry.getKey(), *value);
call    0 never executed
call    1 never executed
    #####: 1489:    break;
        -: 1490:  }
    #####: 1491:  case AsmResourceEntryKind::String: {
    #####: 1492:    FailureOr<std::string> str = entry.parseAsString();
call    0 never executed
    #####: 1493:    if (failed(str))
branch  0 never executed
branch  1 never executed
    #####: 1494:      return failure();
    #####: 1495:    resources.emplace_back(entry.getKey(), std::move(*str));
call    0 never executed
call    1 never executed
    #####: 1496:    break;
branch  0 never executed
branch  1 never executed
        -: 1497:  }
        -: 1498:  }
    #####: 1499:  return success();
        -: 1500:}
        -: 1501:
function _ZNK4mlir22FallbackAsmResourceMap18ResourceCollection14buildResourcesEPNS_9OperationERNS_18AsmResourceBuilderE called 0 returned 0% blocks executed 0%
    #####: 1502:void FallbackAsmResourceMap::ResourceCollection::buildResources(
        -: 1503:    Operation *op, AsmResourceBuilder &builder) const {
    #####: 1504:  for (const auto &entry : resources) {
branch  0 never executed
branch  1 never executed
    #####: 1505:    if (const auto *value = std::get_if<AsmResourceBlob>(&entry.value))
branch  0 never executed
branch  1 never executed
    #####: 1506:      builder.buildBlob(entry.key, *value);
call    0 never executed
    #####: 1507:    else if (const auto *value = std::get_if<bool>(&entry.value))
branch  0 never executed
branch  1 never executed
    #####: 1508:      builder.buildBool(entry.key, *value);
call    0 never executed
    #####: 1509:    else if (const auto *value = std::get_if<std::string>(&entry.value))
branch  0 never executed
branch  1 never executed
    #####: 1510:      builder.buildString(entry.key, *value);
call    0 never executed
        -: 1511:    else
    #####: 1512:      llvm_unreachable("unknown AsmResourceEntryKind");
call    0 never executed
        -: 1513:  }
    #####: 1514:}
        -: 1515:
        -: 1516://===----------------------------------------------------------------------===//
        -: 1517:// AsmState
        -: 1518://===----------------------------------------------------------------------===//
        -: 1519:
        -: 1520:namespace mlir {
        -: 1521:namespace detail {
        -: 1522:class AsmStateImpl {
        -: 1523:public:
function _ZN4mlir6detail12AsmStateImplC2EPNS_9OperationERKNS_15OpPrintingFlagsEPN4llvm8DenseMapIS3_St4pairIjjENS7_12DenseMapInfoIS3_vEENS7_6detail12DenseMapPairIS3_SA_EEEE called 290486 returned 100% blocks executed 100%
   290486: 1524:  explicit AsmStateImpl(Operation *op, const OpPrintingFlags &printerFlags,
        -: 1525:                        AsmState::LocationMap *locationMap)
   290486: 1526:      : interfaces(op->getContext()), nameState(op, printerFlags),
   290486: 1527:        printerFlags(printerFlags), locationMap(locationMap) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
function _ZN4mlir6detail12AsmStateImplC2EPNS_11MLIRContextERKNS_15OpPrintingFlagsEPN4llvm8DenseMapIPNS_9OperationESt4pairIjjENS7_12DenseMapInfoISA_vEENS7_6detail12DenseMapPairISA_SC_EEEE called 31746 returned 100% blocks executed 100%
    31746: 1528:  explicit AsmStateImpl(MLIRContext *ctx, const OpPrintingFlags &printerFlags,
        -: 1529:                        AsmState::LocationMap *locationMap)
    31746: 1530:      : interfaces(ctx), printerFlags(printerFlags), locationMap(locationMap) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 1531:
        -: 1532:  /// Initialize the alias state to enable the printing of aliases.
   155501: 1533:  void initializeAliases(Operation *op) {
   155501: 1534:    aliasState.initialize(op, printerFlags, interfaces);
call    0 returned 100%
        -: 1535:  }
        -: 1536:
        -: 1537:  /// Get the state used for aliases.
15940503*: 1538:  AliasState &getAliasState() { return aliasState; }
        -: 1539:
        -: 1540:  /// Get the state used for SSA names.
    #####: 1541:  SSANameState &getSSANameState() { return nameState; }
call    0 never executed
        -: 1542:
        -: 1543:  /// Return the dialects within the context that implement
        -: 1544:  /// OpAsmDialectInterface.
   155501: 1545:  DialectInterfaceCollection<OpAsmDialectInterface> &getDialectInterfaces() {
   155501: 1546:    return interfaces;
        -: 1547:  }
        -: 1548:
        -: 1549:  /// Return the non-dialect resource printers.
   155501: 1550:  auto getResourcePrinters() {
   155501: 1551:    return llvm::make_pointee_range(externalResourcePrinters);
        -: 1552:  }
        -: 1553:
        -: 1554:  /// Get the printer flags.
  515197*: 1555:  const OpPrintingFlags &getPrinterFlags() const { return printerFlags; }
        -: 1556:
        -: 1557:  /// Register the location, line and column, within the buffer that the given
        -: 1558:  /// operation was printed at.
  2337900: 1559:  void registerOperationLocation(Operation *op, unsigned line, unsigned col) {
  2337900: 1560:    if (locationMap)
    12425: 1561:      (*locationMap)[op] = std::make_pair(line, col);
call    0 returned 100%
        -: 1562:  }
        -: 1563:
        -: 1564:  /// Return the referenced dialect resources within the printer.
        -: 1565:  DenseMap<Dialect *, SetVector<AsmDialectResourceHandle>> &
  178622*: 1566:  getDialectResources() {
  178622*: 1567:    return dialectResources;
        -: 1568:  }
        -: 1569:
        -: 1570:private:
        -: 1571:  /// Collection of OpAsm interfaces implemented in the context.
        -: 1572:  DialectInterfaceCollection<OpAsmDialectInterface> interfaces;
        -: 1573:
        -: 1574:  /// A collection of non-dialect resource printers.
        -: 1575:  SmallVector<std::unique_ptr<AsmResourcePrinter>> externalResourcePrinters;
        -: 1576:
        -: 1577:  /// A set of dialect resources that were referenced during printing.
        -: 1578:  DenseMap<Dialect *, SetVector<AsmDialectResourceHandle>> dialectResources;
        -: 1579:
        -: 1580:  /// The state used for attribute and type aliases.
        -: 1581:  AliasState aliasState;
        -: 1582:
        -: 1583:  /// The state used for SSA value names.
        -: 1584:  SSANameState nameState;
        -: 1585:
        -: 1586:  /// Flags that control op output.
        -: 1587:  OpPrintingFlags printerFlags;
        -: 1588:
        -: 1589:  /// An optional location map to be populated.
        -: 1590:  AsmState::LocationMap *locationMap;
        -: 1591:
        -: 1592:  // Allow direct access to the impl fields.
        -: 1593:  friend AsmState;
        -: 1594:};
        -: 1595:} // namespace detail
        -: 1596:} // namespace mlir
        -: 1597:
        -: 1598:/// Verifies the operation and switches to generic op printing if verification
        -: 1599:/// fails. We need to do this because custom print functions may fail for
        -: 1600:/// invalid ops.
function _ZL22verifyOpAndAdjustFlagsPN4mlir9OperationENS_15OpPrintingFlagsE called 290474 returned 100% blocks executed 46%
   290474: 1601:static OpPrintingFlags verifyOpAndAdjustFlags(Operation *op,
        -: 1602:                                              OpPrintingFlags printerFlags) {
   290474: 1603:  if (printerFlags.shouldPrintGenericOpForm() ||
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
   206630: 1604:      printerFlags.shouldAssumeVerified())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    83844: 1605:    return printerFlags;
        -: 1606:
  206630*: 1607:  LLVM_DEBUG(llvm::dbgs() << DEBUG_TYPE << ": Verifying operation: "
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1608:                          << op->getName() << "\n");
        -: 1609:
        -: 1610:  // Ignore errors emitted by the verifier. We check the thread id to avoid
        -: 1611:  // consuming other threads' errors.
   206630: 1612:  auto parentThreadId = llvm::get_threadid();
call    0 returned 100%
function _ZZL22verifyOpAndAdjustFlagsPN4mlir9OperationENS_15OpPrintingFlagsEENKUlRNS_10DiagnosticEE_clES4_.isra.0 called 2297 returned 100% blocks executed 46%
     2297: 1613:  ScopedDiagnosticHandler diagHandler(op->getContext(), [&](Diagnostic &diag) {
     2297: 1614:    if (parentThreadId == llvm::get_threadid()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    2297*: 1615:      LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -: 1616:        diag.print(llvm::dbgs());
        -: 1617:        llvm::dbgs() << "\n";
        -: 1618:      });
     2297: 1619:      return success();
        -: 1620:    }
    #####: 1621:    return failure();
   206630: 1622:  });
call    0 returned 100%
call    1 returned 100%
   206630: 1623:  if (failed(verify(op))) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
    2275*: 1624:    LLVM_DEBUG(llvm::dbgs()
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1625:               << DEBUG_TYPE << ": '" << op->getName()
        -: 1626:               << "' failed to verify and will be printed in generic form\n");
   206630: 1627:    printerFlags.printGenericOpForm();
        -: 1628:  }
        -: 1629:
   206630: 1630:  return printerFlags;
call    0 returned 100%
        -: 1631:}
        -: 1632:
function _ZN4mlir8AsmStateC2EPNS_9OperationERKNS_15OpPrintingFlagsEPN4llvm8DenseMapIS2_St4pairIjjENS6_12DenseMapInfoIS2_vEENS6_6detail12DenseMapPairIS2_S9_EEEEPNS_22FallbackAsmResourceMapE called 290474 returned 100% blocks executed 100%
   290474: 1633:AsmState::AsmState(Operation *op, const OpPrintingFlags &printerFlags,
   290474: 1634:                   LocationMap *locationMap, FallbackAsmResourceMap *map)
        -: 1635:    : impl(std::make_unique<AsmStateImpl>(
   290474: 1636:          op, verifyOpAndAdjustFlags(op, printerFlags), locationMap)) {
call    0 returned 100%
call    1 returned 100%
   290485: 1637:  if (map)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
   151623: 1638:    attachFallbackResourcePrinter(*map);
call    0 returned 100%
   290485: 1639:}
function _ZN4mlir8AsmStateC2EPNS_11MLIRContextERKNS_15OpPrintingFlagsEPN4llvm8DenseMapIPNS_9OperationESt4pairIjjENS6_12DenseMapInfoIS9_vEENS6_6detail12DenseMapPairIS9_SB_EEEEPNS_22FallbackAsmResourceMapE called 54 returned 100% blocks executed 80%
   31746*: 1640:AsmState::AsmState(MLIRContext *ctx, const OpPrintingFlags &printerFlags,
   31746*: 1641:                   LocationMap *locationMap, FallbackAsmResourceMap *map)
      54*: 1642:    : impl(std::make_unique<AsmStateImpl>(ctx, printerFlags, locationMap)) {
call    0 returned 100%
      54*: 1643:  if (map)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1644:    attachFallbackResourcePrinter(*map);
call    0 never executed
       54: 1645:}
        -: 1646:AsmState::~AsmState() = default;
        -: 1647:
function _ZNK4mlir8AsmState15getPrinterFlagsEv called 0 returned 0% blocks executed 0%
  159083*: 1648:const OpPrintingFlags &AsmState::getPrinterFlags() const {
  159083*: 1649:  return impl->getPrinterFlags();
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -: 1650:}
        -: 1651:
function _ZN4mlir8AsmState21attachResourcePrinterESt10unique_ptrINS_18AsmResourcePrinterESt14default_deleteIS2_EE called 0 returned 0% blocks executed 0%
    #####: 1652:void AsmState::attachResourcePrinter(
        -: 1653:    std::unique_ptr<AsmResourcePrinter> printer) {
    #####: 1654:  impl->externalResourcePrinters.emplace_back(std::move(printer));
call    0 never executed
call    1 never executed
    #####: 1655:}
        -: 1656:
        -: 1657:DenseMap<Dialect *, SetVector<AsmDialectResourceHandle>> &
function _ZNK4mlir8AsmState19getDialectResourcesEv called 54 returned 100% blocks executed 100%
       54: 1658:AsmState::getDialectResources() const {
       54: 1659:  return impl->getDialectResources();
        -: 1660:}
        -: 1661:
        -: 1662://===----------------------------------------------------------------------===//
        -: 1663:// AsmPrinter::Impl
        -: 1664://===----------------------------------------------------------------------===//
        -: 1665:
function _ZN4mlir10AsmPrinter4ImplC2ERN4llvm11raw_ostreamERNS_6detail12AsmStateImplE called 0 returned 0% blocks executed 0%
  356114*: 1666:AsmPrinter::Impl::Impl(raw_ostream &os, AsmStateImpl &state)
   10426*: 1667:    : os(os), state(state), printerFlags(state.getPrinterFlags()) {}
call    0 never executed
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 returned 100%
        -: 1668:
function _ZN4mlir10AsmPrinter4Impl21printTrailingLocationENS_8LocationEb called 2671159 returned 100% blocks executed 100%
  2671159: 1669:void AsmPrinter::Impl::printTrailingLocation(Location loc, bool allowAlias) {
        -: 1670:  // Check to see if we are printing debug information.
  2671159: 1671:  if (!printerFlags.shouldPrintDebugInfo())
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 1672:    return;
        -: 1673:
    18225: 1674:  os << " ";
call    0 returned 100%
    18225: 1675:  printLocation(loc, /*allowAlias=*/allowAlias);
call    0 returned 100%
        -: 1676:}
        -: 1677:
function _ZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEb called 23112 returned 100% blocks executed 100%
    23112: 1678:void AsmPrinter::Impl::printLocationInternal(LocationAttr loc, bool pretty) {
    23112: 1679:  TypeSwitch<LocationAttr>(loc)
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_9OpaqueLocEE_clES3_.isra.0 called 2837 returned 100% blocks executed 100%
     2837: 1680:      .Case<OpaqueLoc>([&](OpaqueLoc loc) {
     2837: 1681:        printLocationInternal(loc.getFallbackLocation(), pretty);
call    0 returned 100%
call    1 returned 100%
    23112: 1682:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_10UnknownLocEE0_clES3_.isra.0 called 1538 returned 100% blocks executed 100%
     1538: 1683:      .Case<UnknownLoc>([&](UnknownLoc loc) {
     1538: 1684:        if (pretty)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
      119: 1685:          os << "[unknown]";
call    0 returned 100%
        -: 1686:        else
     1419: 1687:          os << "unknown";
call    0 returned 100%
    23112: 1688:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_14FileLineColLocEE1_clES3_.isra.0 called 18737 returned 100% blocks executed 100%
    18737: 1689:      .Case<FileLineColLoc>([&](FileLineColLoc loc) {
    18737: 1690:        if (pretty)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
      530: 1691:          os << loc.getFilename().getValue();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1692:        else
    18207: 1693:          printEscapedString(loc.getFilename());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    56211: 1694:        os << ':' << loc.getLine() << ':' << loc.getColumn();
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 28% (fallthrough)
branch  5 taken 72%
call    6 returned 100%
call    7 returned 100%
    23112: 1695:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_7NameLocEE2_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1696:      .Case<NameLoc>([&](NameLoc loc) {
    #####: 1697:        printEscapedString(loc.getName());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1698:
        -: 1699:        // Print the child if it isn't unknown.
    #####: 1700:        auto childLoc = loc.getChildLoc();
call    0 never executed
    #####: 1701:        if (!childLoc.isa<UnknownLoc>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1702:          os << '(';
branch  0 never executed
branch  1 never executed
    #####: 1703:          printLocationInternal(childLoc, pretty);
call    0 never executed
    #####: 1704:          os << ')';
branch  0 never executed
branch  1 never executed
        -: 1705:        }
   23112*: 1706:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_11CallSiteLocEE3_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1707:      .Case<CallSiteLoc>([&](CallSiteLoc loc) {
    #####: 1708:        Location caller = loc.getCaller();
call    0 never executed
    #####: 1709:        Location callee = loc.getCallee();
call    0 never executed
    #####: 1710:        if (!pretty)
branch  0 never executed
branch  1 never executed
    #####: 1711:          os << "callsite(";
call    0 never executed
    #####: 1712:        printLocationInternal(callee, pretty);
call    0 never executed
    #####: 1713:        if (pretty) {
branch  0 never executed
branch  1 never executed
    #####: 1714:          if (callee.isa<NameLoc>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1715:            if (caller.isa<FileLineColLoc>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1716:              os << " at ";
call    0 never executed
        -: 1717:            } else {
    #####: 1718:              os << newLine << " at ";
call    0 never executed
call    1 never executed
        -: 1719:            }
        -: 1720:          } else {
    #####: 1721:            os << newLine << " at ";
call    0 never executed
call    1 never executed
        -: 1722:          }
        -: 1723:        } else {
    #####: 1724:          os << " at ";
call    0 never executed
        -: 1725:        }
    #####: 1726:        printLocationInternal(caller, pretty);
call    0 never executed
    #####: 1727:        if (!pretty)
branch  0 never executed
branch  1 never executed
    #####: 1728:          os << ")";
call    0 never executed
   23112*: 1729:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printLocationInternalENS_12LocationAttrEbENKUlNS_8FusedLocEE4_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1730:      .Case<FusedLoc>([&](FusedLoc loc) {
    #####: 1731:        if (!pretty)
branch  0 never executed
branch  1 never executed
    #####: 1732:          os << "fused";
call    0 never executed
    #####: 1733:        if (Attribute metadata = loc.getMetadata()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1734:          os << '<';
branch  0 never executed
branch  1 never executed
    #####: 1735:          printAttribute(metadata);
call    0 never executed
    #####: 1736:          os << '>';
branch  0 never executed
branch  1 never executed
        -: 1737:        }
    #####: 1738:        os << '[';
branch  0 never executed
branch  1 never executed
    #####: 1739:        interleave(
call    0 never executed
    #####: 1740:            loc.getLocations(),
call    0 never executed
    #####: 1741:            [&](Location loc) { printLocationInternal(loc, pretty); },
call    0 never executed
call    1 never executed
    #####: 1742:            [&]() { os << ", "; });
call    0 never executed
    #####: 1743:        os << ']';
branch  0 never executed
branch  1 never executed
   23112*: 1744:      });
call    0 returned 100%
    23112: 1745:}
        -: 1746:
        -: 1747:/// Print a floating point value in a way that the parser will be able to
        -: 1748:/// round-trip losslessly.
function _ZL15printFloatValueRKN4llvm7APFloatERNS_11raw_ostreamE called 1009596 returned 100% blocks executed 57%
  1009596: 1749:static void printFloatValue(const APFloat &apValue, raw_ostream &os) {
        -: 1750:  // We would like to output the FP constant value in exponential notation,
        -: 1751:  // but we cannot do this if doing so will lose precision.  Check here to
        -: 1752:  // make sure that we only output it in exponential format if we can parse
        -: 1753:  // the value back and get the same value.
  1009596: 1754:  bool isInf = apValue.isInfinity();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1009596: 1755:  bool isNaN = apValue.isNaN();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1009596: 1756:  if (!isInf && !isNaN) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 1009596*: 1757:    SmallString<128> strValue;
call    0 returned 100%
  1009596: 1758:    apValue.toString(strValue, /*FormatPrecision=*/6, /*FormatMaxPadding=*/0,
call    0 returned 100%
        -: 1759:                     /*TruncateZero=*/false);
        -: 1760:
        -: 1761:    // Check to make sure that the stringized number is not some string like
        -: 1762:    // "Inf" or NaN, that atof will accept, but the lexer will not.  Check
        -: 1763:    // that the string matches the "[-+]?[0-9]" regex.
 1010741*: 1764:    assert(((strValue[0] >= '0' && strValue[0] <= '9') ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 never executed
branch  9 never executed
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 0% (fallthrough)
branch 13 taken 100%
call   14 never executed
        -: 1765:            ((strValue[0] == '-' || strValue[0] == '+') &&
        -: 1766:             (strValue[1] >= '0' && strValue[1] <= '9'))) &&
        -: 1767:           "[-+]?[0-9] regex does not match!");
        -: 1768:
        -: 1769:    // Parse back the stringized version and check that the value is equal
        -: 1770:    // (i.e., there is no precision loss).
  1009596: 1771:    if (APFloat(apValue.getSemantics(), strValue).bitwiseIsEqual(apValue)) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
   408162: 1772:      os << strValue;
call    0 returned 100%
  1417758: 1773:      return;
call    0 returned 100%
        -: 1774:    }
        -: 1775:
        -: 1776:    // If it is not, use the default format of APFloat instead of the
        -: 1777:    // exponential notation.
   601434: 1778:    strValue.clear();
call    0 returned 100%
   601434: 1779:    apValue.toString(strValue);
call    0 returned 100%
        -: 1780:
        -: 1781:    // Make sure that we can parse the default form as a float.
   601434: 1782:    if (strValue.str().contains('.')) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   601434: 1783:      os << strValue;
call    0 returned 100%
   601434: 1784:      return;
call    0 returned 100%
        -: 1785:    }
        -: 1786:  }
        -: 1787:
        -: 1788:  // Print special values in hexadecimal format. The sign bit should be included
        -: 1789:  // in the literal.
    #####: 1790:  SmallVector<char, 16> str;
call    0 never executed
    #####: 1791:  APInt apInt = apValue.bitcastToAPInt();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1792:  apInt.toString(str, /*Radix=*/16, /*Signed=*/false,
call    0 never executed
        -: 1793:                 /*formatAsCLiteral=*/true);
    #####: 1794:  os << str;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1795:}
        -: 1796:
function _ZN4mlir10AsmPrinter4Impl13printLocationENS_12LocationAttrEb called 31891 returned 100% blocks executed 100%
    31891: 1797:void AsmPrinter::Impl::printLocation(LocationAttr loc, bool allowAlias) {
    31891: 1798:  if (printerFlags.shouldPrintDebugInfoPrettyForm())
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      649: 1799:    return printLocationInternal(loc, /*pretty=*/true);
call    0 returned 100%
        -: 1800:
    31242: 1801:  os << "loc(";
call    0 returned 100%
    46985: 1802:  if (!allowAlias || failed(printAlias(loc)))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
    19626: 1803:    printLocationInternal(loc);
call    0 returned 100%
    31242: 1804:  os << ')';
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -: 1805:}
        -: 1806:
function _ZN4mlir10AsmPrinter4Impl19printResourceHandleERKNS_24AsmDialectResourceHandleE called 0 returned 0% blocks executed 0%
    #####: 1807:void AsmPrinter::Impl::printResourceHandle(
        -: 1808:    const AsmDialectResourceHandle &resource) {
    #####: 1809:  auto *interface = cast<OpAsmDialectInterface>(resource.getDialect());
call    0 never executed
    #####: 1810:  os << interface->getResourceKey(resource);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1811:  state.getDialectResources()[resource.getDialect()].insert(resource);
call    0 never executed
call    1 never executed
    #####: 1812:}
        -: 1813:
        -: 1814:/// Returns true if the given dialect symbol data is simple enough to print in
        -: 1815:/// the pretty form. This is essentially when the symbol takes the form:
        -: 1816:///   identifier (`<` body `>`)?
function _ZL40isDialectSymbolSimpleEnoughForPrettyFormN4llvm9StringRefE called 33881 returned 100% blocks executed 89%
    33881: 1817:static bool isDialectSymbolSimpleEnoughForPrettyForm(StringRef symName) {
        -: 1818:  // The name must start with an identifier.
    33881: 1819:  if (symName.empty() || !isalpha(symName.front()))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1820:    return false;
        -: 1821:
        -: 1822:  // Ignore all the characters that are valid in an identifier in the symbol
        -: 1823:  // name.
    33881: 1824:  symName = symName.drop_while(
   214657: 1825:      [](char c) { return llvm::isAlnum(c) || c == '.' || c == '_'; });
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
    33885: 1826:  if (symName.empty())
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -: 1827:    return true;
        -: 1828:
        -: 1829:  // If we got to an unexpected character, then it must be a <>. Check that the
        -: 1830:  // rest of the symbol is wrapped within <>.
    32954: 1831:  return symName.front() == '<' && symName.back() == '>';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1832:}
        -: 1833:
        -: 1834:/// Print the given dialect symbol to the stream.
function _ZL18printDialectSymbolRN4llvm11raw_ostreamENS_9StringRefES2_S2_ called 33882 returned 100% blocks executed 59%
    33882: 1835:static void printDialectSymbol(raw_ostream &os, StringRef symPrefix,
        -: 1836:                               StringRef dialectName, StringRef symString) {
    33882: 1837:  os << symPrefix << dialectName;
call    0 returned 100%
call    1 returned 100%
        -: 1838:
        -: 1839:  // If this symbol name is simple enough, print it directly in pretty form,
        -: 1840:  // otherwise, we print it as an escaped string.
    33881: 1841:  if (isDialectSymbolSimpleEnoughForPrettyForm(symString)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    33885: 1842:    os << '.' << symString;
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
    33882: 1843:    return;
call    0 returned 100%
        -: 1844:  }
        -: 1845:
    #####: 1846:  os << '<' << symString << '>';
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1847:}
        -: 1848:
        -: 1849:/// Returns true if the given string can be represented as a bare identifier.
function _ZL16isBareIdentifierN4llvm9StringRefE called 2423936 returned 100% blocks executed 100%
  2423936: 1850:static bool isBareIdentifier(StringRef name) {
        -: 1851:  // By making this unsigned, the value passed in to isalnum will always be
        -: 1852:  // in the range 0-255. This is important when building with MSVC because
        -: 1853:  // its implementation will assert. This situation can arise when dealing
        -: 1854:  // with UTF-8 multibyte characters.
  2423936: 1855:  if (name.empty() || (!isalpha(name[0]) && name[0] != '_'))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -: 1856:    return false;
function _ZZL16isBareIdentifierN4llvm9StringRefEENKUlhE_clEh called 19216618 returned 100% blocks executed 80%
  2423936: 1857:  return llvm::all_of(name.drop_front(), [](unsigned char c) {
call    0 returned 100%
 19216618: 1858:    return isalnum(c) || c == '_' || c == '$' || c == '.';
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 62% (fallthrough)
branch  3 taken 38%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 1859:  });
        -: 1860:}
        -: 1861:
        -: 1862:/// Print the given string as a keyword, or a quoted and escaped string if it
        -: 1863:/// has any special or non-printable characters in it.
function _ZL20printKeywordOrStringN4llvm9StringRefERNS_11raw_ostreamE called 2423938 returned 100% blocks executed 50%
  2423938: 1864:static void printKeywordOrString(StringRef keyword, raw_ostream &os) {
        -: 1865:  // If it can be represented as a bare identifier, write it directly.
  2423938: 1866:  if (isBareIdentifier(keyword)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2423950: 1867:    os << keyword;
  2423950: 1868:    return;
call    0 returned 100%
        -: 1869:  }
        -: 1870:
        -: 1871:  // Otherwise, output the keyword wrapped in quotes with proper escaping.
    #####: 1872:  os << "\"";
call    0 never executed
    #####: 1873:  printEscapedString(keyword, os);
call    0 never executed
    #####: 1874:  os << '"';
branch  0 never executed
branch  1 never executed
        -: 1875:}
        -: 1876:
        -: 1877:/// Print the given string as a symbol reference. A symbol reference is
        -: 1878:/// represented as a string prefixed with '@'. The reference is surrounded with
        -: 1879:/// ""'s and escaped if it has any special or non-printable characters in it.
function _ZL20printSymbolReferenceN4llvm9StringRefERNS_11raw_ostreamE called 183759 returned 100% blocks executed 86%
   183759: 1880:static void printSymbolReference(StringRef symbolRef, raw_ostream &os) {
  183759*: 1881:  assert(!symbolRef.empty() && "expected valid symbol reference");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   183759: 1882:  os << '@';
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
   183759: 1883:  printKeywordOrString(symbolRef, os);
call    0 returned 100%
   183759: 1884:}
        -: 1885:
        -: 1886:// Print out a valid ElementsAttr that is succinct and can represent any
        -: 1887:// potential shape/type, for use when eliding a large ElementsAttr.
        -: 1888://
        -: 1889:// We choose to use a dense resource ElementsAttr literal with conspicuous
        -: 1890:// content to hopefully alert readers to the fact that this has been elided.
    4667*: 1891:static void printElidedElementsAttr(raw_ostream &os) {
    4667*: 1892:  os << R"(dense_resource<__elided__>)";
    4667*: 1893:}
        -: 1894:
function _ZN4mlir10AsmPrinter4Impl10printAliasENS_9AttributeE called 0 returned 0% blocks executed 0%
 3821098*: 1895:LogicalResult AsmPrinter::Impl::printAlias(Attribute attr) {
   15743*: 1896:  return state.getAliasState().getAlias(attr, os);
call    0 never executed
call    1 returned 100%
        -: 1897:}
        -: 1898:
function _ZN4mlir10AsmPrinter4Impl10printAliasENS_4TypeE called 0 returned 0% blocks executed 0%
11808403*: 1899:LogicalResult AsmPrinter::Impl::printAlias(Type type) {
    #####: 1900:  return state.getAliasState().getAlias(type, os);
call    0 never executed
        -: 1901:}
        -: 1902:
function _ZN4mlir10AsmPrinter4Impl14printAttributeENS_9AttributeENS1_15AttrTypeElisionE called 3804753 returned 100% blocks executed 71%
  3804753: 1903:void AsmPrinter::Impl::printAttribute(Attribute attr,
        -: 1904:                                      AttrTypeElision typeElision) {
  3804753: 1905:  if (!attr) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1906:    os << "<<NULL ATTRIBUTE>>";
    #####: 1907:    return;
call    0 never executed
        -: 1908:  }
        -: 1909:
        -: 1910:  // Try to print an alias for this attribute.
  3804753: 1911:  if (succeeded(printAlias(attr)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1912:    return;
  3804756: 1913:  return printAttributeImpl(attr, typeElision);
call    0 returned 100%
        -: 1914:}
        -: 1915:
function _ZN4mlir10AsmPrinter4Impl18printAttributeImplENS_9AttributeENS1_15AttrTypeElisionE called 3817766 returned 100% blocks executed 68%
  3817766: 1916:void AsmPrinter::Impl::printAttributeImpl(Attribute attr,
        -: 1917:                                          AttrTypeElision typeElision) {
  3817766: 1918:  if (!isa<BuiltinDialect>(attr.getDialect())) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
      100: 1919:    printDialectAttribute(attr);
call    0 returned 99%
  3817666: 1920:  } else if (auto opaqueAttr = attr.dyn_cast<OpaqueAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1921:    printDialectSymbol(os, "#", opaqueAttr.getDialectNamespace(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1922:                       opaqueAttr.getAttrData());
  3817666: 1923:  } else if (attr.isa<UnitAttr>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       12: 1924:    os << "unit";
  1319557: 1925:    return;
call    0 returned 100%
  3817653: 1926:  } else if (auto dictAttr = attr.dyn_cast<DictionaryAttr>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
    46813: 1927:    os << '{';
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
    46813: 1928:    interleaveComma(dictAttr.getValue(),
call    0 returned 100%
call    1 returned 100%
    52075: 1929:                    [&](NamedAttribute attr) { printNamedAttribute(attr); });
call    0 returned 100%
call    1 returned 100%
  2544923: 1930:    os << '}';
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 1931:
  3770841: 1932:  } else if (auto intAttr = attr.dyn_cast<IntegerAttr>()) {
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
  1727484: 1933:    Type intType = intAttr.getType();
call    0 returned 100%
  1727484: 1934:    if (intType.isSignlessInteger(1)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1935:      os << (intAttr.getValue().getBoolValue() ? "true" : "false");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
        -: 1936:
        -: 1937:      // Boolean integer attributes always elides the type.
 1319445*: 1938:      return;
        -: 1939:    }
        -: 1940:
        -: 1941:    // Only print attributes as unsigned if they are explicitly unsigned or are
        -: 1942:    // signless 1-bit values.  Indexes, signed values, and multi-bit signless
        -: 1943:    // values print as signed.
  1727484: 1944:    bool isUnsigned =
  1727484: 1945:        intType.isUnsignedInteger() || intType.isSignlessInteger(1);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
  1727484: 1946:    intAttr.getValue().print(os, !isUnsigned);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1947:
        -: 1948:    // IntegerAttr elides the type if I64.
  1727484: 1949:    if (typeElision == AttrTypeElision::May && intType.isSignlessInteger(64))
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 1950:      return;
        -: 1951:
  2043357: 1952:  } else if (auto floatAttr = attr.dyn_cast<FloatAttr>()) {
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
   176424: 1953:    printFloatValue(floatAttr.getValue(), os);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 1954:
        -: 1955:    // FloatAttr elides the type if F64.
  176424*: 1956:    if (typeElision == AttrTypeElision::May && floatAttr.getType().isF64())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      88*: 1957:      return;
        -: 1958:
  1866937: 1959:  } else if (auto strAttr = attr.dyn_cast<StringAttr>()) {
call    0 returned 100%
branch  1 taken 42% (fallthrough)
branch  2 taken 58%
   788549: 1960:    printEscapedString(strAttr.getValue());
call    0 returned 100%
call    1 returned 100%
        -: 1961:
  1078399: 1962:  } else if (auto arrayAttr = attr.dyn_cast<ArrayAttr>()) {
call    0 returned 100%
branch  1 taken 48% (fallthrough)
branch  2 taken 52%
   516413: 1963:    os << '[';
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
   516413: 1964:    interleaveComma(arrayAttr.getValue(), [&](Attribute attr) {
call    0 returned 100%
call    1 returned 100%
  1540936: 1965:      printAttribute(attr, AttrTypeElision::May);
call    0 returned 100%
call    1 returned 100%
        -: 1966:    });
  1594726: 1967:    os << ']';
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
        -: 1968:
   561986: 1969:  } else if (auto affineMapAttr = attr.dyn_cast<AffineMapAttr>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       24: 1970:    os << "affine_map<";
call    0 returned 100%
       24: 1971:    affineMapAttr.getValue().print(os);
call    0 returned 100%
call    1 returned 100%
       24: 1972:    os << '>';
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 1973:
        -: 1974:    // AffineMap always elides the type.
       88: 1975:    return;
        -: 1976:
   561962: 1977:  } else if (auto integerSetAttr = attr.dyn_cast<IntegerSetAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1978:    os << "affine_set<";
call    0 never executed
    #####: 1979:    integerSetAttr.getValue().print(os);
call    0 never executed
call    1 never executed
    #####: 1980:    os << '>';
branch  0 never executed
branch  1 never executed
        -: 1981:
        -: 1982:    // IntegerSet always elides the type.
      64*: 1983:    return;
        -: 1984:
   561962: 1985:  } else if (auto typeAttr = attr.dyn_cast<TypeAttr>()) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
    11907: 1986:    printType(typeAttr.getValue());
call    0 returned 100%
call    1 returned 100%
        -: 1987:
   550055: 1988:  } else if (auto refAttr = attr.dyn_cast<SymbolRefAttr>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       36: 1989:    printSymbolReference(refAttr.getRootReference().getValue(), os);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      36*: 1990:    for (FlatSymbolRefAttr nestedRef : refAttr.getNestedReferences()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1991:      os << "::";
call    0 never executed
    #####: 1992:      printSymbolReference(nestedRef.getValue(), os);
call    0 never executed
call    1 never executed
        -: 1993:    }
        -: 1994:
   550019: 1995:  } else if (auto intOrFpEltAttr = attr.dyn_cast<DenseIntOrFPElementsAttr>()) {
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
   536289: 1996:    if (printerFlags.shouldElideElementsAttr(intOrFpEltAttr)) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
     4667: 1997:      printElidedElementsAttr(os);
call    0 returned 100%
        -: 1998:    } else {
   531622: 1999:      os << "dense<";
call    0 returned 100%
   531622: 2000:      printDenseIntOrFPElementsAttr(intOrFpEltAttr, /*allowHex=*/true);
call    0 returned 100%
  1081577: 2001:      os << '>';
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
        -: 2002:    }
        -: 2003:
    13730: 2004:  } else if (auto strEltAttr = attr.dyn_cast<DenseStringElementsAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2005:    if (printerFlags.shouldElideElementsAttr(strEltAttr)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2006:      printElidedElementsAttr(os);
call    0 never executed
        -: 2007:    } else {
    #####: 2008:      os << "dense<";
call    0 never executed
    #####: 2009:      printDenseStringElementsAttr(strEltAttr);
call    0 never executed
   13666*: 2010:      os << '>';
branch  0 never executed
branch  1 never executed
        -: 2011:    }
        -: 2012:
    13730: 2013:  } else if (auto sparseEltAttr = attr.dyn_cast<SparseElementsAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2014:    if (printerFlags.shouldElideElementsAttr(sparseEltAttr.getIndices()) ||
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2015:        printerFlags.shouldElideElementsAttr(sparseEltAttr.getValues())) {
call    0 never executed
call    1 never executed
call    2 never executed
   13666*: 2016:      printElidedElementsAttr(os);
call    0 never executed
        -: 2017:    } else {
    #####: 2018:      os << "sparse<";
call    0 never executed
    #####: 2019:      DenseIntElementsAttr indices = sparseEltAttr.getIndices();
call    0 never executed
    #####: 2020:      if (indices.getNumElements() != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2021:        printDenseIntOrFPElementsAttr(indices, /*allowHex=*/false);
call    0 never executed
    #####: 2022:        os << ", ";
call    0 never executed
    #####: 2023:        printDenseElementsAttr(sparseEltAttr.getValues(), /*allowHex=*/true);
call    0 never executed
call    1 never executed
        -: 2024:      }
    #####: 2025:      os << '>';
branch  0 never executed
branch  1 never executed
        -: 2026:    }
    13730: 2027:  } else if (auto stridedLayoutAttr = attr.dyn_cast<StridedLayoutAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2028:    stridedLayoutAttr.print(os);
call    0 never executed
    13730: 2029:  } else if (auto denseArrayAttr = attr.dyn_cast<DenseArrayAttr>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       64: 2030:    os << "array<";
call    0 returned 100%
       64: 2031:    if (typeElision != AttrTypeElision::Must)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       64: 2032:      printType(denseArrayAttr.getType().getElementType());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      128: 2033:    if (!denseArrayAttr.empty()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       64: 2034:      if (typeElision != AttrTypeElision::Must)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       64: 2035:        os << ": ";
call    0 returned 100%
       64: 2036:      printDenseArrayAttr(denseArrayAttr);
call    0 returned 100%
        -: 2037:    }
       64: 2038:    os << ">";
call    0 returned 100%
       64: 2039:    return;
    13666: 2040:  } else if (auto resourceAttr = attr.dyn_cast<DenseResourceElementsAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2041:    os << "dense_resource<";
call    0 never executed
    #####: 2042:    printResourceHandle(resourceAttr.getRawHandle());
call    0 never executed
call    1 never executed
    #####: 2043:    os << ">";
call    0 never executed
    13666: 2044:  } else if (auto locAttr = attr.dyn_cast<LocationAttr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    13666: 2045:    printLocation(locAttr);
call    0 returned 100%
        -: 2046:  } else {
    #####: 2047:    llvm::report_fatal_error("Unknown builtin attribute");
call    0 never executed
        -: 2048:  }
        -: 2049:  // Don't print the type if we must elide it, or if it is a None type.
  2498209: 2050:  if (typeElision != AttrTypeElision::Must) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  2498101: 2051:    if (auto typedAttr = attr.dyn_cast<TypedAttr>()) {
call    0 returned 100%
branch  1 taken 76% (fallthrough)
branch  2 taken 24%
  1909221: 2052:      Type attrType = typedAttr.getType();
call    0 returned 100%
  1909230: 2053:      if (!attrType.isa<NoneType>()) {
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
  1120716: 2054:        os << " : ";
call    0 returned 100%
  1120716: 2055:        printType(attrType);
call    0 returned 100%
        -: 2056:      }
        -: 2057:    }
        -: 2058:  }
        -: 2059:}
        -: 2060:
        -: 2061:/// Print the integer element of a DenseElementsAttr.
function _ZL20printDenseIntElementRKN4llvm5APIntERNS_11raw_ostreamEN4mlir4TypeE called 233935 returned 100% blocks executed 45%
   233935: 2062:static void printDenseIntElement(const APInt &value, raw_ostream &os,
        -: 2063:                                 Type type) {
   233935: 2064:  if (type.isInteger(1))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2065:    os << (value.getBoolValue() ? "true" : "false");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2066:  else
   233935: 2067:    value.print(os, !type.isUnsignedInteger());
call    0 returned 100%
call    1 returned 100%
   233935: 2068:}
        -: 2069:
        -: 2070:static void
function _ZL26printDenseElementsAttrImplbN4mlir10ShapedTypeERN4llvm11raw_ostreamENS1_12function_refIFvjEEE called 490376 returned 100% blocks executed 97%
   490376: 2071:printDenseElementsAttrImpl(bool isSplat, ShapedType type, raw_ostream &os,
        -: 2072:                           function_ref<void(unsigned)> printEltFn) {
        -: 2073:  // Special case for 0-d and splat tensors.
   490376: 2074:  if (isSplat)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
   281388: 2075:    return printEltFn(0);
call    0 returned 100%
        -: 2076:
        -: 2077:  // Special case for degenerate tensors.
   208988: 2078:  auto numElements = type.getNumElements();
call    0 returned 100%
   208988: 2079:  if (numElements == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2080:    return;
        -: 2081:
        -: 2082:  // We use a mixed-radix counter to iterate through the shape. When we bump a
        -: 2083:  // non-least-significant digit, we emit a close bracket. When we next emit an
        -: 2084:  // element we re-open all closed brackets.
        -: 2085:
        -: 2086:  // The mixed-radix counter, with radices in 'shape'.
   208988: 2087:  int64_t rank = type.getRank();
call    0 returned 100%
   417976: 2088:  SmallVector<unsigned, 4> counter(rank, 0);
call    0 returned 100%
        -: 2089:  // The number of brackets that have been opened and not closed.
   208988: 2090:  unsigned openBrackets = 0;
        -: 2091:
   208988: 2092:  auto shape = type.getShape();
call    0 returned 100%
function _ZZL26printDenseElementsAttrImplbN4mlir10ShapedTypeERN4llvm11raw_ostreamENS1_12function_refIFvjEEEENKUlvE_clEv called 785615 returned 100% blocks executed 75%
   994603: 2093:  auto bumpCounter = [&] {
        -: 2094:    // Bump the least significant digit.
   785615: 2095:    ++counter[rank - 1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2096:    // Iterate backwards bubbling back the increment.
  2467535: 2097:    for (unsigned i = rank - 1; i > 0; --i)
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
  1681920: 2098:      if (counter[i] >= shape[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 64% (fallthrough)
branch  5 taken 36%
        -: 2099:        // Index 'i' is rolled over. Bump (i-1) and close a bracket.
  1071362: 2100:        counter[i] = 0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1071362: 2101:        ++counter[i - 1];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  1071362: 2102:        --openBrackets;
  2753282: 2103:        os << ']';
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -: 2104:      }
   994603: 2105:  };
        -: 2106:
   994603: 2107:  for (unsigned idx = 0, e = numElements; idx != e; ++idx) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
   785615: 2108:    if (idx != 0)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
   576627: 2109:      os << ", ";
call    0 returned 100%
  2065965: 2110:    while (openBrackets++ < rank)
  2065965: 2111:      os << '[';
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
branch  2 taken 12% (fallthrough)
branch  3 taken 88%
   785615: 2112:    openBrackets = rank;
   785615: 2113:    printEltFn(idx);
call    0 returned 100%
   785615: 2114:    bumpCounter();
call    0 returned 100%
        -: 2115:  }
   417976: 2116:  while (openBrackets-- > 0)
   417976: 2117:    os << ']';
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 13% (fallthrough)
branch  3 taken 87%
        -: 2118:}
        -: 2119:
function _ZN4mlir10AsmPrinter4Impl22printDenseElementsAttrENS_17DenseElementsAttrEb called 0 returned 0% blocks executed 0%
    #####: 2120:void AsmPrinter::Impl::printDenseElementsAttr(DenseElementsAttr attr,
        -: 2121:                                              bool allowHex) {
    #####: 2122:  if (auto stringAttr = attr.dyn_cast<DenseStringElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2123:    return printDenseStringElementsAttr(stringAttr);
call    0 never executed
        -: 2124:
    #####: 2125:  printDenseIntOrFPElementsAttr(attr.cast<DenseIntOrFPElementsAttr>(),
call    0 never executed
call    1 never executed
        -: 2126:                                allowHex);
        -: 2127:}
        -: 2128:
function _ZN4mlir10AsmPrinter4Impl29printDenseIntOrFPElementsAttrENS_24DenseIntOrFPElementsAttrEb called 531622 returned 100% blocks executed 68%
   531622: 2129:void AsmPrinter::Impl::printDenseIntOrFPElementsAttr(
        -: 2130:    DenseIntOrFPElementsAttr attr, bool allowHex) {
   531622: 2131:  auto type = attr.getType();
call    0 returned 100%
   531622: 2132:  auto elementType = type.getElementType();
call    0 returned 100%
        -: 2133:
        -: 2134:  // Check to see if we should format this attribute as a hex string.
   531622: 2135:  auto numElements = type.getNumElements();
call    0 returned 100%
   781856: 2136:  if (!attr.isSplat() && allowHex &&
call    0 returned 100%
branch  1 taken 47% (fallthrough)
branch  2 taken 53%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
branch  5 taken 16% (fallthrough)
branch  6 taken 84%
   250234: 2137:      shouldPrintElementsAttrWithHex(numElements)) {
call    0 returned 100%
    41246: 2138:    ArrayRef<char> rawData = attr.getRawData();
call    0 returned 100%
    41246: 2139:    if (llvm::support::endian::system_endianness() ==
        -: 2140:        llvm::support::endianness::big) {
        -: 2141:      // Convert endianess in big-endian(BE) machines. `rawData` is BE in BE
        -: 2142:      // machines. It is converted here to print in LE format.
        -: 2143:      SmallVector<char, 64> outDataVec(rawData.size());
        -: 2144:      MutableArrayRef<char> convRawData(outDataVec);
        -: 2145:      DenseIntOrFPElementsAttr::convertEndianOfArrayRefForBEmachine(
        -: 2146:          rawData, convRawData, type);
        -: 2147:      printHexString(convRawData);
        -: 2148:    } else {
    82492: 2149:      printHexString(rawData);
        -: 2150:    }
        -: 2151:
    41246: 2152:    return;
        -: 2153:  }
        -: 2154:
   490376: 2155:  if (ComplexType complexTy = elementType.dyn_cast<ComplexType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2156:    Type complexElementType = complexTy.getElementType();
call    0 never executed
        -: 2157:    // Note: The if and else below had a common lambda function which invoked
        -: 2158:    // printDenseElementsAttrImpl. This lambda was hitting a bug in gcc 9.1,9.2
        -: 2159:    // and hence was replaced.
    #####: 2160:    if (complexElementType.isa<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2161:      auto valueIt = attr.value_begin<std::complex<APInt>>();
call    0 never executed
function _ZZN4mlir10AsmPrinter4Impl29printDenseIntOrFPElementsAttrENS_24DenseIntOrFPElementsAttrEbENKUljE_clEj called 0 returned 0% blocks executed 0%
    #####: 2162:      printDenseElementsAttrImpl(attr.isSplat(), type, os, [&](unsigned index) {
call    0 never executed
call    1 never executed
    #####: 2163:        auto complexValue = *(valueIt + index);
call    0 never executed
call    1 never executed
    #####: 2164:        os << "(";
call    0 never executed
    #####: 2165:        printDenseIntElement(complexValue.real(), os, complexElementType);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2166:        os << ",";
call    0 never executed
    #####: 2167:        printDenseIntElement(complexValue.imag(), os, complexElementType);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2168:        os << ")";
call    0 never executed
    #####: 2169:      });
        -: 2170:    } else {
    #####: 2171:      auto valueIt = attr.value_begin<std::complex<APFloat>>();
call    0 never executed
function _ZZN4mlir10AsmPrinter4Impl29printDenseIntOrFPElementsAttrENS_24DenseIntOrFPElementsAttrEbENKUljE0_clEj.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2172:      printDenseElementsAttrImpl(attr.isSplat(), type, os, [&](unsigned index) {
call    0 never executed
call    1 never executed
    #####: 2173:        auto complexValue = *(valueIt + index);
call    0 never executed
    #####: 2174:        os << "(";
call    0 never executed
    #####: 2175:        printFloatValue(complexValue.real(), os);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2176:        os << ",";
call    0 never executed
    #####: 2177:        printFloatValue(complexValue.imag(), os);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2178:        os << ")";
call    0 never executed
call    1 never executed
    #####: 2179:      });
        -: 2180:    }
   490376: 2181:  } else if (elementType.isIntOrIndex()) {
call    0 returned 100%
branch  1 taken 10% (fallthrough)
branch  2 taken 90%
    48297: 2182:    auto valueIt = attr.value_begin<APInt>();
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl29printDenseIntOrFPElementsAttrENS_24DenseIntOrFPElementsAttrEbENKUljE1_clEj called 233831 returned 100% blocks executed 67%
    48297: 2183:    printDenseElementsAttrImpl(attr.isSplat(), type, os, [&](unsigned index) {
call    0 returned 100%
call    1 returned 100%
   233831: 2184:      printDenseIntElement(*(valueIt + index), os, elementType);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   233831: 2185:    });
        -: 2186:  } else {
  442079*: 2187:    assert(elementType.isa<FloatType>() && "unexpected element type");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
   442079: 2188:    auto valueIt = attr.value_begin<APFloat>();
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl29printDenseIntOrFPElementsAttrENS_24DenseIntOrFPElementsAttrEbENKUljE2_clEj.isra.0 called 833172 returned 100% blocks executed 100%
  1275251: 2189:    printDenseElementsAttrImpl(attr.isSplat(), type, os, [&](unsigned index) {
call    0 returned 100%
call    1 returned 100%
   833172: 2190:      printFloatValue(*(valueIt + index), os);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   833172: 2191:    });
        -: 2192:  }
        -: 2193:}
        -: 2194:
function _ZN4mlir10AsmPrinter4Impl28printDenseStringElementsAttrENS_23DenseStringElementsAttrE called 0 returned 0% blocks executed 0%
    #####: 2195:void AsmPrinter::Impl::printDenseStringElementsAttr(
        -: 2196:    DenseStringElementsAttr attr) {
    #####: 2197:  ArrayRef<StringRef> data = attr.getRawStringData();
call    0 never executed
function _ZZN4mlir10AsmPrinter4Impl28printDenseStringElementsAttrENS_23DenseStringElementsAttrEENKUljE_clEj.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2198:  auto printFn = [&](unsigned index) { printEscapedString(data[index]); };
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2199:  printDenseElementsAttrImpl(attr.isSplat(), attr.getType(), os, printFn);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2200:}
        -: 2201:
function _ZN4mlir10AsmPrinter4Impl19printDenseArrayAttrENS_14DenseArrayAttrE called 64 returned 100% blocks executed 100%
       64: 2202:void AsmPrinter::Impl::printDenseArrayAttr(DenseArrayAttr attr) {
       64: 2203:  Type type = attr.getElementType();
call    0 returned 100%
       64: 2204:  unsigned bitwidth = type.isInteger(1) ? 8 : type.getIntOrFloatBitWidth();
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
       64: 2205:  unsigned byteSize = bitwidth / 8;
       64: 2206:  ArrayRef<char> data = attr.getRawData();
call    0 returned 100%
        -: 2207:
function _ZZN4mlir10AsmPrinter4Impl19printDenseArrayAttrENS_14DenseArrayAttrEENKUljE_clEj called 104 returned 100% blocks executed 50%
      168: 2208:  auto printElementAt = [&](unsigned i) {
      104: 2209:    APInt value(bitwidth, 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      104: 2210:    if (bitwidth) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      104: 2211:      llvm::LoadIntFromMemory(
      104: 2212:          value, reinterpret_cast<const uint8_t *>(data.begin() + byteSize * i),
call    0 returned 100%
        -: 2213:          byteSize);
        -: 2214:    }
        -: 2215:    // Print the data as-is or as a float.
     104*: 2216:    if (type.isIntOrIndex()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     104*: 2217:      printDenseIntElement(value, getStream(), type);
call    0 returned 100%
        -: 2218:    } else {
    #####: 2219:      APFloat fltVal(type.cast<FloatType>().getFloatSemantics(), value);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2220:      printFloatValue(fltVal, getStream());
call    0 never executed
call    1 never executed
        -: 2221:    }
      168: 2222:  };
      128: 2223:  llvm::interleaveComma(llvm::seq<unsigned>(0, attr.size()), getStream(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2224:                        printElementAt);
       64: 2225:}
        -: 2226:
function _ZN4mlir10AsmPrinter4Impl9printTypeENS_4TypeE called 11808403 returned 100% blocks executed 71%
 11808403: 2227:void AsmPrinter::Impl::printType(Type type) {
 11808403: 2228:  if (!type) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2229:    os << "<<NULL TYPE>>";
    #####: 2230:    return;
call    0 never executed
        -: 2231:  }
        -: 2232:
        -: 2233:  // Try to print an alias for this type.
 11808403: 2234:  if (succeeded(printAlias(type)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 2235:    return;
 11808403: 2236:  return printTypeImpl(type);
call    0 returned 100%
        -: 2237:}
        -: 2238:
function _ZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeE called 11808401 returned 100% blocks executed 100%
 11808401: 2239:void AsmPrinter::Impl::printTypeImpl(Type type) {
 11808401: 2240:  TypeSwitch<Type>(type)
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_10OpaqueTypeEE_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2241:      .Case<OpaqueType>([&](OpaqueType opaqueTy) {
    #####: 2242:        printDialectSymbol(os, "!", opaqueTy.getDialectNamespace(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2243:                           opaqueTy.getTypeData());
11808401*: 2244:      })
call    0 returned 100%
 11811786: 2245:      .Case<IndexType>([&](Type) { os << "index"; })
call    0 returned 100%
call    1 returned 100%
11808410*: 2246:      .Case<Float8E5M2Type>([&](Type) { os << "f8E5M2"; })
call    0 never executed
call    1 returned 100%
11808414*: 2247:      .Case<BFloat16Type>([&](Type) { os << "bf16"; })
call    0 never executed
call    1 returned 100%
 13448198: 2248:      .Case<Float16Type>([&](Type) { os << "f16"; })
call    0 returned 100%
call    1 returned 100%
 15290309: 2249:      .Case<Float32Type>([&](Type) { os << "f32"; })
call    0 returned 100%
call    1 returned 100%
 11808422: 2250:      .Case<Float64Type>([&](Type) { os << "f64"; })
call    0 returned 100%
call    1 returned 100%
11808410*: 2251:      .Case<Float80Type>([&](Type) { os << "f80"; })
call    0 never executed
call    1 returned 100%
11808412*: 2252:      .Case<Float128Type>([&](Type) { os << "f128"; })
call    0 never executed
call    1 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_11IntegerTypeEE8_clES3_.isra.0 called 1072308 returned 100% blocks executed 65%
  1072308: 2253:      .Case<IntegerType>([&](IntegerType integerTy) {
  1072308: 2254:        if (integerTy.isSigned())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2255:          os << 's';
branch  0 never executed
branch  1 never executed
  1072307: 2256:        else if (integerTy.isUnsigned())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2257:          os << 'u';
branch  0 never executed
branch  1 never executed
  2144611: 2258:        os << 'i' << integerTy.getWidth();
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
call    3 returned 100%
 11808406: 2259:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_12FunctionTypeEE9_clES3_.isra.0 called 11843 returned 100% blocks executed 100%
    11843: 2260:      .Case<FunctionType>([&](FunctionType funcTy) {
    11843: 2261:        os << '(';
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
    33425: 2262:        interleaveComma(funcTy.getInputs(), [&](Type ty) { printType(ty); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    11845: 2263:        os << ") -> ";
call    0 returned 100%
    11846: 2264:        ArrayRef<Type> results = funcTy.getResults();
call    0 returned 100%
    11850: 2265:        if (results.size() == 1 && !results[0].isa<FunctionType>()) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
     2172: 2266:          printType(results[0]);
call    0 returned 100%
        -: 2267:        } else {
     9678: 2268:          os << '(';
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
    31986: 2269:          interleaveComma(results, [&](Type ty) { printType(ty); });
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     9678: 2270:          os << ')';
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -: 2271:        }
 11808409: 2272:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_10VectorTypeEE10_clES3_.isra.0 called 20 returned 100% blocks executed 54%
       20: 2273:      .Case<VectorType>([&](VectorType vectorTy) {
      20*: 2274:        os << "vector<";
call    0 returned 100%
       20: 2275:        auto vShape = vectorTy.getShape();
call    0 returned 100%
       20: 2276:        unsigned lastDim = vShape.size();
call    0 returned 100%
       20: 2277:        unsigned lastFixedDim = lastDim - vectorTy.getNumScalableDims();
call    0 returned 100%
       20: 2278:        unsigned dimIdx = 0;
       40: 2279:        for (dimIdx = 0; dimIdx < lastFixedDim; dimIdx++)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       40: 2280:          os << vShape[dimIdx] << 'x';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 25% (fallthrough)
branch  4 taken 75%
       20: 2281:        if (vectorTy.isScalable()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2282:          os << '[';
branch  0 never executed
branch  1 never executed
    #####: 2283:          unsigned secondToLastDim = lastDim - 1;
    #####: 2284:          for (; dimIdx < secondToLastDim; dimIdx++)
branch  0 never executed
branch  1 never executed
    #####: 2285:            os << vShape[dimIdx] << 'x';
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2286:          os << vShape[dimIdx] << "]x";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 2287:        }
       20: 2288:        printType(vectorTy.getElementType());
call    0 returned 100%
call    1 returned 100%
       20: 2289:        os << '>';
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
 11808410: 2290:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_16RankedTensorTypeEE11_clES3_.isra.0 called 5555116 returned 100% blocks executed 76%
  5555116: 2291:      .Case<RankedTensorType>([&](RankedTensorType tensorTy) {
 5555116*: 2292:        os << "tensor<";
call    0 returned 100%
 26470502: 2293:        for (int64_t dim : tensorTy.getShape()) {
call    0 returned 100%
branch  1 taken 79% (fallthrough)
branch  2 taken 21%
 20915386: 2294:          if (ShapedType::isDynamic(dim))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2295:            os << '?';
branch  0 never executed
branch  1 never executed
        -: 2296:          else
 20915386: 2297:            os << dim;
call    0 returned 100%
 41830772: 2298:          os << 'x';
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -: 2299:        }
  5555116: 2300:        printType(tensorTy.getElementType());
call    0 returned 100%
call    1 returned 100%
        -: 2301:        // Only print the encoding attribute value if set.
  5555116: 2302:        if (tensorTy.getEncoding()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2303:          os << ", ";
call    0 never executed
    #####: 2304:          printAttribute(tensorTy.getEncoding());
call    0 never executed
call    1 never executed
        -: 2305:        }
  5555116: 2306:        os << '>';
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
 11808409: 2307:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_18UnrankedTensorTypeEE12_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2308:      .Case<UnrankedTensorType>([&](UnrankedTensorType tensorTy) {
    #####: 2309:        os << "tensor<*x";
call    0 never executed
    #####: 2310:        printType(tensorTy.getElementType());
call    0 never executed
call    1 never executed
    #####: 2311:        os << '>';
branch  0 never executed
branch  1 never executed
11808408*: 2312:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_10MemRefTypeEE13_clES3_.isra.0 called 10305 returned 100% blocks executed 79%
    10305: 2313:      .Case<MemRefType>([&](MemRefType memrefTy) {
   10305*: 2314:        os << "memref<";
call    0 returned 100%
    47704: 2315:        for (int64_t dim : memrefTy.getShape()) {
call    0 returned 100%
branch  1 taken 78% (fallthrough)
branch  2 taken 22%
    37399: 2316:          if (ShapedType::isDynamic(dim))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2317:            os << '?';
branch  0 never executed
branch  1 never executed
        -: 2318:          else
    37399: 2319:            os << dim;
call    0 returned 100%
    74798: 2320:          os << 'x';
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -: 2321:        }
    10305: 2322:        printType(memrefTy.getElementType());
call    0 returned 100%
call    1 returned 100%
    10305: 2323:        MemRefLayoutAttrInterface layout = memrefTy.getLayout();
call    0 returned 100%
    10305: 2324:        if (!layout.isa<AffineMapAttr>() || !layout.isIdentity()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 2325:          os << ", ";
call    0 never executed
    #####: 2326:          printAttribute(memrefTy.getLayout(), AttrTypeElision::May);
call    0 never executed
call    1 never executed
        -: 2327:        }
        -: 2328:        // Only print the memory space if it is the non-default one.
    10305: 2329:        if (memrefTy.getMemorySpace()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       46: 2330:          os << ", ";
call    0 returned 100%
       46: 2331:          printAttribute(memrefTy.getMemorySpace(), AttrTypeElision::May);
call    0 returned 100%
call    1 returned 100%
        -: 2332:        }
    10305: 2333:        os << '>';
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
 11808409: 2334:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_18UnrankedMemRefTypeEE14_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2335:      .Case<UnrankedMemRefType>([&](UnrankedMemRefType memrefTy) {
    #####: 2336:        os << "memref<*x";
call    0 never executed
    #####: 2337:        printType(memrefTy.getElementType());
call    0 never executed
call    1 never executed
        -: 2338:        // Only print the memory space if it is the non-default one.
    #####: 2339:        if (memrefTy.getMemorySpace()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2340:          os << ", ";
call    0 never executed
    #####: 2341:          printAttribute(memrefTy.getMemorySpace(), AttrTypeElision::May);
call    0 never executed
call    1 never executed
        -: 2342:        }
    #####: 2343:        os << '>';
branch  0 never executed
branch  1 never executed
11808409*: 2344:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_11ComplexTypeEE15_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2345:      .Case<ComplexType>([&](ComplexType complexTy) {
    #####: 2346:        os << "complex<";
call    0 never executed
    #####: 2347:        printType(complexTy.getElementType());
call    0 never executed
call    1 never executed
    #####: 2348:        os << '>';
branch  0 never executed
branch  1 never executed
11808408*: 2349:      })
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl13printTypeImplENS_4TypeEENKUlNS_9TupleTypeEE16_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2350:      .Case<TupleType>([&](TupleType tupleTy) {
    #####: 2351:        os << "tuple<";
call    0 never executed
    #####: 2352:        interleaveComma(tupleTy.getTypes(),
call    0 never executed
call    1 never executed
    #####: 2353:                        [&](Type type) { printType(type); });
call    0 never executed
call    1 never executed
    #####: 2354:        os << '>';
branch  0 never executed
branch  1 never executed
11808405*: 2355:      })
call    0 returned 100%
11808401*: 2356:      .Case<NoneType>([&](Type) { os << "none"; })
call    0 never executed
call    1 returned 100%
 11808403: 2357:      .Default([&](Type type) { return printDialectType(type); });
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
 11808401: 2358:}
        -: 2359:
function _ZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEb called 3024347 returned 100% blocks executed 100%
  3024347: 2360:void AsmPrinter::Impl::printOptionalAttrDict(ArrayRef<NamedAttribute> attrs,
        -: 2361:                                             ArrayRef<StringRef> elidedAttrs,
        -: 2362:                                             bool withKeyword) {
        -: 2363:  // If there are no attributes, then there is nothing to be done.
  3024347: 2364:  if (attrs.empty())
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
  2834483: 2365:    return;
        -: 2366:
        -: 2367:  // Functor used to print a filtered attribute list.
  3987608: 2368:  auto printFilteredAttributesFn = [&](auto filteredAttrs) {
        -: 2369:    // Print the 'attributes' keyword if necessary.
  1900628: 2370:    if (withKeyword)
    3507*: 2371:      os << " attributes";
        -: 2372:
        -: 2373:    // Otherwise, print them all out in braces.
  1900628: 2374:    os << " {";
  1900628: 2375:    interleaveComma(filteredAttrs,
  2184217: 2376:                    [&](NamedAttribute attr) { printNamedAttribute(attr); });
call    0 returned 100%
call    1 returned 100%
  1900631: 2377:    os << '}';
  3987610: 2378:  };
------------------
_ZZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEbENKUlT_E_clIS5_EEDaS8_.isra.0:
function _ZZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEbENKUlT_E_clIS5_EEDaS8_.isra.0 called 1897121 returned 100% blocks executed 89%
  1897121: 2368:  auto printFilteredAttributesFn = [&](auto filteredAttrs) {
        -: 2369:    // Print the 'attributes' keyword if necessary.
  1897121: 2370:    if (withKeyword)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2371:      os << " attributes";
call    0 never executed
        -: 2372:
        -: 2373:    // Otherwise, print them all out in braces.
  1897121: 2374:    os << " {";
call    0 returned 100%
  1897121: 2375:    interleaveComma(filteredAttrs,
call    0 returned 100%
        -: 2376:                    [&](NamedAttribute attr) { printNamedAttribute(attr); });
  1897124: 2377:    os << '}';
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
  1897123: 2378:  };
------------------
_ZZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEbENKUlT_E_clINS2_14iterator_rangeINS2_20filter_iterator_implIPKS4_ZNS1_21printOptionalAttrDictES5_S7_bEUlS4_E0_St26bidirectional_iterator_tagEEEEEEDaS8_.isra.0:
function _ZZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEbENKUlT_E_clINS2_14iterator_rangeINS2_20filter_iterator_implIPKS4_ZNS1_21printOptionalAttrDictES5_S7_bEUlS4_E0_St26bidirectional_iterator_tagEEEEEEDaS8_.isra.0 called 3507 returned 100% blocks executed 100%
     3507: 2368:  auto printFilteredAttributesFn = [&](auto filteredAttrs) {
        -: 2369:    // Print the 'attributes' keyword if necessary.
     3507: 2370:    if (withKeyword)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3507: 2371:      os << " attributes";
call    0 returned 100%
        -: 2372:
        -: 2373:    // Otherwise, print them all out in braces.
     3507: 2374:    os << " {";
call    0 returned 100%
     3507: 2375:    interleaveComma(filteredAttrs,
call    0 returned 100%
        -: 2376:                    [&](NamedAttribute attr) { printNamedAttribute(attr); });
     3507: 2377:    os << '}';
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
     3507: 2378:  };
------------------
        -: 2379:
        -: 2380:  // If no attributes are elided, we can directly print with no filtering.
  2086980: 2381:  if (elidedAttrs.empty())
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
  1897114: 2382:    return printFilteredAttributesFn(attrs);
call    0 returned 100%
        -: 2383:
        -: 2384:  // Otherwise, filter out any attributes that shouldn't be included.
   379732: 2385:  llvm::SmallDenseSet<StringRef> elidedAttrsSet(elidedAttrs.begin(),
   379732: 2386:                                                elidedAttrs.end());
call    0 returned 100%
function _ZZN4mlir10AsmPrinter4Impl21printOptionalAttrDictEN4llvm8ArrayRefINS_14NamedAttributeEEENS3_INS2_9StringRefEEEbENKUlS4_E0_clES4_.isra.0 called 718367 returned 100% blocks executed 100%
   718367: 2387:  auto filteredAttrs = llvm::make_filter_range(attrs, [&](NamedAttribute attr) {
   718367: 2388:    return !elidedAttrsSet.contains(attr.getName().strref());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   189866: 2389:  });
call    0 returned 100%
   189866: 2390:  if (!filteredAttrs.empty())
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     3507: 2391:    printFilteredAttributesFn(filteredAttrs);
call    0 returned 100%
        -: 2392:}
        -: 2393:
function _ZN4mlir10AsmPrinter4Impl19printNamedAttributeENS_14NamedAttributeE called 2240182 returned 100% blocks executed 100%
  2240182: 2394:void AsmPrinter::Impl::printNamedAttribute(NamedAttribute attr) {
        -: 2395:  // Print the name without quotes if possible.
  2240182: 2396:  ::printKeywordOrString(attr.getName().strref(), os);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2397:
        -: 2398:  // Pretty printing elides the attribute value for unit attributes.
  2240183: 2399:  if (attr.getValue().isa<UnitAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
        -: 2400:    return;
        -: 2401:
  2237603: 2402:  os << " = ";
call    0 returned 100%
  2237592: 2403:  printAttribute(attr.getValue());
call    0 returned 100%
        -: 2404:}
        -: 2405:
function _ZN4mlir10AsmPrinter4Impl21printDialectAttributeENS_9AttributeE called 100 returned 100% blocks executed 90%
      100: 2406:void AsmPrinter::Impl::printDialectAttribute(Attribute attr) {
      100: 2407:  auto &dialect = attr.getDialect();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2408:
        -: 2409:  // Ask the dialect to serialize the attribute to a string.
      100: 2410:  std::string attrName;
call    0 returned 100%
      100: 2411:  {
      100: 2412:    llvm::raw_string_ostream attrNameStr(attrName);
call    0 returned 100%
      100: 2413:    Impl subPrinter(attrNameStr, state);
      100: 2414:    DialectAsmPrinter printer(subPrinter);
call    0 returned 100%
call    1 returned 100%
      100: 2415:    dialect.printAttribute(attr, printer);
call    0 returned 100%
call    1 returned 100%
        -: 2416:  }
      100: 2417:  printDialectSymbol(os, "#", dialect.getNamespace(), attrName);
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
      100: 2418:}
        -: 2419:
function _ZN4mlir10AsmPrinter4Impl16printDialectTypeENS_4TypeE called 33784 returned 100% blocks executed 90%
    33784: 2420:void AsmPrinter::Impl::printDialectType(Type type) {
    33784: 2421:  auto &dialect = type.getDialect();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2422:
        -: 2423:  // Ask the dialect to serialize the type to a string.
    33784: 2424:  std::string typeName;
call    0 returned 100%
    33784: 2425:  {
    33784: 2426:    llvm::raw_string_ostream typeNameStr(typeName);
call    0 returned 100%
    33784: 2427:    Impl subPrinter(typeNameStr, state);
    33784: 2428:    DialectAsmPrinter printer(subPrinter);
call    0 returned 100%
call    1 returned 100%
    33784: 2429:    dialect.printType(type, printer);
call    0 returned 100%
call    1 returned 100%
        -: 2430:  }
    33782: 2431:  printDialectSymbol(os, "!", dialect.getNamespace(), typeName);
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
    33783: 2432:}
        -: 2433:
function _ZN4mlir10AsmPrinter4Impl18printEscapedStringEN4llvm9StringRefE called 2629458 returned 100% blocks executed 100%
  2629458: 2434:void AsmPrinter::Impl::printEscapedString(StringRef str) {
  2629458: 2435:  os << "\"";
call    0 returned 100%
  2629449: 2436:  llvm::printEscapedString(str, os);
call    0 returned 100%
  2629426: 2437:  os << "\"";
call    0 returned 100%
  2629433: 2438:}
        -: 2439:
function _ZN4mlir10AsmPrinter4Impl14printHexStringEN4llvm9StringRefE called 41246 returned 100% blocks executed 100%
    41246: 2440:void AsmPrinter::Impl::printHexString(StringRef str) {
    82492: 2441:  os << "\"0x" << llvm::toHex(str) << "\"";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    41246: 2442:}
function _ZN4mlir10AsmPrinter4Impl14printHexStringEN4llvm8ArrayRefIcEE called 0 returned 0% blocks executed 0%
   41246*: 2443:void AsmPrinter::Impl::printHexString(ArrayRef<char> data) {
   41246*: 2444:  printHexString(StringRef(data.data(), data.size()));
call    0 never executed
call    1 returned 100%
    #####: 2445:}
        -: 2446:
        -: 2447://===--------------------------------------------------------------------===//
        -: 2448:// AsmPrinter
        -: 2449://===--------------------------------------------------------------------===//
        -: 2450:
        -: 2451:AsmPrinter::~AsmPrinter() = default;
        -: 2452:
function _ZNK4mlir10AsmPrinter9getStreamEv called 4982884 returned 100% blocks executed 67%
  4982884: 2453:raw_ostream &AsmPrinter::getStream() const {
 4982884*: 2454:  assert(impl && "expected AsmPrinter::getStream to be overriden");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  4982884: 2455:  return impl->getStream();
        -: 2456:}
        -: 2457:
        -: 2458:/// Print the given floating point value in a stablized form.
function _ZN4mlir10AsmPrinter10printFloatERKN4llvm7APFloatE called 0 returned 0% blocks executed 0%
    #####: 2459:void AsmPrinter::printFloat(const APFloat &value) {
    #####: 2460:  assert(impl && "expected AsmPrinter::printFloat to be overriden");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2461:  printFloatValue(value, impl->getStream());
call    0 never executed
    #####: 2462:}
        -: 2463:
function _ZN4mlir10AsmPrinter9printTypeENS_4TypeE called 4720592 returned 100% blocks executed 75%
  4720592: 2464:void AsmPrinter::printType(Type type) {
 4720592*: 2465:  assert(impl && "expected AsmPrinter::printType to be overriden");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  4720592: 2466:  impl->printType(type);
call    0 returned 100%
  4720586: 2467:}
        -: 2468:
function _ZN4mlir10AsmPrinter14printAttributeENS_9AttributeE called 4752 returned 100% blocks executed 75%
     4752: 2469:void AsmPrinter::printAttribute(Attribute attr) {
    4752*: 2470:  assert(impl && "expected AsmPrinter::printAttribute to be overriden");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     4752: 2471:  impl->printAttribute(attr);
call    0 returned 100%
     4752: 2472:}
        -: 2473:
function _ZN4mlir10AsmPrinter10printAliasENS_9AttributeE called 602 returned 100% blocks executed 75%
      602: 2474:LogicalResult AsmPrinter::printAlias(Attribute attr) {
     602*: 2475:  assert(impl && "expected AsmPrinter::printAlias to be overriden");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      602: 2476:  return impl->printAlias(attr);
call    0 returned 100%
        -: 2477:}
        -: 2478:
function _ZN4mlir10AsmPrinter10printAliasENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2479:LogicalResult AsmPrinter::printAlias(Type type) {
    #####: 2480:  assert(impl && "expected AsmPrinter::printAlias to be overriden");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2481:  return impl->printAlias(type);
call    0 never executed
        -: 2482:}
        -: 2483:
function _ZN4mlir10AsmPrinter25printAttributeWithoutTypeENS_9AttributeE called 108 returned 100% blocks executed 75%
      108: 2484:void AsmPrinter::printAttributeWithoutType(Attribute attr) {
     108*: 2485:  assert(impl &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 2486:         "expected AsmPrinter::printAttributeWithoutType to be overriden");
      108: 2487:  impl->printAttribute(attr, Impl::AttrTypeElision::Must);
call    0 returned 100%
      108: 2488:}
        -: 2489:
function _ZN4mlir10AsmPrinter20printKeywordOrStringEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 2490:void AsmPrinter::printKeywordOrString(StringRef keyword) {
    #####: 2491:  assert(impl && "expected AsmPrinter::printKeywordOrString to be overriden");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2492:  ::printKeywordOrString(keyword, impl->getStream());
call    0 never executed
    #####: 2493:}
        -: 2494:
function _ZN4mlir10AsmPrinter15printSymbolNameEN4llvm9StringRefE called 183723 returned 100% blocks executed 75%
   183723: 2495:void AsmPrinter::printSymbolName(StringRef symbolRef) {
  183723*: 2496:  assert(impl && "expected AsmPrinter::printSymbolName to be overriden");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   183723: 2497:  ::printSymbolReference(symbolRef, impl->getStream());
call    0 returned 100%
   183723: 2498:}
        -: 2499:
function _ZN4mlir10AsmPrinter19printResourceHandleERKNS_24AsmDialectResourceHandleE called 0 returned 0% blocks executed 0%
    #####: 2500:void AsmPrinter::printResourceHandle(const AsmDialectResourceHandle &resource) {
    #####: 2501:  assert(impl && "expected AsmPrinter::printResourceHandle to be overriden");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2502:  impl->printResourceHandle(resource);
call    0 never executed
    #####: 2503:}
        -: 2504:
        -: 2505://===----------------------------------------------------------------------===//
        -: 2506:// Affine expressions and maps
        -: 2507://===----------------------------------------------------------------------===//
        -: 2508:
function _ZN4mlir10AsmPrinter4Impl15printAffineExprENS_10AffineExprEN4llvm12function_refIFvjbEEE called 0 returned 0% blocks executed 0%
      90*: 2509:void AsmPrinter::Impl::printAffineExpr(
        -: 2510:    AffineExpr expr, function_ref<void(unsigned, bool)> printValueName) {
      90*: 2511:  printAffineExprInternal(expr, BindingStrength::Weak, printValueName);
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 2512:}
        -: 2513:
function _ZN4mlir10AsmPrinter4Impl23printAffineExprInternalENS_10AffineExprENS1_15BindingStrengthEN4llvm12function_refIFvjbEEE called 90 returned 100% blocks executed 9%
       90: 2514:void AsmPrinter::Impl::printAffineExprInternal(
        -: 2515:    AffineExpr expr, BindingStrength enclosingTightness,
        -: 2516:    function_ref<void(unsigned, bool)> printValueName) {
       90: 2517:  const char *binopSpelling = nullptr;
       90: 2518:  switch (expr.getKind()) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
    #####: 2519:  case AffineExprKind::SymbolId: {
    #####: 2520:    unsigned pos = expr.cast<AffineSymbolExpr>().getPosition();
call    0 never executed
call    1 never executed
    #####: 2521:    if (printValueName)
branch  0 never executed
branch  1 never executed
    #####: 2522:      printValueName(pos, /*isSymbol=*/true);
call    0 never executed
        -: 2523:    else
    #####: 2524:      os << 's' << pos;
branch  0 never executed
branch  1 never executed
call    2 never executed
       90: 2525:    return;
        -: 2526:  }
       90: 2527:  case AffineExprKind::DimId: {
       90: 2528:    unsigned pos = expr.cast<AffineDimExpr>().getPosition();
call    0 returned 100%
call    1 returned 100%
       90: 2529:    if (printValueName)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2530:      printValueName(pos, /*isSymbol=*/false);
call    0 never executed
        -: 2531:    else
      180: 2532:      os << 'd' << pos;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
        -: 2533:    return;
        -: 2534:  }
    #####: 2535:  case AffineExprKind::Constant:
    #####: 2536:    os << expr.cast<AffineConstantExpr>().getValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2537:    return;
    #####: 2538:  case AffineExprKind::Add:
    #####: 2539:    binopSpelling = " + ";
    #####: 2540:    break;
    #####: 2541:  case AffineExprKind::Mul:
    #####: 2542:    binopSpelling = " * ";
    #####: 2543:    break;
    #####: 2544:  case AffineExprKind::FloorDiv:
    #####: 2545:    binopSpelling = " floordiv ";
    #####: 2546:    break;
    #####: 2547:  case AffineExprKind::CeilDiv:
    #####: 2548:    binopSpelling = " ceildiv ";
    #####: 2549:    break;
    #####: 2550:  case AffineExprKind::Mod:
    #####: 2551:    binopSpelling = " mod ";
    #####: 2552:    break;
        -: 2553:  }
        -: 2554:
    #####: 2555:  auto binOp = expr.cast<AffineBinaryOpExpr>();
call    0 never executed
    #####: 2556:  AffineExpr lhsExpr = binOp.getLHS();
call    0 never executed
    #####: 2557:  AffineExpr rhsExpr = binOp.getRHS();
call    0 never executed
        -: 2558:
        -: 2559:  // Handle tightly binding binary operators.
    #####: 2560:  if (binOp.getKind() != AffineExprKind::Add) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2561:    if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2562:      os << '(';
branch  0 never executed
branch  1 never executed
        -: 2563:
        -: 2564:    // Pretty print multiplication with -1.
    #####: 2565:    auto rhsConst = rhsExpr.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####: 2566:    if (rhsConst && binOp.getKind() == AffineExprKind::Mul &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2567:        rhsConst.getValue() == -1) {
call    0 never executed
    #####: 2568:      os << "-";
call    0 never executed
    #####: 2569:      printAffineExprInternal(lhsExpr, BindingStrength::Strong, printValueName);
call    0 never executed
    #####: 2570:      if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2571:        os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2572:      return;
        -: 2573:    }
        -: 2574:
    #####: 2575:    printAffineExprInternal(lhsExpr, BindingStrength::Strong, printValueName);
call    0 never executed
        -: 2576:
    #####: 2577:    os << binopSpelling;
call    0 never executed
    #####: 2578:    printAffineExprInternal(rhsExpr, BindingStrength::Strong, printValueName);
call    0 never executed
        -: 2579:
    #####: 2580:    if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2581:      os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2582:    return;
        -: 2583:  }
        -: 2584:
        -: 2585:  // Print out special "pretty" forms for add.
    #####: 2586:  if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2587:    os << '(';
branch  0 never executed
branch  1 never executed
        -: 2588:
        -: 2589:  // Pretty print addition to a product that has a negative operand as a
        -: 2590:  // subtraction.
    #####: 2591:  if (auto rhs = rhsExpr.dyn_cast<AffineBinaryOpExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2592:    if (rhs.getKind() == AffineExprKind::Mul) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2593:      AffineExpr rrhsExpr = rhs.getRHS();
call    0 never executed
    #####: 2594:      if (auto rrhs = rrhsExpr.dyn_cast<AffineConstantExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2595:        if (rrhs.getValue() == -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2596:          printAffineExprInternal(lhsExpr, BindingStrength::Weak,
call    0 never executed
        -: 2597:                                  printValueName);
    #####: 2598:          os << " - ";
call    0 never executed
    #####: 2599:          if (rhs.getLHS().getKind() == AffineExprKind::Add) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2600:            printAffineExprInternal(rhs.getLHS(), BindingStrength::Strong,
call    0 never executed
call    1 never executed
        -: 2601:                                    printValueName);
        -: 2602:          } else {
    #####: 2603:            printAffineExprInternal(rhs.getLHS(), BindingStrength::Weak,
call    0 never executed
call    1 never executed
        -: 2604:                                    printValueName);
        -: 2605:          }
        -: 2606:
    #####: 2607:          if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2608:            os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2609:          return;
        -: 2610:        }
        -: 2611:
    #####: 2612:        if (rrhs.getValue() < -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2613:          printAffineExprInternal(lhsExpr, BindingStrength::Weak,
call    0 never executed
        -: 2614:                                  printValueName);
    #####: 2615:          os << " - ";
call    0 never executed
    #####: 2616:          printAffineExprInternal(rhs.getLHS(), BindingStrength::Strong,
call    0 never executed
call    1 never executed
        -: 2617:                                  printValueName);
    #####: 2618:          os << " * " << -rrhs.getValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2619:          if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2620:            os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2621:          return;
        -: 2622:        }
        -: 2623:      }
        -: 2624:    }
        -: 2625:  }
        -: 2626:
        -: 2627:  // Pretty print addition to a negative number as a subtraction.
    #####: 2628:  if (auto rhsConst = rhsExpr.dyn_cast<AffineConstantExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2629:    if (rhsConst.getValue() < 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2630:      printAffineExprInternal(lhsExpr, BindingStrength::Weak, printValueName);
call    0 never executed
    #####: 2631:      os << " - " << -rhsConst.getValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2632:      if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2633:        os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2634:      return;
        -: 2635:    }
        -: 2636:  }
        -: 2637:
    #####: 2638:  printAffineExprInternal(lhsExpr, BindingStrength::Weak, printValueName);
call    0 never executed
        -: 2639:
    #####: 2640:  os << " + ";
call    0 never executed
    #####: 2641:  printAffineExprInternal(rhsExpr, BindingStrength::Weak, printValueName);
call    0 never executed
        -: 2642:
    #####: 2643:  if (enclosingTightness == BindingStrength::Strong)
branch  0 never executed
branch  1 never executed
    #####: 2644:    os << ')';
branch  0 never executed
branch  1 never executed
        -: 2645:}
        -: 2646:
function _ZN4mlir10AsmPrinter4Impl21printAffineConstraintENS_10AffineExprEb called 0 returned 0% blocks executed 0%
    #####: 2647:void AsmPrinter::Impl::printAffineConstraint(AffineExpr expr, bool isEq) {
    #####: 2648:  printAffineExprInternal(expr, BindingStrength::Weak);
call    0 never executed
    #####: 2649:  isEq ? os << " == 0" : os << " >= 0";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2650:}
        -: 2651:
function _ZN4mlir10AsmPrinter4Impl14printAffineMapENS_9AffineMapE called 24 returned 100% blocks executed 58%
       24: 2652:void AsmPrinter::Impl::printAffineMap(AffineMap map) {
        -: 2653:  // Dimension identifiers.
       24: 2654:  os << '(';
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       90: 2655:  for (int i = 0; i < (int)map.getNumDims() - 1; ++i)
call    0 returned 100%
branch  1 taken 73% (fallthrough)
branch  2 taken 27%
      132: 2656:    os << 'd' << i << ", ";
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
       24: 2657:  if (map.getNumDims() >= 1)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       48: 2658:    os << 'd' << map.getNumDims() - 1;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
       24: 2659:  os << ')';
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 2660:
        -: 2661:  // Symbolic identifiers.
       24: 2662:  if (map.getNumSymbols() != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2663:    os << '[';
branch  0 never executed
branch  1 never executed
    #####: 2664:    for (unsigned i = 0; i < map.getNumSymbols() - 1; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2665:      os << 's' << i << ", ";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2666:    if (map.getNumSymbols() >= 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2667:      os << 's' << map.getNumSymbols() - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2668:    os << ']';
branch  0 never executed
branch  1 never executed
        -: 2669:  }
        -: 2670:
        -: 2671:  // Result affine expressions.
       24: 2672:  os << " -> (";
call    0 returned 100%
       24: 2673:  interleaveComma(map.getResults(),
call    0 returned 100%
call    1 returned 100%
       90: 2674:                  [&](AffineExpr expr) { printAffineExpr(expr); });
call    0 returned 100%
call    1 returned 100%
       24: 2675:  os << ')';
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       24: 2676:}
        -: 2677:
function _ZN4mlir10AsmPrinter4Impl15printIntegerSetENS_10IntegerSetE called 0 returned 0% blocks executed 0%
    #####: 2678:void AsmPrinter::Impl::printIntegerSet(IntegerSet set) {
        -: 2679:  // Dimension identifiers.
    #####: 2680:  os << '(';
branch  0 never executed
branch  1 never executed
    #####: 2681:  for (unsigned i = 1; i < set.getNumDims(); ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2682:    os << 'd' << i - 1 << ", ";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2683:  if (set.getNumDims() >= 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2684:    os << 'd' << set.getNumDims() - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2685:  os << ')';
branch  0 never executed
branch  1 never executed
        -: 2686:
        -: 2687:  // Symbolic identifiers.
    #####: 2688:  if (set.getNumSymbols() != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2689:    os << '[';
branch  0 never executed
branch  1 never executed
    #####: 2690:    for (unsigned i = 0; i < set.getNumSymbols() - 1; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2691:      os << 's' << i << ", ";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2692:    if (set.getNumSymbols() >= 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2693:      os << 's' << set.getNumSymbols() - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2694:    os << ']';
branch  0 never executed
branch  1 never executed
        -: 2695:  }
        -: 2696:
        -: 2697:  // Print constraints.
    #####: 2698:  os << " : (";
call    0 never executed
    #####: 2699:  int numConstraints = set.getNumConstraints();
call    0 never executed
    #####: 2700:  for (int i = 1; i < numConstraints; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2701:    printAffineConstraint(set.getConstraint(i - 1), set.isEq(i - 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2702:    os << ", ";
call    0 never executed
        -: 2703:  }
    #####: 2704:  if (numConstraints >= 1)
branch  0 never executed
branch  1 never executed
    #####: 2705:    printAffineConstraint(set.getConstraint(numConstraints - 1),
call    0 never executed
call    1 never executed
    #####: 2706:                          set.isEq(numConstraints - 1));
call    0 never executed
    #####: 2707:  os << ')';
branch  0 never executed
branch  1 never executed
    #####: 2708:}
        -: 2709:
        -: 2710://===----------------------------------------------------------------------===//
        -: 2711:// OperationPrinter
        -: 2712://===----------------------------------------------------------------------===//
        -: 2713:
        -: 2714:namespace {
        -: 2715:/// This class contains the logic for printing operations, regions, and blocks.
  284956*: 2716:class OperationPrinter : public AsmPrinter::Impl, private OpAsmPrinter {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2717:public:
        -: 2718:  using Impl = AsmPrinter::Impl;
        -: 2719:  using Impl::printType;
        -: 2720:
function _ZN12_GLOBAL__N_116OperationPrinterC2ERN4llvm11raw_ostreamERN4mlir6detail12AsmStateImplE called 290484 returned 100% blocks executed 100%
   290484: 2721:  explicit OperationPrinter(raw_ostream &os, AsmStateImpl &state)
   290484: 2722:      : Impl(os, state), OpAsmPrinter(static_cast<Impl &>(*this)) {}
call    0 returned 100%
        -: 2723:
        -: 2724:  /// Print the given top-level operation.
        -: 2725:  void printTopLevelOperation(Operation *op);
        -: 2726:
        -: 2727:  /// Print the given operation, including its left-hand side and its right-hand
        -: 2728:  /// side, with its indent and location.
        -: 2729:  void printFullOpWithIndentAndLoc(Operation *op);
        -: 2730:  /// Print the given operation, including its left-hand side and its right-hand
        -: 2731:  /// side, but not including indentation and location.
        -: 2732:  void printFullOp(Operation *op);
        -: 2733:  /// Print the right-hand size of the given operation in the custom or generic
        -: 2734:  /// form.
        -: 2735:  void printCustomOrGenericOp(Operation *op) override;
        -: 2736:  /// Print the right-hand side of the given operation in the generic form.
        -: 2737:  void printGenericOp(Operation *op, bool printOpName) override;
        -: 2738:
        -: 2739:  /// Print the name of the given block.
        -: 2740:  void printBlockName(Block *block);
        -: 2741:
        -: 2742:  /// Print the given block. If 'printBlockArgs' is false, the arguments of the
        -: 2743:  /// block are not printed. If 'printBlockTerminator' is false, the terminator
        -: 2744:  /// operation of the block is not printed.
        -: 2745:  void print(Block *block, bool printBlockArgs = true,
        -: 2746:             bool printBlockTerminator = true);
        -: 2747:
        -: 2748:  /// Print the ID of the given value, optionally with its result number.
        -: 2749:  void printValueID(Value value, bool printResultNo = true,
        -: 2750:                    raw_ostream *streamOverride = nullptr) const;
        -: 2751:
        -: 2752:  /// Print the ID of the given operation.
        -: 2753:  void printOperationID(Operation *op,
        -: 2754:                        raw_ostream *streamOverride = nullptr) const;
        -: 2755:
        -: 2756:  //===--------------------------------------------------------------------===//
        -: 2757:  // OpAsmPrinter methods
        -: 2758:  //===--------------------------------------------------------------------===//
        -: 2759:
        -: 2760:  /// Print a loc(...) specifier if printing debug info is enabled. Locations
        -: 2761:  /// may be deferred with an alias.
function _ZN12_GLOBAL__N_116OperationPrinter30printOptionalLocationSpecifierEN4mlir8LocationE called 0 returned 0% blocks executed 0%
    #####: 2762:  void printOptionalLocationSpecifier(Location loc) override {
    #####: 2763:    printTrailingLocation(loc);
call    0 never executed
    #####: 2764:  }
        -: 2765:
        -: 2766:  /// Print a newline and indent the printer to the start of the current
        -: 2767:  /// operation.
function _ZN12_GLOBAL__N_116OperationPrinter12printNewlineEv called 0 returned 0% blocks executed 0%
    #####: 2768:  void printNewline() override {
    #####: 2769:    os << newLine;
call    0 never executed
    #####: 2770:    os.indent(currentIndent);
call    0 never executed
    #####: 2771:  }
        -: 2772:
        -: 2773:  /// Increase indentation.
function _ZN12_GLOBAL__N_116OperationPrinter14increaseIndentEv called 0 returned 0% blocks executed 0%
    #####: 2774:  void increaseIndent() override { currentIndent += indentWidth; }
        -: 2775:
        -: 2776:  /// Decrease indentation.
function _ZN12_GLOBAL__N_116OperationPrinter14decreaseIndentEv called 0 returned 0% blocks executed 0%
    #####: 2777:  void decreaseIndent() override { currentIndent -= indentWidth; }
        -: 2778:
        -: 2779:  /// Print a block argument in the usual format of:
        -: 2780:  ///   %ssaName : type {attr1=42} loc("here")
        -: 2781:  /// where location printing is controlled by the standard internal option.
        -: 2782:  /// You may pass omitType=true to not print a type, and pass an empty
        -: 2783:  /// attribute list if you don't care for attributes.
        -: 2784:  void printRegionArgument(BlockArgument arg,
        -: 2785:                           ArrayRef<NamedAttribute> argAttrs = {},
        -: 2786:                           bool omitType = false) override;
        -: 2787:
        -: 2788:  /// Print the ID for the given value.
function _ZN12_GLOBAL__N_116OperationPrinter12printOperandEN4mlir5ValueE called 378710 returned 100% blocks executed 100%
  1400130: 2789:  void printOperand(Value value) override { printValueID(value); }
function _ZN12_GLOBAL__N_116OperationPrinter12printOperandEN4mlir5ValueERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 2790:  void printOperand(Value value, raw_ostream &os) override {
    #####: 2791:    printValueID(value, /*printResultNo=*/true, &os);
    #####: 2792:  }
        -: 2793:
        -: 2794:  /// Print an optional attribute dictionary with a given set of elided values.
function _ZN12_GLOBAL__N_116OperationPrinter21printOptionalAttrDictEN4llvm8ArrayRefIN4mlir14NamedAttributeEEENS2_INS1_9StringRefEEE called 540272 returned 100% blocks executed 100%
  2684328: 2795:  void printOptionalAttrDict(ArrayRef<NamedAttribute> attrs,
        -: 2796:                             ArrayRef<StringRef> elidedAttrs = {}) override {
  2684328: 2797:    Impl::printOptionalAttrDict(attrs, elidedAttrs);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   540272: 2798:  }
function _ZN12_GLOBAL__N_116OperationPrinter32printOptionalAttrDictWithKeywordEN4llvm8ArrayRefIN4mlir14NamedAttributeEEENS2_INS1_9StringRefEEE called 340019 returned 100% blocks executed 100%
   340019: 2799:  void printOptionalAttrDictWithKeyword(
        -: 2800:      ArrayRef<NamedAttribute> attrs,
        -: 2801:      ArrayRef<StringRef> elidedAttrs = {}) override {
   340019: 2802:    Impl::printOptionalAttrDict(attrs, elidedAttrs,
call    0 returned 100%
        -: 2803:                                /*withKeyword=*/true);
   340019: 2804:  }
        -: 2805:
        -: 2806:  /// Print the given successor.
        -: 2807:  void printSuccessor(Block *successor) override;
        -: 2808:
        -: 2809:  /// Print an operation successor with the operands used for the block
        -: 2810:  /// arguments.
        -: 2811:  void printSuccessorAndUseList(Block *successor,
        -: 2812:                                ValueRange succOperands) override;
        -: 2813:
        -: 2814:  /// Print the given region.
        -: 2815:  void printRegion(Region &region, bool printEntryBlockArgs,
        -: 2816:                   bool printBlockTerminators, bool printEmptyBlock) override;
        -: 2817:
        -: 2818:  /// Renumber the arguments for the specified region to the same names as the
        -: 2819:  /// SSA values in namesToUse. This may only be used for IsolatedFromAbove
        -: 2820:  /// operations. If any entry in namesToUse is null, the corresponding
        -: 2821:  /// argument name is left alone.
function _ZN12_GLOBAL__N_116OperationPrinter16shadowRegionArgsERN4mlir6RegionENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 2822:  void shadowRegionArgs(Region &region, ValueRange namesToUse) override {
    #####: 2823:    state.getSSANameState().shadowRegionArgs(region, namesToUse);
call    0 never executed
    #####: 2824:  }
        -: 2825:
        -: 2826:  /// Print the given affine map with the symbol and dimension operands printed
        -: 2827:  /// inline with the map.
        -: 2828:  void printAffineMapOfSSAIds(AffineMapAttr mapAttr,
        -: 2829:                              ValueRange operands) override;
        -: 2830:
        -: 2831:  /// Print the given affine expression with the symbol and dimension operands
        -: 2832:  /// printed inline with the expression.
        -: 2833:  void printAffineExprOfSSAIds(AffineExpr expr, ValueRange dimOperands,
        -: 2834:                               ValueRange symOperands) override;
        -: 2835:
        -: 2836:  /// Print users of this operation or id of this operation if it has no result.
        -: 2837:  void printUsersComment(Operation *op);
        -: 2838:
        -: 2839:  /// Print users of this block arg.
        -: 2840:  void printUsersComment(BlockArgument arg);
        -: 2841:
        -: 2842:  /// Print the users of a value.
        -: 2843:  void printValueUsers(Value value);
        -: 2844:
        -: 2845:  /// Print either the ids of the result values or the id of the operation if
        -: 2846:  /// the operation has no results.
        -: 2847:  void printUserIDs(Operation *user, bool prefixComma = false);
        -: 2848:
        -: 2849:private:
        -: 2850:  /// This class represents a resource builder implementation for the MLIR
        -: 2851:  /// textual assembly format.
        -: 2852:  class ResourceBuilder : public AsmResourceBuilder {
        -: 2853:  public:
        -: 2854:    using ValueFn = function_ref<void(raw_ostream &)>;
        -: 2855:    using PrintFn = function_ref<void(StringRef, ValueFn)>;
        -: 2856:
  178568*: 2857:    ResourceBuilder(OperationPrinter &p, PrintFn printFn)
  178568*: 2858:        : p(p), printFn(printFn) {}
call    0 never executed
call    1 returned 100%
call    2 never executed
  178568*: 2859:    ~ResourceBuilder() override = default;
------------------
_ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilderD0Ev:
function _ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilderD0Ev called 0 returned 0% blocks executed 0%
    #####: 2859:    ~ResourceBuilder() override = default;
call    0 never executed
------------------
_ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilderD2Ev:
function _ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilderD2Ev called 0 returned 0% blocks executed 0%
    #####: 2859:    ~ResourceBuilder() override = default;
------------------
        -: 2860:
function _ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilder9buildBoolEN4llvm9StringRefEb called 0 returned 0% blocks executed 0%
    #####: 2861:    void buildBool(StringRef key, bool data) final {
    #####: 2862:      printFn(key, [&](raw_ostream &os) { p.os << (data ? "true" : "false"); });
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 2863:    }
        -: 2864:
function _ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilder11buildStringEN4llvm9StringRefES3_ called 0 returned 0% blocks executed 0%
    #####: 2865:    void buildString(StringRef key, StringRef data) final {
    #####: 2866:      printFn(key, [&](raw_ostream &os) { p.printEscapedString(data); });
call    0 never executed
call    1 never executed
    #####: 2867:    }
        -: 2868:
function _ZN12_GLOBAL__N_116OperationPrinter15ResourceBuilder9buildBlobEN4llvm9StringRefENS2_8ArrayRefIcEEj called 0 returned 0% blocks executed 0%
    #####: 2869:    void buildBlob(StringRef key, ArrayRef<char> data,
        -: 2870:                   uint32_t dataAlignment) final {
function _ZZN12_GLOBAL__N_116OperationPrinter15ResourceBuilder9buildBlobEN4llvm9StringRefENS2_8ArrayRefIcEEjENKUlRNS2_11raw_ostreamEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2871:      printFn(key, [&](raw_ostream &os) {
call    0 never executed
        -: 2872:        // Store the blob in a hex string containing the alignment and the data.
    #####: 2873:        llvm::support::ulittle32_t dataAlignmentLE(dataAlignment);
call    0 never executed
    #####: 2874:        os << "\"0x"
call    0 never executed
call    1 never executed
    #####: 2875:           << llvm::toHex(StringRef(reinterpret_cast<char *>(&dataAlignmentLE),
call    0 never executed
call    1 never executed
    #####: 2876:                                    sizeof(dataAlignment)))
    #####: 2877:           << llvm::toHex(StringRef(data.data(), data.size())) << "\"";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2878:      });
    #####: 2879:    }
        -: 2880:
        -: 2881:  private:
        -: 2882:    OperationPrinter &p;
        -: 2883:    PrintFn printFn;
        -: 2884:  };
        -: 2885:
        -: 2886:  /// Print the metadata dictionary for the file, eliding it if it is empty.
        -: 2887:  void printFileMetadataDictionary(Operation *op);
        -: 2888:
        -: 2889:  /// Print the resource sections for the file metadata dictionary.
        -: 2890:  /// `checkAddMetadataDict` is used to indicate that metadata is going to be
        -: 2891:  /// added, and the file metadata dictionary should be started if it hasn't
        -: 2892:  /// yet.
        -: 2893:  void printResourceFileMetadata(function_ref<void()> checkAddMetadataDict,
        -: 2894:                                 Operation *op);
        -: 2895:
        -: 2896:  // Contains the stack of default dialects to use when printing regions.
        -: 2897:  // A new dialect is pushed to the stack before parsing regions nested under an
        -: 2898:  // operation implementing `OpAsmOpInterface`, and popped when done. At the
        -: 2899:  // top-level we start with "builtin" as the default, so that the top-level
        -: 2900:  // `module` operation prints as-is.
        -: 2901:  SmallVector<StringRef> defaultDialectStack{"builtin"};
        -: 2902:
        -: 2903:  /// The number of spaces used for indenting nested operations.
        -: 2904:  const static unsigned indentWidth = 2;
        -: 2905:
        -: 2906:  // This is the current indentation level for nested structures.
        -: 2907:  unsigned currentIndent = 0;
        -: 2908:};
        -: 2909:} // namespace
        -: 2910:
function _ZN12_GLOBAL__N_116OperationPrinter22printTopLevelOperationEPN4mlir9OperationE called 155501 returned 100% blocks executed 100%
   155501: 2911:void OperationPrinter::printTopLevelOperation(Operation *op) {
        -: 2912:  // Output the aliases at the top level that can't be deferred.
   155501: 2913:  state.getAliasState().printNonDeferredAliases(*this, newLine);
call    0 returned 100%
        -: 2914:
        -: 2915:  // Print the module.
   155501: 2916:  printFullOpWithIndentAndLoc(op);
call    0 returned 100%
   155501: 2917:  os << newLine;
call    0 returned 100%
        -: 2918:
        -: 2919:  // Output the aliases at the top level that can be deferred.
   155501: 2920:  state.getAliasState().printDeferredAliases(*this, newLine);
call    0 returned 100%
        -: 2921:
        -: 2922:  // Output any file level metadata.
   155501: 2923:  printFileMetadataDictionary(op);
call    0 returned 100%
   155501: 2924:}
        -: 2925:
function _ZN12_GLOBAL__N_116OperationPrinter27printFileMetadataDictionaryEPN4mlir9OperationE called 155501 returned 100% blocks executed 50%
   155501: 2926:void OperationPrinter::printFileMetadataDictionary(Operation *op) {
   155501: 2927:  bool sawMetadataEntry = false;
function _ZZN12_GLOBAL__N_116OperationPrinter27printFileMetadataDictionaryEPN4mlir9OperationEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2928:  auto checkAddMetadataDict = [&] {
    #####: 2929:    if (!std::exchange(sawMetadataEntry, true))
branch  0 never executed
branch  1 never executed
    #####: 2930:      os << newLine << "{-#" << newLine;
call    0 never executed
call    1 never executed
call    2 never executed
  155501*: 2931:  };
        -: 2932:
        -: 2933:  // Add the various types of metadata.
   155501: 2934:  printResourceFileMetadata(checkAddMetadataDict, op);
call    0 returned 100%
        -: 2935:
        -: 2936:  // If the file dictionary exists, close it.
   155501: 2937:  if (sawMetadataEntry)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2938:    os << newLine << "#-}" << newLine;
call    0 never executed
call    1 never executed
call    2 never executed
   155501: 2939:}
        -: 2940:
function _ZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationE called 155501 returned 100% blocks executed 64%
   155501: 2941:void OperationPrinter::printResourceFileMetadata(
        -: 2942:    function_ref<void()> checkAddMetadataDict, Operation *op) {
        -: 2943:  // Functor used to add data entries to the file metadata dictionary.
   155501: 2944:  bool hadResource = false;
  334069*: 2945:  auto processProvider = [&](StringRef dictName, StringRef name, auto &provider,
        -: 2946:                             auto &&...providerArgs) {
  178568*: 2947:    bool hadEntry = false;
  178568*: 2948:    auto printFn = [&](StringRef key, ResourceBuilder::ValueFn valueFn) {
  178568*: 2949:      checkAddMetadataDict();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2950:
        -: 2951:      // Emit the top-level resource entry if we haven't yet.
  178568*: 2952:      if (!std::exchange(hadResource, true))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
  178568*: 2953:        os << "  " << dictName << "_resources: {" << newLine;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -: 2954:      // Emit the parent resource entry if we haven't yet.
    #####: 2955:      if (!std::exchange(hadEntry, true))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2956:        os << "    " << name << ": {" << newLine;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -: 2957:      else
    #####: 2958:        os << "," << newLine;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 2959:
    #####: 2960:      os << "      " << key << ": ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 2961:      valueFn(os);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2962:    };
  178568*: 2963:    ResourceBuilder entryBuilder(*this, printFn);
  178568*: 2964:    provider.buildResources(op, providerArgs..., entryBuilder);
        -: 2965:
  178568*: 2966:    if (hadEntry)
    #####: 2967:      os << newLine << "    }";
  334069*: 2968:  };
------------------
_ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_18AsmResourcePrinterEJEEEDaS8_S8_SA_SD_:
function _ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_18AsmResourcePrinterEJEEEDaS8_S8_SA_SD_ called 0 returned 0% blocks executed 0%
    #####: 2945:  auto processProvider = [&](StringRef dictName, StringRef name, auto &provider,
        -: 2946:                             auto &&...providerArgs) {
    #####: 2947:    bool hadEntry = false;
    #####: 2948:    auto printFn = [&](StringRef key, ResourceBuilder::ValueFn valueFn) {
    #####: 2949:      checkAddMetadataDict();
        -: 2950:
        -: 2951:      // Emit the top-level resource entry if we haven't yet.
    #####: 2952:      if (!std::exchange(hadResource, true))
    #####: 2953:        os << "  " << dictName << "_resources: {" << newLine;
        -: 2954:      // Emit the parent resource entry if we haven't yet.
        -: 2955:      if (!std::exchange(hadEntry, true))
        -: 2956:        os << "    " << name << ": {" << newLine;
        -: 2957:      else
        -: 2958:        os << "," << newLine;
        -: 2959:
        -: 2960:      os << "      " << key << ": ";
        -: 2961:      valueFn(os);
        -: 2962:    };
    #####: 2963:    ResourceBuilder entryBuilder(*this, printFn);
call    0 never executed
    #####: 2964:    provider.buildResources(op, providerArgs..., entryBuilder);
call    0 never executed
        -: 2965:
    #####: 2966:    if (hadEntry)
branch  0 never executed
branch  1 never executed
    #####: 2967:      os << newLine << "    }";
call    0 never executed
call    1 never executed
    #####: 2968:  };
------------------
_ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_21OpAsmDialectInterfaceEJNS1_9SetVectorINS5_24AsmDialectResourceHandleESt6vectorISJ_SaISJ_EENS1_8DenseSetISJ_NS1_12DenseMapInfoISJ_vEEEEEEEEEDaS8_S8_SA_SD_:
function _ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_21OpAsmDialectInterfaceEJNS1_9SetVectorINS5_24AsmDialectResourceHandleESt6vectorISJ_SaISJ_EENS1_8DenseSetISJ_NS1_12DenseMapInfoISJ_vEEEEEEEEEDaS8_S8_SA_SD_ called 178568 returned 100% blocks executed 60%
   178568: 2945:  auto processProvider = [&](StringRef dictName, StringRef name, auto &provider,
        -: 2946:                             auto &&...providerArgs) {
   178568: 2947:    bool hadEntry = false;
   178568: 2948:    auto printFn = [&](StringRef key, ResourceBuilder::ValueFn valueFn) {
   178568: 2949:      checkAddMetadataDict();
        -: 2950:
        -: 2951:      // Emit the top-level resource entry if we haven't yet.
   178568: 2952:      if (!std::exchange(hadResource, true))
  178568*: 2953:        os << "  " << dictName << "_resources: {" << newLine;
        -: 2954:      // Emit the parent resource entry if we haven't yet.
        -: 2955:      if (!std::exchange(hadEntry, true))
        -: 2956:        os << "    " << name << ": {" << newLine;
        -: 2957:      else
        -: 2958:        os << "," << newLine;
        -: 2959:
        -: 2960:      os << "      " << key << ": ";
        -: 2961:      valueFn(os);
        -: 2962:    };
   178568: 2963:    ResourceBuilder entryBuilder(*this, printFn);
call    0 returned 100%
   178568: 2964:    provider.buildResources(op, providerArgs..., entryBuilder);
call    0 returned 100%
        -: 2965:
   178568: 2966:    if (hadEntry)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2967:      os << newLine << "    }";
call    0 never executed
call    1 never executed
   178568: 2968:  };
------------------
_ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_21OpAsmDialectInterfaceEJRNS1_9SetVectorINS5_24AsmDialectResourceHandleESt6vectorISJ_SaISJ_EENS1_8DenseSetISJ_NS1_12DenseMapInfoISJ_vEEEEEEEEEDaS8_S8_SA_SD_:
function _ZZN12_GLOBAL__N_116OperationPrinter25printResourceFileMetadataEN4llvm12function_refIFvvEEEPN4mlir9OperationEENKUlNS1_9StringRefES8_RT_DpOT0_E_clIKNS5_21OpAsmDialectInterfaceEJRNS1_9SetVectorINS5_24AsmDialectResourceHandleESt6vectorISJ_SaISJ_EENS1_8DenseSetISJ_NS1_12DenseMapInfoISJ_vEEEEEEEEEDaS8_S8_SA_SD_ called 0 returned 0% blocks executed 0%
    #####: 2945:  auto processProvider = [&](StringRef dictName, StringRef name, auto &provider,
        -: 2946:                             auto &&...providerArgs) {
    #####: 2947:    bool hadEntry = false;
    #####: 2948:    auto printFn = [&](StringRef key, ResourceBuilder::ValueFn valueFn) {
    #####: 2949:      checkAddMetadataDict();
        -: 2950:
        -: 2951:      // Emit the top-level resource entry if we haven't yet.
    #####: 2952:      if (!std::exchange(hadResource, true))
    #####: 2953:        os << "  " << dictName << "_resources: {" << newLine;
        -: 2954:      // Emit the parent resource entry if we haven't yet.
        -: 2955:      if (!std::exchange(hadEntry, true))
        -: 2956:        os << "    " << name << ": {" << newLine;
        -: 2957:      else
        -: 2958:        os << "," << newLine;
        -: 2959:
        -: 2960:      os << "      " << key << ": ";
        -: 2961:      valueFn(os);
        -: 2962:    };
    #####: 2963:    ResourceBuilder entryBuilder(*this, printFn);
call    0 never executed
    #####: 2964:    provider.buildResources(op, providerArgs..., entryBuilder);
call    0 never executed
        -: 2965:
    #####: 2966:    if (hadEntry)
branch  0 never executed
branch  1 never executed
    #####: 2967:      os << newLine << "    }";
call    0 never executed
call    1 never executed
    #####: 2968:  };
------------------
        -: 2969:
        -: 2970:  // Print the `dialect_resources` section if we have any dialects with
        -: 2971:  // resources.
   334069: 2972:  for (const OpAsmDialectInterface &interface : state.getDialectInterfaces()) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
   178568: 2973:    auto &dialectResources = state.getDialectResources();
   178568: 2974:    StringRef name = interface.getDialect()->getNamespace();
call    0 returned 100%
   178568: 2975:    auto it = dialectResources.find(interface.getDialect());
call    0 returned 100%
   178568: 2976:    if (it != dialectResources.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2977:      processProvider("dialect", name, interface, it->second);
call    0 never executed
call    1 never executed
        -: 2978:    else
   178568: 2979:      processProvider("dialect", name, interface,
call    0 returned 100%
   178568: 2980:                      SetVector<AsmDialectResourceHandle>());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2981:  }
   155501: 2982:  if (hadResource)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2983:    os << newLine << "  }";
call    0 never executed
call    1 never executed
        -: 2984:
        -: 2985:  // Print the `external_resources` section if we have any external clients with
        -: 2986:  // resources.
   155501: 2987:  hadResource = false;
  155501*: 2988:  for (const auto &printer : state.getResourcePrinters())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    #####: 2989:    processProvider("external", printer.getName(), printer);
call    0 never executed
   155501: 2990:  if (hadResource)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2991:    os << newLine << "  }";
call    0 never executed
call    1 never executed
   155501: 2992:}
        -: 2993:
        -: 2994:/// Print a block argument in the usual format of:
        -: 2995:///   %ssaName : type {attr1=42} loc("here")
        -: 2996:/// where location printing is controlled by the standard internal option.
        -: 2997:/// You may pass omitType=true to not print a type, and pass an empty
        -: 2998:/// attribute list if you don't care for attributes.
function _ZN12_GLOBAL__N_116OperationPrinter19printRegionArgumentEN4mlir13BlockArgumentEN4llvm8ArrayRefINS1_14NamedAttributeEEEb called 321355 returned 100% blocks executed 100%
   321355: 2999:void OperationPrinter::printRegionArgument(BlockArgument arg,
        -: 3000:                                           ArrayRef<NamedAttribute> argAttrs,
        -: 3001:                                           bool omitType) {
   642710: 3002:  printOperand(arg);
   321355: 3003:  if (!omitType) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   321355: 3004:    os << ": ";
call    0 returned 100%
   321355: 3005:    printType(arg.getType());
call    0 returned 100%
        -: 3006:  }
   321355: 3007:  printOptionalAttrDict(argAttrs);
call    0 returned 100%
        -: 3008:  // TODO: We should allow location aliases on block arguments.
   321355: 3009:  printTrailingLocation(arg.getLoc(), /*allowAlias*/ false);
call    0 returned 100%
   321355: 3010:}
        -: 3011:
function _ZN12_GLOBAL__N_116OperationPrinter27printFullOpWithIndentAndLocEPN4mlir9OperationE called 2337900 returned 100% blocks executed 100%
  2337900: 3012:void OperationPrinter::printFullOpWithIndentAndLoc(Operation *op) {
        -: 3013:  // Track the location of this operation.
  2337900: 3014:  state.registerOperationLocation(op, newLine.curLine, currentIndent);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 3015:
  2337900: 3016:  os.indent(currentIndent);
call    0 returned 100%
  2337899: 3017:  printFullOp(op);
call    0 returned 100%
  2337896: 3018:  printTrailingLocation(op->getLoc());
call    0 returned 100%
  2337896: 3019:  if (printerFlags.shouldPrintValueUsers())
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    17775: 3020:    printUsersComment(op);
call    0 returned 100%
  2337896: 3021:}
        -: 3022:
function _ZN12_GLOBAL__N_116OperationPrinter11printFullOpEPN4mlir9OperationE called 2337899 returned 100% blocks executed 62%
  2337899: 3023:void OperationPrinter::printFullOp(Operation *op) {
  2337899: 3024:  if (size_t numResults = op->getNumResults()) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
function _ZZN12_GLOBAL__N_116OperationPrinter11printFullOpEPN4mlir9OperationEENKUlmmE_clEmm.isra.0 called 1813583 returned 100% blocks executed 55%
  1813583: 3025:    auto printResultGroup = [&](size_t resultNo, size_t resultCount) {
 1813583*: 3026:      printValueID(op->getResult(resultNo), /*printResultNo=*/false);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1813583: 3027:      if (resultCount > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3028:        os << ':' << resultCount;
branch  0 never executed
branch  1 never executed
call    2 never executed
  3627161: 3029:    };
        -: 3030:
        -: 3031:    // Check to see if this operation has multiple result groups.
  1813578: 3032:    ArrayRef<int> resultGroups = state.getSSANameState().getOpResultGroups(op);
call    0 returned 100%
  1813578: 3033:    if (!resultGroups.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3034:      // Interleave the groups excluding the last one, this one will be handled
        -: 3035:      // separately.
function _ZZN12_GLOBAL__N_116OperationPrinter11printFullOpEPN4mlir9OperationEENKUliE0_clEi.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3036:      interleaveComma(llvm::seq<int>(0, resultGroups.size() - 1), [&](int i) {
call    0 never executed
call    1 never executed
    #####: 3037:        printResultGroup(resultGroups[i],
    #####: 3038:                         resultGroups[i + 1] - resultGroups[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3039:      });
    #####: 3040:      os << ", ";
call    0 never executed
    #####: 3041:      printResultGroup(resultGroups.back(), numResults - resultGroups.back());
call    0 never executed
call    1 never executed
        -: 3042:
        -: 3043:    } else {
  1813578: 3044:      printResultGroup(/*resultNo=*/0, /*resultCount=*/numResults);
call    0 returned 100%
        -: 3045:    }
        -: 3046:
  1813578: 3047:    os << " = ";
call    0 returned 100%
        -: 3048:  }
        -: 3049:
  2337899: 3050:  printCustomOrGenericOp(op);
call    0 returned 100%
  2337896: 3051:}
        -: 3052:
function _ZN12_GLOBAL__N_116OperationPrinter17printUsersCommentEPN4mlir9OperationE called 17775 returned 100% blocks executed 98%
    17775: 3053:void OperationPrinter::printUsersComment(Operation *op) {
    17775: 3054:  unsigned numResults = op->getNumResults();
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
    19026: 3055:  if (!numResults && op->getNumOperands()) {
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
     1240: 3056:    os << " // id: ";
call    0 returned 100%
    19015: 3057:    printOperationID(op);
    30400: 3058:  } else if (numResults && op->use_empty()) {
branch  0 taken 84%
branch  1 taken 16%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
      712: 3059:    os << " // unused";
call    0 returned 100%
    28976: 3060:  } else if (numResults && !op->use_empty()) {
branch  0 taken 83%
branch  1 taken 17%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3061:    // Print "user" if the operation has one result used to compute one other
        -: 3062:    // result, or is used in one operation with no result.
    13153: 3063:    unsigned usedInNResults = 0;
    13153: 3064:    unsigned usedInNOperations = 0;
    26306: 3065:    SmallPtrSet<Operation *, 1> userSet;
call    0 returned 100%
    43595: 3066:    for (Operation *user : op->getUsers()) {
call    0 returned 100%
branch  1 taken 54% (fallthrough)
branch  2 taken 46%
call    3 returned 100%
    15221: 3067:      if (userSet.insert(user).second) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
    15174: 3068:        ++usedInNOperations;
    15174: 3069:        usedInNResults += user->getNumResults();
        -: 3070:      }
        -: 3071:    }
        -: 3072:
        -: 3073:    // We already know that users is not empty.
    26306: 3074:    bool exactlyOneUniqueUse =
    13153: 3075:        usedInNResults <= 1 && usedInNOperations <= 1 && numResults == 1;
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    14803: 3076:    os << " // " << (exactlyOneUniqueUse ? "user" : "users") << ": ";
call    0 returned 100%
branch  1 taken 13% (fallthrough)
branch  2 taken 87%
call    3 returned 100%
call    4 returned 100%
    13153: 3077:    bool shouldPrintBrackets = numResults > 1;
function _ZZN12_GLOBAL__N_116OperationPrinter17printUsersCommentEPN4mlir9OperationEENKUlNS1_8OpResultEE_clES4_.isra.0 called 13153 returned 100% blocks executed 71%
    13153: 3078:    auto printOpResult = [&](OpResult opResult) {
    13153: 3079:      if (shouldPrintBrackets)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3080:        os << "(";
call    0 never executed
    13153: 3081:      printValueUsers(opResult);
call    0 returned 100%
    13153: 3082:      if (shouldPrintBrackets)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3083:        os << ")";
call    0 never executed
    26306: 3084:    };
        -: 3085:
    26306: 3086:    interleaveComma(op->getResults(), printOpResult);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 13% (fallthrough)
branch  4 taken 87%
        -: 3087:  }
    17775: 3088:}
        -: 3089:
function _ZN12_GLOBAL__N_116OperationPrinter17printUsersCommentEN4mlir13BlockArgumentE called 2311 returned 100% blocks executed 100%
     2311: 3090:void OperationPrinter::printUsersComment(BlockArgument arg) {
     2311: 3091:  os << "// ";
call    0 returned 100%
     4622: 3092:  printValueID(arg);
     2311: 3093:  if (arg.use_empty()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       19: 3094:    os << " is unused";
call    0 returned 100%
        -: 3095:  } else {
     2292: 3096:    os << " is used by ";
call    0 returned 100%
     2292: 3097:    printValueUsers(arg);
call    0 returned 100%
        -: 3098:  }
     2311: 3099:  os << newLine;
call    0 returned 100%
     2311: 3100:}
        -: 3101:
function _ZN12_GLOBAL__N_116OperationPrinter15printValueUsersEN4mlir5ValueE called 15445 returned 100% blocks executed 92%
    15445: 3102:void OperationPrinter::printValueUsers(Value value) {
    15445: 3103:  if (value.use_empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3104:    os << "unused";
call    0 never executed
        -: 3105:
        -: 3106:  // One value might be used as the operand of an operation more than once.
        -: 3107:  // Only print the operations results once in that case.
    15445: 3108:  SmallPtrSet<Operation *, 1> userSet;
call    0 returned 100%
    33972: 3109:  for (auto &indexedUser : enumerate(value.getUsers())) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
call    2 returned 100%
    18527: 3110:    if (userSet.insert(indexedUser.value()).second)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
    18480: 3111:      printUserIDs(indexedUser.value(), indexedUser.index());
call    0 returned 100%
        -: 3112:  }
    15445: 3113:}
        -: 3114:
function _ZN12_GLOBAL__N_116OperationPrinter12printUserIDsEPN4mlir9OperationEb called 18480 returned 100% blocks executed 100%
    18480: 3115:void OperationPrinter::printUserIDs(Operation *user, bool prefixComma) {
    18480: 3116:  if (prefixComma)
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
     3035: 3117:    os << ", ";
call    0 returned 100%
        -: 3118:
    18480: 3119:  if (!user->getNumResults()) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
    21608: 3120:    printOperationID(user);
        -: 3121:  } else {
    15352: 3122:    interleaveComma(user->getResults(),
call    0 returned 100%
   15352*: 3123:                    [this](Value result) { printValueID(result); });
        -: 3124:  }
    18480: 3125:}
        -: 3126:
function _ZN12_GLOBAL__N_116OperationPrinter22printCustomOrGenericOpEPN4mlir9OperationE called 2337898 returned 100% blocks executed 25%
  2337898: 3127:void OperationPrinter::printCustomOrGenericOp(Operation *op) {
        -: 3128:  // If requested, always print the generic form.
  2337898: 3129:  if (!printerFlags.shouldPrintGenericOpForm()) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 3130:    // Check to see if this is a known operation. If so, use the registered
        -: 3131:    // custom printer hook.
  4294566: 3132:    if (auto opInfo = op->getRegisteredInfo()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  2147283: 3133:      opInfo->printAssembly(op, *this, defaultDialectStack.back());
call    0 returned 100%
call    1 returned 100%
  2147283: 3134:      return;
        -: 3135:    }
        -: 3136:    // Otherwise try to dispatch to the dialect, if available.
    #####: 3137:    if (Dialect *dialect = op->getDialect()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3138:      if (auto opPrinter = dialect->getOperationPrinter(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3139:        // Print the op name first.
    #####: 3140:        StringRef name = op->getName().getStringRef();
call    0 never executed
        -: 3141:        // Only drop the default dialect prefix when it cannot lead to
        -: 3142:        // ambiguities.
    #####: 3143:        if (name.count('.') == 1)
branch  0 never executed
branch  1 never executed
    #####: 3144:          name.consume_front((defaultDialectStack.back() + ".").str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3145:        os << name;
call    0 never executed
        -: 3146:
        -: 3147:        // Print the rest of the op now.
    #####: 3148:        opPrinter(op, *this);
call    0 never executed
    #####: 3149:        return;
call    0 never executed
        -: 3150:      }
        -: 3151:    }
        -: 3152:  }
        -: 3153:
        -: 3154:  // Otherwise print with the generic assembly form.
   190615: 3155:  printGenericOp(op, /*printOpName=*/true);
call    0 returned 100%
        -: 3156:}
        -: 3157:
function _ZN12_GLOBAL__N_116OperationPrinter14printGenericOpEPN4mlir9OperationEb called 1822702 returned 100% blocks executed 76%
  1822702: 3158:void OperationPrinter::printGenericOp(Operation *op, bool printOpName) {
  1822702: 3159:  if (printOpName)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1822702: 3160:    printEscapedString(op->getName().getStringRef());
call    0 returned 100%
call    1 returned 100%
  1822696: 3161:  os << '(';
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
  3921017: 3162:  interleaveComma(op->getOperands(), [&](Value value) { printValueID(value); });
call    0 returned 100%
call    1 returned 100%
  1822696: 3163:  os << ')';
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -: 3164:
        -: 3165:  // For terminators, print the list of successors and their operands.
  1822695: 3166:  if (op->getNumSuccessors() != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3167:    os << '[';
branch  0 never executed
branch  1 never executed
    #####: 3168:    interleaveComma(op->getSuccessors(),
call    0 never executed
call    1 never executed
function _ZZN12_GLOBAL__N_116OperationPrinter14printGenericOpEPN4mlir9OperationEbENKUlPNS1_5BlockEE0_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 3169:                    [&](Block *successor) { printBlockName(successor); });
    #####: 3170:    os << ']';
branch  0 never executed
branch  1 never executed
        -: 3171:  }
        -: 3172:
        -: 3173:  // Print regions.
  1822695: 3174:  if (op->getNumRegions() != 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    10756: 3175:    os << " (";
call    0 returned 100%
   21520*: 3176:    interleaveComma(op->getRegions(), [&](Region &region) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
   10760*: 3177:      printRegion(region, /*printEntryBlockArgs=*/true,
call    0 returned 100%
call    1 never executed
        -: 3178:                  /*printBlockTerminators=*/true, /*printEmptyBlock=*/true);
        -: 3179:    });
    10762: 3180:    os << ')';
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 3181:  }
        -: 3182:
  1822701: 3183:  auto attrs = op->getAttrs();
call    0 returned 100%
  1822701: 3184:  printOptionalAttrDict(attrs);
call    0 returned 100%
        -: 3185:
        -: 3186:  // Print the type signature of the operation.
  1822703: 3187:  os << " : ";
call    0 returned 100%
  1822701: 3188:  printFunctionalType(op);
call    0 returned 100%
  1822700: 3189:}
        -: 3190:
   12378*: 3191:void OperationPrinter::printBlockName(Block *block) {
   12378*: 3192:  os << state.getSSANameState().getBlockInfo(block).name;
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 never executed
    #####: 3193:}
        -: 3194:
function _ZN12_GLOBAL__N_116OperationPrinter5printEPN4mlir5BlockEbb called 328854 returned 100% blocks executed 62%
   328854: 3195:void OperationPrinter::print(Block *block, bool printBlockArgs,
        -: 3196:                             bool printBlockTerminator) {
        -: 3197:  // Print the block label and argument list if requested.
   328854: 3198:  if (printBlockArgs) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     6855: 3199:    os.indent(currentIndent);
call    0 returned 100%
     6855: 3200:    printBlockName(block);
call    0 returned 100%
        -: 3201:
        -: 3202:    // Print the argument list if non-empty.
     6855: 3203:    if (!block->args_empty()) {
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
     5981: 3204:      os << '(';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
function _ZZN12_GLOBAL__N_116OperationPrinter5printEPN4mlir5BlockEbbENKUlNS1_13BlockArgumentEE_clES4_.isra.0 called 11909 returned 100% blocks executed 100%
    17890: 3205:      interleaveComma(block->getArguments(), [&](BlockArgument arg) {
call    0 returned 100%
    47636: 3206:        printValueID(arg);
    11909: 3207:        os << ": ";
call    0 returned 100%
    11909: 3208:        printType(arg.getType());
call    0 returned 100%
        -: 3209:        // TODO: We should allow location aliases on block arguments.
    11909: 3210:        printTrailingLocation(arg.getLoc(), /*allowAlias*/ false);
call    0 returned 100%
    11909: 3211:      });
     5981: 3212:      os << ')';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3213:    }
     6855: 3214:    os << ':';
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
        -: 3215:
        -: 3216:    // Print out some context information about the predecessors of this block.
     6855: 3217:    if (!block->getParent()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3218:      os << "  // block is not in a region!";
call    0 never executed
     6855: 3219:    } else if (block->hasNoPredecessors()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     6855: 3220:      if (!block->isEntryBlock())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3221:        os << "  // no predecessors";
call    0 never executed
    #####: 3222:    } else if (auto *pred = block->getSinglePredecessor()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3223:      os << "  // pred: ";
call    0 never executed
    #####: 3224:      printBlockName(pred);
call    0 never executed
        -: 3225:    } else {
        -: 3226:      // We want to print the predecessors in a stable order, not in
        -: 3227:      // whatever order the use-list is in, so gather and sort them.
    #####: 3228:      SmallVector<BlockInfo, 4> predIDs;
    #####: 3229:      for (auto *pred : block->getPredecessors())
branch  0 never executed
branch  1 never executed
    #####: 3230:        predIDs.push_back(state.getSSANameState().getBlockInfo(pred));
call    0 never executed
call    1 never executed
    #####: 3231:      llvm::sort(predIDs, [](BlockInfo lhs, BlockInfo rhs) {
call    0 never executed
        -: 3232:        return lhs.ordering < rhs.ordering;
        -: 3233:      });
        -: 3234:
    #####: 3235:      os << "  // " << predIDs.size() << " preds: ";
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3236:
    #####: 3237:      interleaveComma(predIDs, [&](BlockInfo pred) { os << pred.name; });
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 3238:    }
     6855: 3239:    os << newLine;
call    0 returned 100%
        -: 3240:  }
        -: 3241:
   328854: 3242:  currentIndent += indentWidth;
        -: 3243:
   328854: 3244:  if (printerFlags.shouldPrintValueUsers()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     4557: 3245:    for (BlockArgument arg : block->getArguments()) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
     2311: 3246:      os.indent(currentIndent);
call    0 returned 100%
     2311: 3247:      printUsersComment(arg);
call    0 returned 100%
        -: 3248:    }
        -: 3249:  }
        -: 3250:
   328854: 3251:  bool hasTerminator =
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   655981: 3252:      !block->empty() && block->back().hasTrait<OpTrait::IsTerminator>();
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
call    2 returned 100%
branch  3 taken 49% (fallthrough)
branch  4 taken 51%
   328854: 3253:  auto range = llvm::make_range(
        -: 3254:      block->begin(),
        -: 3255:      std::prev(block->end(),
   657708: 3256:                (!hasTerminator || printBlockTerminator) ? 0 : 1));
  2381794: 3257:  for (auto &op : range) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
  2052940: 3258:    printFullOpWithIndentAndLoc(&op);
call    0 returned 100%
  2052940: 3259:    os << newLine;
call    0 returned 100%
        -: 3260:  }
   328854: 3261:  currentIndent -= indentWidth;
   328854: 3262:}
        -: 3263:
 4641540*: 3264:void OperationPrinter::printValueID(Value value, bool printResultNo,
        -: 3265:                                    raw_ostream *streamOverride) const {
 4641540*: 3266:  state.getSSANameState().printValueID(value, printResultNo,
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 never executed
call    6 returned 100%
call    7 returned 100%
call    8 never executed
call    9 returned 100%
        -: 3267:                                       streamOverride ? *streamOverride : os);
        -: 3268:}
        -: 3269:
     4368: 3270:void OperationPrinter::printOperationID(Operation *op,
        -: 3271:                                        raw_ostream *streamOverride) const {
     4368: 3272:  state.getSSANameState().printOperationID(op, streamOverride ? *streamOverride
call    0 returned 100%
call    1 returned 100%
        -: 3273:                                                              : os);
     4368: 3274:}
        -: 3275:
function _ZN12_GLOBAL__N_116OperationPrinter14printSuccessorEPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####: 3276:void OperationPrinter::printSuccessor(Block *successor) {
    #####: 3277:  printBlockName(successor);
call    0 never executed
    #####: 3278:}
        -: 3279:
function _ZN12_GLOBAL__N_116OperationPrinter24printSuccessorAndUseListEPN4mlir5BlockENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 3280:void OperationPrinter::printSuccessorAndUseList(Block *successor,
        -: 3281:                                                ValueRange succOperands) {
    #####: 3282:  printBlockName(successor);
call    0 never executed
    #####: 3283:  if (succOperands.empty())
branch  0 never executed
branch  1 never executed
        -: 3284:    return;
        -: 3285:
    #####: 3286:  os << '(';
branch  0 never executed
branch  1 never executed
    #####: 3287:  interleaveComma(succOperands,
call    0 never executed
    #####: 3288:                  [this](Value operand) { printValueID(operand); });
call    0 never executed
call    1 never executed
    #####: 3289:  os << " : ";
call    0 never executed
    #####: 3290:  interleaveComma(succOperands,
call    0 never executed
    #####: 3291:                  [this](Value operand) { printType(operand.getType()); });
call    0 never executed
call    1 never executed
    #####: 3292:  os << ')';
branch  0 never executed
branch  1 never executed
        -: 3293:}
        -: 3294:
function _ZN12_GLOBAL__N_116OperationPrinter11printRegionERN4mlir6RegionEbbb called 330209 returned 100% blocks executed 86%
   330209: 3295:void OperationPrinter::printRegion(Region &region, bool printEntryBlockArgs,
        -: 3296:                                   bool printBlockTerminators,
        -: 3297:                                   bool printEmptyBlock) {
   330209: 3298:  os << "{" << newLine;
call    0 returned 100%
call    1 returned 100%
   330209: 3299:  if (!region.empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   328854: 3300:    auto restoreDefaultDialect =
   657708: 3301:        llvm::make_scope_exit([&]() { defaultDialectStack.pop_back(); });
call    0 returned 100%
call    1 returned 100%
   328854: 3302:    if (auto iface = dyn_cast<OpAsmOpInterface>(region.getParentOp()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   327762: 3303:      defaultDialectStack.push_back(iface.getDefaultDialect());
call    0 returned 100%
call    1 returned 100%
        -: 3304:    else
     1092: 3305:      defaultDialectStack.push_back("");
call    0 returned 100%
        -: 3306:
   328854: 3307:    auto *entryBlock = &region.front();
call    0 returned 100%
        -: 3308:    // Force printing the block header if printEmptyBlock is set and the block
        -: 3309:    // is empty or if printEntryBlockArgs is set and there are arguments to
        -: 3310:    // print.
   328854: 3311:    bool shouldAlwaysPrintBlockHeader =
   328854: 3312:        (printEmptyBlock && entryBlock->empty()) ||
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
branch  2 taken 91% (fallthrough)
branch  3 taken 9%
branch  4 taken 51% (fallthrough)
branch  5 taken 49%
   165908: 3313:        (printEntryBlockArgs && entryBlock->getNumArguments() != 0);
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   328854: 3314:    print(entryBlock, shouldAlwaysPrintBlockHeader, printBlockTerminators);
call    0 returned 100%
  657708*: 3315:    for (auto &b : llvm::drop_begin(region.getBlocks(), 1))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 3316:      print(&b);
call    0 never executed
        -: 3317:  }
   330209: 3318:  os.indent(currentIndent) << "}";
call    0 returned 100%
call    1 returned 100%
   330211: 3319:}
        -: 3320:
function _ZN12_GLOBAL__N_116OperationPrinter22printAffineMapOfSSAIdsEN4mlir13AffineMapAttrENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 3321:void OperationPrinter::printAffineMapOfSSAIds(AffineMapAttr mapAttr,
        -: 3322:                                              ValueRange operands) {
    #####: 3323:  AffineMap map = mapAttr.getValue();
call    0 never executed
    #####: 3324:  unsigned numDims = map.getNumDims();
call    0 never executed
function _ZZN12_GLOBAL__N_116OperationPrinter22printAffineMapOfSSAIdsEN4mlir13AffineMapAttrENS1_10ValueRangeEENKUljbE_clEjb called 0 returned 0% blocks executed 0%
    #####: 3325:  auto printValueName = [&](unsigned pos, bool isSymbol) {
    #####: 3326:    unsigned index = isSymbol ? numDims + pos : pos;
branch  0 never executed
branch  1 never executed
    #####: 3327:    assert(index < operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3328:    if (isSymbol)
branch  0 never executed
branch  1 never executed
    #####: 3329:      os << "symbol(";
call    0 never executed
    #####: 3330:    printValueID(operands[index]);
call    0 never executed
call    1 never executed
    #####: 3331:    if (isSymbol)
branch  0 never executed
branch  1 never executed
    #####: 3332:      os << ')';
branch  0 never executed
branch  1 never executed
    #####: 3333:  };
        -: 3334:
    #####: 3335:  interleaveComma(map.getResults(), [&](AffineExpr expr) {
call    0 never executed
call    1 never executed
    #####: 3336:    printAffineExpr(expr, printValueName);
call    0 never executed
call    1 never executed
        -: 3337:  });
    #####: 3338:}
        -: 3339:
function _ZN12_GLOBAL__N_116OperationPrinter23printAffineExprOfSSAIdsEN4mlir10AffineExprENS1_10ValueRangeES3_ called 0 returned 0% blocks executed 0%
    #####: 3340:void OperationPrinter::printAffineExprOfSSAIds(AffineExpr expr,
        -: 3341:                                               ValueRange dimOperands,
        -: 3342:                                               ValueRange symOperands) {
function _ZZN12_GLOBAL__N_116OperationPrinter23printAffineExprOfSSAIdsEN4mlir10AffineExprENS1_10ValueRangeES3_ENKUljbE_clEjb called 0 returned 0% blocks executed 0%
    #####: 3343:  auto printValueName = [&](unsigned pos, bool isSymbol) {
    #####: 3344:    if (!isSymbol)
branch  0 never executed
branch  1 never executed
    #####: 3345:      return printValueID(dimOperands[pos]);
call    0 never executed
call    1 never executed
    #####: 3346:    os << "symbol(";
call    0 never executed
    #####: 3347:    printValueID(symOperands[pos]);
call    0 never executed
call    1 never executed
    #####: 3348:    os << ')';
branch  0 never executed
branch  1 never executed
    #####: 3349:  };
    #####: 3350:  printAffineExpr(expr, printValueName);
call    0 never executed
    #####: 3351:}
        -: 3352:
        -: 3353://===----------------------------------------------------------------------===//
        -: 3354:// print and dump methods
        -: 3355://===----------------------------------------------------------------------===//
        -: 3356:
function _ZNK4mlir9Attribute5printERN4llvm11raw_ostreamEb called 23893 returned 100% blocks executed 100%
    23893: 3357:void Attribute::print(raw_ostream &os, bool elideType) const {
    23893: 3358:  if (!*this) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
     2588: 3359:    os << "<<NULL ATTRIBUTE>>";
call    0 returned 100%
     2588: 3360:    return;
        -: 3361:  }
        -: 3362:
    42610: 3363:  AsmState state(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    21305: 3364:  print(os, state, elideType);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 3365:}
function _ZNK4mlir9Attribute5printERN4llvm11raw_ostreamERNS_8AsmStateEb called 21320 returned 100% blocks executed 100%
    21320: 3366:void Attribute::print(raw_ostream &os, AsmState &state, bool elideType) const {
    21320: 3367:  using AttrTypeElision = AsmPrinter::Impl::AttrTypeElision;
    21320: 3368:  AsmPrinter::Impl(os, state.getImpl())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    42640: 3369:      .printAttribute(*this, elideType ? AttrTypeElision::Must
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 3370:                                       : AttrTypeElision::Never);
    21320: 3371:}
        -: 3372:
function _ZNK4mlir9Attribute4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3373:void Attribute::dump() const {
    #####: 3374:  print(llvm::errs());
call    0 never executed
call    1 never executed
    #####: 3375:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3376:}
        -: 3377:
function _ZNK4mlir4Type5printERN4llvm11raw_ostreamE called 10363 returned 100% blocks executed 89%
    10363: 3378:void Type::print(raw_ostream &os) const {
    10363: 3379:  if (!*this) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3380:    os << "<<NULL TYPE>>";
    #####: 3381:    return;
call    0 never executed
        -: 3382:  }
        -: 3383:
    20726: 3384:  AsmState state(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    20726: 3385:  print(os, state);
        -: 3386:}
function _ZNK4mlir4Type5printERN4llvm11raw_ostreamERNS_8AsmStateE called 39 returned 100% blocks executed 100%
    10402: 3387:void Type::print(raw_ostream &os, AsmState &state) const {
    10402: 3388:  AsmPrinter::Impl(os, state.getImpl()).printType(*this);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       39: 3389:}
        -: 3390:
function _ZNK4mlir4Type4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3391:void Type::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -: 3392:
function _ZNK4mlir9AffineMap4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3393:void AffineMap::dump() const {
    #####: 3394:  print(llvm::errs());
call    0 never executed
call    1 never executed
    #####: 3395:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3396:}
        -: 3397:
function _ZNK4mlir10IntegerSet4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3398:void IntegerSet::dump() const {
    #####: 3399:  print(llvm::errs());
call    0 never executed
call    1 never executed
    #####: 3400:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3401:}
        -: 3402:
function _ZNK4mlir10AffineExpr5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 3403:void AffineExpr::print(raw_ostream &os) const {
    #####: 3404:  if (!expr) {
branch  0 never executed
branch  1 never executed
    #####: 3405:    os << "<<NULL AFFINE EXPR>>";
    #####: 3406:    return;
call    0 never executed
        -: 3407:  }
    #####: 3408:  AsmState state(getContext());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3409:  AsmPrinter::Impl(os, state.getImpl()).printAffineExpr(*this);
call    0 never executed
call    1 never executed
        -: 3410:}
        -: 3411:
function _ZNK4mlir10AffineExpr4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3412:void AffineExpr::dump() const {
    #####: 3413:  print(llvm::errs());
call    0 never executed
call    1 never executed
    #####: 3414:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3415:}
        -: 3416:
function _ZNK4mlir9AffineMap5printERN4llvm11raw_ostreamE called 24 returned 100% blocks executed 89%
       24: 3417:void AffineMap::print(raw_ostream &os) const {
       24: 3418:  if (!map) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3419:    os << "<<NULL AFFINE MAP>>";
    #####: 3420:    return;
call    0 never executed
        -: 3421:  }
       48: 3422:  AsmState state(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       24: 3423:  AsmPrinter::Impl(os, state.getImpl()).printAffineMap(*this);
call    0 returned 100%
call    1 returned 100%
        -: 3424:}
        -: 3425:
function _ZNK4mlir10IntegerSet5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 3426:void IntegerSet::print(raw_ostream &os) const {
    #####: 3427:  AsmState state(getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3428:  AsmPrinter::Impl(os, state.getImpl()).printIntegerSet(*this);
call    0 never executed
call    1 never executed
    #####: 3429:}
        -: 3430:
function _ZN4mlir5Value5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 3431:void Value::print(raw_ostream &os) { print(os, OpPrintingFlags()); }
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN4mlir5Value5printERN4llvm11raw_ostreamERKNS_15OpPrintingFlagsE called 0 returned 0% blocks executed 0%
    #####: 3432:void Value::print(raw_ostream &os, const OpPrintingFlags &flags) {
    #####: 3433:  if (!impl) {
branch  0 never executed
branch  1 never executed
    #####: 3434:    os << "<<NULL VALUE>>";
    #####: 3435:    return;
call    0 never executed
        -: 3436:  }
        -: 3437:
    #####: 3438:  if (auto *op = getDefiningOp())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3439:    return op->print(os, flags);
call    0 never executed
        -: 3440:  // TODO: Improve BlockArgument print'ing.
    #####: 3441:  BlockArgument arg = this->cast<BlockArgument>();
call    0 never executed
    #####: 3442:  os << "<block argument> of type '" << arg.getType()
call    0 never executed
call    1 never executed
    #####: 3443:     << "' at index: " << arg.getArgNumber();
call    0 never executed
call    1 never executed
        -: 3444:}
function _ZN4mlir5Value5printERN4llvm11raw_ostreamERNS_8AsmStateE called 0 returned 0% blocks executed 0%
    #####: 3445:void Value::print(raw_ostream &os, AsmState &state) {
    #####: 3446:  if (!impl) {
branch  0 never executed
branch  1 never executed
    #####: 3447:    os << "<<NULL VALUE>>";
    #####: 3448:    return;
call    0 never executed
        -: 3449:  }
        -: 3450:
    #####: 3451:  if (auto *op = getDefiningOp())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3452:    return op->print(os, state);
call    0 never executed
        -: 3453:
        -: 3454:  // TODO: Improve BlockArgument print'ing.
    #####: 3455:  BlockArgument arg = this->cast<BlockArgument>();
call    0 never executed
    #####: 3456:  os << "<block argument> of type '" << arg.getType()
call    0 never executed
call    1 never executed
    #####: 3457:     << "' at index: " << arg.getArgNumber();
call    0 never executed
call    1 never executed
        -: 3458:}
        -: 3459:
function _ZN4mlir5Value4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3460:void Value::dump() {
    #####: 3461:  print(llvm::errs());
call    0 never executed
call    1 never executed
    #####: 3462:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3463:}
        -: 3464:
function _ZN4mlir5Value14printAsOperandERN4llvm11raw_ostreamERNS_8AsmStateE called 0 returned 0% blocks executed 0%
    #####: 3465:void Value::printAsOperand(raw_ostream &os, AsmState &state) {
        -: 3466:  // TODO: This doesn't necessarily capture all potential cases.
        -: 3467:  // Currently, region arguments can be shadowed when printing the main
        -: 3468:  // operation. If the IR hasn't been printed, this will produce the old SSA
        -: 3469:  // name and not the shadowed name.
    #####: 3470:  state.getImpl().getSSANameState().printValueID(*this, /*printResultNo=*/true,
call    0 never executed
        -: 3471:                                                 os);
    #####: 3472:}
        -: 3473:
function _ZN4mlir9Operation5printERN4llvm11raw_ostreamERKNS_15OpPrintingFlagsE called 132431 returned 100% blocks executed 100%
   132431: 3474:void Operation::print(raw_ostream &os, const OpPrintingFlags &printerFlags) {
        -: 3475:  // Find the operation to number from based upon the provided flags.
   132431: 3476:  Operation *op = this;
   132431: 3477:  bool shouldUseLocalScope = printerFlags.shouldUseLocalScope();
   247792: 3478:  do {
        -: 3479:    // If we are printing local scope, stop at the first operation that is
        -: 3480:    // isolated from above.
   491761: 3481:    if (shouldUseLocalScope && op->hasTrait<OpTrait::IsIsolatedFromAbove>())
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 47% (fallthrough)
branch  3 taken 53%
        -: 3482:      break;
        -: 3483:
        -: 3484:    // Otherwise, traverse up to the next parent.
   119176: 3485:    Operation *parentOp = op->getParentOp();
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
   115361: 3486:    if (!parentOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3487:      break;
        -: 3488:    op = parentOp;
        -: 3489:  } while (true);
        -: 3490:
   132423: 3491:  AsmState state(op, printerFlags);
call    0 returned 100%
   132436: 3492:  print(os, state);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   132435: 3493:}
function _ZN4mlir9Operation5printERN4llvm11raw_ostreamERNS_8AsmStateE called 284962 returned 100% blocks executed 89%
   284962: 3494:void Operation::print(raw_ostream &os, AsmState &state) {
   284962: 3495:  OperationPrinter printer(os, state.getImpl());
call    0 returned 100%
   284960: 3496:  if (!getParent() && !state.getPrinterFlags().shouldUseLocalScope()) {
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
   155501: 3497:    state.getImpl().initializeAliases(this);
call    0 returned 100%
   155501: 3498:    printer.printTopLevelOperation(this);
call    0 returned 100%
        -: 3499:  } else {
   129459: 3500:    printer.printFullOpWithIndentAndLoc(this);
call    0 returned 100%
        -: 3501:  }
   284956: 3502:}
        -: 3503:
function _ZN4mlir9Operation4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3504:void Operation::dump() {
    #####: 3505:  print(llvm::errs(), OpPrintingFlags().useLocalScope());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3506:  llvm::errs() << "\n";
call    0 never executed
call    1 never executed
    #####: 3507:}
        -: 3508:
function _ZN4mlir5Block5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 3509:void Block::print(raw_ostream &os) {
    #####: 3510:  Operation *parentOp = getParentOp();
call    0 never executed
    #####: 3511:  if (!parentOp) {
branch  0 never executed
branch  1 never executed
    #####: 3512:    os << "<<UNLINKED BLOCK>>\n";
call    0 never executed
    #####: 3513:    return;
        -: 3514:  }
        -: 3515:  // Get the top-level op.
    #####: 3516:  while (auto *nextOp = parentOp->getParentOp())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3517:    parentOp = nextOp;
        -: 3518:
    #####: 3519:  AsmState state(parentOp);
call    0 never executed
call    1 never executed
    #####: 3520:  print(os, state);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3521:}
function _ZN4mlir5Block5printERN4llvm11raw_ostreamERNS_8AsmStateE called 0 returned 0% blocks executed 0%
    #####: 3522:void Block::print(raw_ostream &os, AsmState &state) {
    #####: 3523:  OperationPrinter(os, state.getImpl()).print(this);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3524:}
        -: 3525:
function _ZN4mlir5Block4dumpEv called 0 returned 0% blocks executed 0%
    #####: 3526:void Block::dump() { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -: 3527:
        -: 3528:/// Print out the name of the block without printing its body.
function _ZN4mlir5Block14printAsOperandERN4llvm11raw_ostreamEb called 5523 returned 100% blocks executed 82%
     5523: 3529:void Block::printAsOperand(raw_ostream &os, bool printType) {
     5523: 3530:  Operation *parentOp = getParentOp();
call    0 returned 100%
     5523: 3531:  if (!parentOp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3532:    os << "<<UNLINKED BLOCK>>\n";
call    0 never executed
    #####: 3533:    return;
        -: 3534:  }
    11046: 3535:  AsmState state(parentOp);
call    0 returned 100%
call    1 returned 100%
     5523: 3536:  printAsOperand(os, state);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 3537:}
function _ZN4mlir5Block14printAsOperandERN4llvm11raw_ostreamERNS_8AsmStateE called 5523 returned 100% blocks executed 83%
     5523: 3538:void Block::printAsOperand(raw_ostream &os, AsmState &state) {
     5523: 3539:  OperationPrinter printer(os, state.getImpl());
call    0 returned 100%
    11046: 3540:  printer.printBlockName(this);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     5523: 3541:}
