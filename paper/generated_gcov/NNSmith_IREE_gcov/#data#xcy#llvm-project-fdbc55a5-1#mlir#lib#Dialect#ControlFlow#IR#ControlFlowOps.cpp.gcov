        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/ControlFlow/IR/ControlFlowOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/ControlFlow/IR/CMakeFiles/obj.MLIRControlFlowDialect.dir/ControlFlowOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/ControlFlow/IR/CMakeFiles/obj.MLIRControlFlowDialect.dir/ControlFlowOps.cpp.gcda
        -:    0:Runs:325546
        -:    1://===- ControlFlowOps.cpp - ControlFlow Operations ------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
        -:   10:
        -:   11:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   12:#include "mlir/Dialect/CommonFolders.h"
        -:   13:#include "mlir/IR/AffineExpr.h"
        -:   14:#include "mlir/IR/AffineMap.h"
        -:   15:#include "mlir/IR/BlockAndValueMapping.h"
        -:   16:#include "mlir/IR/Builders.h"
        -:   17:#include "mlir/IR/BuiltinOps.h"
        -:   18:#include "mlir/IR/BuiltinTypes.h"
        -:   19:#include "mlir/IR/Matchers.h"
        -:   20:#include "mlir/IR/OpImplementation.h"
        -:   21:#include "mlir/IR/PatternMatch.h"
        -:   22:#include "mlir/IR/TypeUtilities.h"
        -:   23:#include "mlir/IR/Value.h"
        -:   24:#include "mlir/Support/MathExtras.h"
        -:   25:#include "mlir/Transforms/InliningUtils.h"
        -:   26:#include "llvm/ADT/APFloat.h"
        -:   27:#include "llvm/ADT/STLExtras.h"
        -:   28:#include "llvm/Support/FormatVariadic.h"
        -:   29:#include "llvm/Support/raw_ostream.h"
        -:   30:#include <numeric>
        -:   31:
        -:   32:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOpsDialect.cpp.inc"
        -:   33:
        -:   34:using namespace mlir;
        -:   35:using namespace mlir::cf;
        -:   36:
        -:   37://===----------------------------------------------------------------------===//
        -:   38:// ControlFlowDialect Interfaces
        -:   39://===----------------------------------------------------------------------===//
        -:   40:namespace {
        -:   41:/// This class defines the interface for handling inlining with control flow
        -:   42:/// operations.
        -:   43:struct ControlFlowInlinerInterface : public DialectInlinerInterface {
        -:   44:  using DialectInlinerInterface::DialectInlinerInterface;
  261714*:   45:  ~ControlFlowInlinerInterface() override = default;
------------------
_ZN12_GLOBAL__N_127ControlFlowInlinerInterfaceD0Ev:
function _ZN12_GLOBAL__N_127ControlFlowInlinerInterfaceD0Ev called 261714 returned 100% blocks executed 100%
   261714:   45:  ~ControlFlowInlinerInterface() override = default;
call    0 returned 100%
call    1 returned 100%
------------------
_ZN12_GLOBAL__N_127ControlFlowInlinerInterfaceD2Ev:
function _ZN12_GLOBAL__N_127ControlFlowInlinerInterfaceD2Ev called 0 returned 0% blocks executed 0%
    #####:   45:  ~ControlFlowInlinerInterface() override = default;
call    0 never executed
------------------
        -:   46:
        -:   47:  /// All control flow operations can be inlined.
function _ZNK12_GLOBAL__N_127ControlFlowInlinerInterface15isLegalToInlineEPN4mlir9OperationES3_b called 0 returned 0% blocks executed 0%
    #####:   48:  bool isLegalToInline(Operation *call, Operation *callable,
        -:   49:                       bool wouldBeCloned) const final {
    #####:   50:    return true;
        -:   51:  }
function _ZNK12_GLOBAL__N_127ControlFlowInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:   52:  bool isLegalToInline(Operation *, Region *, bool,
        -:   53:                       BlockAndValueMapping &) const final {
    #####:   54:    return true;
        -:   55:  }
        -:   56:
        -:   57:  /// ControlFlow terminator operations don't really need any special handing.
function _ZNK12_GLOBAL__N_127ControlFlowInlinerInterface16handleTerminatorEPN4mlir9OperationEPNS1_5BlockE called 0 returned 0% blocks executed 0%
    #####:   58:  void handleTerminator(Operation *op, Block *newDest) const final {}
        -:   59:};
        -:   60:} // namespace
        -:   61:
        -:   62://===----------------------------------------------------------------------===//
        -:   63:// ControlFlowDialect
        -:   64://===----------------------------------------------------------------------===//
        -:   65:
function _ZN4mlir2cf18ControlFlowDialect10initializeEv called 0 returned 0% blocks executed 0%
  262096*:   66:void ControlFlowDialect::initialize() {
  262096*:   67:  addOperations<
        -:   68:#define GET_OP_LIST
        -:   69:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.cpp.inc"
  262096*:   70:      >();
call    0 never executed
call    1 returned 100%
  262096*:   71:  addInterfaces<ControlFlowInlinerInterface>();
call    0 never executed
call    1 returned 100%
    #####:   72:}
        -:   73:
        -:   74://===----------------------------------------------------------------------===//
        -:   75:// AssertOp
        -:   76://===----------------------------------------------------------------------===//
        -:   77:
function _ZN4mlir2cf8AssertOp12canonicalizeES1_RNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   78:LogicalResult AssertOp::canonicalize(AssertOp op, PatternRewriter &rewriter) {
        -:   79:  // Erase assertion if argument is constant true.
    #####:   80:  if (matchPattern(op.getArg(), m_One())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   81:    rewriter.eraseOp(op);
call    0 never executed
    #####:   82:    return success();
        -:   83:  }
    #####:   84:  return failure();
        -:   85:}
        -:   86:
        -:   87://===----------------------------------------------------------------------===//
        -:   88:// BranchOp
        -:   89://===----------------------------------------------------------------------===//
        -:   90:
        -:   91:/// Given a successor, try to collapse it to a new destination if it only
        -:   92:/// contains a passthrough unconditional branch. If the successor is
        -:   93:/// collapsable, `successor` and `successorOperands` are updated to reference
        -:   94:/// the new destination and values. `argStorage` is used as storage if operands
        -:   95:/// to the collapsed successor need to be remapped. It must outlive uses of
        -:   96:/// successorOperands.
function _ZL14collapseBranchRPN4mlir5BlockERNS_10ValueRangeERN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:   97:static LogicalResult collapseBranch(Block *&successor,
        -:   98:                                    ValueRange &successorOperands,
        -:   99:                                    SmallVectorImpl<Value> &argStorage) {
        -:  100:  // Check that the successor only contains a unconditional branch.
    #####:  101:  if (std::next(successor->begin()) != successor->end())
branch  0 never executed
branch  1 never executed
    #####:  102:    return failure();
        -:  103:  // Check that the terminator is an unconditional branch.
    #####:  104:  BranchOp successorBranch = dyn_cast<BranchOp>(successor->getTerminator());
call    0 never executed
call    1 never executed
    #####:  105:  if (!successorBranch)
branch  0 never executed
branch  1 never executed
    #####:  106:    return failure();
        -:  107:  // Check that the arguments are only used within the terminator.
    #####:  108:  for (BlockArgument arg : successor->getArguments()) {
branch  0 never executed
branch  1 never executed
    #####:  109:    for (Operation *user : arg.getUsers())
branch  0 never executed
branch  1 never executed
    #####:  110:      if (user != successorBranch)
branch  0 never executed
branch  1 never executed
    #####:  111:        return failure();
        -:  112:  }
        -:  113:  // Don't try to collapse branches to infinite loops.
    #####:  114:  Block *successorDest = successorBranch.getDest();
call    0 never executed
    #####:  115:  if (successorDest == successor)
branch  0 never executed
branch  1 never executed
    #####:  116:    return failure();
        -:  117:
        -:  118:  // Update the operands to the successor. If the branch parent has no
        -:  119:  // arguments, we can use the branch operands directly.
    #####:  120:  OperandRange operands = successorBranch.getOperands();
call    0 never executed
    #####:  121:  if (successor->args_empty()) {
branch  0 never executed
branch  1 never executed
    #####:  122:    successor = successorDest;
    #####:  123:    successorOperands = operands;
call    0 never executed
    #####:  124:    return success();
        -:  125:  }
        -:  126:
        -:  127:  // Otherwise, we need to remap any argument operands.
    #####:  128:  for (Value operand : operands) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  129:    BlockArgument argOperand = operand.dyn_cast<BlockArgument>();
call    0 never executed
    #####:  130:    if (argOperand && argOperand.getOwner() == successor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  131:      argStorage.push_back(successorOperands[argOperand.getArgNumber()]);
call    0 never executed
call    1 never executed
        -:  132:    else
    #####:  133:      argStorage.push_back(operand);
call    0 never executed
        -:  134:  }
    #####:  135:  successor = successorDest;
    #####:  136:  successorOperands = argStorage;
call    0 never executed
    #####:  137:  return success();
        -:  138:}
        -:  139:
        -:  140:/// Simplify a branch to a block that has a single predecessor. This effectively
        -:  141:/// merges the two blocks.
        -:  142:static LogicalResult
function _ZL31simplifyBrToBlockWithSinglePredN4mlir2cf8BranchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  143:simplifyBrToBlockWithSinglePred(BranchOp op, PatternRewriter &rewriter) {
        -:  144:  // Check that the successor block has a single predecessor.
    #####:  145:  Block *succ = op.getDest();
call    0 never executed
    #####:  146:  Block *opParent = op->getBlock();
branch  0 never executed
branch  1 never executed
    #####:  147:  if (succ == opParent || !llvm::hasSingleElement(succ->getPredecessors()))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  148:    return failure();
        -:  149:
        -:  150:  // Merge the successor into the current block and erase the branch.
    #####:  151:  rewriter.mergeBlocks(succ, opParent, op.getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  152:  rewriter.eraseOp(op);
call    0 never executed
    #####:  153:  return success();
        -:  154:}
        -:  155:
        -:  156:///   br ^bb1
        -:  157:/// ^bb1
        -:  158:///   br ^bbN(...)
        -:  159:///
        -:  160:///  -> br ^bbN(...)
        -:  161:///
function _ZL21simplifyPassThroughBrN4mlir2cf8BranchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  162:static LogicalResult simplifyPassThroughBr(BranchOp op,
        -:  163:                                           PatternRewriter &rewriter) {
    #####:  164:  Block *dest = op.getDest();
call    0 never executed
    #####:  165:  ValueRange destOperands = op.getOperands();
call    0 never executed
call    1 never executed
    #####:  166:  SmallVector<Value, 4> destOperandStorage;
branch  0 never executed
branch  1 never executed
        -:  167:
        -:  168:  // Try to collapse the successor if it points somewhere other than this
        -:  169:  // block.
    #####:  170:  if (dest == op->getBlock() ||
branch  0 never executed
branch  1 never executed
    #####:  171:      failed(collapseBranch(dest, destOperands, destOperandStorage)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  172:    return failure();
        -:  173:
        -:  174:  // Create a new branch with the collapsed successor.
    #####:  175:  rewriter.replaceOpWithNewOp<BranchOp>(op, dest, destOperands);
call    0 never executed
    #####:  176:  return success();
branch  0 never executed
branch  1 never executed
        -:  177:}
        -:  178:
function _ZN4mlir2cf8BranchOp12canonicalizeES1_RNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  179:LogicalResult BranchOp::canonicalize(BranchOp op, PatternRewriter &rewriter) {
    #####:  180:  return success(succeeded(simplifyBrToBlockWithSinglePred(op, rewriter)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  181:                 succeeded(simplifyPassThroughBr(op, rewriter)));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  182:}
        -:  183:
function _ZN4mlir2cf8BranchOp7setDestEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####:  184:void BranchOp::setDest(Block *block) { return setSuccessor(block); }
call    0 never executed
        -:  185:
function _ZN4mlir2cf8BranchOp12eraseOperandEj called 0 returned 0% blocks executed 0%
    #####:  186:void BranchOp::eraseOperand(unsigned index) { (*this)->eraseOperand(index); }
call    0 never executed
        -:  187:
function _ZN4mlir2cf8BranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  188:SuccessorOperands BranchOp::getSuccessorOperands(unsigned index) {
    #####:  189:  assert(index == 0 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  190:  return SuccessorOperands(getDestOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  191:}
        -:  192:
function _ZN4mlir2cf8BranchOp23getSuccessorForOperandsEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  193:Block *BranchOp::getSuccessorForOperands(ArrayRef<Attribute>) {
    #####:  194:  return getDest();
call    0 never executed
call    1 never executed
        -:  195:}
        -:  196:
        -:  197://===----------------------------------------------------------------------===//
        -:  198:// CondBranchOp
        -:  199://===----------------------------------------------------------------------===//
        -:  200:
        -:  201:namespace {
        -:  202:/// cf.cond_br true, ^bb1, ^bb2
        -:  203:///  -> br ^bb1
        -:  204:/// cf.cond_br false, ^bb1, ^bb2
        -:  205:///  -> br ^bb2
        -:  206:///
        -:  207:struct SimplifyConstCondBranchPred : public OpRewritePattern<CondBranchOp> {
        -:  208:  using OpRewritePattern<CondBranchOp>::OpRewritePattern;
        -:  209:
function _ZNK12_GLOBAL__N_127SimplifyConstCondBranchPred15matchAndRewriteEN4mlir2cf12CondBranchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  210:  LogicalResult matchAndRewrite(CondBranchOp condbr,
        -:  211:                                PatternRewriter &rewriter) const override {
    #####:  212:    if (matchPattern(condbr.getCondition(), m_NonZero())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  213:      // True branch taken.
    #####:  214:      rewriter.replaceOpWithNewOp<BranchOp>(condbr, condbr.getTrueDest(),
    #####:  215:                                            condbr.getTrueOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  216:      return success();
        -:  217:    }
    #####:  218:    if (matchPattern(condbr.getCondition(), m_Zero())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  219:      // False branch taken.
    #####:  220:      rewriter.replaceOpWithNewOp<BranchOp>(condbr, condbr.getFalseDest(),
    #####:  221:                                            condbr.getFalseOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  222:      return success();
        -:  223:    }
    #####:  224:    return failure();
        -:  225:  }
        -:  226:};
        -:  227:
        -:  228:///   cf.cond_br %cond, ^bb1, ^bb2
        -:  229:/// ^bb1
        -:  230:///   br ^bbN(...)
        -:  231:/// ^bb2
        -:  232:///   br ^bbK(...)
        -:  233:///
        -:  234:///  -> cf.cond_br %cond, ^bbN(...), ^bbK(...)
        -:  235:///
        -:  236:struct SimplifyPassThroughCondBranch : public OpRewritePattern<CondBranchOp> {
        -:  237:  using OpRewritePattern<CondBranchOp>::OpRewritePattern;
        -:  238:
function _ZNK12_GLOBAL__N_129SimplifyPassThroughCondBranch15matchAndRewriteEN4mlir2cf12CondBranchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  239:  LogicalResult matchAndRewrite(CondBranchOp condbr,
        -:  240:                                PatternRewriter &rewriter) const override {
    #####:  241:    Block *trueDest = condbr.getTrueDest(), *falseDest = condbr.getFalseDest();
call    0 never executed
call    1 never executed
    #####:  242:    ValueRange trueDestOperands = condbr.getTrueOperands();
call    0 never executed
call    1 never executed
    #####:  243:    ValueRange falseDestOperands = condbr.getFalseOperands();
call    0 never executed
call    1 never executed
    #####:  244:    SmallVector<Value, 4> trueDestOperandStorage, falseDestOperandStorage;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  245:
        -:  246:    // Try to collapse one of the current successors.
    #####:  247:    LogicalResult collapsedTrue =
    #####:  248:        collapseBranch(trueDest, trueDestOperands, trueDestOperandStorage);
call    0 never executed
    #####:  249:    LogicalResult collapsedFalse =
    #####:  250:        collapseBranch(falseDest, falseDestOperands, falseDestOperandStorage);
call    0 never executed
    #####:  251:    if (failed(collapsedTrue) && failed(collapsedFalse))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  252:      return failure();
        -:  253:
        -:  254:    // Create a new branch with the collapsed successors.
    #####:  255:    rewriter.replaceOpWithNewOp<CondBranchOp>(condbr, condbr.getCondition(),
        -:  256:                                              trueDest, trueDestOperands,
    #####:  257:                                              falseDest, falseDestOperands);
call    0 never executed
call    1 never executed
    #####:  258:    return success();
branch  0 never executed
branch  1 never executed
        -:  259:  }
        -:  260:};
        -:  261:
        -:  262:/// cf.cond_br %cond, ^bb1(A, ..., N), ^bb1(A, ..., N)
        -:  263:///  -> br ^bb1(A, ..., N)
        -:  264:///
        -:  265:/// cf.cond_br %cond, ^bb1(A), ^bb1(B)
        -:  266:///  -> %select = arith.select %cond, A, B
        -:  267:///     br ^bb1(%select)
        -:  268:///
        -:  269:struct SimplifyCondBranchIdenticalSuccessors
        -:  270:    : public OpRewritePattern<CondBranchOp> {
        -:  271:  using OpRewritePattern<CondBranchOp>::OpRewritePattern;
        -:  272:
function _ZNK12_GLOBAL__N_137SimplifyCondBranchIdenticalSuccessors15matchAndRewriteEN4mlir2cf12CondBranchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  273:  LogicalResult matchAndRewrite(CondBranchOp condbr,
        -:  274:                                PatternRewriter &rewriter) const override {
        -:  275:    // Check that the true and false destinations are the same and have the same
        -:  276:    // operands.
    #####:  277:    Block *trueDest = condbr.getTrueDest();
call    0 never executed
    #####:  278:    if (trueDest != condbr.getFalseDest())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  279:      return failure();
        -:  280:
        -:  281:    // If all of the operands match, no selects need to be generated.
    #####:  282:    OperandRange trueOperands = condbr.getTrueOperands();
call    0 never executed
    #####:  283:    OperandRange falseOperands = condbr.getFalseOperands();
call    0 never executed
    #####:  284:    if (trueOperands == falseOperands) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  285:      rewriter.replaceOpWithNewOp<BranchOp>(condbr, trueDest, trueOperands);
call    0 never executed
    #####:  286:      return success();
        -:  287:    }
        -:  288:
        -:  289:    // Otherwise, if the current block is the only predecessor insert selects
        -:  290:    // for any mismatched branch operands.
    #####:  291:    if (trueDest->getUniquePredecessor() != condbr->getBlock())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  292:      return failure();
        -:  293:
        -:  294:    // Generate a select for any operands that differ between the two.
    #####:  295:    SmallVector<Value, 8> mergedOperands;
branch  0 never executed
branch  1 never executed
    #####:  296:    mergedOperands.reserve(trueOperands.size());
branch  0 never executed
branch  1 never executed
    #####:  297:    Value condition = condbr.getCondition();
call    0 never executed
    #####:  298:    for (auto it : llvm::zip(trueOperands, falseOperands)) {
branch  0 never executed
branch  1 never executed
    #####:  299:      if (std::get<0>(it) == std::get<1>(it))
branch  0 never executed
branch  1 never executed
    #####:  300:        mergedOperands.push_back(std::get<0>(it));
call    0 never executed
        -:  301:      else
    #####:  302:        mergedOperands.push_back(rewriter.create<arith::SelectOp>(
call    0 never executed
    #####:  303:            condbr.getLoc(), condition, std::get<0>(it), std::get<1>(it)));
call    0 never executed
call    1 never executed
        -:  304:    }
        -:  305:
    #####:  306:    rewriter.replaceOpWithNewOp<BranchOp>(condbr, trueDest, mergedOperands);
call    0 never executed
    #####:  307:    return success();
branch  0 never executed
branch  1 never executed
        -:  308:  }
        -:  309:};
        -:  310:
        -:  311:///   ...
        -:  312:///   cf.cond_br %cond, ^bb1(...), ^bb2(...)
        -:  313:/// ...
        -:  314:/// ^bb1: // has single predecessor
        -:  315:///   ...
        -:  316:///   cf.cond_br %cond, ^bb3(...), ^bb4(...)
        -:  317:///
        -:  318:/// ->
        -:  319:///
        -:  320:///   ...
        -:  321:///   cf.cond_br %cond, ^bb1(...), ^bb2(...)
        -:  322:/// ...
        -:  323:/// ^bb1: // has single predecessor
        -:  324:///   ...
        -:  325:///   br ^bb3(...)
        -:  326:///
        -:  327:struct SimplifyCondBranchFromCondBranchOnSameCondition
        -:  328:    : public OpRewritePattern<CondBranchOp> {
        -:  329:  using OpRewritePattern<CondBranchOp>::OpRewritePattern;
        -:  330:
function _ZNK12_GLOBAL__N_147SimplifyCondBranchFromCondBranchOnSameCondition15matchAndRewriteEN4mlir2cf12CondBranchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  331:  LogicalResult matchAndRewrite(CondBranchOp condbr,
        -:  332:                                PatternRewriter &rewriter) const override {
        -:  333:    // Check that we have a single distinct predecessor.
    #####:  334:    Block *currentBlock = condbr->getBlock();
call    0 never executed
    #####:  335:    Block *predecessor = currentBlock->getSinglePredecessor();
call    0 never executed
    #####:  336:    if (!predecessor)
branch  0 never executed
branch  1 never executed
    #####:  337:      return failure();
        -:  338:
        -:  339:    // Check that the predecessor terminates with a conditional branch to this
        -:  340:    // block and that it branches on the same condition.
    #####:  341:    auto predBranch = dyn_cast<CondBranchOp>(predecessor->getTerminator());
call    0 never executed
call    1 never executed
    #####:  342:    if (!predBranch || condbr.getCondition() != predBranch.getCondition())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  343:      return failure();
        -:  344:
        -:  345:    // Fold this branch to an unconditional branch.
    #####:  346:    if (currentBlock == predBranch.getTrueDest())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:      rewriter.replaceOpWithNewOp<BranchOp>(condbr, condbr.getTrueDest(),
    #####:  348:                                            condbr.getTrueDestOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  349:    else
    #####:  350:      rewriter.replaceOpWithNewOp<BranchOp>(condbr, condbr.getFalseDest(),
    #####:  351:                                            condbr.getFalseDestOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  352:    return success();
        -:  353:  }
        -:  354:};
        -:  355:
        -:  356:///   cf.cond_br %arg0, ^trueB, ^falseB
        -:  357:///
        -:  358:/// ^trueB:
        -:  359:///   "test.consumer1"(%arg0) : (i1) -> ()
        -:  360:///    ...
        -:  361:///
        -:  362:/// ^falseB:
        -:  363:///   "test.consumer2"(%arg0) : (i1) -> ()
        -:  364:///   ...
        -:  365:///
        -:  366:/// ->
        -:  367:///
        -:  368:///   cf.cond_br %arg0, ^trueB, ^falseB
        -:  369:/// ^trueB:
        -:  370:///   "test.consumer1"(%true) : (i1) -> ()
        -:  371:///   ...
        -:  372:///
        -:  373:/// ^falseB:
        -:  374:///   "test.consumer2"(%false) : (i1) -> ()
        -:  375:///   ...
        -:  376:struct CondBranchTruthPropagation : public OpRewritePattern<CondBranchOp> {
        -:  377:  using OpRewritePattern<CondBranchOp>::OpRewritePattern;
        -:  378:
function _ZNK12_GLOBAL__N_126CondBranchTruthPropagation15matchAndRewriteEN4mlir2cf12CondBranchOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  379:  LogicalResult matchAndRewrite(CondBranchOp condbr,
        -:  380:                                PatternRewriter &rewriter) const override {
        -:  381:    // Check that we have a single distinct predecessor.
    #####:  382:    bool replaced = false;
    #####:  383:    Type ty = rewriter.getI1Type();
call    0 never executed
        -:  384:
        -:  385:    // These variables serve to prevent creating duplicate constants
        -:  386:    // and hold constant true or false values.
    #####:  387:    Value constantTrue = nullptr;
    #####:  388:    Value constantFalse = nullptr;
        -:  389:
        -:  390:    // TODO These checks can be expanded to encompas any use with only
        -:  391:    // either the true of false edge as a predecessor. For now, we fall
        -:  392:    // back to checking the single predecessor is given by the true/fasle
        -:  393:    // destination, thereby ensuring that only that edge can reach the
        -:  394:    // op.
    #####:  395:    if (condbr.getTrueDest()->getSinglePredecessor()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  396:      for (OpOperand &use :
branch  0 never executed
branch  1 never executed
    #####:  397:           llvm::make_early_inc_range(condbr.getCondition().getUses())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  398:        if (use.getOwner()->getBlock() == condbr.getTrueDest()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  399:          replaced = true;
        -:  400:
    #####:  401:          if (!constantTrue)
branch  0 never executed
branch  1 never executed
    #####:  402:            constantTrue = rewriter.create<arith::ConstantOp>(
    #####:  403:                condbr.getLoc(), ty, rewriter.getBoolAttr(true));
call    0 never executed
call    1 never executed
        -:  404:
    #####:  405:          rewriter.updateRootInPlace(use.getOwner(),
call    0 never executed
    #####:  406:                                     [&] { use.set(constantTrue); });
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  407:        }
        -:  408:      }
        -:  409:    }
    #####:  410:    if (condbr.getFalseDest()->getSinglePredecessor()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  411:      for (OpOperand &use :
branch  0 never executed
branch  1 never executed
    #####:  412:           llvm::make_early_inc_range(condbr.getCondition().getUses())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  413:        if (use.getOwner()->getBlock() == condbr.getFalseDest()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  414:          replaced = true;
        -:  415:
    #####:  416:          if (!constantFalse)
branch  0 never executed
branch  1 never executed
    #####:  417:            constantFalse = rewriter.create<arith::ConstantOp>(
    #####:  418:                condbr.getLoc(), ty, rewriter.getBoolAttr(false));
call    0 never executed
call    1 never executed
        -:  419:
    #####:  420:          rewriter.updateRootInPlace(use.getOwner(),
call    0 never executed
    #####:  421:                                     [&] { use.set(constantFalse); });
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  422:        }
        -:  423:      }
        -:  424:    }
    #####:  425:    return success(replaced);
        -:  426:  }
        -:  427:};
        -:  428:} // namespace
        -:  429:
function _ZN4mlir2cf12CondBranchOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3709 returned 100% blocks executed 100%
     3709:  430:void CondBranchOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  431:                                               MLIRContext *context) {
     3709:  432:  results.add<SimplifyConstCondBranchPred, SimplifyPassThroughCondBranch,
        -:  433:              SimplifyCondBranchIdenticalSuccessors,
        -:  434:              SimplifyCondBranchFromCondBranchOnSameCondition,
     3709:  435:              CondBranchTruthPropagation>(context);
call    0 returned 100%
     3711:  436:}
        -:  437:
function _ZN4mlir2cf12CondBranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  438:SuccessorOperands CondBranchOp::getSuccessorOperands(unsigned index) {
    #####:  439:  assert(index < getNumSuccessors() && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  440:  return SuccessorOperands(index == trueIndex ? getTrueDestOperandsMutable()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  441:                                              : getFalseDestOperandsMutable());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  442:}
        -:  443:
function _ZN4mlir2cf12CondBranchOp23getSuccessorForOperandsEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  444:Block *CondBranchOp::getSuccessorForOperands(ArrayRef<Attribute> operands) {
    #####:  445:  if (IntegerAttr condAttr = operands.front().dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  446:    return condAttr.getValue().isOneValue() ? getTrueDest() : getFalseDest();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  447:  return nullptr;
        -:  448:}
        -:  449:
        -:  450://===----------------------------------------------------------------------===//
        -:  451:// SwitchOp
        -:  452://===----------------------------------------------------------------------===//
        -:  453:
function _ZN4mlir2cf8SwitchOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEPNS_5BlockENS_10ValueRangeENS_20DenseIntElementsAttrENS_10BlockRangeEN4llvm8ArrayRefIS9_EE called 0 returned 0% blocks executed 0%
    #####:  454:void SwitchOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  455:                     Block *defaultDestination, ValueRange defaultOperands,
        -:  456:                     DenseIntElementsAttr caseValues,
        -:  457:                     BlockRange caseDestinations,
        -:  458:                     ArrayRef<ValueRange> caseOperands) {
    #####:  459:  build(builder, result, value, defaultOperands, caseOperands, caseValues,
call    0 never executed
call    1 never executed
        -:  460:        defaultDestination, caseDestinations);
    #####:  461:}
        -:  462:
function _ZN4mlir2cf8SwitchOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEPNS_5BlockENS_10ValueRangeEN4llvm8ArrayRefINSA_5APIntEEENS_10BlockRangeENSB_IS9_EE called 0 returned 0% blocks executed 0%
    #####:  463:void SwitchOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  464:                     Block *defaultDestination, ValueRange defaultOperands,
        -:  465:                     ArrayRef<APInt> caseValues, BlockRange caseDestinations,
        -:  466:                     ArrayRef<ValueRange> caseOperands) {
    #####:  467:  DenseIntElementsAttr caseValuesAttr;
    #####:  468:  if (!caseValues.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  469:    ShapedType caseValueType = VectorType::get(
    #####:  470:        static_cast<int64_t>(caseValues.size()), value.getType());
call    0 never executed
call    1 never executed
    #####:  471:    caseValuesAttr = DenseIntElementsAttr::get(caseValueType, caseValues);
call    0 never executed
        -:  472:  }
    #####:  473:  build(builder, result, value, defaultDestination, defaultOperands,
call    0 never executed
        -:  474:        caseValuesAttr, caseDestinations, caseOperands);
    #####:  475:}
        -:  476:
function _ZN4mlir2cf8SwitchOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEPNS_5BlockENS_10ValueRangeEN4llvm8ArrayRefIiEENS_10BlockRangeENSB_IS9_EE called 0 returned 0% blocks executed 0%
    #####:  477:void SwitchOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  478:                     Block *defaultDestination, ValueRange defaultOperands,
        -:  479:                     ArrayRef<int32_t> caseValues, BlockRange caseDestinations,
        -:  480:                     ArrayRef<ValueRange> caseOperands) {
    #####:  481:  DenseIntElementsAttr caseValuesAttr;
    #####:  482:  if (!caseValues.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  483:    ShapedType caseValueType = VectorType::get(
    #####:  484:        static_cast<int64_t>(caseValues.size()), value.getType());
call    0 never executed
call    1 never executed
    #####:  485:    caseValuesAttr = DenseIntElementsAttr::get(caseValueType, caseValues);
call    0 never executed
        -:  486:  }
    #####:  487:  build(builder, result, value, defaultDestination, defaultOperands,
call    0 never executed
        -:  488:        caseValuesAttr, caseDestinations, caseOperands);
    #####:  489:}
        -:  490:
        -:  491:/// <cases> ::= `default` `:` bb-id (`(` ssa-use-and-type-list `)`)?
        -:  492:///             ( `,` integer `:` bb-id (`(` ssa-use-and-type-list `)`)? )*
function _ZL18parseSwitchOpCasesRN4mlir11OpAsmParserERNS_4TypeERPNS_5BlockERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS8_IS2_EERNS_20DenseIntElementsAttrERNS8_IS5_EERNS8_INS7_11SmallVectorIS9_Lj1EEEEERNS8_INSI_IS2_Lj6EEEEE called 0 returned 0% blocks executed 0%
    #####:  493:static ParseResult parseSwitchOpCases(
        -:  494:    OpAsmParser &parser, Type &flagType, Block *&defaultDestination,
        -:  495:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &defaultOperands,
        -:  496:    SmallVectorImpl<Type> &defaultOperandTypes,
        -:  497:    DenseIntElementsAttr &caseValues,
        -:  498:    SmallVectorImpl<Block *> &caseDestinations,
        -:  499:    SmallVectorImpl<SmallVector<OpAsmParser::UnresolvedOperand>> &caseOperands,
        -:  500:    SmallVectorImpl<SmallVector<Type>> &caseOperandTypes) {
    #####:  501:  if (parser.parseKeyword("default") || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  502:      parser.parseSuccessor(defaultDestination))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  503:    return failure();
    #####:  504:  if (succeeded(parser.parseOptionalLParen())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  505:    if (parser.parseOperandList(defaultOperands, OpAsmParser::Delimiter::None,
    #####:  506:                                /*allowResultNumber=*/false) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  507:        parser.parseColonTypeList(defaultOperandTypes) || parser.parseRParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  508:      return failure();
        -:  509:  }
        -:  510:
    #####:  511:  SmallVector<APInt> values;
call    0 never executed
call    1 never executed
    #####:  512:  unsigned bitWidth = flagType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  513:  while (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  514:    int64_t value = 0;
    #####:  515:    if (failed(parser.parseInteger(value)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  516:      return failure();
    #####:  517:    values.push_back(APInt(bitWidth, value));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  518:
    #####:  519:    Block *destination;
    #####:  520:    SmallVector<OpAsmParser::UnresolvedOperand> operands;
call    0 never executed
    #####:  521:    SmallVector<Type> operandTypes;
branch  0 never executed
branch  1 never executed
    #####:  522:    if (failed(parser.parseColon()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  523:        failed(parser.parseSuccessor(destination)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  524:      return failure();
    #####:  525:    if (succeeded(parser.parseOptionalLParen())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  526:      if (failed(parser.parseOperandList(operands, OpAsmParser::Delimiter::None,
    #####:  527:                                         /*allowResultNumber=*/false)) ||
call    0 never executed
    #####:  528:          failed(parser.parseColonTypeList(operandTypes)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  529:          failed(parser.parseRParen()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  530:        return failure();
        -:  531:    }
    #####:  532:    caseDestinations.push_back(destination);
call    0 never executed
    #####:  533:    caseOperands.emplace_back(operands);
call    0 never executed
    #####:  534:    caseOperandTypes.emplace_back(operandTypes);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  535:  }
        -:  536:
    #####:  537:  if (!values.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  538:    ShapedType caseValueType =
    #####:  539:        VectorType::get(static_cast<int64_t>(values.size()), flagType);
call    0 never executed
call    1 never executed
    #####:  540:    caseValues = DenseIntElementsAttr::get(caseValueType, values);
call    0 never executed
        -:  541:  }
    #####:  542:  return success();
        -:  543:}
        -:  544:
        -:  545:static void printSwitchOpCases(
        -:  546:    OpAsmPrinter &p, SwitchOp op, Type flagType, Block *defaultDestination,
        -:  547:    OperandRange defaultOperands, TypeRange defaultOperandTypes,
        -:  548:    DenseIntElementsAttr caseValues, SuccessorRange caseDestinations,
        -:  549:    OperandRangeRange caseOperands, const TypeRangeRange &caseOperandTypes) {
        -:  550:  p << "  default: ";
        -:  551:  p.printSuccessorAndUseList(defaultDestination, defaultOperands);
        -:  552:
        -:  553:  if (!caseValues)
        -:  554:    return;
        -:  555:
        -:  556:  for (const auto &it : llvm::enumerate(caseValues.getValues<APInt>())) {
        -:  557:    p << ',';
        -:  558:    p.printNewline();
        -:  559:    p << "  ";
        -:  560:    p << it.value().getLimitedValue();
        -:  561:    p << ": ";
        -:  562:    p.printSuccessorAndUseList(caseDestinations[it.index()],
        -:  563:                               caseOperands[it.index()]);
        -:  564:  }
        -:  565:  p.printNewline();
        -:  566:}
        -:  567:
function _ZN4mlir2cf8SwitchOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  568:LogicalResult SwitchOp::verify() {
    #####:  569:  auto caseValues = getCaseValues();
call    0 never executed
    #####:  570:  auto caseDestinations = getCaseDestinations();
call    0 never executed
        -:  571:
    #####:  572:  if (!caseValues && caseDestinations.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  573:    return success();
        -:  574:
    #####:  575:  Type flagType = getFlag().getType();
call    0 never executed
call    1 never executed
    #####:  576:  Type caseValueType = caseValues->getType().getElementType();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  577:  if (caseValueType != flagType)
branch  0 never executed
branch  1 never executed
    #####:  578:    return emitOpError() << "'flag' type (" << flagType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  579:                         << ") should match case value type (" << caseValueType
call    0 never executed
call    1 never executed
    #####:  580:                         << ")";
call    0 never executed
        -:  581:
    #####:  582:  if (caseValues &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  583:      caseValues->size() != static_cast<int64_t>(caseDestinations.size()))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  584:    return emitOpError() << "number of case values (" << caseValues->size()
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  585:                         << ") should match number of "
    #####:  586:                            "case destinations ("
    #####:  587:                         << caseDestinations.size() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  588:  return success();
        -:  589:}
        -:  590:
function _ZN4mlir2cf8SwitchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####:  591:SuccessorOperands SwitchOp::getSuccessorOperands(unsigned index) {
    #####:  592:  assert(index < getNumSuccessors() && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  593:  return SuccessorOperands(index == 0 ? getDefaultOperandsMutable()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  594:                                      : getCaseOperandsMutable(index - 1));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  595:}
        -:  596:
function _ZN4mlir2cf8SwitchOp23getSuccessorForOperandsEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  597:Block *SwitchOp::getSuccessorForOperands(ArrayRef<Attribute> operands) {
    #####:  598:  Optional<DenseIntElementsAttr> caseValues = getCaseValues();
call    0 never executed
        -:  599:
    #####:  600:  if (!caseValues)
branch  0 never executed
branch  1 never executed
    #####:  601:    return getDefaultDestination();
call    0 never executed
        -:  602:
    #####:  603:  SuccessorRange caseDests = getCaseDestinations();
call    0 never executed
    #####:  604:  if (auto value = operands.front().dyn_cast_or_null<IntegerAttr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  605:    for (const auto &it : llvm::enumerate(caseValues->getValues<APInt>()))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  606:      if (it.value() == value.getValue())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  607:        return caseDests[it.index()];
branch  0 never executed
branch  1 never executed
    #####:  608:    return getDefaultDestination();
call    0 never executed
        -:  609:  }
    #####:  610:  return nullptr;
        -:  611:}
        -:  612:
        -:  613:/// switch %flag : i32, [
        -:  614:///   default:  ^bb1
        -:  615:/// ]
        -:  616:///  -> br ^bb1
function _ZL29simplifySwitchWithOnlyDefaultN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  617:static LogicalResult simplifySwitchWithOnlyDefault(SwitchOp op,
        -:  618:                                                   PatternRewriter &rewriter) {
    #####:  619:  if (!op.getCaseDestinations().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  620:    return failure();
        -:  621:
    #####:  622:  rewriter.replaceOpWithNewOp<BranchOp>(op, op.getDefaultDestination(),
    #####:  623:                                        op.getDefaultOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  624:  return success();
        -:  625:}
        -:  626:
        -:  627:/// switch %flag : i32, [
        -:  628:///   default: ^bb1,
        -:  629:///   42: ^bb1,
        -:  630:///   43: ^bb2
        -:  631:/// ]
        -:  632:/// ->
        -:  633:/// switch %flag : i32, [
        -:  634:///   default: ^bb1,
        -:  635:///   43: ^bb2
        -:  636:/// ]
        -:  637:static LogicalResult
function _ZL31dropSwitchCasesThatMatchDefaultN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  638:dropSwitchCasesThatMatchDefault(SwitchOp op, PatternRewriter &rewriter) {
    #####:  639:  SmallVector<Block *> newCaseDestinations;
call    0 never executed
    #####:  640:  SmallVector<ValueRange> newCaseOperands;
branch  0 never executed
branch  1 never executed
    #####:  641:  SmallVector<APInt> newCaseValues;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  642:  bool requiresChange = false;
    #####:  643:  auto caseValues = op.getCaseValues();
call    0 never executed
    #####:  644:  auto caseDests = op.getCaseDestinations();
call    0 never executed
        -:  645:
    #####:  646:  for (const auto &it : llvm::enumerate(caseValues->getValues<APInt>())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####:  647:    if (caseDests[it.index()] == op.getDefaultDestination() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  648:        op.getCaseOperands(it.index()) == op.getDefaultOperands()) {
call    0 never executed
call    1 never executed
    #####:  649:      requiresChange = true;
    #####:  650:      continue;
        -:  651:    }
    #####:  652:    newCaseDestinations.push_back(caseDests[it.index()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  653:    newCaseOperands.push_back(op.getCaseOperands(it.index()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  654:    newCaseValues.push_back(it.value());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  655:  }
        -:  656:
    #####:  657:  if (!requiresChange)
branch  0 never executed
branch  1 never executed
    #####:  658:    return failure();
        -:  659:
    #####:  660:  rewriter.replaceOpWithNewOp<SwitchOp>(
    #####:  661:      op, op.getFlag(), op.getDefaultDestination(), op.getDefaultOperands(),
call    0 never executed
call    1 never executed
    #####:  662:      newCaseValues, newCaseDestinations, newCaseOperands);
call    0 never executed
call    1 never executed
    #####:  663:  return success();
call    0 never executed
        -:  664:}
        -:  665:
        -:  666:/// Helper for folding a switch with a constant value.
        -:  667:/// switch %c_42 : i32, [
        -:  668:///   default: ^bb1 ,
        -:  669:///   42: ^bb2,
        -:  670:///   43: ^bb3
        -:  671:/// ]
        -:  672:/// -> br ^bb2
function _ZL10foldSwitchN4mlir2cf8SwitchOpERNS_15PatternRewriterERKN4llvm5APIntE called 0 returned 0% blocks executed 0%
    #####:  673:static void foldSwitch(SwitchOp op, PatternRewriter &rewriter,
        -:  674:                       const APInt &caseValue) {
    #####:  675:  auto caseValues = op.getCaseValues();
call    0 never executed
    #####:  676:  for (const auto &it : llvm::enumerate(caseValues->getValues<APInt>())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  677:    if (it.value() == caseValue) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  678:      rewriter.replaceOpWithNewOp<BranchOp>(
    #####:  679:          op, op.getCaseDestinations()[it.index()],
branch  0 never executed
branch  1 never executed
    #####:  680:          op.getCaseOperands(it.index()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  681:      return;
        -:  682:    }
        -:  683:  }
    #####:  684:  rewriter.replaceOpWithNewOp<BranchOp>(op, op.getDefaultDestination(),
    #####:  685:                                        op.getDefaultOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  686:}
        -:  687:
        -:  688:/// switch %c_42 : i32, [
        -:  689:///   default: ^bb1,
        -:  690:///   42: ^bb2,
        -:  691:///   43: ^bb3
        -:  692:/// ]
        -:  693:/// -> br ^bb2
function _ZL24simplifyConstSwitchValueN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  694:static LogicalResult simplifyConstSwitchValue(SwitchOp op,
        -:  695:                                              PatternRewriter &rewriter) {
    #####:  696:  APInt caseValue;
call    0 never executed
    #####:  697:  if (!matchPattern(op.getFlag(), m_ConstantInt(&caseValue)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  698:    return failure();
        -:  699:
    #####:  700:  foldSwitch(op, rewriter, caseValue);
call    0 never executed
    #####:  701:  return success();
branch  0 never executed
branch  1 never executed
        -:  702:}
        -:  703:
        -:  704:/// switch %c_42 : i32, [
        -:  705:///   default: ^bb1,
        -:  706:///   42: ^bb2,
        -:  707:/// ]
        -:  708:/// ^bb2:
        -:  709:///   br ^bb3
        -:  710:/// ->
        -:  711:/// switch %c_42 : i32, [
        -:  712:///   default: ^bb1,
        -:  713:///   42: ^bb3,
        -:  714:/// ]
function _ZL25simplifyPassThroughSwitchN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  715:static LogicalResult simplifyPassThroughSwitch(SwitchOp op,
        -:  716:                                               PatternRewriter &rewriter) {
    #####:  717:  SmallVector<Block *> newCaseDests;
call    0 never executed
    #####:  718:  SmallVector<ValueRange> newCaseOperands;
branch  0 never executed
branch  1 never executed
    #####:  719:  SmallVector<SmallVector<Value>> argStorage;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  720:  auto caseValues = op.getCaseValues();
call    0 never executed
    #####:  721:  argStorage.reserve(caseValues->size() + 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  722:  auto caseDests = op.getCaseDestinations();
call    0 never executed
    #####:  723:  bool requiresChange = false;
    #####:  724:  for (int64_t i = 0, size = caseValues->size(); i < size; ++i) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  725:    Block *caseDest = caseDests[i];
branch  0 never executed
branch  1 never executed
    #####:  726:    ValueRange caseOperands = op.getCaseOperands(i);
call    0 never executed
call    1 never executed
    #####:  727:    argStorage.emplace_back();
call    0 never executed
    #####:  728:    if (succeeded(collapseBranch(caseDest, caseOperands, argStorage.back())))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  729:      requiresChange = true;
        -:  730:
    #####:  731:    newCaseDests.push_back(caseDest);
call    0 never executed
    #####:  732:    newCaseOperands.push_back(caseOperands);
call    0 never executed
        -:  733:  }
        -:  734:
    #####:  735:  Block *defaultDest = op.getDefaultDestination();
call    0 never executed
    #####:  736:  ValueRange defaultOperands = op.getDefaultOperands();
call    0 never executed
call    1 never executed
    #####:  737:  argStorage.emplace_back();
call    0 never executed
        -:  738:
    #####:  739:  if (succeeded(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  740:          collapseBranch(defaultDest, defaultOperands, argStorage.back())))
call    0 never executed
        -:  741:    requiresChange = true;
        -:  742:
    #####:  743:  if (!requiresChange)
branch  0 never executed
branch  1 never executed
    #####:  744:    return failure();
        -:  745:
    #####:  746:  rewriter.replaceOpWithNewOp<SwitchOp>(op, op.getFlag(), defaultDest,
        -:  747:                                        defaultOperands, *caseValues,
    #####:  748:                                        newCaseDests, newCaseOperands);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  749:  return success();
call    0 never executed
        -:  750:}
        -:  751:
        -:  752:/// switch %flag : i32, [
        -:  753:///   default: ^bb1,
        -:  754:///   42: ^bb2,
        -:  755:/// ]
        -:  756:/// ^bb2:
        -:  757:///   switch %flag : i32, [
        -:  758:///     default: ^bb3,
        -:  759:///     42: ^bb4
        -:  760:///   ]
        -:  761:/// ->
        -:  762:/// switch %flag : i32, [
        -:  763:///   default: ^bb1,
        -:  764:///   42: ^bb2,
        -:  765:/// ]
        -:  766:/// ^bb2:
        -:  767:///   br ^bb4
        -:  768:///
        -:  769:///  and
        -:  770:///
        -:  771:/// switch %flag : i32, [
        -:  772:///   default: ^bb1,
        -:  773:///   42: ^bb2,
        -:  774:/// ]
        -:  775:/// ^bb2:
        -:  776:///   switch %flag : i32, [
        -:  777:///     default: ^bb3,
        -:  778:///     43: ^bb4
        -:  779:///   ]
        -:  780:/// ->
        -:  781:/// switch %flag : i32, [
        -:  782:///   default: ^bb1,
        -:  783:///   42: ^bb2,
        -:  784:/// ]
        -:  785:/// ^bb2:
        -:  786:///   br ^bb3
        -:  787:static LogicalResult
function _ZL39simplifySwitchFromSwitchOnSameConditionN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  788:simplifySwitchFromSwitchOnSameCondition(SwitchOp op,
        -:  789:                                        PatternRewriter &rewriter) {
        -:  790:  // Check that we have a single distinct predecessor.
    #####:  791:  Block *currentBlock = op->getBlock();
call    0 never executed
    #####:  792:  Block *predecessor = currentBlock->getSinglePredecessor();
call    0 never executed
    #####:  793:  if (!predecessor)
branch  0 never executed
branch  1 never executed
    #####:  794:    return failure();
        -:  795:
        -:  796:  // Check that the predecessor terminates with a switch branch to this block
        -:  797:  // and that it branches on the same condition and that this branch isn't the
        -:  798:  // default destination.
    #####:  799:  auto predSwitch = dyn_cast<SwitchOp>(predecessor->getTerminator());
call    0 never executed
call    1 never executed
    #####:  800:  if (!predSwitch || op.getFlag() != predSwitch.getFlag() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  801:      predSwitch.getDefaultDestination() == currentBlock)
branch  0 never executed
branch  1 never executed
    #####:  802:    return failure();
        -:  803:
        -:  804:  // Fold this switch to an unconditional branch.
    #####:  805:  SuccessorRange predDests = predSwitch.getCaseDestinations();
call    0 never executed
    #####:  806:  auto it = llvm::find(predDests, currentBlock);
call    0 never executed
    #####:  807:  if (it != predDests.end()) {
branch  0 never executed
branch  1 never executed
    #####:  808:    Optional<DenseIntElementsAttr> predCaseValues = predSwitch.getCaseValues();
call    0 never executed
    #####:  809:    foldSwitch(op, rewriter,
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  810:               predCaseValues->getValues<APInt>()[it - predDests.begin()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  811:  } else {
    #####:  812:    rewriter.replaceOpWithNewOp<BranchOp>(op, op.getDefaultDestination(),
    #####:  813:                                          op.getDefaultOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  814:  }
    #####:  815:  return success();
        -:  816:}
        -:  817:
        -:  818:/// switch %flag : i32, [
        -:  819:///   default: ^bb1,
        -:  820:///   42: ^bb2
        -:  821:/// ]
        -:  822:/// ^bb1:
        -:  823:///   switch %flag : i32, [
        -:  824:///     default: ^bb3,
        -:  825:///     42: ^bb4,
        -:  826:///     43: ^bb5
        -:  827:///   ]
        -:  828:/// ->
        -:  829:/// switch %flag : i32, [
        -:  830:///   default: ^bb1,
        -:  831:///   42: ^bb2,
        -:  832:/// ]
        -:  833:/// ^bb1:
        -:  834:///   switch %flag : i32, [
        -:  835:///     default: ^bb3,
        -:  836:///     43: ^bb5
        -:  837:///   ]
        -:  838:static LogicalResult
function _ZL46simplifySwitchFromDefaultSwitchOnSameConditionN4mlir2cf8SwitchOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  839:simplifySwitchFromDefaultSwitchOnSameCondition(SwitchOp op,
        -:  840:                                               PatternRewriter &rewriter) {
        -:  841:  // Check that we have a single distinct predecessor.
    #####:  842:  Block *currentBlock = op->getBlock();
call    0 never executed
    #####:  843:  Block *predecessor = currentBlock->getSinglePredecessor();
call    0 never executed
    #####:  844:  if (!predecessor)
branch  0 never executed
branch  1 never executed
    #####:  845:    return failure();
        -:  846:
        -:  847:  // Check that the predecessor terminates with a switch branch to this block
        -:  848:  // and that it branches on the same condition and that this branch is the
        -:  849:  // default destination.
    #####:  850:  auto predSwitch = dyn_cast<SwitchOp>(predecessor->getTerminator());
call    0 never executed
call    1 never executed
    #####:  851:  if (!predSwitch || op.getFlag() != predSwitch.getFlag() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  852:      predSwitch.getDefaultDestination() != currentBlock)
branch  0 never executed
branch  1 never executed
    #####:  853:    return failure();
        -:  854:
        -:  855:  // Delete case values that are not possible here.
    #####:  856:  DenseSet<APInt> caseValuesToRemove;
call    0 never executed
    #####:  857:  auto predDests = predSwitch.getCaseDestinations();
call    0 never executed
    #####:  858:  auto predCaseValues = predSwitch.getCaseValues();
call    0 never executed
    #####:  859:  for (int64_t i = 0, size = predCaseValues->size(); i < size; ++i)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  860:    if (currentBlock != predDests[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  861:      caseValuesToRemove.insert(predCaseValues->getValues<APInt>()[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  862:
    #####:  863:  SmallVector<Block *> newCaseDestinations;
call    0 never executed
call    1 never executed
    #####:  864:  SmallVector<ValueRange> newCaseOperands;
branch  0 never executed
branch  1 never executed
    #####:  865:  SmallVector<APInt> newCaseValues;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  866:  bool requiresChange = false;
        -:  867:
    #####:  868:  auto caseValues = op.getCaseValues();
call    0 never executed
    #####:  869:  auto caseDests = op.getCaseDestinations();
call    0 never executed
    #####:  870:  for (const auto &it : llvm::enumerate(caseValues->getValues<APInt>())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  871:    if (caseValuesToRemove.contains(it.value())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  872:      requiresChange = true;
    #####:  873:      continue;
        -:  874:    }
    #####:  875:    newCaseDestinations.push_back(caseDests[it.index()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  876:    newCaseOperands.push_back(op.getCaseOperands(it.index()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  877:    newCaseValues.push_back(it.value());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  878:  }
        -:  879:
    #####:  880:  if (!requiresChange)
branch  0 never executed
branch  1 never executed
    #####:  881:    return failure();
        -:  882:
    #####:  883:  rewriter.replaceOpWithNewOp<SwitchOp>(
    #####:  884:      op, op.getFlag(), op.getDefaultDestination(), op.getDefaultOperands(),
call    0 never executed
call    1 never executed
    #####:  885:      newCaseValues, newCaseDestinations, newCaseOperands);
call    0 never executed
call    1 never executed
    #####:  886:  return success();
call    0 never executed
        -:  887:}
        -:  888:
function _ZN4mlir2cf8SwitchOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3707 returned 100% blocks executed 100%
     3707:  889:void SwitchOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -:  890:                                           MLIRContext *context) {
     3707:  891:  results.add(&simplifySwitchWithOnlyDefault)
call    0 returned 100%
     3710:  892:      .add(&dropSwitchCasesThatMatchDefault)
call    0 returned 100%
     3713:  893:      .add(&simplifyConstSwitchValue)
call    0 returned 100%
     3712:  894:      .add(&simplifyPassThroughSwitch)
call    0 returned 100%
     3713:  895:      .add(&simplifySwitchFromSwitchOnSameCondition)
call    0 returned 100%
     3713:  896:      .add(&simplifySwitchFromDefaultSwitchOnSameCondition);
call    0 returned 100%
     3714:  897:}
        -:  898:
        -:  899://===----------------------------------------------------------------------===//
        -:  900:// TableGen'd op method definitions
        -:  901://===----------------------------------------------------------------------===//
        -:  902:
        -:  903:#define GET_OP_CLASSES
        -:  904:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.cpp.inc"
