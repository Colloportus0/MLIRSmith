        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Pass/PassRegistry.cpp
        -:    0:Graph:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/PassRegistry.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/PassRegistry.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- PassRegistry.cpp - Pass Registration Utilities ---------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include <utility>
        -:   10:
        -:   11:#include "mlir/Pass/Pass.h"
        -:   12:#include "mlir/Pass/PassManager.h"
        -:   13:#include "mlir/Pass/PassRegistry.h"
        -:   14:#include "llvm/ADT/DenseMap.h"
        -:   15:#include "llvm/Support/Format.h"
        -:   16:#include "llvm/Support/ManagedStatic.h"
        -:   17:#include "llvm/Support/MemoryBuffer.h"
        -:   18:#include "llvm/Support/SourceMgr.h"
        -:   19:
        -:   20:using namespace mlir;
        -:   21:using namespace detail;
        -:   22:
        -:   23:/// Static mapping of all of the registered passes.
        -:   24:static llvm::ManagedStatic<llvm::StringMap<PassInfo>> passRegistry;
        -:   25:
        -:   26:/// A mapping of the above pass registry entries to the corresponding TypeID
        -:   27:/// of the pass that they generate.
        -:   28:static llvm::ManagedStatic<llvm::StringMap<TypeID>> passRegistryTypeIDs;
        -:   29:
        -:   30:/// Static mapping of all of the registered pass pipelines.
        -:   31:static llvm::ManagedStatic<llvm::StringMap<PassPipelineInfo>>
        -:   32:    passPipelineRegistry;
        -:   33:
        -:   34:/// Utility to create a default registry function from a pass instance.
        -:   35:static PassRegistryFunction
function _ZL22buildDefaultRegistryFnRKSt8functionIFSt10unique_ptrIN4mlir4PassESt14default_deleteIS2_EEvEE called 96041380 returned 100% blocks executed 100%
 96041380:   36:buildDefaultRegistryFn(const PassAllocatorFunction &allocator) {
function _ZZL22buildDefaultRegistryFnRKSt8functionIFSt10unique_ptrIN4mlir4PassESt14default_deleteIS2_EEvEEENKUlRNS1_13OpPassManagerEN4llvm9StringRefENSC_12function_refIFNS1_13LogicalResultERKNSC_5TwineEEEEE_clESB_SD_SK_ called 295298 returned 100% blocks executed 29%
 96041380:   37:  return [=](OpPassManager &pm, StringRef options,
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   38:             function_ref<LogicalResult(const Twine &)> errorHandler) {
   295298:   39:    std::unique_ptr<Pass> pass = allocator();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   295298:   40:    LogicalResult result = pass->initializeOptions(options);
call    0 returned 100%
        -:   41:
   295298:   42:    Optional<StringRef> pmOpName = pm.getOpName();
call    0 returned 100%
   295298:   43:    Optional<StringRef> passOpName = pass->getOpName();
call    0 returned 100%
  295298*:   44:    if ((pm.getNesting() == OpPassManager::Nesting::Explicit) && pmOpName &&
call    0 returned 100%
branch  1 never executed
branch  2 never executed
  295298*:   45:        passOpName && *pmOpName != *passOpName) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   46:      return errorHandler(llvm::Twine("Can't add pass '") + pass->getName() +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:   47:                          "' restricted to '" + *pass->getOpName() +
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:   48:                          "' on a PassManager intended to run on '" +
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   49:                          pm.getOpAnchorName() + "', did you intend to nest?");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   50:    }
   295298:   51:    pm.addPass(std::move(pass));
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
   295298:   52:    return result;
 96041380:   53:  };
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   54:}
        -:   55:
        -:   56:/// Utility to print the help string for a specific option.
function _ZL15printOptionHelpN4llvm9StringRefES0_mmb called 0 returned 0% blocks executed 0%
    #####:   57:static void printOptionHelp(StringRef arg, StringRef desc, size_t indent,
        -:   58:                            size_t descIndent, bool isTopLevel) {
    #####:   59:  size_t numSpaces = descIndent - indent - 4;
    #####:   60:  llvm::outs().indent(indent)
call    0 never executed
call    1 never executed
    #####:   61:      << "--" << llvm::left_justify(arg, numSpaces) << "-   " << desc << '\n';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   62:}
        -:   63:
        -:   64://===----------------------------------------------------------------------===//
        -:   65:// PassRegistry
        -:   66://===----------------------------------------------------------------------===//
        -:   67:
        -:   68:/// Print the help information for this pass. This includes the argument,
        -:   69:/// description, and any pass options. `descIndent` is the indent that the
        -:   70:/// descriptions should be aligned.
function _ZNK4mlir17PassRegistryEntry12printHelpStrEmm called 0 returned 0% blocks executed 0%
    #####:   71:void PassRegistryEntry::printHelpStr(size_t indent, size_t descIndent) const {
    #####:   72:  printOptionHelp(getPassArgument(), getPassDescription(), indent, descIndent,
call    0 never executed
        -:   73:                  /*isTopLevel=*/true);
        -:   74:  // If this entry has options, print the help for those as well.
    #####:   75:  optHandler([=](const PassOptions &options) {
branch  0 never executed
branch  1 never executed
    #####:   76:    options.printHelp(indent, descIndent);
call    0 never executed
        -:   77:  });
    #####:   78:}
        -:   79:
        -:   80:/// Return the maximum width required when printing the options of this
        -:   81:/// entry.
function _ZNK4mlir17PassRegistryEntry14getOptionWidthEv called 0 returned 0% blocks executed 0%
    #####:   82:size_t PassRegistryEntry::getOptionWidth() const {
    #####:   83:  size_t maxLen = 0;
    #####:   84:  optHandler([&](const PassOptions &options) mutable {
branch  0 never executed
branch  1 never executed
    #####:   85:    maxLen = options.getOptionWidth() + 2;
call    0 never executed
        -:   86:  });
    #####:   87:  return maxLen;
        -:   88:}
        -:   89:
        -:   90://===----------------------------------------------------------------------===//
        -:   91:// PassPipelineInfo
        -:   92://===----------------------------------------------------------------------===//
        -:   93:
function _ZN4mlir20registerPassPipelineEN4llvm9StringRefES1_RKSt8functionIFNS_13LogicalResultERNS_13OpPassManagerES1_NS0_12function_refIFS3_RKNS0_5TwineEEEEEES2_IFvNS6_IFvRKNS_6detail11PassOptionsEEEEEE called 1302256 returned 100% blocks executed 78%
  1302256:   94:void mlir::registerPassPipeline(
        -:   95:    StringRef arg, StringRef description, const PassRegistryFunction &function,
        -:   96:    std::function<void(function_ref<void(const PassOptions &)>)> optHandler) {
  1302256:   97:  PassPipelineInfo pipelineInfo(arg, description, function,
call    0 returned 100%
  1302256:   98:                                std::move(optHandler));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  1302256:   99:  bool inserted = passPipelineRegistry->try_emplace(arg, pipelineInfo).second;
call    0 returned 100%
call    1 returned 100%
 1302256*:  100:  assert(inserted && "Pass pipeline registered multiple times");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  1302256:  101:  (void)inserted;
call    0 returned 100%
  1302256:  102:}
        -:  103:
        -:  104://===----------------------------------------------------------------------===//
        -:  105:// PassInfo
        -:  106://===----------------------------------------------------------------------===//
        -:  107:
function _ZN4mlir8PassInfoC2EN4llvm9StringRefES2_RKSt8functionIFSt10unique_ptrINS_4PassESt14default_deleteIS5_EEvEE called 96041380 returned 100% blocks executed 92%
 96041380:  108:PassInfo::PassInfo(StringRef arg, StringRef description,
 96041380:  109:                   const PassAllocatorFunction &allocator)
        -:  110:    : PassRegistryEntry(
 96041380:  111:          arg, description, buildDefaultRegistryFn(allocator),
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  112:          // Use a temporary pass to provide an options instance.
function _ZZN4mlir8PassInfoC4EN4llvm9StringRefES2_RKSt8functionIFSt10unique_ptrINS_4PassESt14default_deleteIS5_EEvEEENKUlNS1_12function_refIFvRKNS_6detail11PassOptionsEEEEE_clESJ_ called 0 returned 0% blocks executed 0%
192082760*:  113:          [=](function_ref<void(const PassOptions &)> optHandler) {
    #####:  114:            optHandler(allocator()->passOptions);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
288124140*:  115:          }) {}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
branch  7 taken 100% (fallthrough)
branch  8 taken 0%
        -:  116:
function _ZN4mlir12registerPassERKSt8functionIFSt10unique_ptrINS_4PassESt14default_deleteIS2_EEvEE called 96041380 returned 100% blocks executed 62%
 96041380:  117:void mlir::registerPass(const PassAllocatorFunction &function) {
 96041380:  118:  std::unique_ptr<Pass> pass = function();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 96041380:  119:  StringRef arg = pass->getArgument();
call    0 returned 100%
 96041380:  120:  if (arg.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  121:    llvm::report_fatal_error(llvm::Twine("Trying to register '") +
call    0 never executed
call    1 never executed
    #####:  122:                             pass->getName() +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  123:                             "' pass that does not override `getArgument()`");
call    0 never executed
call    1 never executed
call    2 never executed
 96041380:  124:  StringRef description = pass->getDescription();
call    0 returned 100%
192082760:  125:  PassInfo passInfo(arg, description, function);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
 96041380:  126:  passRegistry->try_emplace(arg, passInfo);
call    0 returned 100%
call    1 returned 100%
        -:  127:
        -:  128:  // Verify that the registered pass has the same ID as any registered to this
        -:  129:  // arg before it.
 96041380:  130:  TypeID entryTypeID = pass->getTypeID();
call    0 returned 100%
 96041380:  131:  auto it = passRegistryTypeIDs->try_emplace(arg, entryTypeID).first;
call    0 returned 100%
call    1 returned 100%
 96041380:  132:  if (it->second != entryTypeID)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  133:    llvm::report_fatal_error(
call    0 never executed
        -:  134:        "pass allocator creates a different pass than previously "
        -:  135:        "registered for pass " +
    #####:  136:        arg);
call    0 never executed
 96041380:  137:}
        -:  138:
        -:  139:/// Returns the pass info for the specified pass argument or null if unknown.
function _ZN4mlir4Pass14lookupPassInfoEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  140:const PassInfo *mlir::Pass::lookupPassInfo(StringRef passArg) {
    #####:  141:  auto it = passRegistry->find(passArg);
call    0 never executed
call    1 never executed
    #####:  142:  return it == passRegistry->end() ? nullptr : &it->second;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  143:}
        -:  144:
        -:  145://===----------------------------------------------------------------------===//
        -:  146:// PassOptions
        -:  147://===----------------------------------------------------------------------===//
        -:  148:
function _ZN4mlir6detail12pass_options23parseCommaSeparatedListERN4llvm2cl6OptionENS2_9StringRefES6_NS2_12function_refIFNS_13LogicalResultES6_EEE called 0 returned 0% blocks executed 0%
    #####:  149:LogicalResult detail::pass_options::parseCommaSeparatedList(
        -:  150:    llvm::cl::Option &opt, StringRef argName, StringRef optionStr,
        -:  151:    function_ref<LogicalResult(StringRef)> elementParseFn) {
        -:  152:  // Functor used for finding a character in a string, and skipping over
        -:  153:  // various "range" characters.
    #####:  154:  llvm::unique_function<size_t(StringRef, size_t, char)> findChar =
function _ZZN4mlir6detail12pass_options23parseCommaSeparatedListERN4llvm2cl6OptionENS2_9StringRefES6_NS2_12function_refIFNS_13LogicalResultES6_EEEENKUlS6_mcE_clES6_mc called 0 returned 0% blocks executed 0%
    #####:  155:      [&](StringRef str, size_t index, char c) -> size_t {
    #####:  156:    for (size_t i = index, e = str.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  157:      if (str[i] == c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  158:        return i;
        -:  159:      // Check for various range characters.
    #####:  160:      if (str[i] == '{')
branch  0 never executed
branch  1 never executed
    #####:  161:        i = findChar(str, i + 1, '}');
call    0 never executed
    #####:  162:      else if (str[i] == '(')
branch  0 never executed
branch  1 never executed
    #####:  163:        i = findChar(str, i + 1, ')');
call    0 never executed
    #####:  164:      else if (str[i] == '[')
branch  0 never executed
branch  1 never executed
    #####:  165:        i = findChar(str, i + 1, ']');
call    0 never executed
    #####:  166:      else if (str[i] == '\"')
branch  0 never executed
branch  1 never executed
    #####:  167:        i = str.find_first_of('\"', i + 1);
    #####:  168:      else if (str[i] == '\'')
branch  0 never executed
branch  1 never executed
    #####:  169:        i = str.find_first_of('\'', i + 1);
        -:  170:    }
        -:  171:    return StringRef::npos;
    #####:  172:  };
call    0 never executed
        -:  173:
    #####:  174:  size_t nextElePos = findChar(optionStr, 0, ',');
call    0 never executed
    #####:  175:  while (nextElePos != StringRef::npos) {
branch  0 never executed
branch  1 never executed
        -:  176:    // Process the portion before the comma.
    #####:  177:    if (failed(elementParseFn(optionStr.substr(0, nextElePos))))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  178:      return failure();
call    0 never executed
        -:  179:
    #####:  180:    optionStr = optionStr.substr(nextElePos + 1);
branch  0 never executed
branch  1 never executed
    #####:  181:    nextElePos = findChar(optionStr, 0, ',');
call    0 never executed
        -:  182:  }
    #####:  183:  return elementParseFn(optionStr.substr(0, nextElePos));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  184:}
        -:  185:
        -:  186:/// Out of line virtual function to provide home for the class.
function _ZN4mlir6detail11PassOptions10OptionBase6anchorEv called 0 returned 0% blocks executed 0%
    #####:  187:void detail::PassOptions::OptionBase::anchor() {}
        -:  188:
        -:  189:/// Copy the option values from 'other'.
function _ZN4mlir6detail11PassOptions20copyOptionValuesFromERKS1_ called 6224256 returned 100% blocks executed 89%
  6224256:  190:void detail::PassOptions::copyOptionValuesFrom(const PassOptions &other) {
 6224256*:  191:  assert(options.size() == other.options.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  6224256:  192:  if (options.empty())
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
        -:  193:    return;
  8709192:  194:  for (auto optionsIt : llvm::zip(options, other.options))
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
  6742296:  195:    std::get<0>(optionsIt)->copyValueFrom(*std::get<1>(optionsIt));
call    0 returned 100%
        -:  196:}
        -:  197:
        -:  198:/// Parse in the next argument from the given options string. Returns a tuple
        -:  199:/// containing [the key of the option, the value of the option, updated
        -:  200:/// `options` string pointing after the parsed option].
        -:  201:static std::tuple<StringRef, StringRef, StringRef>
function _ZL12parseNextArgN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  202:parseNextArg(StringRef options) {
        -:  203:  // Functor used to extract an argument from 'options' and update it to point
        -:  204:  // after the arg.
function _ZZL12parseNextArgN4llvm9StringRefEENKUlmE_clEm.isra.0 called 0 returned 0% blocks executed 0%
    #####:  205:  auto extractArgAndUpdateOptions = [&](size_t argSize) {
    #####:  206:    StringRef str = options.take_front(argSize).trim();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  207:    options = options.drop_front(argSize).ltrim();
call    0 never executed
call    1 never executed
    #####:  208:    return str;
    #####:  209:  };
        -:  210:  // Try to process the given punctuation, properly escaping any contained
        -:  211:  // characters.
function _ZZL12parseNextArgN4llvm9StringRefEENKUlRmcE0_clES1_c called 0 returned 0% blocks executed 0%
    #####:  212:  auto tryProcessPunct = [&](size_t &currentPos, char punct) {
    #####:  213:    if (options[currentPos] != punct)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  214:      return false;
    #####:  215:    size_t nextIt = options.find_first_of(punct, currentPos + 1);
branch  0 never executed
branch  1 never executed
    #####:  216:    if (nextIt != StringRef::npos)
branch  0 never executed
branch  1 never executed
    #####:  217:      currentPos = nextIt;
        -:  218:    return true;
    #####:  219:  };
        -:  220:
        -:  221:  // Parse the argument name of the option.
    #####:  222:  StringRef argName;
    #####:  223:  for (size_t argEndIt = 0, optionsE = options.size();; ++argEndIt) {
        -:  224:    // Check for the end of the full option.
    #####:  225:    if (argEndIt == optionsE || options[argEndIt] == ' ') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  226:      argName = extractArgAndUpdateOptions(argEndIt);
call    0 never executed
    #####:  227:      return std::make_tuple(argName, StringRef(), options);
        -:  228:    }
        -:  229:
        -:  230:    // Check for the end of the name and the start of the value.
    #####:  231:    if (options[argEndIt] == '=') {
branch  0 never executed
branch  1 never executed
    #####:  232:      argName = extractArgAndUpdateOptions(argEndIt);
call    0 never executed
    #####:  233:      options = options.drop_front();
call    0 never executed
    #####:  234:      break;
        -:  235:    }
        -:  236:  }
        -:  237:
        -:  238:  // Parse the value of the option.
    #####:  239:  for (size_t argEndIt = 0, optionsE = options.size();; ++argEndIt) {
        -:  240:    // Handle the end of the options string.
    #####:  241:    if (argEndIt == optionsE || options[argEndIt] == ' ') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  242:      StringRef value = extractArgAndUpdateOptions(argEndIt);
call    0 never executed
    #####:  243:      return std::make_tuple(argName, value, options);
        -:  244:    }
        -:  245:
        -:  246:    // Skip over escaped sequences.
    #####:  247:    char c = options[argEndIt];
call    0 never executed
    #####:  248:    if (tryProcessPunct(argEndIt, '\'') || tryProcessPunct(argEndIt, '"'))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  249:      continue;
        -:  250:    // '{...}' is used to specify options to passes, properly escape it so
        -:  251:    // that we don't accidentally split any nested options.
    #####:  252:    if (c == '{') {
branch  0 never executed
branch  1 never executed
    #####:  253:      size_t braceCount = 1;
    #####:  254:      for (++argEndIt; argEndIt != optionsE; ++argEndIt) {
branch  0 never executed
branch  1 never executed
        -:  255:        // Allow nested punctuation.
    #####:  256:        if (tryProcessPunct(argEndIt, '\'') || tryProcessPunct(argEndIt, '"'))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  257:          continue;
    #####:  258:        if (options[argEndIt] == '{')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  259:          ++braceCount;
    #####:  260:        else if (options[argEndIt] == '}' && --braceCount == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  261:          break;
        -:  262:      }
        -:  263:      // Account for the increment at the top of the loop.
    #####:  264:      --argEndIt;
        -:  265:    }
    #####:  266:  }
        -:  267:  llvm_unreachable("unexpected control flow in pass option parsing");
        -:  268:}
        -:  269:
function _ZN4mlir6detail11PassOptions15parseFromStringEN4llvm9StringRefE called 297375 returned 100% blocks executed 20%
   297375:  270:LogicalResult detail::PassOptions::parseFromString(StringRef options) {
        -:  271:  // NOTE: `options` is modified in place to always refer to the unprocessed
        -:  272:  // part of the string.
   297375:  273:  while (!options.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  274:    StringRef key, value;
    #####:  275:    std::tie(key, value, options) = parseNextArg(options);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  276:    if (key.empty())
branch  0 never executed
branch  1 never executed
    #####:  277:      continue;
        -:  278:
    #####:  279:    auto it = OptionsMap.find(key);
call    0 never executed
    #####:  280:    if (it == OptionsMap.end()) {
branch  0 never executed
branch  1 never executed
    #####:  281:      llvm::errs() << "<Pass-Options-Parser>: no such option " << key << "\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  282:      return failure();
        -:  283:    }
    #####:  284:    if (llvm::cl::ProvidePositionalOption(it->second, value, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  285:      return failure();
        -:  286:  }
        -:  287:
   297375:  288:  return success();
        -:  289:}
        -:  290:
        -:  291:/// Print the options held by this struct in a form that can be parsed via
        -:  292:/// 'parseFromString'.
function _ZN4mlir6detail11PassOptions5printERN4llvm11raw_ostreamE called 4795 returned 100% blocks executed 88%
     4795:  293:void detail::PassOptions::print(raw_ostream &os) {
        -:  294:  // If there are no options, there is nothing left to do.
     4795:  295:  if (OptionsMap.empty())
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
     3439:  296:    return;
        -:  297:
        -:  298:  // Sort the options to make the ordering deterministic.
     2712:  299:  SmallVector<OptionBase *, 4> orderedOps(options.begin(), options.end());
call    0 returned 100%
function _ZZN4mlir6detail11PassOptions5printERN4llvm11raw_ostreamEENKUlPKPNS1_10OptionBaseES8_E_clES8_S8_.isra.0 called 4040 returned 100% blocks executed 100%
     5396:  300:  auto compareOptionArgs = [](OptionBase *const *lhs, OptionBase *const *rhs) {
     4040:  301:    return (*lhs)->getArgStr().compare((*rhs)->getArgStr());
call    0 returned 100%
call    1 returned 100%
        -:  302:  };
     1356:  303:  llvm::array_pod_sort(orderedOps.begin(), orderedOps.end(), compareOptionArgs);
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -:  304:
        -:  305:  // Interleave the options with ' '.
     1356:  306:  os << '{';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1356:  307:  llvm::interleave(
call    0 returned 100%
     3760:  308:      orderedOps, os, [&](OptionBase *option) { option->print(os); }, " ");
call    0 returned 100%
call    1 returned 100%
     2712:  309:  os << '}';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 18% (fallthrough)
branch  3 taken 82%
        -:  310:}
        -:  311:
        -:  312:/// Print the help string for the options held by this struct. `descIndent` is
        -:  313:/// the indent within the stream that the descriptions should be aligned.
function _ZNK4mlir6detail11PassOptions9printHelpEmm called 0 returned 0% blocks executed 0%
    #####:  314:void detail::PassOptions::printHelp(size_t indent, size_t descIndent) const {
        -:  315:  // Sort the options to make the ordering deterministic.
    #####:  316:  SmallVector<OptionBase *, 4> orderedOps(options.begin(), options.end());
call    0 never executed
function _ZZNK4mlir6detail11PassOptions9printHelpEmmENKUlPKPNS1_10OptionBaseES5_E_clES5_S5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  317:  auto compareOptionArgs = [](OptionBase *const *lhs, OptionBase *const *rhs) {
    #####:  318:    return (*lhs)->getArgStr().compare((*rhs)->getArgStr());
call    0 never executed
call    1 never executed
        -:  319:  };
    #####:  320:  llvm::array_pod_sort(orderedOps.begin(), orderedOps.end(), compareOptionArgs);
branch  0 never executed
branch  1 never executed
    #####:  321:  for (OptionBase *option : orderedOps) {
branch  0 never executed
branch  1 never executed
        -:  322:    // TODO: printOptionInfo assumes a specific indent and will
        -:  323:    // print options with values with incorrect indentation. We should add
        -:  324:    // support to llvm::cl::Option for passing in a base indent to use when
        -:  325:    // printing.
    #####:  326:    llvm::outs().indent(indent);
call    0 never executed
call    1 never executed
    #####:  327:    option->getOption()->printOptionInfo(descIndent - indent);
call    0 never executed
call    1 never executed
        -:  328:  }
    #####:  329:}
        -:  330:
        -:  331:/// Return the maximum width required when printing the help string.
function _ZNK4mlir6detail11PassOptions14getOptionWidthEv called 0 returned 0% blocks executed 0%
    #####:  332:size_t detail::PassOptions::getOptionWidth() const {
    #####:  333:  size_t max = 0;
    #####:  334:  for (auto *option : options)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  335:    max = std::max(max, option->getOption()->getOptionWidth());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  336:  return max;
        -:  337:}
        -:  338:
        -:  339://===----------------------------------------------------------------------===//
        -:  340:// MLIR Options
        -:  341://===----------------------------------------------------------------------===//
        -:  342:
        -:  343://===----------------------------------------------------------------------===//
        -:  344:// OpPassManager: OptionValue
        -:  345:
        -:  346:llvm::cl::OptionValue<OpPassManager>::OptionValue() = default;
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEEC2ERKS3_ called 0 returned 0% blocks executed 0%
    #####:  347:llvm::cl::OptionValue<OpPassManager>::OptionValue(
    #####:  348:    const mlir::OpPassManager &value) {
call    0 never executed
    #####:  349:  setValue(value);
call    0 never executed
    #####:  350:}
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEEC2ERKS4_ called 0 returned 0% blocks executed 0%
    #####:  351:llvm::cl::OptionValue<OpPassManager>::OptionValue(
    #####:  352:    const llvm::cl::OptionValue<mlir::OpPassManager> &rhs) {
branch  0 never executed
branch  1 never executed
    #####:  353:  if (rhs.hasValue())
branch  0 never executed
branch  1 never executed
    #####:  354:    setValue(rhs.getValue());
call    0 never executed
    #####:  355:}
        -:  356:llvm::cl::OptionValue<OpPassManager> &
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEEaSERKS3_ called 0 returned 0% blocks executed 0%
    #####:  357:llvm::cl::OptionValue<OpPassManager>::operator=(
        -:  358:    const mlir::OpPassManager &rhs) {
    #####:  359:  setValue(rhs);
call    0 never executed
    #####:  360:  return *this;
        -:  361:}
        -:  362:
        -:  363:llvm::cl::OptionValue<OpPassManager>::~OptionValue<OpPassManager>() = default;
        -:  364:
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEE8setValueERKS3_ called 0 returned 0% blocks executed 0%
    #####:  365:void llvm::cl::OptionValue<OpPassManager>::setValue(
        -:  366:    const OpPassManager &newValue) {
    #####:  367:  if (hasValue())
branch  0 never executed
branch  1 never executed
    #####:  368:    *value = newValue;
call    0 never executed
        -:  369:  else
    #####:  370:    value = std::make_unique<mlir::OpPassManager>(newValue);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:}
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEE8setValueENS_9StringRefE called 0 returned 0% blocks executed 0%
    #####:  372:void llvm::cl::OptionValue<OpPassManager>::setValue(StringRef pipelineStr) {
    #####:  373:  FailureOr<OpPassManager> pipeline = parsePassPipeline(pipelineStr);
call    0 never executed
call    1 never executed
    #####:  374:  assert(succeeded(pipeline) && "invalid pass pipeline");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  375:  setValue(*pipeline);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  376:}
        -:  377:
function _ZNK4llvm2cl11OptionValueIN4mlir13OpPassManagerEE7compareERKS3_ called 0 returned 0% blocks executed 0%
    #####:  378:bool llvm::cl::OptionValue<OpPassManager>::compare(
        -:  379:    const mlir::OpPassManager &rhs) const {
    #####:  380:  std::string lhsStr, rhsStr;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  381:  {
    #####:  382:    raw_string_ostream lhsStream(lhsStr);
call    0 never executed
    #####:  383:    value->printAsTextualPipeline(lhsStream);
call    0 never executed
        -:  384:
    #####:  385:    raw_string_ostream rhsStream(rhsStr);
call    0 never executed
call    1 never executed
    #####:  386:    rhs.printAsTextualPipeline(rhsStream);
call    0 never executed
call    1 never executed
        -:  387:  }
        -:  388:
        -:  389:  // Use the textual format for pipeline comparisons.
    #####:  390:  return lhsStr == rhsStr;
branch  0 never executed
branch  1 never executed
        -:  391:}
        -:  392:
function _ZN4llvm2cl11OptionValueIN4mlir13OpPassManagerEE6anchorEv called 0 returned 0% blocks executed 0%
    #####:  393:void llvm::cl::OptionValue<OpPassManager>::anchor() {}
        -:  394:
        -:  395://===----------------------------------------------------------------------===//
        -:  396:// OpPassManager: Parser
        -:  397:
        -:  398:namespace llvm {
        -:  399:namespace cl {
        -:  400:template class basic_parser<OpPassManager>;
        -:  401:} // namespace cl
        -:  402:} // namespace llvm
        -:  403:
function _ZN4llvm2cl6parserIN4mlir13OpPassManagerEE5parseERNS0_6OptionENS_9StringRefES7_RNS4_17ParsedPassManagerE called 0 returned 0% blocks executed 0%
    #####:  404:bool llvm::cl::parser<OpPassManager>::parse(Option &, StringRef, StringRef arg,
        -:  405:                                            ParsedPassManager &value) {
    #####:  406:  FailureOr<OpPassManager> pipeline = parsePassPipeline(arg);
call    0 never executed
call    1 never executed
    #####:  407:  if (failed(pipeline))
branch  0 never executed
branch  1 never executed
        -:  408:    return true;
    #####:  409:  value.value = std::make_unique<OpPassManager>(std::move(*pipeline));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  410:  return false;
        -:  411:}
        -:  412:
function _ZN4llvm2cl6parserIN4mlir13OpPassManagerEE5printERNS_11raw_ostreamERKS3_ called 0 returned 0% blocks executed 0%
    #####:  413:void llvm::cl::parser<OpPassManager>::print(raw_ostream &os,
        -:  414:                                            const OpPassManager &value) {
    #####:  415:  value.printAsTextualPipeline(os);
call    0 never executed
    #####:  416:}
        -:  417:
function _ZNK4llvm2cl6parserIN4mlir13OpPassManagerEE15printOptionDiffERKNS0_6OptionERS3_RKNS0_11OptionValueIS3_EEm called 0 returned 0% blocks executed 0%
    #####:  418:void llvm::cl::parser<OpPassManager>::printOptionDiff(
        -:  419:    const Option &opt, OpPassManager &pm, const OptVal &defaultValue,
        -:  420:    size_t globalWidth) const {
    #####:  421:  printOptionName(opt, globalWidth);
call    0 never executed
    #####:  422:  outs() << "= ";
call    0 never executed
call    1 never executed
    #####:  423:  pm.printAsTextualPipeline(outs());
call    0 never executed
call    1 never executed
        -:  424:
    #####:  425:  if (defaultValue.hasValue()) {
branch  0 never executed
branch  1 never executed
    #####:  426:    outs().indent(2) << " (default: ";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  427:    defaultValue.getValue().printAsTextualPipeline(outs());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  428:    outs() << ")";
call    0 never executed
call    1 never executed
        -:  429:  }
    #####:  430:  outs() << "\n";
call    0 never executed
call    1 never executed
    #####:  431:}
        -:  432:
function _ZN4llvm2cl6parserIN4mlir13OpPassManagerEE6anchorEv called 0 returned 0% blocks executed 0%
    #####:  433:void llvm::cl::parser<OpPassManager>::anchor() {}
        -:  434:
        -:  435:llvm::cl::parser<OpPassManager>::ParsedPassManager::ParsedPassManager() =
        -:  436:    default;
        -:  437:llvm::cl::parser<OpPassManager>::ParsedPassManager::ParsedPassManager(
        -:  438:    ParsedPassManager &&) = default;
        -:  439:llvm::cl::parser<OpPassManager>::ParsedPassManager::~ParsedPassManager() =
        -:  440:    default;
        -:  441:
        -:  442://===----------------------------------------------------------------------===//
        -:  443:// TextualPassPipeline Parser
        -:  444://===----------------------------------------------------------------------===//
        -:  445:
        -:  446:namespace {
        -:  447:/// This class represents a textual description of a pass pipeline.
294776617*:  448:class TextualPipeline {
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
        -:  449:public:
        -:  450:  /// Try to initialize this pipeline with the given pipeline text.
        -:  451:  /// `errorStream` is the output stream to emit errors to.
        -:  452:  LogicalResult initialize(StringRef text, raw_ostream &errorStream);
        -:  453:
        -:  454:  /// Add the internal pipeline elements to the provided pass manager.
        -:  455:  LogicalResult
        -:  456:  addToPipeline(OpPassManager &pm,
        -:  457:                function_ref<LogicalResult(const Twine &)> errorHandler) const;
        -:  458:
        -:  459:private:
        -:  460:  /// A functor used to emit errors found during pipeline handling. The first
        -:  461:  /// parameter corresponds to the raw location within the pipeline string. This
        -:  462:  /// should always return failure.
        -:  463:  using ErrorHandlerT = function_ref<LogicalResult(const char *, Twine)>;
        -:  464:
        -:  465:  /// A struct to capture parsed pass pipeline names.
        -:  466:  ///
        -:  467:  /// A pipeline is defined as a series of names, each of which may in itself
        -:  468:  /// recursively contain a nested pipeline. A name is either the name of a pass
        -:  469:  /// (e.g. "cse") or the name of an operation type (e.g. "buitin.module"). If
        -:  470:  /// the name is the name of a pass, the InnerPipeline is empty, since passes
        -:  471:  /// cannot contain inner pipelines.
    #####:  472:  struct PipelineElement {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    1034*:  473:    PipelineElement(StringRef name) : name(name) {}
call    0 returned 100%
        -:  474:
        -:  475:    StringRef name;
        -:  476:    StringRef options;
        -:  477:    const PassRegistryEntry *registryEntry = nullptr;
        -:  478:    std::vector<PipelineElement> innerPipeline;
        -:  479:  };
        -:  480:
        -:  481:  /// Parse the given pipeline text into the internal pipeline vector. This
        -:  482:  /// function only parses the structure of the pipeline, and does not resolve
        -:  483:  /// its elements.
        -:  484:  LogicalResult parsePipelineText(StringRef text, ErrorHandlerT errorHandler);
        -:  485:
        -:  486:  /// Resolve the elements of the pipeline, i.e. connect passes and pipelines to
        -:  487:  /// the corresponding registry entry.
        -:  488:  LogicalResult
        -:  489:  resolvePipelineElements(MutableArrayRef<PipelineElement> elements,
        -:  490:                          ErrorHandlerT errorHandler);
        -:  491:
        -:  492:  /// Resolve a single element of the pipeline.
        -:  493:  LogicalResult resolvePipelineElement(PipelineElement &element,
        -:  494:                                       ErrorHandlerT errorHandler);
        -:  495:
        -:  496:  /// Add the given pipeline elements to the provided pass manager.
        -:  497:  LogicalResult
        -:  498:  addToPipeline(ArrayRef<PipelineElement> elements, OpPassManager &pm,
        -:  499:                function_ref<LogicalResult(const Twine &)> errorHandler) const;
        -:  500:
        -:  501:  std::vector<PipelineElement> pipeline;
        -:  502:};
        -:  503:
        -:  504:} // namespace
        -:  505:
        -:  506:/// Try to initialize this pipeline with the given pipeline text. An option is
        -:  507:/// given to enable accurate error reporting.
function _ZN12_GLOBAL__N_115TextualPipeline10initializeEN4llvm9StringRefERNS1_11raw_ostreamE called 2128 returned 100% blocks executed 80%
     2128:  508:LogicalResult TextualPipeline::initialize(StringRef text,
        -:  509:                                          raw_ostream &errorStream) {
     2128:  510:  if (text.empty())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
     1094:  511:    return success();
        -:  512:
        -:  513:  // Build a source manager to use for error reporting.
     1034:  514:  llvm::SourceMgr pipelineMgr;
call    0 returned 100%
     1034:  515:  pipelineMgr.AddNewSourceBuffer(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1034:  516:      llvm::MemoryBuffer::getMemBuffer(text, "MLIR Textual PassPipeline Parser",
call    0 returned 100%
        -:  517:                                       /*RequiresNullTerminator=*/false),
        -:  518:      SMLoc());
    1034*:  519:  auto errorHandler = [&](const char *rawLoc, Twine msg) {
    #####:  520:    pipelineMgr.PrintMessage(errorStream, SMLoc::getFromPointer(rawLoc),
call    0 never executed
        -:  521:                             llvm::SourceMgr::DK_Error, msg);
    #####:  522:    return failure();
     1034:  523:  };
        -:  524:
        -:  525:  // Parse the provided pipeline string.
     1034:  526:  if (failed(parsePipelineText(text, errorHandler)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    1034*:  527:    return failure();
call    0 returned 100%
     1034:  528:  return resolvePipelineElements(pipeline, errorHandler);
call    0 returned 100%
        -:  529:}
        -:  530:
        -:  531:/// Add the internal pipeline elements to the provided pass manager.
    2128*:  532:LogicalResult TextualPipeline::addToPipeline(
        -:  533:    OpPassManager &pm,
        -:  534:    function_ref<LogicalResult(const Twine &)> errorHandler) const {
    2128*:  535:  return addToPipeline(pipeline, pm, errorHandler);
call    0 returned 100%
        -:  536:}
        -:  537:
        -:  538:/// Parse the given pipeline text into the internal pipeline vector. This
        -:  539:/// function only parses the structure of the pipeline, and does not resolve
        -:  540:/// its elements.
function _ZN12_GLOBAL__N_115TextualPipeline17parsePipelineTextEN4llvm9StringRefENS1_12function_refIFN4mlir13LogicalResultEPKcNS1_5TwineEEEE called 1034 returned 100% blocks executed 23%
     1034:  541:LogicalResult TextualPipeline::parsePipelineText(StringRef text,
        -:  542:                                                 ErrorHandlerT errorHandler) {
     1034:  543:  SmallVector<std::vector<PipelineElement> *, 4> pipelineStack = {&pipeline};
call    0 returned 100%
     1034:  544:  for (;;) {
     1034:  545:    std::vector<PipelineElement> &pipeline = *pipelineStack.back();
call    0 returned 100%
     1034:  546:    size_t pos = text.find_first_of(",(){");
call    0 returned 100%
     3102:  547:    pipeline.emplace_back(/*name=*/text.substr(0, pos).trim());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
        -:  548:
        -:  549:    // If we have a single terminating name, we're done.
     1034:  550:    if (pos == StringRef::npos)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  551:      break;
        -:  552:
    #####:  553:    text = text.substr(pos);
branch  0 never executed
branch  1 never executed
    #####:  554:    char sep = text[0];
branch  0 never executed
branch  1 never executed
        -:  555:
        -:  556:    // Handle pulling ... from 'pass{...}' out as PipelineElement.options.
    #####:  557:    if (sep == '{') {
branch  0 never executed
branch  1 never executed
    #####:  558:      text = text.substr(1);
branch  0 never executed
branch  1 never executed
        -:  559:
        -:  560:      // Skip over everything until the closing '}' and store as options.
    #####:  561:      size_t close = StringRef::npos;
    #####:  562:      for (unsigned i = 0, e = text.size(), braceCount = 1; i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  563:        if (text[i] == '{') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  564:          ++braceCount;
    #####:  565:          continue;
        -:  566:        }
    #####:  567:        if (text[i] == '}' && --braceCount == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  568:          close = i;
        -:  569:          break;
        -:  570:        }
        -:  571:      }
        -:  572:
        -:  573:      // Check to see if a closing options brace was found.
    #####:  574:      if (close == StringRef::npos) {
branch  0 never executed
branch  1 never executed
    #####:  575:        return errorHandler(
    #####:  576:            /*rawLoc=*/text.data() - 1,
call    0 never executed
    #####:  577:            "missing closing '}' while processing pass options");
call    0 never executed
call    1 never executed
        -:  578:      }
    #####:  579:      pipeline.back().options = text.substr(0, close);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  580:      text = text.substr(close + 1);
branch  0 never executed
branch  1 never executed
        -:  581:
        -:  582:      // Skip checking for '(' because nested pipelines cannot have options.
    #####:  583:    } else if (sep == '(') {
branch  0 never executed
branch  1 never executed
    #####:  584:      text = text.substr(1);
branch  0 never executed
branch  1 never executed
        -:  585:
        -:  586:      // Push the inner pipeline onto the stack to continue processing.
    #####:  587:      pipelineStack.push_back(&pipeline.back().innerPipeline);
call    0 never executed
    #####:  588:      continue;
        -:  589:    }
        -:  590:
        -:  591:    // When handling the close parenthesis, we greedily consume them to avoid
        -:  592:    // empty strings in the pipeline.
    #####:  593:    while (text.consume_front(")")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  594:      // If we try to pop the outer pipeline we have unbalanced parentheses.
    #####:  595:      if (pipelineStack.size() == 1)
branch  0 never executed
branch  1 never executed
    #####:  596:        return errorHandler(/*rawLoc=*/text.data() - 1,
call    0 never executed
        -:  597:                            "encountered extra closing ')' creating unbalanced "
    #####:  598:                            "parentheses while parsing pipeline");
call    0 never executed
call    1 never executed
        -:  599:
    #####:  600:      pipelineStack.pop_back();
call    0 never executed
        -:  601:    }
        -:  602:
        -:  603:    // Check if we've finished parsing.
    #####:  604:    if (text.empty())
branch  0 never executed
branch  1 never executed
        -:  605:      break;
        -:  606:
        -:  607:    // Otherwise, the end of an inner pipeline always has to be followed by
        -:  608:    // a comma, and then we can continue.
    #####:  609:    if (!text.consume_front(","))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  610:      return errorHandler(text.data(), "expected ',' after parsing pipeline");
call    0 never executed
call    1 never executed
        -:  611:  }
        -:  612:
        -:  613:  // Check for unbalanced parentheses.
     1034:  614:  if (pipelineStack.size() > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  615:    return errorHandler(
        -:  616:        text.data(),
    #####:  617:        "encountered unbalanced parentheses while parsing pipeline");
call    0 never executed
call    1 never executed
        -:  618:
    1034*:  619:  assert(pipelineStack.back() == &pipeline &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  620:         "wrong pipeline at the bottom of the stack");
     1034:  621:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  622:}
        -:  623:
        -:  624:/// Resolve the elements of the pipeline, i.e. connect passes and pipelines to
        -:  625:/// the corresponding registry entry.
function _ZN12_GLOBAL__N_115TextualPipeline23resolvePipelineElementsEN4llvm15MutableArrayRefINS0_15PipelineElementEEENS1_12function_refIFN4mlir13LogicalResultEPKcNS1_5TwineEEEE called 1034 returned 100% blocks executed 88%
     1034:  626:LogicalResult TextualPipeline::resolvePipelineElements(
        -:  627:    MutableArrayRef<PipelineElement> elements, ErrorHandlerT errorHandler) {
     2068:  628:  for (auto &elt : elements)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1034:  629:    if (failed(resolvePipelineElement(elt, errorHandler)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  630:      return failure();
     1034:  631:  return success();
        -:  632:}
        -:  633:
        -:  634:/// Resolve a single element of the pipeline.
        -:  635:LogicalResult
function _ZN12_GLOBAL__N_115TextualPipeline22resolvePipelineElementERNS0_15PipelineElementEN4llvm12function_refIFN4mlir13LogicalResultEPKcNS3_5TwineEEEE called 1034 returned 100% blocks executed 41%
     1034:  636:TextualPipeline::resolvePipelineElement(PipelineElement &element,
        -:  637:                                        ErrorHandlerT errorHandler) {
        -:  638:  // If the inner pipeline of this element is not empty, this is an operation
        -:  639:  // pipeline.
     1034:  640:  if (!element.innerPipeline.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:    return resolvePipelineElements(element.innerPipeline, errorHandler);
call    0 never executed
        -:  642:  // Otherwise, this must be a pass or pass pipeline.
        -:  643:  // Check to see if a pipeline was registered with this name.
     1034:  644:  auto pipelineRegistryIt = passPipelineRegistry->find(element.name);
call    0 returned 100%
call    1 returned 100%
     1034:  645:  if (pipelineRegistryIt != passPipelineRegistry->end()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1034:  646:    element.registryEntry = &pipelineRegistryIt->second;
     1034:  647:    return success();
        -:  648:  }
        -:  649:
        -:  650:  // If not, then this must be a specific pass name.
    #####:  651:  if ((element.registryEntry = Pass::lookupPassInfo(element.name)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  652:    return success();
        -:  653:
        -:  654:  // Emit an error for the unknown pass.
    #####:  655:  auto *rawLoc = element.name.data();
call    0 never executed
    #####:  656:  return errorHandler(rawLoc, "'" + element.name +
call    0 never executed
call    1 never executed
        -:  657:                                  "' does not refer to a "
    #####:  658:                                  "registered pass or pass pipeline");
call    0 never executed
call    1 never executed
        -:  659:}
        -:  660:
        -:  661:/// Add the given pipeline elements to the provided pass manager.
function _ZNK12_GLOBAL__N_115TextualPipeline13addToPipelineEN4llvm8ArrayRefINS0_15PipelineElementEEERN4mlir13OpPassManagerENS1_12function_refIFNS5_13LogicalResultERKNS1_5TwineEEEE called 2128 returned 100% blocks executed 28%
     2128:  662:LogicalResult TextualPipeline::addToPipeline(
        -:  663:    ArrayRef<PipelineElement> elements, OpPassManager &pm,
        -:  664:    function_ref<LogicalResult(const Twine &)> errorHandler) const {
     3162:  665:  for (auto &elt : elements) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
     1034:  666:    if (elt.registryEntry) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1034:  667:      if (failed(elt.registryEntry->addToPipeline(pm, elt.options,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  668:                                                  errorHandler))) {
    #####:  669:        return errorHandler("failed to add `" + elt.name + "` with options `" +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  670:                            elt.options + "`");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  671:      }
    #####:  672:    } else if (failed(addToPipeline(elt.innerPipeline, pm.nest(elt.name),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  673:                                    errorHandler))) {
    #####:  674:      return errorHandler("failed to add `" + elt.name + "` with options `" +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  675:                          elt.options + "` to inner pipeline");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  676:    }
        -:  677:  }
     2128:  678:  return success();
        -:  679:}
        -:  680:
function _ZN4mlir17parsePassPipelineEN4llvm9StringRefERNS_13OpPassManagerERNS0_11raw_ostreamE called 2128 returned 100% blocks executed 78%
     2128:  681:LogicalResult mlir::parsePassPipeline(StringRef pipeline, OpPassManager &pm,
        -:  682:                                      raw_ostream &errorStream) {
     2128:  683:  TextualPipeline pipelineParser;
call    0 returned 100%
     2128:  684:  if (failed(pipelineParser.initialize(pipeline, errorStream)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  685:    return failure();
    2128*:  686:  auto errorHandler = [&](Twine msg) {
    #####:  687:    errorStream << msg << "\n";
call    0 never executed
call    1 never executed
    #####:  688:    return failure();
     2128:  689:  };
     2128:  690:  if (failed(pipelineParser.addToPipeline(pm, errorHandler)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  691:    return failure();
     2128:  692:  return success();
call    0 returned 100%
        -:  693:}
        -:  694:
function _ZN4mlir17parsePassPipelineEN4llvm9StringRefERNS0_11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  695:FailureOr<OpPassManager> mlir::parsePassPipeline(StringRef pipeline,
        -:  696:                                                 raw_ostream &errorStream) {
        -:  697:  // Pipelines are expected to be of the form `<op-name>(<pipeline>)`.
    #####:  698:  size_t pipelineStart = pipeline.find_first_of('(');
branch  0 never executed
branch  1 never executed
    #####:  699:  if (pipelineStart == 0 || pipelineStart == StringRef::npos ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  700:      !pipeline.consume_back(")")) {
call    0 never executed
    #####:  701:    errorStream << "expected pass pipeline to be wrapped with the anchor "
    #####:  702:                   "operation type, e.g. 'builtin.module(...)'";
call    0 never executed
    #####:  703:    return failure();
        -:  704:  }
        -:  705:
    #####:  706:  StringRef opName = pipeline.take_front(pipelineStart);
branch  0 never executed
branch  1 never executed
    #####:  707:  OpPassManager pm(opName);
call    0 never executed
    #####:  708:  if (failed(parsePassPipeline(pipeline.drop_front(1 + pipelineStart), pm,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  709:                               errorStream)))
    #####:  710:    return failure();
    #####:  711:  return pm;
call    0 never executed
call    1 never executed
        -:  712:}
        -:  713:
        -:  714://===----------------------------------------------------------------------===//
        -:  715:// PassNameParser
        -:  716://===----------------------------------------------------------------------===//
        -:  717:
        -:  718:namespace {
        -:  719:/// This struct represents the possible data entries in a parsed pass pipeline
        -:  720:/// list.
1136969405*:  721:struct PassArgData {
call    0 never executed
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 never executed
call    5 never executed
call    6 returned 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
call   11 returned 100%
call   12 returned 100%
call   13 returned 100%
 2745709*:  722:  PassArgData() = default;
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
292030908:  723:  PassArgData(const PassRegistryEntry *registryEntry)
292030908:  724:      : registryEntry(registryEntry) {}
call    0 returned 100%
call    1 returned 100%
        -:  725:
        -:  726:  /// This field is used when the parsed option corresponds to a registered pass
        -:  727:  /// or pass pipeline.
        -:  728:  const PassRegistryEntry *registryEntry{nullptr};
        -:  729:
        -:  730:  /// This field is set when instance specific pass options have been provided
        -:  731:  /// on the command line.
        -:  732:  StringRef options;
        -:  733:
        -:  734:  /// This field is used when the parsed option corresponds to an explicit
        -:  735:  /// pipeline.
        -:  736:  TextualPipeline pipeline;
        -:  737:};
        -:  738:} // namespace
        -:  739:
        -:  740:namespace llvm {
        -:  741:namespace cl {
        -:  742:/// Define a valid OptionValue for the command line pass argument.
        -:  743:template <>
1918848024*:  744:struct OptionValue<PassArgData> final
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 never executed
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
        -:  745:    : OptionValueBase<PassArgData, /*isClass=*/true> {
293007600*:  746:  OptionValue(const PassArgData &value) { this->setValue(value); }
call    0 never executed
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  747:  OptionValue() = default;
function _ZN4llvm2cl11OptionValueIN12_GLOBAL__N_111PassArgDataEE6anchorEv called 0 returned 0% blocks executed 0%
    #####:  748:  void anchor() override {}
        -:  749:
        -:  750:  bool hasValue() const { return true; }
  792325*:  751:  const PassArgData &getValue() const { return value; }
call    0 never executed
call    1 returned 100%
293007600*:  752:  void setValue(const PassArgData &value) { this->value = value; }
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
        -:  753:
        -:  754:  PassArgData value;
        -:  755:};
        -:  756:} // namespace cl
        -:  757:} // namespace llvm
        -:  758:
        -:  759:namespace {
        -:  760:
        -:  761:/// The name for the command line option used for parsing the textual pass
        -:  762:/// pipeline.
        -:  763:static constexpr StringLiteral passPipelineArg = "pass-pipeline";
        -:  764:
        -:  765:/// Adds command line option for each registered pass or pass pipeline, as well
        -:  766:/// as textual pass pipelines.
        -:  767:struct PassNameParser : public llvm::cl::parser<PassArgData> {
   976692:  768:  PassNameParser(llvm::cl::Option &opt) : llvm::cl::parser<PassArgData>(opt) {}
call    0 returned 100%
        -:  769:
        -:  770:  void initialize();
        -:  771:  void printOptionInfo(const llvm::cl::Option &opt,
        -:  772:                       size_t globalWidth) const override;
        -:  773:  size_t getOptionWidth(const llvm::cl::Option &opt) const override;
        -:  774:  bool parse(llvm::cl::Option &opt, StringRef argName, StringRef arg,
        -:  775:             PassArgData &value);
        -:  776:
        -:  777:  /// If true, this parser only parses entries that correspond to a concrete
        -:  778:  /// pass registry entry, and does not add a `pass-pipeline` argument, does not
        -:  779:  /// include the options for pass entries, and does not include pass pipelines
        -:  780:  /// entries.
        -:  781:  bool passNamesOnly = false;
        -:  782:};
        -:  783:} // namespace
        -:  784:
function _ZN12_GLOBAL__N_114PassNameParser10initializeEv called 976692 returned 100% blocks executed 94%
   976692:  785:void PassNameParser::initialize() {
   976692:  786:  llvm::cl::parser<PassArgData>::initialize();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  787:
        -:  788:  /// Add an entry for the textual pass pipeline option.
   976692:  789:  if (!passNamesOnly) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   976692:  790:    addLiteralOption(passPipelineArg, PassArgData(),
call    0 returned 100%
call    1 returned 100%
        -:  791:                     "A textual description of a pass pipeline to run");
        -:  792:  }
        -:  793:
        -:  794:  /// Add the pass entries.
290077524:  795:  for (const auto &kv : *passRegistry) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
call    5 returned 100%
288124140:  796:    addLiteralOption(kv.second.getPassArgument(), &kv.second,
call    0 returned 100%
        -:  797:                     kv.second.getPassDescription());
        -:  798:  }
        -:  799:  /// Add the pass pipeline entries.
   976692:  800:  if (!passNamesOnly) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  5860152:  801:    for (const auto &kv : *passPipelineRegistry) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 80% (fallthrough)
branch  4 taken 20%
call    5 returned 100%
  3906768:  802:      addLiteralOption(kv.second.getPassArgument(), &kv.second,
call    0 returned 100%
        -:  803:                       kv.second.getPassDescription());
        -:  804:    }
        -:  805:  }
   976692:  806:}
        -:  807:
function _ZNK12_GLOBAL__N_114PassNameParser15printOptionInfoERKN4llvm2cl6OptionEm called 0 returned 0% blocks executed 0%
    #####:  808:void PassNameParser::printOptionInfo(const llvm::cl::Option &opt,
        -:  809:                                     size_t globalWidth) const {
        -:  810:  // If this parser is just parsing pass names, print a simplified option
        -:  811:  // string.
    #####:  812:  if (passNamesOnly) {
branch  0 never executed
branch  1 never executed
    #####:  813:    llvm::outs() << "  --" << opt.ArgStr << "=<pass-arg>";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  814:    opt.printHelpStr(opt.HelpStr, globalWidth, opt.ArgStr.size() + 18);
call    0 never executed
    #####:  815:    return;
        -:  816:  }
        -:  817:
        -:  818:  // Print the information for the top-level option.
    #####:  819:  if (opt.hasArgStr()) {
branch  0 never executed
branch  1 never executed
    #####:  820:    llvm::outs() << "  --" << opt.ArgStr;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  821:    opt.printHelpStr(opt.HelpStr, globalWidth, opt.ArgStr.size() + 7);
call    0 never executed
        -:  822:  } else {
    #####:  823:    llvm::outs() << "  " << opt.HelpStr << '\n';
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  824:  }
        -:  825:
        -:  826:  // Print the top-level pipeline argument.
    #####:  827:  printOptionHelp(passPipelineArg,
call    0 never executed
        -:  828:                  "A textual description of a pass pipeline to run",
    #####:  829:                  /*indent=*/4, globalWidth, /*isTopLevel=*/!opt.hasArgStr());
call    0 never executed
        -:  830:
        -:  831:  // Functor used to print the ordered entries of a registration map.
    #####:  832:  auto printOrderedEntries = [&](StringRef header, auto &map) {
    #####:  833:    llvm::SmallVector<PassRegistryEntry *, 32> orderedEntries;
    #####:  834:    for (auto &kv : map)
    #####:  835:      orderedEntries.push_back(&kv.second);
    #####:  836:    llvm::array_pod_sort(
        -:  837:        orderedEntries.begin(), orderedEntries.end(),
        -:  838:        [](PassRegistryEntry *const *lhs, PassRegistryEntry *const *rhs) {
        -:  839:          return (*lhs)->getPassArgument().compare((*rhs)->getPassArgument());
        -:  840:        });
        -:  841:
    #####:  842:    llvm::outs().indent(4) << header << ":\n";
    #####:  843:    for (PassRegistryEntry *entry : orderedEntries)
    #####:  844:      entry->printHelpStr(/*indent=*/6, globalWidth);
    #####:  845:  };
------------------
_ZZNK12_GLOBAL__N_114PassNameParser15printOptionInfoERKN4llvm2cl6OptionEmENKUlNS1_9StringRefERT_E_clINS1_9StringMapIN4mlir16PassPipelineInfoENS1_15MallocAllocatorEEEEEDaS6_S8_.isra.0:
function _ZZNK12_GLOBAL__N_114PassNameParser15printOptionInfoERKN4llvm2cl6OptionEmENKUlNS1_9StringRefERT_E_clINS1_9StringMapIN4mlir16PassPipelineInfoENS1_15MallocAllocatorEEEEEDaS6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  832:  auto printOrderedEntries = [&](StringRef header, auto &map) {
    #####:  833:    llvm::SmallVector<PassRegistryEntry *, 32> orderedEntries;
    #####:  834:    for (auto &kv : map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  835:      orderedEntries.push_back(&kv.second);
call    0 never executed
    #####:  836:    llvm::array_pod_sort(
branch  0 never executed
branch  1 never executed
        -:  837:        orderedEntries.begin(), orderedEntries.end(),
        -:  838:        [](PassRegistryEntry *const *lhs, PassRegistryEntry *const *rhs) {
        -:  839:          return (*lhs)->getPassArgument().compare((*rhs)->getPassArgument());
        -:  840:        });
        -:  841:
    #####:  842:    llvm::outs().indent(4) << header << ":\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  843:    for (PassRegistryEntry *entry : orderedEntries)
branch  0 never executed
branch  1 never executed
    #####:  844:      entry->printHelpStr(/*indent=*/6, globalWidth);
call    0 never executed
    #####:  845:  };
------------------
_ZZNK12_GLOBAL__N_114PassNameParser15printOptionInfoERKN4llvm2cl6OptionEmENKUlNS1_9StringRefERT_E_clINS1_9StringMapIN4mlir8PassInfoENS1_15MallocAllocatorEEEEEDaS6_S8_.isra.0:
function _ZZNK12_GLOBAL__N_114PassNameParser15printOptionInfoERKN4llvm2cl6OptionEmENKUlNS1_9StringRefERT_E_clINS1_9StringMapIN4mlir8PassInfoENS1_15MallocAllocatorEEEEEDaS6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  832:  auto printOrderedEntries = [&](StringRef header, auto &map) {
    #####:  833:    llvm::SmallVector<PassRegistryEntry *, 32> orderedEntries;
    #####:  834:    for (auto &kv : map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  835:      orderedEntries.push_back(&kv.second);
call    0 never executed
    #####:  836:    llvm::array_pod_sort(
branch  0 never executed
branch  1 never executed
        -:  837:        orderedEntries.begin(), orderedEntries.end(),
        -:  838:        [](PassRegistryEntry *const *lhs, PassRegistryEntry *const *rhs) {
        -:  839:          return (*lhs)->getPassArgument().compare((*rhs)->getPassArgument());
        -:  840:        });
        -:  841:
    #####:  842:    llvm::outs().indent(4) << header << ":\n";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  843:    for (PassRegistryEntry *entry : orderedEntries)
branch  0 never executed
branch  1 never executed
    #####:  844:      entry->printHelpStr(/*indent=*/6, globalWidth);
call    0 never executed
    #####:  845:  };
------------------
        -:  846:
        -:  847:  // Print the available passes.
    #####:  848:  printOrderedEntries("Passes", *passRegistry);
call    0 never executed
call    1 never executed
        -:  849:
        -:  850:  // Print the available pass pipelines.
    #####:  851:  if (!passPipelineRegistry->empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  852:    printOrderedEntries("Pass Pipelines", *passPipelineRegistry);
call    0 never executed
call    1 never executed
        -:  853:}
        -:  854:
function _ZNK12_GLOBAL__N_114PassNameParser14getOptionWidthERKN4llvm2cl6OptionE called 0 returned 0% blocks executed 0%
    #####:  855:size_t PassNameParser::getOptionWidth(const llvm::cl::Option &opt) const {
    #####:  856:  size_t maxWidth = llvm::cl::parser<PassArgData>::getOptionWidth(opt) + 2;
call    0 never executed
        -:  857:
        -:  858:  // Check for any wider pass or pipeline options.
    #####:  859:  for (auto &entry : *passRegistry)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  860:    maxWidth = std::max(maxWidth, entry.second.getOptionWidth() + 4);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  861:  for (auto &entry : *passPipelineRegistry)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  862:    maxWidth = std::max(maxWidth, entry.second.getOptionWidth() + 4);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  863:  return maxWidth;
        -:  864:}
        -:  865:
function _ZN12_GLOBAL__N_114PassNameParser5parseERN4llvm2cl6OptionENS1_9StringRefES5_RNS_11PassArgDataE called 792325 returned 100% blocks executed 67%
   792325:  866:bool PassNameParser::parse(llvm::cl::Option &opt, StringRef argName,
        -:  867:                           StringRef arg, PassArgData &value) {
        -:  868:  // Handle the pipeline option explicitly.
  792325*:  869:  if (argName == passPipelineArg)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    #####:  870:    return failed(value.pipeline.initialize(arg, llvm::errs()));
call    0 never executed
call    1 never executed
        -:  871:
        -:  872:  // Otherwise, default to the base for handling.
   792325:  873:  if (llvm::cl::parser<PassArgData>::parse(opt, argName, arg, value))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  874:    return true;
   792325:  875:  value.options = arg;
   792325:  876:  return false;
        -:  877:}
        -:  878:
        -:  879://===----------------------------------------------------------------------===//
        -:  880:// PassPipelineCLParser
        -:  881://===----------------------------------------------------------------------===//
        -:  882:
        -:  883:namespace mlir {
        -:  884:namespace detail {
        -:  885:struct PassPipelineCLParserImpl {
        -:  886:  PassPipelineCLParserImpl(StringRef arg, StringRef description,
        -:  887:                           bool passNamesOnly)
        -:  888:      : passList(arg, llvm::cl::desc(description)) {
        -:  889:    passList.getParser().passNamesOnly = passNamesOnly;
        -:  890:    passList.setValueExpectedFlag(llvm::cl::ValueExpected::ValueOptional);
        -:  891:  }
        -:  892:
        -:  893:  /// Returns true if the given pass registry entry was registered at the
        -:  894:  /// top-level of the parser, i.e. not within an explicit textual pipeline.
    #####:  895:  bool contains(const PassRegistryEntry *entry) const {
    #####:  896:    return llvm::any_of(passList, [&](const PassArgData &data) {
call    0 never executed
call    1 never executed
        -:  897:      return data.registryEntry == entry;
        -:  898:    });
        -:  899:  }
        -:  900:
        -:  901:  /// The set of passes and pass pipelines to run.
        -:  902:  llvm::cl::list<PassArgData, bool, PassNameParser> passList;
        -:  903:};
        -:  904:} // namespace detail
        -:  905:} // namespace mlir
        -:  906:
        -:  907:/// Construct a pass pipeline parser with the given command line description.
function _ZN4mlir20PassPipelineCLParserC2EN4llvm9StringRefES2_ called 325564 returned 100% blocks executed 100%
   325564:  908:PassPipelineCLParser::PassPipelineCLParser(StringRef arg, StringRef description)
        -:  909:    : impl(std::make_unique<detail::PassPipelineCLParserImpl>(
   325564:  910:          arg, description, /*passNamesOnly=*/false)) {}
call    0 returned 100%
        -:  911:PassPipelineCLParser::~PassPipelineCLParser() = default;
        -:  912:
        -:  913:/// Returns true if this parser contains any valid options to add.
function _ZNK4mlir20PassPipelineCLParser17hasAnyOccurrencesEv called 0 returned 0% blocks executed 0%
    #####:  914:bool PassPipelineCLParser::hasAnyOccurrences() const {
    #####:  915:  return impl->passList.getNumOccurrences() != 0;
        -:  916:}
        -:  917:
        -:  918:/// Returns true if the given pass registry entry was registered at the
        -:  919:/// top-level of the parser, i.e. not within an explicit textual pipeline.
function _ZNK4mlir20PassPipelineCLParser8containsEPKNS_17PassRegistryEntryE called 0 returned 0% blocks executed 0%
    #####:  920:bool PassPipelineCLParser::contains(const PassRegistryEntry *entry) const {
    #####:  921:  return impl->contains(entry);
call    0 never executed
        -:  922:}
        -:  923:
        -:  924:/// Adds the passes defined by this parser entry to the given pass manager.
function _ZNK4mlir20PassPipelineCLParser13addToPipelineERNS_13OpPassManagerEN4llvm12function_refIFNS_13LogicalResultERKNS3_5TwineEEEE called 171750 returned 100% blocks executed 53%
   171750:  925:LogicalResult PassPipelineCLParser::addToPipeline(
        -:  926:    OpPassManager &pm,
        -:  927:    function_ref<LogicalResult(const Twine &)> errorHandler) const {
   471184:  928:  for (auto &passIt : impl->passList) {
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   299434:  929:    if (passIt.registryEntry) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   299434:  930:      if (failed(passIt.registryEntry->addToPipeline(pm, passIt.options,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  931:                                                     errorHandler)))
    #####:  932:        return failure();
        -:  933:    } else {
    #####:  934:      OpPassManager::Nesting nesting = pm.getNesting();
call    0 never executed
    #####:  935:      pm.setNesting(OpPassManager::Nesting::Explicit);
call    0 never executed
    #####:  936:      LogicalResult status = passIt.pipeline.addToPipeline(pm, errorHandler);
call    0 never executed
    #####:  937:      pm.setNesting(nesting);
call    0 never executed
    #####:  938:      if (failed(status))
branch  0 never executed
branch  1 never executed
    #####:  939:        return failure();
        -:  940:    }
        -:  941:  }
   171750:  942:  return success();
        -:  943:}
        -:  944:
        -:  945://===----------------------------------------------------------------------===//
        -:  946:// PassNameCLParser
        -:  947:
        -:  948:/// Construct a pass pipeline parser with the given command line description.
function _ZN4mlir16PassNameCLParserC2EN4llvm9StringRefES2_ called 651128 returned 100% blocks executed 100%
   651128:  949:PassNameCLParser::PassNameCLParser(StringRef arg, StringRef description)
        -:  950:    : impl(std::make_unique<detail::PassPipelineCLParserImpl>(
   651128:  951:          arg, description, /*passNamesOnly=*/true)) {
call    0 returned 100%
   651128:  952:  impl->passList.setMiscFlag(llvm::cl::CommaSeparated);
   651128:  953:}
        -:  954:PassNameCLParser::~PassNameCLParser() = default;
        -:  955:
        -:  956:/// Returns true if this parser contains any valid options to add.
function _ZNK4mlir16PassNameCLParser17hasAnyOccurrencesEv called 340385 returned 100% blocks executed 100%
   340385:  957:bool PassNameCLParser::hasAnyOccurrences() const {
   340385:  958:  return impl->passList.getNumOccurrences() != 0;
        -:  959:}
        -:  960:
        -:  961:/// Returns true if the given pass registry entry was registered at the
        -:  962:/// top-level of the parser, i.e. not within an explicit textual pipeline.
function _ZNK4mlir16PassNameCLParser8containsEPKNS_17PassRegistryEntryE called 0 returned 0% blocks executed 0%
    #####:  963:bool PassNameCLParser::contains(const PassRegistryEntry *entry) const {
    #####:  964:  return impl->contains(entry);
call    0 never executed
        -:  965:}
