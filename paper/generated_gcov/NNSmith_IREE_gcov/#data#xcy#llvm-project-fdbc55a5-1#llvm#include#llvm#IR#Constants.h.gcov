        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/IR/Constants.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:325580
        -:    1://===-- llvm/Constants.h - Constant class subclass definitions --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:/// @file
        -:   10:/// This file contains the declarations for the subclasses of Constant,
        -:   11:/// which represent the different flavors of constant values that live in LLVM.
        -:   12:/// Note that Constants are immutable (once created they never change) and are
        -:   13:/// fully shared by structural equivalence.  This means that two structurally
        -:   14:/// equivalent constants will always have the same address.  Constants are
        -:   15:/// created on demand as needed and never deleted: thus clients don't have to
        -:   16:/// worry about the lifetime of the objects.
        -:   17://
        -:   18://===----------------------------------------------------------------------===//
        -:   19:
        -:   20:#ifndef LLVM_IR_CONSTANTS_H
        -:   21:#define LLVM_IR_CONSTANTS_H
        -:   22:
        -:   23:#include "llvm/ADT/APFloat.h"
        -:   24:#include "llvm/ADT/APInt.h"
        -:   25:#include "llvm/ADT/ArrayRef.h"
        -:   26:#include "llvm/ADT/None.h"
        -:   27:#include "llvm/ADT/Optional.h"
        -:   28:#include "llvm/ADT/STLExtras.h"
        -:   29:#include "llvm/ADT/StringRef.h"
        -:   30:#include "llvm/IR/Constant.h"
        -:   31:#include "llvm/IR/DerivedTypes.h"
        -:   32:#include "llvm/IR/OperandTraits.h"
        -:   33:#include "llvm/IR/User.h"
        -:   34:#include "llvm/IR/Value.h"
        -:   35:#include "llvm/Support/Casting.h"
        -:   36:#include "llvm/Support/Compiler.h"
        -:   37:#include "llvm/Support/ErrorHandling.h"
        -:   38:#include <cassert>
        -:   39:#include <cstddef>
        -:   40:#include <cstdint>
        -:   41:
        -:   42:namespace llvm {
        -:   43:
        -:   44:template <class ConstantClass> struct ConstantAggrKeyType;
        -:   45:
        -:   46:/// Base class for constants with no operands.
        -:   47:///
        -:   48:/// These constants have no operands; they represent their data directly.
        -:   49:/// Since they can be in use by unrelated modules (and are never based on
        -:   50:/// GlobalValues), it never makes sense to RAUW them.
        -:   51:class ConstantData : public Constant {
        -:   52:  friend class Constant;
        -:   53:
        -:   54:  Value *handleOperandChangeImpl(Value *From, Value *To) {
        -:   55:    llvm_unreachable("Constant data does not have operands!");
        -:   56:  }
        -:   57:
        -:   58:protected:
        -:   59:  explicit ConstantData(Type *Ty, ValueTy VT) : Constant(Ty, VT, nullptr, 0) {}
        -:   60:
        -:   61:  void *operator new(size_t S) { return User::operator new(S, 0); }
        -:   62:
        -:   63:public:
        -:   64:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:   65:
        -:   66:  ConstantData(const ConstantData &) = delete;
        -:   67:
        -:   68:  /// Methods to support type inquiry through isa, cast, and dyn_cast.
        -:   69:  static bool classof(const Value *V) {
        -:   70:    return V->getValueID() >= ConstantDataFirstVal &&
        -:   71:           V->getValueID() <= ConstantDataLastVal;
        -:   72:  }
        -:   73:};
        -:   74:
        -:   75://===----------------------------------------------------------------------===//
        -:   76:/// This is the shared class of boolean and integer constants. This class
        -:   77:/// represents both boolean and integral constants.
        -:   78:/// Class for constant integers.
        -:   79:class ConstantInt final : public ConstantData {
        -:   80:  friend class Constant;
        -:   81:
        -:   82:  APInt Val;
        -:   83:
        -:   84:  ConstantInt(IntegerType *Ty, const APInt &V);
        -:   85:
        -:   86:  void destroyConstantImpl();
        -:   87:
        -:   88:public:
        -:   89:  ConstantInt(const ConstantInt &) = delete;
        -:   90:
        -:   91:  static ConstantInt *getTrue(LLVMContext &Context);
        -:   92:  static ConstantInt *getFalse(LLVMContext &Context);
        -:   93:  static ConstantInt *getBool(LLVMContext &Context, bool V);
        -:   94:  static Constant *getTrue(Type *Ty);
        -:   95:  static Constant *getFalse(Type *Ty);
        -:   96:  static Constant *getBool(Type *Ty, bool V);
        -:   97:
        -:   98:  /// If Ty is a vector type, return a Constant with a splat of the given
        -:   99:  /// value. Otherwise return a ConstantInt for the given value.
        -:  100:  static Constant *get(Type *Ty, uint64_t V, bool IsSigned = false);
        -:  101:
        -:  102:  /// Return a ConstantInt with the specified integer value for the specified
        -:  103:  /// type. If the type is wider than 64 bits, the value will be zero-extended
        -:  104:  /// to fit the type, unless IsSigned is true, in which case the value will
        -:  105:  /// be interpreted as a 64-bit signed integer and sign-extended to fit
        -:  106:  /// the type.
        -:  107:  /// Get a ConstantInt for a specific value.
        -:  108:  static ConstantInt *get(IntegerType *Ty, uint64_t V, bool IsSigned = false);
        -:  109:
        -:  110:  /// Return a ConstantInt with the specified value for the specified type. The
        -:  111:  /// value V will be canonicalized to a an unsigned APInt. Accessing it with
        -:  112:  /// either getSExtValue() or getZExtValue() will yield a correctly sized and
        -:  113:  /// signed value for the type Ty.
        -:  114:  /// Get a ConstantInt for a specific signed value.
        -:  115:  static ConstantInt *getSigned(IntegerType *Ty, int64_t V);
        -:  116:  static Constant *getSigned(Type *Ty, int64_t V);
        -:  117:
        -:  118:  /// Return a ConstantInt with the specified value and an implied Type. The
        -:  119:  /// type is the integer type that corresponds to the bit width of the value.
        -:  120:  static ConstantInt *get(LLVMContext &Context, const APInt &V);
        -:  121:
        -:  122:  /// Return a ConstantInt constructed from the string strStart with the given
        -:  123:  /// radix.
        -:  124:  static ConstantInt *get(IntegerType *Ty, StringRef Str, uint8_t Radix);
        -:  125:
        -:  126:  /// If Ty is a vector type, return a Constant with a splat of the given
        -:  127:  /// value. Otherwise return a ConstantInt for the given value.
        -:  128:  static Constant *get(Type *Ty, const APInt &V);
        -:  129:
        -:  130:  /// Return the constant as an APInt value reference. This allows clients to
        -:  131:  /// obtain a full-precision copy of the value.
        -:  132:  /// Return the constant's value.
        -:  133:  inline const APInt &getValue() const { return Val; }
        -:  134:
        -:  135:  /// getBitWidth - Return the bitwidth of this constant.
        -:  136:  unsigned getBitWidth() const { return Val.getBitWidth(); }
        -:  137:
        -:  138:  /// Return the constant as a 64-bit unsigned integer value after it
        -:  139:  /// has been zero extended as appropriate for the type of this constant. Note
        -:  140:  /// that this method can assert if the value does not fit in 64 bits.
        -:  141:  /// Return the zero extended value.
        -:  142:  inline uint64_t getZExtValue() const { return Val.getZExtValue(); }
        -:  143:
        -:  144:  /// Return the constant as a 64-bit integer value after it has been sign
        -:  145:  /// extended as appropriate for the type of this constant. Note that
        -:  146:  /// this method can assert if the value does not fit in 64 bits.
        -:  147:  /// Return the sign extended value.
        -:  148:  inline int64_t getSExtValue() const { return Val.getSExtValue(); }
        -:  149:
        -:  150:  /// Return the constant as an llvm::MaybeAlign.
        -:  151:  /// Note that this method can assert if the value does not fit in 64 bits or
        -:  152:  /// is not a power of two.
        -:  153:  inline MaybeAlign getMaybeAlignValue() const {
        -:  154:    return MaybeAlign(getZExtValue());
        -:  155:  }
        -:  156:
        -:  157:  /// Return the constant as an llvm::Align, interpreting `0` as `Align(1)`.
        -:  158:  /// Note that this method can assert if the value does not fit in 64 bits or
        -:  159:  /// is not a power of two.
        -:  160:  inline Align getAlignValue() const {
        -:  161:    return getMaybeAlignValue().valueOrOne();
        -:  162:  }
        -:  163:
        -:  164:  /// A helper method that can be used to determine if the constant contained
        -:  165:  /// within is equal to a constant.  This only works for very small values,
        -:  166:  /// because this is all that can be represented with all types.
        -:  167:  /// Determine if this constant's value is same as an unsigned char.
        -:  168:  bool equalsInt(uint64_t V) const { return Val == V; }
        -:  169:
        -:  170:  /// getType - Specialize the getType() method to always return an IntegerType,
        -:  171:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  172:  ///
        -:  173:  inline IntegerType *getType() const {
        -:  174:    return cast<IntegerType>(Value::getType());
        -:  175:  }
        -:  176:
        -:  177:  /// This static method returns true if the type Ty is big enough to
        -:  178:  /// represent the value V. This can be used to avoid having the get method
        -:  179:  /// assert when V is larger than Ty can represent. Note that there are two
        -:  180:  /// versions of this method, one for unsigned and one for signed integers.
        -:  181:  /// Although ConstantInt canonicalizes everything to an unsigned integer,
        -:  182:  /// the signed version avoids callers having to convert a signed quantity
        -:  183:  /// to the appropriate unsigned type before calling the method.
        -:  184:  /// @returns true if V is a valid value for type Ty
        -:  185:  /// Determine if the value is in range for the given type.
        -:  186:  static bool isValueValidForType(Type *Ty, uint64_t V);
        -:  187:  static bool isValueValidForType(Type *Ty, int64_t V);
        -:  188:
        -:  189:  bool isNegative() const { return Val.isNegative(); }
        -:  190:
        -:  191:  /// This is just a convenience method to make client code smaller for a
        -:  192:  /// common code. It also correctly performs the comparison without the
        -:  193:  /// potential for an assertion from getZExtValue().
        -:  194:  bool isZero() const { return Val.isZero(); }
        -:  195:
        -:  196:  /// This is just a convenience method to make client code smaller for a
        -:  197:  /// common case. It also correctly performs the comparison without the
        -:  198:  /// potential for an assertion from getZExtValue().
        -:  199:  /// Determine if the value is one.
        -:  200:  bool isOne() const { return Val.isOne(); }
        -:  201:
        -:  202:  /// This function will return true iff every bit in this constant is set
        -:  203:  /// to true.
        -:  204:  /// @returns true iff this constant's bits are all set to true.
        -:  205:  /// Determine if the value is all ones.
        -:  206:  bool isMinusOne() const { return Val.isAllOnes(); }
        -:  207:
        -:  208:  /// This function will return true iff this constant represents the largest
        -:  209:  /// value that may be represented by the constant's type.
        -:  210:  /// @returns true iff this is the largest value that may be represented
        -:  211:  /// by this type.
        -:  212:  /// Determine if the value is maximal.
        -:  213:  bool isMaxValue(bool IsSigned) const {
        -:  214:    if (IsSigned)
        -:  215:      return Val.isMaxSignedValue();
        -:  216:    else
        -:  217:      return Val.isMaxValue();
        -:  218:  }
        -:  219:
        -:  220:  /// This function will return true iff this constant represents the smallest
        -:  221:  /// value that may be represented by this constant's type.
        -:  222:  /// @returns true if this is the smallest value that may be represented by
        -:  223:  /// this type.
        -:  224:  /// Determine if the value is minimal.
        -:  225:  bool isMinValue(bool IsSigned) const {
        -:  226:    if (IsSigned)
        -:  227:      return Val.isMinSignedValue();
        -:  228:    else
        -:  229:      return Val.isMinValue();
        -:  230:  }
        -:  231:
        -:  232:  /// This function will return true iff this constant represents a value with
        -:  233:  /// active bits bigger than 64 bits or a value greater than the given uint64_t
        -:  234:  /// value.
        -:  235:  /// @returns true iff this constant is greater or equal to the given number.
        -:  236:  /// Determine if the value is greater or equal to the given number.
        -:  237:  bool uge(uint64_t Num) const { return Val.uge(Num); }
        -:  238:
        -:  239:  /// getLimitedValue - If the value is smaller than the specified limit,
        -:  240:  /// return it, otherwise return the limit value.  This causes the value
        -:  241:  /// to saturate to the limit.
        -:  242:  /// @returns the min of the value of the constant and the specified value
        -:  243:  /// Get the constant's value with a saturation limit
        -:  244:  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {
        -:  245:    return Val.getLimitedValue(Limit);
        -:  246:  }
        -:  247:
        -:  248:  /// Methods to support type inquiry through isa, cast, and dyn_cast.
        -:  249:  static bool classof(const Value *V) {
        -:  250:    return V->getValueID() == ConstantIntVal;
        -:  251:  }
        -:  252:};
        -:  253:
        -:  254://===----------------------------------------------------------------------===//
        -:  255:/// ConstantFP - Floating Point Values [float, double]
        -:  256:///
        -:  257:class ConstantFP final : public ConstantData {
        -:  258:  friend class Constant;
        -:  259:
        -:  260:  APFloat Val;
        -:  261:
        -:  262:  ConstantFP(Type *Ty, const APFloat &V);
        -:  263:
        -:  264:  void destroyConstantImpl();
        -:  265:
        -:  266:public:
        -:  267:  ConstantFP(const ConstantFP &) = delete;
        -:  268:
        -:  269:  /// Floating point negation must be implemented with f(x) = -0.0 - x. This
        -:  270:  /// method returns the negative zero constant for floating point or vector
        -:  271:  /// floating point types; for all other types, it returns the null value.
        -:  272:  static Constant *getZeroValueForNegation(Type *Ty);
        -:  273:
        -:  274:  /// This returns a ConstantFP, or a vector containing a splat of a ConstantFP,
        -:  275:  /// for the specified value in the specified type. This should only be used
        -:  276:  /// for simple constant values like 2.0/1.0 etc, that are known-valid both as
        -:  277:  /// host double and as the target format.
        -:  278:  static Constant *get(Type *Ty, double V);
        -:  279:
        -:  280:  /// If Ty is a vector type, return a Constant with a splat of the given
        -:  281:  /// value. Otherwise return a ConstantFP for the given value.
        -:  282:  static Constant *get(Type *Ty, const APFloat &V);
        -:  283:
        -:  284:  static Constant *get(Type *Ty, StringRef Str);
        -:  285:  static ConstantFP *get(LLVMContext &Context, const APFloat &V);
        -:  286:  static Constant *getNaN(Type *Ty, bool Negative = false,
        -:  287:                          uint64_t Payload = 0);
        -:  288:  static Constant *getQNaN(Type *Ty, bool Negative = false,
        -:  289:                           APInt *Payload = nullptr);
        -:  290:  static Constant *getSNaN(Type *Ty, bool Negative = false,
        -:  291:                           APInt *Payload = nullptr);
        -:  292:  static Constant *getZero(Type *Ty, bool Negative = false);
        -:  293:  static Constant *getNegativeZero(Type *Ty) { return getZero(Ty, true); }
        -:  294:  static Constant *getInfinity(Type *Ty, bool Negative = false);
        -:  295:
        -:  296:  /// Return true if Ty is big enough to represent V.
        -:  297:  static bool isValueValidForType(Type *Ty, const APFloat &V);
        -:  298:  inline const APFloat &getValueAPF() const { return Val; }
        -:  299:  inline const APFloat &getValue() const { return Val; }
        -:  300:
        -:  301:  /// Return true if the value is positive or negative zero.
        -:  302:  bool isZero() const { return Val.isZero(); }
        -:  303:
        -:  304:  /// Return true if the sign bit is set.
        -:  305:  bool isNegative() const { return Val.isNegative(); }
        -:  306:
        -:  307:  /// Return true if the value is infinity
        -:  308:  bool isInfinity() const { return Val.isInfinity(); }
        -:  309:
        -:  310:  /// Return true if the value is a NaN.
        -:  311:  bool isNaN() const { return Val.isNaN(); }
        -:  312:
        -:  313:  /// We don't rely on operator== working on double values, as it returns true
        -:  314:  /// for things that are clearly not equal, like -0.0 and 0.0.
        -:  315:  /// As such, this method can be used to do an exact bit-for-bit comparison of
        -:  316:  /// two floating point values.  The version with a double operand is retained
        -:  317:  /// because it's so convenient to write isExactlyValue(2.0), but please use
        -:  318:  /// it only for simple constants.
        -:  319:  bool isExactlyValue(const APFloat &V) const;
        -:  320:
        -:  321:  bool isExactlyValue(double V) const {
        -:  322:    bool ignored;
        -:  323:    APFloat FV(V);
        -:  324:    FV.convert(Val.getSemantics(), APFloat::rmNearestTiesToEven, &ignored);
        -:  325:    return isExactlyValue(FV);
        -:  326:  }
        -:  327:
        -:  328:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  329:  static bool classof(const Value *V) {
        -:  330:    return V->getValueID() == ConstantFPVal;
        -:  331:  }
        -:  332:};
        -:  333:
        -:  334://===----------------------------------------------------------------------===//
        -:  335:/// All zero aggregate value
        -:  336:///
        -:  337:class ConstantAggregateZero final : public ConstantData {
        -:  338:  friend class Constant;
        -:  339:
        -:  340:  explicit ConstantAggregateZero(Type *Ty)
        -:  341:      : ConstantData(Ty, ConstantAggregateZeroVal) {}
        -:  342:
        -:  343:  void destroyConstantImpl();
        -:  344:
        -:  345:public:
        -:  346:  ConstantAggregateZero(const ConstantAggregateZero &) = delete;
        -:  347:
        -:  348:  static ConstantAggregateZero *get(Type *Ty);
        -:  349:
        -:  350:  /// If this CAZ has array or vector type, return a zero with the right element
        -:  351:  /// type.
        -:  352:  Constant *getSequentialElement() const;
        -:  353:
        -:  354:  /// If this CAZ has struct type, return a zero with the right element type for
        -:  355:  /// the specified element.
        -:  356:  Constant *getStructElement(unsigned Elt) const;
        -:  357:
        -:  358:  /// Return a zero of the right value for the specified GEP index if we can,
        -:  359:  /// otherwise return null (e.g. if C is a ConstantExpr).
        -:  360:  Constant *getElementValue(Constant *C) const;
        -:  361:
        -:  362:  /// Return a zero of the right value for the specified GEP index.
        -:  363:  Constant *getElementValue(unsigned Idx) const;
        -:  364:
        -:  365:  /// Return the number of elements in the array, vector, or struct.
        -:  366:  ElementCount getElementCount() const;
        -:  367:
        -:  368:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  369:  ///
        -:  370:  static bool classof(const Value *V) {
        -:  371:    return V->getValueID() == ConstantAggregateZeroVal;
        -:  372:  }
        -:  373:};
        -:  374:
        -:  375:/// Base class for aggregate constants (with operands).
        -:  376:///
        -:  377:/// These constants are aggregates of other constants, which are stored as
        -:  378:/// operands.
        -:  379:///
        -:  380:/// Subclasses are \a ConstantStruct, \a ConstantArray, and \a
        -:  381:/// ConstantVector.
        -:  382:///
        -:  383:/// \note Some subclasses of \a ConstantData are semantically aggregates --
        -:  384:/// such as \a ConstantDataArray -- but are not subclasses of this because they
        -:  385:/// use operands.
        -:  386:class ConstantAggregate : public Constant {
        -:  387:protected:
        -:  388:  ConstantAggregate(Type *T, ValueTy VT, ArrayRef<Constant *> V);
        -:  389:
        -:  390:public:
        -:  391:  /// Transparently provide more efficient getOperand methods.
        -:  392:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);
        -:  393:
        -:  394:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  395:  static bool classof(const Value *V) {
        -:  396:    return V->getValueID() >= ConstantAggregateFirstVal &&
        -:  397:           V->getValueID() <= ConstantAggregateLastVal;
        -:  398:  }
        -:  399:};
        -:  400:
        -:  401:template <>
        -:  402:struct OperandTraits<ConstantAggregate>
        -:  403:    : public VariadicOperandTraits<ConstantAggregate> {};
        -:  404:
        -:  405:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantAggregate, Constant)
        -:  406:
        -:  407://===----------------------------------------------------------------------===//
        -:  408:/// ConstantArray - Constant Array Declarations
        -:  409:///
        -:  410:class ConstantArray final : public ConstantAggregate {
        -:  411:  friend struct ConstantAggrKeyType<ConstantArray>;
        -:  412:  friend class Constant;
        -:  413:
        -:  414:  ConstantArray(ArrayType *T, ArrayRef<Constant *> Val);
        -:  415:
        -:  416:  void destroyConstantImpl();
        -:  417:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  418:
        -:  419:public:
        -:  420:  // ConstantArray accessors
        -:  421:  static Constant *get(ArrayType *T, ArrayRef<Constant *> V);
        -:  422:
        -:  423:private:
        -:  424:  static Constant *getImpl(ArrayType *T, ArrayRef<Constant *> V);
        -:  425:
        -:  426:public:
        -:  427:  /// Specialize the getType() method to always return an ArrayType,
        -:  428:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  429:  inline ArrayType *getType() const {
        -:  430:    return cast<ArrayType>(Value::getType());
        -:  431:  }
        -:  432:
        -:  433:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  434:  static bool classof(const Value *V) {
        -:  435:    return V->getValueID() == ConstantArrayVal;
        -:  436:  }
        -:  437:};
        -:  438:
        -:  439://===----------------------------------------------------------------------===//
        -:  440:// Constant Struct Declarations
        -:  441://
        -:  442:class ConstantStruct final : public ConstantAggregate {
        -:  443:  friend struct ConstantAggrKeyType<ConstantStruct>;
        -:  444:  friend class Constant;
        -:  445:
        -:  446:  ConstantStruct(StructType *T, ArrayRef<Constant *> Val);
        -:  447:
        -:  448:  void destroyConstantImpl();
        -:  449:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  450:
        -:  451:public:
        -:  452:  // ConstantStruct accessors
        -:  453:  static Constant *get(StructType *T, ArrayRef<Constant *> V);
        -:  454:
        -:  455:  template <typename... Csts>
        -:  456:  static std::enable_if_t<are_base_of<Constant, Csts...>::value, Constant *>
        -:  457:  get(StructType *T, Csts *...Vs) {
        -:  458:    return get(T, ArrayRef<Constant *>({Vs...}));
        -:  459:  }
        -:  460:
        -:  461:  /// Return an anonymous struct that has the specified elements.
        -:  462:  /// If the struct is possibly empty, then you must specify a context.
        -:  463:  static Constant *getAnon(ArrayRef<Constant *> V, bool Packed = false) {
        -:  464:    return get(getTypeForElements(V, Packed), V);
        -:  465:  }
        -:  466:  static Constant *getAnon(LLVMContext &Ctx, ArrayRef<Constant *> V,
        -:  467:                           bool Packed = false) {
        -:  468:    return get(getTypeForElements(Ctx, V, Packed), V);
        -:  469:  }
        -:  470:
        -:  471:  /// Return an anonymous struct type to use for a constant with the specified
        -:  472:  /// set of elements. The list must not be empty.
        -:  473:  static StructType *getTypeForElements(ArrayRef<Constant *> V,
        -:  474:                                        bool Packed = false);
        -:  475:  /// This version of the method allows an empty list.
        -:  476:  static StructType *getTypeForElements(LLVMContext &Ctx,
        -:  477:                                        ArrayRef<Constant *> V,
        -:  478:                                        bool Packed = false);
        -:  479:
        -:  480:  /// Specialization - reduce amount of casting.
        -:  481:  inline StructType *getType() const {
        -:  482:    return cast<StructType>(Value::getType());
        -:  483:  }
        -:  484:
        -:  485:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  486:  static bool classof(const Value *V) {
        -:  487:    return V->getValueID() == ConstantStructVal;
        -:  488:  }
        -:  489:};
        -:  490:
        -:  491://===----------------------------------------------------------------------===//
        -:  492:/// Constant Vector Declarations
        -:  493:///
        -:  494:class ConstantVector final : public ConstantAggregate {
        -:  495:  friend struct ConstantAggrKeyType<ConstantVector>;
        -:  496:  friend class Constant;
        -:  497:
        -:  498:  ConstantVector(VectorType *T, ArrayRef<Constant *> Val);
        -:  499:
        -:  500:  void destroyConstantImpl();
        -:  501:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  502:
        -:  503:public:
        -:  504:  // ConstantVector accessors
        -:  505:  static Constant *get(ArrayRef<Constant *> V);
        -:  506:
        -:  507:private:
        -:  508:  static Constant *getImpl(ArrayRef<Constant *> V);
        -:  509:
        -:  510:public:
        -:  511:  /// Return a ConstantVector with the specified constant in each element.
        -:  512:  /// Note that this might not return an instance of ConstantVector
        -:  513:  static Constant *getSplat(ElementCount EC, Constant *Elt);
        -:  514:
        -:  515:  /// Specialize the getType() method to always return a FixedVectorType,
        -:  516:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  517:  inline FixedVectorType *getType() const {
        -:  518:    return cast<FixedVectorType>(Value::getType());
        -:  519:  }
        -:  520:
        -:  521:  /// If all elements of the vector constant have the same value, return that
        -:  522:  /// value. Otherwise, return nullptr. Ignore undefined elements by setting
        -:  523:  /// AllowUndefs to true.
        -:  524:  Constant *getSplatValue(bool AllowUndefs = false) const;
        -:  525:
        -:  526:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  527:  static bool classof(const Value *V) {
        -:  528:    return V->getValueID() == ConstantVectorVal;
        -:  529:  }
        -:  530:};
        -:  531:
        -:  532://===----------------------------------------------------------------------===//
        -:  533:/// A constant pointer value that points to null
        -:  534:///
        -:  535:class ConstantPointerNull final : public ConstantData {
        -:  536:  friend class Constant;
        -:  537:
        -:  538:  explicit ConstantPointerNull(PointerType *T)
        -:  539:      : ConstantData(T, Value::ConstantPointerNullVal) {}
        -:  540:
        -:  541:  void destroyConstantImpl();
        -:  542:
        -:  543:public:
        -:  544:  ConstantPointerNull(const ConstantPointerNull &) = delete;
        -:  545:
        -:  546:  /// Static factory methods - Return objects of the specified value
        -:  547:  static ConstantPointerNull *get(PointerType *T);
        -:  548:
        -:  549:  /// Specialize the getType() method to always return an PointerType,
        -:  550:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  551:  inline PointerType *getType() const {
        -:  552:    return cast<PointerType>(Value::getType());
        -:  553:  }
        -:  554:
        -:  555:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  556:  static bool classof(const Value *V) {
        -:  557:    return V->getValueID() == ConstantPointerNullVal;
        -:  558:  }
        -:  559:};
        -:  560:
        -:  561://===----------------------------------------------------------------------===//
        -:  562:/// ConstantDataSequential - A vector or array constant whose element type is a
        -:  563:/// simple 1/2/4/8-byte integer or half/bfloat/float/double, and whose elements
        -:  564:/// are just simple data values (i.e. ConstantInt/ConstantFP).  This Constant
        -:  565:/// node has no operands because it stores all of the elements of the constant
        -:  566:/// as densely packed data, instead of as Value*'s.
        -:  567:///
        -:  568:/// This is the common base class of ConstantDataArray and ConstantDataVector.
        -:  569:///
        -:  570:class ConstantDataSequential : public ConstantData {
        -:  571:  friend class LLVMContextImpl;
        -:  572:  friend class Constant;
        -:  573:
        -:  574:  /// A pointer to the bytes underlying this constant (which is owned by the
        -:  575:  /// uniquing StringMap).
        -:  576:  const char *DataElements;
        -:  577:
        -:  578:  /// This forms a link list of ConstantDataSequential nodes that have
        -:  579:  /// the same value but different type.  For example, 0,0,0,1 could be a 4
        -:  580:  /// element array of i8, or a 1-element array of i32.  They'll both end up in
        -:  581:  /// the same StringMap bucket, linked up.
        -:  582:  std::unique_ptr<ConstantDataSequential> Next;
        -:  583:
        -:  584:  void destroyConstantImpl();
        -:  585:
        -:  586:protected:
        -:  587:  explicit ConstantDataSequential(Type *ty, ValueTy VT, const char *Data)
        -:  588:      : ConstantData(ty, VT), DataElements(Data) {}
        -:  589:
        -:  590:  static Constant *getImpl(StringRef Bytes, Type *Ty);
        -:  591:
        -:  592:public:
        -:  593:  ConstantDataSequential(const ConstantDataSequential &) = delete;
        -:  594:
        -:  595:  /// Return true if a ConstantDataSequential can be formed with a vector or
        -:  596:  /// array of the specified element type.
        -:  597:  /// ConstantDataArray only works with normal float and int types that are
        -:  598:  /// stored densely in memory, not with things like i42 or x86_f80.
        -:  599:  static bool isElementTypeCompatible(Type *Ty);
        -:  600:
        -:  601:  /// If this is a sequential container of integers (of any size), return the
        -:  602:  /// specified element in the low bits of a uint64_t.
        -:  603:  uint64_t getElementAsInteger(unsigned i) const;
        -:  604:
        -:  605:  /// If this is a sequential container of integers (of any size), return the
        -:  606:  /// specified element as an APInt.
        -:  607:  APInt getElementAsAPInt(unsigned i) const;
        -:  608:
        -:  609:  /// If this is a sequential container of floating point type, return the
        -:  610:  /// specified element as an APFloat.
        -:  611:  APFloat getElementAsAPFloat(unsigned i) const;
        -:  612:
        -:  613:  /// If this is an sequential container of floats, return the specified element
        -:  614:  /// as a float.
        -:  615:  float getElementAsFloat(unsigned i) const;
        -:  616:
        -:  617:  /// If this is an sequential container of doubles, return the specified
        -:  618:  /// element as a double.
        -:  619:  double getElementAsDouble(unsigned i) const;
        -:  620:
        -:  621:  /// Return a Constant for a specified index's element.
        -:  622:  /// Note that this has to compute a new constant to return, so it isn't as
        -:  623:  /// efficient as getElementAsInteger/Float/Double.
        -:  624:  Constant *getElementAsConstant(unsigned i) const;
        -:  625:
        -:  626:  /// Return the element type of the array/vector.
        -:  627:  Type *getElementType() const;
        -:  628:
        -:  629:  /// Return the number of elements in the array or vector.
        -:  630:  unsigned getNumElements() const;
        -:  631:
        -:  632:  /// Return the size (in bytes) of each element in the array/vector.
        -:  633:  /// The size of the elements is known to be a multiple of one byte.
        -:  634:  uint64_t getElementByteSize() const;
        -:  635:
        -:  636:  /// This method returns true if this is an array of \p CharSize integers.
        -:  637:  bool isString(unsigned CharSize = 8) const;
        -:  638:
        -:  639:  /// This method returns true if the array "isString", ends with a null byte,
        -:  640:  /// and does not contains any other null bytes.
        -:  641:  bool isCString() const;
        -:  642:
        -:  643:  /// If this array is isString(), then this method returns the array as a
        -:  644:  /// StringRef. Otherwise, it asserts out.
        -:  645:  StringRef getAsString() const {
        -:  646:    assert(isString() && "Not a string");
        -:  647:    return getRawDataValues();
        -:  648:  }
        -:  649:
        -:  650:  /// If this array is isCString(), then this method returns the array (without
        -:  651:  /// the trailing null byte) as a StringRef. Otherwise, it asserts out.
        -:  652:  StringRef getAsCString() const {
        -:  653:    assert(isCString() && "Isn't a C string");
        -:  654:    StringRef Str = getAsString();
        -:  655:    return Str.substr(0, Str.size() - 1);
        -:  656:  }
        -:  657:
        -:  658:  /// Return the raw, underlying, bytes of this data. Note that this is an
        -:  659:  /// extremely tricky thing to work with, as it exposes the host endianness of
        -:  660:  /// the data elements.
        -:  661:  StringRef getRawDataValues() const;
        -:  662:
        -:  663:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  664:  static bool classof(const Value *V) {
        -:  665:    return V->getValueID() == ConstantDataArrayVal ||
        -:  666:           V->getValueID() == ConstantDataVectorVal;
        -:  667:  }
        -:  668:
        -:  669:private:
        -:  670:  const char *getElementPointer(unsigned Elt) const;
        -:  671:};
        -:  672:
        -:  673://===----------------------------------------------------------------------===//
        -:  674:/// An array constant whose element type is a simple 1/2/4/8-byte integer or
        -:  675:/// float/double, and whose elements are just simple data values
        -:  676:/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it
        -:  677:/// stores all of the elements of the constant as densely packed data, instead
        -:  678:/// of as Value*'s.
        -:  679:class ConstantDataArray final : public ConstantDataSequential {
        -:  680:  friend class ConstantDataSequential;
        -:  681:
        -:  682:  explicit ConstantDataArray(Type *ty, const char *Data)
        -:  683:      : ConstantDataSequential(ty, ConstantDataArrayVal, Data) {}
        -:  684:
        -:  685:public:
        -:  686:  ConstantDataArray(const ConstantDataArray &) = delete;
        -:  687:
        -:  688:  /// get() constructor - Return a constant with array type with an element
        -:  689:  /// count and element type matching the ArrayRef passed in.  Note that this
        -:  690:  /// can return a ConstantAggregateZero object.
        -:  691:  template <typename ElementTy>
        -:  692:  static Constant *get(LLVMContext &Context, ArrayRef<ElementTy> Elts) {
        -:  693:    const char *Data = reinterpret_cast<const char *>(Elts.data());
        -:  694:    return getRaw(StringRef(Data, Elts.size() * sizeof(ElementTy)), Elts.size(),
        -:  695:                  Type::getScalarTy<ElementTy>(Context));
        -:  696:  }
        -:  697:
        -:  698:  /// get() constructor - ArrayTy needs to be compatible with
        -:  699:  /// ArrayRef<ElementTy>. Calls get(LLVMContext, ArrayRef<ElementTy>).
        -:  700:  template <typename ArrayTy>
        -:  701:  static Constant *get(LLVMContext &Context, ArrayTy &Elts) {
        -:  702:    return ConstantDataArray::get(Context, makeArrayRef(Elts));
        -:  703:  }
        -:  704:
        -:  705:  /// getRaw() constructor - Return a constant with array type with an element
        -:  706:  /// count and element type matching the NumElements and ElementTy parameters
        -:  707:  /// passed in. Note that this can return a ConstantAggregateZero object.
        -:  708:  /// ElementTy must be one of i8/i16/i32/i64/half/bfloat/float/double. Data is
        -:  709:  /// the buffer containing the elements. Be careful to make sure Data uses the
        -:  710:  /// right endianness, the buffer will be used as-is.
        -:  711:  static Constant *getRaw(StringRef Data, uint64_t NumElements,
        -:  712:                          Type *ElementTy) {
        -:  713:    Type *Ty = ArrayType::get(ElementTy, NumElements);
        -:  714:    return getImpl(Data, Ty);
        -:  715:  }
        -:  716:
        -:  717:  /// getFP() constructors - Return a constant of array type with a float
        -:  718:  /// element type taken from argument `ElementType', and count taken from
        -:  719:  /// argument `Elts'.  The amount of bits of the contained type must match the
        -:  720:  /// number of bits of the type contained in the passed in ArrayRef.
        -:  721:  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note
        -:  722:  /// that this can return a ConstantAggregateZero object.
        -:  723:  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);
        -:  724:  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);
        -:  725:  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);
        -:  726:
        -:  727:  /// This method constructs a CDS and initializes it with a text string.
        -:  728:  /// The default behavior (AddNull==true) causes a null terminator to
        -:  729:  /// be placed at the end of the array (increasing the length of the string by
        -:  730:  /// one more than the StringRef would normally indicate.  Pass AddNull=false
        -:  731:  /// to disable this behavior.
        -:  732:  static Constant *getString(LLVMContext &Context, StringRef Initializer,
        -:  733:                             bool AddNull = true);
        -:  734:
        -:  735:  /// Specialize the getType() method to always return an ArrayType,
        -:  736:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  737:  inline ArrayType *getType() const {
        -:  738:    return cast<ArrayType>(Value::getType());
        -:  739:  }
        -:  740:
        -:  741:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  742:  static bool classof(const Value *V) {
        -:  743:    return V->getValueID() == ConstantDataArrayVal;
        -:  744:  }
        -:  745:};
        -:  746:
        -:  747://===----------------------------------------------------------------------===//
        -:  748:/// A vector constant whose element type is a simple 1/2/4/8-byte integer or
        -:  749:/// float/double, and whose elements are just simple data values
        -:  750:/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it
        -:  751:/// stores all of the elements of the constant as densely packed data, instead
        -:  752:/// of as Value*'s.
        -:  753:class ConstantDataVector final : public ConstantDataSequential {
        -:  754:  friend class ConstantDataSequential;
        -:  755:
        -:  756:  explicit ConstantDataVector(Type *ty, const char *Data)
        -:  757:      : ConstantDataSequential(ty, ConstantDataVectorVal, Data),
        -:  758:        IsSplatSet(false) {}
        -:  759:  // Cache whether or not the constant is a splat.
        -:  760:  mutable bool IsSplatSet : 1;
        -:  761:  mutable bool IsSplat : 1;
        -:  762:  bool isSplatData() const;
        -:  763:
        -:  764:public:
        -:  765:  ConstantDataVector(const ConstantDataVector &) = delete;
        -:  766:
        -:  767:  /// get() constructors - Return a constant with vector type with an element
        -:  768:  /// count and element type matching the ArrayRef passed in.  Note that this
        -:  769:  /// can return a ConstantAggregateZero object.
        -:  770:  static Constant *get(LLVMContext &Context, ArrayRef<uint8_t> Elts);
        -:  771:  static Constant *get(LLVMContext &Context, ArrayRef<uint16_t> Elts);
        -:  772:  static Constant *get(LLVMContext &Context, ArrayRef<uint32_t> Elts);
        -:  773:  static Constant *get(LLVMContext &Context, ArrayRef<uint64_t> Elts);
        -:  774:  static Constant *get(LLVMContext &Context, ArrayRef<float> Elts);
        -:  775:  static Constant *get(LLVMContext &Context, ArrayRef<double> Elts);
        -:  776:
        -:  777:  /// getRaw() constructor - Return a constant with vector type with an element
        -:  778:  /// count and element type matching the NumElements and ElementTy parameters
        -:  779:  /// passed in. Note that this can return a ConstantAggregateZero object.
        -:  780:  /// ElementTy must be one of i8/i16/i32/i64/half/bfloat/float/double. Data is
        -:  781:  /// the buffer containing the elements. Be careful to make sure Data uses the
        -:  782:  /// right endianness, the buffer will be used as-is.
        -:  783:  static Constant *getRaw(StringRef Data, uint64_t NumElements,
        -:  784:                          Type *ElementTy) {
        -:  785:    Type *Ty = VectorType::get(ElementTy, ElementCount::getFixed(NumElements));
        -:  786:    return getImpl(Data, Ty);
        -:  787:  }
        -:  788:
        -:  789:  /// getFP() constructors - Return a constant of vector type with a float
        -:  790:  /// element type taken from argument `ElementType', and count taken from
        -:  791:  /// argument `Elts'.  The amount of bits of the contained type must match the
        -:  792:  /// number of bits of the type contained in the passed in ArrayRef.
        -:  793:  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note
        -:  794:  /// that this can return a ConstantAggregateZero object.
        -:  795:  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);
        -:  796:  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);
        -:  797:  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);
        -:  798:
        -:  799:  /// Return a ConstantVector with the specified constant in each element.
        -:  800:  /// The specified constant has to be a of a compatible type (i8/i16/
        -:  801:  /// i32/i64/half/bfloat/float/double) and must be a ConstantFP or ConstantInt.
        -:  802:  static Constant *getSplat(unsigned NumElts, Constant *Elt);
        -:  803:
        -:  804:  /// Returns true if this is a splat constant, meaning that all elements have
        -:  805:  /// the same value.
        -:  806:  bool isSplat() const;
        -:  807:
        -:  808:  /// If this is a splat constant, meaning that all of the elements have the
        -:  809:  /// same value, return that value. Otherwise return NULL.
        -:  810:  Constant *getSplatValue() const;
        -:  811:
        -:  812:  /// Specialize the getType() method to always return a FixedVectorType,
        -:  813:  /// which reduces the amount of casting needed in parts of the compiler.
        -:  814:  inline FixedVectorType *getType() const {
        -:  815:    return cast<FixedVectorType>(Value::getType());
        -:  816:  }
        -:  817:
        -:  818:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  819:  static bool classof(const Value *V) {
        -:  820:    return V->getValueID() == ConstantDataVectorVal;
        -:  821:  }
        -:  822:};
        -:  823:
        -:  824://===----------------------------------------------------------------------===//
        -:  825:/// A constant token which is empty
        -:  826:///
        -:  827:class ConstantTokenNone final : public ConstantData {
        -:  828:  friend class Constant;
        -:  829:
        -:  830:  explicit ConstantTokenNone(LLVMContext &Context)
        -:  831:      : ConstantData(Type::getTokenTy(Context), ConstantTokenNoneVal) {}
        -:  832:
        -:  833:  void destroyConstantImpl();
        -:  834:
        -:  835:public:
        -:  836:  ConstantTokenNone(const ConstantTokenNone &) = delete;
        -:  837:
        -:  838:  /// Return the ConstantTokenNone.
        -:  839:  static ConstantTokenNone *get(LLVMContext &Context);
        -:  840:
        -:  841:  /// Methods to support type inquiry through isa, cast, and dyn_cast.
        -:  842:  static bool classof(const Value *V) {
        -:  843:    return V->getValueID() == ConstantTokenNoneVal;
        -:  844:  }
        -:  845:};
        -:  846:
        -:  847:/// The address of a basic block.
        -:  848:///
        -:  849:class BlockAddress final : public Constant {
        -:  850:  friend class Constant;
        -:  851:
        -:  852:  BlockAddress(Function *F, BasicBlock *BB);
        -:  853:
        -:  854:  void *operator new(size_t S) { return User::operator new(S, 2); }
        -:  855:
        -:  856:  void destroyConstantImpl();
        -:  857:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  858:
        -:  859:public:
        -:  860:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:  861:
        -:  862:  /// Return a BlockAddress for the specified function and basic block.
        -:  863:  static BlockAddress *get(Function *F, BasicBlock *BB);
        -:  864:
        -:  865:  /// Return a BlockAddress for the specified basic block.  The basic
        -:  866:  /// block must be embedded into a function.
        -:  867:  static BlockAddress *get(BasicBlock *BB);
        -:  868:
        -:  869:  /// Lookup an existing \c BlockAddress constant for the given BasicBlock.
        -:  870:  ///
        -:  871:  /// \returns 0 if \c !BB->hasAddressTaken(), otherwise the \c BlockAddress.
        -:  872:  static BlockAddress *lookup(const BasicBlock *BB);
        -:  873:
        -:  874:  /// Transparently provide more efficient getOperand methods.
        -:  875:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  876:
        -:  877:  Function *getFunction() const { return (Function *)Op<0>().get(); }
        -:  878:  BasicBlock *getBasicBlock() const { return (BasicBlock *)Op<1>().get(); }
        -:  879:
        -:  880:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  881:  static bool classof(const Value *V) {
        -:  882:    return V->getValueID() == BlockAddressVal;
        -:  883:  }
        -:  884:};
        -:  885:
        -:  886:template <>
        -:  887:struct OperandTraits<BlockAddress>
        -:  888:    : public FixedNumOperandTraits<BlockAddress, 2> {};
        -:  889:
        -:  890:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(BlockAddress, Value)
        -:  891:
        -:  892:/// Wrapper for a function that represents a value that
        -:  893:/// functionally represents the original function. This can be a function,
        -:  894:/// global alias to a function, or an ifunc.
        -:  895:class DSOLocalEquivalent final : public Constant {
        -:  896:  friend class Constant;
        -:  897:
        -:  898:  DSOLocalEquivalent(GlobalValue *GV);
        -:  899:
        -:  900:  void *operator new(size_t S) { return User::operator new(S, 1); }
        -:  901:
        -:  902:  void destroyConstantImpl();
        -:  903:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  904:
        -:  905:public:
        -:  906:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:  907:
        -:  908:  /// Return a DSOLocalEquivalent for the specified global value.
        -:  909:  static DSOLocalEquivalent *get(GlobalValue *GV);
        -:  910:
        -:  911:  /// Transparently provide more efficient getOperand methods.
        -:  912:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  913:
        -:  914:  GlobalValue *getGlobalValue() const {
        -:  915:    return cast<GlobalValue>(Op<0>().get());
        -:  916:  }
        -:  917:
        -:  918:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  919:  static bool classof(const Value *V) {
        -:  920:    return V->getValueID() == DSOLocalEquivalentVal;
        -:  921:  }
        -:  922:};
        -:  923:
        -:  924:template <>
        -:  925:struct OperandTraits<DSOLocalEquivalent>
        -:  926:    : public FixedNumOperandTraits<DSOLocalEquivalent, 1> {};
        -:  927:
        -:  928:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(DSOLocalEquivalent, Value)
        -:  929:
        -:  930:/// Wrapper for a value that won't be replaced with a CFI jump table
        -:  931:/// pointer in LowerTypeTestsModule.
        -:  932:class NoCFIValue final : public Constant {
        -:  933:  friend class Constant;
        -:  934:
        -:  935:  NoCFIValue(GlobalValue *GV);
        -:  936:
        -:  937:  void *operator new(size_t S) { return User::operator new(S, 1); }
        -:  938:
        -:  939:  void destroyConstantImpl();
        -:  940:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  941:
        -:  942:public:
        -:  943:  /// Return a NoCFIValue for the specified function.
        -:  944:  static NoCFIValue *get(GlobalValue *GV);
        -:  945:
        -:  946:  /// Transparently provide more efficient getOperand methods.
        -:  947:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  948:
        -:  949:  GlobalValue *getGlobalValue() const {
        -:  950:    return cast<GlobalValue>(Op<0>().get());
        -:  951:  }
        -:  952:
        -:  953:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  954:  static bool classof(const Value *V) {
        -:  955:    return V->getValueID() == NoCFIValueVal;
        -:  956:  }
        -:  957:};
        -:  958:
        -:  959:template <>
        -:  960:struct OperandTraits<NoCFIValue> : public FixedNumOperandTraits<NoCFIValue, 1> {
        -:  961:};
        -:  962:
        -:  963:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(NoCFIValue, Value)
        -:  964:
        -:  965://===----------------------------------------------------------------------===//
        -:  966:/// A constant value that is initialized with an expression using
        -:  967:/// other constant values.
        -:  968:///
        -:  969:/// This class uses the standard Instruction opcodes to define the various
        -:  970:/// constant expressions.  The Opcode field for the ConstantExpr class is
        -:  971:/// maintained in the Value::SubclassData field.
        -:  972:class ConstantExpr : public Constant {
        -:  973:  friend struct ConstantExprKeyType;
        -:  974:  friend class Constant;
        -:  975:
        -:  976:  void destroyConstantImpl();
        -:  977:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  978:
        -:  979:protected:
        -:  980:  ConstantExpr(Type *ty, unsigned Opcode, Use *Ops, unsigned NumOps)
        -:  981:      : Constant(ty, ConstantExprVal, Ops, NumOps) {
        -:  982:    // Operation type (an Instruction opcode) is stored as the SubclassData.
        -:  983:    setValueSubclassData(Opcode);
        -:  984:  }
        -:  985:
        -:  986:  ~ConstantExpr() = default;
        -:  987:
        -:  988:public:
        -:  989:  // Static methods to construct a ConstantExpr of different kinds.  Note that
        -:  990:  // these methods may return a object that is not an instance of the
        -:  991:  // ConstantExpr class, because they will attempt to fold the constant
        -:  992:  // expression into something simpler if possible.
        -:  993:
        -:  994:  /// getAlignOf constant expr - computes the alignment of a type in a target
        -:  995:  /// independent way (Note: the return type is an i64).
        -:  996:  static Constant *getAlignOf(Type *Ty);
        -:  997:
        -:  998:  /// getSizeOf constant expr - computes the (alloc) size of a type (in
        -:  999:  /// address-units, not bits) in a target independent way (Note: the return
        -: 1000:  /// type is an i64).
        -: 1001:  ///
        -: 1002:  static Constant *getSizeOf(Type *Ty);
        -: 1003:
        -: 1004:  /// getOffsetOf constant expr - computes the offset of a struct field in a
        -: 1005:  /// target independent way (Note: the return type is an i64).
        -: 1006:  ///
        -: 1007:  static Constant *getOffsetOf(StructType *STy, unsigned FieldNo);
        -: 1008:
        -: 1009:  /// getOffsetOf constant expr - This is a generalized form of getOffsetOf,
        -: 1010:  /// which supports any aggregate type, and any Constant index.
        -: 1011:  ///
        -: 1012:  static Constant *getOffsetOf(Type *Ty, Constant *FieldNo);
        -: 1013:
        -: 1014:  static Constant *getNeg(Constant *C, bool HasNUW = false,
        -: 1015:                          bool HasNSW = false);
        -: 1016:  static Constant *getNot(Constant *C);
        -: 1017:  static Constant *getAdd(Constant *C1, Constant *C2, bool HasNUW = false,
        -: 1018:                          bool HasNSW = false);
        -: 1019:  static Constant *getSub(Constant *C1, Constant *C2, bool HasNUW = false,
        -: 1020:                          bool HasNSW = false);
        -: 1021:  static Constant *getMul(Constant *C1, Constant *C2, bool HasNUW = false,
        -: 1022:                          bool HasNSW = false);
        -: 1023:  static Constant *getAnd(Constant *C1, Constant *C2);
        -: 1024:  static Constant *getOr(Constant *C1, Constant *C2);
        -: 1025:  static Constant *getXor(Constant *C1, Constant *C2);
        -: 1026:  static Constant *getUMin(Constant *C1, Constant *C2);
        -: 1027:  static Constant *getShl(Constant *C1, Constant *C2, bool HasNUW = false,
        -: 1028:                          bool HasNSW = false);
        -: 1029:  static Constant *getLShr(Constant *C1, Constant *C2, bool isExact = false);
        -: 1030:  static Constant *getAShr(Constant *C1, Constant *C2, bool isExact = false);
        -: 1031:  static Constant *getTrunc(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1032:  static Constant *getSExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1033:  static Constant *getZExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1034:  static Constant *getFPTrunc(Constant *C, Type *Ty,
        -: 1035:                              bool OnlyIfReduced = false);
        -: 1036:  static Constant *getFPExtend(Constant *C, Type *Ty,
        -: 1037:                               bool OnlyIfReduced = false);
        -: 1038:  static Constant *getUIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1039:  static Constant *getSIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1040:  static Constant *getFPToUI(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1041:  static Constant *getFPToSI(Constant *C, Type *Ty, bool OnlyIfReduced = false);
        -: 1042:  static Constant *getPtrToInt(Constant *C, Type *Ty,
        -: 1043:                               bool OnlyIfReduced = false);
        -: 1044:  static Constant *getIntToPtr(Constant *C, Type *Ty,
        -: 1045:                               bool OnlyIfReduced = false);
        -: 1046:  static Constant *getBitCast(Constant *C, Type *Ty,
        -: 1047:                              bool OnlyIfReduced = false);
        -: 1048:  static Constant *getAddrSpaceCast(Constant *C, Type *Ty,
        -: 1049:                                    bool OnlyIfReduced = false);
        -: 1050:
        -: 1051:  static Constant *getNSWNeg(Constant *C) { return getNeg(C, false, true); }
        -: 1052:  static Constant *getNUWNeg(Constant *C) { return getNeg(C, true, false); }
        -: 1053:
        -: 1054:  static Constant *getNSWAdd(Constant *C1, Constant *C2) {
        -: 1055:    return getAdd(C1, C2, false, true);
        -: 1056:  }
        -: 1057:
        -: 1058:  static Constant *getNUWAdd(Constant *C1, Constant *C2) {
        -: 1059:    return getAdd(C1, C2, true, false);
        -: 1060:  }
        -: 1061:
        -: 1062:  static Constant *getNSWSub(Constant *C1, Constant *C2) {
        -: 1063:    return getSub(C1, C2, false, true);
        -: 1064:  }
        -: 1065:
        -: 1066:  static Constant *getNUWSub(Constant *C1, Constant *C2) {
        -: 1067:    return getSub(C1, C2, true, false);
        -: 1068:  }
        -: 1069:
        -: 1070:  static Constant *getNSWMul(Constant *C1, Constant *C2) {
        -: 1071:    return getMul(C1, C2, false, true);
        -: 1072:  }
        -: 1073:
        -: 1074:  static Constant *getNUWMul(Constant *C1, Constant *C2) {
        -: 1075:    return getMul(C1, C2, true, false);
        -: 1076:  }
        -: 1077:
        -: 1078:  static Constant *getNSWShl(Constant *C1, Constant *C2) {
        -: 1079:    return getShl(C1, C2, false, true);
        -: 1080:  }
        -: 1081:
        -: 1082:  static Constant *getNUWShl(Constant *C1, Constant *C2) {
        -: 1083:    return getShl(C1, C2, true, false);
        -: 1084:  }
        -: 1085:
        -: 1086:  static Constant *getExactAShr(Constant *C1, Constant *C2) {
        -: 1087:    return getAShr(C1, C2, true);
        -: 1088:  }
        -: 1089:
        -: 1090:  static Constant *getExactLShr(Constant *C1, Constant *C2) {
        -: 1091:    return getLShr(C1, C2, true);
        -: 1092:  }
        -: 1093:
        -: 1094:  /// If C is a scalar/fixed width vector of known powers of 2, then this
        -: 1095:  /// function returns a new scalar/fixed width vector obtained from logBase2
        -: 1096:  /// of C. Undef vector elements are set to zero.
        -: 1097:  /// Return a null pointer otherwise.
        -: 1098:  static Constant *getExactLogBase2(Constant *C);
        -: 1099:
        -: 1100:  /// Return the identity constant for a binary opcode.
        -: 1101:  /// The identity constant C is defined as X op C = X and C op X = X for every
        -: 1102:  /// X when the binary operation is commutative. If the binop is not
        -: 1103:  /// commutative, callers can acquire the operand 1 identity constant by
        -: 1104:  /// setting AllowRHSConstant to true. For example, any shift has a zero
        -: 1105:  /// identity constant for operand 1: X shift 0 = X.
        -: 1106:  /// If this is a fadd/fsub operation and we don't care about signed zeros,
        -: 1107:  /// then setting NSZ to true returns the identity +0.0 instead of -0.0.
        -: 1108:  /// Return nullptr if the operator does not have an identity constant.
        -: 1109:  static Constant *getBinOpIdentity(unsigned Opcode, Type *Ty,
        -: 1110:                                    bool AllowRHSConstant = false,
        -: 1111:                                    bool NSZ = false);
        -: 1112:
        -: 1113:  /// Return the absorbing element for the given binary
        -: 1114:  /// operation, i.e. a constant C such that X op C = C and C op X = C for
        -: 1115:  /// every X.  For example, this returns zero for integer multiplication.
        -: 1116:  /// It returns null if the operator doesn't have an absorbing element.
        -: 1117:  static Constant *getBinOpAbsorber(unsigned Opcode, Type *Ty);
        -: 1118:
        -: 1119:  /// Transparently provide more efficient getOperand methods.
        -: 1120:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);
        -: 1121:
        -: 1122:  /// Convenience function for getting a Cast operation.
        -: 1123:  ///
        -: 1124:  /// \param ops The opcode for the conversion
        -: 1125:  /// \param C  The constant to be converted
        -: 1126:  /// \param Ty The type to which the constant is converted
        -: 1127:  /// \param OnlyIfReduced see \a getWithOperands() docs.
        -: 1128:  static Constant *getCast(unsigned ops, Constant *C, Type *Ty,
        -: 1129:                           bool OnlyIfReduced = false);
        -: 1130:
        -: 1131:  // Create a ZExt or BitCast cast constant expression
        -: 1132:  static Constant *
        -: 1133:  getZExtOrBitCast(Constant *C, ///< The constant to zext or bitcast
        -: 1134:                   Type *Ty     ///< The type to zext or bitcast C to
        -: 1135:  );
        -: 1136:
        -: 1137:  // Create a SExt or BitCast cast constant expression
        -: 1138:  static Constant *
        -: 1139:  getSExtOrBitCast(Constant *C, ///< The constant to sext or bitcast
        -: 1140:                   Type *Ty     ///< The type to sext or bitcast C to
        -: 1141:  );
        -: 1142:
        -: 1143:  // Create a Trunc or BitCast cast constant expression
        -: 1144:  static Constant *
        -: 1145:  getTruncOrBitCast(Constant *C, ///< The constant to trunc or bitcast
        -: 1146:                    Type *Ty     ///< The type to trunc or bitcast C to
        -: 1147:  );
        -: 1148:
        -: 1149:  /// Create either an sext, trunc or nothing, depending on whether Ty is
        -: 1150:  /// wider, narrower or the same as C->getType(). This only works with
        -: 1151:  /// integer or vector of integer types.
        -: 1152:  static Constant *getSExtOrTrunc(Constant *C, Type *Ty);
        -: 1153:
        -: 1154:  /// Create a BitCast, AddrSpaceCast, or a PtrToInt cast constant
        -: 1155:  /// expression.
        -: 1156:  static Constant *
        -: 1157:  getPointerCast(Constant *C, ///< The pointer value to be casted (operand 0)
        -: 1158:                 Type *Ty     ///< The type to which cast should be made
        -: 1159:  );
        -: 1160:
        -: 1161:  /// Create a BitCast or AddrSpaceCast for a pointer type depending on
        -: 1162:  /// the address space.
        -: 1163:  static Constant *getPointerBitCastOrAddrSpaceCast(
        -: 1164:      Constant *C, ///< The constant to addrspacecast or bitcast
        -: 1165:      Type *Ty     ///< The type to bitcast or addrspacecast C to
        -: 1166:  );
        -: 1167:
        -: 1168:  /// Create a ZExt, Bitcast or Trunc for integer -> integer casts
        -: 1169:  static Constant *
        -: 1170:  getIntegerCast(Constant *C,  ///< The integer constant to be casted
        -: 1171:                 Type *Ty,     ///< The integer type to cast to
        -: 1172:                 bool IsSigned ///< Whether C should be treated as signed or not
        -: 1173:  );
        -: 1174:
        -: 1175:  /// Create a FPExt, Bitcast or FPTrunc for fp -> fp casts
        -: 1176:  static Constant *getFPCast(Constant *C, ///< The integer constant to be casted
        -: 1177:                             Type *Ty     ///< The integer type to cast to
        -: 1178:  );
        -: 1179:
        -: 1180:  /// Return true if this is a convert constant expression
        -: 1181:  bool isCast() const;
        -: 1182:
        -: 1183:  /// Return true if this is a compare constant expression
        -: 1184:  bool isCompare() const;
        -: 1185:
        -: 1186:  /// Select constant expr
        -: 1187:  ///
        -: 1188:  /// \param OnlyIfReducedTy see \a getWithOperands() docs.
        -: 1189:  static Constant *getSelect(Constant *C, Constant *V1, Constant *V2,
        -: 1190:                             Type *OnlyIfReducedTy = nullptr);
        -: 1191:
        -: 1192:  /// get - Return a binary or shift operator constant expression,
        -: 1193:  /// folding if possible.
        -: 1194:  ///
        -: 1195:  /// \param OnlyIfReducedTy see \a getWithOperands() docs.
        -: 1196:  static Constant *get(unsigned Opcode, Constant *C1, Constant *C2,
        -: 1197:                       unsigned Flags = 0, Type *OnlyIfReducedTy = nullptr);
        -: 1198:
        -: 1199:  /// Return an ICmp or FCmp comparison operator constant expression.
        -: 1200:  ///
        -: 1201:  /// \param OnlyIfReduced see \a getWithOperands() docs.
        -: 1202:  static Constant *getCompare(unsigned short pred, Constant *C1, Constant *C2,
        -: 1203:                              bool OnlyIfReduced = false);
        -: 1204:
        -: 1205:  /// get* - Return some common constants without having to
        -: 1206:  /// specify the full Instruction::OPCODE identifier.
        -: 1207:  ///
        -: 1208:  static Constant *getICmp(unsigned short pred, Constant *LHS, Constant *RHS,
        -: 1209:                           bool OnlyIfReduced = false);
        -: 1210:  static Constant *getFCmp(unsigned short pred, Constant *LHS, Constant *RHS,
        -: 1211:                           bool OnlyIfReduced = false);
        -: 1212:
        -: 1213:  /// Getelementptr form.  Value* is only accepted for convenience;
        -: 1214:  /// all elements must be Constants.
        -: 1215:  ///
        -: 1216:  /// \param InRangeIndex the inrange index if present or None.
        -: 1217:  /// \param OnlyIfReducedTy see \a getWithOperands() docs.
        -: 1218:  static Constant *getGetElementPtr(Type *Ty, Constant *C,
        -: 1219:                                    ArrayRef<Constant *> IdxList,
        -: 1220:                                    bool InBounds = false,
        -: 1221:                                    Optional<unsigned> InRangeIndex = None,
        -: 1222:                                    Type *OnlyIfReducedTy = nullptr) {
        -: 1223:    return getGetElementPtr(
        -: 1224:        Ty, C, makeArrayRef((Value *const *)IdxList.data(), IdxList.size()),
        -: 1225:        InBounds, InRangeIndex, OnlyIfReducedTy);
        -: 1226:  }
        -: 1227:  static Constant *getGetElementPtr(Type *Ty, Constant *C, Constant *Idx,
        -: 1228:                                    bool InBounds = false,
        -: 1229:                                    Optional<unsigned> InRangeIndex = None,
        -: 1230:                                    Type *OnlyIfReducedTy = nullptr) {
        -: 1231:    // This form of the function only exists to avoid ambiguous overload
        -: 1232:    // warnings about whether to convert Idx to ArrayRef<Constant *> or
        -: 1233:    // ArrayRef<Value *>.
        -: 1234:    return getGetElementPtr(Ty, C, cast<Value>(Idx), InBounds, InRangeIndex,
        -: 1235:                            OnlyIfReducedTy);
        -: 1236:  }
        -: 1237:  static Constant *getGetElementPtr(Type *Ty, Constant *C,
        -: 1238:                                    ArrayRef<Value *> IdxList,
        -: 1239:                                    bool InBounds = false,
        -: 1240:                                    Optional<unsigned> InRangeIndex = None,
        -: 1241:                                    Type *OnlyIfReducedTy = nullptr);
        -: 1242:
        -: 1243:  /// Create an "inbounds" getelementptr. See the documentation for the
        -: 1244:  /// "inbounds" flag in LangRef.html for details.
        -: 1245:  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,
        -: 1246:                                            ArrayRef<Constant *> IdxList) {
        -: 1247:    return getGetElementPtr(Ty, C, IdxList, true);
        -: 1248:  }
        -: 1249:  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,
        -: 1250:                                            Constant *Idx) {
        -: 1251:    // This form of the function only exists to avoid ambiguous overload
        -: 1252:    // warnings about whether to convert Idx to ArrayRef<Constant *> or
        -: 1253:    // ArrayRef<Value *>.
        -: 1254:    return getGetElementPtr(Ty, C, Idx, true);
        -: 1255:  }
    #####: 1256:  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,
        -: 1257:                                            ArrayRef<Value *> IdxList) {
    #####: 1258:    return getGetElementPtr(Ty, C, IdxList, true);
call    0 never executed
        -: 1259:  }
        -: 1260:
        -: 1261:  static Constant *getExtractElement(Constant *Vec, Constant *Idx,
        -: 1262:                                     Type *OnlyIfReducedTy = nullptr);
        -: 1263:  static Constant *getInsertElement(Constant *Vec, Constant *Elt, Constant *Idx,
        -: 1264:                                    Type *OnlyIfReducedTy = nullptr);
        -: 1265:  static Constant *getShuffleVector(Constant *V1, Constant *V2,
        -: 1266:                                    ArrayRef<int> Mask,
        -: 1267:                                    Type *OnlyIfReducedTy = nullptr);
        -: 1268:
        -: 1269:  /// Return the opcode at the root of this constant expression
    #####: 1270:  unsigned getOpcode() const { return getSubclassDataFromValue(); }
        -: 1271:
        -: 1272:  /// Return the ICMP or FCMP predicate value. Assert if this is not an ICMP or
        -: 1273:  /// FCMP constant expression.
        -: 1274:  unsigned getPredicate() const;
        -: 1275:
        -: 1276:  /// Assert that this is a shufflevector and return the mask. See class
        -: 1277:  /// ShuffleVectorInst for a description of the mask representation.
        -: 1278:  ArrayRef<int> getShuffleMask() const;
        -: 1279:
        -: 1280:  /// Assert that this is a shufflevector and return the mask.
        -: 1281:  ///
        -: 1282:  /// TODO: This is a temporary hack until we update the bitcode format for
        -: 1283:  /// shufflevector.
        -: 1284:  Constant *getShuffleMaskForBitcode() const;
        -: 1285:
        -: 1286:  /// Return a string representation for an opcode.
        -: 1287:  const char *getOpcodeName() const;
        -: 1288:
        -: 1289:  /// This returns the current constant expression with the operands replaced
        -: 1290:  /// with the specified values. The specified array must have the same number
        -: 1291:  /// of operands as our current one.
        -: 1292:  Constant *getWithOperands(ArrayRef<Constant *> Ops) const {
        -: 1293:    return getWithOperands(Ops, getType());
        -: 1294:  }
        -: 1295:
        -: 1296:  /// Get the current expression with the operands replaced.
        -: 1297:  ///
        -: 1298:  /// Return the current constant expression with the operands replaced with \c
        -: 1299:  /// Ops and the type with \c Ty.  The new operands must have the same number
        -: 1300:  /// as the current ones.
        -: 1301:  ///
        -: 1302:  /// If \c OnlyIfReduced is \c true, nullptr will be returned unless something
        -: 1303:  /// gets constant-folded, the type changes, or the expression is otherwise
        -: 1304:  /// canonicalized.  This parameter should almost always be \c false.
        -: 1305:  Constant *getWithOperands(ArrayRef<Constant *> Ops, Type *Ty,
        -: 1306:                            bool OnlyIfReduced = false,
        -: 1307:                            Type *SrcTy = nullptr) const;
        -: 1308:
        -: 1309:  /// Returns an Instruction which implements the same operation as this
        -: 1310:  /// ConstantExpr. If \p InsertBefore is not null, the new instruction is
        -: 1311:  /// inserted before it, otherwise it is not inserted into any basic block.
        -: 1312:  ///
        -: 1313:  /// A better approach to this could be to have a constructor for Instruction
        -: 1314:  /// which would take a ConstantExpr parameter, but that would have spread
        -: 1315:  /// implementation details of ConstantExpr outside of Constants.cpp, which
        -: 1316:  /// would make it harder to remove ConstantExprs altogether.
        -: 1317:  Instruction *getAsInstruction(Instruction *InsertBefore = nullptr) const;
        -: 1318:
        -: 1319:  /// Whether creating a constant expression for this binary operator is
        -: 1320:  /// desirable.
        -: 1321:  static bool isDesirableBinOp(unsigned Opcode);
        -: 1322:
        -: 1323:  /// Whether creating a constant expression for this binary operator is
        -: 1324:  /// supported.
        -: 1325:  static bool isSupportedBinOp(unsigned Opcode);
        -: 1326:
        -: 1327:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
    #####: 1328:  static bool classof(const Value *V) {
    #####: 1329:    return V->getValueID() == ConstantExprVal;
branch  0 never executed
branch  1 never executed
        -: 1330:  }
        -: 1331:
        -: 1332:private:
        -: 1333:  // Shadow Value::setValueSubclassData with a private forwarding method so that
        -: 1334:  // subclasses cannot accidentally use it.
        -: 1335:  void setValueSubclassData(unsigned short D) {
        -: 1336:    Value::setValueSubclassData(D);
        -: 1337:  }
        -: 1338:};
        -: 1339:
        -: 1340:template <>
        -: 1341:struct OperandTraits<ConstantExpr>
        -: 1342:    : public VariadicOperandTraits<ConstantExpr, 1> {};
        -: 1343:
        -: 1344:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantExpr, Constant)
        -: 1345:
        -: 1346://===----------------------------------------------------------------------===//
        -: 1347:/// 'undef' values are things that do not have specified contents.
        -: 1348:/// These are used for a variety of purposes, including global variable
        -: 1349:/// initializers and operands to instructions.  'undef' values can occur with
        -: 1350:/// any first-class type.
        -: 1351:///
        -: 1352:/// Undef values aren't exactly constants; if they have multiple uses, they
        -: 1353:/// can appear to have different bit patterns at each use. See
        -: 1354:/// LangRef.html#undefvalues for details.
        -: 1355:///
        -: 1356:class UndefValue : public ConstantData {
        -: 1357:  friend class Constant;
        -: 1358:
        -: 1359:  explicit UndefValue(Type *T) : ConstantData(T, UndefValueVal) {}
        -: 1360:
        -: 1361:  void destroyConstantImpl();
        -: 1362:
        -: 1363:protected:
        -: 1364:  explicit UndefValue(Type *T, ValueTy vty) : ConstantData(T, vty) {}
        -: 1365:
        -: 1366:public:
        -: 1367:  UndefValue(const UndefValue &) = delete;
        -: 1368:
        -: 1369:  /// Static factory methods - Return an 'undef' object of the specified type.
        -: 1370:  static UndefValue *get(Type *T);
        -: 1371:
        -: 1372:  /// If this Undef has array or vector type, return a undef with the right
        -: 1373:  /// element type.
        -: 1374:  UndefValue *getSequentialElement() const;
        -: 1375:
        -: 1376:  /// If this undef has struct type, return a undef with the right element type
        -: 1377:  /// for the specified element.
        -: 1378:  UndefValue *getStructElement(unsigned Elt) const;
        -: 1379:
        -: 1380:  /// Return an undef of the right value for the specified GEP index if we can,
        -: 1381:  /// otherwise return null (e.g. if C is a ConstantExpr).
        -: 1382:  UndefValue *getElementValue(Constant *C) const;
        -: 1383:
        -: 1384:  /// Return an undef of the right value for the specified GEP index.
        -: 1385:  UndefValue *getElementValue(unsigned Idx) const;
        -: 1386:
        -: 1387:  /// Return the number of elements in the array, vector, or struct.
        -: 1388:  unsigned getNumElements() const;
        -: 1389:
        -: 1390:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -: 1391:  static bool classof(const Value *V) {
        -: 1392:    return V->getValueID() == UndefValueVal ||
        -: 1393:           V->getValueID() == PoisonValueVal;
        -: 1394:  }
        -: 1395:};
        -: 1396:
        -: 1397://===----------------------------------------------------------------------===//
        -: 1398:/// In order to facilitate speculative execution, many instructions do not
        -: 1399:/// invoke immediate undefined behavior when provided with illegal operands,
        -: 1400:/// and return a poison value instead.
        -: 1401:///
        -: 1402:/// see LangRef.html#poisonvalues for details.
        -: 1403:///
        -: 1404:class PoisonValue final : public UndefValue {
        -: 1405:  friend class Constant;
        -: 1406:
        -: 1407:  explicit PoisonValue(Type *T) : UndefValue(T, PoisonValueVal) {}
        -: 1408:
        -: 1409:  void destroyConstantImpl();
        -: 1410:
        -: 1411:public:
        -: 1412:  PoisonValue(const PoisonValue &) = delete;
        -: 1413:
        -: 1414:  /// Static factory methods - Return an 'poison' object of the specified type.
        -: 1415:  static PoisonValue *get(Type *T);
        -: 1416:
        -: 1417:  /// If this poison has array or vector type, return a poison with the right
        -: 1418:  /// element type.
        -: 1419:  PoisonValue *getSequentialElement() const;
        -: 1420:
        -: 1421:  /// If this poison has struct type, return a poison with the right element
        -: 1422:  /// type for the specified element.
        -: 1423:  PoisonValue *getStructElement(unsigned Elt) const;
        -: 1424:
        -: 1425:  /// Return an poison of the right value for the specified GEP index if we can,
        -: 1426:  /// otherwise return null (e.g. if C is a ConstantExpr).
        -: 1427:  PoisonValue *getElementValue(Constant *C) const;
        -: 1428:
        -: 1429:  /// Return an poison of the right value for the specified GEP index.
        -: 1430:  PoisonValue *getElementValue(unsigned Idx) const;
        -: 1431:
        -: 1432:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -: 1433:  static bool classof(const Value *V) {
        -: 1434:    return V->getValueID() == PoisonValueVal;
        -: 1435:  }
        -: 1436:};
        -: 1437:
        -: 1438:} // end namespace llvm
        -: 1439:
        -: 1440:#endif // LLVM_IR_CONSTANTS_H
