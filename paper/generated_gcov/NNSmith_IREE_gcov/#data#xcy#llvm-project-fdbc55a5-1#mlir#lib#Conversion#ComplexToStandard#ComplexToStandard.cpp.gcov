        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Conversion/ComplexToStandard/ComplexToStandard.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/ComplexToStandard/CMakeFiles/obj.MLIRComplexToStandard.dir/ComplexToStandard.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/ComplexToStandard/CMakeFiles/obj.MLIRComplexToStandard.dir/ComplexToStandard.cpp.gcda
        -:    0:Runs:325556
        -:    1://===- ComplexToStandard.cpp - conversion from Complex to Standard dialect ===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/ComplexToStandard/ComplexToStandard.h"
        -:   10:
        -:   11:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   12:#include "mlir/Dialect/Complex/IR/Complex.h"
        -:   13:#include "mlir/Dialect/Math/IR/Math.h"
        -:   14:#include "mlir/IR/ImplicitLocOpBuilder.h"
        -:   15:#include "mlir/IR/PatternMatch.h"
        -:   16:#include "mlir/Pass/Pass.h"
        -:   17:#include "mlir/Transforms/DialectConversion.h"
        -:   18:#include <memory>
        -:   19:#include <type_traits>
        -:   20:
        -:   21:namespace mlir {
        -:   22:#define GEN_PASS_DEF_CONVERTCOMPLEXTOSTANDARD
        -:   23:#include "mlir/Conversion/Passes.h.inc"
        -:   24:} // namespace mlir
        -:   25:
        -:   26:using namespace mlir;
        -:   27:
        -:   28:namespace {
        -:   29:struct AbsOpConversion : public OpConversionPattern<complex::AbsOp> {
        -:   30:  using OpConversionPattern<complex::AbsOp>::OpConversionPattern;
        -:   31:
        -:   32:  LogicalResult
function _ZNK12_GLOBAL__N_115AbsOpConversion15matchAndRewriteEN4mlir7complex5AbsOpENS2_12AbsOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   33:  matchAndRewrite(complex::AbsOp op, OpAdaptor adaptor,
        -:   34:                  ConversionPatternRewriter &rewriter) const override {
    #####:   35:    auto loc = op.getLoc();
call    0 never executed
    #####:   36:    auto type = op.getType();
call    0 never executed
        -:   37:
    #####:   38:    Value real =
    #####:   39:        rewriter.create<complex::ReOp>(loc, type, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   40:    Value imag =
    #####:   41:        rewriter.create<complex::ImOp>(loc, type, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   42:    Value realSqr = rewriter.create<arith::MulFOp>(loc, real, real);
call    0 never executed
call    1 never executed
    #####:   43:    Value imagSqr = rewriter.create<arith::MulFOp>(loc, imag, imag);
call    0 never executed
call    1 never executed
    #####:   44:    Value sqNorm = rewriter.create<arith::AddFOp>(loc, realSqr, imagSqr);
call    0 never executed
call    1 never executed
        -:   45:
    #####:   46:    rewriter.replaceOpWithNewOp<math::SqrtOp>(op, sqNorm);
call    0 never executed
    #####:   47:    return success();
        -:   48:  }
        -:   49:};
        -:   50:
        -:   51:// atan2(y,x) = -i * log((x + i * y)/sqrt(x**2+y**2))
        -:   52:struct Atan2OpConversion : public OpConversionPattern<complex::Atan2Op> {
        -:   53:  using OpConversionPattern<complex::Atan2Op>::OpConversionPattern;
        -:   54:
        -:   55:  LogicalResult
function _ZNK12_GLOBAL__N_117Atan2OpConversion15matchAndRewriteEN4mlir7complex7Atan2OpENS2_14Atan2OpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   56:  matchAndRewrite(complex::Atan2Op op, OpAdaptor adaptor,
        -:   57:                  ConversionPatternRewriter &rewriter) const override {
    #####:   58:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:   59:
    #####:   60:    auto type = op.getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:   61:    Type elementType = type.getElementType();
call    0 never executed
        -:   62:
    #####:   63:    Value lhs = adaptor.getLhs();
call    0 never executed
    #####:   64:    Value rhs = adaptor.getRhs();
call    0 never executed
        -:   65:
    #####:   66:    Value rhsSquared = b.create<complex::MulOp>(type, rhs, rhs);
call    0 never executed
call    1 never executed
    #####:   67:    Value lhsSquared = b.create<complex::MulOp>(type, lhs, lhs);
call    0 never executed
call    1 never executed
    #####:   68:    Value rhsSquaredPlusLhsSquared =
call    0 never executed
    #####:   69:        b.create<complex::AddOp>(type, rhsSquared, lhsSquared);
call    0 never executed
    #####:   70:    Value sqrtOfRhsSquaredPlusLhsSquared =
call    0 never executed
    #####:   71:        b.create<complex::SqrtOp>(type, rhsSquaredPlusLhsSquared);
call    0 never executed
        -:   72:
    #####:   73:    Value zero =
    #####:   74:        b.create<arith::ConstantOp>(elementType, b.getZeroAttr(elementType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   75:    Value one = b.create<arith::ConstantOp>(elementType,
    #####:   76:                                            b.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   77:    Value i = b.create<complex::CreateOp>(type, zero, one);
call    0 never executed
call    1 never executed
    #####:   78:    Value iTimesLhs = b.create<complex::MulOp>(i, lhs);
call    0 never executed
call    1 never executed
    #####:   79:    Value rhsPlusILhs = b.create<complex::AddOp>(rhs, iTimesLhs);
call    0 never executed
call    1 never executed
        -:   80:
    #####:   81:    Value divResult =
call    0 never executed
    #####:   82:        b.create<complex::DivOp>(rhsPlusILhs, sqrtOfRhsSquaredPlusLhsSquared);
call    0 never executed
    #####:   83:    Value logResult = b.create<complex::LogOp>(divResult);
call    0 never executed
call    1 never executed
        -:   84:
    #####:   85:    Value negativeOne = b.create<arith::ConstantOp>(
    #####:   86:        elementType, b.getFloatAttr(elementType, -1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   87:    Value negativeI = b.create<complex::CreateOp>(type, zero, negativeOne);
call    0 never executed
        -:   88:
    #####:   89:    rewriter.replaceOpWithNewOp<complex::MulOp>(op, negativeI, logResult);
call    0 never executed
    #####:   90:    return success();
        -:   91:  }
        -:   92:};
        -:   93:
        -:   94:template <typename ComparisonOp, arith::CmpFPredicate p>
        -:   95:struct ComparisonOpConversion : public OpConversionPattern<ComparisonOp> {
        -:   96:  using OpConversionPattern<ComparisonOp>::OpConversionPattern;
        -:   97:  using ResultCombiner =
        -:   98:      std::conditional_t<std::is_same<ComparisonOp, complex::EqualOp>::value,
        -:   99:                         arith::AndIOp, arith::OrIOp>;
        -:  100:
        -:  101:  LogicalResult
    #####:  102:  matchAndRewrite(ComparisonOp op, typename ComparisonOp::Adaptor adaptor,
        -:  103:                  ConversionPatternRewriter &rewriter) const override {
    #####:  104:    auto loc = op.getLoc();
    #####:  105:    auto type = adaptor.getLhs()
    #####:  106:                    .getType()
    #####:  107:                    .template cast<ComplexType>()
    #####:  108:                    .getElementType();
        -:  109:
    #####:  110:    Value realLhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getLhs());
    #####:  111:    Value imagLhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getLhs());
    #####:  112:    Value realRhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getRhs());
    #####:  113:    Value imagRhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getRhs());
    #####:  114:    Value realComparison =
        -:  115:        rewriter.create<arith::CmpFOp>(loc, p, realLhs, realRhs);
    #####:  116:    Value imagComparison =
        -:  117:        rewriter.create<arith::CmpFOp>(loc, p, imagLhs, imagRhs);
        -:  118:
    #####:  119:    rewriter.replaceOpWithNewOp<ResultCombiner>(op, realComparison,
        -:  120:                                                imagComparison);
    #####:  121:    return success();
        -:  122:  }
------------------
_ZNK12_GLOBAL__N_122ComparisonOpConversionIN4mlir7complex7EqualOpELNS1_5arith13CmpFPredicateE1EE15matchAndRewriteES3_NS2_14EqualOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122ComparisonOpConversionIN4mlir7complex7EqualOpELNS1_5arith13CmpFPredicateE1EE15matchAndRewriteES3_NS2_14EqualOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  102:  matchAndRewrite(ComparisonOp op, typename ComparisonOp::Adaptor adaptor,
        -:  103:                  ConversionPatternRewriter &rewriter) const override {
    #####:  104:    auto loc = op.getLoc();
call    0 never executed
    #####:  105:    auto type = adaptor.getLhs()
    #####:  106:                    .getType()
call    0 never executed
    #####:  107:                    .template cast<ComplexType>()
call    0 never executed
    #####:  108:                    .getElementType();
call    0 never executed
        -:  109:
    #####:  110:    Value realLhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  111:    Value imagLhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  112:    Value realRhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  113:    Value imagRhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  114:    Value realComparison =
call    0 never executed
call    1 never executed
        -:  115:        rewriter.create<arith::CmpFOp>(loc, p, realLhs, realRhs);
    #####:  116:    Value imagComparison =
call    0 never executed
call    1 never executed
        -:  117:        rewriter.create<arith::CmpFOp>(loc, p, imagLhs, imagRhs);
        -:  118:
    #####:  119:    rewriter.replaceOpWithNewOp<ResultCombiner>(op, realComparison,
call    0 never executed
        -:  120:                                                imagComparison);
    #####:  121:    return success();
        -:  122:  }
------------------
_ZNK12_GLOBAL__N_122ComparisonOpConversionIN4mlir7complex10NotEqualOpELNS1_5arith13CmpFPredicateE13EE15matchAndRewriteES3_NS2_17NotEqualOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_122ComparisonOpConversionIN4mlir7complex10NotEqualOpELNS1_5arith13CmpFPredicateE13EE15matchAndRewriteES3_NS2_17NotEqualOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  102:  matchAndRewrite(ComparisonOp op, typename ComparisonOp::Adaptor adaptor,
        -:  103:                  ConversionPatternRewriter &rewriter) const override {
    #####:  104:    auto loc = op.getLoc();
call    0 never executed
    #####:  105:    auto type = adaptor.getLhs()
    #####:  106:                    .getType()
call    0 never executed
    #####:  107:                    .template cast<ComplexType>()
call    0 never executed
    #####:  108:                    .getElementType();
call    0 never executed
        -:  109:
    #####:  110:    Value realLhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  111:    Value imagLhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  112:    Value realRhs = rewriter.create<complex::ReOp>(loc, type, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  113:    Value imagRhs = rewriter.create<complex::ImOp>(loc, type, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  114:    Value realComparison =
call    0 never executed
call    1 never executed
        -:  115:        rewriter.create<arith::CmpFOp>(loc, p, realLhs, realRhs);
    #####:  116:    Value imagComparison =
call    0 never executed
call    1 never executed
        -:  117:        rewriter.create<arith::CmpFOp>(loc, p, imagLhs, imagRhs);
        -:  118:
    #####:  119:    rewriter.replaceOpWithNewOp<ResultCombiner>(op, realComparison,
call    0 never executed
        -:  120:                                                imagComparison);
    #####:  121:    return success();
        -:  122:  }
------------------
        -:  123:};
        -:  124:
        -:  125:// Default conversion which applies the BinaryStandardOp separately on the real
        -:  126:// and imaginary parts. Can for example be used for complex::AddOp and
        -:  127:// complex::SubOp.
        -:  128:template <typename BinaryComplexOp, typename BinaryStandardOp>
        -:  129:struct BinaryComplexOpConversion : public OpConversionPattern<BinaryComplexOp> {
        -:  130:  using OpConversionPattern<BinaryComplexOp>::OpConversionPattern;
        -:  131:
        -:  132:  LogicalResult
    #####:  133:  matchAndRewrite(BinaryComplexOp op, typename BinaryComplexOp::Adaptor adaptor,
        -:  134:                  ConversionPatternRewriter &rewriter) const override {
    #####:  135:    auto type = adaptor.getLhs().getType().template cast<ComplexType>();
    #####:  136:    auto elementType = type.getElementType().template cast<FloatType>();
    #####:  137:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
        -:  138:
    #####:  139:    Value realLhs = b.create<complex::ReOp>(elementType, adaptor.getLhs());
    #####:  140:    Value realRhs = b.create<complex::ReOp>(elementType, adaptor.getRhs());
    #####:  141:    Value resultReal =
        -:  142:        b.create<BinaryStandardOp>(elementType, realLhs, realRhs);
    #####:  143:    Value imagLhs = b.create<complex::ImOp>(elementType, adaptor.getLhs());
    #####:  144:    Value imagRhs = b.create<complex::ImOp>(elementType, adaptor.getRhs());
    #####:  145:    Value resultImag =
        -:  146:        b.create<BinaryStandardOp>(elementType, imagLhs, imagRhs);
    #####:  147:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
        -:  148:                                                   resultImag);
    #####:  149:    return success();
        -:  150:  }
------------------
_ZNK12_GLOBAL__N_125BinaryComplexOpConversionIN4mlir7complex5AddOpENS1_5arith6AddFOpEE15matchAndRewriteES3_NS2_12AddOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125BinaryComplexOpConversionIN4mlir7complex5AddOpENS1_5arith6AddFOpEE15matchAndRewriteES3_NS2_12AddOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  133:  matchAndRewrite(BinaryComplexOp op, typename BinaryComplexOp::Adaptor adaptor,
        -:  134:                  ConversionPatternRewriter &rewriter) const override {
    #####:  135:    auto type = adaptor.getLhs().getType().template cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  136:    auto elementType = type.getElementType().template cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  137:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  138:
    #####:  139:    Value realLhs = b.create<complex::ReOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  140:    Value realRhs = b.create<complex::ReOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  141:    Value resultReal =
call    0 never executed
        -:  142:        b.create<BinaryStandardOp>(elementType, realLhs, realRhs);
    #####:  143:    Value imagLhs = b.create<complex::ImOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  144:    Value imagRhs = b.create<complex::ImOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  145:    Value resultImag =
call    0 never executed
        -:  146:        b.create<BinaryStandardOp>(elementType, imagLhs, imagRhs);
    #####:  147:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
call    0 never executed
        -:  148:                                                   resultImag);
    #####:  149:    return success();
        -:  150:  }
------------------
_ZNK12_GLOBAL__N_125BinaryComplexOpConversionIN4mlir7complex5SubOpENS1_5arith6SubFOpEE15matchAndRewriteES3_NS2_12SubOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125BinaryComplexOpConversionIN4mlir7complex5SubOpENS1_5arith6SubFOpEE15matchAndRewriteES3_NS2_12SubOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  133:  matchAndRewrite(BinaryComplexOp op, typename BinaryComplexOp::Adaptor adaptor,
        -:  134:                  ConversionPatternRewriter &rewriter) const override {
    #####:  135:    auto type = adaptor.getLhs().getType().template cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  136:    auto elementType = type.getElementType().template cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  137:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  138:
    #####:  139:    Value realLhs = b.create<complex::ReOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  140:    Value realRhs = b.create<complex::ReOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  141:    Value resultReal =
call    0 never executed
        -:  142:        b.create<BinaryStandardOp>(elementType, realLhs, realRhs);
    #####:  143:    Value imagLhs = b.create<complex::ImOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  144:    Value imagRhs = b.create<complex::ImOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  145:    Value resultImag =
call    0 never executed
        -:  146:        b.create<BinaryStandardOp>(elementType, imagLhs, imagRhs);
    #####:  147:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
call    0 never executed
        -:  148:                                                   resultImag);
    #####:  149:    return success();
        -:  150:  }
------------------
        -:  151:};
        -:  152:
        -:  153:template <typename TrigonometricOp>
        -:  154:struct TrigonometricOpConversion : public OpConversionPattern<TrigonometricOp> {
        -:  155:  using OpAdaptor = typename OpConversionPattern<TrigonometricOp>::OpAdaptor;
        -:  156:
        -:  157:  using OpConversionPattern<TrigonometricOp>::OpConversionPattern;
        -:  158:
        -:  159:  LogicalResult
    #####:  160:  matchAndRewrite(TrigonometricOp op, OpAdaptor adaptor,
        -:  161:                  ConversionPatternRewriter &rewriter) const override {
    #####:  162:    auto loc = op.getLoc();
    #####:  163:    auto type = adaptor.getComplex().getType().template cast<ComplexType>();
    #####:  164:    auto elementType = type.getElementType().template cast<FloatType>();
        -:  165:
    #####:  166:    Value real =
        -:  167:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
    #####:  168:    Value imag =
        -:  169:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
        -:  170:
        -:  171:    // Trigonometric ops use a set of common building blocks to convert to real
        -:  172:    // ops. Here we create these building blocks and call into an op-specific
        -:  173:    // implementation in the subclass to combine them.
    #####:  174:    Value half = rewriter.create<arith::ConstantOp>(
        -:  175:        loc, elementType, rewriter.getFloatAttr(elementType, 0.5));
    #####:  176:    Value exp = rewriter.create<math::ExpOp>(loc, imag);
    #####:  177:    Value scaledExp = rewriter.create<arith::MulFOp>(loc, half, exp);
    #####:  178:    Value reciprocalExp = rewriter.create<arith::DivFOp>(loc, half, exp);
    #####:  179:    Value sin = rewriter.create<math::SinOp>(loc, real);
    #####:  180:    Value cos = rewriter.create<math::CosOp>(loc, real);
        -:  181:
    #####:  182:    auto resultPair =
        -:  183:        combine(loc, scaledExp, reciprocalExp, sin, cos, rewriter);
        -:  184:
    #####:  185:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultPair.first,
        -:  186:                                                   resultPair.second);
    #####:  187:    return success();
        -:  188:  }
------------------
_ZNK12_GLOBAL__N_125TrigonometricOpConversionIN4mlir7complex5CosOpEE15matchAndRewriteES3_NS2_12CosOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125TrigonometricOpConversionIN4mlir7complex5CosOpEE15matchAndRewriteES3_NS2_12CosOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  160:  matchAndRewrite(TrigonometricOp op, OpAdaptor adaptor,
        -:  161:                  ConversionPatternRewriter &rewriter) const override {
    #####:  162:    auto loc = op.getLoc();
call    0 never executed
    #####:  163:    auto type = adaptor.getComplex().getType().template cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  164:    auto elementType = type.getElementType().template cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  165:
    #####:  166:    Value real =
call    0 never executed
call    1 never executed
call    2 never executed
        -:  167:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
    #####:  168:    Value imag =
call    0 never executed
call    1 never executed
call    2 never executed
        -:  169:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
        -:  170:
        -:  171:    // Trigonometric ops use a set of common building blocks to convert to real
        -:  172:    // ops. Here we create these building blocks and call into an op-specific
        -:  173:    // implementation in the subclass to combine them.
    #####:  174:    Value half = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  175:        loc, elementType, rewriter.getFloatAttr(elementType, 0.5));
    #####:  176:    Value exp = rewriter.create<math::ExpOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  177:    Value scaledExp = rewriter.create<arith::MulFOp>(loc, half, exp);
call    0 never executed
call    1 never executed
    #####:  178:    Value reciprocalExp = rewriter.create<arith::DivFOp>(loc, half, exp);
call    0 never executed
call    1 never executed
    #####:  179:    Value sin = rewriter.create<math::SinOp>(loc, real);
call    0 never executed
call    1 never executed
    #####:  180:    Value cos = rewriter.create<math::CosOp>(loc, real);
call    0 never executed
call    1 never executed
        -:  181:
    #####:  182:    auto resultPair =
call    0 never executed
        -:  183:        combine(loc, scaledExp, reciprocalExp, sin, cos, rewriter);
        -:  184:
    #####:  185:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultPair.first,
call    0 never executed
        -:  186:                                                   resultPair.second);
    #####:  187:    return success();
        -:  188:  }
------------------
_ZNK12_GLOBAL__N_125TrigonometricOpConversionIN4mlir7complex5SinOpEE15matchAndRewriteES3_NS2_12SinOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125TrigonometricOpConversionIN4mlir7complex5SinOpEE15matchAndRewriteES3_NS2_12SinOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  160:  matchAndRewrite(TrigonometricOp op, OpAdaptor adaptor,
        -:  161:                  ConversionPatternRewriter &rewriter) const override {
    #####:  162:    auto loc = op.getLoc();
call    0 never executed
    #####:  163:    auto type = adaptor.getComplex().getType().template cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  164:    auto elementType = type.getElementType().template cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  165:
    #####:  166:    Value real =
call    0 never executed
call    1 never executed
call    2 never executed
        -:  167:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
    #####:  168:    Value imag =
call    0 never executed
call    1 never executed
call    2 never executed
        -:  169:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
        -:  170:
        -:  171:    // Trigonometric ops use a set of common building blocks to convert to real
        -:  172:    // ops. Here we create these building blocks and call into an op-specific
        -:  173:    // implementation in the subclass to combine them.
    #####:  174:    Value half = rewriter.create<arith::ConstantOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  175:        loc, elementType, rewriter.getFloatAttr(elementType, 0.5));
    #####:  176:    Value exp = rewriter.create<math::ExpOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  177:    Value scaledExp = rewriter.create<arith::MulFOp>(loc, half, exp);
call    0 never executed
call    1 never executed
    #####:  178:    Value reciprocalExp = rewriter.create<arith::DivFOp>(loc, half, exp);
call    0 never executed
call    1 never executed
    #####:  179:    Value sin = rewriter.create<math::SinOp>(loc, real);
call    0 never executed
call    1 never executed
    #####:  180:    Value cos = rewriter.create<math::CosOp>(loc, real);
call    0 never executed
call    1 never executed
        -:  181:
    #####:  182:    auto resultPair =
call    0 never executed
        -:  183:        combine(loc, scaledExp, reciprocalExp, sin, cos, rewriter);
        -:  184:
    #####:  185:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultPair.first,
call    0 never executed
        -:  186:                                                   resultPair.second);
    #####:  187:    return success();
        -:  188:  }
------------------
        -:  189:
        -:  190:  virtual std::pair<Value, Value>
        -:  191:  combine(Location loc, Value scaledExp, Value reciprocalExp, Value sin,
        -:  192:          Value cos, ConversionPatternRewriter &rewriter) const = 0;
        -:  193:};
        -:  194:
        -:  195:struct CosOpConversion : public TrigonometricOpConversion<complex::CosOp> {
        -:  196:  using TrigonometricOpConversion<complex::CosOp>::TrigonometricOpConversion;
        -:  197:
        -:  198:  std::pair<Value, Value>
function _ZNK12_GLOBAL__N_115CosOpConversion7combineEN4mlir8LocationENS1_5ValueES3_S3_S3_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  199:  combine(Location loc, Value scaledExp, Value reciprocalExp, Value sin,
        -:  200:          Value cos, ConversionPatternRewriter &rewriter) const override {
        -:  201:    // Complex cosine is defined as;
        -:  202:    //   cos(x + iy) = 0.5 * (exp(i(x + iy)) + exp(-i(x + iy)))
        -:  203:    // Plugging in:
        -:  204:    //   exp(i(x+iy)) = exp(-y + ix) = exp(-y)(cos(x) + i sin(x))
        -:  205:    //   exp(-i(x+iy)) = exp(y + i(-x)) = exp(y)(cos(x) + i (-sin(x)))
        -:  206:    // and defining t := exp(y)
        -:  207:    // We get:
        -:  208:    //   Re(cos(x + iy)) = (0.5/t + 0.5*t) * cos x
        -:  209:    //   Im(cos(x + iy)) = (0.5/t - 0.5*t) * sin x
    #####:  210:    Value sum = rewriter.create<arith::AddFOp>(loc, reciprocalExp, scaledExp);
call    0 never executed
call    1 never executed
    #####:  211:    Value resultReal = rewriter.create<arith::MulFOp>(loc, sum, cos);
call    0 never executed
call    1 never executed
    #####:  212:    Value diff = rewriter.create<arith::SubFOp>(loc, reciprocalExp, scaledExp);
call    0 never executed
call    1 never executed
    #####:  213:    Value resultImag = rewriter.create<arith::MulFOp>(loc, diff, sin);
call    0 never executed
    #####:  214:    return {resultReal, resultImag};
        -:  215:  }
        -:  216:};
        -:  217:
        -:  218:struct DivOpConversion : public OpConversionPattern<complex::DivOp> {
        -:  219:  using OpConversionPattern<complex::DivOp>::OpConversionPattern;
        -:  220:
        -:  221:  LogicalResult
function _ZNK12_GLOBAL__N_115DivOpConversion15matchAndRewriteEN4mlir7complex5DivOpENS2_12DivOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  222:  matchAndRewrite(complex::DivOp op, OpAdaptor adaptor,
        -:  223:                  ConversionPatternRewriter &rewriter) const override {
    #####:  224:    auto loc = op.getLoc();
call    0 never executed
    #####:  225:    auto type = adaptor.getLhs().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  226:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  227:
    #####:  228:    Value lhsReal =
    #####:  229:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  230:    Value lhsImag =
    #####:  231:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  232:    Value rhsReal =
    #####:  233:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  234:    Value rhsImag =
    #####:  235:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  236:
        -:  237:    // Smith's algorithm to divide complex numbers. It is just a bit smarter
        -:  238:    // way to compute the following formula:
        -:  239:    //  (lhsReal + lhsImag * i) / (rhsReal + rhsImag * i)
        -:  240:    //    = (lhsReal + lhsImag * i) (rhsReal - rhsImag * i) /
        -:  241:    //          ((rhsReal + rhsImag * i)(rhsReal - rhsImag * i))
        -:  242:    //    = ((lhsReal * rhsReal + lhsImag * rhsImag) +
        -:  243:    //          (lhsImag * rhsReal - lhsReal * rhsImag) * i) / ||rhs||^2
        -:  244:    //
        -:  245:    // Depending on whether |rhsReal| < |rhsImag| we compute either
        -:  246:    //   rhsRealImagRatio = rhsReal / rhsImag
        -:  247:    //   rhsRealImagDenom = rhsImag + rhsReal * rhsRealImagRatio
        -:  248:    //   resultReal = (lhsReal * rhsRealImagRatio + lhsImag) / rhsRealImagDenom
        -:  249:    //   resultImag = (lhsImag * rhsRealImagRatio - lhsReal) / rhsRealImagDenom
        -:  250:    //
        -:  251:    // or
        -:  252:    //
        -:  253:    //   rhsImagRealRatio = rhsImag / rhsReal
        -:  254:    //   rhsImagRealDenom = rhsReal + rhsImag * rhsImagRealRatio
        -:  255:    //   resultReal = (lhsReal + lhsImag * rhsImagRealRatio) / rhsImagRealDenom
        -:  256:    //   resultImag = (lhsImag - lhsReal * rhsImagRealRatio) / rhsImagRealDenom
        -:  257:    //
        -:  258:    // See https://dl.acm.org/citation.cfm?id=368661 for more details.
    #####:  259:    Value rhsRealImagRatio =
    #####:  260:        rewriter.create<arith::DivFOp>(loc, rhsReal, rhsImag);
call    0 never executed
call    1 never executed
    #####:  261:    Value rhsRealImagDenom = rewriter.create<arith::AddFOp>(
        -:  262:        loc, rhsImag,
    #####:  263:        rewriter.create<arith::MulFOp>(loc, rhsRealImagRatio, rhsReal));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  264:    Value realNumerator1 = rewriter.create<arith::AddFOp>(
    #####:  265:        loc, rewriter.create<arith::MulFOp>(loc, lhsReal, rhsRealImagRatio),
call    0 never executed
    #####:  266:        lhsImag);
call    0 never executed
call    1 never executed
    #####:  267:    Value resultReal1 =
    #####:  268:        rewriter.create<arith::DivFOp>(loc, realNumerator1, rhsRealImagDenom);
call    0 never executed
call    1 never executed
    #####:  269:    Value imagNumerator1 = rewriter.create<arith::SubFOp>(
    #####:  270:        loc, rewriter.create<arith::MulFOp>(loc, lhsImag, rhsRealImagRatio),
call    0 never executed
    #####:  271:        lhsReal);
call    0 never executed
call    1 never executed
    #####:  272:    Value resultImag1 =
    #####:  273:        rewriter.create<arith::DivFOp>(loc, imagNumerator1, rhsRealImagDenom);
call    0 never executed
call    1 never executed
        -:  274:
    #####:  275:    Value rhsImagRealRatio =
    #####:  276:        rewriter.create<arith::DivFOp>(loc, rhsImag, rhsReal);
call    0 never executed
call    1 never executed
    #####:  277:    Value rhsImagRealDenom = rewriter.create<arith::AddFOp>(
        -:  278:        loc, rhsReal,
    #####:  279:        rewriter.create<arith::MulFOp>(loc, rhsImagRealRatio, rhsImag));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  280:    Value realNumerator2 = rewriter.create<arith::AddFOp>(
        -:  281:        loc, lhsReal,
    #####:  282:        rewriter.create<arith::MulFOp>(loc, lhsImag, rhsImagRealRatio));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  283:    Value resultReal2 =
    #####:  284:        rewriter.create<arith::DivFOp>(loc, realNumerator2, rhsImagRealDenom);
call    0 never executed
call    1 never executed
    #####:  285:    Value imagNumerator2 = rewriter.create<arith::SubFOp>(
        -:  286:        loc, lhsImag,
    #####:  287:        rewriter.create<arith::MulFOp>(loc, lhsReal, rhsImagRealRatio));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  288:    Value resultImag2 =
    #####:  289:        rewriter.create<arith::DivFOp>(loc, imagNumerator2, rhsImagRealDenom);
call    0 never executed
call    1 never executed
        -:  290:
        -:  291:    // Consider corner cases.
        -:  292:    // Case 1. Zero denominator, numerator contains at most one NaN value.
    #####:  293:    Value zero = rewriter.create<arith::ConstantOp>(
    #####:  294:        loc, elementType, rewriter.getZeroAttr(elementType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  295:    Value rhsRealAbs = rewriter.create<math::AbsFOp>(loc, rhsReal);
call    0 never executed
call    1 never executed
    #####:  296:    Value rhsRealIsZero = rewriter.create<arith::CmpFOp>(
    #####:  297:        loc, arith::CmpFPredicate::OEQ, rhsRealAbs, zero);
call    0 never executed
call    1 never executed
    #####:  298:    Value rhsImagAbs = rewriter.create<math::AbsFOp>(loc, rhsImag);
call    0 never executed
call    1 never executed
    #####:  299:    Value rhsImagIsZero = rewriter.create<arith::CmpFOp>(
    #####:  300:        loc, arith::CmpFPredicate::OEQ, rhsImagAbs, zero);
call    0 never executed
call    1 never executed
    #####:  301:    Value lhsRealIsNotNaN = rewriter.create<arith::CmpFOp>(
    #####:  302:        loc, arith::CmpFPredicate::ORD, lhsReal, zero);
call    0 never executed
call    1 never executed
    #####:  303:    Value lhsImagIsNotNaN = rewriter.create<arith::CmpFOp>(
    #####:  304:        loc, arith::CmpFPredicate::ORD, lhsImag, zero);
call    0 never executed
call    1 never executed
    #####:  305:    Value lhsContainsNotNaNValue =
    #####:  306:        rewriter.create<arith::OrIOp>(loc, lhsRealIsNotNaN, lhsImagIsNotNaN);
call    0 never executed
call    1 never executed
    #####:  307:    Value resultIsInfinity = rewriter.create<arith::AndIOp>(
        -:  308:        loc, lhsContainsNotNaNValue,
    #####:  309:        rewriter.create<arith::AndIOp>(loc, rhsRealIsZero, rhsImagIsZero));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  310:    Value inf = rewriter.create<arith::ConstantOp>(
        -:  311:        loc, elementType,
    #####:  312:        rewriter.getFloatAttr(
call    0 never executed
    #####:  313:            elementType, APFloat::getInf(elementType.getFloatSemantics())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  314:    Value infWithSignOfRhsReal =
    #####:  315:        rewriter.create<math::CopySignOp>(loc, inf, rhsReal);
call    0 never executed
call    1 never executed
    #####:  316:    Value infinityResultReal =
    #####:  317:        rewriter.create<arith::MulFOp>(loc, infWithSignOfRhsReal, lhsReal);
call    0 never executed
call    1 never executed
    #####:  318:    Value infinityResultImag =
    #####:  319:        rewriter.create<arith::MulFOp>(loc, infWithSignOfRhsReal, lhsImag);
call    0 never executed
call    1 never executed
        -:  320:
        -:  321:    // Case 2. Infinite numerator, finite denominator.
    #####:  322:    Value rhsRealFinite = rewriter.create<arith::CmpFOp>(
    #####:  323:        loc, arith::CmpFPredicate::ONE, rhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  324:    Value rhsImagFinite = rewriter.create<arith::CmpFOp>(
    #####:  325:        loc, arith::CmpFPredicate::ONE, rhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  326:    Value rhsFinite =
    #####:  327:        rewriter.create<arith::AndIOp>(loc, rhsRealFinite, rhsImagFinite);
call    0 never executed
call    1 never executed
    #####:  328:    Value lhsRealAbs = rewriter.create<math::AbsFOp>(loc, lhsReal);
call    0 never executed
call    1 never executed
    #####:  329:    Value lhsRealInfinite = rewriter.create<arith::CmpFOp>(
    #####:  330:        loc, arith::CmpFPredicate::OEQ, lhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  331:    Value lhsImagAbs = rewriter.create<math::AbsFOp>(loc, lhsImag);
call    0 never executed
call    1 never executed
    #####:  332:    Value lhsImagInfinite = rewriter.create<arith::CmpFOp>(
    #####:  333:        loc, arith::CmpFPredicate::OEQ, lhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  334:    Value lhsInfinite =
    #####:  335:        rewriter.create<arith::OrIOp>(loc, lhsRealInfinite, lhsImagInfinite);
call    0 never executed
call    1 never executed
    #####:  336:    Value infNumFiniteDenom =
    #####:  337:        rewriter.create<arith::AndIOp>(loc, lhsInfinite, rhsFinite);
call    0 never executed
call    1 never executed
    #####:  338:    Value one = rewriter.create<arith::ConstantOp>(
    #####:  339:        loc, elementType, rewriter.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  340:    Value lhsRealIsInfWithSign = rewriter.create<math::CopySignOp>(
    #####:  341:        loc, rewriter.create<arith::SelectOp>(loc, lhsRealInfinite, one, zero),
call    0 never executed
    #####:  342:        lhsReal);
call    0 never executed
call    1 never executed
    #####:  343:    Value lhsImagIsInfWithSign = rewriter.create<math::CopySignOp>(
    #####:  344:        loc, rewriter.create<arith::SelectOp>(loc, lhsImagInfinite, one, zero),
call    0 never executed
    #####:  345:        lhsImag);
call    0 never executed
call    1 never executed
    #####:  346:    Value lhsRealIsInfWithSignTimesRhsReal =
    #####:  347:        rewriter.create<arith::MulFOp>(loc, lhsRealIsInfWithSign, rhsReal);
call    0 never executed
call    1 never executed
    #####:  348:    Value lhsImagIsInfWithSignTimesRhsImag =
    #####:  349:        rewriter.create<arith::MulFOp>(loc, lhsImagIsInfWithSign, rhsImag);
call    0 never executed
call    1 never executed
    #####:  350:    Value resultReal3 = rewriter.create<arith::MulFOp>(
        -:  351:        loc, inf,
    #####:  352:        rewriter.create<arith::AddFOp>(loc, lhsRealIsInfWithSignTimesRhsReal,
    #####:  353:                                       lhsImagIsInfWithSignTimesRhsImag));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  354:    Value lhsRealIsInfWithSignTimesRhsImag =
    #####:  355:        rewriter.create<arith::MulFOp>(loc, lhsRealIsInfWithSign, rhsImag);
call    0 never executed
call    1 never executed
    #####:  356:    Value lhsImagIsInfWithSignTimesRhsReal =
    #####:  357:        rewriter.create<arith::MulFOp>(loc, lhsImagIsInfWithSign, rhsReal);
call    0 never executed
call    1 never executed
    #####:  358:    Value resultImag3 = rewriter.create<arith::MulFOp>(
        -:  359:        loc, inf,
    #####:  360:        rewriter.create<arith::SubFOp>(loc, lhsImagIsInfWithSignTimesRhsReal,
    #####:  361:                                       lhsRealIsInfWithSignTimesRhsImag));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  362:
        -:  363:    // Case 3: Finite numerator, infinite denominator.
    #####:  364:    Value lhsRealFinite = rewriter.create<arith::CmpFOp>(
    #####:  365:        loc, arith::CmpFPredicate::ONE, lhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  366:    Value lhsImagFinite = rewriter.create<arith::CmpFOp>(
    #####:  367:        loc, arith::CmpFPredicate::ONE, lhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  368:    Value lhsFinite =
    #####:  369:        rewriter.create<arith::AndIOp>(loc, lhsRealFinite, lhsImagFinite);
call    0 never executed
call    1 never executed
    #####:  370:    Value rhsRealInfinite = rewriter.create<arith::CmpFOp>(
    #####:  371:        loc, arith::CmpFPredicate::OEQ, rhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  372:    Value rhsImagInfinite = rewriter.create<arith::CmpFOp>(
    #####:  373:        loc, arith::CmpFPredicate::OEQ, rhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  374:    Value rhsInfinite =
    #####:  375:        rewriter.create<arith::OrIOp>(loc, rhsRealInfinite, rhsImagInfinite);
call    0 never executed
call    1 never executed
    #####:  376:    Value finiteNumInfiniteDenom =
    #####:  377:        rewriter.create<arith::AndIOp>(loc, lhsFinite, rhsInfinite);
call    0 never executed
call    1 never executed
    #####:  378:    Value rhsRealIsInfWithSign = rewriter.create<math::CopySignOp>(
    #####:  379:        loc, rewriter.create<arith::SelectOp>(loc, rhsRealInfinite, one, zero),
call    0 never executed
    #####:  380:        rhsReal);
call    0 never executed
call    1 never executed
    #####:  381:    Value rhsImagIsInfWithSign = rewriter.create<math::CopySignOp>(
    #####:  382:        loc, rewriter.create<arith::SelectOp>(loc, rhsImagInfinite, one, zero),
call    0 never executed
    #####:  383:        rhsImag);
call    0 never executed
call    1 never executed
    #####:  384:    Value rhsRealIsInfWithSignTimesLhsReal =
    #####:  385:        rewriter.create<arith::MulFOp>(loc, lhsReal, rhsRealIsInfWithSign);
call    0 never executed
call    1 never executed
    #####:  386:    Value rhsImagIsInfWithSignTimesLhsImag =
    #####:  387:        rewriter.create<arith::MulFOp>(loc, lhsImag, rhsImagIsInfWithSign);
call    0 never executed
call    1 never executed
    #####:  388:    Value resultReal4 = rewriter.create<arith::MulFOp>(
        -:  389:        loc, zero,
    #####:  390:        rewriter.create<arith::AddFOp>(loc, rhsRealIsInfWithSignTimesLhsReal,
    #####:  391:                                       rhsImagIsInfWithSignTimesLhsImag));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  392:    Value rhsRealIsInfWithSignTimesLhsImag =
    #####:  393:        rewriter.create<arith::MulFOp>(loc, lhsImag, rhsRealIsInfWithSign);
call    0 never executed
call    1 never executed
    #####:  394:    Value rhsImagIsInfWithSignTimesLhsReal =
    #####:  395:        rewriter.create<arith::MulFOp>(loc, lhsReal, rhsImagIsInfWithSign);
call    0 never executed
call    1 never executed
    #####:  396:    Value resultImag4 = rewriter.create<arith::MulFOp>(
        -:  397:        loc, zero,
    #####:  398:        rewriter.create<arith::SubFOp>(loc, rhsRealIsInfWithSignTimesLhsImag,
    #####:  399:                                       rhsImagIsInfWithSignTimesLhsReal));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  400:
    #####:  401:    Value realAbsSmallerThanImagAbs = rewriter.create<arith::CmpFOp>(
    #####:  402:        loc, arith::CmpFPredicate::OLT, rhsRealAbs, rhsImagAbs);
call    0 never executed
call    1 never executed
    #####:  403:    Value resultReal = rewriter.create<arith::SelectOp>(
    #####:  404:        loc, realAbsSmallerThanImagAbs, resultReal1, resultReal2);
call    0 never executed
call    1 never executed
    #####:  405:    Value resultImag = rewriter.create<arith::SelectOp>(
    #####:  406:        loc, realAbsSmallerThanImagAbs, resultImag1, resultImag2);
call    0 never executed
call    1 never executed
    #####:  407:    Value resultRealSpecialCase3 = rewriter.create<arith::SelectOp>(
    #####:  408:        loc, finiteNumInfiniteDenom, resultReal4, resultReal);
call    0 never executed
call    1 never executed
    #####:  409:    Value resultImagSpecialCase3 = rewriter.create<arith::SelectOp>(
    #####:  410:        loc, finiteNumInfiniteDenom, resultImag4, resultImag);
call    0 never executed
call    1 never executed
    #####:  411:    Value resultRealSpecialCase2 = rewriter.create<arith::SelectOp>(
    #####:  412:        loc, infNumFiniteDenom, resultReal3, resultRealSpecialCase3);
call    0 never executed
call    1 never executed
    #####:  413:    Value resultImagSpecialCase2 = rewriter.create<arith::SelectOp>(
    #####:  414:        loc, infNumFiniteDenom, resultImag3, resultImagSpecialCase3);
call    0 never executed
call    1 never executed
    #####:  415:    Value resultRealSpecialCase1 = rewriter.create<arith::SelectOp>(
    #####:  416:        loc, resultIsInfinity, infinityResultReal, resultRealSpecialCase2);
call    0 never executed
call    1 never executed
    #####:  417:    Value resultImagSpecialCase1 = rewriter.create<arith::SelectOp>(
    #####:  418:        loc, resultIsInfinity, infinityResultImag, resultImagSpecialCase2);
call    0 never executed
call    1 never executed
        -:  419:
    #####:  420:    Value resultRealIsNaN = rewriter.create<arith::CmpFOp>(
    #####:  421:        loc, arith::CmpFPredicate::UNO, resultReal, zero);
call    0 never executed
call    1 never executed
    #####:  422:    Value resultImagIsNaN = rewriter.create<arith::CmpFOp>(
    #####:  423:        loc, arith::CmpFPredicate::UNO, resultImag, zero);
call    0 never executed
call    1 never executed
    #####:  424:    Value resultIsNaN =
    #####:  425:        rewriter.create<arith::AndIOp>(loc, resultRealIsNaN, resultImagIsNaN);
call    0 never executed
call    1 never executed
    #####:  426:    Value resultRealWithSpecialCases = rewriter.create<arith::SelectOp>(
    #####:  427:        loc, resultIsNaN, resultRealSpecialCase1, resultReal);
call    0 never executed
call    1 never executed
    #####:  428:    Value resultImagWithSpecialCases = rewriter.create<arith::SelectOp>(
    #####:  429:        loc, resultIsNaN, resultImagSpecialCase1, resultImag);
call    0 never executed
call    1 never executed
        -:  430:
    #####:  431:    rewriter.replaceOpWithNewOp<complex::CreateOp>(
    #####:  432:        op, type, resultRealWithSpecialCases, resultImagWithSpecialCases);
call    0 never executed
    #####:  433:    return success();
        -:  434:  }
        -:  435:};
        -:  436:
        -:  437:struct ExpOpConversion : public OpConversionPattern<complex::ExpOp> {
        -:  438:  using OpConversionPattern<complex::ExpOp>::OpConversionPattern;
        -:  439:
        -:  440:  LogicalResult
function _ZNK12_GLOBAL__N_115ExpOpConversion15matchAndRewriteEN4mlir7complex5ExpOpENS2_12ExpOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  441:  matchAndRewrite(complex::ExpOp op, OpAdaptor adaptor,
        -:  442:                  ConversionPatternRewriter &rewriter) const override {
    #####:  443:    auto loc = op.getLoc();
call    0 never executed
    #####:  444:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  445:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  446:
    #####:  447:    Value real =
    #####:  448:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  449:    Value imag =
    #####:  450:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  451:    Value expReal = rewriter.create<math::ExpOp>(loc, real);
call    0 never executed
call    1 never executed
    #####:  452:    Value cosImag = rewriter.create<math::CosOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  453:    Value resultReal = rewriter.create<arith::MulFOp>(loc, expReal, cosImag);
call    0 never executed
call    1 never executed
    #####:  454:    Value sinImag = rewriter.create<math::SinOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  455:    Value resultImag = rewriter.create<arith::MulFOp>(loc, expReal, sinImag);
call    0 never executed
call    1 never executed
        -:  456:
    #####:  457:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
    #####:  458:                                                   resultImag);
call    0 never executed
    #####:  459:    return success();
        -:  460:  }
        -:  461:};
        -:  462:
        -:  463:struct Expm1OpConversion : public OpConversionPattern<complex::Expm1Op> {
        -:  464:  using OpConversionPattern<complex::Expm1Op>::OpConversionPattern;
        -:  465:
        -:  466:  LogicalResult
function _ZNK12_GLOBAL__N_117Expm1OpConversion15matchAndRewriteEN4mlir7complex7Expm1OpENS2_14Expm1OpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  467:  matchAndRewrite(complex::Expm1Op op, OpAdaptor adaptor,
        -:  468:                  ConversionPatternRewriter &rewriter) const override {
    #####:  469:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  470:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  471:
    #####:  472:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
    #####:  473:    Value exp = b.create<complex::ExpOp>(adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  474:
    #####:  475:    Value real = b.create<complex::ReOp>(elementType, exp);
call    0 never executed
call    1 never executed
    #####:  476:    Value one = b.create<arith::ConstantOp>(elementType,
    #####:  477:                                            b.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  478:    Value realMinusOne = b.create<arith::SubFOp>(real, one);
call    0 never executed
call    1 never executed
    #####:  479:    Value imag = b.create<complex::ImOp>(elementType, exp);
call    0 never executed
call    1 never executed
        -:  480:
    #####:  481:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, realMinusOne,
    #####:  482:                                                   imag);
call    0 never executed
    #####:  483:    return success();
        -:  484:  }
        -:  485:};
        -:  486:
        -:  487:struct LogOpConversion : public OpConversionPattern<complex::LogOp> {
        -:  488:  using OpConversionPattern<complex::LogOp>::OpConversionPattern;
        -:  489:
        -:  490:  LogicalResult
function _ZNK12_GLOBAL__N_115LogOpConversion15matchAndRewriteEN4mlir7complex5LogOpENS2_12LogOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  491:  matchAndRewrite(complex::LogOp op, OpAdaptor adaptor,
        -:  492:                  ConversionPatternRewriter &rewriter) const override {
    #####:  493:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  494:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  495:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  496:
    #####:  497:    Value abs = b.create<complex::AbsOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  498:    Value resultReal = b.create<math::LogOp>(elementType, abs);
call    0 never executed
call    1 never executed
    #####:  499:    Value real = b.create<complex::ReOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  500:    Value imag = b.create<complex::ImOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  501:    Value resultImag = b.create<math::Atan2Op>(elementType, imag, real);
call    0 never executed
call    1 never executed
    #####:  502:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
    #####:  503:                                                   resultImag);
call    0 never executed
    #####:  504:    return success();
        -:  505:  }
        -:  506:};
        -:  507:
        -:  508:struct Log1pOpConversion : public OpConversionPattern<complex::Log1pOp> {
        -:  509:  using OpConversionPattern<complex::Log1pOp>::OpConversionPattern;
        -:  510:
        -:  511:  LogicalResult
function _ZNK12_GLOBAL__N_117Log1pOpConversion15matchAndRewriteEN4mlir7complex7Log1pOpENS2_14Log1pOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  512:  matchAndRewrite(complex::Log1pOp op, OpAdaptor adaptor,
        -:  513:                  ConversionPatternRewriter &rewriter) const override {
    #####:  514:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  515:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  516:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  517:
    #####:  518:    Value real = b.create<complex::ReOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  519:    Value imag = b.create<complex::ImOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  520:
    #####:  521:    Value half = b.create<arith::ConstantOp>(elementType,
    #####:  522:                                             b.getFloatAttr(elementType, 0.5));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  523:    Value one = b.create<arith::ConstantOp>(elementType,
    #####:  524:                                            b.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  525:    Value two = b.create<arith::ConstantOp>(elementType,
    #####:  526:                                            b.getFloatAttr(elementType, 2));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  527:
        -:  528:    // log1p(a+bi) = .5*log((a+1)^2+b^2) + i*atan2(b, a + 1)
        -:  529:    // log((a+1)+bi) = .5*log(a*a + 2*a + 1 + b*b) + i*atan2(b, a+1)
        -:  530:    // log((a+1)+bi) = .5*log1p(a*a + 2*a + b*b) + i*atan2(b, a+1)
    #####:  531:    Value sumSq = b.create<arith::MulFOp>(real, real);
call    0 never executed
call    1 never executed
    #####:  532:    sumSq = b.create<arith::AddFOp>(sumSq, b.create<arith::MulFOp>(real, two));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  533:    sumSq = b.create<arith::AddFOp>(sumSq, b.create<arith::MulFOp>(imag, imag));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  534:    Value logSumSq = b.create<math::Log1pOp>(elementType, sumSq);
call    0 never executed
call    1 never executed
    #####:  535:    Value resultReal = b.create<arith::MulFOp>(logSumSq, half);
call    0 never executed
call    1 never executed
        -:  536:
    #####:  537:    Value realPlusOne = b.create<arith::AddFOp>(real, one);
call    0 never executed
call    1 never executed
        -:  538:
    #####:  539:    Value resultImag = b.create<math::Atan2Op>(elementType, imag, realPlusOne);
call    0 never executed
call    1 never executed
    #####:  540:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
    #####:  541:                                                   resultImag);
call    0 never executed
    #####:  542:    return success();
        -:  543:  }
        -:  544:};
        -:  545:
        -:  546:struct MulOpConversion : public OpConversionPattern<complex::MulOp> {
        -:  547:  using OpConversionPattern<complex::MulOp>::OpConversionPattern;
        -:  548:
        -:  549:  LogicalResult
function _ZNK12_GLOBAL__N_115MulOpConversion15matchAndRewriteEN4mlir7complex5MulOpENS2_12MulOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  550:  matchAndRewrite(complex::MulOp op, OpAdaptor adaptor,
        -:  551:                  ConversionPatternRewriter &rewriter) const override {
    #####:  552:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
    #####:  553:    auto type = adaptor.getLhs().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  554:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  555:
    #####:  556:    Value lhsReal = b.create<complex::ReOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  557:    Value lhsRealAbs = b.create<math::AbsFOp>(lhsReal);
call    0 never executed
call    1 never executed
    #####:  558:    Value lhsImag = b.create<complex::ImOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  559:    Value lhsImagAbs = b.create<math::AbsFOp>(lhsImag);
call    0 never executed
call    1 never executed
    #####:  560:    Value rhsReal = b.create<complex::ReOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  561:    Value rhsRealAbs = b.create<math::AbsFOp>(rhsReal);
call    0 never executed
call    1 never executed
    #####:  562:    Value rhsImag = b.create<complex::ImOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  563:    Value rhsImagAbs = b.create<math::AbsFOp>(rhsImag);
call    0 never executed
call    1 never executed
        -:  564:
    #####:  565:    Value lhsRealTimesRhsReal = b.create<arith::MulFOp>(lhsReal, rhsReal);
call    0 never executed
call    1 never executed
    #####:  566:    Value lhsRealTimesRhsRealAbs = b.create<math::AbsFOp>(lhsRealTimesRhsReal);
call    0 never executed
call    1 never executed
    #####:  567:    Value lhsImagTimesRhsImag = b.create<arith::MulFOp>(lhsImag, rhsImag);
call    0 never executed
call    1 never executed
    #####:  568:    Value lhsImagTimesRhsImagAbs = b.create<math::AbsFOp>(lhsImagTimesRhsImag);
call    0 never executed
call    1 never executed
    #####:  569:    Value real =
call    0 never executed
    #####:  570:        b.create<arith::SubFOp>(lhsRealTimesRhsReal, lhsImagTimesRhsImag);
call    0 never executed
        -:  571:
    #####:  572:    Value lhsImagTimesRhsReal = b.create<arith::MulFOp>(lhsImag, rhsReal);
call    0 never executed
call    1 never executed
    #####:  573:    Value lhsImagTimesRhsRealAbs = b.create<math::AbsFOp>(lhsImagTimesRhsReal);
call    0 never executed
call    1 never executed
    #####:  574:    Value lhsRealTimesRhsImag = b.create<arith::MulFOp>(lhsReal, rhsImag);
call    0 never executed
call    1 never executed
    #####:  575:    Value lhsRealTimesRhsImagAbs = b.create<math::AbsFOp>(lhsRealTimesRhsImag);
call    0 never executed
call    1 never executed
    #####:  576:    Value imag =
call    0 never executed
    #####:  577:        b.create<arith::AddFOp>(lhsImagTimesRhsReal, lhsRealTimesRhsImag);
call    0 never executed
        -:  578:
        -:  579:    // Handle cases where the "naive" calculation results in NaN values.
    #####:  580:    Value realIsNan =
    #####:  581:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, real, real);
call    0 never executed
call    1 never executed
    #####:  582:    Value imagIsNan =
    #####:  583:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, imag, imag);
call    0 never executed
call    1 never executed
    #####:  584:    Value isNan = b.create<arith::AndIOp>(realIsNan, imagIsNan);
call    0 never executed
call    1 never executed
        -:  585:
    #####:  586:    Value inf = b.create<arith::ConstantOp>(
        -:  587:        elementType,
    #####:  588:        b.getFloatAttr(elementType,
call    0 never executed
    #####:  589:                       APFloat::getInf(elementType.getFloatSemantics())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  590:
        -:  591:    // Case 1. `lhsReal` or `lhsImag` are infinite.
    #####:  592:    Value lhsRealIsInf =
    #####:  593:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, lhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  594:    Value lhsImagIsInf =
    #####:  595:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, lhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  596:    Value lhsIsInf = b.create<arith::OrIOp>(lhsRealIsInf, lhsImagIsInf);
call    0 never executed
call    1 never executed
    #####:  597:    Value rhsRealIsNan =
    #####:  598:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, rhsReal, rhsReal);
call    0 never executed
call    1 never executed
    #####:  599:    Value rhsImagIsNan =
    #####:  600:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, rhsImag, rhsImag);
call    0 never executed
call    1 never executed
    #####:  601:    Value zero =
    #####:  602:        b.create<arith::ConstantOp>(elementType, b.getZeroAttr(elementType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  603:    Value one = b.create<arith::ConstantOp>(elementType,
    #####:  604:                                            b.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  605:    Value lhsRealIsInfFloat =
call    0 never executed
    #####:  606:        b.create<arith::SelectOp>(lhsRealIsInf, one, zero);
call    0 never executed
    #####:  607:    lhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  608:        lhsIsInf, b.create<math::CopySignOp>(lhsRealIsInfFloat, lhsReal),
call    0 never executed
    #####:  609:        lhsReal);
call    0 never executed
    #####:  610:    Value lhsImagIsInfFloat =
call    0 never executed
    #####:  611:        b.create<arith::SelectOp>(lhsImagIsInf, one, zero);
call    0 never executed
    #####:  612:    lhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  613:        lhsIsInf, b.create<math::CopySignOp>(lhsImagIsInfFloat, lhsImag),
call    0 never executed
    #####:  614:        lhsImag);
call    0 never executed
    #####:  615:    Value lhsIsInfAndRhsRealIsNan =
call    0 never executed
    #####:  616:        b.create<arith::AndIOp>(lhsIsInf, rhsRealIsNan);
call    0 never executed
    #####:  617:    rhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  618:        lhsIsInfAndRhsRealIsNan, b.create<math::CopySignOp>(zero, rhsReal),
call    0 never executed
    #####:  619:        rhsReal);
call    0 never executed
    #####:  620:    Value lhsIsInfAndRhsImagIsNan =
call    0 never executed
    #####:  621:        b.create<arith::AndIOp>(lhsIsInf, rhsImagIsNan);
call    0 never executed
    #####:  622:    rhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  623:        lhsIsInfAndRhsImagIsNan, b.create<math::CopySignOp>(zero, rhsImag),
call    0 never executed
    #####:  624:        rhsImag);
call    0 never executed
        -:  625:
        -:  626:    // Case 2. `rhsReal` or `rhsImag` are infinite.
    #####:  627:    Value rhsRealIsInf =
    #####:  628:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, rhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  629:    Value rhsImagIsInf =
    #####:  630:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, rhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  631:    Value rhsIsInf = b.create<arith::OrIOp>(rhsRealIsInf, rhsImagIsInf);
call    0 never executed
call    1 never executed
    #####:  632:    Value lhsRealIsNan =
    #####:  633:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, lhsReal, lhsReal);
call    0 never executed
call    1 never executed
    #####:  634:    Value lhsImagIsNan =
    #####:  635:        b.create<arith::CmpFOp>(arith::CmpFPredicate::UNO, lhsImag, lhsImag);
call    0 never executed
call    1 never executed
    #####:  636:    Value rhsRealIsInfFloat =
call    0 never executed
    #####:  637:        b.create<arith::SelectOp>(rhsRealIsInf, one, zero);
call    0 never executed
    #####:  638:    rhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  639:        rhsIsInf, b.create<math::CopySignOp>(rhsRealIsInfFloat, rhsReal),
call    0 never executed
    #####:  640:        rhsReal);
call    0 never executed
    #####:  641:    Value rhsImagIsInfFloat =
call    0 never executed
    #####:  642:        b.create<arith::SelectOp>(rhsImagIsInf, one, zero);
call    0 never executed
    #####:  643:    rhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  644:        rhsIsInf, b.create<math::CopySignOp>(rhsImagIsInfFloat, rhsImag),
call    0 never executed
    #####:  645:        rhsImag);
call    0 never executed
    #####:  646:    Value rhsIsInfAndLhsRealIsNan =
call    0 never executed
    #####:  647:        b.create<arith::AndIOp>(rhsIsInf, lhsRealIsNan);
call    0 never executed
    #####:  648:    lhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  649:        rhsIsInfAndLhsRealIsNan, b.create<math::CopySignOp>(zero, lhsReal),
call    0 never executed
    #####:  650:        lhsReal);
call    0 never executed
    #####:  651:    Value rhsIsInfAndLhsImagIsNan =
call    0 never executed
    #####:  652:        b.create<arith::AndIOp>(rhsIsInf, lhsImagIsNan);
call    0 never executed
    #####:  653:    lhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  654:        rhsIsInfAndLhsImagIsNan, b.create<math::CopySignOp>(zero, lhsImag),
call    0 never executed
    #####:  655:        lhsImag);
call    0 never executed
    #####:  656:    Value recalc = b.create<arith::OrIOp>(lhsIsInf, rhsIsInf);
call    0 never executed
call    1 never executed
        -:  657:
        -:  658:    // Case 3. One of the pairwise products of left hand side with right hand
        -:  659:    // side is infinite.
    #####:  660:    Value lhsRealTimesRhsRealIsInf = b.create<arith::CmpFOp>(
    #####:  661:        arith::CmpFPredicate::OEQ, lhsRealTimesRhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  662:    Value lhsImagTimesRhsImagIsInf = b.create<arith::CmpFOp>(
    #####:  663:        arith::CmpFPredicate::OEQ, lhsImagTimesRhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  664:    Value isSpecialCase = b.create<arith::OrIOp>(lhsRealTimesRhsRealIsInf,
call    0 never executed
    #####:  665:                                                 lhsImagTimesRhsImagIsInf);
call    0 never executed
    #####:  666:    Value lhsRealTimesRhsImagIsInf = b.create<arith::CmpFOp>(
    #####:  667:        arith::CmpFPredicate::OEQ, lhsRealTimesRhsImagAbs, inf);
call    0 never executed
call    1 never executed
    #####:  668:    isSpecialCase =
call    0 never executed
    #####:  669:        b.create<arith::OrIOp>(isSpecialCase, lhsRealTimesRhsImagIsInf);
call    0 never executed
    #####:  670:    Value lhsImagTimesRhsRealIsInf = b.create<arith::CmpFOp>(
    #####:  671:        arith::CmpFPredicate::OEQ, lhsImagTimesRhsRealAbs, inf);
call    0 never executed
call    1 never executed
    #####:  672:    isSpecialCase =
call    0 never executed
    #####:  673:        b.create<arith::OrIOp>(isSpecialCase, lhsImagTimesRhsRealIsInf);
call    0 never executed
    #####:  674:    Type i1Type = b.getI1Type();
call    0 never executed
    #####:  675:    Value notRecalc = b.create<arith::XOrIOp>(
        -:  676:        recalc,
    #####:  677:        b.create<arith::ConstantOp>(i1Type, b.getIntegerAttr(i1Type, 1)));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  678:    isSpecialCase = b.create<arith::AndIOp>(isSpecialCase, notRecalc);
call    0 never executed
call    1 never executed
    #####:  679:    Value isSpecialCaseAndLhsRealIsNan =
call    0 never executed
    #####:  680:        b.create<arith::AndIOp>(isSpecialCase, lhsRealIsNan);
call    0 never executed
    #####:  681:    lhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  682:        isSpecialCaseAndLhsRealIsNan, b.create<math::CopySignOp>(zero, lhsReal),
call    0 never executed
    #####:  683:        lhsReal);
call    0 never executed
    #####:  684:    Value isSpecialCaseAndLhsImagIsNan =
call    0 never executed
    #####:  685:        b.create<arith::AndIOp>(isSpecialCase, lhsImagIsNan);
call    0 never executed
    #####:  686:    lhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  687:        isSpecialCaseAndLhsImagIsNan, b.create<math::CopySignOp>(zero, lhsImag),
call    0 never executed
    #####:  688:        lhsImag);
call    0 never executed
    #####:  689:    Value isSpecialCaseAndRhsRealIsNan =
call    0 never executed
    #####:  690:        b.create<arith::AndIOp>(isSpecialCase, rhsRealIsNan);
call    0 never executed
    #####:  691:    rhsReal = b.create<arith::SelectOp>(
call    0 never executed
    #####:  692:        isSpecialCaseAndRhsRealIsNan, b.create<math::CopySignOp>(zero, rhsReal),
call    0 never executed
    #####:  693:        rhsReal);
call    0 never executed
    #####:  694:    Value isSpecialCaseAndRhsImagIsNan =
call    0 never executed
    #####:  695:        b.create<arith::AndIOp>(isSpecialCase, rhsImagIsNan);
call    0 never executed
    #####:  696:    rhsImag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  697:        isSpecialCaseAndRhsImagIsNan, b.create<math::CopySignOp>(zero, rhsImag),
call    0 never executed
    #####:  698:        rhsImag);
call    0 never executed
    #####:  699:    recalc = b.create<arith::OrIOp>(recalc, isSpecialCase);
call    0 never executed
call    1 never executed
    #####:  700:    recalc = b.create<arith::AndIOp>(isNan, recalc);
call    0 never executed
call    1 never executed
        -:  701:
        -:  702:    // Recalculate real part.
    #####:  703:    lhsRealTimesRhsReal = b.create<arith::MulFOp>(lhsReal, rhsReal);
call    0 never executed
call    1 never executed
    #####:  704:    lhsImagTimesRhsImag = b.create<arith::MulFOp>(lhsImag, rhsImag);
call    0 never executed
call    1 never executed
    #####:  705:    Value newReal =
call    0 never executed
    #####:  706:        b.create<arith::SubFOp>(lhsRealTimesRhsReal, lhsImagTimesRhsImag);
call    0 never executed
    #####:  707:    real = b.create<arith::SelectOp>(
call    0 never executed
    #####:  708:        recalc, b.create<arith::MulFOp>(inf, newReal), real);
call    0 never executed
call    1 never executed
        -:  709:
        -:  710:    // Recalculate imag part.
    #####:  711:    lhsImagTimesRhsReal = b.create<arith::MulFOp>(lhsImag, rhsReal);
call    0 never executed
call    1 never executed
    #####:  712:    lhsRealTimesRhsImag = b.create<arith::MulFOp>(lhsReal, rhsImag);
call    0 never executed
call    1 never executed
    #####:  713:    Value newImag =
call    0 never executed
    #####:  714:        b.create<arith::AddFOp>(lhsImagTimesRhsReal, lhsRealTimesRhsImag);
call    0 never executed
    #####:  715:    imag = b.create<arith::SelectOp>(
call    0 never executed
    #####:  716:        recalc, b.create<arith::MulFOp>(inf, newImag), imag);
call    0 never executed
call    1 never executed
        -:  717:
    #####:  718:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, real, imag);
call    0 never executed
    #####:  719:    return success();
        -:  720:  }
        -:  721:};
        -:  722:
        -:  723:struct NegOpConversion : public OpConversionPattern<complex::NegOp> {
        -:  724:  using OpConversionPattern<complex::NegOp>::OpConversionPattern;
        -:  725:
        -:  726:  LogicalResult
function _ZNK12_GLOBAL__N_115NegOpConversion15matchAndRewriteEN4mlir7complex5NegOpENS2_12NegOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  727:  matchAndRewrite(complex::NegOp op, OpAdaptor adaptor,
        -:  728:                  ConversionPatternRewriter &rewriter) const override {
    #####:  729:    auto loc = op.getLoc();
call    0 never executed
    #####:  730:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  731:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  732:
    #####:  733:    Value real =
    #####:  734:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  735:    Value imag =
    #####:  736:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  737:    Value negReal = rewriter.create<arith::NegFOp>(loc, real);
call    0 never executed
call    1 never executed
    #####:  738:    Value negImag = rewriter.create<arith::NegFOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  739:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, negReal, negImag);
call    0 never executed
    #####:  740:    return success();
        -:  741:  }
        -:  742:};
        -:  743:
        -:  744:struct SinOpConversion : public TrigonometricOpConversion<complex::SinOp> {
        -:  745:  using TrigonometricOpConversion<complex::SinOp>::TrigonometricOpConversion;
        -:  746:
        -:  747:  std::pair<Value, Value>
function _ZNK12_GLOBAL__N_115SinOpConversion7combineEN4mlir8LocationENS1_5ValueES3_S3_S3_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  748:  combine(Location loc, Value scaledExp, Value reciprocalExp, Value sin,
        -:  749:          Value cos, ConversionPatternRewriter &rewriter) const override {
        -:  750:    // Complex sine is defined as;
        -:  751:    //   sin(x + iy) = -0.5i * (exp(i(x + iy)) - exp(-i(x + iy)))
        -:  752:    // Plugging in:
        -:  753:    //   exp(i(x+iy)) = exp(-y + ix) = exp(-y)(cos(x) + i sin(x))
        -:  754:    //   exp(-i(x+iy)) = exp(y + i(-x)) = exp(y)(cos(x) + i (-sin(x)))
        -:  755:    // and defining t := exp(y)
        -:  756:    // We get:
        -:  757:    //   Re(sin(x + iy)) = (0.5*t + 0.5/t) * sin x
        -:  758:    //   Im(cos(x + iy)) = (0.5*t - 0.5/t) * cos x
    #####:  759:    Value sum = rewriter.create<arith::AddFOp>(loc, scaledExp, reciprocalExp);
call    0 never executed
call    1 never executed
    #####:  760:    Value resultReal = rewriter.create<arith::MulFOp>(loc, sum, sin);
call    0 never executed
call    1 never executed
    #####:  761:    Value diff = rewriter.create<arith::SubFOp>(loc, scaledExp, reciprocalExp);
call    0 never executed
call    1 never executed
    #####:  762:    Value resultImag = rewriter.create<arith::MulFOp>(loc, diff, cos);
call    0 never executed
    #####:  763:    return {resultReal, resultImag};
        -:  764:  }
        -:  765:};
        -:  766:
        -:  767:// The algorithm is listed in https://dl.acm.org/doi/pdf/10.1145/363717.363780.
        -:  768:struct SqrtOpConversion : public OpConversionPattern<complex::SqrtOp> {
        -:  769:  using OpConversionPattern<complex::SqrtOp>::OpConversionPattern;
        -:  770:
        -:  771:  LogicalResult
function _ZNK12_GLOBAL__N_116SqrtOpConversion15matchAndRewriteEN4mlir7complex6SqrtOpENS2_13SqrtOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  772:  matchAndRewrite(complex::SqrtOp op, OpAdaptor adaptor,
        -:  773:                  ConversionPatternRewriter &rewriter) const override {
    #####:  774:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  775:
    #####:  776:    auto type = op.getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  777:    Type elementType = type.getElementType();
call    0 never executed
    #####:  778:    Value arg = adaptor.getComplex();
call    0 never executed
        -:  779:
    #####:  780:    Value zero =
    #####:  781:        b.create<arith::ConstantOp>(elementType, b.getZeroAttr(elementType));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  782:
    #####:  783:    Value real = b.create<complex::ReOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  784:    Value imag = b.create<complex::ImOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  785:
    #####:  786:    Value absLhs = b.create<math::AbsFOp>(real);
call    0 never executed
call    1 never executed
    #####:  787:    Value absArg = b.create<complex::AbsOp>(elementType, arg);
call    0 never executed
call    1 never executed
    #####:  788:    Value addAbs = b.create<arith::AddFOp>(absLhs, absArg);
call    0 never executed
call    1 never executed
        -:  789:
    #####:  790:    Value half = b.create<arith::ConstantOp>(elementType,
    #####:  791:                                             b.getFloatAttr(elementType, 0.5));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  792:    Value halfAddAbs = b.create<arith::MulFOp>(addAbs, half);
call    0 never executed
call    1 never executed
    #####:  793:    Value sqrtAddAbs = b.create<math::SqrtOp>(halfAddAbs);
call    0 never executed
call    1 never executed
        -:  794:
    #####:  795:    Value realIsNegative =
    #####:  796:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OLT, real, zero);
call    0 never executed
call    1 never executed
    #####:  797:    Value imagIsNegative =
    #####:  798:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OLT, imag, zero);
call    0 never executed
call    1 never executed
        -:  799:
    #####:  800:    Value resultReal = sqrtAddAbs;
        -:  801:
    #####:  802:    Value imagDivTwoResultReal = b.create<arith::DivFOp>(
call    0 never executed
    #####:  803:        imag, b.create<arith::AddFOp>(resultReal, resultReal));
call    0 never executed
call    1 never executed
        -:  804:
    #####:  805:    Value negativeResultReal = b.create<arith::NegFOp>(resultReal);
call    0 never executed
call    1 never executed
        -:  806:
    #####:  807:    Value resultImag = b.create<arith::SelectOp>(
call    0 never executed
        -:  808:        realIsNegative,
    #####:  809:        b.create<arith::SelectOp>(imagIsNegative, negativeResultReal,
    #####:  810:                                  resultReal),
call    0 never executed
    #####:  811:        imagDivTwoResultReal);
call    0 never executed
        -:  812:
    #####:  813:    resultReal = b.create<arith::SelectOp>(
call    0 never executed
        -:  814:        realIsNegative,
    #####:  815:        b.create<arith::DivFOp>(
    #####:  816:            imag, b.create<arith::AddFOp>(resultImag, resultImag)),
call    0 never executed
call    1 never executed
    #####:  817:        resultReal);
call    0 never executed
        -:  818:
    #####:  819:    Value realIsZero =
    #####:  820:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, real, zero);
call    0 never executed
call    1 never executed
    #####:  821:    Value imagIsZero =
    #####:  822:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, imag, zero);
call    0 never executed
call    1 never executed
    #####:  823:    Value argIsZero = b.create<arith::AndIOp>(realIsZero, imagIsZero);
call    0 never executed
call    1 never executed
        -:  824:
    #####:  825:    resultReal = b.create<arith::SelectOp>(argIsZero, zero, resultReal);
call    0 never executed
call    1 never executed
    #####:  826:    resultImag = b.create<arith::SelectOp>(argIsZero, zero, resultImag);
call    0 never executed
call    1 never executed
        -:  827:
    #####:  828:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, resultReal,
    #####:  829:                                                   resultImag);
call    0 never executed
    #####:  830:    return success();
        -:  831:  }
        -:  832:};
        -:  833:
        -:  834:struct SignOpConversion : public OpConversionPattern<complex::SignOp> {
        -:  835:  using OpConversionPattern<complex::SignOp>::OpConversionPattern;
        -:  836:
        -:  837:  LogicalResult
function _ZNK12_GLOBAL__N_116SignOpConversion15matchAndRewriteEN4mlir7complex6SignOpENS2_13SignOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  838:  matchAndRewrite(complex::SignOp op, OpAdaptor adaptor,
        -:  839:                  ConversionPatternRewriter &rewriter) const override {
    #####:  840:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  841:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  842:    mlir::ImplicitLocOpBuilder b(op.getLoc(), rewriter);
call    0 never executed
        -:  843:
    #####:  844:    Value real = b.create<complex::ReOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  845:    Value imag = b.create<complex::ImOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  846:    Value zero =
    #####:  847:        b.create<arith::ConstantOp>(elementType, b.getZeroAttr(elementType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  848:    Value realIsZero =
    #####:  849:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, real, zero);
call    0 never executed
call    1 never executed
    #####:  850:    Value imagIsZero =
    #####:  851:        b.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, imag, zero);
call    0 never executed
call    1 never executed
    #####:  852:    Value isZero = b.create<arith::AndIOp>(realIsZero, imagIsZero);
call    0 never executed
call    1 never executed
    #####:  853:    auto abs = b.create<complex::AbsOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
    #####:  854:    Value realSign = b.create<arith::DivFOp>(real, abs);
call    0 never executed
call    1 never executed
    #####:  855:    Value imagSign = b.create<arith::DivFOp>(imag, abs);
call    0 never executed
call    1 never executed
    #####:  856:    Value sign = b.create<complex::CreateOp>(type, realSign, imagSign);
call    0 never executed
call    1 never executed
    #####:  857:    rewriter.replaceOpWithNewOp<arith::SelectOp>(op, isZero,
    #####:  858:                                                 adaptor.getComplex(), sign);
call    0 never executed
call    1 never executed
    #####:  859:    return success();
        -:  860:  }
        -:  861:};
        -:  862:
        -:  863:struct TanOpConversion : public OpConversionPattern<complex::TanOp> {
        -:  864:  using OpConversionPattern<complex::TanOp>::OpConversionPattern;
        -:  865:
        -:  866:  LogicalResult
function _ZNK12_GLOBAL__N_115TanOpConversion15matchAndRewriteEN4mlir7complex5TanOpENS2_12TanOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  867:  matchAndRewrite(complex::TanOp op, OpAdaptor adaptor,
        -:  868:                  ConversionPatternRewriter &rewriter) const override {
    #####:  869:    auto loc = op.getLoc();
call    0 never executed
    #####:  870:    Value cos = rewriter.create<complex::CosOp>(loc, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  871:    Value sin = rewriter.create<complex::SinOp>(loc, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  872:    rewriter.replaceOpWithNewOp<complex::DivOp>(op, sin, cos);
call    0 never executed
    #####:  873:    return success();
        -:  874:  }
        -:  875:};
        -:  876:
        -:  877:struct TanhOpConversion : public OpConversionPattern<complex::TanhOp> {
        -:  878:  using OpConversionPattern<complex::TanhOp>::OpConversionPattern;
        -:  879:
        -:  880:  LogicalResult
function _ZNK12_GLOBAL__N_116TanhOpConversion15matchAndRewriteEN4mlir7complex6TanhOpENS2_13TanhOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  881:  matchAndRewrite(complex::TanhOp op, OpAdaptor adaptor,
        -:  882:                  ConversionPatternRewriter &rewriter) const override {
    #####:  883:    auto loc = op.getLoc();
call    0 never executed
    #####:  884:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  885:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  886:
        -:  887:    // The hyperbolic tangent for complex number can be calculated as follows.
        -:  888:    // tanh(x + i * y) = (tanh(x) + i * tan(y)) / (1 + tanh(x) * tan(y))
        -:  889:    // See: https://proofwiki.org/wiki/Hyperbolic_Tangent_of_Complex_Number
    #####:  890:    Value real =
    #####:  891:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  892:    Value imag =
    #####:  893:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  894:    Value tanhA = rewriter.create<math::TanhOp>(loc, real);
call    0 never executed
call    1 never executed
    #####:  895:    Value cosB = rewriter.create<math::CosOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  896:    Value sinB = rewriter.create<math::SinOp>(loc, imag);
call    0 never executed
call    1 never executed
    #####:  897:    Value tanB = rewriter.create<arith::DivFOp>(loc, sinB, cosB);
call    0 never executed
call    1 never executed
    #####:  898:    Value numerator =
    #####:  899:        rewriter.create<complex::CreateOp>(loc, type, tanhA, tanB);
call    0 never executed
call    1 never executed
    #####:  900:    Value one = rewriter.create<arith::ConstantOp>(
    #####:  901:        loc, elementType, rewriter.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  902:    Value mul = rewriter.create<arith::MulFOp>(loc, tanhA, tanB);
call    0 never executed
call    1 never executed
    #####:  903:    Value denominator = rewriter.create<complex::CreateOp>(loc, type, one, mul);
call    0 never executed
call    1 never executed
    #####:  904:    rewriter.replaceOpWithNewOp<complex::DivOp>(op, numerator, denominator);
call    0 never executed
    #####:  905:    return success();
        -:  906:  }
        -:  907:};
        -:  908:
        -:  909:struct ConjOpConversion : public OpConversionPattern<complex::ConjOp> {
        -:  910:  using OpConversionPattern<complex::ConjOp>::OpConversionPattern;
        -:  911:
        -:  912:  LogicalResult
function _ZNK12_GLOBAL__N_116ConjOpConversion15matchAndRewriteEN4mlir7complex6ConjOpENS2_13ConjOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  913:  matchAndRewrite(complex::ConjOp op, OpAdaptor adaptor,
        -:  914:                  ConversionPatternRewriter &rewriter) const override {
    #####:  915:    auto loc = op.getLoc();
call    0 never executed
    #####:  916:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  917:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  918:    Value real =
    #####:  919:        rewriter.create<complex::ReOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  920:    Value imag =
    #####:  921:        rewriter.create<complex::ImOp>(loc, elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  922:    Value negImag = rewriter.create<arith::NegFOp>(loc, elementType, imag);
call    0 never executed
call    1 never executed
        -:  923:
    #####:  924:    rewriter.replaceOpWithNewOp<complex::CreateOp>(op, type, real, negImag);
call    0 never executed
        -:  925:
    #####:  926:    return success();
        -:  927:  }
        -:  928:};
        -:  929:
        -:  930:/// Coverts x^y = (a+bi)^(c+di) to
        -:  931:///    (a*a+b*b)^(0.5c) * exp(-d*atan2(b,a)) * (cos(q) + i*sin(q)),
        -:  932:///    where q = c*atan2(b,a)+0.5d*ln(a*a+b*b)
function _ZN12_GLOBAL__N_1L19powOpConversionImplERN4mlir20ImplicitLocOpBuilderENS0_11ComplexTypeENS0_5ValueES4_S4_S4_ called 0 returned 0% blocks executed 0%
    #####:  933:static Value powOpConversionImpl(mlir::ImplicitLocOpBuilder &builder,
        -:  934:                                 ComplexType type, Value a, Value b, Value c,
        -:  935:                                 Value d) {
    #####:  936:  auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -:  937:
        -:  938:  // Compute (a*a+b*b)^(0.5c).
    #####:  939:  Value aaPbb = builder.create<arith::AddFOp>(
call    0 never executed
    #####:  940:      builder.create<arith::MulFOp>(a, a), builder.create<arith::MulFOp>(b, b));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  941:  Value half = builder.create<arith::ConstantOp>(
    #####:  942:      elementType, builder.getFloatAttr(elementType, 0.5));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  943:  Value halfC = builder.create<arith::MulFOp>(half, c);
call    0 never executed
call    1 never executed
    #####:  944:  Value aaPbbTohalfC = builder.create<math::PowFOp>(aaPbb, halfC);
call    0 never executed
call    1 never executed
        -:  945:
        -:  946:  // Compute exp(-d*atan2(b,a)).
    #####:  947:  Value negD = builder.create<arith::NegFOp>(d);
call    0 never executed
call    1 never executed
    #####:  948:  Value argX = builder.create<math::Atan2Op>(b, a);
call    0 never executed
call    1 never executed
    #####:  949:  Value negDArgX = builder.create<arith::MulFOp>(negD, argX);
call    0 never executed
call    1 never executed
    #####:  950:  Value eToNegDArgX = builder.create<math::ExpOp>(negDArgX);
call    0 never executed
call    1 never executed
        -:  951:
        -:  952:  // Compute (a*a+b*b)^(0.5c) * exp(-d*atan2(b,a)).
    #####:  953:  Value coeff = builder.create<arith::MulFOp>(aaPbbTohalfC, eToNegDArgX);
call    0 never executed
call    1 never executed
        -:  954:
        -:  955:  // Compute c*atan2(b,a)+0.5d*ln(a*a+b*b).
    #####:  956:  Value lnAaPbb = builder.create<math::LogOp>(aaPbb);
call    0 never executed
call    1 never executed
    #####:  957:  Value halfD = builder.create<arith::MulFOp>(half, d);
call    0 never executed
call    1 never executed
    #####:  958:  Value q = builder.create<arith::AddFOp>(
call    0 never executed
    #####:  959:      builder.create<arith::MulFOp>(c, argX),
call    0 never executed
    #####:  960:      builder.create<arith::MulFOp>(halfD, lnAaPbb));
call    0 never executed
call    1 never executed
        -:  961:
    #####:  962:  Value cosQ = builder.create<math::CosOp>(q);
call    0 never executed
call    1 never executed
    #####:  963:  Value sinQ = builder.create<math::SinOp>(q);
call    0 never executed
call    1 never executed
    #####:  964:  Value zero = builder.create<arith::ConstantOp>(
    #####:  965:      elementType, builder.getFloatAttr(elementType, 0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  966:  Value one = builder.create<arith::ConstantOp>(
    #####:  967:      elementType, builder.getFloatAttr(elementType, 1));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  968:
    #####:  969:  Value xEqZero =
    #####:  970:      builder.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, aaPbb, zero);
call    0 never executed
call    1 never executed
    #####:  971:  Value yGeZero = builder.create<arith::AndIOp>(
    #####:  972:      builder.create<arith::CmpFOp>(arith::CmpFPredicate::OGE, c, zero),
call    0 never executed
    #####:  973:      builder.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, d, zero));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  974:  Value cEqZero =
    #####:  975:      builder.create<arith::CmpFOp>(arith::CmpFPredicate::OEQ, c, zero);
call    0 never executed
call    1 never executed
    #####:  976:  Value complexZero = builder.create<complex::CreateOp>(type, zero, zero);
call    0 never executed
call    1 never executed
    #####:  977:  Value complexOne = builder.create<complex::CreateOp>(type, one, zero);
call    0 never executed
call    1 never executed
    #####:  978:  Value complexOther = builder.create<complex::CreateOp>(
call    0 never executed
    #####:  979:      type, builder.create<arith::MulFOp>(coeff, cosQ),
call    0 never executed
    #####:  980:      builder.create<arith::MulFOp>(coeff, sinQ));
call    0 never executed
call    1 never executed
        -:  981:
        -:  982:  // x^y is 0 if x is 0 and y > 0. 0^0 is defined to be 1.0, see
        -:  983:  // Branch Cuts for Complex Elementary Functions or Much Ado About
        -:  984:  // Nothing's Sign Bit, W. Kahan, Section 10.
    #####:  985:  return builder.create<arith::SelectOp>(
call    0 never executed
    #####:  986:      builder.create<arith::AndIOp>(xEqZero, yGeZero),
call    0 never executed
    #####:  987:      builder.create<arith::SelectOp>(cEqZero, complexOne, complexZero),
call    0 never executed
    #####:  988:      complexOther);
        -:  989:}
        -:  990:
        -:  991:struct PowOpConversion : public OpConversionPattern<complex::PowOp> {
        -:  992:  using OpConversionPattern<complex::PowOp>::OpConversionPattern;
        -:  993:
        -:  994:  LogicalResult
function _ZNK12_GLOBAL__N_115PowOpConversion15matchAndRewriteEN4mlir7complex5PowOpENS2_12PowOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  995:  matchAndRewrite(complex::PowOp op, OpAdaptor adaptor,
        -:  996:                  ConversionPatternRewriter &rewriter) const override {
    #####:  997:    mlir::ImplicitLocOpBuilder builder(op.getLoc(), rewriter);
call    0 never executed
    #####:  998:    auto type = adaptor.getLhs().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####:  999:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -: 1000:
    #####: 1001:    Value a = builder.create<complex::ReOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1002:    Value b = builder.create<complex::ImOp>(elementType, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1003:    Value c = builder.create<complex::ReOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1004:    Value d = builder.create<complex::ImOp>(elementType, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1005:
    #####: 1006:    rewriter.replaceOp(op, {powOpConversionImpl(builder, type, a, b, c, d)});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1007:    return success();
        -: 1008:  }
        -: 1009:};
        -: 1010:
        -: 1011:struct RsqrtOpConversion : public OpConversionPattern<complex::RsqrtOp> {
        -: 1012:  using OpConversionPattern<complex::RsqrtOp>::OpConversionPattern;
        -: 1013:
        -: 1014:  LogicalResult
function _ZNK12_GLOBAL__N_117RsqrtOpConversion15matchAndRewriteEN4mlir7complex7RsqrtOpENS2_14RsqrtOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1015:  matchAndRewrite(complex::RsqrtOp op, OpAdaptor adaptor,
        -: 1016:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1017:    mlir::ImplicitLocOpBuilder builder(op.getLoc(), rewriter);
call    0 never executed
    #####: 1018:    auto type = adaptor.getComplex().getType().cast<ComplexType>();
call    0 never executed
call    1 never executed
    #####: 1019:    auto elementType = type.getElementType().cast<FloatType>();
call    0 never executed
call    1 never executed
        -: 1020:
    #####: 1021:    Value a = builder.create<complex::ReOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1022:    Value b = builder.create<complex::ImOp>(elementType, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1023:    Value c = builder.create<arith::ConstantOp>(
    #####: 1024:        elementType, builder.getFloatAttr(elementType, -0.5));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1025:    Value d = builder.create<arith::ConstantOp>(
    #####: 1026:        elementType, builder.getFloatAttr(elementType, 0));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1027:
    #####: 1028:    rewriter.replaceOp(op, {powOpConversionImpl(builder, type, a, b, c, d)});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1029:    return success();
        -: 1030:  }
        -: 1031:};
        -: 1032:
        -: 1033:struct AngleOpConversion : public OpConversionPattern<complex::AngleOp> {
        -: 1034:  using OpConversionPattern<complex::AngleOp>::OpConversionPattern;
        -: 1035:
        -: 1036:  LogicalResult
function _ZNK12_GLOBAL__N_117AngleOpConversion15matchAndRewriteEN4mlir7complex7AngleOpENS2_14AngleOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1037:  matchAndRewrite(complex::AngleOp op, OpAdaptor adaptor,
        -: 1038:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1039:    auto loc = op.getLoc();
call    0 never executed
    #####: 1040:    auto type = op.getType();
call    0 never executed
        -: 1041:
    #####: 1042:    Value real =
    #####: 1043:        rewriter.create<complex::ReOp>(loc, type, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1044:    Value imag =
    #####: 1045:        rewriter.create<complex::ImOp>(loc, type, adaptor.getComplex());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1046:
    #####: 1047:    rewriter.replaceOpWithNewOp<math::Atan2Op>(op, imag, real);
call    0 never executed
        -: 1048:
    #####: 1049:    return success();
        -: 1050:  }
        -: 1051:};
        -: 1052:
        -: 1053:} // namespace
        -: 1054:
function _ZN4mlir43populateComplexToStandardConversionPatternsERNS_17RewritePatternSetE called 0 returned 0% blocks executed 0%
     874*: 1055:void mlir::populateComplexToStandardConversionPatterns(
        -: 1056:    RewritePatternSet &patterns) {
        -: 1057:  // clang-format off
     874*: 1058:  patterns.add<
        -: 1059:      AbsOpConversion,
        -: 1060:      AngleOpConversion,
        -: 1061:      Atan2OpConversion,
        -: 1062:      BinaryComplexOpConversion<complex::AddOp, arith::AddFOp>,
        -: 1063:      BinaryComplexOpConversion<complex::SubOp, arith::SubFOp>,
        -: 1064:      ComparisonOpConversion<complex::EqualOp, arith::CmpFPredicate::OEQ>,
        -: 1065:      ComparisonOpConversion<complex::NotEqualOp, arith::CmpFPredicate::UNE>,
        -: 1066:      ConjOpConversion,
        -: 1067:      CosOpConversion,
        -: 1068:      DivOpConversion,
        -: 1069:      ExpOpConversion,
        -: 1070:      Expm1OpConversion,
        -: 1071:      Log1pOpConversion,
        -: 1072:      LogOpConversion,
        -: 1073:      MulOpConversion,
        -: 1074:      NegOpConversion,
        -: 1075:      SignOpConversion,
        -: 1076:      SinOpConversion,
        -: 1077:      SqrtOpConversion,
        -: 1078:      TanOpConversion,
        -: 1079:      TanhOpConversion,
        -: 1080:      PowOpConversion,
        -: 1081:      RsqrtOpConversion
    #####: 1082:  >(patterns.getContext());
call    0 never executed
        -: 1083:  // clang-format on
    #####: 1084:}
        -: 1085:
        -: 1086:namespace {
  327694*: 1087:struct ConvertComplexToStandardPass
call    0 never executed
call    1 returned 100%
        -: 1088:    : public impl::ConvertComplexToStandardBase<ConvertComplexToStandardPass> {
        -: 1089:  void runOnOperation() override;
        -: 1090:};
        -: 1091:
function _ZN12_GLOBAL__N_128ConvertComplexToStandardPass14runOnOperationEv called 874 returned 100% blocks executed 88%
      874: 1092:void ConvertComplexToStandardPass::runOnOperation() {
        -: 1093:  // Convert to the Standard dialect using the converter defined above.
      874: 1094:  RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
      874: 1095:  populateComplexToStandardConversionPatterns(patterns);
call    0 returned 100%
        -: 1096:
     1748: 1097:  ConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      874: 1098:  target.addLegalDialect<arith::ArithDialect, math::MathDialect>();
call    0 returned 100%
      874: 1099:  target.addLegalOp<complex::CreateOp, complex::ImOp, complex::ReOp>();
call    0 returned 100%
      874: 1100:  if (failed(
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      874: 1101:          applyPartialConversion(getOperation(), target, std::move(patterns))))
call    0 returned 100%
    #####: 1102:    signalPassFailure();
call    0 never executed
      874: 1103:}
        -: 1104:} // namespace
        -: 1105:
function _ZN4mlir34createConvertComplexToStandardPassEv called 327694 returned 100% blocks executed 100%
   327694: 1106:std::unique_ptr<Pass> mlir::createConvertComplexToStandardPass() {
   327694: 1107:  return std::make_unique<ConvertComplexToStandardPass>();
call    0 returned 100%
        -: 1108:}
