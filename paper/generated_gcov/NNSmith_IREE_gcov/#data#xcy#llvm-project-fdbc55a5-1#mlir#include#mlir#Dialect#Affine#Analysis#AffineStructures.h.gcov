        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/include/mlir/Dialect/Affine/Analysis/AffineStructures.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Linalg/Utils/CMakeFiles/obj.MLIRLinalgUtils.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Linalg/Utils/CMakeFiles/obj.MLIRLinalgUtils.dir/Utils.cpp.gcda
        -:    0:Runs:325547
        -:    1://===- AffineStructures.h - MLIR Affine Structures Class --------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Structures for affine/polyhedral analysis of ML functions.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef MLIR_DIALECT_AFFINE_ANALYSIS_AFFINESTRUCTURES_H
        -:   14:#define MLIR_DIALECT_AFFINE_ANALYSIS_AFFINESTRUCTURES_H
        -:   15:
        -:   16:#include "mlir/Analysis/Presburger/IntegerRelation.h"
        -:   17:#include "mlir/Analysis/Presburger/Matrix.h"
        -:   18:#include "mlir/IR/AffineExpr.h"
        -:   19:#include "mlir/IR/OpDefinition.h"
        -:   20:#include "mlir/Support/LogicalResult.h"
        -:   21:
        -:   22:namespace mlir {
        -:   23:
        -:   24:class AffineCondition;
        -:   25:class AffineForOp;
        -:   26:class AffineIfOp;
        -:   27:class AffineMap;
        -:   28:class AffineValueMap;
        -:   29:class IntegerSet;
        -:   30:class MLIRContext;
        -:   31:class Value;
        -:   32:class MemRefType;
        -:   33:struct MutableAffineMap;
        -:   34:
        -:   35:namespace presburger {
        -:   36:class MultiAffineFunction;
        -:   37:} // namespace presburger
        -:   38:
        -:   39:/// FlatAffineValueConstraints represents an extension of IntegerPolyhedron
        -:   40:/// where each non-local variable can have an SSA Value attached to it.
        -:   41:class FlatAffineValueConstraints : public presburger::IntegerPolyhedron {
        -:   42:public:
        -:   43:  /// Constructs a constraint system reserving memory for the specified number
        -:   44:  /// of constraints and variables.
function _ZN4mlir26FlatAffineValueConstraintsC2EjjjjjjN4llvm8ArrayRefINS1_8OptionalINS_5ValueEEEEE called 0 returned 0% blocks executed 0%
    #####:   45:  FlatAffineValueConstraints(unsigned numReservedInequalities,
        -:   46:                             unsigned numReservedEqualities,
        -:   47:                             unsigned numReservedCols, unsigned numDims,
        -:   48:                             unsigned numSymbols, unsigned numLocals,
        -:   49:                             ArrayRef<Optional<Value>> valArgs = {})
    #####:   50:      : IntegerPolyhedron(numReservedInequalities, numReservedEqualities,
        -:   51:                          numReservedCols,
    #####:   52:                          presburger::PresburgerSpace::getSetSpace(
call    0 never executed
    #####:   53:                              numDims, numSymbols, numLocals)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   54:    assert(numReservedCols >= getNumVars() + 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   55:    assert(valArgs.empty() || valArgs.size() == getNumDimAndSymbolVars());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   56:    values.reserve(numReservedCols);
branch  0 never executed
branch  1 never executed
    #####:   57:    if (valArgs.empty())
branch  0 never executed
branch  1 never executed
    #####:   58:      values.resize(getNumDimAndSymbolVars(), None);
call    0 never executed
        -:   59:    else
    #####:   60:      values.append(valArgs.begin(), valArgs.end());
call    0 never executed
    #####:   61:  }
        -:   62:
        -:   63:  /// Constructs a constraint system with the specified number of
        -:   64:  /// dimensions and symbols.
    #####:   65:  FlatAffineValueConstraints(unsigned numDims = 0, unsigned numSymbols = 0,
        -:   66:                             unsigned numLocals = 0,
        -:   67:                             ArrayRef<Optional<Value>> valArgs = {})
    #####:   68:      : FlatAffineValueConstraints(/*numReservedInequalities=*/0,
        -:   69:                                   /*numReservedEqualities=*/0,
        -:   70:                                   /*numReservedCols=*/numDims + numSymbols +
        -:   71:                                       numLocals + 1,
    #####:   72:                                   numDims, numSymbols, numLocals, valArgs) {}
call    0 never executed
        -:   73:
        -:   74:  FlatAffineValueConstraints(const IntegerPolyhedron &fac,
        -:   75:                             ArrayRef<Optional<Value>> valArgs = {})
        -:   76:      : IntegerPolyhedron(fac) {
        -:   77:    assert(valArgs.empty() || valArgs.size() == getNumDimAndSymbolVars());
        -:   78:    if (valArgs.empty())
        -:   79:      values.resize(getNumDimAndSymbolVars(), None);
        -:   80:    else
        -:   81:      values.append(valArgs.begin(), valArgs.end());
        -:   82:  }
        -:   83:
        -:   84:  /// Create a flat affine constraint system from an AffineValueMap or a list of
        -:   85:  /// these. The constructed system will only include equalities.
        -:   86:  explicit FlatAffineValueConstraints(const AffineValueMap &avm);
        -:   87:  explicit FlatAffineValueConstraints(ArrayRef<const AffineValueMap *> avmRef);
        -:   88:
        -:   89:  /// Creates an affine constraint system from an IntegerSet.
        -:   90:  explicit FlatAffineValueConstraints(IntegerSet set);
        -:   91:
        -:   92:  FlatAffineValueConstraints(ArrayRef<const AffineValueMap *> avmRef,
        -:   93:                             IntegerSet set);
        -:   94:
        -:   95:  // Construct a hyperrectangular constraint set from ValueRanges that represent
        -:   96:  // induction variables, lower and upper bounds. `ivs`, `lbs` and `ubs` are
        -:   97:  // expected to match one to one. The order of variables and constraints is:
        -:   98:  //
        -:   99:  // ivs | lbs | ubs | eq/ineq
        -:  100:  // ----+-----+-----+---------
        -:  101:  //   1   -1     0      >= 0
        -:  102:  // ----+-----+-----+---------
        -:  103:  //  -1    0     1      >= 0
        -:  104:  //
        -:  105:  // All dimensions as set as VarKind::SetDim.
        -:  106:  static FlatAffineValueConstraints
        -:  107:  getHyperrectangular(ValueRange ivs, ValueRange lbs, ValueRange ubs);
        -:  108:
        -:  109:  /// Return the kind of this FlatAffineConstraints.
        -:  110:  Kind getKind() const override { return Kind::FlatAffineValueConstraints; }
        -:  111:
        -:  112:  static bool classof(const IntegerRelation *cst) {
        -:  113:    return cst->getKind() == Kind::FlatAffineValueConstraints;
        -:  114:  }
        -:  115:
        -:  116:  /// Clears any existing data and reserves memory for the specified
        -:  117:  /// constraints.
        -:  118:  void reset(unsigned numReservedInequalities, unsigned numReservedEqualities,
        -:  119:             unsigned numReservedCols, unsigned numDims, unsigned numSymbols,
        -:  120:             unsigned numLocals = 0);
        -:  121:  void reset(unsigned numDims = 0, unsigned numSymbols = 0,
        -:  122:             unsigned numLocals = 0);
        -:  123:  void reset(unsigned numReservedInequalities, unsigned numReservedEqualities,
        -:  124:             unsigned numReservedCols, unsigned numDims, unsigned numSymbols,
        -:  125:             unsigned numLocals, ArrayRef<Value> valArgs);
        -:  126:  void reset(unsigned numDims, unsigned numSymbols, unsigned numLocals,
        -:  127:             ArrayRef<Value> valArgs);
        -:  128:
        -:  129:  /// Clones this object.
        -:  130:  std::unique_ptr<FlatAffineValueConstraints> clone() const;
        -:  131:
        -:  132:  /// Adds constraints (lower and upper bounds) for the specified 'affine.for'
        -:  133:  /// operation's Value using IR information stored in its bound maps. The
        -:  134:  /// right variable is first looked up using `forOp`'s Value. Asserts if the
        -:  135:  /// Value corresponding to the 'affine.for' operation isn't found in the
        -:  136:  /// constraint system. Returns failure for the yet unimplemented/unsupported
        -:  137:  /// cases.  Any new variables that are found in the bound operands of the
        -:  138:  /// 'affine.for' operation are added as trailing variables (either
        -:  139:  /// dimensional or symbolic depending on whether the operand is a valid
        -:  140:  /// symbol).
        -:  141:  //  TODO: add support for non-unit strides.
        -:  142:  LogicalResult addAffineForOpDomain(AffineForOp forOp);
        -:  143:
        -:  144:  /// Adds constraints (lower and upper bounds) for each loop in the loop nest
        -:  145:  /// described by the bound maps `lbMaps` and `ubMaps` of a computation slice.
        -:  146:  /// Every pair (`lbMaps[i]`, `ubMaps[i]`) describes the bounds of a loop in
        -:  147:  /// the nest, sorted outer-to-inner. `operands` contains the bound operands
        -:  148:  /// for a single bound map. All the bound maps will use the same bound
        -:  149:  /// operands. Note that some loops described by a computation slice might not
        -:  150:  /// exist yet in the IR so the Value attached to those dimension variables
        -:  151:  /// might be empty. For that reason, this method doesn't perform Value
        -:  152:  /// look-ups to retrieve the dimension variable positions. Instead, it
        -:  153:  /// assumes the position of the dim variables in the constraint system is
        -:  154:  /// the same as the position of the loop in the loop nest.
        -:  155:  LogicalResult addDomainFromSliceMaps(ArrayRef<AffineMap> lbMaps,
        -:  156:                                       ArrayRef<AffineMap> ubMaps,
        -:  157:                                       ArrayRef<Value> operands);
        -:  158:
        -:  159:  /// Adds constraints imposed by the `affine.if` operation. These constraints
        -:  160:  /// are collected from the IntegerSet attached to the given `affine.if`
        -:  161:  /// instance argument (`ifOp`). It is asserted that:
        -:  162:  /// 1) The IntegerSet of the given `affine.if` instance should not contain
        -:  163:  /// semi-affine expressions,
        -:  164:  /// 2) The columns of the constraint system created from `ifOp` should match
        -:  165:  /// the columns in the current one regarding numbers and values.
        -:  166:  void addAffineIfOpDomain(AffineIfOp ifOp);
        -:  167:
        -:  168:  /// Adds a bound for the variable at the specified position with constraints
        -:  169:  /// being drawn from the specified bound map. In case of an EQ bound, the
        -:  170:  /// bound map is expected to have exactly one result. In case of a LB/UB, the
        -:  171:  /// bound map may have more than one result, for each of which an inequality
        -:  172:  /// is added.
        -:  173:  ///
        -:  174:  /// The bound can be added as open or closed by specifying isClosedBound. In
        -:  175:  /// case of a LB/UB, isClosedBound = false means the bound is added internally
        -:  176:  /// as a closed bound by +1/-1 respectively. In case of an EQ bound, it can
        -:  177:  /// only be added as a closed bound.
        -:  178:  ///
        -:  179:  /// Note: The dimensions/symbols of this FlatAffineConstraints must match the
        -:  180:  /// dimensions/symbols of the affine map.
        -:  181:  LogicalResult addBound(BoundType type, unsigned pos, AffineMap boundMap,
        -:  182:                         bool isClosedBound);
        -:  183:
        -:  184:  /// Adds a bound for the variable at the specified position with constraints
        -:  185:  /// being drawn from the specified bound map. In case of an EQ bound, the
        -:  186:  /// bound map is expected to have exactly one result. In case of a LB/UB, the
        -:  187:  /// bound map may have more than one result, for each of which an inequality
        -:  188:  /// is added.
        -:  189:  /// Note: The dimensions/symbols of this FlatAffineConstraints must match the
        -:  190:  /// dimensions/symbols of the affine map. By default the lower bound is closed
        -:  191:  /// and the upper bound is open.
        -:  192:  LogicalResult addBound(BoundType type, unsigned pos, AffineMap boundMap);
        -:  193:
        -:  194:  /// Adds a bound for the variable at the specified position with constraints
        -:  195:  /// being drawn from the specified bound map and operands. In case of an
        -:  196:  /// EQ bound, the  bound map is expected to have exactly one result. In case
        -:  197:  /// of a LB/UB, the bound map may have more than one result, for each of which
        -:  198:  /// an inequality is added.
        -:  199:  LogicalResult addBound(BoundType type, unsigned pos, AffineMap boundMap,
        -:  200:                         ValueRange operands);
        -:  201:
        -:  202:  /// Adds a constant bound for the variable associated with the given Value.
        -:  203:  void addBound(BoundType type, Value val, int64_t value);
        -:  204:
        -:  205:  /// The `addBound` overload above hides the inherited overloads by default, so
        -:  206:  /// we explicitly introduce them here.
        -:  207:  using IntegerPolyhedron::addBound;
        -:  208:
        -:  209:  /// Returns the constraint system as an integer set. Returns a null integer
        -:  210:  /// set if the system has no constraints, or if an integer set couldn't be
        -:  211:  /// constructed as a result of a local variable's explicit representation not
        -:  212:  /// being known and such a local variable appearing in any of the constraints.
        -:  213:  IntegerSet getAsIntegerSet(MLIRContext *context) const;
        -:  214:
        -:  215:  /// Computes the lower and upper bounds of the first `num` dimensional
        -:  216:  /// variables (starting at `offset`) as an affine map of the remaining
        -:  217:  /// variables (dimensional and symbolic). This method is able to detect
        -:  218:  /// variables as floordiv's and mod's of affine expressions of other
        -:  219:  /// variables with respect to (positive) constants. Sets bound map to a
        -:  220:  /// null AffineMap if such a bound can't be found (or yet unimplemented).
        -:  221:  ///
        -:  222:  /// By default the returned lower bounds are closed and upper bounds are open.
        -:  223:  /// This can be changed by getClosedUB.
        -:  224:  void getSliceBounds(unsigned offset, unsigned num, MLIRContext *context,
        -:  225:                      SmallVectorImpl<AffineMap> *lbMaps,
        -:  226:                      SmallVectorImpl<AffineMap> *ubMaps,
        -:  227:                      bool getClosedUB = false);
        -:  228:
        -:  229:  /// Composes an affine map whose dimensions and symbols match one to one with
        -:  230:  /// the dimensions and symbols of this FlatAffineConstraints. The results of
        -:  231:  /// the map `other` are added as the leading dimensions of this constraint
        -:  232:  /// system. Returns failure if `other` is a semi-affine map.
        -:  233:  LogicalResult composeMatchingMap(AffineMap other);
        -:  234:
        -:  235:  /// Gets the lower and upper bound of the `offset` + `pos`th variable
        -:  236:  /// treating [0, offset) U [offset + num, symStartPos) as dimensions and
        -:  237:  /// [symStartPos, getNumDimAndSymbolVars) as symbols, and `pos` lies in
        -:  238:  /// [0, num). The multi-dimensional maps in the returned pair represent the
        -:  239:  /// max and min of potentially multiple affine expressions. The upper bound is
        -:  240:  /// exclusive. `localExprs` holds pre-computed AffineExpr's for all local
        -:  241:  /// variables in the system.
        -:  242:  std::pair<AffineMap, AffineMap>
        -:  243:  getLowerAndUpperBound(unsigned pos, unsigned offset, unsigned num,
        -:  244:                        unsigned symStartPos, ArrayRef<AffineExpr> localExprs,
        -:  245:                        MLIRContext *context) const;
        -:  246:
        -:  247:  /// Returns the bound for the variable at `pos` from the inequality at
        -:  248:  /// `ineqPos` as a 1-d affine value map (affine map + operands). The returned
        -:  249:  /// affine value map can either be a lower bound or an upper bound depending
        -:  250:  /// on the sign of atIneq(ineqPos, pos). Asserts if the row at `ineqPos` does
        -:  251:  /// not involve the `pos`th variable.
        -:  252:  void getIneqAsAffineValueMap(unsigned pos, unsigned ineqPos,
        -:  253:                               AffineValueMap &vmap,
        -:  254:                               MLIRContext *context) const;
        -:  255:
        -:  256:  /// Adds slice lower bounds represented by lower bounds in `lbMaps` and upper
        -:  257:  /// bounds in `ubMaps` to each variable in the constraint system which has
        -:  258:  /// a value in `values`. Note that both lower/upper bounds share the same
        -:  259:  /// operand list `operands`.
        -:  260:  /// This function assumes `values.size` == `lbMaps.size` == `ubMaps.size`.
        -:  261:  /// Note that both lower/upper bounds use operands from `operands`.
        -:  262:  LogicalResult addSliceBounds(ArrayRef<Value> values,
        -:  263:                               ArrayRef<AffineMap> lbMaps,
        -:  264:                               ArrayRef<AffineMap> ubMaps,
        -:  265:                               ArrayRef<Value> operands);
        -:  266:
        -:  267:  /// Looks up the position of the variable with the specified Value. Returns
        -:  268:  /// true if found (false otherwise). `pos` is set to the (column) position of
        -:  269:  /// the variable.
        -:  270:  bool findVar(Value val, unsigned *pos) const;
        -:  271:
        -:  272:  /// Returns true if an variable with the specified Value exists, false
        -:  273:  /// otherwise.
        -:  274:  bool containsVar(Value mayBeVar) const;
        -:  275:
        -:  276:  /// Swap the posA^th variable with the posB^th variable.
        -:  277:  void swapVar(unsigned posA, unsigned posB) override;
        -:  278:
        -:  279:  /// Insert variables of the specified kind at position `pos`. Positions are
        -:  280:  /// relative to the kind of variable. The coefficient columns corresponding
        -:  281:  /// to the added variables are initialized to zero. `vals` are the Values
        -:  282:  /// corresponding to the variables. Values should not be used with
        -:  283:  /// VarKind::Local since values can only be attached to non-local variables.
        -:  284:  /// Return the absolute column position (i.e., not relative to the kind of
        -:  285:  /// variable) of the first added variable.
        -:  286:  ///
        -:  287:  /// Note: Empty Values are allowed in `vals`.
        -:  288:  unsigned insertDimVar(unsigned pos, unsigned num = 1) {
        -:  289:    return insertVar(VarKind::SetDim, pos, num);
        -:  290:  }
        -:  291:  unsigned insertSymbolVar(unsigned pos, unsigned num = 1) {
        -:  292:    return insertVar(VarKind::Symbol, pos, num);
        -:  293:  }
        -:  294:  unsigned insertLocalVar(unsigned pos, unsigned num = 1) {
        -:  295:    return insertVar(VarKind::Local, pos, num);
        -:  296:  }
        -:  297:  unsigned insertDimVar(unsigned pos, ValueRange vals);
        -:  298:  unsigned insertSymbolVar(unsigned pos, ValueRange vals);
        -:  299:  unsigned insertVar(presburger::VarKind kind, unsigned pos,
        -:  300:                     unsigned num = 1) override;
        -:  301:  unsigned insertVar(presburger::VarKind kind, unsigned pos, ValueRange vals);
        -:  302:
        -:  303:  /// Append variables of the specified kind after the last variable of that
        -:  304:  /// kind. The coefficient columns corresponding to the added variables are
        -:  305:  /// initialized to zero. `vals` are the Values corresponding to the
        -:  306:  /// variables. Return the absolute column position (i.e., not relative to the
        -:  307:  /// kind of variable) of the first appended variable.
        -:  308:  ///
        -:  309:  /// Note: Empty Values are allowed in `vals`.
        -:  310:  unsigned appendDimVar(ValueRange vals);
        -:  311:  unsigned appendSymbolVar(ValueRange vals);
        -:  312:  unsigned appendDimVar(unsigned num = 1) {
        -:  313:    return appendVar(VarKind::SetDim, num);
        -:  314:  }
        -:  315:  unsigned appendSymbolVar(unsigned num = 1) {
        -:  316:    return appendVar(VarKind::Symbol, num);
        -:  317:  }
        -:  318:  unsigned appendLocalVar(unsigned num = 1) {
        -:  319:    return appendVar(VarKind::Local, num);
        -:  320:  }
        -:  321:
        -:  322:  /// Removes variables in the column range [varStart, varLimit), and copies any
        -:  323:  /// remaining valid data into place, updates member variables, and resizes
        -:  324:  /// arrays as needed.
        -:  325:  void removeVarRange(presburger::VarKind kind, unsigned varStart,
        -:  326:                      unsigned varLimit) override;
        -:  327:  using IntegerPolyhedron::removeVarRange;
        -:  328:
        -:  329:  /// Add the specified values as a dim or symbol var depending on its nature,
        -:  330:  /// if it already doesn't exist in the system. `val` has to be either a
        -:  331:  /// terminal symbol or a loop IV, i.e., it cannot be the result affine.apply
        -:  332:  /// of any symbols or loop IVs. The variable is added to the end of the
        -:  333:  /// existing dims or symbols. Additional information on the variable is
        -:  334:  /// extracted from the IR and added to the constraint system.
        -:  335:  void addInductionVarOrTerminalSymbol(Value val);
        -:  336:
        -:  337:  /// Align `map` with this constraint system based on `operands`. Each operand
        -:  338:  /// must already have a corresponding dim/symbol in this constraint system.
        -:  339:  AffineMap computeAlignedMap(AffineMap map, ValueRange operands) const;
        -:  340:
        -:  341:  /// Composes the affine value map with this FlatAffineValueConstrains, adding
        -:  342:  /// the results of the map as dimensions at the front
        -:  343:  /// [0, vMap->getNumResults()) and with the dimensions set to the equalities
        -:  344:  /// specified by the value map.
        -:  345:  ///
        -:  346:  /// Returns failure if the composition fails (when vMap is a semi-affine map).
        -:  347:  /// The vMap's operand Value's are used to look up the right positions in
        -:  348:  /// the FlatAffineConstraints with which to associate. Every operand of vMap
        -:  349:  /// should have a matching dim/symbol column in this constraint system (with
        -:  350:  /// the same associated Value).
        -:  351:  LogicalResult composeMap(const AffineValueMap *vMap);
        -:  352:
        -:  353:  /// Projects out the variable that is associate with Value.
        -:  354:  void projectOut(Value val);
        -:  355:  using IntegerPolyhedron::projectOut;
        -:  356:
        -:  357:  /// Changes all symbol variables which are loop IVs to dim variables.
        -:  358:  void convertLoopIVSymbolsToDims();
        -:  359:
        -:  360:  /// Updates the constraints to be the smallest bounding (enclosing) box that
        -:  361:  /// contains the points of `this` set and that of `other`, with the symbols
        -:  362:  /// being treated specially. For each of the dimensions, the min of the lower
        -:  363:  /// bounds (symbolic) and the max of the upper bounds (symbolic) is computed
        -:  364:  /// to determine such a bounding box. `other` is expected to have the same
        -:  365:  /// dimensional variables as this constraint system (in the same order).
        -:  366:  ///
        -:  367:  /// E.g.:
        -:  368:  /// 1) this   = {0 <= d0 <= 127},
        -:  369:  ///    other  = {16 <= d0 <= 192},
        -:  370:  ///    output = {0 <= d0 <= 192}
        -:  371:  /// 2) this   = {s0 + 5 <= d0 <= s0 + 20},
        -:  372:  ///    other  = {s0 + 1 <= d0 <= s0 + 9},
        -:  373:  ///    output = {s0 + 1 <= d0 <= s0 + 20}
        -:  374:  /// 3) this   = {0 <= d0 <= 5, 1 <= d1 <= 9}
        -:  375:  ///    other  = {2 <= d0 <= 6, 5 <= d1 <= 15},
        -:  376:  ///    output = {0 <= d0 <= 6, 1 <= d1 <= 15}
        -:  377:  LogicalResult unionBoundingBox(const FlatAffineValueConstraints &other);
        -:  378:  using IntegerPolyhedron::unionBoundingBox;
        -:  379:
        -:  380:  /// Merge and align the variables of `this` and `other` starting at
        -:  381:  /// `offset`, so that both constraint systems get the union of the contained
        -:  382:  /// variables that is dimension-wise and symbol-wise unique; both
        -:  383:  /// constraint systems are updated so that they have the union of all
        -:  384:  /// variables, with `this`'s original variables appearing first followed
        -:  385:  /// by any of `other`'s variables that didn't appear in `this`. Local
        -:  386:  /// variables in `other` that have the same division representation as local
        -:  387:  /// variables in `this` are merged into one.
        -:  388:  //  E.g.: Input: `this`  has (%i, %j) [%M, %N]
        -:  389:  //               `other` has (%k, %j) [%P, %N, %M]
        -:  390:  //        Output: both `this`, `other` have (%i, %j, %k) [%M, %N, %P]
        -:  391:  //
        -:  392:  void mergeAndAlignVarsWithOther(unsigned offset,
        -:  393:                                  FlatAffineValueConstraints *other);
        -:  394:
        -:  395:  /// Returns true if this constraint system and `other` are in the same
        -:  396:  /// space, i.e., if they are associated with the same set of variables,
        -:  397:  /// appearing in the same order. Returns false otherwise.
        -:  398:  bool areVarsAlignedWithOther(const FlatAffineValueConstraints &other);
        -:  399:
        -:  400:  /// Replaces the contents of this FlatAffineValueConstraints with `other`.
        -:  401:  void clearAndCopyFrom(const IntegerRelation &other) override;
        -:  402:
        -:  403:  /// Returns the Value associated with the pos^th variable. Asserts if
        -:  404:  /// no Value variable was associated.
function _ZNK4mlir26FlatAffineValueConstraints8getValueEj called 0 returned 0% blocks executed 0%
    #####:  405:  inline Value getValue(unsigned pos) const {
    #####:  406:    assert(pos < getNumDimAndSymbolVars() && "Invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  407:    assert(hasValue(pos) && "variable's Value not set");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  408:    return values[pos].value();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  409:  }
        -:  410:
        -:  411:  /// Returns true if the pos^th variable has an associated Value.
function _ZNK4mlir26FlatAffineValueConstraints8hasValueEj called 0 returned 0% blocks executed 0%
    #####:  412:  inline bool hasValue(unsigned pos) const {
    #####:  413:    assert(pos < getNumDimAndSymbolVars() && "Invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  414:    return values[pos].has_value();
branch  0 never executed
branch  1 never executed
        -:  415:  }
        -:  416:
        -:  417:  /// Returns true if at least one variable has an associated Value.
        -:  418:  bool hasValues() const;
        -:  419:
        -:  420:  /// Returns the Values associated with variables in range [start, end).
        -:  421:  /// Asserts if no Value was associated with one of these variables.
function _ZNK4mlir26FlatAffineValueConstraints9getValuesEjjPN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  422:  inline void getValues(unsigned start, unsigned end,
        -:  423:                        SmallVectorImpl<Value> *values) const {
    #####:  424:    assert(end <= getNumDimAndSymbolVars() && "invalid end position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  425:    assert(start <= end && "invalid start position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  426:    values->clear();
branch  0 never executed
branch  1 never executed
    #####:  427:    values->reserve(end - start);
branch  0 never executed
branch  1 never executed
    #####:  428:    for (unsigned i = start; i < end; i++)
branch  0 never executed
branch  1 never executed
    #####:  429:      values->push_back(getValue(i));
call    0 never executed
call    1 never executed
    #####:  430:  }
    #####:  431:  inline void getAllValues(SmallVectorImpl<Value> *values) const {
    #####:  432:    getValues(0, getNumDimAndSymbolVars(), values);
call    0 never executed
        -:  433:  }
        -:  434:
        -:  435:  inline ArrayRef<Optional<Value>> getMaybeValues() const {
        -:  436:    return {values.data(), values.size()};
        -:  437:  }
        -:  438:
        -:  439:  inline ArrayRef<Optional<Value>>
        -:  440:  getMaybeValues(presburger::VarKind kind) const {
        -:  441:    assert(kind != VarKind::Local &&
        -:  442:           "Local variables do not have any value attached to them.");
        -:  443:    return {values.data() + getVarKindOffset(kind), getNumVarKind(kind)};
        -:  444:  }
        -:  445:
        -:  446:  /// Sets the Value associated with the pos^th variable.
        -:  447:  inline void setValue(unsigned pos, Value val) {
        -:  448:    assert(pos < getNumDimAndSymbolVars() && "invalid var position");
        -:  449:    values[pos] = val;
        -:  450:  }
        -:  451:
        -:  452:  /// Sets the Values associated with the variables in the range [start, end).
        -:  453:  /// The range must contain only dim and symbol variables.
        -:  454:  void setValues(unsigned start, unsigned end, ArrayRef<Value> values) {
        -:  455:    assert(end <= getNumVars() && "invalid end position");
        -:  456:    assert(start <= end && "invalid start position");
        -:  457:    assert(values.size() == end - start &&
        -:  458:           "value should be provided for each variable in the range.");
        -:  459:    for (unsigned i = start; i < end; ++i)
        -:  460:      setValue(i, values[i - start]);
        -:  461:  }
        -:  462:
        -:  463:  /// Merge and align symbols of `this` and `other` such that both get union of
        -:  464:  /// of symbols that are unique. Symbols in `this` and `other` should be
        -:  465:  /// unique. Symbols with Value as `None` are considered to be inequal to all
        -:  466:  /// other symbols.
        -:  467:  void mergeSymbolVars(FlatAffineValueConstraints &other);
        -:  468:
        -:  469:protected:
        -:  470:  using VarKind = presburger::VarKind;
        -:  471:
        -:  472:  /// Returns false if the fields corresponding to various variable counts, or
        -:  473:  /// equality/inequality buffer sizes aren't consistent; true otherwise. This
        -:  474:  /// is meant to be used within an assert internally.
        -:  475:  bool hasConsistentState() const override;
        -:  476:
        -:  477:  /// Given an affine map that is aligned with this constraint system:
        -:  478:  /// * Flatten the map.
        -:  479:  /// * Add newly introduced local columns at the beginning of this constraint
        -:  480:  ///   system (local column pos 0).
        -:  481:  /// * Add equalities that define the new local columns to this constraint
        -:  482:  ///   system.
        -:  483:  /// * Return the flattened expressions via `flattenedExprs`.
        -:  484:  ///
        -:  485:  /// Note: This is a shared helper function of `addLowerOrUpperBound` and
        -:  486:  ///       `composeMatchingMap`.
        -:  487:  LogicalResult flattenAlignedMapAndMergeLocals(
        -:  488:      AffineMap map, std::vector<SmallVector<int64_t, 8>> *flattenedExprs);
        -:  489:
        -:  490:  /// Eliminates the variable at the specified position using Fourier-Motzkin
        -:  491:  /// variable elimination, but uses Gaussian elimination if there is an
        -:  492:  /// equality involving that variable. If the result of the elimination is
        -:  493:  /// integer exact, `*isResultIntegerExact` is set to true. If `darkShadow` is
        -:  494:  /// set to true, a potential under approximation (subset) of the rational
        -:  495:  /// shadow / exact integer shadow is computed.
        -:  496:  // See implementation comments for more details.
        -:  497:  void fourierMotzkinEliminate(unsigned pos, bool darkShadow = false,
        -:  498:                               bool *isResultIntegerExact = nullptr) override;
        -:  499:
        -:  500:  /// Prints the number of constraints, dimensions, symbols and locals in the
        -:  501:  /// FlatAffineConstraints. Also, prints for each variable whether there is
        -:  502:  /// an SSA Value attached to it.
        -:  503:  void printSpace(raw_ostream &os) const override;
        -:  504:
        -:  505:  /// Values corresponding to the (column) non-local variables of this
        -:  506:  /// constraint system appearing in the order the variables correspond to
        -:  507:  /// columns. Variables that aren't associated with any Value are set to
        -:  508:  /// None.
        -:  509:  SmallVector<Optional<Value>, 8> values;
        -:  510:};
        -:  511:
        -:  512:/// A FlatAffineRelation represents a set of ordered pairs (domain -> range)
        -:  513:/// where "domain" and "range" are tuples of variables. The relation is
        -:  514:/// represented as a FlatAffineValueConstraints with separation of dimension
        -:  515:/// variables into domain and  range. The variables are stored as:
        -:  516:/// [domainVars, rangeVars, symbolVars, localVars, constant].
        -:  517:class FlatAffineRelation : public FlatAffineValueConstraints {
        -:  518:public:
        -:  519:  FlatAffineRelation(unsigned numReservedInequalities,
        -:  520:                     unsigned numReservedEqualities, unsigned numReservedCols,
        -:  521:                     unsigned numDomainDims, unsigned numRangeDims,
        -:  522:                     unsigned numSymbols, unsigned numLocals,
        -:  523:                     ArrayRef<Optional<Value>> valArgs = {})
        -:  524:      : FlatAffineValueConstraints(
        -:  525:            numReservedInequalities, numReservedEqualities, numReservedCols,
        -:  526:            numDomainDims + numRangeDims, numSymbols, numLocals, valArgs),
        -:  527:        numDomainDims(numDomainDims), numRangeDims(numRangeDims) {}
        -:  528:
        -:  529:  FlatAffineRelation(unsigned numDomainDims = 0, unsigned numRangeDims = 0,
        -:  530:                     unsigned numSymbols = 0, unsigned numLocals = 0)
        -:  531:      : FlatAffineValueConstraints(numDomainDims + numRangeDims, numSymbols,
        -:  532:                                   numLocals),
        -:  533:        numDomainDims(numDomainDims), numRangeDims(numRangeDims) {}
        -:  534:
        -:  535:  FlatAffineRelation(unsigned numDomainDims, unsigned numRangeDims,
        -:  536:                     FlatAffineValueConstraints &fac)
        -:  537:      : FlatAffineValueConstraints(fac), numDomainDims(numDomainDims),
        -:  538:        numRangeDims(numRangeDims) {}
        -:  539:
        -:  540:  FlatAffineRelation(unsigned numDomainDims, unsigned numRangeDims,
        -:  541:                     IntegerPolyhedron &fac)
        -:  542:      : FlatAffineValueConstraints(fac), numDomainDims(numDomainDims),
        -:  543:        numRangeDims(numRangeDims) {}
        -:  544:
        -:  545:  /// Returns a set corresponding to the domain/range of the affine relation.
        -:  546:  FlatAffineValueConstraints getDomainSet() const;
        -:  547:  FlatAffineValueConstraints getRangeSet() const;
        -:  548:
        -:  549:  /// Returns the number of variables corresponding to domain/range of
        -:  550:  /// relation.
        -:  551:  inline unsigned getNumDomainDims() const { return numDomainDims; }
        -:  552:  inline unsigned getNumRangeDims() const { return numRangeDims; }
        -:  553:
        -:  554:  /// Given affine relation `other: (domainOther -> rangeOther)`, this operation
        -:  555:  /// takes the composition of `other` on `this: (domainThis -> rangeThis)`.
        -:  556:  /// The resulting relation represents tuples of the form: `domainOther ->
        -:  557:  /// rangeThis`.
        -:  558:  void compose(const FlatAffineRelation &other);
        -:  559:
        -:  560:  /// Swap domain and range of the relation.
        -:  561:  /// `(domain -> range)` is converted to `(range -> domain)`.
        -:  562:  void inverse();
        -:  563:
        -:  564:  /// Insert `num` variables of the specified kind after the `pos` variable
        -:  565:  /// of that kind. The coefficient columns corresponding to the added
        -:  566:  /// variables are initialized to zero.
        -:  567:  void insertDomainVar(unsigned pos, unsigned num = 1);
        -:  568:  void insertRangeVar(unsigned pos, unsigned num = 1);
        -:  569:
        -:  570:  /// Append `num` variables of the specified kind after the last variable
        -:  571:  /// of that kind. The coefficient columns corresponding to the added
        -:  572:  /// variables are initialized to zero.
        -:  573:  void appendDomainVar(unsigned num = 1);
        -:  574:  void appendRangeVar(unsigned num = 1);
        -:  575:
        -:  576:  /// Removes variables in the column range [varStart, varLimit), and copies any
        -:  577:  /// remaining valid data into place, updates member variables, and resizes
        -:  578:  /// arrays as needed.
        -:  579:  void removeVarRange(VarKind kind, unsigned varStart,
        -:  580:                      unsigned varLimit) override;
        -:  581:  using IntegerRelation::removeVarRange;
        -:  582:
        -:  583:protected:
        -:  584:  // Number of dimension variables corresponding to domain variables.
        -:  585:  unsigned numDomainDims;
        -:  586:
        -:  587:  // Number of dimension variables corresponding to range variables.
        -:  588:  unsigned numRangeDims;
        -:  589:};
        -:  590:
        -:  591:/// Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the
        -:  592:/// dimensions, symbols, and additional variables that represent floor divisions
        -:  593:/// of dimensions, symbols, and in turn other floor divisions.  Returns failure
        -:  594:/// if 'expr' could not be flattened (i.e., semi-affine is not yet handled).
        -:  595:/// 'cst' contains constraints that connect newly introduced local variables
        -:  596:/// to existing dimensional and symbolic variables. See documentation for
        -:  597:/// AffineExprFlattener on how mod's and div's are flattened.
        -:  598:LogicalResult getFlattenedAffineExpr(AffineExpr expr, unsigned numDims,
        -:  599:                                     unsigned numSymbols,
        -:  600:                                     SmallVectorImpl<int64_t> *flattenedExpr,
        -:  601:                                     FlatAffineValueConstraints *cst = nullptr);
        -:  602:
        -:  603:/// Flattens the result expressions of the map to their corresponding flattened
        -:  604:/// forms and set in 'flattenedExprs'. Returns failure if any expression in the
        -:  605:/// map could not be flattened (i.e., semi-affine is not yet handled). 'cst'
        -:  606:/// contains constraints that connect newly introduced local variables to
        -:  607:/// existing dimensional and / symbolic variables. See documentation for
        -:  608:/// AffineExprFlattener on how mod's and div's are flattened. For all affine
        -:  609:/// expressions that share the same operands (like those of an affine map), this
        -:  610:/// method should be used instead of repeatedly calling getFlattenedAffineExpr
        -:  611:/// since local variables added to deal with div's and mod's will be reused
        -:  612:/// across expressions.
        -:  613:LogicalResult
        -:  614:getFlattenedAffineExprs(AffineMap map,
        -:  615:                        std::vector<SmallVector<int64_t, 8>> *flattenedExprs,
        -:  616:                        FlatAffineValueConstraints *cst = nullptr);
        -:  617:LogicalResult
        -:  618:getFlattenedAffineExprs(IntegerSet set,
        -:  619:                        std::vector<SmallVector<int64_t, 8>> *flattenedExprs,
        -:  620:                        FlatAffineValueConstraints *cst = nullptr);
        -:  621:
        -:  622:LogicalResult
        -:  623:getMultiAffineFunctionFromMap(AffineMap map,
        -:  624:                              presburger::MultiAffineFunction &multiAff);
        -:  625:
        -:  626:/// Re-indexes the dimensions and symbols of an affine map with given `operands`
        -:  627:/// values to align with `dims` and `syms` values.
        -:  628:///
        -:  629:/// Each dimension/symbol of the map, bound to an operand `o`, is replaced with
        -:  630:/// dimension `i`, where `i` is the position of `o` within `dims`. If `o` is not
        -:  631:/// in `dims`, replace it with symbol `i`, where `i` is the position of `o`
        -:  632:/// within `syms`. If `o` is not in `syms` either, replace it with a new symbol.
        -:  633:///
        -:  634:/// Note: If a value appears multiple times as a dimension/symbol (or both), all
        -:  635:/// corresponding dim/sym expressions are replaced with the first dimension
        -:  636:/// bound to that value (or first symbol if no such dimension exists).
        -:  637:///
        -:  638:/// The resulting affine map has `dims.size()` many dimensions and at least
        -:  639:/// `syms.size()` many symbols.
        -:  640:///
        -:  641:/// The SSA values of the symbols of the resulting map are optionally returned
        -:  642:/// via `newSyms`. This is a concatenation of `syms` with the SSA values of the
        -:  643:/// newly added symbols.
        -:  644:///
        -:  645:/// Note: As part of this re-indexing, dimensions may turn into symbols, or vice
        -:  646:/// versa.
        -:  647:AffineMap alignAffineMapWithValues(AffineMap map, ValueRange operands,
        -:  648:                                   ValueRange dims, ValueRange syms,
        -:  649:                                   SmallVector<Value> *newSyms = nullptr);
        -:  650:
        -:  651:/// Builds a relation from the given AffineMap/AffineValueMap `map`, containing
        -:  652:/// all pairs of the form `operands -> result` that satisfy `map`. `rel` is set
        -:  653:/// to the relation built. For example, give the AffineMap:
        -:  654:///
        -:  655:///   (d0, d1)[s0] -> (d0 + s0, d0 - s0)
        -:  656:///
        -:  657:/// the resulting relation formed is:
        -:  658:///
        -:  659:///   (d0, d1) -> (r1, r2)
        -:  660:///   [d0  d1  r1  r2  s0  const]
        -:  661:///    1   0   -1   0  1     0     = 0
        -:  662:///    0   1    0  -1  -1    0     = 0
        -:  663:///
        -:  664:/// For AffineValueMap, the domain and symbols have Value set corresponding to
        -:  665:/// the Value in `map`. Returns failure if the AffineMap could not be flattened
        -:  666:/// (i.e., semi-affine is not yet handled).
        -:  667:LogicalResult getRelationFromMap(AffineMap &map, FlatAffineRelation &rel);
        -:  668:LogicalResult getRelationFromMap(const AffineValueMap &map,
        -:  669:                                 FlatAffineRelation &rel);
        -:  670:
        -:  671:} // namespace mlir.
        -:  672:
        -:  673:#endif // MLIR_DIALECT_AFFINE_ANALYSIS_AFFINESTRUCTURES_H
