        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/AsmParser/TypeParser.cpp
        -:    0:Graph:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/TypeParser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/TypeParser.cpp.gcda
        -:    0:Runs:325595
        -:    1://===- TypeParser.cpp - MLIR Type Parser Implementation -------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the parser for the MLIR Types.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "Parser.h"
        -:   14:#include "mlir/IR/AffineMap.h"
        -:   15:#include "mlir/IR/BuiltinTypes.h"
        -:   16:#include "mlir/IR/OpDefinition.h"
        -:   17:#include "mlir/IR/TensorEncoding.h"
        -:   18:
        -:   19:using namespace mlir;
        -:   20:using namespace mlir::detail;
        -:   21:
        -:   22:/// Optionally parse a type.
function _ZN4mlir6detail6Parser17parseOptionalTypeERNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:   23:OptionalParseResult Parser::parseOptionalType(Type &type) {
        -:   24:  // There are many different starting tokens for a type, check them here.
    #####:   25:  switch (getToken().getKind()) {
branch  0 never executed
branch  1 never executed
    #####:   26:  case Token::l_paren:
    #####:   27:  case Token::kw_memref:
    #####:   28:  case Token::kw_tensor:
    #####:   29:  case Token::kw_complex:
    #####:   30:  case Token::kw_tuple:
    #####:   31:  case Token::kw_vector:
    #####:   32:  case Token::inttype:
    #####:   33:  case Token::kw_f8E5M2:
    #####:   34:  case Token::kw_bf16:
    #####:   35:  case Token::kw_f16:
    #####:   36:  case Token::kw_f32:
    #####:   37:  case Token::kw_f64:
    #####:   38:  case Token::kw_f80:
    #####:   39:  case Token::kw_f128:
    #####:   40:  case Token::kw_index:
    #####:   41:  case Token::kw_none:
    #####:   42:  case Token::exclamation_identifier:
    #####:   43:    return failure(!(type = parseType()));
call    0 never executed
        -:   44:
    #####:   45:  default:
    #####:   46:    return llvm::None;
        -:   47:  }
        -:   48:}
        -:   49:
        -:   50:/// Parse an arbitrary type.
        -:   51:///
        -:   52:///   type ::= function-type
        -:   53:///          | non-function-type
        -:   54:///
function _ZN4mlir6detail6Parser9parseTypeEv called 23004949 returned 100% blocks executed 100%
 23004949:   55:Type Parser::parseType() {
 23004949:   56:  if (getToken().is(Token::l_paren))
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
  3787340:   57:    return parseFunctionType();
call    0 returned 100%
 19217609:   58:  return parseNonFunctionType();
call    0 returned 100%
        -:   59:}
        -:   60:
        -:   61:/// Parse a function result type.
        -:   62:///
        -:   63:///   function-result-type ::= type-list-parens
        -:   64:///                          | non-function-type
        -:   65:///
function _ZN4mlir6detail6Parser24parseFunctionResultTypesERN4llvm15SmallVectorImplINS_4TypeEEE called 3787340 returned 100% blocks executed 75%
  3787340:   66:ParseResult Parser::parseFunctionResultTypes(SmallVectorImpl<Type> &elements) {
  3787340:   67:  if (getToken().is(Token::l_paren))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   68:    return parseTypeListParens(elements);
call    0 never executed
        -:   69:
  3787340:   70:  Type t = parseNonFunctionType();
call    0 returned 100%
  3787340:   71:  if (!t)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   72:    return failure();
  3787340:   73:  elements.push_back(t);
call    0 returned 100%
  3787340:   74:  return success();
        -:   75:}
        -:   76:
        -:   77:/// Parse a list of types without an enclosing parenthesis.  The list must have
        -:   78:/// at least one member.
        -:   79:///
        -:   80:///   type-list-no-parens ::=  type (`,` type)*
        -:   81:///
function _ZN4mlir6detail6Parser21parseTypeListNoParensERN4llvm15SmallVectorImplINS_4TypeEEE called 2426078 returned 100% blocks executed 100%
  2426078:   82:ParseResult Parser::parseTypeListNoParens(SmallVectorImpl<Type> &elements) {
function _ZZN4mlir6detail6Parser21parseTypeListNoParensERN4llvm15SmallVectorImplINS_4TypeEEEENKUlvE_clEv.isra.0 called 4182570 returned 100% blocks executed 83%
  4182570:   83:  auto parseElt = [&]() -> ParseResult {
  4182570:   84:    auto elt = parseType();
call    0 returned 100%
  4182570:   85:    elements.push_back(elt);
call    0 returned 100%
  4182570:   86:    return elt ? success() : failure();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  2426078:   87:  };
        -:   88:
  2426078:   89:  return parseCommaSeparatedList(parseElt);
call    0 returned 100%
        -:   90:}
        -:   91:
        -:   92:/// Parse a parenthesized list of types.
        -:   93:///
        -:   94:///   type-list-parens ::= `(` `)`
        -:   95:///                      | `(` type-list-no-parens `)`
        -:   96:///
function _ZN4mlir6detail6Parser19parseTypeListParensERN4llvm15SmallVectorImplINS_4TypeEEE called 3787340 returned 100% blocks executed 87%
  3787340:   97:ParseResult Parser::parseTypeListParens(SmallVectorImpl<Type> &elements) {
  3787340:   98:  if (parseToken(Token::l_paren, "expected '('"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   99:    return failure();
        -:  100:
        -:  101:  // Handle empty lists.
  3787340:  102:  if (getToken().is(Token::r_paren))
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
  1361262:  103:    return consumeToken(), success();
call    0 returned 100%
        -:  104:
 4852156*:  105:  if (parseTypeListNoParens(elements) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
 2426078*:  106:      parseToken(Token::r_paren, "expected ')'"))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  107:    return failure();
  2426078:  108:  return success();
        -:  109:}
        -:  110:
        -:  111:/// Parse a complex type.
        -:  112:///
        -:  113:///   complex-type ::= `complex` `<` type `>`
        -:  114:///
function _ZN4mlir6detail6Parser16parseComplexTypeEv called 0 returned 0% blocks executed 0%
    #####:  115:Type Parser::parseComplexType() {
    #####:  116:  consumeToken(Token::kw_complex);
call    0 never executed
        -:  117:
        -:  118:  // Parse the '<'.
    #####:  119:  if (parseToken(Token::less, "expected '<' in complex type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  120:    return nullptr;
        -:  121:
    #####:  122:  SMLoc elementTypeLoc = getToken().getLoc();
call    0 never executed
    #####:  123:  auto elementType = parseType();
call    0 never executed
    #####:  124:  if (!elementType ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  125:      parseToken(Token::greater, "expected '>' in complex type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:    return nullptr;
    #####:  127:  if (!elementType.isa<FloatType>() && !elementType.isa<IntegerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  128:    return emitError(elementTypeLoc, "invalid element type for complex"),
    #####:  129:           nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  130:
    #####:  131:  return ComplexType::get(elementType);
call    0 never executed
        -:  132:}
        -:  133:
        -:  134:/// Parse a function type.
        -:  135:///
        -:  136:///   function-type ::= type-list-parens `->` function-result-type
        -:  137:///
function _ZN4mlir6detail6Parser17parseFunctionTypeEv called 3787340 returned 100% blocks executed 84%
  3787340:  138:Type Parser::parseFunctionType() {
 3787340*:  139:  assert(getToken().is(Token::l_paren));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  140:
  7574680:  141:  SmallVector<Type, 4> arguments, results;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
 7574680*:  142:  if (parseTypeListParens(arguments) ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 7574680*:  143:      parseToken(Token::arrow, "expected '->' in function type") ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
 3787340*:  144:      parseFunctionResultTypes(results))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  145:    return nullptr;
        -:  146:
  3787340:  147:  return builder.getFunctionType(arguments, results);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  148:}
        -:  149:
        -:  150:/// Parse a memref type.
        -:  151:///
        -:  152:///   memref-type ::= ranked-memref-type | unranked-memref-type
        -:  153:///
        -:  154:///   ranked-memref-type ::= `memref` `<` dimension-list-ranked type
        -:  155:///                          (`,` layout-specification)? (`,` memory-space)? `>`
        -:  156:///
        -:  157:///   unranked-memref-type ::= `memref` `<*x` type (`,` memory-space)? `>`
        -:  158:///
        -:  159:///   stride-list ::= `[` (dimension (`,` dimension)*)? `]`
        -:  160:///   strided-layout ::= `offset:` dimension `,` `strides: ` stride-list
        -:  161:///   layout-specification ::= semi-affine-map | strided-layout | attribute
        -:  162:///   memory-space ::= integer-literal | attribute
        -:  163:///
function _ZN4mlir6detail6Parser15parseMemRefTypeEv called 0 returned 0% blocks executed 0%
    #####:  164:Type Parser::parseMemRefType() {
    #####:  165:  SMLoc loc = getToken().getLoc();
call    0 never executed
    #####:  166:  consumeToken(Token::kw_memref);
call    0 never executed
        -:  167:
    #####:  168:  if (parseToken(Token::less, "expected '<' in memref type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  169:    return nullptr;
        -:  170:
    #####:  171:  bool isUnranked;
    #####:  172:  SmallVector<int64_t, 4> dimensions;
branch  0 never executed
branch  1 never executed
        -:  173:
    #####:  174:  if (consumeIf(Token::star)) {
branch  0 never executed
branch  1 never executed
        -:  175:    // This is an unranked memref type.
    #####:  176:    isUnranked = true;
    #####:  177:    if (parseXInDimensionList())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  178:      return nullptr;
        -:  179:
        -:  180:  } else {
    #####:  181:    isUnranked = false;
    #####:  182:    if (parseDimensionListRanked(dimensions))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  183:      return nullptr;
        -:  184:  }
        -:  185:
        -:  186:  // Parse the element type.
    #####:  187:  auto typeLoc = getToken().getLoc();
call    0 never executed
    #####:  188:  auto elementType = parseType();
call    0 never executed
    #####:  189:  if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  190:    return nullptr;
        -:  191:
        -:  192:  // Check that memref is formed from allowed types.
    #####:  193:  if (!BaseMemRefType::isValidElementType(elementType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:    return emitError(typeLoc, "invalid memref element type"), nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  195:
    #####:  196:  MemRefLayoutAttrInterface layout;
call    0 never executed
    #####:  197:  Attribute memorySpace;
        -:  198:
function _ZZN4mlir6detail6Parser15parseMemRefTypeEvENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  199:  auto parseElt = [&]() -> ParseResult {
        -:  200:    // Either it is MemRefLayoutAttrInterface or memory space attribute.
    #####:  201:    Attribute attr = parseAttribute();
call    0 never executed
    #####:  202:    if (!attr)
branch  0 never executed
branch  1 never executed
    #####:  203:      return failure();
        -:  204:
    #####:  205:    if (attr.isa<MemRefLayoutAttrInterface>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  206:      layout = attr.cast<MemRefLayoutAttrInterface>();
call    0 never executed
    #####:  207:    } else if (memorySpace) {
branch  0 never executed
branch  1 never executed
    #####:  208:      return emitError("multiple memory spaces specified in memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  209:    } else {
    #####:  210:      memorySpace = attr;
    #####:  211:      return success();
        -:  212:    }
        -:  213:
    #####:  214:    if (isUnranked)
branch  0 never executed
branch  1 never executed
    #####:  215:      return emitError("cannot have affine map for unranked memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  216:    if (memorySpace)
branch  0 never executed
branch  1 never executed
    #####:  217:      return emitError("expected memory space to be last in memref type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  218:
    #####:  219:    return success();
    #####:  220:  };
        -:  221:
        -:  222:  // Parse a list of mappings and address space if present.
    #####:  223:  if (!consumeIf(Token::greater)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  224:    // Parse comma separated list of affine maps, followed by memory space.
    #####:  225:    if (parseToken(Token::comma, "expected ',' or '>' in memref type") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  226:        parseCommaSeparatedListUntil(Token::greater, parseElt,
    #####:  227:                                     /*allowEmptyList=*/false)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  228:      return nullptr;
        -:  229:    }
        -:  230:  }
        -:  231:
    #####:  232:  if (isUnranked)
branch  0 never executed
branch  1 never executed
    #####:  233:    return getChecked<UnrankedMemRefType>(loc, elementType, memorySpace);
call    0 never executed
        -:  234:
    #####:  235:  return getChecked<MemRefType>(loc, dimensions, elementType, layout,
    #####:  236:                                memorySpace);
call    0 never executed
        -:  237:}
        -:  238:
        -:  239:/// Parse any type except the function type.
        -:  240:///
        -:  241:///   non-function-type ::= integer-type
        -:  242:///                       | index-type
        -:  243:///                       | float-type
        -:  244:///                       | extended-type
        -:  245:///                       | vector-type
        -:  246:///                       | tensor-type
        -:  247:///                       | memref-type
        -:  248:///                       | complex-type
        -:  249:///                       | tuple-type
        -:  250:///                       | none-type
        -:  251:///
        -:  252:///   index-type ::= `index`
        -:  253:///   float-type ::= `f16` | `bf16` | `f32` | `f64` | `f80` | `f128`
        -:  254:///   none-type ::= `none`
        -:  255:///
function _ZN4mlir6detail6Parser20parseNonFunctionTypeEv called 23004949 returned 100% blocks executed 29%
 23004949:  256:Type Parser::parseNonFunctionType() {
 23004949:  257:  switch (getToken().getKind()) {
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 48%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 10%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 7%
branch 10 taken 35%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 1%
branch 17 taken 0%
    #####:  258:  default:
    #####:  259:    return (emitWrongTokenError("expected non-function type"), nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  260:  case Token::kw_memref:
    #####:  261:    return parseMemRefType();
call    0 never executed
 10994498:  262:  case Token::kw_tensor:
 10994498:  263:    return parseTensorType();
call    0 returned 100%
    #####:  264:  case Token::kw_complex:
    #####:  265:    return parseComplexType();
call    0 never executed
    #####:  266:  case Token::kw_tuple:
    #####:  267:    return parseTupleType();
call    0 never executed
    #####:  268:  case Token::kw_vector:
    #####:  269:    return parseVectorType();
call    0 never executed
        -:  270:  // integer-type
  2293588:  271:  case Token::inttype: {
  2293588:  272:    auto width = getToken().getIntTypeBitwidth();
call    0 returned 100%
  2293588:  273:    if (!width.has_value())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  274:      return (emitError("invalid integer width"), nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
  2293588:  275:    if (width.value() > IntegerType::kMaxWidth) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  276:      emitError(getToken().getLoc(), "integer bitwidth is limited to ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  277:          << IntegerType::kMaxWidth << " bits";
call    0 never executed
call    1 never executed
    #####:  278:      return nullptr;
        -:  279:    }
        -:  280:
  2293588:  281:    IntegerType::SignednessSemantics signSemantics = IntegerType::Signless;
  2293588:  282:    if (Optional<bool> signedness = getToken().getIntTypeSignedness())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  283:      signSemantics = *signedness ? IntegerType::Signed : IntegerType::Unsigned;
branch  0 never executed
branch  1 never executed
        -:  284:
  2293588:  285:    consumeToken(Token::inttype);
call    0 returned 100%
  2293588:  286:    return IntegerType::get(getContext(), *width, signSemantics);
call    0 returned 100%
        -:  287:  }
        -:  288:
        -:  289:  // float-type
    #####:  290:  case Token::kw_f8E5M2:
    #####:  291:    consumeToken(Token::kw_f8E5M2);
call    0 never executed
    #####:  292:    return builder.getFloat8E5M2Type();
call    0 never executed
    #####:  293:  case Token::kw_bf16:
    #####:  294:    consumeToken(Token::kw_bf16);
call    0 never executed
    #####:  295:    return builder.getBF16Type();
call    0 never executed
  1588643:  296:  case Token::kw_f16:
  1588643:  297:    consumeToken(Token::kw_f16);
call    0 returned 100%
  1588643:  298:    return builder.getF16Type();
call    0 returned 100%
  8123525:  299:  case Token::kw_f32:
  8123525:  300:    consumeToken(Token::kw_f32);
call    0 returned 100%
  8123525:  301:    return builder.getF32Type();
call    0 returned 100%
    #####:  302:  case Token::kw_f64:
    #####:  303:    consumeToken(Token::kw_f64);
call    0 never executed
    #####:  304:    return builder.getF64Type();
call    0 never executed
    #####:  305:  case Token::kw_f80:
    #####:  306:    consumeToken(Token::kw_f80);
call    0 never executed
    #####:  307:    return builder.getF80Type();
call    0 never executed
    #####:  308:  case Token::kw_f128:
    #####:  309:    consumeToken(Token::kw_f128);
call    0 never executed
    #####:  310:    return builder.getF128Type();
call    0 never executed
        -:  311:
        -:  312:  // index-type
    #####:  313:  case Token::kw_index:
    #####:  314:    consumeToken(Token::kw_index);
call    0 never executed
    #####:  315:    return builder.getIndexType();
call    0 never executed
        -:  316:
        -:  317:  // none-type
    #####:  318:  case Token::kw_none:
    #####:  319:    consumeToken(Token::kw_none);
call    0 never executed
    #####:  320:    return builder.getNoneType();
call    0 never executed
        -:  321:
        -:  322:  // extended type
     4695:  323:  case Token::exclamation_identifier:
     4695:  324:    return parseExtendedType();
call    0 returned 100%
        -:  325:
        -:  326:  // Handle completion of a dialect type.
    #####:  327:  case Token::code_complete:
    #####:  328:    if (getToken().isCodeCompletionFor(Token::exclamation_identifier))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  329:      return parseExtendedType();
call    0 never executed
    #####:  330:    return codeCompleteType();
call    0 never executed
        -:  331:  }
        -:  332:}
        -:  333:
        -:  334:/// Parse a tensor type.
        -:  335:///
        -:  336:///   tensor-type ::= `tensor` `<` dimension-list type `>`
        -:  337:///   dimension-list ::= dimension-list-ranked | `*x`
        -:  338:///
function _ZN4mlir6detail6Parser15parseTensorTypeEv called 10994498 returned 100% blocks executed 45%
 10994498:  339:Type Parser::parseTensorType() {
 10994498:  340:  consumeToken(Token::kw_tensor);
call    0 returned 100%
        -:  341:
 10994498:  342:  if (parseToken(Token::less, "expected '<' in tensor type"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  343:    return nullptr;
        -:  344:
 10994498:  345:  bool isUnranked;
 10994498:  346:  SmallVector<int64_t, 4> dimensions;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  347:
10994498*:  348:  if (consumeIf(Token::star)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  349:    // This is an unranked tensor type.
    #####:  350:    isUnranked = true;
        -:  351:
    #####:  352:    if (parseXInDimensionList())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  353:      return nullptr;
        -:  354:
        -:  355:  } else {
 10994498:  356:    isUnranked = false;
 10994498:  357:    if (parseDimensionListRanked(dimensions))
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  358:      return nullptr;
        -:  359:  }
        -:  360:
        -:  361:  // Parse the element type.
 10994498:  362:  auto elementTypeLoc = getToken().getLoc();
call    0 returned 100%
 10994498:  363:  auto elementType = parseType();
call    0 returned 100%
        -:  364:
        -:  365:  // Parse an optional encoding attribute.
 10994498:  366:  Attribute encoding;
10994498*:  367:  if (consumeIf(Token::comma)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  368:    encoding = parseAttribute();
call    0 never executed
    #####:  369:    if (auto v = encoding.dyn_cast_or_null<VerifiableTensorEncoding>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  370:      if (failed(v.verifyEncoding(dimensions, elementType,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:                                  [&] { return emitError(); })))
call    0 never executed
call    1 never executed
    #####:  372:        return nullptr;
        -:  373:    }
        -:  374:  }
        -:  375:
10994498*:  376:  if (!elementType || parseToken(Token::greater, "expected '>' in tensor type"))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####:  377:    return nullptr;
 10994498:  378:  if (!TensorType::isValidElementType(elementType))
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  379:    return emitError(elementTypeLoc, "invalid tensor element type"), nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  380:
 10994498:  381:  if (isUnranked) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  382:    if (encoding)
branch  0 never executed
branch  1 never executed
    #####:  383:      return emitError("cannot apply encoding to unranked tensor"), nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  384:    return UnrankedTensorType::get(elementType);
call    0 never executed
        -:  385:  }
 10994498:  386:  return RankedTensorType::get(dimensions, elementType, encoding);
call    0 returned 100%
        -:  387:}
        -:  388:
        -:  389:/// Parse a tuple type.
        -:  390:///
        -:  391:///   tuple-type ::= `tuple` `<` (type (`,` type)*)? `>`
        -:  392:///
function _ZN4mlir6detail6Parser14parseTupleTypeEv called 0 returned 0% blocks executed 0%
    #####:  393:Type Parser::parseTupleType() {
    #####:  394:  consumeToken(Token::kw_tuple);
call    0 never executed
        -:  395:
        -:  396:  // Parse the '<'.
    #####:  397:  if (parseToken(Token::less, "expected '<' in tuple type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  398:    return nullptr;
        -:  399:
        -:  400:  // Check for an empty tuple by directly parsing '>'.
    #####:  401:  if (consumeIf(Token::greater))
branch  0 never executed
branch  1 never executed
    #####:  402:    return TupleType::get(getContext());
call    0 never executed
        -:  403:
        -:  404:  // Parse the element types and the '>'.
    #####:  405:  SmallVector<Type, 4> types;
call    0 never executed
    #####:  406:  if (parseTypeListNoParens(types) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  407:      parseToken(Token::greater, "expected '>' in tuple type"))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  408:    return nullptr;
        -:  409:
    #####:  410:  return TupleType::get(getContext(), types);
call    0 never executed
call    1 never executed
        -:  411:}
        -:  412:
        -:  413:/// Parse a vector type.
        -:  414:///
        -:  415:/// vector-type ::= `vector` `<` vector-dim-list vector-element-type `>`
        -:  416:/// vector-dim-list := (static-dim-list `x`)? (`[` static-dim-list `]` `x`)?
        -:  417:/// static-dim-list ::= decimal-literal (`x` decimal-literal)*
        -:  418:///
function _ZN4mlir6detail6Parser15parseVectorTypeEv called 0 returned 0% blocks executed 0%
    #####:  419:VectorType Parser::parseVectorType() {
    #####:  420:  consumeToken(Token::kw_vector);
call    0 never executed
        -:  421:
    #####:  422:  if (parseToken(Token::less, "expected '<' in vector type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  423:    return nullptr;
        -:  424:
    #####:  425:  SmallVector<int64_t, 4> dimensions;
call    0 never executed
    #####:  426:  unsigned numScalableDims;
    #####:  427:  if (parseVectorDimensionList(dimensions, numScalableDims))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  428:    return nullptr;
    #####:  429:  if (any_of(dimensions, [](int64_t i) { return i <= 0; }))
branch  0 never executed
branch  1 never executed
    #####:  430:    return emitError(getToken().getLoc(),
call    0 never executed
        -:  431:                     "vector types must have positive constant sizes"),
    #####:  432:           nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  433:
        -:  434:  // Parse the element type.
    #####:  435:  auto typeLoc = getToken().getLoc();
call    0 never executed
    #####:  436:  auto elementType = parseType();
call    0 never executed
    #####:  437:  if (!elementType || parseToken(Token::greater, "expected '>' in vector type"))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  438:    return nullptr;
        -:  439:
    #####:  440:  if (!VectorType::isValidElementType(elementType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  441:    return emitError(typeLoc, "vector elements must be int/index/float type"),
    #####:  442:           nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  443:
    #####:  444:  return VectorType::get(dimensions, elementType, numScalableDims);
call    0 never executed
        -:  445:}
        -:  446:
        -:  447:/// Parse a dimension list in a vector type. This populates the dimension list,
        -:  448:/// and returns the number of scalable dimensions in `numScalableDims`.
        -:  449:///
        -:  450:/// vector-dim-list := (static-dim-list `x`)? (`[` static-dim-list `]` `x`)?
        -:  451:/// static-dim-list ::= decimal-literal (`x` decimal-literal)*
        -:  452:///
        -:  453:ParseResult
function _ZN4mlir6detail6Parser24parseVectorDimensionListERN4llvm15SmallVectorImplIlEERj called 0 returned 0% blocks executed 0%
    #####:  454:Parser::parseVectorDimensionList(SmallVectorImpl<int64_t> &dimensions,
        -:  455:                                 unsigned &numScalableDims) {
    #####:  456:  numScalableDims = 0;
        -:  457:  // If there is a set of fixed-length dimensions, consume it
    #####:  458:  while (getToken().is(Token::integer)) {
branch  0 never executed
branch  1 never executed
    #####:  459:    int64_t value;
    #####:  460:    if (parseIntegerInDimensionList(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  461:      return failure();
    #####:  462:    dimensions.push_back(value);
call    0 never executed
        -:  463:    // Make sure we have an 'x' or something like 'xbf32'.
    #####:  464:    if (parseXInDimensionList())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  465:      return failure();
        -:  466:  }
        -:  467:  // If there is a set of scalable dimensions, consume it
    #####:  468:  if (consumeIf(Token::l_square)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  469:    while (getToken().is(Token::integer)) {
branch  0 never executed
branch  1 never executed
    #####:  470:      int64_t value;
    #####:  471:      if (parseIntegerInDimensionList(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  472:        return failure();
    #####:  473:      dimensions.push_back(value);
call    0 never executed
    #####:  474:      numScalableDims++;
        -:  475:      // Check if we have reached the end of the scalable dimension list
    #####:  476:      if (consumeIf(Token::r_square)) {
branch  0 never executed
branch  1 never executed
        -:  477:        // Make sure we have something like 'xbf32'.
    #####:  478:        return parseXInDimensionList();
call    0 never executed
        -:  479:      }
        -:  480:      // Make sure we have an 'x'
    #####:  481:      if (parseXInDimensionList())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  482:        return failure();
        -:  483:    }
        -:  484:    // If we make it here, we've finished parsing the dimension list
        -:  485:    // without finding ']' closing the set of scalable dimensions
    #####:  486:    return emitWrongTokenError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  487:        "missing ']' closing set of scalable dimensions");
call    0 never executed
        -:  488:  }
        -:  489:
    #####:  490:  return success();
        -:  491:}
        -:  492:
        -:  493:/// Parse a dimension list of a tensor or memref type.  This populates the
        -:  494:/// dimension list, using -1 for the `?` dimensions if `allowDynamic` is set and
        -:  495:/// errors out on `?` otherwise. Parsing the trailing `x` is configurable.
        -:  496:///
        -:  497:///   dimension-list ::= eps | dimension (`x` dimension)*
        -:  498:///   dimension-list-with-trailing-x ::= (dimension `x`)*
        -:  499:///   dimension ::= `?` | decimal-literal
        -:  500:///
        -:  501:/// When `allowDynamic` is not set, this is used to parse:
        -:  502:///
        -:  503:///   static-dimension-list ::= eps | decimal-literal (`x` decimal-literal)*
        -:  504:///   static-dimension-list-with-trailing-x ::= (dimension `x`)*
        -:  505:ParseResult
function _ZN4mlir6detail6Parser24parseDimensionListRankedERN4llvm15SmallVectorImplIlEEbb called 10994498 returned 100% blocks executed 38%
 10994498:  506:Parser::parseDimensionListRanked(SmallVectorImpl<int64_t> &dimensions,
        -:  507:                                 bool allowDynamic, bool withTrailingX) {
function _ZZN4mlir6detail6Parser24parseDimensionListRankedERN4llvm15SmallVectorImplIlEEbbENKUlvE_clEv called 41215828 returned 100% blocks executed 47%
 52210326:  508:  auto parseDim = [&]() -> LogicalResult {
41215828*:  509:    auto loc = getToken().getLoc();
call    0 returned 100%
41215828*:  510:    if (consumeIf(Token::question)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  511:      if (!allowDynamic)
branch  0 never executed
branch  1 never executed
    #####:  512:        return emitError(loc, "expected static shape");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  513:      dimensions.push_back(ShapedType::kDynamicSize);
call    0 never executed
        -:  514:    } else {
 41215828:  515:      int64_t value;
 41215828:  516:      if (failed(parseIntegerInDimensionList(value)))
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  517:        return failure();
 41215828:  518:      dimensions.push_back(value);
call    0 returned 100%
        -:  519:    }
 41215828:  520:    return success();
 10994498:  521:  };
        -:  522:
 10994498:  523:  if (withTrailingX) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 52210326:  524:    while (getToken().isAny(Token::integer, Token::question)) {
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
41215828*:  525:      if (failed(parseDim()) || failed(parseXInDimensionList()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####:  526:        return failure();
        -:  527:    }
 10994498:  528:    return success();
        -:  529:  }
        -:  530:
    #####:  531:  if (getToken().isAny(Token::integer, Token::question)) {
branch  0 never executed
branch  1 never executed
    #####:  532:    if (failed(parseDim()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  533:      return failure();
    #####:  534:    while (getToken().is(Token::bare_identifier) &&
branch  0 never executed
branch  1 never executed
    #####:  535:           getTokenSpelling()[0] == 'x') {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  536:      if (failed(parseXInDimensionList()) || failed(parseDim()))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  537:        return failure();
        -:  538:    }
        -:  539:  }
    #####:  540:  return success();
        -:  541:}
        -:  542:
function _ZN4mlir6detail6Parser27parseIntegerInDimensionListERl called 41215828 returned 100% blocks executed 50%
 41215828:  543:ParseResult Parser::parseIntegerInDimensionList(int64_t &value) {
        -:  544:  // Hexadecimal integer literals (starting with `0x`) are not allowed in
        -:  545:  // aggregate type declarations.  Therefore, `0xf32` should be processed as
        -:  546:  // a sequence of separate elements `0`, `x`, `f32`.
 41215828:  547:  if (getTokenSpelling().size() > 1 && getTokenSpelling()[1] == 'x') {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  548:    // We can get here only if the token is an integer literal.  Hexadecimal
        -:  549:    // integer literals can only start with `0x` (`1x` wouldn't lex as a
        -:  550:    // literal, just `1` would, at which point we don't get into this
        -:  551:    // branch).
    #####:  552:    assert(getTokenSpelling()[0] == '0' && "invalid integer literal");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  553:    value = 0;
    #####:  554:    state.lex.resetPointer(getTokenSpelling().data() + 1);
call    0 never executed
    #####:  555:    consumeToken();
call    0 never executed
        -:  556:  } else {
        -:  557:    // Make sure this integer value is in bound and valid.
 41215828:  558:    Optional<uint64_t> dimension = getToken().getUInt64IntegerValue();
call    0 returned 100%
 41215828:  559:    if (!dimension ||
branch  0 taken 100%
branch  1 taken 0%
 41215828:  560:        *dimension > (uint64_t)std::numeric_limits<int64_t>::max())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  561:      return emitError("invalid dimension");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 41215828:  562:    value = (int64_t)*dimension;
call    0 returned 100%
 41215828:  563:    consumeToken(Token::integer);
call    0 returned 100%
        -:  564:  }
 41215828:  565:  return success();
        -:  566:}
        -:  567:
        -:  568:/// Parse an 'x' token in a dimension list, handling the case where the x is
        -:  569:/// juxtaposed with an element type, as in "xf32", leaving the "f32" as the next
        -:  570:/// token.
function _ZN4mlir6detail6Parser21parseXInDimensionListEv called 41215828 returned 100% blocks executed 57%
 41215828:  571:ParseResult Parser::parseXInDimensionList() {
 41215828:  572:  if (getToken().isNot(Token::bare_identifier) || getTokenSpelling()[0] != 'x')
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  573:    return emitWrongTokenError("expected 'x' in dimension list");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  574:
        -:  575:  // If we had a prefix of 'x', lex the next token immediately after the 'x'.
 41215828:  576:  if (getTokenSpelling().size() != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 41215828:  577:    state.lex.resetPointer(getTokenSpelling().data() + 1);
        -:  578:
        -:  579:  // Consume the 'x'.
 41215828:  580:  consumeToken(Token::bare_identifier);
call    0 returned 100%
        -:  581:
 41215828:  582:  return success();
        -:  583:}
