        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Transform/IR/TransformOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Transform/IR/CMakeFiles/obj.MLIRTransformDialect.dir/TransformOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Transform/IR/CMakeFiles/obj.MLIRTransformDialect.dir/TransformOps.cpp.gcda
        -:    0:Runs:325556
        -:    1://===- TransformDialect.cpp - Transform dialect operations ----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Transform/IR/TransformOps.h"
        -:   10:#include "mlir/Dialect/PDL/IR/PDLOps.h"
        -:   11:#include "mlir/Dialect/Transform/IR/TransformDialect.h"
        -:   12:#include "mlir/Dialect/Transform/IR/TransformInterfaces.h"
        -:   13:#include "mlir/Dialect/Transform/IR/TransformTypes.h"
        -:   14:#include "mlir/IR/OpImplementation.h"
        -:   15:#include "mlir/IR/PatternMatch.h"
        -:   16:#include "mlir/Interfaces/ControlFlowInterfaces.h"
        -:   17:#include "mlir/Rewrite/FrozenRewritePatternSet.h"
        -:   18:#include "mlir/Rewrite/PatternApplicator.h"
        -:   19:#include "llvm/ADT/STLExtras.h"
        -:   20:#include "llvm/ADT/ScopeExit.h"
        -:   21:#include "llvm/Support/Debug.h"
        -:   22:
        -:   23:#define DEBUG_TYPE "transform-dialect"
        -:   24:#define DBGS() (llvm::dbgs() << "[" DEBUG_TYPE "] ")
        -:   25:
        -:   26:using namespace mlir;
        -:   27:
        -:   28:#define GET_OP_CLASSES
        -:   29:#include "mlir/Dialect/Transform/IR/TransformOps.cpp.inc"
        -:   30:
        -:   31://===----------------------------------------------------------------------===//
        -:   32:// PatternApplicatorExtension
        -:   33://===----------------------------------------------------------------------===//
        -:   34:
        -:   35:namespace {
        -:   36:/// A simple pattern rewriter that can be constructed from a context. This is
        -:   37:/// necessary to apply patterns to a specific op locally.
    #####:   38:class TrivialPatternRewriter : public PatternRewriter {
call    0 never executed
        -:   39:public:
    #####:   40:  explicit TrivialPatternRewriter(MLIRContext *context)
    #####:   41:      : PatternRewriter(context) {}
        -:   42:};
        -:   43:
        -:   44:/// A TransformState extension that keeps track of compiled PDL pattern sets.
        -:   45:/// This is intended to be used along the WithPDLPatterns op. The extension
        -:   46:/// can be constructed given an operation that has a SymbolTable trait and
        -:   47:/// contains pdl::PatternOp instances. The patterns are compiled lazily and one
        -:   48:/// by one when requested; this behavior is subject to change.
        -:   49:class PatternApplicatorExtension : public transform::TransformState::Extension {
        -:   50:public:
function _ZN12_GLOBAL__N_126PatternApplicatorExtension13resolveTypeIDEv called 0 returned 0% blocks executed 0%
    #####:   51:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PatternApplicatorExtension)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   52:
        -:   53:  /// Creates the extension for patterns contained in `patternContainer`.
        -:   54:  explicit PatternApplicatorExtension(transform::TransformState &state,
        -:   55:                                      Operation *patternContainer)
        -:   56:      : Extension(state), patterns(patternContainer) {}
        -:   57:
        -:   58:  /// Appends to `results` the operations contained in `root` that matched the
        -:   59:  /// PDL pattern with the given name. Note that `root` may or may not be the
        -:   60:  /// operation that contains PDL patterns. Reports an error if the pattern
        -:   61:  /// cannot be found. Note that when no operations are matched, this still
        -:   62:  /// succeeds as long as the pattern exists.
        -:   63:  LogicalResult findAllMatches(StringRef patternName, Operation *root,
        -:   64:                               SmallVectorImpl<Operation *> &results);
        -:   65:
        -:   66:private:
        -:   67:  /// Map from the pattern name to a singleton set of rewrite patterns that only
        -:   68:  /// contains the pattern with this name. Populated when the pattern is first
        -:   69:  /// requested.
        -:   70:  // TODO: reconsider the efficiency of this storage when more usage data is
        -:   71:  // available. Storing individual patterns in a set and triggering compilation
        -:   72:  // for each of them has overhead. So does compiling a large set of patterns
        -:   73:  // only to apply a handlful of them.
        -:   74:  llvm::StringMap<FrozenRewritePatternSet> compiledPatterns;
        -:   75:
        -:   76:  /// A symbol table operation containing the relevant PDL patterns.
        -:   77:  SymbolTable patterns;
        -:   78:};
        -:   79:
function _ZN12_GLOBAL__N_126PatternApplicatorExtension14findAllMatchesEN4llvm9StringRefEPN4mlir9OperationERNS1_15SmallVectorImplIS5_EE called 0 returned 0% blocks executed 0%
    #####:   80:LogicalResult PatternApplicatorExtension::findAllMatches(
        -:   81:    StringRef patternName, Operation *root,
        -:   82:    SmallVectorImpl<Operation *> &results) {
    #####:   83:  auto it = compiledPatterns.find(patternName);
call    0 never executed
    #####:   84:  if (it == compiledPatterns.end()) {
branch  0 never executed
branch  1 never executed
    #####:   85:    auto patternOp = patterns.lookup<pdl::PatternOp>(patternName);
call    0 never executed
    #####:   86:    if (!patternOp)
branch  0 never executed
branch  1 never executed
    #####:   87:      return failure();
        -:   88:
    #####:   89:    OwningOpRef<ModuleOp> pdlModuleOp = ModuleOp::create(patternOp.getLoc());
call    0 never executed
call    1 never executed
    #####:   90:    patternOp->moveBefore(pdlModuleOp->getBody(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   91:                          pdlModuleOp->getBody()->end());
call    0 never executed
    #####:   92:    PDLPatternModule patternModule(std::move(pdlModuleOp));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   93:
        -:   94:    // Merge in the hooks owned by the dialect. Make a copy as they may be
        -:   95:    // also used by the following operations.
    #####:   96:    auto *dialect =
call    0 never executed
    #####:   97:        root->getContext()->getLoadedDialect<transform::TransformDialect>();
call    0 never executed
    #####:   98:    for (const auto &pair : dialect->getPDLConstraintHooks())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   99:      patternModule.registerConstraintFunction(pair.first(), pair.second);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  100:
        -:  101:    // Register a noop rewriter because PDL requires patterns to end with some
        -:  102:    // rewrite call.
    #####:  103:    patternModule.registerRewriteFunction(
call    0 never executed
        -:  104:        "transform.dialect", [](PatternRewriter &, Operation *) {});
        -:  105:
    #####:  106:    it = compiledPatterns
    #####:  107:             .try_emplace(patternOp.getName(), std::move(patternModule))
call    0 never executed
call    1 never executed
call    2 never executed
        -:  108:             .first;
        -:  109:  }
        -:  110:
    #####:  111:  PatternApplicator applicator(it->second);
call    0 never executed
    #####:  112:  TrivialPatternRewriter rewriter(root->getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  113:  applicator.applyDefaultCostModel();
call    0 never executed
function _ZZN12_GLOBAL__N_126PatternApplicatorExtension14findAllMatchesEN4llvm9StringRefEPN4mlir9OperationERNS1_15SmallVectorImplIS5_EEENKUlS5_E0_clES5_ called 0 returned 0% blocks executed 0%
    #####:  114:  root->walk([&](Operation *op) {
call    0 never executed
    #####:  115:    if (succeeded(applicator.matchAndRewrite(op, rewriter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  116:      results.push_back(op);
call    0 never executed
    #####:  117:  });
        -:  118:
    #####:  119:  return success();
call    0 never executed
        -:  120:}
        -:  121:} // namespace
        -:  122:
        -:  123://===----------------------------------------------------------------------===//
        -:  124:// AlternativesOp
        -:  125://===----------------------------------------------------------------------===//
        -:  126:
        -:  127:OperandRange
function _ZN4mlir9transform14AlternativesOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 0 returned 0% blocks executed 0%
    #####:  128:transform::AlternativesOp::getSuccessorEntryOperands(Optional<unsigned> index) {
    #####:  129:  if (index && getOperation()->getNumOperands() == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  130:    return getOperation()->getOperands();
call    0 never executed
    #####:  131:  return OperandRange(getOperation()->operand_end(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  132:                      getOperation()->operand_end());
        -:  133:}
        -:  134:
function _ZN4mlir9transform14AlternativesOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####:  135:void transform::AlternativesOp::getSuccessorRegions(
        -:  136:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -:  137:    SmallVectorImpl<RegionSuccessor> &regions) {
    #####:  138:  for (Region &alternative : llvm::drop_begin(
branch  0 never executed
branch  1 never executed
    #####:  139:           getAlternatives(), index.has_value() ? *index + 1 : 0)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  140:    regions.emplace_back(&alternative, !getOperands().empty()
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  141:                                           ? alternative.getArguments()
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  142:                                           : Block::BlockArgListType());
call    0 never executed
        -:  143:  }
    #####:  144:  if (index.has_value())
branch  0 never executed
branch  1 never executed
    #####:  145:    regions.emplace_back(getOperation()->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  146:}
        -:  147:
function _ZN4mlir9transform14AlternativesOp25getRegionInvocationBoundsEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_16InvocationBoundsEEE called 0 returned 0% blocks executed 0%
    #####:  148:void transform::AlternativesOp::getRegionInvocationBounds(
        -:  149:    ArrayRef<Attribute> operands, SmallVectorImpl<InvocationBounds> &bounds) {
    #####:  150:  (void)operands;
        -:  151:  // The region corresponding to the first alternative is always executed, the
        -:  152:  // remaining may or may not be executed.
    #####:  153:  bounds.reserve(getNumRegions());
branch  0 never executed
branch  1 never executed
    #####:  154:  bounds.emplace_back(1, 1);
call    0 never executed
    #####:  155:  bounds.resize(getNumRegions(), InvocationBounds(0, 1));
call    0 never executed
    #####:  156:}
        -:  157:
function _ZL25forwardTerminatorOperandsPN4mlir5BlockERNS_9transform14TransformStateERNS2_16TransformResultsE called 0 returned 0% blocks executed 0%
    #####:  158:static void forwardTerminatorOperands(Block *block,
        -:  159:                                      transform::TransformState &state,
        -:  160:                                      transform::TransformResults &results) {
    #####:  161:  for (const auto &pair : llvm::zip(block->getTerminator()->getOperands(),
call    0 never executed
    #####:  162:                                    block->getParentOp()->getOpResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  163:    Value terminatorOperand = std::get<0>(pair);
    #####:  164:    OpResult result = std::get<1>(pair);
call    0 never executed
    #####:  165:    results.set(result, state.getPayloadOps(terminatorOperand));
call    0 never executed
call    1 never executed
        -:  166:  }
    #####:  167:}
        -:  168:
        -:  169:DiagnosedSilenceableFailure
function _ZN4mlir9transform14AlternativesOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  170:transform::AlternativesOp::apply(transform::TransformResults &results,
        -:  171:                                 transform::TransformState &state) {
    #####:  172:  SmallVector<Operation *> originals;
call    0 never executed
    #####:  173:  if (Value scopeHandle = getScope())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  174:    llvm::append_range(originals, state.getPayloadOps(scopeHandle));
call    0 never executed
call    1 never executed
        -:  175:  else
    #####:  176:    originals.push_back(state.getTopLevel());
call    0 never executed
call    1 never executed
        -:  177:
    #####:  178:  for (Operation *original : originals) {
branch  0 never executed
branch  1 never executed
    #####:  179:    if (original->isAncestor(getOperation())) {
branch  0 never executed
branch  1 never executed
    #####:  180:      auto diag = emitDefiniteFailure()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  181:                  << "scope must not contain the transforms being applied";
call    0 never executed
call    1 never executed
    #####:  182:      diag.attachNote(original->getLoc()) << "scope";
call    0 never executed
call    1 never executed
    #####:  183:      return diag;
call    0 never executed
call    1 never executed
        -:  184:    }
    #####:  185:    if (!original->hasTrait<OpTrait::IsIsolatedFromAbove>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:      auto diag = emitDefiniteFailure()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  187:                  << "only isolated-from-above ops can be alternative scopes";
call    0 never executed
call    1 never executed
    #####:  188:      diag.attachNote(original->getLoc()) << "scope";
call    0 never executed
call    1 never executed
    #####:  189:      return diag;
call    0 never executed
call    1 never executed
        -:  190:    }
        -:  191:  }
        -:  192:
    #####:  193:  for (Region &reg : getAlternatives()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  194:    // Clone the scope operations and make the transforms in this alternative
        -:  195:    // region apply to them by virtue of mapping the block argument (the only
        -:  196:    // visible handle) to the cloned scope operations. This effectively prevents
        -:  197:    // the transformation from accessing any IR outside the scope.
    #####:  198:    auto scope = state.make_region_scope(reg);
call    0 never executed
    #####:  199:    auto clones = llvm::to_vector(
    #####:  200:        llvm::map_range(originals, [](Operation *op) { return op->clone(); }));
call    0 never executed
call    1 never executed
    #####:  201:    auto deleteClones = llvm::make_scope_exit([&] {
    #####:  202:      for (Operation *clone : clones)
branch  0 never executed
branch  1 never executed
    #####:  203:        clone->erase();
call    0 never executed
    #####:  204:    });
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  205:    if (failed(state.mapBlockArguments(reg.front().getArgument(0), clones)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  206:      return DiagnosedSilenceableFailure::definiteFailure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  207:
    #####:  208:    bool failed = false;
    #####:  209:    for (Operation &transform : reg.front().without_terminator()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  210:      DiagnosedSilenceableFailure result =
    #####:  211:          state.applyTransform(cast<TransformOpInterface>(transform));
call    0 never executed
call    1 never executed
    #####:  212:      if (result.isSilenceableFailure()) {
branch  0 never executed
branch  1 never executed
    #####:  213:        LLVM_DEBUG(DBGS() << "alternative failed: " << result.getMessage()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
        -:  214:                          << "\n");
    #####:  215:        failed = true;
    #####:  216:        break;
call    0 never executed
        -:  217:      }
        -:  218:
    #####:  219:      if (::mlir::failed(result.silence()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  220:        return DiagnosedSilenceableFailure::definiteFailure();
call    0 never executed
        -:  221:    }
        -:  222:
        -:  223:    // If all operations in the given alternative succeeded, no need to consider
        -:  224:    // the rest. Replace the original scoping operation with the clone on which
        -:  225:    // the transformations were performed.
    #####:  226:    if (!failed) {
call    0 never executed
        -:  227:      // We will be using the clones, so cancel their scheduled deletion.
    #####:  228:      deleteClones.release();
call    0 never executed
    #####:  229:      IRRewriter rewriter(getContext());
call    0 never executed
    #####:  230:      for (const auto &kvp : llvm::zip(originals, clones)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        Operation *original = std::get<0>(kvp);
    #####:  232:        Operation *clone = std::get<1>(kvp);
    #####:  233:        original->getBlock()->getOperations().insert(original->getIterator(),
call    0 never executed
    #####:  234:                                                     clone);
call    0 never executed
    #####:  235:        rewriter.replaceOp(original, clone->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  236:      }
    #####:  237:      forwardTerminatorOperands(&reg.front(), state, results);
call    0 never executed
call    1 never executed
    #####:  238:      return DiagnosedSilenceableFailure::success();
call    0 never executed
        -:  239:    }
        -:  240:  }
    #####:  241:  return emitSilenceableError() << "all alternatives failed";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  242:}
        -:  243:
function _ZN4mlir9transform14AlternativesOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  244:LogicalResult transform::AlternativesOp::verify() {
    #####:  245:  for (Region &alternative : getAlternatives()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  246:    Block &block = alternative.front();
call    0 never executed
    #####:  247:    Operation *terminator = block.getTerminator();
call    0 never executed
    #####:  248:    if (terminator->getOperands().getTypes() != getResults().getTypes()) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  249:      InFlightDiagnostic diag = emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
        -:  250:                                << "expects terminator operands to have the "
    #####:  251:                                   "same type as results of the operation";
call    0 never executed
call    1 never executed
    #####:  252:      diag.attachNote(terminator->getLoc()) << "terminator";
call    0 never executed
call    1 never executed
    #####:  253:      return diag;
call    0 never executed
        -:  254:    }
        -:  255:  }
        -:  256:
    #####:  257:  return success();
        -:  258:}
        -:  259:
        -:  260://===----------------------------------------------------------------------===//
        -:  261:// ForeachOp
        -:  262://===----------------------------------------------------------------------===//
        -:  263:
        -:  264:DiagnosedSilenceableFailure
function _ZN4mlir9transform6CastOp10applyToOneEPNS_9OperationERN4llvm15SmallVectorImplIS3_EERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  265:transform::CastOp::applyToOne(Operation *target,
        -:  266:                              SmallVectorImpl<Operation *> &results,
        -:  267:                              transform::TransformState &state) {
    #####:  268:  results.push_back(target);
call    0 never executed
    #####:  269:  return DiagnosedSilenceableFailure::success();
        -:  270:}
        -:  271:
function _ZN4mlir9transform6CastOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  272:void transform::CastOp::getEffects(
        -:  273:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  274:  onlyReadsPayload(effects);
call    0 never executed
    #####:  275:  consumesHandle(getInput(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  276:  producesHandle(getOutput(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  277:}
        -:  278:
function _ZN4mlir9transform6CastOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####:  279:bool transform::CastOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####:  280:  assert(inputs.size() == 1 && "expected one input");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  281:  assert(outputs.size() == 1 && "expected one output");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  282:  return llvm::all_of(
call    0 never executed
    #####:  283:      std::initializer_list<Type>{inputs.front(), outputs.front()},
call    0 never executed
call    1 never executed
        -:  284:      [](Type ty) {
        -:  285:        return ty.isa<pdl::OperationType, transform::TransformTypeInterface>();
    #####:  286:      });
        -:  287:}
        -:  288:
        -:  289://===----------------------------------------------------------------------===//
        -:  290:// ForeachOp
        -:  291://===----------------------------------------------------------------------===//
        -:  292:
        -:  293:DiagnosedSilenceableFailure
function _ZN4mlir9transform9ForeachOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  294:transform::ForeachOp::apply(transform::TransformResults &results,
        -:  295:                            transform::TransformState &state) {
    #####:  296:  ArrayRef<Operation *> payloadOps = state.getPayloadOps(getTarget());
call    0 never executed
call    1 never executed
    #####:  297:  SmallVector<SmallVector<Operation *>> resultOps(getNumResults(), {});
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  298:
    #####:  299:  for (Operation *op : payloadOps) {
branch  0 never executed
branch  1 never executed
    #####:  300:    auto scope = state.make_region_scope(getBody());
call    0 never executed
call    1 never executed
    #####:  301:    if (failed(state.mapBlockArguments(getIterationVariable(), {op})))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  302:      return DiagnosedSilenceableFailure::definiteFailure();
        -:  303:
        -:  304:    // Execute loop body.
    #####:  305:    for (Operation &transform : getBody().front().without_terminator()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  306:      DiagnosedSilenceableFailure result = state.applyTransform(
    #####:  307:          cast<transform::TransformOpInterface>(transform));
call    0 never executed
call    1 never executed
    #####:  308:      if (!result.succeeded())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  309:        return result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  310:    }
        -:  311:
        -:  312:    // Append yielded payload ops to result list (if any).
    #####:  313:    for (unsigned i = 0; i < getNumResults(); ++i) {
branch  0 never executed
branch  1 never executed
    #####:  314:      ArrayRef<Operation *> yieldedOps =
    #####:  315:          state.getPayloadOps(getYieldOp().getOperand(i));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  316:      resultOps[i].append(yieldedOps.begin(), yieldedOps.end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  317:    }
        -:  318:  }
        -:  319:
    #####:  320:  for (unsigned i = 0; i < getNumResults(); ++i)
branch  0 never executed
branch  1 never executed
    #####:  321:    results.set(getResult(i).cast<OpResult>(), resultOps[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  322:
    #####:  323:  return DiagnosedSilenceableFailure::success();
        -:  324:}
        -:  325:
function _ZN4mlir9transform9ForeachOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  326:void transform::ForeachOp::getEffects(
        -:  327:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  328:  BlockArgument iterVar = getIterationVariable();
call    0 never executed
    #####:  329:  if (any_of(getBody().front().without_terminator(), [&](Operation &op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  330:        return isHandleConsumed(iterVar, cast<TransformOpInterface>(&op));
call    0 never executed
call    1 never executed
        -:  331:      })) {
    #####:  332:    consumesHandle(getTarget(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  333:  } else {
    #####:  334:    onlyReadsHandle(getTarget(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  335:  }
        -:  336:
    #####:  337:  for (Value result : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  338:    producesHandle(result, effects);
call    0 never executed
call    1 never executed
    #####:  339:}
        -:  340:
function _ZN4mlir9transform9ForeachOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####:  341:void transform::ForeachOp::getSuccessorRegions(
        -:  342:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -:  343:    SmallVectorImpl<RegionSuccessor> &regions) {
    #####:  344:  Region *bodyRegion = &getBody();
call    0 never executed
    #####:  345:  if (!index) {
branch  0 never executed
branch  1 never executed
    #####:  346:    regions.emplace_back(bodyRegion, bodyRegion->getArguments());
call    0 never executed
call    1 never executed
    #####:  347:    return;
        -:  348:  }
        -:  349:
        -:  350:  // Branch back to the region or the parent.
    #####:  351:  assert(*index == 0 && "unexpected region index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  352:  regions.emplace_back(bodyRegion, bodyRegion->getArguments());
call    0 never executed
call    1 never executed
    #####:  353:  regions.emplace_back();
call    0 never executed
        -:  354:}
        -:  355:
        -:  356:OperandRange
function _ZN4mlir9transform9ForeachOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 0 returned 0% blocks executed 0%
    #####:  357:transform::ForeachOp::getSuccessorEntryOperands(Optional<unsigned> index) {
        -:  358:  // The iteration variable op handle is mapped to a subset (one op to be
        -:  359:  // precise) of the payload ops of the ForeachOp operand.
    #####:  360:  assert(index && *index == 0 && "unexpected region index");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  361:  return getOperation()->getOperands();
call    0 never executed
        -:  362:}
        -:  363:
function _ZN4mlir9transform9ForeachOp10getYieldOpEv called 0 returned 0% blocks executed 0%
    #####:  364:transform::YieldOp transform::ForeachOp::getYieldOp() {
    #####:  365:  return cast<transform::YieldOp>(getBody().front().getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  366:}
        -:  367:
function _ZN4mlir9transform9ForeachOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  368:LogicalResult transform::ForeachOp::verify() {
    #####:  369:  auto yieldOp = getYieldOp();
call    0 never executed
    #####:  370:  if (getNumResults() != yieldOp.getNumOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:    return emitOpError() << "expects the same number of results as the "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  372:                            "terminator has operands";
call    0 never executed
    #####:  373:  for (Value v : yieldOp.getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  374:    if (!v.getType().isa<TransformTypeInterface>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  375:      return yieldOp->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  376:          "expects operands to have types implementing TransformTypeInterface");
call    0 never executed
    #####:  377:  return success();
        -:  378:}
        -:  379:
        -:  380://===----------------------------------------------------------------------===//
        -:  381:// GetClosestIsolatedParentOp
        -:  382://===----------------------------------------------------------------------===//
        -:  383:
function _ZN4mlir9transform26GetClosestIsolatedParentOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  384:DiagnosedSilenceableFailure transform::GetClosestIsolatedParentOp::apply(
        -:  385:    transform::TransformResults &results, transform::TransformState &state) {
    #####:  386:  SetVector<Operation *> parents;
call    0 never executed
call    1 never executed
    #####:  387:  for (Operation *target : state.getPayloadOps(getTarget())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  388:    Operation *parent =
    #####:  389:        target->getParentWithTrait<OpTrait::IsIsolatedFromAbove>();
call    0 never executed
    #####:  390:    if (!parent) {
branch  0 never executed
branch  1 never executed
    #####:  391:      DiagnosedSilenceableFailure diag =
    #####:  392:          emitSilenceableError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  393:          << "could not find an isolated-from-above parent op";
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  394:      diag.attachNote(target->getLoc()) << "target op";
call    0 never executed
call    1 never executed
    #####:  395:      return diag;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  396:    }
    #####:  397:    parents.insert(parent);
call    0 never executed
        -:  398:  }
    #####:  399:  results.set(getResult().cast<OpResult>(), parents.getArrayRef());
call    0 never executed
call    1 never executed
    #####:  400:  return DiagnosedSilenceableFailure::success();
        -:  401:}
        -:  402:
        -:  403://===----------------------------------------------------------------------===//
        -:  404:// GetProducerOfOperand
        -:  405://===----------------------------------------------------------------------===//
        -:  406:
        -:  407:DiagnosedSilenceableFailure
function _ZN4mlir9transform20GetProducerOfOperand5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  408:transform::GetProducerOfOperand::apply(transform::TransformResults &results,
        -:  409:                                       transform::TransformState &state) {
    #####:  410:  int64_t operandNumber = getOperandNumber();
call    0 never executed
    #####:  411:  SmallVector<Operation *> producers;
call    0 never executed
    #####:  412:  for (Operation *target : state.getPayloadOps(getTarget())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  413:    Operation *producer =
branch  0 never executed
branch  1 never executed
    #####:  414:        target->getNumOperands() <= operandNumber
    #####:  415:            ? nullptr
branch  0 never executed
branch  1 never executed
    #####:  416:            : target->getOperand(operandNumber).getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  417:    if (!producer) {
branch  0 never executed
branch  1 never executed
    #####:  418:      DiagnosedSilenceableFailure diag =
    #####:  419:          emitSilenceableError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  420:          << "could not find a producer for operand number: " << operandNumber
call    0 never executed
call    1 never executed
    #####:  421:          << " of " << *target;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  422:      diag.attachNote(target->getLoc()) << "target op";
call    0 never executed
call    1 never executed
    #####:  423:      results.set(getResult().cast<OpResult>(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  424:                  SmallVector<mlir::Operation *>{});
call    0 never executed
    #####:  425:      return diag;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  426:    }
    #####:  427:    producers.push_back(producer);
call    0 never executed
        -:  428:  }
    #####:  429:  results.set(getResult().cast<OpResult>(), producers);
call    0 never executed
call    1 never executed
    #####:  430:  return DiagnosedSilenceableFailure::success();
        -:  431:}
        -:  432:
        -:  433://===----------------------------------------------------------------------===//
        -:  434:// MergeHandlesOp
        -:  435://===----------------------------------------------------------------------===//
        -:  436:
        -:  437:DiagnosedSilenceableFailure
function _ZN4mlir9transform14MergeHandlesOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  438:transform::MergeHandlesOp::apply(transform::TransformResults &results,
        -:  439:                                 transform::TransformState &state) {
    #####:  440:  SmallVector<Operation *> operations;
call    0 never executed
    #####:  441:  for (Value operand : getHandles())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  442:    llvm::append_range(operations, state.getPayloadOps(operand));
call    0 never executed
call    1 never executed
    #####:  443:  if (!getDeduplicate()) {
call    0 never executed
    #####:  444:    results.set(getResult().cast<OpResult>(), operations);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  445:    return DiagnosedSilenceableFailure::success();
        -:  446:  }
        -:  447:
    #####:  448:  SetVector<Operation *> uniqued(operations.begin(), operations.end());
call    0 never executed
call    1 never executed
    #####:  449:  results.set(getResult().cast<OpResult>(), uniqued.getArrayRef());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  450:  return DiagnosedSilenceableFailure::success();
call    0 never executed
        -:  451:}
        -:  452:
function _ZN4mlir9transform14MergeHandlesOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  453:void transform::MergeHandlesOp::getEffects(
        -:  454:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  455:  consumesHandle(getHandles(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  456:  producesHandle(getResult(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  457:
        -:  458:  // There are no effects on the Payload IR as this is only a handle
        -:  459:  // manipulation.
    #####:  460:}
        -:  461:
function _ZN4mlir9transform14MergeHandlesOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  462:OpFoldResult transform::MergeHandlesOp::fold(ArrayRef<Attribute> operands) {
    #####:  463:  if (getDeduplicate() || getHandles().size() != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  464:    return {};
        -:  465:
        -:  466:  // If deduplication is not required and there is only one operand, it can be
        -:  467:  // used directly instead of merging.
    #####:  468:  return getHandles().front();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  469:}
        -:  470:
        -:  471://===----------------------------------------------------------------------===//
        -:  472:// SplitHandlesOp
        -:  473://===----------------------------------------------------------------------===//
        -:  474:
        -:  475:DiagnosedSilenceableFailure
function _ZN4mlir9transform14SplitHandlesOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  476:transform::SplitHandlesOp::apply(transform::TransformResults &results,
        -:  477:                                 transform::TransformState &state) {
    #####:  478:  int64_t numResultHandles =
    #####:  479:      getHandle() ? state.getPayloadOps(getHandle()).size() : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  480:  int64_t expectedNumResultHandles = getNumResultHandles();
call    0 never executed
    #####:  481:  if (numResultHandles != expectedNumResultHandles) {
branch  0 never executed
branch  1 never executed
        -:  482:    // Failing case needs to propagate gracefully for both suppress and
        -:  483:    // propagate modes.
    #####:  484:    for (int64_t idx = 0; idx < expectedNumResultHandles; ++idx)
branch  0 never executed
branch  1 never executed
    #####:  485:      results.set(getResults()[idx].cast<OpResult>(), {});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  486:    // Empty input handle corner case: always propagates empty handles in both
        -:  487:    // suppress and propagate modes.
    #####:  488:    if (numResultHandles == 0)
branch  0 never executed
branch  1 never executed
    #####:  489:      return DiagnosedSilenceableFailure::success();
        -:  490:    // If the input handle was not empty and the number of result handles does
        -:  491:    // not match, this is a legit silenceable error.
    #####:  492:    return emitSilenceableError()
call    0 never executed
call    1 never executed
    #####:  493:           << getHandle() << " expected to contain " << expectedNumResultHandles
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  494:           << " operation handles but it only contains " << numResultHandles
call    0 never executed
call    1 never executed
    #####:  495:           << " handles";
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  496:  }
        -:  497:  // Normal successful case.
    #####:  498:  for (const auto &en : llvm::enumerate(state.getPayloadOps(getHandle())))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  499:    results.set(getResults()[en.index()].cast<OpResult>(), en.value());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  500:  return DiagnosedSilenceableFailure::success();
        -:  501:}
        -:  502:
function _ZN4mlir9transform14SplitHandlesOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  503:void transform::SplitHandlesOp::getEffects(
        -:  504:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  505:  consumesHandle(getHandle(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  506:  producesHandle(getResults(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  507:  // There are no effects on the Payload IR as this is only a handle
        -:  508:  // manipulation.
    #####:  509:}
        -:  510:
        -:  511://===----------------------------------------------------------------------===//
        -:  512:// PDLMatchOp
        -:  513://===----------------------------------------------------------------------===//
        -:  514:
        -:  515:DiagnosedSilenceableFailure
function _ZN4mlir9transform10PDLMatchOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  516:transform::PDLMatchOp::apply(transform::TransformResults &results,
        -:  517:                             transform::TransformState &state) {
    #####:  518:  auto *extension = state.getExtension<PatternApplicatorExtension>();
call    0 never executed
    #####:  519:  assert(extension &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  520:         "expected PatternApplicatorExtension to be attached by the parent op");
    #####:  521:  SmallVector<Operation *> targets;
call    0 never executed
    #####:  522:  for (Operation *root : state.getPayloadOps(getRoot())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  523:    if (failed(extension->findAllMatches(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  524:            getPatternName().getLeafReference().getValue(), root, targets))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  525:      emitDefiniteFailure()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  526:          << "could not find pattern '" << getPatternName() << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  527:    }
        -:  528:  }
    #####:  529:  results.set(getResult().cast<OpResult>(), targets);
call    0 never executed
call    1 never executed
    #####:  530:  return DiagnosedSilenceableFailure::success();
branch  0 never executed
branch  1 never executed
        -:  531:}
        -:  532:
function _ZN4mlir9transform10PDLMatchOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  533:void transform::PDLMatchOp::getEffects(
        -:  534:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  535:  onlyReadsHandle(getRoot(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  536:  producesHandle(getMatched(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  537:  onlyReadsPayload(effects);
call    0 never executed
    #####:  538:}
        -:  539:
        -:  540://===----------------------------------------------------------------------===//
        -:  541:// ReplicateOp
        -:  542://===----------------------------------------------------------------------===//
        -:  543:
        -:  544:DiagnosedSilenceableFailure
function _ZN4mlir9transform11ReplicateOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  545:transform::ReplicateOp::apply(transform::TransformResults &results,
        -:  546:                              transform::TransformState &state) {
    #####:  547:  unsigned numRepetitions = state.getPayloadOps(getPattern()).size();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  548:  for (const auto &en : llvm::enumerate(getHandles())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  549:    Value handle = en.value();
call    0 never executed
    #####:  550:    ArrayRef<Operation *> current = state.getPayloadOps(handle);
call    0 never executed
    #####:  551:    SmallVector<Operation *> payload;
branch  0 never executed
branch  1 never executed
    #####:  552:    payload.reserve(numRepetitions * current.size());
branch  0 never executed
branch  1 never executed
    #####:  553:    for (unsigned i = 0; i < numRepetitions; ++i)
branch  0 never executed
branch  1 never executed
    #####:  554:      llvm::append_range(payload, current);
call    0 never executed
    #####:  555:    results.set(getReplicated()[en.index()].cast<OpResult>(), payload);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  556:  }
    #####:  557:  return DiagnosedSilenceableFailure::success();
        -:  558:}
        -:  559:
function _ZN4mlir9transform11ReplicateOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  560:void transform::ReplicateOp::getEffects(
        -:  561:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  562:  onlyReadsHandle(getPattern(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  563:  consumesHandle(getHandles(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  564:  producesHandle(getReplicated(), effects);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  565:}
        -:  566:
        -:  567://===----------------------------------------------------------------------===//
        -:  568:// SequenceOp
        -:  569://===----------------------------------------------------------------------===//
        -:  570:
        -:  571:DiagnosedSilenceableFailure
function _ZN4mlir9transform10SequenceOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  572:transform::SequenceOp::apply(transform::TransformResults &results,
        -:  573:                             transform::TransformState &state) {
        -:  574:  // Map the entry block argument to the list of operations.
    #####:  575:  auto scope = state.make_region_scope(*getBodyBlock()->getParent());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  576:  if (failed(mapBlockArguments(state)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  577:    return DiagnosedSilenceableFailure::definiteFailure();
        -:  578:
        -:  579:  // Apply the sequenced ops one by one.
    #####:  580:  for (Operation &transform : getBodyBlock()->without_terminator()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  581:    DiagnosedSilenceableFailure result =
    #####:  582:        state.applyTransform(cast<TransformOpInterface>(transform));
call    0 never executed
call    1 never executed
    #####:  583:    if (result.isDefiniteFailure())
branch  0 never executed
branch  1 never executed
    #####:  584:      return result;
        -:  585:
    #####:  586:    if (result.isSilenceableFailure()) {
branch  0 never executed
branch  1 never executed
    #####:  587:      if (getFailurePropagationMode() == FailurePropagationMode::Propagate)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  588:        return result;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  589:      (void)result.silence();
call    0 never executed
        -:  590:    }
        -:  591:  }
        -:  592:
        -:  593:  // Forward the operation mapping for values yielded from the sequence to the
        -:  594:  // values produced by the sequence op.
    #####:  595:  forwardTerminatorOperands(getBodyBlock(), state, results);
call    0 never executed
call    1 never executed
    #####:  596:  return DiagnosedSilenceableFailure::success();
        -:  597:}
        -:  598:
        -:  599:/// Returns `true` if the given op operand may be consuming the handle value in
        -:  600:/// the Transform IR. That is, if it may have a Free effect on it.
function _ZL27isValueUsePotentialConsumerRN4mlir9OpOperandE called 0 returned 0% blocks executed 0%
    #####:  601:static bool isValueUsePotentialConsumer(OpOperand &use) {
        -:  602:  // Conservatively assume the effect being present in absence of the interface.
    #####:  603:  auto iface = dyn_cast<transform::TransformOpInterface>(use.getOwner());
call    0 never executed
    #####:  604:  if (!iface)
branch  0 never executed
branch  1 never executed
        -:  605:    return true;
        -:  606:
    #####:  607:  return isHandleConsumed(use.get(), iface);
call    0 never executed
        -:  608:}
        -:  609:
        -:  610:LogicalResult
function _Z18checkDoubleConsumeN4mlir5ValueEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEE called 0 returned 0% blocks executed 0%
    #####:  611:checkDoubleConsume(Value value,
        -:  612:                   function_ref<InFlightDiagnostic()> reportError) {
    #####:  613:  OpOperand *potentialConsumer = nullptr;
    #####:  614:  for (OpOperand &use : value.getUses()) {
branch  0 never executed
branch  1 never executed
    #####:  615:    if (!isValueUsePotentialConsumer(use))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  616:      continue;
        -:  617:
    #####:  618:    if (!potentialConsumer) {
branch  0 never executed
branch  1 never executed
    #####:  619:      potentialConsumer = &use;
    #####:  620:      continue;
        -:  621:    }
        -:  622:
    #####:  623:    InFlightDiagnostic diag = reportError()
call    0 never executed
call    1 never executed
    #####:  624:                              << " has more than one potential consumer";
call    0 never executed
call    1 never executed
    #####:  625:    diag.attachNote(potentialConsumer->getOwner()->getLoc())
call    0 never executed
    #####:  626:        << "used here as operand #" << potentialConsumer->getOperandNumber();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  627:    diag.attachNote(use.getOwner()->getLoc())
call    0 never executed
    #####:  628:        << "used here as operand #" << use.getOperandNumber();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  629:    return diag;
call    0 never executed
        -:  630:  }
        -:  631:
    #####:  632:  return success();
        -:  633:}
        -:  634:
function _ZN4mlir9transform10SequenceOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  635:LogicalResult transform::SequenceOp::verify() {
        -:  636:  // Check if the block argument has more than one consuming use.
    #####:  637:  for (BlockArgument argument : getBodyBlock()->getArguments()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZN4mlir9transform10SequenceOp6verifyEvENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  638:    auto report = [&]() {
    #####:  639:      return (emitOpError() << "block argument #" << argument.getArgNumber());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  640:    };
    #####:  641:    if (failed(checkDoubleConsume(argument, report)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  642:      return failure();
        -:  643:  }
        -:  644:
        -:  645:  // Check properties of the nested operations they cannot check themselves.
    #####:  646:  for (Operation &child : *getBodyBlock()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  647:    if (!isa<TransformOpInterface>(child) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  648:        &child != &getBodyBlock()->back()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  649:      InFlightDiagnostic diag =
    #####:  650:          emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  651:          << "expected children ops to implement TransformOpInterface";
call    0 never executed
call    1 never executed
    #####:  652:      diag.attachNote(child.getLoc()) << "op without interface";
call    0 never executed
call    1 never executed
    #####:  653:      return diag;
call    0 never executed
        -:  654:    }
        -:  655:
    #####:  656:    for (OpResult result : child.getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
function _ZZN4mlir9transform10SequenceOp6verifyEvENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  657:      auto report = [&]() {
    #####:  658:        return (child.emitError() << "result #" << result.getResultNumber());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  659:      };
    #####:  660:      if (failed(checkDoubleConsume(result, report)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  661:        return failure();
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  if (getBodyBlock()->getTerminator()->getOperandTypes() !=
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  666:      getOperation()->getResultTypes()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  667:    InFlightDiagnostic diag = emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
        -:  668:                              << "expects the types of the terminator operands "
    #####:  669:                                 "to match the types of the result";
call    0 never executed
call    1 never executed
    #####:  670:    diag.attachNote(getBodyBlock()->getTerminator()->getLoc()) << "terminator";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  671:    return diag;
call    0 never executed
        -:  672:  }
    #####:  673:  return success();
        -:  674:}
        -:  675:
function _ZN4mlir9transform10SequenceOp10getEffectsERN4llvm15SmallVectorImplINS_11SideEffects14EffectInstanceINS_13MemoryEffects6EffectEEEEE called 0 returned 0% blocks executed 0%
    #####:  676:void transform::SequenceOp::getEffects(
        -:  677:    SmallVectorImpl<MemoryEffects::EffectInstance> &effects) {
    #####:  678:  auto *mappingResource = TransformMappingResource::get();
call    0 never executed
    #####:  679:  effects.emplace_back(MemoryEffects::Read::get(), getRoot(), mappingResource);
call    0 never executed
call    1 never executed
        -:  680:
    #####:  681:  for (Value result : getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  682:    effects.emplace_back(MemoryEffects::Allocate::get(), result,
call    0 never executed
    #####:  683:                         mappingResource);
call    0 never executed
    #####:  684:    effects.emplace_back(MemoryEffects::Write::get(), result, mappingResource);
call    0 never executed
call    1 never executed
        -:  685:  }
        -:  686:
    #####:  687:  if (!getRoot()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  688:    for (Operation &op : *getBodyBlock()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  689:      auto iface = dyn_cast<MemoryEffectOpInterface>(&op);
call    0 never executed
    #####:  690:      if (!iface) {
branch  0 never executed
branch  1 never executed
        -:  691:        // TODO: fill all possible effects; or require ops to actually implement
        -:  692:        // the memory effect interface always
    #####:  693:        assert(false);
call    0 never executed
        -:  694:      }
        -:  695:
    #####:  696:      SmallVector<MemoryEffects::EffectInstance, 2> nestedEffects;
call    0 never executed
    #####:  697:      iface.getEffects(effects);
call    0 never executed
        -:  698:    }
    #####:  699:    return;
        -:  700:  }
        -:  701:
        -:  702:  // Carry over all effects on the argument of the entry block as those on the
        -:  703:  // operand, this is the same value just remapped.
    #####:  704:  for (Operation &op : *getBodyBlock()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  705:    auto iface = dyn_cast<MemoryEffectOpInterface>(&op);
call    0 never executed
    #####:  706:    if (!iface) {
branch  0 never executed
branch  1 never executed
        -:  707:      // TODO: fill all possible effects; or require ops to actually implement
        -:  708:      // the memory effect interface always
    #####:  709:      assert(false);
call    0 never executed
        -:  710:    }
        -:  711:
    #####:  712:    SmallVector<MemoryEffects::EffectInstance, 2> nestedEffects;
call    0 never executed
    #####:  713:    iface.getEffectsOnValue(getBodyBlock()->getArgument(0), nestedEffects);
call    0 never executed
call    1 never executed
    #####:  714:    for (const auto &effect : nestedEffects)
branch  0 never executed
branch  1 never executed
    #####:  715:      effects.emplace_back(effect.getEffect(), getRoot(), effect.getResource());
call    0 never executed
call    1 never executed
        -:  716:  }
        -:  717:}
        -:  718:
        -:  719:OperandRange
function _ZN4mlir9transform10SequenceOp25getSuccessorEntryOperandsEN4llvm8OptionalIjEE called 0 returned 0% blocks executed 0%
    #####:  720:transform::SequenceOp::getSuccessorEntryOperands(Optional<unsigned> index) {
    #####:  721:  assert(index && *index == 0 && "unexpected region index");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  722:  if (getOperation()->getNumOperands() == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  723:    return getOperation()->getOperands();
call    0 never executed
    #####:  724:  return OperandRange(getOperation()->operand_end(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  725:                      getOperation()->operand_end());
        -:  726:}
        -:  727:
function _ZN4mlir9transform10SequenceOp19getSuccessorRegionsEN4llvm8OptionalIjEENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_15RegionSuccessorEEE called 0 returned 0% blocks executed 0%
    #####:  728:void transform::SequenceOp::getSuccessorRegions(
        -:  729:    Optional<unsigned> index, ArrayRef<Attribute> operands,
        -:  730:    SmallVectorImpl<RegionSuccessor> &regions) {
    #####:  731:  if (!index) {
branch  0 never executed
branch  1 never executed
    #####:  732:    Region *bodyRegion = &getBody();
call    0 never executed
    #####:  733:    regions.emplace_back(bodyRegion, !operands.empty()
branch  0 never executed
branch  1 never executed
    #####:  734:                                         ? bodyRegion->getArguments()
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  735:                                         : Block::BlockArgListType());
call    0 never executed
    #####:  736:    return;
        -:  737:  }
        -:  738:
    #####:  739:  assert(*index == 0 && "unexpected region index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  740:  regions.emplace_back(getOperation()->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  741:}
        -:  742:
function _ZN4mlir9transform10SequenceOp25getRegionInvocationBoundsEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_16InvocationBoundsEEE called 0 returned 0% blocks executed 0%
    #####:  743:void transform::SequenceOp::getRegionInvocationBounds(
        -:  744:    ArrayRef<Attribute> operands, SmallVectorImpl<InvocationBounds> &bounds) {
    #####:  745:  (void)operands;
    #####:  746:  bounds.emplace_back(1, 1);
call    0 never executed
    #####:  747:}
        -:  748:
        -:  749://===----------------------------------------------------------------------===//
        -:  750:// WithPDLPatternsOp
        -:  751://===----------------------------------------------------------------------===//
        -:  752:
        -:  753:DiagnosedSilenceableFailure
function _ZN4mlir9transform17WithPDLPatternsOp5applyERNS0_16TransformResultsERNS0_14TransformStateE called 0 returned 0% blocks executed 0%
    #####:  754:transform::WithPDLPatternsOp::apply(transform::TransformResults &results,
        -:  755:                                    transform::TransformState &state) {
    #####:  756:  OwningOpRef<ModuleOp> pdlModuleOp =
call    0 never executed
    #####:  757:      ModuleOp::create(getOperation()->getLoc());
call    0 never executed
call    1 never executed
    #####:  758:  TransformOpInterface transformOp = nullptr;
call    0 never executed
    #####:  759:  for (Operation &nested : getBody().front()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  760:    if (!isa<pdl::PatternOp>(nested)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  761:      transformOp = cast<TransformOpInterface>(nested);
    #####:  762:      break;
call    0 never executed
        -:  763:    }
        -:  764:  }
        -:  765:
    #####:  766:  state.addExtension<PatternApplicatorExtension>(getOperation());
call    0 never executed
    #####:  767:  auto guard = llvm::make_scope_exit(
    #####:  768:      [&]() { state.removeExtension<PatternApplicatorExtension>(); });
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  769:
    #####:  770:  auto scope = state.make_region_scope(getBody());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  771:  if (failed(mapBlockArguments(state)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  772:    return DiagnosedSilenceableFailure::definiteFailure();
    #####:  773:  return state.applyTransform(transformOp);
call    0 never executed
        -:  774:}
        -:  775:
function _ZN4mlir9transform17WithPDLPatternsOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  776:LogicalResult transform::WithPDLPatternsOp::verify() {
    #####:  777:  Block *body = getBodyBlock();
call    0 never executed
    #####:  778:  Operation *topLevelOp = nullptr;
    #####:  779:  for (Operation &op : body->getOperations()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  780:    if (isa<pdl::PatternOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  781:      continue;
        -:  782:
    #####:  783:    if (op.hasTrait<::mlir::transform::PossibleTopLevelTransformOpTrait>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  784:      if (topLevelOp) {
branch  0 never executed
branch  1 never executed
    #####:  785:        InFlightDiagnostic diag =
    #####:  786:            emitOpError() << "expects only one non-pattern op in its body";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  787:        diag.attachNote(topLevelOp->getLoc()) << "first non-pattern op";
call    0 never executed
call    1 never executed
    #####:  788:        diag.attachNote(op.getLoc()) << "second non-pattern op";
call    0 never executed
call    1 never executed
    #####:  789:        return diag;
call    0 never executed
        -:  790:      }
    #####:  791:      topLevelOp = &op;
    #####:  792:      continue;
        -:  793:    }
        -:  794:
    #####:  795:    InFlightDiagnostic diag =
    #####:  796:        emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  797:        << "expects only pattern and top-level transform ops in its body";
call    0 never executed
call    1 never executed
    #####:  798:    diag.attachNote(op.getLoc()) << "offending op";
call    0 never executed
call    1 never executed
    #####:  799:    return diag;
call    0 never executed
        -:  800:  }
        -:  801:
    #####:  802:  if (auto parent = getOperation()->getParentOfType<WithPDLPatternsOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  803:    InFlightDiagnostic diag = emitOpError() << "cannot be nested";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  804:    diag.attachNote(parent.getLoc()) << "parent operation";
call    0 never executed
call    1 never executed
    #####:  805:    return diag;
call    0 never executed
        -:  806:  }
        -:  807:
    #####:  808:  return success();
        -:  809:}
