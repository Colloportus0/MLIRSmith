        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Arith/IR/ArithOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcda
        -:    0:Runs:325545
        -:    1://===- ArithOps.cpp - MLIR Arith dialect ops implementation -----===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include <cassert>
        -:   10:#include <utility>
        -:   11:
        -:   12:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   13:#include "mlir/Dialect/CommonFolders.h"
        -:   14:#include "mlir/IR/Builders.h"
        -:   15:#include "mlir/IR/Matchers.h"
        -:   16:#include "mlir/IR/OpImplementation.h"
        -:   17:#include "mlir/IR/PatternMatch.h"
        -:   18:#include "mlir/IR/TypeUtilities.h"
        -:   19:
        -:   20:#include "llvm/ADT/APSInt.h"
        -:   21:#include "llvm/ADT/SmallString.h"
        -:   22:
        -:   23:using namespace mlir;
        -:   24:using namespace mlir::arith;
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// Floating point op parse/print helpers
        -:   28://===----------------------------------------------------------------------===//
function _ZL22parseArithFastMathAttrRN4mlir11OpAsmParserERNS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:   29:static ParseResult parseArithFastMathAttr(OpAsmParser &parser,
        -:   30:                                          Attribute &attr) {
    #####:   31:  if (succeeded(
    #####:   32:          parser.parseOptionalKeyword(FastMathFlagsAttr::getMnemonic()))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   33:    attr = FastMathFlagsAttr::parse(parser, Type{});
call    0 never executed
    #####:   34:    return success(static_cast<bool>(attr));
        -:   35:  } else {
        -:   36:    // No fastmath attribute mnemonic present - defer attribute creation and use
        -:   37:    // the default value.
    #####:   38:    return success();
        -:   39:  }
        -:   40:}
        -:   41:
        -:   42:static void printArithFastMathAttr(OpAsmPrinter &printer, Operation *op,
        -:   43:                                   FastMathFlagsAttr fmAttr) {
        -:   44:  // Elide printing the fastmath attribute when fastmath=none
        -:   45:  if (fmAttr && (fmAttr.getValue() != FastMathFlags::none)) {
        -:   46:    printer << " " << FastMathFlagsAttr::getMnemonic();
        -:   47:    fmAttr.print(printer);
        -:   48:  }
        -:   49:}
        -:   50:
        -:   51://===----------------------------------------------------------------------===//
        -:   52:// Pattern helpers
        -:   53://===----------------------------------------------------------------------===//
        -:   54:
function _ZL15addIntegerAttrsRN4mlir15PatternRewriterENS_5ValueENS_9AttributeES3_ called 0 returned 0% blocks executed 0%
    #####:   55:static IntegerAttr addIntegerAttrs(PatternRewriter &builder, Value res,
        -:   56:                                   Attribute lhs, Attribute rhs) {
    #####:   57:  return builder.getIntegerAttr(res.getType(),
    #####:   58:                                lhs.cast<IntegerAttr>().getInt() +
call    0 never executed
call    1 never executed
    #####:   59:                                    rhs.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   60:}
        -:   61:
function _ZL15subIntegerAttrsRN4mlir15PatternRewriterENS_5ValueENS_9AttributeES3_ called 0 returned 0% blocks executed 0%
    #####:   62:static IntegerAttr subIntegerAttrs(PatternRewriter &builder, Value res,
        -:   63:                                   Attribute lhs, Attribute rhs) {
    #####:   64:  return builder.getIntegerAttr(res.getType(),
    #####:   65:                                lhs.cast<IntegerAttr>().getInt() -
call    0 never executed
call    1 never executed
    #####:   66:                                    rhs.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   67:}
        -:   68:
        -:   69:/// Invert an integer comparison predicate.
function _ZN4mlir5arith15invertPredicateENS0_13CmpIPredicateE called 0 returned 0% blocks executed 0%
    #####:   70:arith::CmpIPredicate arith::invertPredicate(arith::CmpIPredicate pred) {
    #####:   71:  switch (pred) {
branch  0 never executed
branch  1 never executed
        -:   72:  case arith::CmpIPredicate::eq:
        -:   73:    return arith::CmpIPredicate::ne;
        -:   74:  case arith::CmpIPredicate::ne:
        -:   75:    return arith::CmpIPredicate::eq;
        -:   76:  case arith::CmpIPredicate::slt:
        -:   77:    return arith::CmpIPredicate::sge;
        -:   78:  case arith::CmpIPredicate::sle:
        -:   79:    return arith::CmpIPredicate::sgt;
        -:   80:  case arith::CmpIPredicate::sgt:
        -:   81:    return arith::CmpIPredicate::sle;
        -:   82:  case arith::CmpIPredicate::sge:
        -:   83:    return arith::CmpIPredicate::slt;
        -:   84:  case arith::CmpIPredicate::ult:
        -:   85:    return arith::CmpIPredicate::uge;
        -:   86:  case arith::CmpIPredicate::ule:
        -:   87:    return arith::CmpIPredicate::ugt;
        -:   88:  case arith::CmpIPredicate::ugt:
        -:   89:    return arith::CmpIPredicate::ule;
        -:   90:  case arith::CmpIPredicate::uge:
        -:   91:    return arith::CmpIPredicate::ult;
        -:   92:  }
    #####:   93:  llvm_unreachable("unknown cmpi predicate kind");
        -:   94:}
        -:   95:
function _ZL15invertPredicateN4mlir5arith17CmpIPredicateAttrE called 0 returned 0% blocks executed 0%
    #####:   96:static arith::CmpIPredicateAttr invertPredicate(arith::CmpIPredicateAttr pred) {
    #####:   97:  return arith::CmpIPredicateAttr::get(pred.getContext(),
call    0 never executed
    #####:   98:                                       invertPredicate(pred.getValue()));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:   99:}
        -:  100:
        -:  101://===----------------------------------------------------------------------===//
        -:  102:// TableGen'd canonicalization patterns
        -:  103://===----------------------------------------------------------------------===//
        -:  104:
        -:  105:namespace {
        -:  106:#include "ArithCanonicalization.inc"
        -:  107:} // namespace
        -:  108:
        -:  109://===----------------------------------------------------------------------===//
        -:  110:// ConstantOp
        -:  111://===----------------------------------------------------------------------===//
        -:  112:
function _ZN4mlir5arith10ConstantOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 6752 returned 100% blocks executed 56%
     6752:  113:void arith::ConstantOp::getAsmResultNames(
        -:  114:    function_ref<void(Value, StringRef)> setNameFn) {
     6752:  115:  auto type = getType();
call    0 returned 100%
     6752:  116:  if (auto intCst = getValue().dyn_cast<IntegerAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 40% (fallthrough)
branch  3 taken 60%
     2679:  117:    auto intType = type.dyn_cast<IntegerType>();
call    0 returned 100%
        -:  118:
        -:  119:    // Sugar i1 constants with 'true' and 'false'.
    2679*:  120:    if (intType && intType.getWidth() == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  121:      return setNameFn(getResult(), (intCst.getInt() ? "true" : "false"));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  122:
        -:  123:    // Otherwise, build a complex name with the value and type.
     5358:  124:    SmallString<32> specialNameBuffer;
call    0 returned 100%
     5358:  125:    llvm::raw_svector_ostream specialName(specialNameBuffer);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     5358:  126:    specialName << 'c' << intCst.getValue();
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     2679:  127:    if (intType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  128:      specialName << '_' << type;
branch  0 never executed
branch  1 never executed
call    2 never executed
     2679:  129:    setNameFn(getResult(), specialName.str());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  130:  } else {
     4073:  131:    setNameFn(getResult(), "cst");
call    0 returned 100%
call    1 returned 100%
        -:  132:  }
        -:  133:}
        -:  134:
        -:  135:/// TODO: disallow arith.constant to return anything other than signless integer
        -:  136:/// or float like.
function _ZN4mlir5arith10ConstantOp6verifyEv called 19858 returned 100% blocks executed 29%
    19858:  137:LogicalResult arith::ConstantOp::verify() {
    19858:  138:  auto type = getType();
call    0 returned 100%
        -:  139:  // The value's type must match the return type.
    19858:  140:  if (getValue().getType() != type) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  141:    return emitOpError() << "value type " << getValue().getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  142:                         << " must match return type: " << type;
call    0 never executed
call    1 never executed
        -:  143:  }
        -:  144:  // Integer values must be signless.
   19858*:  145:  if (type.isa<IntegerType>() && !type.cast<IntegerType>().isSignless())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  146:    return emitOpError("integer return type must be signless");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  147:  // Any float or elements attribute are acceptable.
    19858:  148:  if (!getValue().isa<IntegerAttr, FloatAttr, ElementsAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  149:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  150:        "value must be an integer, float, or elements attribute");
call    0 never executed
        -:  151:  }
    19858:  152:  return success();
        -:  153:}
        -:  154:
function _ZN4mlir5arith10ConstantOp15isBuildableWithENS_9AttributeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  155:bool arith::ConstantOp::isBuildableWith(Attribute value, Type type) {
        -:  156:  // The value's type must be the same as the provided type.
    #####:  157:  auto typedAttr = value.dyn_cast<TypedAttr>();
call    0 never executed
    #####:  158:  if (!typedAttr || typedAttr.getType() != type)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  159:    return false;
        -:  160:  // Integer values must be signless.
    #####:  161:  if (type.isa<IntegerType>() && !type.cast<IntegerType>().isSignless())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  162:    return false;
        -:  163:  // Integer, float, and element attributes are buildable.
    #####:  164:  return value.isa<IntegerAttr, FloatAttr, ElementsAttr>();
call    0 never executed
        -:  165:}
        -:  166:
function _ZN4mlir5arith10ConstantOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 8105 returned 100% blocks executed 100%
     8105:  167:OpFoldResult arith::ConstantOp::fold(ArrayRef<Attribute> operands) {
     8105:  168:  return getValue();
call    0 returned 100%
call    1 returned 100%
        -:  169:}
        -:  170:
function _ZN4mlir5arith13ConstantIntOp5buildERNS_9OpBuilderERNS_14OperationStateElj called 0 returned 0% blocks executed 0%
    #####:  171:void arith::ConstantIntOp::build(OpBuilder &builder, OperationState &result,
        -:  172:                                 int64_t value, unsigned width) {
    #####:  173:  auto type = builder.getIntegerType(width);
call    0 never executed
    #####:  174:  arith::ConstantOp::build(builder, result, type,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  175:                           builder.getIntegerAttr(type, value));
    #####:  176:}
        -:  177:
function _ZN4mlir5arith13ConstantIntOp5buildERNS_9OpBuilderERNS_14OperationStateElNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  178:void arith::ConstantIntOp::build(OpBuilder &builder, OperationState &result,
        -:  179:                                 int64_t value, Type type) {
    #####:  180:  assert(type.isSignlessInteger() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  181:         "ConstantIntOp can only have signless integer type values");
    #####:  182:  arith::ConstantOp::build(builder, result, type,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  183:                           builder.getIntegerAttr(type, value));
    #####:  184:}
        -:  185:
function _ZN4mlir5arith13ConstantIntOp7classofEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  186:bool arith::ConstantIntOp::classof(Operation *op) {
    #####:  187:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  188:    return constOp.getType().isSignlessInteger();
call    0 never executed
        -:  189:  return false;
        -:  190:}
        -:  191:
function _ZN4mlir5arith15ConstantFloatOp5buildERNS_9OpBuilderERNS_14OperationStateERKN4llvm7APFloatENS_9FloatTypeE called 0 returned 0% blocks executed 0%
    #####:  192:void arith::ConstantFloatOp::build(OpBuilder &builder, OperationState &result,
        -:  193:                                   const APFloat &value, FloatType type) {
    #####:  194:  arith::ConstantOp::build(builder, result, type,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  195:                           builder.getFloatAttr(type, value));
    #####:  196:}
        -:  197:
function _ZN4mlir5arith15ConstantFloatOp7classofEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  198:bool arith::ConstantFloatOp::classof(Operation *op) {
    #####:  199:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  200:    return constOp.getType().isa<FloatType>();
call    0 never executed
        -:  201:  return false;
        -:  202:}
        -:  203:
function _ZN4mlir5arith15ConstantIndexOp5buildERNS_9OpBuilderERNS_14OperationStateEl called 3883 returned 99% blocks executed 100%
     3883:  204:void arith::ConstantIndexOp::build(OpBuilder &builder, OperationState &result,
        -:  205:                                   int64_t value) {
     3883:  206:  arith::ConstantOp::build(builder, result, builder.getIndexType(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 99%
        -:  207:                           builder.getIndexAttr(value));
     3860:  208:}
        -:  209:
function _ZN4mlir5arith15ConstantIndexOp7classofEPNS_9OperationE called 3853 returned 100% blocks executed 100%
     3853:  210:bool arith::ConstantIndexOp::classof(Operation *op) {
     7702:  211:  if (auto constOp = dyn_cast_or_null<arith::ConstantOp>(op))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
     3854:  212:    return constOp.getType().isIndex();
call    0 returned 100%
        -:  213:  return false;
        -:  214:}
        -:  215:
        -:  216://===----------------------------------------------------------------------===//
        -:  217:// AddIOp
        -:  218://===----------------------------------------------------------------------===//
        -:  219:
function _ZN4mlir5arith6AddIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  220:OpFoldResult arith::AddIOp::fold(ArrayRef<Attribute> operands) {
        -:  221:  // addi(x, 0) -> x
    #####:  222:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  223:    return getLhs();
call    0 never executed
call    1 never executed
        -:  224:
        -:  225:  // addi(subi(a, b), b) -> a
    #####:  226:  if (auto sub = getLhs().getDefiningOp<SubIOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  227:    if (getRhs() == sub.getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  228:      return sub.getLhs();
call    0 never executed
call    1 never executed
        -:  229:
        -:  230:  // addi(b, subi(a, b)) -> a
    #####:  231:  if (auto sub = getRhs().getDefiningOp<SubIOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  232:    if (getLhs() == sub.getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  233:      return sub.getLhs();
call    0 never executed
call    1 never executed
        -:  234:
    #####:  235:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6AddIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  236:      operands, [](APInt a, const APInt &b) { return std::move(a) + b; });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  237:}
        -:  238:
function _ZN4mlir5arith6AddIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3708 returned 100% blocks executed 100%
     3708:  239:void arith::AddIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  240:                                                MLIRContext *context) {
     3708:  241:  patterns.add<AddIAddConstant, AddISubConstantRHS, AddISubConstantLHS>(
     3708:  242:      context);
call    0 returned 100%
     3714:  243:}
        -:  244:
        -:  245://===----------------------------------------------------------------------===//
        -:  246:// AddUICarryOp
        -:  247://===----------------------------------------------------------------------===//
        -:  248:
function _ZN4mlir5arith12AddUICarryOp17getShapeForUnrollEv called 0 returned 0% blocks executed 0%
    #####:  249:Optional<SmallVector<int64_t, 4>> arith::AddUICarryOp::getShapeForUnroll() {
    #####:  250:  if (auto vt = getType(0).dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  251:    return llvm::to_vector<4>(vt.getShape());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  252:  return None;
        -:  253:}
        -:  254:
        -:  255:// Returns the carry bit, assuming that `sum` is the result of addition of
        -:  256:// `operand` and another number.
function _ZL14calculateCarryRKN4llvm5APIntES2_ called 0 returned 0% blocks executed 0%
    #####:  257:static APInt calculateCarry(const APInt &sum, const APInt &operand) {
    #####:  258:  return sum.ult(operand) ? APInt::getAllOnes(1) : APInt::getZero(1);
branch  0 never executed
branch  1 never executed
        -:  259:}
        -:  260:
        -:  261:LogicalResult
function _ZN4mlir5arith12AddUICarryOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:  262:arith::AddUICarryOp::fold(ArrayRef<Attribute> operands,
        -:  263:                          SmallVectorImpl<OpFoldResult> &results) {
    #####:  264:  auto carryTy = getCarry().getType();
call    0 never executed
call    1 never executed
        -:  265:  // addui_carry(x, 0) -> x, false
    #####:  266:  if (matchPattern(getRhs(), m_Zero())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  267:    auto carryZero = APInt::getZero(1);
call    0 never executed
    #####:  268:    Builder builder(getContext());
call    0 never executed
call    1 never executed
    #####:  269:    auto falseValue = builder.getZeroAttr(carryTy);
call    0 never executed
        -:  270:
    #####:  271:    results.push_back(getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  272:    results.push_back(falseValue);
call    0 never executed
call    1 never executed
    #####:  273:    return success();
branch  0 never executed
branch  1 never executed
        -:  274:  }
        -:  275:
        -:  276:  // addui_carry(constant_a, constant_b) -> constant_sum, constant_carry
        -:  277:  // Let the `constFoldBinaryOp` utility attempt to fold the sum of both
        -:  278:  // operands. If that succeeds, calculate the carry boolean based on the sum
        -:  279:  // and the first (constant) operand, `lhs`. Note that we cannot simply call
        -:  280:  // `constFoldBinaryOp` again to calculate the carry (bit) because the
        -:  281:  // constructed attribute is of the same element type as both operands.
    #####:  282:  if (Attribute sumAttr = constFoldBinaryOp<IntegerAttr>(
branch  0 never executed
branch  1 never executed
function _ZZN4mlir5arith12AddUICarryOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEENKUlNS2_5APIntERKSA_E_clESA_SC_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  283:          operands, [](APInt a, const APInt &b) { return std::move(a) + b; })) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  284:    Attribute carryAttr;
    #####:  285:    if (auto lhs = operands[0].dyn_cast<IntegerAttr>()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  286:      // Both arguments are scalars, calculate the scalar carry value.
    #####:  287:      auto sum = sumAttr.cast<IntegerAttr>();
call    0 never executed
    #####:  288:      carryAttr = IntegerAttr::get(
branch  0 never executed
branch  1 never executed
    #####:  289:          carryTy, calculateCarry(sum.getValue(), lhs.getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  290:    } else if (auto lhs = operands[0].dyn_cast<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:      // Both arguments are splats, calculate the splat carry value.
    #####:  292:      auto sum = sumAttr.cast<SplatElementsAttr>();
call    0 never executed
    #####:  293:      APInt carry = calculateCarry(sum.getSplatValue<APInt>(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:                                   lhs.getSplatValue<APInt>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  295:      carryAttr = SplatElementsAttr::get(carryTy, carry);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  296:    } else if (auto lhs = operands[0].dyn_cast<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  297:      // Othwerwise calculate element-wise carry values.
    #####:  298:      auto sum = sumAttr.cast<ElementsAttr>();
call    0 never executed
    #####:  299:      const auto numElems = static_cast<size_t>(sum.getNumElements());
call    0 never executed
    #####:  300:      SmallVector<APInt> carryValues;
branch  0 never executed
branch  1 never executed
    #####:  301:      carryValues.reserve(numElems);
branch  0 never executed
branch  1 never executed
        -:  302:
    #####:  303:      auto sumIt = sum.value_begin<APInt>();
call    0 never executed
call    1 never executed
    #####:  304:      auto lhsIt = lhs.value_begin<APInt>();
branch  0 never executed
branch  1 never executed
    #####:  305:      for (size_t i = 0, e = numElems; i != e; ++i, ++sumIt, ++lhsIt)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  306:        carryValues.push_back(calculateCarry(*sumIt, *lhsIt));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  307:
    #####:  308:      carryAttr = DenseElementsAttr::get(carryTy, carryValues);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  309:    } else {
    #####:  310:      return failure();
        -:  311:    }
        -:  312:
    #####:  313:    results.push_back(sumAttr);
call    0 never executed
call    1 never executed
    #####:  314:    results.push_back(carryAttr);
call    0 never executed
call    1 never executed
    #####:  315:    return success();
        -:  316:  }
        -:  317:
    #####:  318:  return failure();
        -:  319:}
        -:  320:
        -:  321://===----------------------------------------------------------------------===//
        -:  322:// SubIOp
        -:  323://===----------------------------------------------------------------------===//
        -:  324:
function _ZN4mlir5arith6SubIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  325:OpFoldResult arith::SubIOp::fold(ArrayRef<Attribute> operands) {
        -:  326:  // subi(x,x) -> 0
    #####:  327:  if (getOperand(0) == getOperand(1))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  328:    return Builder(getContext()).getZeroAttr(getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  329:  // subi(x,0) -> x
    #####:  330:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  331:    return getLhs();
call    0 never executed
call    1 never executed
        -:  332:
    #####:  333:  if (auto add = getLhs().getDefiningOp<AddIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  334:    // subi(addi(a, b), b) -> a
    #####:  335:    if (getRhs() == add.getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  336:      return add.getLhs();
call    0 never executed
call    1 never executed
        -:  337:    // subi(addi(a, b), a) -> b
    #####:  338:    if (getRhs() == add.getLhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  339:      return add.getRhs();
call    0 never executed
call    1 never executed
        -:  340:  }
        -:  341:
    #####:  342:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6SubIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  343:      operands, [](APInt a, const APInt &b) { return std::move(a) - b; });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  344:}
        -:  345:
function _ZN4mlir5arith6SubIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3704 returned 100% blocks executed 100%
     3704:  346:void arith::SubIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  347:                                                MLIRContext *context) {
     3704:  348:  patterns.add<SubIRHSAddConstant, SubILHSAddConstant, SubIRHSSubConstantRHS,
        -:  349:               SubIRHSSubConstantLHS, SubILHSSubConstantRHS,
     3704:  350:               SubILHSSubConstantLHS, SubISubILHSRHSLHS>(context);
call    0 returned 100%
     3716:  351:}
        -:  352:
        -:  353://===----------------------------------------------------------------------===//
        -:  354:// MulIOp
        -:  355://===----------------------------------------------------------------------===//
        -:  356:
function _ZN4mlir5arith6MulIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  357:OpFoldResult arith::MulIOp::fold(ArrayRef<Attribute> operands) {
        -:  358:  // muli(x, 0) -> 0
    #####:  359:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  360:    return getRhs();
call    0 never executed
call    1 never executed
        -:  361:  // muli(x, 1) -> x
    #####:  362:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  363:    return getOperand(0);
call    0 never executed
call    1 never executed
        -:  364:  // TODO: Handle the overflow case.
        -:  365:
        -:  366:  // default folder
    #####:  367:  return constFoldBinaryOp<IntegerAttr>(
    #####:  368:      operands, [](const APInt &a, const APInt &b) { return a * b; });
call    0 never executed
call    1 never executed
call    2 never executed
        -:  369:}
        -:  370:
        -:  371://===----------------------------------------------------------------------===//
        -:  372:// DivUIOp
        -:  373://===----------------------------------------------------------------------===//
        -:  374:
function _ZN4mlir5arith7DivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  375:OpFoldResult arith::DivUIOp::fold(ArrayRef<Attribute> operands) {
        -:  376:  // divui (x, 1) -> x.
    #####:  377:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  378:    return getLhs();
call    0 never executed
call    1 never executed
        -:  379:
        -:  380:  // Don't fold if it would require a division by zero.
    #####:  381:  bool div0 = false;
    #####:  382:  auto result =
function _ZZN4mlir5arith7DivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  383:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  384:        if (div0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  385:          div0 = true;
    #####:  386:          return a;
        -:  387:        }
    #####:  388:        return a.udiv(b);
call    0 never executed
    #####:  389:      });
call    0 never executed
        -:  390:
    #####:  391:  return div0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  392:}
        -:  393:
        -:  394://===----------------------------------------------------------------------===//
        -:  395:// DivSIOp
        -:  396://===----------------------------------------------------------------------===//
        -:  397:
function _ZN4mlir5arith7DivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  398:OpFoldResult arith::DivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  399:  // divsi (x, 1) -> x.
    #####:  400:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  401:    return getLhs();
call    0 never executed
call    1 never executed
        -:  402:
        -:  403:  // Don't fold if it would overflow or if it requires a division by zero.
    #####:  404:  bool overflowOrDiv0 = false;
    #####:  405:  auto result =
function _ZZN4mlir5arith7DivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  406:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  407:        if (overflowOrDiv0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  408:          overflowOrDiv0 = true;
    #####:  409:          return a;
        -:  410:        }
    #####:  411:        return a.sdiv_ov(b, overflowOrDiv0);
call    0 never executed
    #####:  412:      });
call    0 never executed
        -:  413:
    #####:  414:  return overflowOrDiv0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  415:}
        -:  416:
        -:  417://===----------------------------------------------------------------------===//
        -:  418:// Ceil and floor division folding helpers
        -:  419://===----------------------------------------------------------------------===//
        -:  420:
function _ZL22signedCeilNonnegInputsRKN4llvm5APIntES2_Rb called 0 returned 0% blocks executed 0%
    #####:  421:static APInt signedCeilNonnegInputs(const APInt &a, const APInt &b,
        -:  422:                                    bool &overflow) {
        -:  423:  // Returns (a-1)/b + 1
    #####:  424:  APInt one(a.getBitWidth(), 1, true); // Signed value 1.
branch  0 never executed
branch  1 never executed
    #####:  425:  APInt val = a.ssub_ov(one, overflow).sdiv_ov(b, overflow);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  426:  return val.sadd_ov(one, overflow);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  427:}
        -:  428:
        -:  429://===----------------------------------------------------------------------===//
        -:  430:// CeilDivUIOp
        -:  431://===----------------------------------------------------------------------===//
        -:  432:
function _ZN4mlir5arith11CeilDivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  433:OpFoldResult arith::CeilDivUIOp::fold(ArrayRef<Attribute> operands) {
        -:  434:  // ceildivui (x, 1) -> x.
    #####:  435:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  436:    return getLhs();
call    0 never executed
call    1 never executed
        -:  437:
    #####:  438:  bool overflowOrDiv0 = false;
    #####:  439:  auto result =
function _ZZN4mlir5arith11CeilDivUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  440:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  441:        if (overflowOrDiv0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  442:          overflowOrDiv0 = true;
    #####:  443:          return a;
        -:  444:        }
    #####:  445:        APInt quotient = a.udiv(b);
call    0 never executed
    #####:  446:        if (!a.urem(b))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  447:          return quotient;
    #####:  448:        APInt one(a.getBitWidth(), 1, true);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  449:        return quotient.uadd_ov(one, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  450:      });
call    0 never executed
        -:  451:
    #####:  452:  return overflowOrDiv0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  453:}
        -:  454:
        -:  455://===----------------------------------------------------------------------===//
        -:  456:// CeilDivSIOp
        -:  457://===----------------------------------------------------------------------===//
        -:  458:
function _ZN4mlir5arith11CeilDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  459:OpFoldResult arith::CeilDivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  460:  // ceildivsi (x, 1) -> x.
    #####:  461:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  462:    return getLhs();
call    0 never executed
call    1 never executed
        -:  463:
        -:  464:  // Don't fold if it would overflow or if it requires a division by zero.
    #####:  465:  bool overflowOrDiv0 = false;
    #####:  466:  auto result =
function _ZZN4mlir5arith11CeilDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  467:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  468:        if (overflowOrDiv0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  469:          overflowOrDiv0 = true;
    #####:  470:          return a;
        -:  471:        }
    #####:  472:        if (!a)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  473:          return a;
        -:  474:        // After this point we know that neither a or b are zero.
    #####:  475:        unsigned bits = a.getBitWidth();
call    0 never executed
    #####:  476:        APInt zero = APInt::getZero(bits);
call    0 never executed
    #####:  477:        bool aGtZero = a.sgt(zero);
branch  0 never executed
branch  1 never executed
    #####:  478:        bool bGtZero = b.sgt(zero);
    #####:  479:        if (aGtZero && bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  480:          // Both positive, return ceil(a, b).
    #####:  481:          return signedCeilNonnegInputs(a, b, overflowOrDiv0);
call    0 never executed
        -:  482:        }
    #####:  483:        if (!aGtZero && !bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  484:          // Both negative, return ceil(-a, -b).
    #####:  485:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 never executed
    #####:  486:          APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  487:          return signedCeilNonnegInputs(posA, posB, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  488:        }
    #####:  489:        if (!aGtZero && bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  490:          // A is negative, b is positive, return - ( -a / b).
    #####:  491:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 never executed
    #####:  492:          APInt div = posA.sdiv_ov(b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  493:          return zero.ssub_ov(div, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:        }
        -:  495:        // A is positive, b is negative, return - (a / -b).
    #####:  496:        APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  497:        APInt div = a.sdiv_ov(posB, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  498:        return zero.ssub_ov(div, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:      });
call    0 never executed
        -:  500:
    #####:  501:  return overflowOrDiv0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  502:}
        -:  503:
        -:  504://===----------------------------------------------------------------------===//
        -:  505:// FloorDivSIOp
        -:  506://===----------------------------------------------------------------------===//
        -:  507:
function _ZN4mlir5arith12FloorDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  508:OpFoldResult arith::FloorDivSIOp::fold(ArrayRef<Attribute> operands) {
        -:  509:  // floordivsi (x, 1) -> x.
    #####:  510:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  511:    return getLhs();
call    0 never executed
call    1 never executed
        -:  512:
        -:  513:  // Don't fold if it would overflow or if it requires a division by zero.
    #####:  514:  bool overflowOrDiv0 = false;
    #####:  515:  auto result =
function _ZZN4mlir5arith12FloorDivSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  516:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  517:        if (overflowOrDiv0 || !b) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  518:          overflowOrDiv0 = true;
    #####:  519:          return a;
        -:  520:        }
    #####:  521:        if (!a)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  522:          return a;
        -:  523:        // After this point we know that neither a or b are zero.
    #####:  524:        unsigned bits = a.getBitWidth();
call    0 never executed
    #####:  525:        APInt zero = APInt::getZero(bits);
call    0 never executed
    #####:  526:        bool aGtZero = a.sgt(zero);
branch  0 never executed
branch  1 never executed
    #####:  527:        bool bGtZero = b.sgt(zero);
    #####:  528:        if (aGtZero && bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  529:          // Both positive, return a / b.
    #####:  530:          return a.sdiv_ov(b, overflowOrDiv0);
call    0 never executed
        -:  531:        }
    #####:  532:        if (!aGtZero && !bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  533:          // Both negative, return -a / -b.
    #####:  534:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 never executed
    #####:  535:          APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  536:          return posA.sdiv_ov(posB, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  537:        }
    #####:  538:        if (!aGtZero && bGtZero) {
branch  0 never executed
branch  1 never executed
        -:  539:          // A is negative, b is positive, return - ceil(-a, b).
    #####:  540:          APInt posA = zero.ssub_ov(a, overflowOrDiv0);
call    0 never executed
    #####:  541:          APInt ceil = signedCeilNonnegInputs(posA, b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  542:          return zero.ssub_ov(ceil, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  543:        }
        -:  544:        // A is positive, b is negative, return - ceil(a, -b).
    #####:  545:        APInt posB = zero.ssub_ov(b, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  546:        APInt ceil = signedCeilNonnegInputs(a, posB, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  547:        return zero.ssub_ov(ceil, overflowOrDiv0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  548:      });
call    0 never executed
        -:  549:
    #####:  550:  return overflowOrDiv0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  551:}
        -:  552:
        -:  553://===----------------------------------------------------------------------===//
        -:  554:// RemUIOp
        -:  555://===----------------------------------------------------------------------===//
        -:  556:
function _ZN4mlir5arith7RemUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  557:OpFoldResult arith::RemUIOp::fold(ArrayRef<Attribute> operands) {
        -:  558:  // remui (x, 1) -> 0.
    #####:  559:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:    return Builder(getContext()).getZeroAttr(getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  561:
        -:  562:  // Don't fold if it would require a division by zero.
    #####:  563:  bool div0 = false;
    #####:  564:  auto result =
function _ZZN4mlir5arith7RemUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  565:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  566:        if (div0 || b.isNullValue()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  567:          div0 = true;
    #####:  568:          return a;
        -:  569:        }
    #####:  570:        return a.urem(b);
call    0 never executed
    #####:  571:      });
call    0 never executed
        -:  572:
    #####:  573:  return div0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  574:}
        -:  575:
        -:  576://===----------------------------------------------------------------------===//
        -:  577:// RemSIOp
        -:  578://===----------------------------------------------------------------------===//
        -:  579:
function _ZN4mlir5arith7RemSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  580:OpFoldResult arith::RemSIOp::fold(ArrayRef<Attribute> operands) {
        -:  581:  // remsi (x, 1) -> 0.
    #####:  582:  if (matchPattern(getRhs(), m_One()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  583:    return Builder(getContext()).getZeroAttr(getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  584:
        -:  585:  // Don't fold if it would require a division by zero.
    #####:  586:  bool div0 = false;
    #####:  587:  auto result =
function _ZZN4mlir5arith7RemSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  588:      constFoldBinaryOp<IntegerAttr>(operands, [&](APInt a, const APInt &b) {
    #####:  589:        if (div0 || b.isNullValue()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  590:          div0 = true;
    #####:  591:          return a;
        -:  592:        }
    #####:  593:        return a.srem(b);
call    0 never executed
    #####:  594:      });
call    0 never executed
        -:  595:
    #####:  596:  return div0 ? Attribute() : result;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  597:}
        -:  598:
        -:  599://===----------------------------------------------------------------------===//
        -:  600:// AndIOp
        -:  601://===----------------------------------------------------------------------===//
        -:  602:
function _ZN4mlir5arith6AndIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  603:OpFoldResult arith::AndIOp::fold(ArrayRef<Attribute> operands) {
        -:  604:  /// and(x, 0) -> 0
    #####:  605:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  606:    return getRhs();
call    0 never executed
call    1 never executed
        -:  607:  /// and(x, allOnes) -> x
    #####:  608:  APInt intValue;
call    0 never executed
    #####:  609:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isAllOnes())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  610:    return getLhs();
call    0 never executed
call    1 never executed
        -:  611:  /// and(x, not(x)) -> 0
    #####:  612:  if (matchPattern(getRhs(), m_Op<XOrIOp>(matchers::m_Val(getLhs()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  613:                                          m_ConstantInt(&intValue))) &&
branch  0 never executed
branch  1 never executed
    #####:  614:      intValue.isAllOnes())
branch  0 never executed
branch  1 never executed
    #####:  615:    return IntegerAttr::get(getType(), 0);
call    0 never executed
call    1 never executed
        -:  616:  /// and(not(x), x) -> 0
    #####:  617:  if (matchPattern(getLhs(), m_Op<XOrIOp>(matchers::m_Val(getRhs()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  618:                                          m_ConstantInt(&intValue))) &&
branch  0 never executed
branch  1 never executed
    #####:  619:      intValue.isAllOnes())
branch  0 never executed
branch  1 never executed
    #####:  620:    return IntegerAttr::get(getType(), 0);
call    0 never executed
call    1 never executed
        -:  621:
    #####:  622:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6AndIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  623:      operands, [](APInt a, const APInt &b) { return std::move(a) & b; });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  624:}
        -:  625:
        -:  626://===----------------------------------------------------------------------===//
        -:  627:// OrIOp
        -:  628://===----------------------------------------------------------------------===//
        -:  629:
function _ZN4mlir5arith5OrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  630:OpFoldResult arith::OrIOp::fold(ArrayRef<Attribute> operands) {
        -:  631:  /// or(x, 0) -> x
    #####:  632:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  633:    return getLhs();
call    0 never executed
call    1 never executed
        -:  634:  /// or(x, <all ones>) -> <all ones>
    #####:  635:  if (auto rhsAttr = operands[1].dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  636:    if (rhsAttr.getValue().isAllOnes())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  637:      return rhsAttr;
call    0 never executed
        -:  638:
    #####:  639:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith5OrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  640:      operands, [](APInt a, const APInt &b) { return std::move(a) | b; });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  641:}
        -:  642:
        -:  643://===----------------------------------------------------------------------===//
        -:  644:// XOrIOp
        -:  645://===----------------------------------------------------------------------===//
        -:  646:
function _ZN4mlir5arith6XOrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  647:OpFoldResult arith::XOrIOp::fold(ArrayRef<Attribute> operands) {
        -:  648:  /// xor(x, 0) -> x
    #####:  649:  if (matchPattern(getRhs(), m_Zero()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  650:    return getLhs();
call    0 never executed
call    1 never executed
        -:  651:  /// xor(x, x) -> 0
    #####:  652:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  653:    return Builder(getContext()).getZeroAttr(getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  654:  /// xor(xor(x, a), a) -> x
        -:  655:  /// xor(xor(a, x), a) -> x
    #####:  656:  if (arith::XOrIOp prev = getLhs().getDefiningOp<arith::XOrIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  657:    if (prev.getRhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  658:      return prev.getLhs();
call    0 never executed
call    1 never executed
    #####:  659:    if (prev.getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  660:      return prev.getRhs();
call    0 never executed
call    1 never executed
        -:  661:  }
        -:  662:  /// xor(a, xor(x, a)) -> x
        -:  663:  /// xor(a, xor(a, x)) -> x
    #####:  664:  if (arith::XOrIOp prev = getRhs().getDefiningOp<arith::XOrIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  665:    if (prev.getRhs() == getLhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  666:      return prev.getLhs();
call    0 never executed
call    1 never executed
    #####:  667:    if (prev.getLhs() == getLhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  668:      return prev.getRhs();
call    0 never executed
call    1 never executed
        -:  669:  }
        -:  670:
    #####:  671:  return constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6XOrIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlNS2_5APIntERKS6_E_clES6_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  672:      operands, [](APInt a, const APInt &b) { return std::move(a) ^ b; });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  673:}
        -:  674:
function _ZN4mlir5arith6XOrIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3710 returned 100% blocks executed 100%
     3710:  675:void arith::XOrIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  676:                                                MLIRContext *context) {
     3710:  677:  patterns.add<XOrINotCmpI>(context);
call    0 returned 100%
     3709:  678:}
        -:  679:
        -:  680://===----------------------------------------------------------------------===//
        -:  681:// NegFOp
        -:  682://===----------------------------------------------------------------------===//
        -:  683:
function _ZN4mlir5arith6NegFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  684:OpFoldResult arith::NegFOp::fold(ArrayRef<Attribute> operands) {
        -:  685:  /// negf(negf(x)) -> x
    #####:  686:  if (auto op = this->getOperand().getDefiningOp<arith::NegFOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  687:    return op.getOperand();
call    0 never executed
call    1 never executed
    #####:  688:  return constFoldUnaryOp<FloatAttr>(operands,
    #####:  689:                                     [](const APFloat &a) { return -a; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  690:}
        -:  691:
        -:  692://===----------------------------------------------------------------------===//
        -:  693:// AddFOp
        -:  694://===----------------------------------------------------------------------===//
        -:  695:
function _ZN4mlir5arith6AddFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  696:OpFoldResult arith::AddFOp::fold(ArrayRef<Attribute> operands) {
        -:  697:  // addf(x, -0) -> x
    #####:  698:  if (matchPattern(getRhs(), m_NegZeroFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  699:    return getLhs();
call    0 never executed
call    1 never executed
        -:  700:
    #####:  701:  return constFoldBinaryOp<FloatAttr>(
    #####:  702:      operands, [](const APFloat &a, const APFloat &b) { return a + b; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  703:}
        -:  704:
        -:  705://===----------------------------------------------------------------------===//
        -:  706:// SubFOp
        -:  707://===----------------------------------------------------------------------===//
        -:  708:
function _ZN4mlir5arith6SubFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  709:OpFoldResult arith::SubFOp::fold(ArrayRef<Attribute> operands) {
        -:  710:  // subf(x, +0) -> x
    #####:  711:  if (matchPattern(getRhs(), m_PosZeroFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  712:    return getLhs();
call    0 never executed
call    1 never executed
        -:  713:
    #####:  714:  return constFoldBinaryOp<FloatAttr>(
    #####:  715:      operands, [](const APFloat &a, const APFloat &b) { return a - b; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  716:}
        -:  717:
        -:  718://===----------------------------------------------------------------------===//
        -:  719:// MaxFOp
        -:  720://===----------------------------------------------------------------------===//
        -:  721:
function _ZN4mlir5arith6MaxFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  722:OpFoldResult arith::MaxFOp::fold(ArrayRef<Attribute> operands) {
    #####:  723:  assert(operands.size() == 2 && "maxf takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  724:
        -:  725:  // maxf(x,x) -> x
    #####:  726:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  727:    return getRhs();
call    0 never executed
call    1 never executed
        -:  728:
        -:  729:  // maxf(x, -inf) -> x
    #####:  730:  if (matchPattern(getRhs(), m_NegInfFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  731:    return getLhs();
call    0 never executed
call    1 never executed
        -:  732:
    #####:  733:  return constFoldBinaryOp<FloatAttr>(
        -:  734:      operands,
    #####:  735:      [](const APFloat &a, const APFloat &b) { return llvm::maximum(a, b); });
call    0 never executed
call    1 never executed
call    2 never executed
        -:  736:}
        -:  737:
        -:  738://===----------------------------------------------------------------------===//
        -:  739:// MaxSIOp
        -:  740://===----------------------------------------------------------------------===//
        -:  741:
function _ZN4mlir5arith7MaxSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  742:OpFoldResult MaxSIOp::fold(ArrayRef<Attribute> operands) {
    #####:  743:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:
        -:  745:  // maxsi(x,x) -> x
    #####:  746:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  747:    return getRhs();
call    0 never executed
call    1 never executed
        -:  748:
    #####:  749:  APInt intValue;
call    0 never executed
        -:  750:  // maxsi(x,MAX_INT) -> MAX_INT
    #####:  751:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  752:      intValue.isMaxSignedValue())
call    0 never executed
    #####:  753:    return getRhs();
call    0 never executed
call    1 never executed
        -:  754:
        -:  755:  // maxsi(x, MIN_INT) -> x
    #####:  756:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  757:      intValue.isMinSignedValue())
call    0 never executed
    #####:  758:    return getLhs();
call    0 never executed
call    1 never executed
        -:  759:
    #####:  760:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MaxSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  761:                                        [](const APInt &a, const APInt &b) {
    #####:  762:                                          return llvm::APIntOps::smax(a, b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  763:                                        });
call    0 never executed
call    1 never executed
        -:  764:}
        -:  765:
        -:  766://===----------------------------------------------------------------------===//
        -:  767:// MaxUIOp
        -:  768://===----------------------------------------------------------------------===//
        -:  769:
function _ZN4mlir5arith7MaxUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  770:OpFoldResult MaxUIOp::fold(ArrayRef<Attribute> operands) {
    #####:  771:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  772:
        -:  773:  // maxui(x,x) -> x
    #####:  774:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  775:    return getRhs();
call    0 never executed
call    1 never executed
        -:  776:
    #####:  777:  APInt intValue;
call    0 never executed
        -:  778:  // maxui(x,MAX_INT) -> MAX_INT
    #####:  779:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMaxValue())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  780:    return getRhs();
call    0 never executed
call    1 never executed
        -:  781:
        -:  782:  // maxui(x, MIN_INT) -> x
    #####:  783:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMinValue())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  784:    return getLhs();
call    0 never executed
call    1 never executed
        -:  785:
    #####:  786:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MaxUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  787:                                        [](const APInt &a, const APInt &b) {
    #####:  788:                                          return llvm::APIntOps::umax(a, b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  789:                                        });
call    0 never executed
call    1 never executed
        -:  790:}
        -:  791:
        -:  792://===----------------------------------------------------------------------===//
        -:  793:// MinFOp
        -:  794://===----------------------------------------------------------------------===//
        -:  795:
function _ZN4mlir5arith6MinFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  796:OpFoldResult arith::MinFOp::fold(ArrayRef<Attribute> operands) {
    #####:  797:  assert(operands.size() == 2 && "minf takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  798:
        -:  799:  // minf(x,x) -> x
    #####:  800:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  801:    return getRhs();
call    0 never executed
call    1 never executed
        -:  802:
        -:  803:  // minf(x, +inf) -> x
    #####:  804:  if (matchPattern(getRhs(), m_PosInfFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  805:    return getLhs();
call    0 never executed
call    1 never executed
        -:  806:
    #####:  807:  return constFoldBinaryOp<FloatAttr>(
        -:  808:      operands,
    #####:  809:      [](const APFloat &a, const APFloat &b) { return llvm::minimum(a, b); });
call    0 never executed
call    1 never executed
call    2 never executed
        -:  810:}
        -:  811:
        -:  812://===----------------------------------------------------------------------===//
        -:  813:// MinSIOp
        -:  814://===----------------------------------------------------------------------===//
        -:  815:
function _ZN4mlir5arith7MinSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  816:OpFoldResult MinSIOp::fold(ArrayRef<Attribute> operands) {
    #####:  817:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  818:
        -:  819:  // minsi(x,x) -> x
    #####:  820:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  821:    return getRhs();
call    0 never executed
call    1 never executed
        -:  822:
    #####:  823:  APInt intValue;
call    0 never executed
        -:  824:  // minsi(x,MIN_INT) -> MIN_INT
    #####:  825:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  826:      intValue.isMinSignedValue())
call    0 never executed
    #####:  827:    return getRhs();
call    0 never executed
call    1 never executed
        -:  828:
        -:  829:  // minsi(x, MAX_INT) -> x
    #####:  830:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  831:      intValue.isMaxSignedValue())
call    0 never executed
    #####:  832:    return getLhs();
call    0 never executed
call    1 never executed
        -:  833:
    #####:  834:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MinSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  835:                                        [](const APInt &a, const APInt &b) {
    #####:  836:                                          return llvm::APIntOps::smin(a, b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  837:                                        });
call    0 never executed
call    1 never executed
        -:  838:}
        -:  839:
        -:  840://===----------------------------------------------------------------------===//
        -:  841:// MinUIOp
        -:  842://===----------------------------------------------------------------------===//
        -:  843:
function _ZN4mlir5arith7MinUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  844:OpFoldResult MinUIOp::fold(ArrayRef<Attribute> operands) {
    #####:  845:  assert(operands.size() == 2 && "binary operation takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  846:
        -:  847:  // minui(x,x) -> x
    #####:  848:  if (getLhs() == getRhs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  849:    return getRhs();
call    0 never executed
call    1 never executed
        -:  850:
    #####:  851:  APInt intValue;
call    0 never executed
        -:  852:  // minui(x,MIN_INT) -> MIN_INT
    #####:  853:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMinValue())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  854:    return getRhs();
call    0 never executed
call    1 never executed
        -:  855:
        -:  856:  // minui(x, MAX_INT) -> x
    #####:  857:  if (matchPattern(getRhs(), m_ConstantInt(&intValue)) && intValue.isMaxValue())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  858:    return getLhs();
call    0 never executed
call    1 never executed
        -:  859:
    #####:  860:  return constFoldBinaryOp<IntegerAttr>(operands,
function _ZZN4mlir5arith7MinUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  861:                                        [](const APInt &a, const APInt &b) {
    #####:  862:                                          return llvm::APIntOps::umin(a, b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  863:                                        });
call    0 never executed
call    1 never executed
        -:  864:}
        -:  865:
        -:  866://===----------------------------------------------------------------------===//
        -:  867:// MulFOp
        -:  868://===----------------------------------------------------------------------===//
        -:  869:
function _ZN4mlir5arith6MulFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  870:OpFoldResult arith::MulFOp::fold(ArrayRef<Attribute> operands) {
        -:  871:  // mulf(x, 1) -> x
    #####:  872:  if (matchPattern(getRhs(), m_OneFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  873:    return getLhs();
call    0 never executed
call    1 never executed
        -:  874:
    #####:  875:  return constFoldBinaryOp<FloatAttr>(
    #####:  876:      operands, [](const APFloat &a, const APFloat &b) { return a * b; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  877:}
        -:  878:
function _ZN4mlir5arith6MulFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3709 returned 100% blocks executed 100%
     3709:  879:void arith::MulFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  880:                                                MLIRContext *context) {
     3709:  881:  patterns.add<MulFOfNegF>(context);
call    0 returned 100%
     3712:  882:}
        -:  883:
        -:  884://===----------------------------------------------------------------------===//
        -:  885:// DivFOp
        -:  886://===----------------------------------------------------------------------===//
        -:  887:
function _ZN4mlir5arith6DivFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  888:OpFoldResult arith::DivFOp::fold(ArrayRef<Attribute> operands) {
        -:  889:  // divf(x, 1) -> x
    #####:  890:  if (matchPattern(getRhs(), m_OneFloat()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  891:    return getLhs();
call    0 never executed
call    1 never executed
        -:  892:
    #####:  893:  return constFoldBinaryOp<FloatAttr>(
    #####:  894:      operands, [](const APFloat &a, const APFloat &b) { return a / b; });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  895:}
        -:  896:
function _ZN4mlir5arith6DivFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3706 returned 100% blocks executed 100%
     3706:  897:void arith::DivFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -:  898:                                                MLIRContext *context) {
     3706:  899:  patterns.add<DivFOfNegF>(context);
call    0 returned 100%
     3713:  900:}
        -:  901:
        -:  902://===----------------------------------------------------------------------===//
        -:  903:// RemFOp
        -:  904://===----------------------------------------------------------------------===//
        -:  905:
function _ZN4mlir5arith6RemFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  906:OpFoldResult arith::RemFOp::fold(ArrayRef<Attribute> operands) {
    #####:  907:  return constFoldBinaryOp<FloatAttr>(operands,
    #####:  908:                                      [](const APFloat &a, const APFloat &b) {
    #####:  909:                                        APFloat result(a);
call    0 never executed
    #####:  910:                                        (void)result.remainder(b);
call    0 never executed
    #####:  911:                                        return result;
call    0 never executed
    #####:  912:                                      });
call    0 never executed
call    1 never executed
        -:  913:}
        -:  914:
        -:  915://===----------------------------------------------------------------------===//
        -:  916:// Utility functions for verifying cast ops
        -:  917://===----------------------------------------------------------------------===//
        -:  918:
        -:  919:template <typename... Types>
        -:  920:using type_list = std::tuple<Types...> *;
        -:  921:
        -:  922:/// Returns a non-null type only if the provided type is one of the allowed
        -:  923:/// types or one of the allowed shaped types of the allowed types. Returns the
        -:  924:/// element type if a valid shaped type is provided.
        -:  925:template <typename... ShapedTypes, typename... ElementTypes>
        -:  926:static Type getUnderlyingType(Type type, type_list<ShapedTypes...>,
        -:  927:                              type_list<ElementTypes...>) {
        -:  928:  if (type.isa<ShapedType>() && !type.isa<ShapedTypes...>())
        -:  929:    return {};
        -:  930:
        -:  931:  auto underlyingType = getElementTypeOrSelf(type);
        -:  932:  if (!underlyingType.isa<ElementTypes...>())
        -:  933:    return {};
        -:  934:
        -:  935:  return underlyingType;
        -:  936:}
        -:  937:
        -:  938:/// Get allowed underlying types for vectors and tensors.
        -:  939:template <typename... ElementTypes>
    #####:  940:static Type getTypeIfLike(Type type) {
    #####:  941:  return getUnderlyingType(type, type_list<VectorType, TensorType>(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -:  942:                           type_list<ElementTypes...>());
        -:  943:}
        -:  944:
        -:  945:/// Get allowed underlying types for vectors, tensors, and memrefs.
        -:  946:template <typename... ElementTypes>
    #####:  947:static Type getTypeIfLikeOrMemRef(Type type) {
    #####:  948:  return getUnderlyingType(type,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  949:                           type_list<VectorType, TensorType, MemRefType>(),
        -:  950:                           type_list<ElementTypes...>());
        -:  951:}
        -:  952:
function _ZL28areValidCastInputsAndOutputsN4mlir9TypeRangeES0_ called 0 returned 0% blocks executed 0%
    #####:  953:static bool areValidCastInputsAndOutputs(TypeRange inputs, TypeRange outputs) {
    #####:  954:  return inputs.size() == 1 && outputs.size() == 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  955:         succeeded(verifyCompatibleShapes(inputs.front(), outputs.front()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  956:}
        -:  957:
        -:  958://===----------------------------------------------------------------------===//
        -:  959:// Verifiers for integer and floating point extension/truncation ops
        -:  960://===----------------------------------------------------------------------===//
        -:  961:
        -:  962:// Extend ops can only extend to a wider type.
        -:  963:template <typename ValType, typename Op>
    #####:  964:static LogicalResult verifyExtOp(Op op) {
    #####:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
    #####:  966:  Type dstType = getElementTypeOrSelf(op.getType());
        -:  967:
    #####:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
        -:  971:
    #####:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir9FloatTypeENS0_5arith6ExtFOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir9FloatTypeENS0_5arith6ExtFOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  964:static LogicalResult verifyExtOp(Op op) {
call    0 never executed
    #####:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
    #####:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtSIOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtSIOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  964:static LogicalResult verifyExtOp(Op op) {
call    0 never executed
    #####:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
    #####:  972:  return success();
        -:  973:}
------------------
_Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtUIOpEENS0_13LogicalResultET0_:
function _Z11verifyExtOpIN4mlir11IntegerTypeENS0_5arith7ExtUIOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  964:static LogicalResult verifyExtOp(Op op) {
call    0 never executed
    #####:  965:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  966:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:  if (srcType.cast<ValType>().getWidth() >= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  969:    return op.emitError("result type ")
    #####:  970:           << dstType << " must be wider than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  971:
    #####:  972:  return success();
        -:  973:}
------------------
        -:  974:
        -:  975:// Truncate ops can only truncate to a shorter type.
        -:  976:template <typename ValType, typename Op>
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
_Z16verifyTruncateOpIN4mlir9FloatTypeENS0_5arith8TruncFOpEENS0_13LogicalResultET0_:
function _Z16verifyTruncateOpIN4mlir9FloatTypeENS0_5arith8TruncFOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
call    0 never executed
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
_Z16verifyTruncateOpIN4mlir11IntegerTypeENS0_5arith8TruncIOpEENS0_13LogicalResultET0_:
function _Z16verifyTruncateOpIN4mlir11IntegerTypeENS0_5arith8TruncIOpEENS0_13LogicalResultET0_ called 0 returned 0% blocks executed 0%
    #####:  977:static LogicalResult verifyTruncateOp(Op op) {
call    0 never executed
    #####:  978:  Type srcType = getElementTypeOrSelf(op.getIn().getType());
call    0 never executed
call    1 never executed
    #####:  979:  Type dstType = getElementTypeOrSelf(op.getType());
call    0 never executed
call    1 never executed
        -:  980:
    #####:  981:  if (srcType.cast<ValType>().getWidth() <= dstType.cast<ValType>().getWidth())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  982:    return op.emitError("result type ")
    #####:  983:           << dstType << " must be shorter than operand type " << srcType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  984:
    #####:  985:  return success();
        -:  986:}
------------------
        -:  987:
        -:  988:/// Validate a cast that changes the width of a type.
        -:  989:template <template <typename> class WidthComparator, typename... ElementTypes>
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
    #####:  996:  if (!srcType || !dstType)
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt4lessJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt4lessJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt4lessJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt4lessJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt7greaterJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt7greaterJN4mlir9FloatTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
_Z20checkWidthChangeCastISt7greaterJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_:
function _Z20checkWidthChangeCastISt7greaterJN4mlir11IntegerTypeEEEbNS1_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####:  990:static bool checkWidthChangeCast(TypeRange inputs, TypeRange outputs) {
    #####:  991:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  992:    return false;
        -:  993:
    #####:  994:  auto srcType = getTypeIfLike<ElementTypes...>(inputs.front());
call    0 never executed
    #####:  995:  auto dstType = getTypeIfLike<ElementTypes...>(outputs.front());
call    0 never executed
    #####:  996:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  997:    return false;
        -:  998:
    #####:  999:  return WidthComparator<unsigned>()(dstType.getIntOrFloatBitWidth(),
call    0 never executed
call    1 never executed
        -: 1000:                                     srcType.getIntOrFloatBitWidth());
        -: 1001:}
------------------
        -: 1002:
        -: 1003://===----------------------------------------------------------------------===//
        -: 1004:// ExtUIOp
        -: 1005://===----------------------------------------------------------------------===//
        -: 1006:
function _ZN4mlir5arith7ExtUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1007:OpFoldResult arith::ExtUIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1008:  if (auto lhs = getIn().getDefiningOp<ExtUIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1009:    getInMutable().assign(lhs.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1010:    return getResult();
call    0 never executed
        -: 1011:  }
    #####: 1012:  Type resType = getType();
call    0 never executed
    #####: 1013:  unsigned bitWidth;
    #####: 1014:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1015:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1016:  else
    #####: 1017:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 never executed
    #####: 1018:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    #####: 1019:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    #####: 1020:        return a.zext(bitWidth);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1021:      });
call    0 never executed
call    1 never executed
        -: 1022:}
        -: 1023:
function _ZN4mlir5arith7ExtUIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1024:bool arith::ExtUIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1025:  return checkWidthChangeCast<std::greater, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1026:}
        -: 1027:
function _ZN4mlir5arith7ExtUIOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1028:LogicalResult arith::ExtUIOp::verify() {
    #####: 1029:  return verifyExtOp<IntegerType>(*this);
call    0 never executed
call    1 never executed
        -: 1030:}
        -: 1031:
        -: 1032://===----------------------------------------------------------------------===//
        -: 1033:// ExtSIOp
        -: 1034://===----------------------------------------------------------------------===//
        -: 1035:
function _ZN4mlir5arith7ExtSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1036:OpFoldResult arith::ExtSIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1037:  if (auto lhs = getIn().getDefiningOp<ExtSIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1038:    getInMutable().assign(lhs.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1039:    return getResult();
call    0 never executed
        -: 1040:  }
    #####: 1041:  Type resType = getType();
call    0 never executed
    #####: 1042:  unsigned bitWidth;
    #####: 1043:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1044:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1045:  else
    #####: 1046:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 never executed
    #####: 1047:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    #####: 1048:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    #####: 1049:        return a.sext(bitWidth);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1050:      });
call    0 never executed
call    1 never executed
        -: 1051:}
        -: 1052:
function _ZN4mlir5arith7ExtSIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1053:bool arith::ExtSIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1054:  return checkWidthChangeCast<std::greater, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1055:}
        -: 1056:
function _ZN4mlir5arith7ExtSIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3707 returned 100% blocks executed 100%
     3707: 1057:void arith::ExtSIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1058:                                                 MLIRContext *context) {
     3707: 1059:  patterns.add<ExtSIOfExtUI>(context);
call    0 returned 100%
     3713: 1060:}
        -: 1061:
function _ZN4mlir5arith7ExtSIOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1062:LogicalResult arith::ExtSIOp::verify() {
    #####: 1063:  return verifyExtOp<IntegerType>(*this);
call    0 never executed
call    1 never executed
        -: 1064:}
        -: 1065:
        -: 1066://===----------------------------------------------------------------------===//
        -: 1067:// ExtFOp
        -: 1068://===----------------------------------------------------------------------===//
        -: 1069:
function _ZN4mlir5arith6ExtFOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1070:bool arith::ExtFOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1071:  return checkWidthChangeCast<std::greater, FloatType>(inputs, outputs);
call    0 never executed
        -: 1072:}
        -: 1073:
function _ZN4mlir5arith6ExtFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1074:LogicalResult arith::ExtFOp::verify() { return verifyExtOp<FloatType>(*this); }
call    0 never executed
call    1 never executed
        -: 1075:
        -: 1076://===----------------------------------------------------------------------===//
        -: 1077:// TruncIOp
        -: 1078://===----------------------------------------------------------------------===//
        -: 1079:
function _ZN4mlir5arith8TruncIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1080:OpFoldResult arith::TruncIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1081:  assert(operands.size() == 1 && "unary operation takes one operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1082:
        -: 1083:  // trunci(zexti(a)) -> a
        -: 1084:  // trunci(sexti(a)) -> a
    #####: 1085:  if (matchPattern(getOperand(), m_Op<arith::ExtUIOp>()) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1086:      matchPattern(getOperand(), m_Op<arith::ExtSIOp>()))
call    0 never executed
call    1 never executed
    #####: 1087:    return getOperand().getDefiningOp()->getOperand(0);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1088:
        -: 1089:  // trunci(trunci(a)) -> trunci(a))
    #####: 1090:  if (matchPattern(getOperand(), m_Op<arith::TruncIOp>())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1091:    setOperand(getOperand().getDefiningOp()->getOperand(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1092:    return getResult();
call    0 never executed
        -: 1093:  }
        -: 1094:
    #####: 1095:  Type resType = getType();
call    0 never executed
    #####: 1096:  unsigned bitWidth;
    #####: 1097:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1098:    bitWidth = shapedType.getElementTypeBitWidth();
call    0 never executed
        -: 1099:  else
    #####: 1100:    bitWidth = resType.getIntOrFloatBitWidth();
call    0 never executed
        -: 1101:
    #####: 1102:  return constFoldCastOp<IntegerAttr, IntegerAttr>(
    #####: 1103:      operands, getType(), [bitWidth](const APInt &a, bool &castStatus) {
    #####: 1104:        return a.trunc(bitWidth);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1105:      });
call    0 never executed
call    1 never executed
        -: 1106:}
        -: 1107:
function _ZN4mlir5arith8TruncIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1108:bool arith::TruncIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1109:  return checkWidthChangeCast<std::less, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1110:}
        -: 1111:
function _ZN4mlir5arith8TruncIOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1112:LogicalResult arith::TruncIOp::verify() {
    #####: 1113:  return verifyTruncateOp<IntegerType>(*this);
call    0 never executed
call    1 never executed
        -: 1114:}
        -: 1115:
        -: 1116://===----------------------------------------------------------------------===//
        -: 1117:// TruncFOp
        -: 1118://===----------------------------------------------------------------------===//
        -: 1119:
        -: 1120:/// Perform safe const propagation for truncf, i.e. only propagate if FP value
        -: 1121:/// can be represented without precision loss or rounding.
function _ZN4mlir5arith8TruncFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1122:OpFoldResult arith::TruncFOp::fold(ArrayRef<Attribute> operands) {
    #####: 1123:  assert(operands.size() == 1 && "unary operation takes one operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1124:
    #####: 1125:  auto constOperand = operands.front();
branch  0 never executed
branch  1 never executed
    #####: 1126:  if (!constOperand || !constOperand.isa<FloatAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1127:    return {};
        -: 1128:
        -: 1129:  // Convert to target type via 'double'.
    #####: 1130:  double sourceValue =
call    0 never executed
    #####: 1131:      constOperand.dyn_cast<FloatAttr>().getValue().convertToDouble();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1132:  auto targetAttr = FloatAttr::get(getType(), sourceValue);
call    0 never executed
        -: 1133:
        -: 1134:  // Propagate if constant's value does not change after truncation.
    #####: 1135:  if (sourceValue == targetAttr.getValue().convertToDouble())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1136:    return targetAttr;
call    0 never executed
        -: 1137:
    #####: 1138:  return {};
        -: 1139:}
        -: 1140:
function _ZN4mlir5arith8TruncFOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1141:bool arith::TruncFOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1142:  return checkWidthChangeCast<std::less, FloatType>(inputs, outputs);
call    0 never executed
        -: 1143:}
        -: 1144:
function _ZN4mlir5arith8TruncFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1145:LogicalResult arith::TruncFOp::verify() {
    #####: 1146:  return verifyTruncateOp<FloatType>(*this);
call    0 never executed
call    1 never executed
        -: 1147:}
        -: 1148:
        -: 1149://===----------------------------------------------------------------------===//
        -: 1150:// AndIOp
        -: 1151://===----------------------------------------------------------------------===//
        -: 1152:
function _ZN4mlir5arith6AndIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3712 returned 100% blocks executed 100%
     3712: 1153:void arith::AndIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1154:                                                MLIRContext *context) {
     3712: 1155:  patterns.add<AndOfExtUI, AndOfExtSI>(context);
call    0 returned 100%
     3712: 1156:}
        -: 1157:
        -: 1158://===----------------------------------------------------------------------===//
        -: 1159:// OrIOp
        -: 1160://===----------------------------------------------------------------------===//
        -: 1161:
function _ZN4mlir5arith5OrIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3706 returned 100% blocks executed 100%
     3706: 1162:void arith::OrIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1163:                                               MLIRContext *context) {
     3706: 1164:  patterns.add<OrOfExtUI, OrOfExtSI>(context);
call    0 returned 100%
     3715: 1165:}
        -: 1166:
        -: 1167://===----------------------------------------------------------------------===//
        -: 1168:// Verifiers for casts between integers and floats.
        -: 1169://===----------------------------------------------------------------------===//
        -: 1170:
        -: 1171:template <typename From, typename To>
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
        -: 1178:
    #####: 1179:  return srcType && dstType;
        -: 1180:}
------------------
_Z17checkIntFloatCastIN4mlir9FloatTypeENS0_11IntegerTypeEEbNS0_9TypeRangeES3_:
function _Z17checkIntFloatCastIN4mlir9FloatTypeENS0_11IntegerTypeEEbNS0_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
call    0 never executed
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
call    0 never executed
        -: 1178:
    #####: 1179:  return srcType && dstType;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1180:}
------------------
_Z17checkIntFloatCastIN4mlir11IntegerTypeENS0_9FloatTypeEEbNS0_9TypeRangeES3_:
function _Z17checkIntFloatCastIN4mlir11IntegerTypeENS0_9FloatTypeEEbNS0_9TypeRangeES3_ called 0 returned 0% blocks executed 0%
    #####: 1172:static bool checkIntFloatCast(TypeRange inputs, TypeRange outputs) {
    #####: 1173:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1174:    return false;
        -: 1175:
    #####: 1176:  auto srcType = getTypeIfLike<From>(inputs.front());
call    0 never executed
    #####: 1177:  auto dstType = getTypeIfLike<To>(outputs.back());
call    0 never executed
        -: 1178:
    #####: 1179:  return srcType && dstType;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1180:}
------------------
        -: 1181:
        -: 1182://===----------------------------------------------------------------------===//
        -: 1183:// UIToFPOp
        -: 1184://===----------------------------------------------------------------------===//
        -: 1185:
function _ZN4mlir5arith8UIToFPOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1186:bool arith::UIToFPOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1187:  return checkIntFloatCast<IntegerType, FloatType>(inputs, outputs);
call    0 never executed
        -: 1188:}
        -: 1189:
function _ZN4mlir5arith8UIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1190:OpFoldResult arith::UIToFPOp::fold(ArrayRef<Attribute> operands) {
    #####: 1191:  Type resType = getType();
call    0 never executed
    #####: 1192:  Type resEleType;
    #####: 1193:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1194:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1195:  else
    #####: 1196:    resEleType = resType;
    #####: 1197:  return constFoldCastOp<IntegerAttr, FloatAttr>(
function _ZZN4mlir5arith8UIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1198:      operands, getType(), [&resEleType](const APInt &a, bool &castStatus) {
    #####: 1199:        FloatType floatTy = resEleType.cast<FloatType>();
call    0 never executed
    #####: 1200:        APFloat apf(floatTy.getFloatSemantics(),
    #####: 1201:                    APInt::getZero(floatTy.getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1202:        apf.convertFromAPInt(a, /*IsSigned=*/false,
call    0 never executed
        -: 1203:                             APFloat::rmNearestTiesToEven);
    #####: 1204:        return apf;
    #####: 1205:      });
call    0 never executed
call    1 never executed
        -: 1206:}
        -: 1207:
        -: 1208://===----------------------------------------------------------------------===//
        -: 1209:// SIToFPOp
        -: 1210://===----------------------------------------------------------------------===//
        -: 1211:
function _ZN4mlir5arith8SIToFPOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1212:bool arith::SIToFPOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1213:  return checkIntFloatCast<IntegerType, FloatType>(inputs, outputs);
call    0 never executed
        -: 1214:}
        -: 1215:
function _ZN4mlir5arith8SIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1216:OpFoldResult arith::SIToFPOp::fold(ArrayRef<Attribute> operands) {
    #####: 1217:  Type resType = getType();
call    0 never executed
    #####: 1218:  Type resEleType;
    #####: 1219:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1220:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1221:  else
    #####: 1222:    resEleType = resType;
    #####: 1223:  return constFoldCastOp<IntegerAttr, FloatAttr>(
function _ZZN4mlir5arith8SIToFPOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1224:      operands, getType(), [&resEleType](const APInt &a, bool &castStatus) {
    #####: 1225:        FloatType floatTy = resEleType.cast<FloatType>();
call    0 never executed
    #####: 1226:        APFloat apf(floatTy.getFloatSemantics(),
    #####: 1227:                    APInt::getZero(floatTy.getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1228:        apf.convertFromAPInt(a, /*IsSigned=*/true,
call    0 never executed
        -: 1229:                             APFloat::rmNearestTiesToEven);
    #####: 1230:        return apf;
    #####: 1231:      });
call    0 never executed
call    1 never executed
        -: 1232:}
        -: 1233://===----------------------------------------------------------------------===//
        -: 1234:// FPToUIOp
        -: 1235://===----------------------------------------------------------------------===//
        -: 1236:
function _ZN4mlir5arith8FPToUIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1237:bool arith::FPToUIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1238:  return checkIntFloatCast<FloatType, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1239:}
        -: 1240:
function _ZN4mlir5arith8FPToUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1241:OpFoldResult arith::FPToUIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1242:  Type resType = getType();
call    0 never executed
    #####: 1243:  Type resEleType;
    #####: 1244:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1245:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1246:  else
    #####: 1247:    resEleType = resType;
    #####: 1248:  return constFoldCastOp<FloatAttr, IntegerAttr>(
function _ZZN4mlir5arith8FPToUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_7APFloatERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1249:      operands, getType(), [&resEleType](const APFloat &a, bool &castStatus) {
    #####: 1250:        IntegerType intTy = resEleType.cast<IntegerType>();
call    0 never executed
    #####: 1251:        bool ignored;
    #####: 1252:        APSInt api(intTy.getWidth(), /*isUnsigned=*/true);
call    0 never executed
call    1 never executed
    #####: 1253:        castStatus = APFloat::opInvalidOp !=
    #####: 1254:                     a.convertToInteger(api, APFloat::rmTowardZero, &ignored);
call    0 never executed
    #####: 1255:        return api;
    #####: 1256:      });
call    0 never executed
call    1 never executed
        -: 1257:}
        -: 1258:
        -: 1259://===----------------------------------------------------------------------===//
        -: 1260:// FPToSIOp
        -: 1261://===----------------------------------------------------------------------===//
        -: 1262:
function _ZN4mlir5arith8FPToSIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1263:bool arith::FPToSIOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1264:  return checkIntFloatCast<FloatType, IntegerType>(inputs, outputs);
call    0 never executed
        -: 1265:}
        -: 1266:
function _ZN4mlir5arith8FPToSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1267:OpFoldResult arith::FPToSIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1268:  Type resType = getType();
call    0 never executed
    #####: 1269:  Type resEleType;
    #####: 1270:  if (auto shapedType = resType.dyn_cast<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1271:    resEleType = shapedType.getElementType();
call    0 never executed
        -: 1272:  else
    #####: 1273:    resEleType = resType;
    #####: 1274:  return constFoldCastOp<FloatAttr, IntegerAttr>(
function _ZZN4mlir5arith8FPToSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_7APFloatERbE_clES8_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1275:      operands, getType(), [&resEleType](const APFloat &a, bool &castStatus) {
    #####: 1276:        IntegerType intTy = resEleType.cast<IntegerType>();
call    0 never executed
    #####: 1277:        bool ignored;
    #####: 1278:        APSInt api(intTy.getWidth(), /*isUnsigned=*/false);
call    0 never executed
call    1 never executed
    #####: 1279:        castStatus = APFloat::opInvalidOp !=
    #####: 1280:                     a.convertToInteger(api, APFloat::rmTowardZero, &ignored);
call    0 never executed
    #####: 1281:        return api;
    #####: 1282:      });
call    0 never executed
call    1 never executed
        -: 1283:}
        -: 1284:
        -: 1285://===----------------------------------------------------------------------===//
        -: 1286:// IndexCastOp
        -: 1287://===----------------------------------------------------------------------===//
        -: 1288:
function _ZL22areIndexCastCompatibleN4mlir9TypeRangeES0_ called 0 returned 0% blocks executed 0%
    #####: 1289:static bool areIndexCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1290:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1291:    return false;
        -: 1292:
    #####: 1293:  auto srcType = getTypeIfLikeOrMemRef<IntegerType, IndexType>(inputs.front());
call    0 never executed
    #####: 1294:  auto dstType = getTypeIfLikeOrMemRef<IntegerType, IndexType>(outputs.front());
call    0 never executed
    #####: 1295:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1296:    return false;
        -: 1297:
    #####: 1298:  return (srcType.isIndex() && dstType.isSignlessInteger()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1299:         (srcType.isSignlessInteger() && dstType.isIndex());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1300:}
        -: 1301:
function _ZN4mlir5arith11IndexCastOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1302:bool arith::IndexCastOp::areCastCompatible(TypeRange inputs,
        -: 1303:                                           TypeRange outputs) {
    #####: 1304:  return areIndexCastCompatible(inputs, outputs);
call    0 never executed
        -: 1305:}
        -: 1306:
function _ZN4mlir5arith11IndexCastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1307:OpFoldResult arith::IndexCastOp::fold(ArrayRef<Attribute> operands) {
        -: 1308:  // index_cast(constant) -> constant
        -: 1309:  // A little hack because we go through int. Otherwise, the size of the
        -: 1310:  // constant might need to change.
    #####: 1311:  if (auto value = operands[0].dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1312:    return IntegerAttr::get(getType(), value.getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1313:
    #####: 1314:  return {};
        -: 1315:}
        -: 1316:
function _ZN4mlir5arith11IndexCastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3708 returned 100% blocks executed 100%
     3708: 1317:void arith::IndexCastOp::getCanonicalizationPatterns(
        -: 1318:    RewritePatternSet &patterns, MLIRContext *context) {
     3708: 1319:  patterns.add<IndexCastOfIndexCast, IndexCastOfExtSI>(context);
call    0 returned 100%
     3710: 1320:}
        -: 1321:
        -: 1322://===----------------------------------------------------------------------===//
        -: 1323:// IndexCastUIOp
        -: 1324://===----------------------------------------------------------------------===//
        -: 1325:
function _ZN4mlir5arith13IndexCastUIOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1326:bool arith::IndexCastUIOp::areCastCompatible(TypeRange inputs,
        -: 1327:                                             TypeRange outputs) {
    #####: 1328:  return areIndexCastCompatible(inputs, outputs);
call    0 never executed
        -: 1329:}
        -: 1330:
function _ZN4mlir5arith13IndexCastUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1331:OpFoldResult arith::IndexCastUIOp::fold(ArrayRef<Attribute> operands) {
        -: 1332:  // index_castui(constant) -> constant
        -: 1333:  // A little hack because we go through int. Otherwise, the size of the
        -: 1334:  // constant might need to change.
    #####: 1335:  if (auto value = operands[0].dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1336:    return IntegerAttr::get(getType(), value.getValue().getZExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1337:
    #####: 1338:  return {};
        -: 1339:}
        -: 1340:
function _ZN4mlir5arith13IndexCastUIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3706 returned 100% blocks executed 100%
     3706: 1341:void arith::IndexCastUIOp::getCanonicalizationPatterns(
        -: 1342:    RewritePatternSet &patterns, MLIRContext *context) {
     3706: 1343:  patterns.add<IndexCastUIOfIndexCastUI, IndexCastUIOfExtUI>(context);
call    0 returned 100%
     3712: 1344:}
        -: 1345:
        -: 1346://===----------------------------------------------------------------------===//
        -: 1347:// BitcastOp
        -: 1348://===----------------------------------------------------------------------===//
        -: 1349:
function _ZN4mlir5arith9BitcastOp17areCastCompatibleENS_9TypeRangeES2_ called 0 returned 0% blocks executed 0%
    #####: 1350:bool arith::BitcastOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {
    #####: 1351:  if (!areValidCastInputsAndOutputs(inputs, outputs))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1352:    return false;
        -: 1353:
    #####: 1354:  auto srcType =
    #####: 1355:      getTypeIfLikeOrMemRef<IntegerType, IndexType, FloatType>(inputs.front());
call    0 never executed
    #####: 1356:  auto dstType =
    #####: 1357:      getTypeIfLikeOrMemRef<IntegerType, IndexType, FloatType>(outputs.front());
call    0 never executed
    #####: 1358:  if (!srcType || !dstType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1359:    return false;
        -: 1360:
    #####: 1361:  return srcType.getIntOrFloatBitWidth() == dstType.getIntOrFloatBitWidth();
call    0 never executed
call    1 never executed
        -: 1362:}
        -: 1363:
function _ZN4mlir5arith9BitcastOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1364:OpFoldResult arith::BitcastOp::fold(ArrayRef<Attribute> operands) {
    #####: 1365:  assert(operands.size() == 1 && "bitcast op expects 1 operand");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1366:
    #####: 1367:  auto resType = getType();
branch  0 never executed
branch  1 never executed
    #####: 1368:  auto operand = operands[0];
branch  0 never executed
branch  1 never executed
    #####: 1369:  if (!operand)
branch  0 never executed
branch  1 never executed
    #####: 1370:    return {};
        -: 1371:
        -: 1372:  /// Bitcast dense elements.
    #####: 1373:  if (auto denseAttr = operand.dyn_cast_or_null<DenseElementsAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1374:    return denseAttr.bitcast(resType.cast<ShapedType>().getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1375:  /// Other shaped types unhandled.
    #####: 1376:  if (resType.isa<ShapedType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1377:    return {};
        -: 1378:
        -: 1379:  /// Bitcast integer or float to integer or float.
    #####: 1380:  APInt bits = operand.isa<FloatAttr>()
call    0 never executed
    #####: 1381:                   ? operand.cast<FloatAttr>().getValue().bitcastToAPInt()
call    0 never executed
    #####: 1382:                   : operand.cast<IntegerAttr>().getValue();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1383:
    #####: 1384:  if (auto resFloatType = resType.dyn_cast<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1385:    return FloatAttr::get(resType,
    #####: 1386:                          APFloat(resFloatType.getFloatSemantics(), bits));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1387:  return IntegerAttr::get(resType, bits);
call    0 never executed
call    1 never executed
        -: 1388:}
        -: 1389:
function _ZN4mlir5arith9BitcastOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3706 returned 100% blocks executed 100%
     3706: 1390:void arith::BitcastOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1391:                                                   MLIRContext *context) {
     3706: 1392:  patterns.add<BitcastOfBitcast>(context);
call    0 returned 100%
     3715: 1393:}
        -: 1394:
        -: 1395://===----------------------------------------------------------------------===//
        -: 1396:// Helpers for compare ops
        -: 1397://===----------------------------------------------------------------------===//
        -: 1398:
        -: 1399:/// Return the type of the same shape (scalar, vector or tensor) containing i1.
function _ZL14getI1SameShapeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####: 1400:static Type getI1SameShape(Type type) {
    #####: 1401:  auto i1Type = IntegerType::get(type.getContext(), 1);
call    0 never executed
call    1 never executed
    #####: 1402:  if (auto tensorType = type.dyn_cast<RankedTensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1403:    return RankedTensorType::get(tensorType.getShape(), i1Type);
call    0 never executed
call    1 never executed
    #####: 1404:  if (type.isa<UnrankedTensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1405:    return UnrankedTensorType::get(i1Type);
call    0 never executed
    #####: 1406:  if (auto vectorType = type.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1407:    return VectorType::get(vectorType.getShape(), i1Type,
    #####: 1408:                           vectorType.getNumScalableDims());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1409:  return i1Type;
        -: 1410:}
        -: 1411:
        -: 1412://===----------------------------------------------------------------------===//
        -: 1413:// CmpIOp
        -: 1414://===----------------------------------------------------------------------===//
        -: 1415:
        -: 1416:/// Compute `lhs` `pred` `rhs`, where `pred` is one of the known integer
        -: 1417:/// comparison predicates.
function _ZN4mlir5arith17applyCmpPredicateENS0_13CmpIPredicateERKN4llvm5APIntES5_ called 0 returned 0% blocks executed 0%
    #####: 1418:bool mlir::arith::applyCmpPredicate(arith::CmpIPredicate predicate,
        -: 1419:                                    const APInt &lhs, const APInt &rhs) {
    #####: 1420:  switch (predicate) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1421:  case arith::CmpIPredicate::eq:
    #####: 1422:    return lhs.eq(rhs);
call    0 never executed
    #####: 1423:  case arith::CmpIPredicate::ne:
    #####: 1424:    return lhs.ne(rhs);
call    0 never executed
    #####: 1425:  case arith::CmpIPredicate::slt:
    #####: 1426:    return lhs.slt(rhs);
    #####: 1427:  case arith::CmpIPredicate::sle:
    #####: 1428:    return lhs.sle(rhs);
    #####: 1429:  case arith::CmpIPredicate::sgt:
    #####: 1430:    return lhs.sgt(rhs);
    #####: 1431:  case arith::CmpIPredicate::sge:
    #####: 1432:    return lhs.sge(rhs);
    #####: 1433:  case arith::CmpIPredicate::ult:
    #####: 1434:    return lhs.ult(rhs);
    #####: 1435:  case arith::CmpIPredicate::ule:
    #####: 1436:    return lhs.ule(rhs);
    #####: 1437:  case arith::CmpIPredicate::ugt:
    #####: 1438:    return lhs.ugt(rhs);
    #####: 1439:  case arith::CmpIPredicate::uge:
    #####: 1440:    return lhs.uge(rhs);
        -: 1441:  }
    #####: 1442:  llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1443:}
        -: 1444:
        -: 1445:/// Returns true if the predicate is true for two equal operands.
function _ZL32applyCmpPredicateToEqualOperandsN4mlir5arith13CmpIPredicateE called 0 returned 0% blocks executed 0%
    #####: 1446:static bool applyCmpPredicateToEqualOperands(arith::CmpIPredicate predicate) {
    #####: 1447:  switch (predicate) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1448:  case arith::CmpIPredicate::eq:
        -: 1449:  case arith::CmpIPredicate::sle:
        -: 1450:  case arith::CmpIPredicate::sge:
        -: 1451:  case arith::CmpIPredicate::ule:
        -: 1452:  case arith::CmpIPredicate::uge:
        -: 1453:    return true;
    #####: 1454:  case arith::CmpIPredicate::ne:
    #####: 1455:  case arith::CmpIPredicate::slt:
    #####: 1456:  case arith::CmpIPredicate::sgt:
    #####: 1457:  case arith::CmpIPredicate::ult:
    #####: 1458:  case arith::CmpIPredicate::ugt:
    #####: 1459:    return false;
        -: 1460:  }
    #####: 1461:  llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1462:}
        -: 1463:
function _ZL16getBoolAttributeN4mlir4TypeEPNS_11MLIRContextEb called 0 returned 0% blocks executed 0%
    #####: 1464:static Attribute getBoolAttribute(Type type, MLIRContext *ctx, bool value) {
    #####: 1465:  auto boolAttr = BoolAttr::get(ctx, value);
call    0 never executed
    #####: 1466:  ShapedType shapedType = type.dyn_cast_or_null<ShapedType>();
branch  0 never executed
branch  1 never executed
    #####: 1467:  if (!shapedType)
branch  0 never executed
branch  1 never executed
    #####: 1468:    return boolAttr;
    #####: 1469:  return DenseElementsAttr::get(shapedType, boolAttr);
call    0 never executed
        -: 1470:}
        -: 1471:
function _ZN4mlir5arith6CmpIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1472:OpFoldResult arith::CmpIOp::fold(ArrayRef<Attribute> operands) {
    #####: 1473:  assert(operands.size() == 2 && "cmpi takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1474:
        -: 1475:  // cmpi(pred, x, x)
    #####: 1476:  if (getLhs() == getRhs()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1477:    auto val = applyCmpPredicateToEqualOperands(getPredicate());
call    0 never executed
call    1 never executed
    #####: 1478:    return getBoolAttribute(getType(), getContext(), val);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1479:  }
        -: 1480:
    #####: 1481:  if (matchPattern(getRhs(), m_Zero())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1482:    if (auto extOp = getLhs().getDefiningOp<ExtSIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1483:      // extsi(%x : i1 -> iN) != 0  ->  %x
    #####: 1484:      if (extOp.getOperand().getType().cast<IntegerType>().getWidth() == 1 &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1485:          getPredicate() == arith::CmpIPredicate::ne)
branch  0 never executed
branch  1 never executed
    #####: 1486:        return extOp.getOperand();
call    0 never executed
call    1 never executed
        -: 1487:    }
    #####: 1488:    if (auto extOp = getLhs().getDefiningOp<ExtUIOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1489:      // extui(%x : i1 -> iN) != 0  ->  %x
    #####: 1490:      if (extOp.getOperand().getType().cast<IntegerType>().getWidth() == 1 &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1491:          getPredicate() == arith::CmpIPredicate::ne)
branch  0 never executed
branch  1 never executed
    #####: 1492:        return extOp.getOperand();
call    0 never executed
call    1 never executed
        -: 1493:    }
        -: 1494:  }
        -: 1495:
        -: 1496:  // Move constant to the right side.
    #####: 1497:  if (operands[0] && !operands[1]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1498:    // Do not use invertPredicate, as it will change eq to ne and vice versa.
    #####: 1499:    using Pred = CmpIPredicate;
    #####: 1500:    const std::pair<Pred, Pred> invPreds[] = {
        -: 1501:        {Pred::slt, Pred::sgt}, {Pred::sgt, Pred::slt}, {Pred::sle, Pred::sge},
        -: 1502:        {Pred::sge, Pred::sle}, {Pred::ult, Pred::ugt}, {Pred::ugt, Pred::ult},
        -: 1503:        {Pred::ule, Pred::uge}, {Pred::uge, Pred::ule}, {Pred::eq, Pred::eq},
        -: 1504:        {Pred::ne, Pred::ne},
        -: 1505:    };
    #####: 1506:    Pred origPred = getPredicate();
call    0 never executed
    #####: 1507:    for (auto pred : invPreds) {
branch  0 never executed
branch  1 never executed
    #####: 1508:      if (origPred == pred.first) {
branch  0 never executed
branch  1 never executed
    #####: 1509:        setPredicate(pred.second);
call    0 never executed
    #####: 1510:        Value lhs = getLhs();
call    0 never executed
    #####: 1511:        Value rhs = getRhs();
call    0 never executed
    #####: 1512:        getLhsMutable().assign(rhs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1513:        getRhsMutable().assign(lhs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1514:        return getResult();
call    0 never executed
call    1 never executed
        -: 1515:      }
        -: 1516:    }
    #####: 1517:    llvm_unreachable("unknown cmpi predicate kind");
call    0 never executed
        -: 1518:  }
        -: 1519:
    #####: 1520:  auto lhs = operands.front().dyn_cast_or_null<IntegerAttr>();
branch  0 never executed
branch  1 never executed
    #####: 1521:  if (!lhs)
branch  0 never executed
branch  1 never executed
    #####: 1522:    return {};
        -: 1523:
        -: 1524:  // We are moving constants to the right side; So if lhs is constant rhs is
        -: 1525:  // guaranteed to be a constant.
    #####: 1526:  auto rhs = operands.back().cast<IntegerAttr>();
call    0 never executed
call    1 never executed
        -: 1527:
    #####: 1528:  auto val = applyCmpPredicate(getPredicate(), lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1529:  return BoolAttr::get(getContext(), val);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1530:}
        -: 1531:
function _ZN4mlir5arith6CmpIOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3708 returned 100% blocks executed 100%
     3708: 1532:void arith::CmpIOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1533:                                                MLIRContext *context) {
     3708: 1534:  patterns.insert<CmpIExtSI, CmpIExtUI>(context);
call    0 returned 100%
     3713: 1535:}
        -: 1536:
        -: 1537://===----------------------------------------------------------------------===//
        -: 1538:// CmpFOp
        -: 1539://===----------------------------------------------------------------------===//
        -: 1540:
        -: 1541:/// Compute `lhs` `pred` `rhs`, where `pred` is one of the known floating point
        -: 1542:/// comparison predicates.
function _ZN4mlir5arith17applyCmpPredicateENS0_13CmpFPredicateERKN4llvm7APFloatES5_ called 0 returned 0% blocks executed 0%
    #####: 1543:bool mlir::arith::applyCmpPredicate(arith::CmpFPredicate predicate,
        -: 1544:                                    const APFloat &lhs, const APFloat &rhs) {
    #####: 1545:  auto cmpResult = lhs.compare(rhs);
call    0 never executed
    #####: 1546:  switch (predicate) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
        -: 1547:  case arith::CmpFPredicate::AlwaysFalse:
        -: 1548:    return false;
    #####: 1549:  case arith::CmpFPredicate::OEQ:
    #####: 1550:    return cmpResult == APFloat::cmpEqual;
    #####: 1551:  case arith::CmpFPredicate::OGT:
    #####: 1552:    return cmpResult == APFloat::cmpGreaterThan;
    #####: 1553:  case arith::CmpFPredicate::OGE:
    #####: 1554:    return cmpResult == APFloat::cmpGreaterThan ||
    #####: 1555:           cmpResult == APFloat::cmpEqual;
    #####: 1556:  case arith::CmpFPredicate::OLT:
    #####: 1557:    return cmpResult == APFloat::cmpLessThan;
    #####: 1558:  case arith::CmpFPredicate::OLE:
    #####: 1559:    return cmpResult == APFloat::cmpLessThan || cmpResult == APFloat::cmpEqual;
    #####: 1560:  case arith::CmpFPredicate::ONE:
    #####: 1561:    return cmpResult != APFloat::cmpUnordered && cmpResult != APFloat::cmpEqual;
    #####: 1562:  case arith::CmpFPredicate::ORD:
    #####: 1563:    return cmpResult != APFloat::cmpUnordered;
    #####: 1564:  case arith::CmpFPredicate::UEQ:
    #####: 1565:    return cmpResult == APFloat::cmpUnordered || cmpResult == APFloat::cmpEqual;
    #####: 1566:  case arith::CmpFPredicate::UGT:
    #####: 1567:    return cmpResult == APFloat::cmpUnordered ||
    #####: 1568:           cmpResult == APFloat::cmpGreaterThan;
    #####: 1569:  case arith::CmpFPredicate::UGE:
    #####: 1570:    return cmpResult == APFloat::cmpUnordered ||
    #####: 1571:           cmpResult == APFloat::cmpGreaterThan ||
    #####: 1572:           cmpResult == APFloat::cmpEqual;
    #####: 1573:  case arith::CmpFPredicate::ULT:
    #####: 1574:    return cmpResult == APFloat::cmpUnordered ||
    #####: 1575:           cmpResult == APFloat::cmpLessThan;
    #####: 1576:  case arith::CmpFPredicate::ULE:
    #####: 1577:    return cmpResult == APFloat::cmpUnordered ||
    #####: 1578:           cmpResult == APFloat::cmpLessThan || cmpResult == APFloat::cmpEqual;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1579:  case arith::CmpFPredicate::UNE:
    #####: 1580:    return cmpResult != APFloat::cmpEqual;
    #####: 1581:  case arith::CmpFPredicate::UNO:
    #####: 1582:    return cmpResult == APFloat::cmpUnordered;
    #####: 1583:  case arith::CmpFPredicate::AlwaysTrue:
    #####: 1584:    return true;
        -: 1585:  }
    #####: 1586:  llvm_unreachable("unknown cmpf predicate kind");
call    0 never executed
        -: 1587:}
        -: 1588:
function _ZN4mlir5arith6CmpFOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1589:OpFoldResult arith::CmpFOp::fold(ArrayRef<Attribute> operands) {
    #####: 1590:  assert(operands.size() == 2 && "cmpf takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1591:
    #####: 1592:  auto lhs = operands.front().dyn_cast_or_null<FloatAttr>();
branch  0 never executed
branch  1 never executed
    #####: 1593:  auto rhs = operands.back().dyn_cast_or_null<FloatAttr>();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1594:
        -: 1595:  // If one operand is NaN, making them both NaN does not change the result.
    #####: 1596:  if (lhs && lhs.getValue().isNaN())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1597:    rhs = lhs;
    #####: 1598:  if (rhs && rhs.getValue().isNaN())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1599:    lhs = rhs;
        -: 1600:
    #####: 1601:  if (!lhs || !rhs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1602:    return {};
        -: 1603:
    #####: 1604:  auto val = applyCmpPredicate(getPredicate(), lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1605:  return BoolAttr::get(getContext(), val);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1606:}
        -: 1607:
        -: 1608:class CmpFIntToFPConst final : public OpRewritePattern<CmpFOp> {
        -: 1609:public:
        -: 1610:  using OpRewritePattern<CmpFOp>::OpRewritePattern;
        -: 1611:
function _ZN16CmpFIntToFPConst25convertToIntegerPredicateEN4mlir5arith13CmpFPredicateEb called 0 returned 0% blocks executed 0%
    #####: 1612:  static CmpIPredicate convertToIntegerPredicate(CmpFPredicate pred,
        -: 1613:                                                 bool isUnsigned) {
    #####: 1614:    using namespace arith;
    #####: 1615:    switch (pred) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1616:    case CmpFPredicate::UEQ:
        -: 1617:    case CmpFPredicate::OEQ:
        -: 1618:      return CmpIPredicate::eq;
    #####: 1619:    case CmpFPredicate::UGT:
    #####: 1620:    case CmpFPredicate::OGT:
    #####: 1621:      return isUnsigned ? CmpIPredicate::ugt : CmpIPredicate::sgt;
branch  0 never executed
branch  1 never executed
    #####: 1622:    case CmpFPredicate::UGE:
    #####: 1623:    case CmpFPredicate::OGE:
    #####: 1624:      return isUnsigned ? CmpIPredicate::uge : CmpIPredicate::sge;
branch  0 never executed
branch  1 never executed
    #####: 1625:    case CmpFPredicate::ULT:
    #####: 1626:    case CmpFPredicate::OLT:
    #####: 1627:      return isUnsigned ? CmpIPredicate::ult : CmpIPredicate::slt;
branch  0 never executed
branch  1 never executed
    #####: 1628:    case CmpFPredicate::ULE:
    #####: 1629:    case CmpFPredicate::OLE:
    #####: 1630:      return isUnsigned ? CmpIPredicate::ule : CmpIPredicate::sle;
branch  0 never executed
branch  1 never executed
    #####: 1631:    case CmpFPredicate::UNE:
    #####: 1632:    case CmpFPredicate::ONE:
    #####: 1633:      return CmpIPredicate::ne;
    #####: 1634:    default:
    #####: 1635:      llvm_unreachable("Unexpected predicate!");
call    0 never executed
        -: 1636:    }
        -: 1637:  }
        -: 1638:
function _ZNK16CmpFIntToFPConst15matchAndRewriteEN4mlir5arith6CmpFOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1639:  LogicalResult matchAndRewrite(CmpFOp op,
        -: 1640:                                PatternRewriter &rewriter) const override {
    #####: 1641:    FloatAttr flt;
    #####: 1642:    if (!matchPattern(op.getRhs(), m_Constant(&flt)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1643:      return failure();
        -: 1644:
    #####: 1645:    const APFloat &rhs = flt.getValue();
call    0 never executed
        -: 1646:
        -: 1647:    // Don't attempt to fold a nan.
    #####: 1648:    if (rhs.isNaN())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1649:      return failure();
        -: 1650:
        -: 1651:    // Get the width of the mantissa.  We don't want to hack on conversions that
        -: 1652:    // might lose information from the integer, e.g. "i64 -> float"
    #####: 1653:    FloatType floatTy = op.getRhs().getType().cast<FloatType>();
call    0 never executed
call    1 never executed
    #####: 1654:    int mantissaWidth = floatTy.getFPMantissaWidth();
call    0 never executed
    #####: 1655:    if (mantissaWidth <= 0)
branch  0 never executed
branch  1 never executed
    #####: 1656:      return failure();
        -: 1657:
    #####: 1658:    bool isUnsigned;
    #####: 1659:    Value intVal;
        -: 1660:
    #####: 1661:    if (auto si = op.getLhs().getDefiningOp<SIToFPOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1662:      isUnsigned = false;
    #####: 1663:      intVal = si.getIn();
call    0 never executed
    #####: 1664:    } else if (auto ui = op.getLhs().getDefiningOp<UIToFPOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1665:      isUnsigned = true;
    #####: 1666:      intVal = ui.getIn();
call    0 never executed
        -: 1667:    } else {
    #####: 1668:      return failure();
        -: 1669:    }
        -: 1670:
        -: 1671:    // Check to see that the input is converted from an integer type that is
        -: 1672:    // small enough that preserves all bits.
    #####: 1673:    auto intTy = intVal.getType().cast<IntegerType>();
call    0 never executed
    #####: 1674:    auto intWidth = intTy.getWidth();
call    0 never executed
        -: 1675:
        -: 1676:    // Number of bits representing values, as opposed to the sign
    #####: 1677:    auto valueBits = isUnsigned ? intWidth : (intWidth - 1);
branch  0 never executed
branch  1 never executed
        -: 1678:
        -: 1679:    // Following test does NOT adjust intWidth downwards for signed inputs,
        -: 1680:    // because the most negative value still requires all the mantissa bits
        -: 1681:    // to distinguish it from one less than that value.
    #####: 1682:    if ((int)intWidth > mantissaWidth) {
branch  0 never executed
branch  1 never executed
        -: 1683:      // Conversion would lose accuracy. Check if loss can impact comparison.
    #####: 1684:      int exponent = ilogb(rhs);
call    0 never executed
    #####: 1685:      if (exponent == APFloat::IEK_Inf) {
branch  0 never executed
branch  1 never executed
    #####: 1686:        int maxExponent = ilogb(APFloat::getLargest(rhs.getSemantics()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1687:        if (maxExponent < (int)valueBits) {
branch  0 never executed
branch  1 never executed
        -: 1688:          // Conversion could create infinity.
    #####: 1689:          return failure();
        -: 1690:        }
        -: 1691:      } else {
        -: 1692:        // Note that if rhs is zero or NaN, then Exp is negative
        -: 1693:        // and first condition is trivially false.
    #####: 1694:        if (mantissaWidth <= exponent && exponent <= (int)valueBits) {
branch  0 never executed
branch  1 never executed
        -: 1695:          // Conversion could affect comparison.
    #####: 1696:          return failure();
        -: 1697:        }
        -: 1698:      }
        -: 1699:    }
        -: 1700:
        -: 1701:    // Convert to equivalent cmpi predicate
    #####: 1702:    CmpIPredicate pred;
    #####: 1703:    switch (op.getPredicate()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1704:    case CmpFPredicate::ORD:
        -: 1705:      // Int to fp conversion doesn't create a nan (ord checks neither is a nan)
    #####: 1706:      rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1707:                                                 /*width=*/1);
call    0 never executed
    #####: 1708:      return success();
    #####: 1709:    case CmpFPredicate::UNO:
        -: 1710:      // Int to fp conversion doesn't create a nan (uno checks either is a nan)
    #####: 1711:      rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1712:                                                 /*width=*/1);
call    0 never executed
    #####: 1713:      return success();
    #####: 1714:    default:
    #####: 1715:      pred = convertToIntegerPredicate(op.getPredicate(), isUnsigned);
call    0 never executed
call    1 never executed
    #####: 1716:      break;
        -: 1717:    }
        -: 1718:
    #####: 1719:    if (!isUnsigned) {
branch  0 never executed
branch  1 never executed
        -: 1720:      // If the rhs value is > SignedMax, fold the comparison.  This handles
        -: 1721:      // +INF and large values.
    #####: 1722:      APFloat signedMax(rhs.getSemantics());
call    0 never executed
    #####: 1723:      signedMax.convertFromAPInt(APInt::getSignedMaxValue(intWidth), true,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1724:                                 APFloat::rmNearestTiesToEven);
    #####: 1725:      if (signedMax < rhs) { // smax < 13123.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1726:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::slt ||
branch  0 never executed
branch  1 never executed
        -: 1727:            pred == CmpIPredicate::sle)
    #####: 1728:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1729:                                                     /*width=*/1);
call    0 never executed
        -: 1730:        else
    #####: 1731:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1732:                                                     /*width=*/1);
call    0 never executed
    #####: 1733:        return success();
call    0 never executed
        -: 1734:      }
        -: 1735:    } else {
        -: 1736:      // If the rhs value is > UnsignedMax, fold the comparison. This handles
        -: 1737:      // +INF and large values.
    #####: 1738:      APFloat unsignedMax(rhs.getSemantics());
call    0 never executed
    #####: 1739:      unsignedMax.convertFromAPInt(APInt::getMaxValue(intWidth), false,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1740:                                   APFloat::rmNearestTiesToEven);
    #####: 1741:      if (unsignedMax < rhs) { // umax < 13123.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1742:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::ult ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1743:            pred == CmpIPredicate::ule)
    #####: 1744:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1745:                                                     /*width=*/1);
call    0 never executed
        -: 1746:        else
    #####: 1747:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1748:                                                     /*width=*/1);
call    0 never executed
    #####: 1749:        return success();
call    0 never executed
        -: 1750:      }
        -: 1751:    }
        -: 1752:
    #####: 1753:    if (!isUnsigned) {
branch  0 never executed
branch  1 never executed
        -: 1754:      // See if the rhs value is < SignedMin.
    #####: 1755:      APFloat signedMin(rhs.getSemantics());
call    0 never executed
    #####: 1756:      signedMin.convertFromAPInt(APInt::getSignedMinValue(intWidth), true,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1757:                                 APFloat::rmNearestTiesToEven);
    #####: 1758:      if (signedMin > rhs) { // smin > 12312.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1759:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::sgt ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1760:            pred == CmpIPredicate::sge)
    #####: 1761:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1762:                                                     /*width=*/1);
call    0 never executed
        -: 1763:        else
    #####: 1764:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1765:                                                     /*width=*/1);
call    0 never executed
    #####: 1766:        return success();
call    0 never executed
        -: 1767:      }
        -: 1768:    } else {
        -: 1769:      // See if the rhs value is < UnsignedMin.
    #####: 1770:      APFloat unsignedMin(rhs.getSemantics());
call    0 never executed
    #####: 1771:      unsignedMin.convertFromAPInt(APInt::getMinValue(intWidth), false,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1772:                                   APFloat::rmNearestTiesToEven);
    #####: 1773:      if (unsignedMin > rhs) { // umin > 12312.0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1774:        if (pred == CmpIPredicate::ne || pred == CmpIPredicate::ugt ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1775:            pred == CmpIPredicate::uge)
    #####: 1776:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1777:                                                     /*width=*/1);
call    0 never executed
        -: 1778:        else
    #####: 1779:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1780:                                                     /*width=*/1);
call    0 never executed
    #####: 1781:        return success();
call    0 never executed
        -: 1782:      }
        -: 1783:    }
        -: 1784:
        -: 1785:    // Okay, now we know that the FP constant fits in the range [SMIN, SMAX] or
        -: 1786:    // [0, UMAX], but it may still be fractional.  See if it is fractional by
        -: 1787:    // casting the FP value to the integer value and back, checking for
        -: 1788:    // equality. Don't do this for zero, because -0.0 is not fractional.
    #####: 1789:    bool ignored;
    #####: 1790:    APSInt rhsInt(intWidth, isUnsigned);
call    0 never executed
call    1 never executed
    #####: 1791:    if (APFloat::opInvalidOp ==
branch  0 never executed
branch  1 never executed
    #####: 1792:        rhs.convertToInteger(rhsInt, APFloat::rmTowardZero, &ignored)) {
call    0 never executed
        -: 1793:      // Undefined behavior invoked - the destination type can't represent
        -: 1794:      // the input constant.
    #####: 1795:      return failure();
        -: 1796:    }
        -: 1797:
    #####: 1798:    if (!rhs.isZero()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1799:      APFloat apf(floatTy.getFloatSemantics(),
    #####: 1800:                  APInt::getZero(floatTy.getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1801:      apf.convertFromAPInt(rhsInt, !isUnsigned, APFloat::rmNearestTiesToEven);
call    0 never executed
        -: 1802:
    #####: 1803:      bool equal = apf == rhs;
call    0 never executed
    #####: 1804:      if (!equal) {
branch  0 never executed
branch  1 never executed
        -: 1805:        // If we had a comparison against a fractional value, we have to adjust
        -: 1806:        // the compare predicate and sometimes the value.  rhsInt is rounded
        -: 1807:        // towards zero at this point.
    #####: 1808:        switch (pred) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1809:        case CmpIPredicate::ne: // (float)int != 4.4   --> true
    #####: 1810:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1811:                                                     /*width=*/1);
call    0 never executed
    #####: 1812:          return success();
    #####: 1813:        case CmpIPredicate::eq: // (float)int == 4.4   --> false
    #####: 1814:          rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1815:                                                     /*width=*/1);
call    0 never executed
    #####: 1816:          return success();
    #####: 1817:        case CmpIPredicate::ule:
        -: 1818:          // (float)int <= 4.4   --> int <= 4
        -: 1819:          // (float)int <= -4.4  --> false
    #####: 1820:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1821:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1822:                                                       /*width=*/1);
call    0 never executed
    #####: 1823:            return success();
        -: 1824:          }
        -: 1825:          break;
    #####: 1826:        case CmpIPredicate::sle:
        -: 1827:          // (float)int <= 4.4   --> int <= 4
        -: 1828:          // (float)int <= -4.4  --> int < -4
    #####: 1829:          if (rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1830:            pred = CmpIPredicate::slt;
        -: 1831:          break;
    #####: 1832:        case CmpIPredicate::ult:
        -: 1833:          // (float)int < -4.4   --> false
        -: 1834:          // (float)int < 4.4    --> int <= 4
    #####: 1835:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1836:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/false,
    #####: 1837:                                                       /*width=*/1);
call    0 never executed
    #####: 1838:            return success();
        -: 1839:          }
    #####: 1840:          pred = CmpIPredicate::ule;
    #####: 1841:          break;
    #####: 1842:        case CmpIPredicate::slt:
        -: 1843:          // (float)int < -4.4   --> int < -4
        -: 1844:          // (float)int < 4.4    --> int <= 4
    #####: 1845:          if (!rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1846:            pred = CmpIPredicate::sle;
        -: 1847:          break;
    #####: 1848:        case CmpIPredicate::ugt:
        -: 1849:          // (float)int > 4.4    --> int > 4
        -: 1850:          // (float)int > -4.4   --> true
    #####: 1851:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1852:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1853:                                                       /*width=*/1);
call    0 never executed
    #####: 1854:            return success();
        -: 1855:          }
        -: 1856:          break;
    #####: 1857:        case CmpIPredicate::sgt:
        -: 1858:          // (float)int > 4.4    --> int > 4
        -: 1859:          // (float)int > -4.4   --> int >= -4
    #####: 1860:          if (rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1861:            pred = CmpIPredicate::sge;
        -: 1862:          break;
    #####: 1863:        case CmpIPredicate::uge:
        -: 1864:          // (float)int >= -4.4   --> true
        -: 1865:          // (float)int >= 4.4    --> int > 4
    #####: 1866:          if (rhs.isNegative()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1867:            rewriter.replaceOpWithNewOp<ConstantIntOp>(op, /*value=*/true,
    #####: 1868:                                                       /*width=*/1);
call    0 never executed
    #####: 1869:            return success();
call    0 never executed
        -: 1870:          }
    #####: 1871:          pred = CmpIPredicate::ugt;
    #####: 1872:          break;
    #####: 1873:        case CmpIPredicate::sge:
        -: 1874:          // (float)int >= -4.4   --> int >= -4
        -: 1875:          // (float)int >= 4.4    --> int > 4
    #####: 1876:          if (!rhs.isNegative())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1877:            pred = CmpIPredicate::sgt;
        -: 1878:          break;
        -: 1879:        }
        -: 1880:      }
        -: 1881:    }
        -: 1882:
        -: 1883:    // Lower this FP comparison into an appropriate integer version of the
        -: 1884:    // comparison.
    #####: 1885:    rewriter.replaceOpWithNewOp<CmpIOp>(
        -: 1886:        op, pred, intVal,
    #####: 1887:        rewriter.create<ConstantOp>(
    #####: 1888:            op.getLoc(), intVal.getType(),
call    0 never executed
    #####: 1889:            rewriter.getIntegerAttr(intVal.getType(), rhsInt)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1890:    return success();
branch  0 never executed
branch  1 never executed
        -: 1891:  }
        -: 1892:};
        -: 1893:
function _ZN4mlir5arith6CmpFOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3707 returned 100% blocks executed 100%
     3707: 1894:void arith::CmpFOp::getCanonicalizationPatterns(RewritePatternSet &patterns,
        -: 1895:                                                MLIRContext *context) {
     3707: 1896:  patterns.insert<CmpFIntToFPConst>(context);
call    0 returned 100%
     3713: 1897:}
        -: 1898:
        -: 1899://===----------------------------------------------------------------------===//
        -: 1900:// SelectOp
        -: 1901://===----------------------------------------------------------------------===//
        -: 1902:
        -: 1903:// Transforms a select of a boolean to arithmetic operations
        -: 1904://
        -: 1905://  arith.select %arg, %x, %y : i1
        -: 1906://
        -: 1907://  becomes
        -: 1908://
        -: 1909://  and(%arg, %x) or and(!%arg, %y)
        -: 1910:struct SelectI1Simplify : public OpRewritePattern<arith::SelectOp> {
        -: 1911:  using OpRewritePattern<arith::SelectOp>::OpRewritePattern;
        -: 1912:
function _ZNK16SelectI1Simplify15matchAndRewriteEN4mlir5arith8SelectOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1913:  LogicalResult matchAndRewrite(arith::SelectOp op,
        -: 1914:                                PatternRewriter &rewriter) const override {
    #####: 1915:    if (!op.getType().isInteger(1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1916:      return failure();
        -: 1917:
    #####: 1918:    Value falseConstant =
    #####: 1919:        rewriter.create<arith::ConstantIntOp>(op.getLoc(), true, 1);
call    0 never executed
call    1 never executed
    #####: 1920:    Value notCondition = rewriter.create<arith::XOrIOp>(
    #####: 1921:        op.getLoc(), op.getCondition(), falseConstant);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1922:
    #####: 1923:    Value trueVal = rewriter.create<arith::AndIOp>(
    #####: 1924:        op.getLoc(), op.getCondition(), op.getTrueValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1925:    Value falseVal = rewriter.create<arith::AndIOp>(op.getLoc(), notCondition,
    #####: 1926:                                                    op.getFalseValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1927:    rewriter.replaceOpWithNewOp<arith::OrIOp>(op, trueVal, falseVal);
call    0 never executed
    #####: 1928:    return success();
        -: 1929:  }
        -: 1930:};
        -: 1931:
        -: 1932://  select %arg, %c1, %c0 => extui %arg
        -: 1933:struct SelectToExtUI : public OpRewritePattern<arith::SelectOp> {
        -: 1934:  using OpRewritePattern<arith::SelectOp>::OpRewritePattern;
        -: 1935:
function _ZNK13SelectToExtUI15matchAndRewriteEN4mlir5arith8SelectOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1936:  LogicalResult matchAndRewrite(arith::SelectOp op,
        -: 1937:                                PatternRewriter &rewriter) const override {
        -: 1938:    // Cannot extui i1 to i1, or i1 to f32
    #####: 1939:    if (!op.getType().isa<IntegerType>() || op.getType().isInteger(1))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1940:      return failure();
        -: 1941:
        -: 1942:    // select %x, c1, %c0 => extui %arg
    #####: 1943:    if (matchPattern(op.getTrueValue(), m_One()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1944:        matchPattern(op.getFalseValue(), m_Zero())) {
call    0 never executed
call    1 never executed
    #####: 1945:      rewriter.replaceOpWithNewOp<arith::ExtUIOp>(op, op.getType(),
call    0 never executed
    #####: 1946:                                                  op.getCondition());
call    0 never executed
call    1 never executed
    #####: 1947:      return success();
        -: 1948:    }
        -: 1949:
        -: 1950:    // select %x, c0, %c1 => extui (xor %arg, true)
    #####: 1951:    if (matchPattern(op.getTrueValue(), m_Zero()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1952:        matchPattern(op.getFalseValue(), m_One())) {
call    0 never executed
call    1 never executed
    #####: 1953:      rewriter.replaceOpWithNewOp<arith::ExtUIOp>(
    #####: 1954:          op, op.getType(),
call    0 never executed
    #####: 1955:          rewriter.create<arith::XOrIOp>(
    #####: 1956:              op.getLoc(), op.getCondition(),
    #####: 1957:              rewriter.create<arith::ConstantIntOp>(
    #####: 1958:                  op.getLoc(), 1, op.getCondition().getType())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1959:      return success();
        -: 1960:    }
        -: 1961:
    #####: 1962:    return failure();
        -: 1963:  }
        -: 1964:};
        -: 1965:
function _ZN4mlir5arith8SelectOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 3711 returned 100% blocks executed 100%
     3711: 1966:void arith::SelectOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1967:                                                  MLIRContext *context) {
     3711: 1968:  results.add<SelectI1Simplify, SelectToExtUI>(context);
call    0 returned 100%
     3714: 1969:}
        -: 1970:
function _ZN4mlir5arith8SelectOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 1971:OpFoldResult arith::SelectOp::fold(ArrayRef<Attribute> operands) {
    #####: 1972:  Value trueVal = getTrueValue();
call    0 never executed
    #####: 1973:  Value falseVal = getFalseValue();
call    0 never executed
    #####: 1974:  if (trueVal == falseVal)
branch  0 never executed
branch  1 never executed
    #####: 1975:    return trueVal;
call    0 never executed
        -: 1976:
    #####: 1977:  Value condition = getCondition();
call    0 never executed
        -: 1978:
        -: 1979:  // select true, %0, %1 => %0
    #####: 1980:  if (matchPattern(condition, m_One()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1981:    return trueVal;
call    0 never executed
        -: 1982:
        -: 1983:  // select false, %0, %1 => %1
    #####: 1984:  if (matchPattern(condition, m_Zero()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1985:    return falseVal;
call    0 never executed
        -: 1986:
        -: 1987:  // select %x, true, false => %x
    #####: 1988:  if (getType().isInteger(1) && matchPattern(getTrueValue(), m_One()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1989:      matchPattern(getFalseValue(), m_Zero()))
call    0 never executed
call    1 never executed
    #####: 1990:    return condition;
call    0 never executed
        -: 1991:
    #####: 1992:  if (auto cmp = dyn_cast_or_null<arith::CmpIOp>(condition.getDefiningOp())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1993:    auto pred = cmp.getPredicate();
call    0 never executed
    #####: 1994:    if (pred == arith::CmpIPredicate::eq || pred == arith::CmpIPredicate::ne) {
branch  0 never executed
branch  1 never executed
    #####: 1995:      auto cmpLhs = cmp.getLhs();
call    0 never executed
    #####: 1996:      auto cmpRhs = cmp.getRhs();
call    0 never executed
        -: 1997:
        -: 1998:      // %0 = arith.cmpi eq, %arg0, %arg1
        -: 1999:      // %1 = arith.select %0, %arg0, %arg1 => %arg1
        -: 2000:
        -: 2001:      // %0 = arith.cmpi ne, %arg0, %arg1
        -: 2002:      // %1 = arith.select %0, %arg0, %arg1 => %arg0
        -: 2003:
    #####: 2004:      if ((cmpLhs == trueVal && cmpRhs == falseVal) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2005:          (cmpRhs == trueVal && cmpLhs == falseVal))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2006:        return pred == arith::CmpIPredicate::ne ? trueVal : falseVal;
branch  0 never executed
branch  1 never executed
        -: 2007:    }
        -: 2008:  }
    #####: 2009:  return nullptr;
        -: 2010:}
        -: 2011:
function _ZN4mlir5arith8SelectOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2012:ParseResult SelectOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2013:  Type conditionType, resultType;
    #####: 2014:  SmallVector<OpAsmParser::UnresolvedOperand, 3> operands;
call    0 never executed
    #####: 2015:  if (parser.parseOperandList(operands, /*requiredOperandCount=*/3) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2016:      parser.parseOptionalAttrDict(result.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2017:      parser.parseColonType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2018:    return failure();
        -: 2019:
        -: 2020:  // Check for the explicit condition type if this is a masked tensor or vector.
    #####: 2021:  if (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2022:    conditionType = resultType;
    #####: 2023:    if (parser.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2024:      return failure();
        -: 2025:  } else {
    #####: 2026:    conditionType = parser.getBuilder().getI1Type();
call    0 never executed
call    1 never executed
        -: 2027:  }
        -: 2028:
    #####: 2029:  result.addTypes(resultType);
call    0 never executed
    #####: 2030:  return parser.resolveOperands(operands,
        -: 2031:                                {conditionType, resultType, resultType},
    #####: 2032:                                parser.getNameLoc(), result.operands);
call    0 never executed
call    1 never executed
        -: 2033:}
        -: 2034:
function _ZN4mlir5arith8SelectOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2035:void arith::SelectOp::print(OpAsmPrinter &p) {
    #####: 2036:  p << " " << getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2037:  p.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 2038:  p << " : ";
call    0 never executed
    #####: 2039:  if (ShapedType condType = getCondition().getType().dyn_cast<ShapedType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2040:    p << condType << ", ";
call    0 never executed
call    1 never executed
    #####: 2041:  p << getType();
call    0 never executed
    #####: 2042:}
        -: 2043:
function _ZN4mlir5arith8SelectOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2044:LogicalResult arith::SelectOp::verify() {
    #####: 2045:  Type conditionType = getCondition().getType();
call    0 never executed
call    1 never executed
    #####: 2046:  if (conditionType.isSignlessInteger(1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2047:    return success();
        -: 2048:
        -: 2049:  // If the result type is a vector or tensor, the type can be a mask with the
        -: 2050:  // same elements.
    #####: 2051:  Type resultType = getType();
call    0 never executed
    #####: 2052:  if (!resultType.isa<TensorType, VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2053:    return emitOpError() << "expected condition to be a signless i1, but got "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2054:                         << conditionType;
call    0 never executed
    #####: 2055:  Type shapedConditionType = getI1SameShape(resultType);
call    0 never executed
    #####: 2056:  if (conditionType != shapedConditionType) {
branch  0 never executed
branch  1 never executed
    #####: 2057:    return emitOpError() << "expected condition type to have the same shape "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2058:                            "as the result type, expected "
call    0 never executed
    #####: 2059:                         << shapedConditionType << ", but got "
call    0 never executed
call    1 never executed
    #####: 2060:                         << conditionType;
call    0 never executed
        -: 2061:  }
    #####: 2062:  return success();
        -: 2063:}
        -: 2064://===----------------------------------------------------------------------===//
        -: 2065:// ShLIOp
        -: 2066://===----------------------------------------------------------------------===//
        -: 2067:
function _ZN4mlir5arith6ShLIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2068:OpFoldResult arith::ShLIOp::fold(ArrayRef<Attribute> operands) {
        -: 2069:  // Don't fold if shifting more than the bit width.
    #####: 2070:  bool bounded = false;
    #####: 2071:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith6ShLIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2072:      operands, [&](const APInt &a, const APInt &b) {
    #####: 2073:        bounded = b.ule(b.getBitWidth());
call    0 never executed
    #####: 2074:        return a.shl(b);
call    0 never executed
    #####: 2075:      });
call    0 never executed
    #####: 2076:  return bounded ? result : Attribute();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2077:}
        -: 2078:
        -: 2079://===----------------------------------------------------------------------===//
        -: 2080:// ShRUIOp
        -: 2081://===----------------------------------------------------------------------===//
        -: 2082:
function _ZN4mlir5arith7ShRUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2083:OpFoldResult arith::ShRUIOp::fold(ArrayRef<Attribute> operands) {
        -: 2084:  // Don't fold if shifting more than the bit width.
    #####: 2085:  bool bounded = false;
    #####: 2086:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith7ShRUIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2087:      operands, [&](const APInt &a, const APInt &b) {
    #####: 2088:        bounded = b.ule(b.getBitWidth());
call    0 never executed
    #####: 2089:        return a.lshr(b);
call    0 never executed
    #####: 2090:      });
call    0 never executed
    #####: 2091:  return bounded ? result : Attribute();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2092:}
        -: 2093:
        -: 2094://===----------------------------------------------------------------------===//
        -: 2095:// ShRSIOp
        -: 2096://===----------------------------------------------------------------------===//
        -: 2097:
function _ZN4mlir5arith7ShRSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2098:OpFoldResult arith::ShRSIOp::fold(ArrayRef<Attribute> operands) {
        -: 2099:  // Don't fold if shifting more than the bit width.
    #####: 2100:  bool bounded = false;
    #####: 2101:  auto result = constFoldBinaryOp<IntegerAttr>(
function _ZZN4mlir5arith7ShRSIOp4foldEN4llvm8ArrayRefINS_9AttributeEEEENKUlRKNS2_5APIntES8_E_clES8_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2102:      operands, [&](const APInt &a, const APInt &b) {
    #####: 2103:        bounded = b.ule(b.getBitWidth());
call    0 never executed
    #####: 2104:        return a.ashr(b);
call    0 never executed
    #####: 2105:      });
call    0 never executed
    #####: 2106:  return bounded ? result : Attribute();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2107:}
        -: 2108:
        -: 2109://===----------------------------------------------------------------------===//
        -: 2110:// Atomic Enum
        -: 2111://===----------------------------------------------------------------------===//
        -: 2112:
        -: 2113:/// Returns the identity value attribute associated with an AtomicRMWKind op.
function _ZN4mlir5arith20getIdentityValueAttrENS0_13AtomicRMWKindENS_4TypeERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 2114:Attribute mlir::arith::getIdentityValueAttr(AtomicRMWKind kind, Type resultType,
        -: 2115:                                            OpBuilder &builder, Location loc) {
    #####: 2116:  switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 2117:  case AtomicRMWKind::maxf:
    #####: 2118:    return builder.getFloatAttr(
        -: 2119:        resultType,
    #####: 2120:        APFloat::getInf(resultType.cast<FloatType>().getFloatSemantics(),
call    0 never executed
call    1 never executed
    #####: 2121:                        /*Negative=*/true));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2122:  case AtomicRMWKind::addf:
    #####: 2123:  case AtomicRMWKind::addi:
    #####: 2124:  case AtomicRMWKind::maxu:
    #####: 2125:  case AtomicRMWKind::ori:
    #####: 2126:    return builder.getZeroAttr(resultType);
call    0 never executed
    #####: 2127:  case AtomicRMWKind::andi:
    #####: 2128:    return builder.getIntegerAttr(
        -: 2129:        resultType,
    #####: 2130:        APInt::getAllOnes(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2131:  case AtomicRMWKind::maxs:
    #####: 2132:    return builder.getIntegerAttr(
        -: 2133:        resultType,
    #####: 2134:        APInt::getSignedMinValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2135:  case AtomicRMWKind::minf:
    #####: 2136:    return builder.getFloatAttr(
        -: 2137:        resultType,
    #####: 2138:        APFloat::getInf(resultType.cast<FloatType>().getFloatSemantics(),
call    0 never executed
call    1 never executed
    #####: 2139:                        /*Negative=*/false));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2140:  case AtomicRMWKind::mins:
    #####: 2141:    return builder.getIntegerAttr(
        -: 2142:        resultType,
    #####: 2143:        APInt::getSignedMaxValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2144:  case AtomicRMWKind::minu:
    #####: 2145:    return builder.getIntegerAttr(
        -: 2146:        resultType,
    #####: 2147:        APInt::getMaxValue(resultType.cast<IntegerType>().getWidth()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2148:  case AtomicRMWKind::muli:
    #####: 2149:    return builder.getIntegerAttr(resultType, 1);
call    0 never executed
    #####: 2150:  case AtomicRMWKind::mulf:
    #####: 2151:    return builder.getFloatAttr(resultType, 1);
call    0 never executed
        -: 2152:  // TODO: Add remaining reduction operations.
    #####: 2153:  default:
    #####: 2154:    (void)emitOptionalError(loc, "Reduction operation type not supported");
call    0 never executed
    #####: 2155:    break;
        -: 2156:  }
    #####: 2157:  return nullptr;
        -: 2158:}
        -: 2159:
        -: 2160:/// Returns the identity value associated with an AtomicRMWKind op.
function _ZN4mlir5arith16getIdentityValueENS0_13AtomicRMWKindENS_4TypeERNS_9OpBuilderENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 2161:Value mlir::arith::getIdentityValue(AtomicRMWKind op, Type resultType,
        -: 2162:                                    OpBuilder &builder, Location loc) {
    #####: 2163:  Attribute attr = getIdentityValueAttr(op, resultType, builder, loc);
call    0 never executed
    #####: 2164:  return builder.create<arith::ConstantOp>(loc, attr);
call    0 never executed
        -: 2165:}
        -: 2166:
        -: 2167:/// Return the value obtained by applying the reduction operation kind
        -: 2168:/// associated with a binary AtomicRMWKind op to `lhs` and `rhs`.
function _ZN4mlir5arith14getReductionOpENS0_13AtomicRMWKindERNS_9OpBuilderENS_8LocationENS_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####: 2169:Value mlir::arith::getReductionOp(AtomicRMWKind op, OpBuilder &builder,
        -: 2170:                                  Location loc, Value lhs, Value rhs) {
    #####: 2171:  switch (op) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 2172:  case AtomicRMWKind::addf:
    #####: 2173:    return builder.create<arith::AddFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2174:  case AtomicRMWKind::addi:
    #####: 2175:    return builder.create<arith::AddIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2176:  case AtomicRMWKind::mulf:
    #####: 2177:    return builder.create<arith::MulFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2178:  case AtomicRMWKind::muli:
    #####: 2179:    return builder.create<arith::MulIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2180:  case AtomicRMWKind::maxf:
    #####: 2181:    return builder.create<arith::MaxFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2182:  case AtomicRMWKind::minf:
    #####: 2183:    return builder.create<arith::MinFOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2184:  case AtomicRMWKind::maxs:
    #####: 2185:    return builder.create<arith::MaxSIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2186:  case AtomicRMWKind::mins:
    #####: 2187:    return builder.create<arith::MinSIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2188:  case AtomicRMWKind::maxu:
    #####: 2189:    return builder.create<arith::MaxUIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2190:  case AtomicRMWKind::minu:
    #####: 2191:    return builder.create<arith::MinUIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2192:  case AtomicRMWKind::ori:
    #####: 2193:    return builder.create<arith::OrIOp>(loc, lhs, rhs);
call    0 never executed
    #####: 2194:  case AtomicRMWKind::andi:
    #####: 2195:    return builder.create<arith::AndIOp>(loc, lhs, rhs);
call    0 never executed
        -: 2196:  // TODO: Add remaining reduction operations.
    #####: 2197:  default:
    #####: 2198:    (void)emitOptionalError(loc, "Reduction operation type not supported");
call    0 never executed
    #####: 2199:    break;
        -: 2200:  }
    #####: 2201:  return nullptr;
        -: 2202:}
        -: 2203:
        -: 2204://===----------------------------------------------------------------------===//
        -: 2205:// TableGen'd op method definitions
        -: 2206://===----------------------------------------------------------------------===//
        -: 2207:
        -: 2208:#define GET_OP_CLASSES
        -: 2209:#include "mlir/Dialect/Arith/IR/ArithOps.cpp.inc"
        -: 2210:
        -: 2211://===----------------------------------------------------------------------===//
        -: 2212:// TableGen'd enum attribute definitions
        -: 2213://===----------------------------------------------------------------------===//
        -: 2214:
        -: 2215:#include "mlir/Dialect/Arith/IR/ArithOpsEnums.cpp.inc"
