        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/SPIRV/Transforms/UnifyAliasedResourcePass.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVTransforms.dir/UnifyAliasedResourcePass.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVTransforms.dir/UnifyAliasedResourcePass.cpp.gcda
        -:    0:Runs:325554
        -:    1://===- UnifyAliasedResourcePass.cpp - Pass to Unify Aliased Resources -----===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements a pass that unifies access of multiple aliased resources
        -:   10:// into access of one single resource.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/SPIRV/Transforms/Passes.h"
        -:   15:
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   18:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   19:#include "mlir/Dialect/SPIRV/IR/TargetAndABI.h"
        -:   20:#include "mlir/IR/Builders.h"
        -:   21:#include "mlir/IR/BuiltinAttributes.h"
        -:   22:#include "mlir/IR/BuiltinTypes.h"
        -:   23:#include "mlir/IR/SymbolTable.h"
        -:   24:#include "mlir/Transforms/DialectConversion.h"
        -:   25:#include "llvm/ADT/DenseMap.h"
        -:   26:#include "llvm/ADT/STLExtras.h"
        -:   27:#include "llvm/Support/Debug.h"
        -:   28:#include <algorithm>
        -:   29:#include <iterator>
        -:   30:
        -:   31:namespace mlir {
        -:   32:namespace spirv {
        -:   33:#define GEN_PASS_DEF_SPIRVUNIFYALIASEDRESOURCEPASS
        -:   34:#include "mlir/Dialect/SPIRV/Transforms/Passes.h.inc"
        -:   35:} // namespace spirv
        -:   36:} // namespace mlir
        -:   37:
        -:   38:#define DEBUG_TYPE "spirv-unify-aliased-resource"
        -:   39:
        -:   40:using namespace mlir;
        -:   41:
        -:   42://===----------------------------------------------------------------------===//
        -:   43:// Utility functions
        -:   44://===----------------------------------------------------------------------===//
        -:   45:
        -:   46:using Descriptor = std::pair<uint32_t, uint32_t>; // (set #, binding #)
        -:   47:using AliasedResourceMap =
        -:   48:    DenseMap<Descriptor, SmallVector<spirv::GlobalVariableOp>>;
        -:   49:
        -:   50:/// Collects all aliased resources in the given SPIR-V `moduleOp`.
function _ZL23collectAliasedResourcesN4mlir5spirv8ModuleOpE called 0 returned 0% blocks executed 0%
    #####:   51:static AliasedResourceMap collectAliasedResources(spirv::ModuleOp moduleOp) {
    #####:   52:  AliasedResourceMap aliasedResources;
call    0 never executed
function _ZZL23collectAliasedResourcesN4mlir5spirv8ModuleOpEENKUlNS0_16GlobalVariableOpEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   53:  moduleOp->walk([&aliasedResources](spirv::GlobalVariableOp varOp) {
call    0 never executed
    #####:   54:    if (varOp->getAttrOfType<UnitAttr>("aliased")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   55:      Optional<uint32_t> set = varOp.getDescriptorSet();
call    0 never executed
    #####:   56:      Optional<uint32_t> binding = varOp.getBinding();
call    0 never executed
    #####:   57:      if (set && binding)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   58:        aliasedResources[{*set, *binding}].push_back(varOp);
call    0 never executed
call    1 never executed
        -:   59:    }
    #####:   60:  });
    #####:   61:  return aliasedResources;
        -:   62:}
        -:   63:
        -:   64:/// Returns the element type if the given `type` is a runtime array resource:
        -:   65:/// `!spirv.ptr<!spirv.struct<!spirv.rtarray<...>>>`. Returns null type
        -:   66:/// otherwise.
function _ZL26getRuntimeArrayElementTypeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:   67:static Type getRuntimeArrayElementType(Type type) {
    #####:   68:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####:   69:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####:   70:    return {};
        -:   71:
    #####:   72:  auto structType = ptrType.getPointeeType().dyn_cast<spirv::StructType>();
call    0 never executed
call    1 never executed
    #####:   73:  if (!structType || structType.getNumElements() != 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   74:    return {};
        -:   75:
    #####:   76:  auto rtArrayType =
    #####:   77:      structType.getElementType(0).dyn_cast<spirv::RuntimeArrayType>();
call    0 never executed
call    1 never executed
    #####:   78:  if (!rtArrayType)
branch  0 never executed
branch  1 never executed
    #####:   79:    return {};
        -:   80:
    #####:   81:  return rtArrayType.getElementType();
call    0 never executed
        -:   82:}
        -:   83:
        -:   84:/// Given a list of resource element `types`, returns the index of the canonical
        -:   85:/// resource that all resources should be unified into. Returns llvm::None if
        -:   86:/// unable to unify.
function _ZL23deduceCanonicalResourceN4llvm8ArrayRefIN4mlir5spirv9SPIRVTypeEEE called 0 returned 0% blocks executed 0%
    #####:   87:static Optional<int> deduceCanonicalResource(ArrayRef<spirv::SPIRVType> types) {
        -:   88:  // scalarNumBits: contains all resources' scalar types' bit counts.
        -:   89:  // vectorNumBits: only contains resources whose element types are vectors.
        -:   90:  // vectorIndices: each vector's original index in `types`.
    #####:   91:  SmallVector<int> scalarNumBits, vectorNumBits, vectorIndices;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   92:  scalarNumBits.reserve(types.size());
branch  0 never executed
branch  1 never executed
    #####:   93:  vectorNumBits.reserve(types.size());
branch  0 never executed
branch  1 never executed
    #####:   94:  vectorIndices.reserve(types.size());
branch  0 never executed
branch  1 never executed
        -:   95:
    #####:   96:  for (const auto &indexedTypes : llvm::enumerate(types)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   97:    spirv::SPIRVType type = indexedTypes.value();
call    0 never executed
    #####:   98:    assert(type.isScalarOrVector());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   99:    if (auto vectorType = type.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:      if (vectorType.getNumElements() % 2 != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  101:        return llvm::None; // Odd-sized vector has special layout requirements.
        -:  102:
    #####:  103:      Optional<int64_t> numBytes = type.getSizeInBytes();
call    0 never executed
    #####:  104:      if (!numBytes)
branch  0 never executed
branch  1 never executed
    #####:  105:        return llvm::None;
        -:  106:
    #####:  107:      scalarNumBits.push_back(
call    0 never executed
    #####:  108:          vectorType.getElementType().getIntOrFloatBitWidth());
call    0 never executed
call    1 never executed
    #####:  109:      vectorNumBits.push_back(*numBytes * 8);
call    0 never executed
    #####:  110:      vectorIndices.push_back(indexedTypes.index());
call    0 never executed
        -:  111:    } else {
    #####:  112:      scalarNumBits.push_back(type.getIntOrFloatBitWidth());
call    0 never executed
call    1 never executed
        -:  113:    }
        -:  114:  }
        -:  115:
    #####:  116:  if (!vectorNumBits.empty()) {
branch  0 never executed
branch  1 never executed
        -:  117:    // Choose the *vector* with the smallest bitwidth as the canonical resource,
        -:  118:    // so that we can still keep vectorized load/store and avoid partial updates
        -:  119:    // to large vectors.
    #####:  120:    auto *minVal = std::min_element(vectorNumBits.begin(), vectorNumBits.end());
branch  0 never executed
branch  1 never executed
        -:  121:    // Make sure that the canonical resource's bitwidth is divisible by others.
        -:  122:    // With out this, we cannot properly adjust the index later.
    #####:  123:    if (llvm::any_of(vectorNumBits,
branch  0 never executed
branch  1 never executed
        -:  124:                     [&](int bits) { return bits % *minVal != 0; }))
    #####:  125:      return llvm::None;
        -:  126:
        -:  127:    // Require all scalar type bit counts to be a multiple of the chosen
        -:  128:    // vector's primitive type to avoid reading/writing subcomponents.
    #####:  129:    int index = vectorIndices[std::distance(vectorNumBits.begin(), minVal)];
branch  0 never executed
branch  1 never executed
    #####:  130:    int baseNumBits = scalarNumBits[index];
branch  0 never executed
branch  1 never executed
    #####:  131:    if (llvm::any_of(scalarNumBits,
branch  0 never executed
branch  1 never executed
        -:  132:                     [&](int bits) { return bits % baseNumBits != 0; }))
    #####:  133:      return llvm::None;
        -:  134:
    #####:  135:    return index;
        -:  136:  }
        -:  137:
        -:  138:  // All element types are scalars. Then choose the smallest bitwidth as the
        -:  139:  // cannonical resource to avoid subcomponent load/store.
    #####:  140:  auto *minVal = std::min_element(scalarNumBits.begin(), scalarNumBits.end());
branch  0 never executed
branch  1 never executed
    #####:  141:  if (llvm::any_of(scalarNumBits,
branch  0 never executed
branch  1 never executed
        -:  142:                   [minVal](int64_t bit) { return bit % *minVal != 0; }))
    #####:  143:    return llvm::None;
    #####:  144:  return std::distance(scalarNumBits.begin(), minVal);
        -:  145:}
        -:  146:
function _ZL25areSameBitwidthScalarTypeN4mlir4TypeES0_ called 0 returned 0% blocks executed 0%
    #####:  147:static bool areSameBitwidthScalarType(Type a, Type b) {
    #####:  148:  return a.isIntOrFloat() && b.isIntOrFloat() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  149:         a.getIntOrFloatBitWidth() == b.getIntOrFloatBitWidth();
call    0 never executed
call    1 never executed
        -:  150:}
        -:  151:
        -:  152://===----------------------------------------------------------------------===//
        -:  153:// Analysis
        -:  154://===----------------------------------------------------------------------===//
        -:  155:
        -:  156:namespace {
        -:  157:/// A class for analyzing aliased resources.
        -:  158:///
        -:  159:/// Resources are expected to be spirv.GlobalVarible that has a descriptor set
        -:  160:/// and binding number. Such resources are of the type
        -:  161:/// `!spirv.ptr<!spirv.struct<...>>` per Vulkan requirements.
        -:  162:///
        -:  163:/// Right now, we only support the case that there is a single runtime array
        -:  164:/// inside the struct.
        -:  165:class ResourceAliasAnalysis {
        -:  166:public:
function _ZN12_GLOBAL__N_121ResourceAliasAnalysis13resolveTypeIDEv called 0 returned 0% blocks executed 0%
    #####:  167:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ResourceAliasAnalysis)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  168:
        -:  169:  explicit ResourceAliasAnalysis(Operation *);
        -:  170:
        -:  171:  /// Returns true if the given `op` can be rewritten to use a canonical
        -:  172:  /// resource.
        -:  173:  bool shouldUnify(Operation *op) const;
        -:  174:
        -:  175:  /// Returns all descriptors and their corresponding aliased resources.
        -:  176:  const AliasedResourceMap &getResourceMap() const { return resourceMap; }
        -:  177:
        -:  178:  /// Returns the canonical resource for the given descriptor/variable.
        -:  179:  spirv::GlobalVariableOp
        -:  180:  getCanonicalResource(const Descriptor &descriptor) const;
        -:  181:  spirv::GlobalVariableOp
        -:  182:  getCanonicalResource(spirv::GlobalVariableOp varOp) const;
        -:  183:
        -:  184:  /// Returns the element type for the given variable.
        -:  185:  spirv::SPIRVType getElementType(spirv::GlobalVariableOp varOp) const;
        -:  186:
        -:  187:private:
        -:  188:  /// Given the descriptor and aliased resources bound to it, analyze whether we
        -:  189:  /// can unify them and record if so.
        -:  190:  void recordIfUnifiable(const Descriptor &descriptor,
        -:  191:                         ArrayRef<spirv::GlobalVariableOp> resources);
        -:  192:
        -:  193:  /// Mapping from a descriptor to all aliased resources bound to it.
        -:  194:  AliasedResourceMap resourceMap;
        -:  195:
        -:  196:  /// Mapping from a descriptor to the chosen canonical resource.
        -:  197:  DenseMap<Descriptor, spirv::GlobalVariableOp> canonicalResourceMap;
        -:  198:
        -:  199:  /// Mapping from an aliased resource to its descriptor.
        -:  200:  DenseMap<spirv::GlobalVariableOp, Descriptor> descriptorMap;
        -:  201:
        -:  202:  /// Mapping from an aliased resource to its element (scalar/vector) type.
        -:  203:  DenseMap<spirv::GlobalVariableOp, spirv::SPIRVType> elementTypeMap;
        -:  204:};
        -:  205:} // namespace
        -:  206:
function _ZN12_GLOBAL__N_121ResourceAliasAnalysisC2EPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  207:ResourceAliasAnalysis::ResourceAliasAnalysis(Operation *root) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  208:  // Collect all aliased resources first and put them into different sets
        -:  209:  // according to the descriptor.
    #####:  210:  AliasedResourceMap aliasedResources =
    #####:  211:      collectAliasedResources(cast<spirv::ModuleOp>(root));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  212:
        -:  213:  // For each resource set, analyze whether we can unify; if so, try to identify
        -:  214:  // a canonical resource, whose element type has the largest bitwidth.
    #####:  215:  for (const auto &descriptorResource : aliasedResources) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  216:    recordIfUnifiable(descriptorResource.first, descriptorResource.second);
call    0 never executed
call    1 never executed
        -:  217:  }
    #####:  218:}
        -:  219:
function _ZNK12_GLOBAL__N_121ResourceAliasAnalysis11shouldUnifyEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  220:bool ResourceAliasAnalysis::shouldUnify(Operation *op) const {
    #####:  221:  if (auto varOp = dyn_cast<spirv::GlobalVariableOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  222:    auto canonicalOp = getCanonicalResource(varOp);
call    0 never executed
    #####:  223:    return canonicalOp && varOp != canonicalOp;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  224:  }
    #####:  225:  if (auto addressOp = dyn_cast<spirv::AddressOfOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  226:    auto moduleOp = addressOp->getParentOfType<spirv::ModuleOp>();
call    0 never executed
    #####:  227:    auto *varOp =
    #####:  228:        SymbolTable::lookupSymbolIn(moduleOp, addressOp.getVariable());
call    0 never executed
call    1 never executed
    #####:  229:    return shouldUnify(varOp);
call    0 never executed
        -:  230:  }
        -:  231:
    #####:  232:  if (auto acOp = dyn_cast<spirv::AccessChainOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  233:    return shouldUnify(acOp.getBasePtr().getDefiningOp());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  234:  if (auto loadOp = dyn_cast<spirv::LoadOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  235:    return shouldUnify(loadOp.getPtr().getDefiningOp());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  236:  if (auto storeOp = dyn_cast<spirv::StoreOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  237:    return shouldUnify(storeOp.getPtr().getDefiningOp());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  238:
    #####:  239:  return false;
        -:  240:}
        -:  241:
function _ZNK12_GLOBAL__N_121ResourceAliasAnalysis20getCanonicalResourceERKSt4pairIjjE called 0 returned 0% blocks executed 0%
    #####:  242:spirv::GlobalVariableOp ResourceAliasAnalysis::getCanonicalResource(
        -:  243:    const Descriptor &descriptor) const {
    #####:  244:  auto varIt = canonicalResourceMap.find(descriptor);
call    0 never executed
    #####:  245:  if (varIt == canonicalResourceMap.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  246:    return {};
    #####:  247:  return varIt->second;
call    0 never executed
        -:  248:}
        -:  249:
function _ZNK12_GLOBAL__N_121ResourceAliasAnalysis20getCanonicalResourceEN4mlir5spirv16GlobalVariableOpE called 0 returned 0% blocks executed 0%
    #####:  250:spirv::GlobalVariableOp ResourceAliasAnalysis::getCanonicalResource(
        -:  251:    spirv::GlobalVariableOp varOp) const {
    #####:  252:  auto descriptorIt = descriptorMap.find(varOp);
call    0 never executed
    #####:  253:  if (descriptorIt == descriptorMap.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  254:    return {};
    #####:  255:  return getCanonicalResource(descriptorIt->second);
call    0 never executed
call    1 never executed
        -:  256:}
        -:  257:
        -:  258:spirv::SPIRVType
function _ZNK12_GLOBAL__N_121ResourceAliasAnalysis14getElementTypeEN4mlir5spirv16GlobalVariableOpE called 0 returned 0% blocks executed 0%
    #####:  259:ResourceAliasAnalysis::getElementType(spirv::GlobalVariableOp varOp) const {
    #####:  260:  auto it = elementTypeMap.find(varOp);
call    0 never executed
    #####:  261:  if (it == elementTypeMap.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  262:    return {};
    #####:  263:  return it->second;
call    0 never executed
        -:  264:}
        -:  265:
function _ZN12_GLOBAL__N_121ResourceAliasAnalysis17recordIfUnifiableERKSt4pairIjjEN4llvm8ArrayRefIN4mlir5spirv16GlobalVariableOpEEE called 0 returned 0% blocks executed 0%
    #####:  266:void ResourceAliasAnalysis::recordIfUnifiable(
        -:  267:    const Descriptor &descriptor, ArrayRef<spirv::GlobalVariableOp> resources) {
        -:  268:  // Collect the element types for all resources in the current set.
    #####:  269:  SmallVector<spirv::SPIRVType> elementTypes;
    #####:  270:  for (spirv::GlobalVariableOp resource : resources) {
branch  0 never executed
branch  1 never executed
    #####:  271:    Type elementType = getRuntimeArrayElementType(resource.getType());
call    0 never executed
call    1 never executed
    #####:  272:    if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  273:      return; // Unexpected resource variable type.
        -:  274:
    #####:  275:    auto type = elementType.cast<spirv::SPIRVType>();
call    0 never executed
    #####:  276:    if (!type.isScalarOrVector())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  277:      return; // Unexpected resource element type.
        -:  278:
    #####:  279:    elementTypes.push_back(type);
call    0 never executed
        -:  280:  }
        -:  281:
    #####:  282:  Optional<int> index = deduceCanonicalResource(elementTypes);
call    0 never executed
    #####:  283:  if (!index)
branch  0 never executed
branch  1 never executed
        -:  284:    return;
        -:  285:
        -:  286:  // Update internal data structures for later use.
    #####:  287:  resourceMap[descriptor].assign(resources.begin(), resources.end());
call    0 never executed
call    1 never executed
    #####:  288:  canonicalResourceMap[descriptor] = resources[*index];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  289:  for (const auto &resource : llvm::enumerate(resources)) {
branch  0 never executed
branch  1 never executed
    #####:  290:    descriptorMap[resource.value()] = descriptor;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  291:    elementTypeMap[resource.value()] = elementTypes[resource.index()];
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  292:  }
        -:  293:}
        -:  294:
        -:  295://===----------------------------------------------------------------------===//
        -:  296:// Patterns
        -:  297://===----------------------------------------------------------------------===//
        -:  298:
        -:  299:template <typename OpTy>
        -:  300:class ConvertAliasResource : public OpConversionPattern<OpTy> {
        -:  301:public:
        -:  302:  ConvertAliasResource(const ResourceAliasAnalysis &analysis,
        -:  303:                       MLIRContext *context, PatternBenefit benefit = 1)
        -:  304:      : OpConversionPattern<OpTy>(context, benefit), analysis(analysis) {}
        -:  305:
        -:  306:protected:
        -:  307:  const ResourceAliasAnalysis &analysis;
        -:  308:};
        -:  309:
        -:  310:struct ConvertVariable : public ConvertAliasResource<spirv::GlobalVariableOp> {
        -:  311:  using ConvertAliasResource::ConvertAliasResource;
        -:  312:
        -:  313:  LogicalResult
function _ZNK15ConvertVariable15matchAndRewriteEN4mlir5spirv16GlobalVariableOpENS1_23GlobalVariableOpAdaptorERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  314:  matchAndRewrite(spirv::GlobalVariableOp varOp, OpAdaptor adaptor,
        -:  315:                  ConversionPatternRewriter &rewriter) const override {
        -:  316:    // Just remove the aliased resource. Users will be rewritten to use the
        -:  317:    // canonical one.
    #####:  318:    rewriter.eraseOp(varOp);
call    0 never executed
    #####:  319:    return success();
        -:  320:  }
        -:  321:};
        -:  322:
        -:  323:struct ConvertAddressOf : public ConvertAliasResource<spirv::AddressOfOp> {
        -:  324:  using ConvertAliasResource::ConvertAliasResource;
        -:  325:
        -:  326:  LogicalResult
function _ZNK16ConvertAddressOf15matchAndRewriteEN4mlir5spirv11AddressOfOpENS1_18AddressOfOpAdaptorERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  327:  matchAndRewrite(spirv::AddressOfOp addressOp, OpAdaptor adaptor,
        -:  328:                  ConversionPatternRewriter &rewriter) const override {
        -:  329:    // Rewrite the AddressOf op to get the address of the canoncical resource.
    #####:  330:    auto moduleOp = addressOp->getParentOfType<spirv::ModuleOp>();
call    0 never executed
    #####:  331:    auto srcVarOp = cast<spirv::GlobalVariableOp>(
    #####:  332:        SymbolTable::lookupSymbolIn(moduleOp, addressOp.getVariable()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  333:    auto dstVarOp = analysis.getCanonicalResource(srcVarOp);
call    0 never executed
    #####:  334:    rewriter.replaceOpWithNewOp<spirv::AddressOfOp>(addressOp, dstVarOp);
call    0 never executed
    #####:  335:    return success();
        -:  336:  }
        -:  337:};
        -:  338:
        -:  339:struct ConvertAccessChain : public ConvertAliasResource<spirv::AccessChainOp> {
        -:  340:  using ConvertAliasResource::ConvertAliasResource;
        -:  341:
        -:  342:  LogicalResult
function _ZNK18ConvertAccessChain15matchAndRewriteEN4mlir5spirv13AccessChainOpENS1_20AccessChainOpAdaptorERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  343:  matchAndRewrite(spirv::AccessChainOp acOp, OpAdaptor adaptor,
        -:  344:                  ConversionPatternRewriter &rewriter) const override {
    #####:  345:    auto addressOp = acOp.getBasePtr().getDefiningOp<spirv::AddressOfOp>();
call    0 never executed
call    1 never executed
    #####:  346:    if (!addressOp)
branch  0 never executed
branch  1 never executed
    #####:  347:      return rewriter.notifyMatchFailure(acOp, "base ptr not addressof op");
call    0 never executed
        -:  348:
    #####:  349:    auto moduleOp = acOp->getParentOfType<spirv::ModuleOp>();
call    0 never executed
    #####:  350:    auto srcVarOp = cast<spirv::GlobalVariableOp>(
    #####:  351:        SymbolTable::lookupSymbolIn(moduleOp, addressOp.getVariable()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  352:    auto dstVarOp = analysis.getCanonicalResource(srcVarOp);
call    0 never executed
        -:  353:
    #####:  354:    spirv::SPIRVType srcElemType = analysis.getElementType(srcVarOp);
call    0 never executed
    #####:  355:    spirv::SPIRVType dstElemType = analysis.getElementType(dstVarOp);
call    0 never executed
        -:  356:
    #####:  357:    if (srcElemType == dstElemType ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  358:        areSameBitwidthScalarType(srcElemType, dstElemType)) {
call    0 never executed
        -:  359:      // We have the same bitwidth for source and destination element types.
        -:  360:      // Thie indices keep the same.
    #####:  361:      rewriter.replaceOpWithNewOp<spirv::AccessChainOp>(
    #####:  362:          acOp, adaptor.getBasePtr(), adaptor.getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  363:      return success();
        -:  364:    }
        -:  365:
    #####:  366:    Location loc = acOp.getLoc();
call    0 never executed
    #####:  367:    auto i32Type = rewriter.getI32Type();
call    0 never executed
        -:  368:
    #####:  369:    if (srcElemType.isIntOrFloat() && dstElemType.isa<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  370:      // The source indices are for a buffer with scalar element types. Rewrite
        -:  371:      // them into a buffer with vector element types. We need to scale the last
        -:  372:      // index for the vector as a whole, then add one level of index for inside
        -:  373:      // the vector.
    #####:  374:      int srcNumBytes = *srcElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  375:      int dstNumBytes = *dstElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  376:      assert(dstNumBytes >= srcNumBytes && dstNumBytes % srcNumBytes == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  377:      int ratio = dstNumBytes / srcNumBytes;
    #####:  378:      auto ratioValue = rewriter.create<spirv::ConstantOp>(
    #####:  379:          loc, i32Type, rewriter.getI32IntegerAttr(ratio));
call    0 never executed
call    1 never executed
        -:  380:
    #####:  381:      auto indices = llvm::to_vector<4>(acOp.getIndices());
call    0 never executed
call    1 never executed
    #####:  382:      Value oldIndex = indices.back();
call    0 never executed
    #####:  383:      indices.back() =
call    0 never executed
    #####:  384:          rewriter.create<spirv::SDivOp>(loc, i32Type, oldIndex, ratioValue);
call    0 never executed
call    1 never executed
    #####:  385:      indices.push_back(
call    0 never executed
    #####:  386:          rewriter.create<spirv::SModOp>(loc, i32Type, oldIndex, ratioValue));
call    0 never executed
call    1 never executed
        -:  387:
    #####:  388:      rewriter.replaceOpWithNewOp<spirv::AccessChainOp>(
    #####:  389:          acOp, adaptor.getBasePtr(), indices);
call    0 never executed
call    1 never executed
    #####:  390:      return success();
branch  0 never executed
branch  1 never executed
        -:  391:    }
        -:  392:
    #####:  393:    if ((srcElemType.isIntOrFloat() && dstElemType.isIntOrFloat()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  394:        (srcElemType.isa<VectorType>() && dstElemType.isa<VectorType>())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  395:      // The source indices are for a buffer with larger bitwidth scalar/vector
        -:  396:      // element types. Rewrite them into a buffer with smaller bitwidth element
        -:  397:      // types. We only need to scale the last index.
    #####:  398:      int srcNumBytes = *srcElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  399:      int dstNumBytes = *dstElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  400:      assert(srcNumBytes >= dstNumBytes && srcNumBytes % dstNumBytes == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  401:      int ratio = srcNumBytes / dstNumBytes;
    #####:  402:      auto ratioValue = rewriter.create<spirv::ConstantOp>(
    #####:  403:          loc, i32Type, rewriter.getI32IntegerAttr(ratio));
call    0 never executed
call    1 never executed
        -:  404:
    #####:  405:      auto indices = llvm::to_vector<4>(acOp.getIndices());
call    0 never executed
call    1 never executed
    #####:  406:      Value oldIndex = indices.back();
call    0 never executed
    #####:  407:      indices.back() =
call    0 never executed
    #####:  408:          rewriter.create<spirv::IMulOp>(loc, i32Type, oldIndex, ratioValue);
call    0 never executed
call    1 never executed
        -:  409:
    #####:  410:      rewriter.replaceOpWithNewOp<spirv::AccessChainOp>(
    #####:  411:          acOp, adaptor.getBasePtr(), indices);
call    0 never executed
call    1 never executed
    #####:  412:      return success();
branch  0 never executed
branch  1 never executed
        -:  413:    }
        -:  414:
    #####:  415:    return rewriter.notifyMatchFailure(
    #####:  416:        acOp, "unsupported src/dst types for spirv.AccessChain");
call    0 never executed
        -:  417:  }
        -:  418:};
        -:  419:
        -:  420:struct ConvertLoad : public ConvertAliasResource<spirv::LoadOp> {
        -:  421:  using ConvertAliasResource::ConvertAliasResource;
        -:  422:
        -:  423:  LogicalResult
function _ZNK11ConvertLoad15matchAndRewriteEN4mlir5spirv6LoadOpENS1_13LoadOpAdaptorERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  424:  matchAndRewrite(spirv::LoadOp loadOp, OpAdaptor adaptor,
        -:  425:                  ConversionPatternRewriter &rewriter) const override {
    #####:  426:    auto srcPtrType = loadOp.getPtr().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####:  427:    auto srcElemType = srcPtrType.getPointeeType().cast<spirv::SPIRVType>();
call    0 never executed
call    1 never executed
    #####:  428:    auto dstPtrType = adaptor.getPtr().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####:  429:    auto dstElemType = dstPtrType.getPointeeType().cast<spirv::SPIRVType>();
call    0 never executed
call    1 never executed
        -:  430:
    #####:  431:    Location loc = loadOp.getLoc();
call    0 never executed
    #####:  432:    auto newLoadOp = rewriter.create<spirv::LoadOp>(loc, adaptor.getPtr());
call    0 never executed
call    1 never executed
    #####:  433:    if (srcElemType == dstElemType) {
branch  0 never executed
branch  1 never executed
    #####:  434:      rewriter.replaceOp(loadOp, newLoadOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  435:      return success();
        -:  436:    }
        -:  437:
    #####:  438:    if (areSameBitwidthScalarType(srcElemType, dstElemType)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  439:      auto castOp = rewriter.create<spirv::BitcastOp>(loc, srcElemType,
    #####:  440:                                                      newLoadOp.getValue());
call    0 never executed
call    1 never executed
    #####:  441:      rewriter.replaceOp(loadOp, castOp->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  442:
    #####:  443:      return success();
        -:  444:    }
        -:  445:
    #####:  446:    if ((srcElemType.isIntOrFloat() && dstElemType.isIntOrFloat()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  447:        (srcElemType.isa<VectorType>() && dstElemType.isa<VectorType>())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  448:      // The source and destination have scalar types of different bitwidths, or
        -:  449:      // vector types of different component counts. For such cases, we load
        -:  450:      // multiple smaller bitwidth values and construct a larger bitwidth one.
        -:  451:
    #####:  452:      int srcNumBytes = *srcElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  453:      int dstNumBytes = *dstElemType.getSizeInBytes();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  454:      assert(srcNumBytes > dstNumBytes && srcNumBytes % dstNumBytes == 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  455:      int ratio = srcNumBytes / dstNumBytes;
    #####:  456:      if (ratio > 4)
branch  0 never executed
branch  1 never executed
    #####:  457:        return rewriter.notifyMatchFailure(loadOp, "more than 4 components");
call    0 never executed
        -:  458:
    #####:  459:      SmallVector<Value> components;
branch  0 never executed
branch  1 never executed
    #####:  460:      components.reserve(ratio);
branch  0 never executed
branch  1 never executed
    #####:  461:      components.push_back(newLoadOp);
call    0 never executed
        -:  462:
    #####:  463:      auto acOp = adaptor.getPtr().getDefiningOp<spirv::AccessChainOp>();
call    0 never executed
call    1 never executed
    #####:  464:      if (!acOp)
branch  0 never executed
branch  1 never executed
    #####:  465:        return rewriter.notifyMatchFailure(loadOp, "ptr not spirv.AccessChain");
call    0 never executed
        -:  466:
    #####:  467:      auto i32Type = rewriter.getI32Type();
call    0 never executed
    #####:  468:      Value oneValue = spirv::ConstantOp::getOne(i32Type, loc, rewriter);
call    0 never executed
call    1 never executed
    #####:  469:      auto indices = llvm::to_vector<4>(acOp.getIndices());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  470:      for (int i = 1; i < ratio; ++i) {
branch  0 never executed
branch  1 never executed
        -:  471:        // Load all subsequent components belonging to this element.
    #####:  472:        indices.back() = rewriter.create<spirv::IAddOp>(
call    0 never executed
    #####:  473:            loc, i32Type, indices.back(), oneValue);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  474:        auto componentAcOp = rewriter.create<spirv::AccessChainOp>(
    #####:  475:            loc, acOp.getBasePtr(), indices);
call    0 never executed
call    1 never executed
        -:  476:        // Assuming little endian, this reads lower-ordered bits of the number
        -:  477:        // to lower-numbered components of the vector.
    #####:  478:        components.push_back(
call    0 never executed
    #####:  479:            rewriter.create<spirv::LoadOp>(loc, componentAcOp));
call    0 never executed
call    1 never executed
        -:  480:      }
        -:  481:
        -:  482:      // Create a vector of the components and then cast back to the larger
        -:  483:      // bitwidth element type. For spirv.bitcast, the lower-numbered components
        -:  484:      // of the vector map to lower-ordered bits of the larger bitwidth element
        -:  485:      // type.
    #####:  486:      Type vectorType = srcElemType;
    #####:  487:      if (!srcElemType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  488:        vectorType = VectorType::get({ratio}, dstElemType);
call    0 never executed
    #####:  489:      Value vectorValue = rewriter.create<spirv::CompositeConstructOp>(
    #####:  490:          loc, vectorType, components);
call    0 never executed
call    1 never executed
    #####:  491:      if (!srcElemType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  492:        vectorValue =
    #####:  493:            rewriter.create<spirv::BitcastOp>(loc, srcElemType, vectorValue);
call    0 never executed
    #####:  494:      rewriter.replaceOp(loadOp, vectorValue);
call    0 never executed
call    1 never executed
    #####:  495:      return success();
branch  0 never executed
branch  1 never executed
        -:  496:    }
        -:  497:
    #####:  498:    return rewriter.notifyMatchFailure(
    #####:  499:        loadOp, "unsupported src/dst types for spirv.Load");
call    0 never executed
        -:  500:  }
        -:  501:};
        -:  502:
        -:  503:struct ConvertStore : public ConvertAliasResource<spirv::StoreOp> {
        -:  504:  using ConvertAliasResource::ConvertAliasResource;
        -:  505:
        -:  506:  LogicalResult
function _ZNK12ConvertStore15matchAndRewriteEN4mlir5spirv7StoreOpENS1_14StoreOpAdaptorERNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  507:  matchAndRewrite(spirv::StoreOp storeOp, OpAdaptor adaptor,
        -:  508:                  ConversionPatternRewriter &rewriter) const override {
    #####:  509:    auto srcElemType =
    #####:  510:        storeOp.getPtr().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  511:    auto dstElemType =
    #####:  512:        adaptor.getPtr().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  513:    if (!srcElemType.isIntOrFloat() || !dstElemType.isIntOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  514:      return rewriter.notifyMatchFailure(storeOp, "not scalar type");
call    0 never executed
    #####:  515:    if (!areSameBitwidthScalarType(srcElemType, dstElemType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  516:      return rewriter.notifyMatchFailure(storeOp, "different bitwidth");
call    0 never executed
        -:  517:
    #####:  518:    Location loc = storeOp.getLoc();
call    0 never executed
    #####:  519:    Value value = adaptor.getValue();
call    0 never executed
    #####:  520:    if (srcElemType != dstElemType)
branch  0 never executed
branch  1 never executed
    #####:  521:      value = rewriter.create<spirv::BitcastOp>(loc, dstElemType, value);
call    0 never executed
    #####:  522:    rewriter.replaceOpWithNewOp<spirv::StoreOp>(storeOp, adaptor.getPtr(),
    #####:  523:                                                value, storeOp->getAttrs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  524:    return success();
        -:  525:  }
        -:  526:};
        -:  527:
        -:  528://===----------------------------------------------------------------------===//
        -:  529:// Pass
        -:  530://===----------------------------------------------------------------------===//
        -:  531:
        -:  532:namespace {
        -:  533:class UnifyAliasedResourcePass final
        -:  534:    : public spirv::impl::SPIRVUnifyAliasedResourcePassBase<
        -:  535:          UnifyAliasedResourcePass> {
        -:  536:public:
function _ZN12_GLOBAL__N_124UnifyAliasedResourcePassC2ESt8functionIFN4mlir5spirv13TargetEnvAttrENS3_8ModuleOpEEE called 326619 returned 100% blocks executed 100%
   326619:  537:  explicit UnifyAliasedResourcePass(spirv::GetTargetEnvFn getTargetEnv)
   326619:  538:      : getTargetEnvFn(std::move(getTargetEnv)) {}
call    0 returned 100%
        -:  539:
        -:  540:  void runOnOperation() override;
        -:  541:
        -:  542:private:
        -:  543:  spirv::GetTargetEnvFn getTargetEnvFn;
        -:  544:};
        -:  545:} // namespace
        -:  546:
function _ZN12_GLOBAL__N_124UnifyAliasedResourcePass14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  547:void UnifyAliasedResourcePass::runOnOperation() {
    #####:  548:  spirv::ModuleOp moduleOp = getOperation();
call    0 never executed
    #####:  549:  MLIRContext *context = &getContext();
call    0 never executed
        -:  550:
    #####:  551:  if (getTargetEnvFn) {
branch  0 never executed
branch  1 never executed
        -:  552:    // This pass is actually only needed for targeting Apple GPUs via MoltenVK,
        -:  553:    // where we need to translate SPIR-V into MSL. The translation has
        -:  554:    // limitations.
    #####:  555:    if (getTargetEnvFn(moduleOp).getVendorID() != spirv::Vendor::Apple)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  556:      return;
        -:  557:  }
        -:  558:
        -:  559:  // Analyze aliased resources first.
    #####:  560:  ResourceAliasAnalysis &analysis = getAnalysis<ResourceAliasAnalysis>();
call    0 never executed
        -:  561:
    #####:  562:  ConversionTarget target(*context);
call    0 never executed
    #####:  563:  target.addDynamicallyLegalOp<spirv::GlobalVariableOp, spirv::AddressOfOp,
        -:  564:                               spirv::AccessChainOp, spirv::LoadOp,
    #####:  565:                               spirv::StoreOp>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  566:      [&analysis](Operation *op) { return !analysis.shouldUnify(op); });
call    0 never executed
    #####:  567:  target.addLegalDialect<spirv::SPIRVDialect>();
call    0 never executed
        -:  568:
        -:  569:  // Run patterns to rewrite usages of non-canonical resources.
    #####:  570:  RewritePatternSet patterns(context);
call    0 never executed
call    1 never executed
    #####:  571:  patterns.add<ConvertVariable, ConvertAddressOf, ConvertAccessChain,
    #####:  572:               ConvertLoad, ConvertStore>(analysis, context);
call    0 never executed
    #####:  573:  if (failed(applyPartialConversion(moduleOp, target, std::move(patterns))))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  574:    return signalPassFailure();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  575:
        -:  576:  // Drop aliased attribute if we only have one single bound resource for a
        -:  577:  // descriptor. We need to re-collect the map here given in the above the
        -:  578:  // conversion is best effort; certain sets may not be converted.
    #####:  579:  AliasedResourceMap resourceMap =
call    0 never executed
    #####:  580:      collectAliasedResources(cast<spirv::ModuleOp>(moduleOp));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  581:  for (const auto &dr : resourceMap) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  582:    const auto &resources = dr.second;
    #####:  583:    if (resources.size() == 1)
branch  0 never executed
branch  1 never executed
    #####:  584:      resources.front()->removeAttr("aliased");
call    0 never executed
        -:  585:  }
        -:  586:}
        -:  587:
        -:  588:std::unique_ptr<mlir::OperationPass<spirv::ModuleOp>>
function _ZN4mlir5spirv30createUnifyAliasedResourcePassESt8functionIFNS0_13TargetEnvAttrENS0_8ModuleOpEEE called 326619 returned 100% blocks executed 100%
   326619:  589:spirv::createUnifyAliasedResourcePass(spirv::GetTargetEnvFn getTargetEnv) {
   326619:  590:  return std::make_unique<UnifyAliasedResourcePass>(std::move(getTargetEnv));
call    0 returned 100%
        -:  591:}
