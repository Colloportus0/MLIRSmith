        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/MemRef/Transforms/NormalizeMemRefs.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/MemRef/Transforms/CMakeFiles/obj.MLIRMemRefTransforms.dir/NormalizeMemRefs.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/MemRef/Transforms/CMakeFiles/obj.MLIRMemRefTransforms.dir/NormalizeMemRefs.cpp.gcda
        -:    0:Runs:325549
        -:    1://===- NormalizeMemRefs.cpp -----------------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements an interprocedural pass to normalize memrefs to have
        -:   10:// identity layout maps.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   15:#include "mlir/Dialect/Affine/Utils.h"
        -:   16:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   17:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   18:#include "mlir/Dialect/MemRef/Transforms/Passes.h"
        -:   19:#include "llvm/ADT/SmallSet.h"
        -:   20:#include "llvm/Support/Debug.h"
        -:   21:
        -:   22:namespace mlir {
        -:   23:namespace memref {
        -:   24:#define GEN_PASS_DEF_NORMALIZEMEMREFS
        -:   25:#include "mlir/Dialect/MemRef/Transforms/Passes.h.inc"
        -:   26:} // namespace memref
        -:   27:} // namespace mlir
        -:   28:
        -:   29:#define DEBUG_TYPE "normalize-memrefs"
        -:   30:
        -:   31:using namespace mlir;
        -:   32:
        -:   33:namespace {
        -:   34:
        -:   35:/// All memrefs passed across functions with non-trivial layout maps are
        -:   36:/// converted to ones with trivial identity layout ones.
        -:   37:/// If all the memref types/uses in a function are normalizable, we treat
        -:   38:/// such functions as normalizable. Also, if a normalizable function is known
        -:   39:/// to call a non-normalizable function, we treat that function as
        -:   40:/// non-normalizable as well. We assume external functions to be normalizable.
  326592*:   41:struct NormalizeMemRefs
call    0 never executed
call    1 returned 100%
        -:   42:    : public memref::impl::NormalizeMemRefsBase<NormalizeMemRefs> {
        -:   43:  void runOnOperation() override;
        -:   44:  void normalizeFuncOpMemRefs(func::FuncOp funcOp, ModuleOp moduleOp);
        -:   45:  bool areMemRefsNormalizable(func::FuncOp funcOp);
        -:   46:  void updateFunctionSignature(func::FuncOp funcOp, ModuleOp moduleOp);
        -:   47:  void setCalleesAndCallersNonNormalizable(
        -:   48:      func::FuncOp funcOp, ModuleOp moduleOp,
        -:   49:      DenseSet<func::FuncOp> &normalizableFuncs);
        -:   50:  Operation *createOpResultsNormalized(func::FuncOp funcOp, Operation *oldOp);
        -:   51:};
        -:   52:
        -:   53:} // namespace
        -:   54:
        -:   55:std::unique_ptr<OperationPass<ModuleOp>>
function _ZN4mlir6memref26createNormalizeMemRefsPassEv called 326592 returned 100% blocks executed 100%
   326592:   56:mlir::memref::createNormalizeMemRefsPass() {
   326592:   57:  return std::make_unique<NormalizeMemRefs>();
call    0 returned 100%
        -:   58:}
        -:   59:
function _ZN12_GLOBAL__N_116NormalizeMemRefs14runOnOperationEv called 861 returned 100% blocks executed 60%
      861:   60:void NormalizeMemRefs::runOnOperation() {
     861*:   61:  LLVM_DEBUG(llvm::dbgs() << "Normalizing Memrefs...\n");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
      861:   62:  ModuleOp moduleOp = getOperation();
call    0 returned 100%
        -:   63:  // We maintain all normalizable FuncOps in a DenseSet. It is initialized
        -:   64:  // with all the functions within a module and then functions which are not
        -:   65:  // normalizable are removed from this set.
        -:   66:  // TODO: Change this to work on FuncLikeOp once there is an operation
        -:   67:  // interface for it.
      861:   68:  DenseSet<func::FuncOp> normalizableFuncs;
call    0 returned 100%
        -:   69:  // Initialize `normalizableFuncs` with all the functions within a module.
     1810:   70:  moduleOp.walk([&](func::FuncOp funcOp) { normalizableFuncs.insert(funcOp); });
call    0 returned 100%
call    1 returned 100%
        -:   71:
        -:   72:  // Traverse through all the functions applying a filter which determines
        -:   73:  // whether that function is normalizable or not. All callers/callees of
        -:   74:  // a non-normalizable function will also become non-normalizable even if
        -:   75:  // they aren't passing any or specific non-normalizable memrefs. So,
        -:   76:  // functions which calls or get called by a non-normalizable becomes non-
        -:   77:  // normalizable functions themselves.
function _ZZN12_GLOBAL__N_116NormalizeMemRefs14runOnOperationEvENKUlN4mlir4func6FuncOpEE0_clES3_ called 949 returned 100% blocks executed 36%
      861:   78:  moduleOp.walk([&](func::FuncOp funcOp) {
call    0 returned 100%
     949*:   79:    if (normalizableFuncs.contains(funcOp)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     949*:   80:      if (!areMemRefsNormalizable(funcOp)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   81:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:   82:                   << "@" << funcOp.getName()
        -:   83:                   << " contains ops that cannot normalize MemRefs\n");
        -:   84:        // Since this function is not normalizable, we set all the caller
        -:   85:        // functions and the callees of this function as not normalizable.
        -:   86:        // TODO: Drop this conservative assumption in the future.
    #####:   87:        setCalleesAndCallersNonNormalizable(funcOp, moduleOp,
call    0 never executed
        -:   88:                                            normalizableFuncs);
        -:   89:      }
        -:   90:    }
      949:   91:  });
        -:   92:
     861*:   93:  LLVM_DEBUG(llvm::dbgs() << "Normalizing " << normalizableFuncs.size()
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:   94:                          << " functions\n");
        -:   95:  // Those functions which can be normalized are subjected to normalization.
     1810:   96:  for (func::FuncOp &funcOp : normalizableFuncs)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 52% (fallthrough)
branch  4 taken 48%
call    5 returned 100%
      949:   97:    normalizeFuncOpMemRefs(funcOp, moduleOp);
call    0 returned 100%
      861:   98:}
        -:   99:
        -:  100:/// Check whether all the uses of oldMemRef are either dereferencing uses or the
        -:  101:/// op is of type : DeallocOp, CallOp or ReturnOp. Only if these constraints
        -:  102:/// are satisfied will the value become a candidate for replacement.
        -:  103:/// TODO: Extend this for DimOps.
    #####:  104:static bool isMemRefNormalizable(Value::user_range opUsers) {
    #####:  105:  return llvm::all_of(opUsers, [](Operation *op) {
        -:  106:    return op->hasTrait<OpTrait::MemRefsNormalizable>();
        -:  107:  });
        -:  108:}
        -:  109:
        -:  110:/// Set all the calling functions and the callees of the function as not
        -:  111:/// normalizable.
function _ZN12_GLOBAL__N_116NormalizeMemRefs35setCalleesAndCallersNonNormalizableEN4mlir4func6FuncOpENS1_8ModuleOpERN4llvm8DenseSetIS3_NS5_12DenseMapInfoIS3_vEEEE called 0 returned 0% blocks executed 0%
    #####:  112:void NormalizeMemRefs::setCalleesAndCallersNonNormalizable(
        -:  113:    func::FuncOp funcOp, ModuleOp moduleOp,
        -:  114:    DenseSet<func::FuncOp> &normalizableFuncs) {
    #####:  115:  if (!normalizableFuncs.contains(funcOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  116:    return;
        -:  117:
    #####:  118:  LLVM_DEBUG(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  119:      llvm::dbgs() << "@" << funcOp.getName()
        -:  120:                   << " calls or is called by non-normalizable function\n");
    #####:  121:  normalizableFuncs.erase(funcOp);
call    0 never executed
        -:  122:  // Caller of the function.
    #####:  123:  Optional<SymbolTable::UseRange> symbolUses = funcOp.getSymbolUses(moduleOp);
call    0 never executed
    #####:  124:  for (SymbolTable::SymbolUse symbolUse : *symbolUses) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  125:    // TODO: Extend this for ops that are FunctionOpInterface. This would
        -:  126:    // require creating an OpInterface for FunctionOpInterface ops.
    #####:  127:    func::FuncOp parentFuncOp =
    #####:  128:        symbolUse.getUser()->getParentOfType<func::FuncOp>();
call    0 never executed
    #####:  129:    for (func::FuncOp &funcOp : normalizableFuncs) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  130:      if (parentFuncOp == funcOp) {
branch  0 never executed
branch  1 never executed
    #####:  131:        setCalleesAndCallersNonNormalizable(funcOp, moduleOp,
        -:  132:                                            normalizableFuncs);
    #####:  133:        break;
call    0 never executed
        -:  134:      }
        -:  135:    }
        -:  136:  }
        -:  137:
        -:  138:  // Functions called by this function.
function _ZZN12_GLOBAL__N_116NormalizeMemRefs35setCalleesAndCallersNonNormalizableEN4mlir4func6FuncOpENS1_8ModuleOpERN4llvm8DenseSetIS3_NS5_12DenseMapInfoIS3_vEEEEENKUlNS2_6CallOpEE_clESB_ called 0 returned 0% blocks executed 0%
    #####:  139:  funcOp.walk([&](func::CallOp callOp) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  140:    StringAttr callee = callOp.getCalleeAttr().getAttr();
call    0 never executed
call    1 never executed
    #####:  141:    for (func::FuncOp &funcOp : normalizableFuncs) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  142:      // We compare func::FuncOp and callee's name.
    #####:  143:      if (callee == funcOp.getNameAttr()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  144:        setCalleesAndCallersNonNormalizable(funcOp, moduleOp,
    #####:  145:                                            normalizableFuncs);
    #####:  146:        break;
call    0 never executed
        -:  147:      }
        -:  148:    }
    #####:  149:  });
        -:  150:}
        -:  151:
        -:  152:/// Check whether all the uses of AllocOps, CallOps and function arguments of a
        -:  153:/// function are either of dereferencing type or are uses in: DeallocOp, CallOp
        -:  154:/// or ReturnOp. Only if these constraints are satisfied will the function
        -:  155:/// become a candidate for normalization. When the uses of a memref are
        -:  156:/// non-normalizable and the memref map layout is trivial (identity), we can
        -:  157:/// still label the entire function as normalizable. We assume external
        -:  158:/// functions to be normalizable.
        -:  159:bool NormalizeMemRefs::areMemRefsNormalizable(func::FuncOp funcOp) {
        -:  160:  // We assume external functions to be normalizable.
        -:  161:  if (funcOp.isExternal())
        -:  162:    return true;
        -:  163:
        -:  164:  if (funcOp
function _ZZN12_GLOBAL__N_116NormalizeMemRefs22areMemRefsNormalizableEN4mlir4func6FuncOpEENKUlNS1_6memref7AllocOpEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  165:          .walk([&](memref::AllocOp allocOp) -> WalkResult {
    #####:  166:            Value oldMemRef = allocOp.getResult();
call    0 never executed
    #####:  167:            if (!allocOp.getType().getLayout().isIdentity() &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  168:                !isMemRefNormalizable(oldMemRef.getUsers()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  169:              return WalkResult::interrupt();
    #####:  170:            return WalkResult::advance();
        -:  171:          })
        -:  172:          .wasInterrupted())
        -:  173:    return false;
        -:  174:
        -:  175:  if (funcOp
function _ZZN12_GLOBAL__N_116NormalizeMemRefs22areMemRefsNormalizableEN4mlir4func6FuncOpEENKUlNS2_6CallOpEE0_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  176:          .walk([&](func::CallOp callOp) -> WalkResult {
    #####:  177:            for (unsigned resIndex :
call    0 never executed
    #####:  178:                 llvm::seq<unsigned>(0, callOp.getNumResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  179:              Value oldMemRef = callOp.getResult(resIndex);
branch  0 never executed
branch  1 never executed
    #####:  180:              if (auto oldMemRefType =
branch  0 never executed
branch  1 never executed
    #####:  181:                      oldMemRef.getType().dyn_cast<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  182:                if (!oldMemRefType.getLayout().isIdentity() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  183:                    !isMemRefNormalizable(oldMemRef.getUsers()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  184:                  return WalkResult::interrupt();
        -:  185:            }
    #####:  186:            return WalkResult::advance();
        -:  187:          })
        -:  188:          .wasInterrupted())
        -:  189:    return false;
        -:  190:
        -:  191:  for (unsigned argIndex : llvm::seq<unsigned>(0, funcOp.getNumArguments())) {
        -:  192:    BlockArgument oldMemRef = funcOp.getArgument(argIndex);
        -:  193:    if (auto oldMemRefType = oldMemRef.getType().dyn_cast<MemRefType>())
        -:  194:      if (!oldMemRefType.getLayout().isIdentity() &&
        -:  195:          !isMemRefNormalizable(oldMemRef.getUsers()))
        -:  196:        return false;
        -:  197:  }
        -:  198:
        -:  199:  return true;
        -:  200:}
        -:  201:
        -:  202:/// Fetch the updated argument list and result of the function and update the
        -:  203:/// function signature. This updates the function's return type at the caller
        -:  204:/// site and in case the return type is a normalized memref then it updates
        -:  205:/// the calling function's signature.
        -:  206:/// TODO: An update to the calling function signature is required only if the
        -:  207:/// returned value is in turn used in ReturnOp of the calling function.
function _ZN12_GLOBAL__N_116NormalizeMemRefs23updateFunctionSignatureEN4mlir4func6FuncOpENS1_8ModuleOpE called 949 returned 100% blocks executed 43%
      949:  208:void NormalizeMemRefs::updateFunctionSignature(func::FuncOp funcOp,
        -:  209:                                               ModuleOp moduleOp) {
      949:  210:  FunctionType functionType = funcOp.getFunctionType();
call    0 returned 100%
      949:  211:  SmallVector<Type, 4> resultTypes;
call    0 returned 100%
      949:  212:  FunctionType newFuncType;
      949:  213:  resultTypes = llvm::to_vector<4>(functionType.getResults());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  214:
        -:  215:  // External function's signature was already updated in
        -:  216:  // 'normalizeFuncOpMemRefs()'.
      949:  217:  if (!funcOp.isExternal()) {
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
     1722:  218:    SmallVector<Type, 8> argTypes;
call    0 returned 100%
     2579:  219:    for (const auto &argEn : llvm::enumerate(funcOp.getArguments()))
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
call    3 returned 100%
     1718:  220:      argTypes.push_back(argEn.value().getType());
call    0 returned 100%
        -:  221:
        -:  222:    // Traverse ReturnOps to check if an update to the return type in the
        -:  223:    // function signature is required.
function _ZZN12_GLOBAL__N_116NormalizeMemRefs23updateFunctionSignatureEN4mlir4func6FuncOpENS1_8ModuleOpEENKUlNS2_8ReturnOpEE_clES5_.isra.0 called 861 returned 100% blocks executed 60%
     1722:  224:    funcOp.walk([&](func::ReturnOp returnOp) {
call    0 returned 100%
     4847:  225:      for (const auto &operandEn : llvm::enumerate(returnOp.getOperands())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
     1993:  226:        Type opType = operandEn.value().getType();
call    0 returned 100%
     1993:  227:        MemRefType memrefType = opType.dyn_cast<MemRefType>();
call    0 returned 100%
        -:  228:        // If type is not memref or if the memref type is same as that in
        -:  229:        // function's return signature then no update is required.
    1993*:  230:        if (!memrefType || memrefType == resultTypes[operandEn.index()])
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
     1993:  231:          continue;
        -:  232:        // Update function's return type signature.
        -:  233:        // Return type gets normalized either as a result of function argument
        -:  234:        // normalization, AllocOp normalization or an update made at CallOp.
        -:  235:        // There can be many call flows inside a function and an update to a
        -:  236:        // specific ReturnOp has not yet been made. So we check that the result
        -:  237:        // memref type is normalized.
        -:  238:        // TODO: When selective normalization is implemented, handle multiple
        -:  239:        // results case where some are normalized, some aren't.
    #####:  240:        if (memrefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:          resultTypes[operandEn.index()] = memrefType;
branch  0 never executed
branch  1 never executed
        -:  242:      }
      861:  243:    });
        -:  244:
        -:  245:    // We create a new function type and modify the function signature with this
        -:  246:    // new type.
      861:  247:    newFuncType = FunctionType::get(&getContext(), /*inputs=*/argTypes,
call    0 returned 100%
      861:  248:                                    /*results=*/resultTypes);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -:  249:  }
        -:  250:
        -:  251:  // Since we update the function signature, it might affect the result types at
        -:  252:  // the caller site. Since this result might even be used by the caller
        -:  253:  // function in ReturnOps, the caller function's signature will also change.
        -:  254:  // Hence we record the caller function in 'funcOpsToUpdate' to update their
        -:  255:  // signature as well.
     1898:  256:  llvm::SmallDenseSet<func::FuncOp, 8> funcOpsToUpdate;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  257:  // We iterate over all symbolic uses of the function and update the return
        -:  258:  // type at the caller site.
     1898:  259:  Optional<SymbolTable::UseRange> symbolUses = funcOp.getSymbolUses(moduleOp);
call    0 returned 100%
call    1 returned 100%
     949*:  260:  for (SymbolTable::SymbolUse symbolUse : *symbolUses) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
    #####:  261:    Operation *userOp = symbolUse.getUser();
call    0 never executed
    #####:  262:    OpBuilder builder(userOp);
call    0 never executed
        -:  263:    // When `userOp` can not be casted to `CallOp`, it is skipped. This assumes
        -:  264:    // that the non-CallOp has no memrefs to be replaced.
        -:  265:    // TODO: Handle cases where a non-CallOp symbol use of a function deals with
        -:  266:    // memrefs.
    #####:  267:    auto callOp = dyn_cast<func::CallOp>(userOp);
call    0 never executed
    #####:  268:    if (!callOp)
branch  0 never executed
branch  1 never executed
    #####:  269:      continue;
    #####:  270:    Operation *newCallOp =
call    0 never executed
    #####:  271:        builder.create<func::CallOp>(userOp->getLoc(), callOp.getCalleeAttr(),
    #####:  272:                                     resultTypes, userOp->getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  273:    bool replacingMemRefUsesFailed = false;
    #####:  274:    bool returnTypeChanged = false;
    #####:  275:    for (unsigned resIndex : llvm::seq<unsigned>(0, userOp->getNumResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  276:      OpResult oldResult = userOp->getResult(resIndex);
branch  0 never executed
branch  1 never executed
    #####:  277:      OpResult newResult = newCallOp->getResult(resIndex);
branch  0 never executed
branch  1 never executed
        -:  278:      // This condition ensures that if the result is not of type memref or if
        -:  279:      // the resulting memref was already having a trivial map layout then we
        -:  280:      // need not perform any use replacement here.
    #####:  281:      if (oldResult.getType() == newResult.getType())
branch  0 never executed
branch  1 never executed
    #####:  282:        continue;
    #####:  283:      AffineMap layoutMap =
    #####:  284:          oldResult.getType().cast<MemRefType>().getLayout().getAffineMap();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  285:      if (failed(replaceAllMemRefUsesWith(oldResult, /*newMemRef=*/newResult,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  286:                                          /*extraIndices=*/{},
        -:  287:                                          /*indexRemap=*/layoutMap,
        -:  288:                                          /*extraOperands=*/{},
        -:  289:                                          /*symbolOperands=*/{},
        -:  290:                                          /*domOpFilter=*/nullptr,
        -:  291:                                          /*postDomOpFilter=*/nullptr,
        -:  292:                                          /*allowNonDereferencingOps=*/true,
        -:  293:                                          /*replaceInDeallocOp=*/true))) {
        -:  294:        // If it failed (due to escapes for example), bail out.
        -:  295:        // It should never hit this part of the code because it is called by
        -:  296:        // only those functions which are normalizable.
    #####:  297:        newCallOp->erase();
call    0 never executed
    #####:  298:        replacingMemRefUsesFailed = true;
    #####:  299:        break;
        -:  300:      }
    #####:  301:      returnTypeChanged = true;
        -:  302:    }
    #####:  303:    if (replacingMemRefUsesFailed)
    #####:  304:      continue;
        -:  305:    // Replace all uses for other non-memref result types.
    #####:  306:    userOp->replaceAllUsesWith(newCallOp);
branch  0 never executed
branch  1 never executed
    #####:  307:    userOp->erase();
call    0 never executed
    #####:  308:    if (returnTypeChanged) {
branch  0 never executed
branch  1 never executed
        -:  309:      // Since the return type changed it might lead to a change in function's
        -:  310:      // signature.
        -:  311:      // TODO: If funcOp doesn't return any memref type then no need to update
        -:  312:      // signature.
        -:  313:      // TODO: Further optimization - Check if the memref is indeed part of
        -:  314:      // ReturnOp at the parentFuncOp and only then updation of signature is
        -:  315:      // required.
        -:  316:      // TODO: Extend this for ops that are FunctionOpInterface. This would
        -:  317:      // require creating an OpInterface for FunctionOpInterface ops.
    #####:  318:      func::FuncOp parentFuncOp = newCallOp->getParentOfType<func::FuncOp>();
call    0 never executed
    #####:  319:      funcOpsToUpdate.insert(parentFuncOp);
call    0 never executed
        -:  320:    }
        -:  321:  }
        -:  322:  // Because external function's signature is already updated in
        -:  323:  // 'normalizeFuncOpMemRefs()', we don't need to update it here again.
      949:  324:  if (!funcOp.isExternal())
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
      861:  325:    funcOp.setType(newFuncType);
call    0 returned 100%
        -:  326:
        -:  327:  // Updating the signature type of those functions which call the current
        -:  328:  // function. Only if the return type of the current function has a normalized
        -:  329:  // memref will the caller function become a candidate for signature update.
    1898*:  330:  for (func::FuncOp parentFuncOp : funcOpsToUpdate)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
    #####:  331:    updateFunctionSignature(parentFuncOp, moduleOp);
call    0 never executed
      949:  332:}
        -:  333:
        -:  334:/// Normalizes the memrefs within a function which includes those arising as a
        -:  335:/// result of AllocOps, CallOps and function's argument. The ModuleOp argument
        -:  336:/// is used to help update function's signature after normalization.
function _ZN12_GLOBAL__N_116NormalizeMemRefs22normalizeFuncOpMemRefsEN4mlir4func6FuncOpENS1_8ModuleOpE called 949 returned 100% blocks executed 65%
      949:  337:void NormalizeMemRefs::normalizeFuncOpMemRefs(func::FuncOp funcOp,
        -:  338:                                              ModuleOp moduleOp) {
        -:  339:  // Turn memrefs' non-identity layouts maps into ones with identity. Collect
        -:  340:  // alloc ops first and then process since normalizeMemRef replaces/erases ops
        -:  341:  // during memref rewriting.
      949:  342:  SmallVector<memref::AllocOp, 4> allocOps;
call    0 returned 100%
     949*:  343:  funcOp.walk([&](memref::AllocOp op) { allocOps.push_back(op); });
call    0 never executed
call    1 returned 100%
     949*:  344:  for (memref::AllocOp allocOp : allocOps)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  345:    (void)normalizeMemRef(&allocOp);
call    0 never executed
        -:  346:
        -:  347:  // We use this OpBuilder to create new memref layout later.
      949:  348:  OpBuilder b(funcOp);
call    0 returned 100%
        -:  349:
      949:  350:  FunctionType functionType = funcOp.getFunctionType();
call    0 returned 100%
     1898:  351:  SmallVector<Location> functionArgLocs(llvm::map_range(
     1898:  352:      funcOp.getArguments(), [](BlockArgument arg) { return arg.getLoc(); }));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1898:  353:  SmallVector<Type, 8> inputTypes;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  354:  // Walk over each argument of a function to perform memref normalization (if
      949:  355:  for (unsigned argIndex :
     4625:  356:       llvm::seq<unsigned>(0, functionType.getNumInputs())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 66% (fallthrough)
branch  3 taken 34%
call    4 returned 100%
     1838:  357:    Type argType = functionType.getInput(argIndex);
call    0 returned 100%
     1838:  358:    MemRefType memrefType = argType.dyn_cast<MemRefType>();
call    0 returned 100%
        -:  359:    // Check whether argument is of MemRef type. Any other argument type can
        -:  360:    // simply be part of the final function signature.
     1838:  361:    if (!memrefType) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     1831:  362:      inputTypes.push_back(argType);
call    0 returned 100%
     1838:  363:      continue;
        -:  364:    }
        -:  365:    // Fetch a new memref type after normalizing the old memref to have an
        -:  366:    // identity map layout.
        7:  367:    MemRefType newMemRefType = normalizeMemRefType(memrefType,
        7:  368:                                                   /*numSymbolicOperands=*/0);
call    0 returned 100%
       7*:  369:    if (newMemRefType == memrefType || funcOp.isExternal()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  370:      // Either memrefType already had an identity map or the map couldn't be
        -:  371:      // transformed to an identity map.
        7:  372:      inputTypes.push_back(newMemRefType);
call    0 returned 100%
        7:  373:      continue;
        -:  374:    }
        -:  375:
        -:  376:    // Insert a new temporary argument with the new memref type.
    #####:  377:    BlockArgument newMemRef = funcOp.front().insertArgument(
call    0 never executed
    #####:  378:        argIndex, newMemRefType, functionArgLocs[argIndex]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  379:    BlockArgument oldMemRef = funcOp.getArgument(argIndex + 1);
call    0 never executed
    #####:  380:    AffineMap layoutMap = memrefType.getLayout().getAffineMap();
call    0 never executed
call    1 never executed
        -:  381:    // Replace all uses of the old memref.
    #####:  382:    if (failed(replaceAllMemRefUsesWith(oldMemRef, /*newMemRef=*/newMemRef,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  383:                                        /*extraIndices=*/{},
        -:  384:                                        /*indexRemap=*/layoutMap,
        -:  385:                                        /*extraOperands=*/{},
        -:  386:                                        /*symbolOperands=*/{},
        -:  387:                                        /*domOpFilter=*/nullptr,
        -:  388:                                        /*postDomOpFilter=*/nullptr,
        -:  389:                                        /*allowNonDereferencingOps=*/true,
        -:  390:                                        /*replaceInDeallocOp=*/true))) {
        -:  391:      // If it failed (due to escapes for example), bail out. Removing the
        -:  392:      // temporary argument inserted previously.
    #####:  393:      funcOp.front().eraseArgument(argIndex);
call    0 never executed
call    1 never executed
    #####:  394:      continue;
        -:  395:    }
        -:  396:
        -:  397:    // All uses for the argument with old memref type were replaced
        -:  398:    // successfully. So we remove the old argument now.
    #####:  399:    funcOp.front().eraseArgument(argIndex + 1);
call    0 never executed
call    1 never executed
        -:  400:  }
        -:  401:
        -:  402:  // Walk over normalizable operations to normalize memrefs of the operation
        -:  403:  // results. When `op` has memrefs with affine map in the operation results,
        -:  404:  // new operation containin normalized memrefs is created. Then, the memrefs
        -:  405:  // are replaced. `CallOp` is skipped here because it is handled in
        -:  406:  // `updateFunctionSignature()`.
function _ZZN12_GLOBAL__N_116NormalizeMemRefs22normalizeFuncOpMemRefsEN4mlir4func6FuncOpENS1_8ModuleOpEENKUlPNS1_9OperationEE1_clES6_.isra.0 called 10474 returned 100% blocks executed 10%
      949:  407:  funcOp.walk([&](Operation *op) {
call    0 returned 100%
    11335:  408:    if (op->hasTrait<OpTrait::MemRefsNormalizable>() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   10474*:  409:        op->getNumResults() > 0 && !isa<func::CallOp>(op) &&
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  410:        !funcOp.isExternal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  411:      // Create newOp containing normalized memref in the operation result.
    #####:  412:      Operation *newOp = createOpResultsNormalized(funcOp, op);
call    0 never executed
        -:  413:      // When all of the operation results have no memrefs or memrefs without
        -:  414:      // affine map, `newOp` is the same with `op` and following process is
        -:  415:      // skipped.
    #####:  416:      if (op != newOp) {
branch  0 never executed
branch  1 never executed
    #####:  417:        bool replacingMemRefUsesFailed = false;
    #####:  418:        for (unsigned resIndex : llvm::seq<unsigned>(0, op->getNumResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  419:          // Replace all uses of the old memrefs.
    #####:  420:          Value oldMemRef = op->getResult(resIndex);
branch  0 never executed
branch  1 never executed
    #####:  421:          Value newMemRef = newOp->getResult(resIndex);
branch  0 never executed
branch  1 never executed
    #####:  422:          MemRefType oldMemRefType = oldMemRef.getType().dyn_cast<MemRefType>();
call    0 never executed
        -:  423:          // Check whether the operation result is MemRef type.
    #####:  424:          if (!oldMemRefType)
branch  0 never executed
branch  1 never executed
    #####:  425:            continue;
    #####:  426:          MemRefType newMemRefType = newMemRef.getType().cast<MemRefType>();
call    0 never executed
    #####:  427:          if (oldMemRefType == newMemRefType)
branch  0 never executed
branch  1 never executed
    #####:  428:            continue;
        -:  429:          // TODO: Assume single layout map. Multiple maps not supported.
    #####:  430:          AffineMap layoutMap = oldMemRefType.getLayout().getAffineMap();
call    0 never executed
call    1 never executed
    #####:  431:          if (failed(replaceAllMemRefUsesWith(oldMemRef,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  432:                                              /*newMemRef=*/newMemRef,
        -:  433:                                              /*extraIndices=*/{},
        -:  434:                                              /*indexRemap=*/layoutMap,
        -:  435:                                              /*extraOperands=*/{},
        -:  436:                                              /*symbolOperands=*/{},
        -:  437:                                              /*domOpFilter=*/nullptr,
        -:  438:                                              /*postDomOpFilter=*/nullptr,
        -:  439:                                              /*allowNonDereferencingOps=*/true,
        -:  440:                                              /*replaceInDeallocOp=*/true))) {
    #####:  441:            newOp->erase();
call    0 never executed
    #####:  442:            replacingMemRefUsesFailed = true;
    #####:  443:            continue;
        -:  444:          }
        -:  445:        }
    #####:  446:        if (!replacingMemRefUsesFailed) {
branch  0 never executed
branch  1 never executed
        -:  447:          // Replace other ops with new op and delete the old op when the
        -:  448:          // replacement succeeded.
    #####:  449:          op->replaceAllUsesWith(newOp);
branch  0 never executed
branch  1 never executed
    #####:  450:          op->erase();
call    0 never executed
        -:  451:        }
        -:  452:      }
        -:  453:    }
    10474:  454:  });
        -:  455:
        -:  456:  // In a normal function, memrefs in the return type signature gets normalized
        -:  457:  // as a result of normalization of functions arguments, AllocOps or CallOps'
        -:  458:  // result types. Since an external function doesn't have a body, memrefs in
        -:  459:  // the return type signature can only get normalized by iterating over the
        -:  460:  // individual return types.
      949:  461:  if (funcOp.isExternal()) {
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
      176:  462:    SmallVector<Type, 4> resultTypes;
call    0 returned 100%
       88:  463:    for (unsigned resIndex :
      160:  464:         llvm::seq<unsigned>(0, functionType.getNumResults())) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
call    4 returned 100%
       36:  465:      Type resType = functionType.getResult(resIndex);
call    0 returned 100%
       36:  466:      MemRefType memrefType = resType.dyn_cast<MemRefType>();
call    0 returned 100%
        -:  467:      // Check whether result is of MemRef type. Any other argument type can
        -:  468:      // simply be part of the final function signature.
       36:  469:      if (!memrefType) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       36:  470:        resultTypes.push_back(resType);
call    0 returned 100%
       36:  471:        continue;
        -:  472:      }
        -:  473:      // Computing a new memref type after normalizing the old memref to have an
        -:  474:      // identity map layout.
    #####:  475:      MemRefType newMemRefType = normalizeMemRefType(memrefType,
    #####:  476:                                                     /*numSymbolicOperands=*/0);
call    0 never executed
    #####:  477:      resultTypes.push_back(newMemRefType);
call    0 never executed
        -:  478:    }
        -:  479:
       88:  480:    FunctionType newFuncType =
call    0 returned 100%
       88:  481:        FunctionType::get(&getContext(), /*inputs=*/inputTypes,
       88:  482:                          /*results=*/resultTypes);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  483:    // Setting the new function signature for this external function.
       88:  484:    funcOp.setType(newFuncType);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  485:  }
      949:  486:  updateFunctionSignature(funcOp, moduleOp);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      949:  487:}
        -:  488:
        -:  489:/// Create an operation containing normalized memrefs in the operation results.
        -:  490:/// When the results of `oldOp` have memrefs with affine map, the memrefs are
        -:  491:/// normalized, and new operation containing them in the operation results is
        -:  492:/// returned. If all of the results of `oldOp` have no memrefs or memrefs
        -:  493:/// without affine map, `oldOp` is returned without modification.
        -:  494:Operation *NormalizeMemRefs::createOpResultsNormalized(func::FuncOp funcOp,
        -:  495:                                                       Operation *oldOp) {
        -:  496:  // Prepare OperationState to create newOp containing normalized memref in
        -:  497:  // the operation results.
        -:  498:  OperationState result(oldOp->getLoc(), oldOp->getName());
        -:  499:  result.addOperands(oldOp->getOperands());
        -:  500:  result.addAttributes(oldOp->getAttrs());
        -:  501:  // Add normalized MemRefType to the OperationState.
        -:  502:  SmallVector<Type, 4> resultTypes;
        -:  503:  OpBuilder b(funcOp);
        -:  504:  bool resultTypeNormalized = false;
        -:  505:  for (unsigned resIndex : llvm::seq<unsigned>(0, oldOp->getNumResults())) {
        -:  506:    auto resultType = oldOp->getResult(resIndex).getType();
        -:  507:    MemRefType memrefType = resultType.dyn_cast<MemRefType>();
        -:  508:    // Check whether the operation result is MemRef type.
        -:  509:    if (!memrefType) {
        -:  510:      resultTypes.push_back(resultType);
        -:  511:      continue;
        -:  512:    }
        -:  513:    // Fetch a new memref type after normalizing the old memref.
        -:  514:    MemRefType newMemRefType = normalizeMemRefType(memrefType,
        -:  515:                                                   /*numSymbolicOperands=*/0);
        -:  516:    if (newMemRefType == memrefType) {
        -:  517:      // Either memrefType already had an identity map or the map couldn't
        -:  518:      // be transformed to an identity map.
        -:  519:      resultTypes.push_back(memrefType);
        -:  520:      continue;
        -:  521:    }
        -:  522:    resultTypes.push_back(newMemRefType);
        -:  523:    resultTypeNormalized = true;
        -:  524:  }
        -:  525:  result.addTypes(resultTypes);
        -:  526:  // When all of the results of `oldOp` have no memrefs or memrefs without
        -:  527:  // affine map, `oldOp` is returned without modification.
        -:  528:  if (resultTypeNormalized) {
        -:  529:    OpBuilder bb(oldOp);
        -:  530:    for (auto &oldRegion : oldOp->getRegions()) {
        -:  531:      Region *newRegion = result.addRegion();
        -:  532:      newRegion->takeBody(oldRegion);
        -:  533:    }
        -:  534:    return bb.create(result);
        -:  535:  }
        -:  536:  return oldOp;
        -:  537:}
