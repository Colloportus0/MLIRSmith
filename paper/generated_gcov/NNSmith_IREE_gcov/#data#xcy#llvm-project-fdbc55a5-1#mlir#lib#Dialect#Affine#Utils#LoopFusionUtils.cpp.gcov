        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Affine/Utils/LoopFusionUtils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Utils/CMakeFiles/obj.MLIRAffineUtils.dir/LoopFusionUtils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Utils/CMakeFiles/obj.MLIRAffineUtils.dir/LoopFusionUtils.cpp.gcda
        -:    0:Runs:325545
        -:    1://===- LoopFusionUtils.cpp ---- Utilities for loop fusion ----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements loop fusion transformation utility functions.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Affine/LoopFusionUtils.h"
        -:   14:#include "mlir/Analysis/SliceAnalysis.h"
        -:   15:#include "mlir/Dialect/Affine/Analysis/AffineAnalysis.h"
        -:   16:#include "mlir/Dialect/Affine/Analysis/AffineStructures.h"
        -:   17:#include "mlir/Dialect/Affine/Analysis/LoopAnalysis.h"
        -:   18:#include "mlir/Dialect/Affine/Analysis/Utils.h"
        -:   19:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   20:#include "mlir/Dialect/Affine/LoopUtils.h"
        -:   21:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   22:#include "mlir/IR/AffineExpr.h"
        -:   23:#include "mlir/IR/AffineMap.h"
        -:   24:#include "mlir/IR/BlockAndValueMapping.h"
        -:   25:#include "mlir/IR/Builders.h"
        -:   26:#include "mlir/IR/BuiltinOps.h"
        -:   27:#include "mlir/IR/Operation.h"
        -:   28:#include "llvm/ADT/DenseMap.h"
        -:   29:#include "llvm/ADT/SmallVector.h"
        -:   30:#include "llvm/Support/Debug.h"
        -:   31:#include "llvm/Support/raw_ostream.h"
        -:   32:
        -:   33:#define DEBUG_TYPE "loop-fusion-utils"
        -:   34:
        -:   35:using namespace mlir;
        -:   36:
        -:   37:// Gathers all load and store memref accesses in 'opA' into 'values', where
        -:   38:// 'values[memref] == true' for each store operation.
    #####:   39:static void getLoadAndStoreMemRefAccesses(Operation *opA,
        -:   40:                                          DenseMap<Value, bool> &values) {
function _ZZL29getLoadAndStoreMemRefAccessesPN4mlir9OperationERN4llvm8DenseMapINS_5ValueEbNS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_bEEEEENKUlS1_E_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   41:  opA->walk([&](Operation *op) {
    #####:   42:    if (auto loadOp = dyn_cast<AffineReadOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:      if (values.count(loadOp.getMemRef()) == 0)
call    0 never executed
call    1 never executed
    #####:   44:        values[loadOp.getMemRef()] = false;
call    0 never executed
call    1 never executed
    #####:   45:    } else if (auto storeOp = dyn_cast<AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   46:      values[storeOp.getMemRef()] = true;
call    0 never executed
call    1 never executed
        -:   47:    }
    #####:   48:  });
        -:   49:}
        -:   50:
        -:   51:/// Returns true if 'op' is a load or store operation which access a memref
        -:   52:/// accessed 'values' and at least one of the access is a store operation.
        -:   53:/// Returns false otherwise.
function _ZL24isDependentLoadOrStoreOpPN4mlir9OperationERN4llvm8DenseMapINS_5ValueEbNS2_12DenseMapInfoIS4_vEENS2_6detail12DenseMapPairIS4_bEEEE called 0 returned 0% blocks executed 0%
    #####:   54:static bool isDependentLoadOrStoreOp(Operation *op,
        -:   55:                                     DenseMap<Value, bool> &values) {
    #####:   56:  if (auto loadOp = dyn_cast<AffineReadOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   57:    return values.count(loadOp.getMemRef()) > 0 && values[loadOp.getMemRef()];
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:   58:  }
    #####:   59:  if (auto storeOp = dyn_cast<AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   60:    return values.count(storeOp.getMemRef()) > 0;
call    0 never executed
call    1 never executed
        -:   61:  }
    #####:   62:  return false;
        -:   63:}
        -:   64:
        -:   65:// Returns the first operation in range ('opA', 'opB') which has a data
        -:   66:// dependence on 'opA'. Returns 'nullptr' of no dependence exists.
function _ZL26getFirstDependentOpInRangePN4mlir9OperationES1_ called 0 returned 0% blocks executed 0%
    #####:   67:static Operation *getFirstDependentOpInRange(Operation *opA, Operation *opB) {
        -:   68:  // Record memref values from all loads/store in loop nest rooted at 'opA'.
        -:   69:  // Map from memref value to bool which is true if store, false otherwise.
    #####:   70:  DenseMap<Value, bool> values;
call    0 never executed
    #####:   71:  getLoadAndStoreMemRefAccesses(opA, values);
call    0 never executed
        -:   72:
        -:   73:  // For each 'opX' in block in range ('opA', 'opB'), check if there is a data
        -:   74:  // dependence from 'opA' to 'opX' ('opA' and 'opX' access the same memref
        -:   75:  // and at least one of the accesses is a store).
    #####:   76:  Operation *firstDepOp = nullptr;
    #####:   77:  for (Block::iterator it = std::next(Block::iterator(opA));
call    0 never executed
    #####:   78:       it != Block::iterator(opB); ++it) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:    Operation *opX = &(*it);
call    0 never executed
function _ZZL26getFirstDependentOpInRangePN4mlir9OperationES1_ENKUlS1_E_clES1_ called 0 returned 0% blocks executed 0%
    #####:   80:    opX->walk([&](Operation *op) {
call    0 never executed
    #####:   81:      if (!firstDepOp && isDependentLoadOrStoreOp(op, values))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   82:        firstDepOp = opX;
    #####:   83:    });
    #####:   84:    if (firstDepOp)
branch  0 never executed
branch  1 never executed
        -:   85:      break;
        -:   86:  }
    #####:   87:  return firstDepOp;
call    0 never executed
        -:   88:}
        -:   89:
        -:   90:// Returns the last operation 'opX' in range ('opA', 'opB'), for which there
        -:   91:// exists a data dependence from 'opX' to 'opB'.
        -:   92:// Returns 'nullptr' of no dependence exists.
function _ZL25getLastDependentOpInRangePN4mlir9OperationES1_ called 0 returned 0% blocks executed 0%
    #####:   93:static Operation *getLastDependentOpInRange(Operation *opA, Operation *opB) {
        -:   94:  // Record memref values from all loads/store in loop nest rooted at 'opB'.
        -:   95:  // Map from memref value to bool which is true if store, false otherwise.
    #####:   96:  DenseMap<Value, bool> values;
call    0 never executed
    #####:   97:  getLoadAndStoreMemRefAccesses(opB, values);
call    0 never executed
        -:   98:
        -:   99:  // For each 'opX' in block in range ('opA', 'opB') in reverse order,
        -:  100:  // check if there is a data dependence from 'opX' to 'opB':
        -:  101:  // *) 'opX' and 'opB' access the same memref and at least one of the accesses
        -:  102:  //    is a store.
        -:  103:  // *) 'opX' produces an SSA Value which is used by 'opB'.
    #####:  104:  Operation *lastDepOp = nullptr;
    #####:  105:  for (Block::reverse_iterator it = std::next(Block::reverse_iterator(opB));
call    0 never executed
    #####:  106:       it != Block::reverse_iterator(opA); ++it) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  107:    Operation *opX = &(*it);
call    0 never executed
function _ZZL25getLastDependentOpInRangePN4mlir9OperationES1_ENKUlS1_E_clES1_ called 0 returned 0% blocks executed 0%
    #####:  108:    opX->walk([&](Operation *op) {
    #####:  109:      if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  110:        if (isDependentLoadOrStoreOp(op, values)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  111:          lastDepOp = opX;
    #####:  112:          return WalkResult::interrupt();
        -:  113:        }
    #####:  114:        return WalkResult::advance();
        -:  115:      }
    #####:  116:      for (auto value : op->getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  117:        for (Operation *user : value.getUsers()) {
branch  0 never executed
branch  1 never executed
    #####:  118:          SmallVector<AffineForOp, 4> loops;
call    0 never executed
        -:  119:          // Check if any loop in loop nest surrounding 'user' is 'opB'.
    #####:  120:          getLoopIVs(*user, &loops);
call    0 never executed
    #####:  121:          if (llvm::is_contained(loops, cast<AffineForOp>(opB))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  122:            lastDepOp = opX;
    #####:  123:            return WalkResult::interrupt();
branch  0 never executed
branch  1 never executed
        -:  124:          }
        -:  125:        }
        -:  126:      }
    #####:  127:      return WalkResult::advance();
    #####:  128:    });
call    0 never executed
    #####:  129:    if (lastDepOp)
branch  0 never executed
branch  1 never executed
        -:  130:      break;
        -:  131:  }
    #####:  132:  return lastDepOp;
call    0 never executed
        -:  133:}
        -:  134:
        -:  135:// Computes and returns an insertion point operation, before which the
        -:  136:// the fused <srcForOp, dstForOp> loop nest can be inserted while preserving
        -:  137:// dependences. Returns nullptr if no such insertion point is found.
function _ZL30getFusedLoopNestInsertionPointN4mlir11AffineForOpES0_ called 0 returned 0% blocks executed 0%
    #####:  138:static Operation *getFusedLoopNestInsertionPoint(AffineForOp srcForOp,
        -:  139:                                                 AffineForOp dstForOp) {
    #####:  140:  bool isSrcForOpBeforeDstForOp =
    #####:  141:      srcForOp->isBeforeInBlock(dstForOp.getOperation());
call    0 never executed
    #####:  142:  auto forOpA = isSrcForOpBeforeDstForOp ? srcForOp : dstForOp;
branch  0 never executed
branch  1 never executed
    #####:  143:  auto forOpB = isSrcForOpBeforeDstForOp ? dstForOp : srcForOp;
branch  0 never executed
branch  1 never executed
        -:  144:
    #####:  145:  auto *firstDepOpA =
    #####:  146:      getFirstDependentOpInRange(forOpA.getOperation(), forOpB.getOperation());
call    0 never executed
    #####:  147:  auto *lastDepOpB =
    #####:  148:      getLastDependentOpInRange(forOpA.getOperation(), forOpB.getOperation());
call    0 never executed
        -:  149:  // Block:
        -:  150:  //      ...
        -:  151:  //  |-- opA
        -:  152:  //  |   ...
        -:  153:  //  |   lastDepOpB --|
        -:  154:  //  |   ...          |
        -:  155:  //  |-> firstDepOpA  |
        -:  156:  //      ...          |
        -:  157:  //      opB <---------
        -:  158:  //
        -:  159:  // Valid insertion point range: (lastDepOpB, firstDepOpA)
        -:  160:  //
    #####:  161:  if (firstDepOpA != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  162:    if (lastDepOpB != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  163:      if (firstDepOpA->isBeforeInBlock(lastDepOpB) || firstDepOpA == lastDepOpB)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  164:        // No valid insertion point exists which preserves dependences.
        -:  165:        return nullptr;
        -:  166:    }
        -:  167:    // Return insertion point in valid range closest to 'opB'.
        -:  168:    // TODO: Consider other insertion points in valid range.
    #####:  169:    return firstDepOpA;
        -:  170:  }
        -:  171:  // No dependences from 'opA' to operation in range ('opA', 'opB'), return
        -:  172:  // 'opB' insertion point.
        -:  173:  return forOpB.getOperation();
        -:  174:}
        -:  175:
        -:  176:// Gathers all load and store ops in loop nest rooted at 'forOp' into
        -:  177:// 'loadAndStoreOps'.
        -:  178:static bool
    #####:  179:gatherLoadsAndStores(AffineForOp forOp,
        -:  180:                     SmallVectorImpl<Operation *> &loadAndStoreOps) {
    #####:  181:  bool hasIfOp = false;
function _ZZL20gatherLoadsAndStoresN4mlir11AffineForOpERN4llvm15SmallVectorImplIPNS_9OperationEEEENKUlS4_E_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  182:  forOp.walk([&](Operation *op) {
    #####:  183:    if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  184:      loadAndStoreOps.push_back(op);
call    0 never executed
    #####:  185:    else if (isa<AffineIfOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  186:      hasIfOp = true;
    #####:  187:  });
    #####:  188:  return !hasIfOp;
        -:  189:}
        -:  190:
        -:  191:/// Returns the maximum loop depth at which we could fuse producer loop
        -:  192:/// 'srcForOp' into consumer loop 'dstForOp' without violating data dependences.
        -:  193:// TODO: Generalize this check for sibling and more generic fusion scenarios.
        -:  194:// TODO: Support forward slice fusion.
function _ZL15getMaxLoopDepthN4llvm8ArrayRefIPN4mlir9OperationEEES4_ called 0 returned 0% blocks executed 0%
    #####:  195:static unsigned getMaxLoopDepth(ArrayRef<Operation *> srcOps,
        -:  196:                                ArrayRef<Operation *> dstOps) {
    #####:  197:  if (dstOps.empty())
branch  0 never executed
branch  1 never executed
        -:  198:    // Expected at least one memory operation.
        -:  199:    // TODO: Revisit this case with a specific example.
        -:  200:    return 0;
        -:  201:
        -:  202:  // Filter out ops in 'dstOps' that do not use the producer-consumer memref so
        -:  203:  // that they are not considered for analysis.
    #####:  204:  DenseSet<Value> producerConsumerMemrefs;
call    0 never executed
    #####:  205:  gatherProducerConsumerMemrefs(srcOps, dstOps, producerConsumerMemrefs);
call    0 never executed
    #####:  206:  SmallVector<Operation *, 4> targetDstOps;
call    0 never executed
    #####:  207:  for (Operation *dstOp : dstOps) {
branch  0 never executed
branch  1 never executed
    #####:  208:    auto loadOp = dyn_cast<AffineReadOpInterface>(dstOp);
call    0 never executed
    #####:  209:    Value memref = loadOp ? loadOp.getMemRef()
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  210:                          : cast<AffineWriteOpInterface>(dstOp).getMemRef();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  211:    if (producerConsumerMemrefs.count(memref) > 0)
call    0 never executed
    #####:  212:      targetDstOps.push_back(dstOp);
call    0 never executed
        -:  213:  }
        -:  214:
    #####:  215:  assert(!targetDstOps.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  216:         "No dependences between 'srcForOp' and 'dstForOp'?");
        -:  217:
        -:  218:  // Compute the innermost common loop depth for loads and stores.
    #####:  219:  unsigned loopDepth = getInnermostCommonLoopDepth(targetDstOps);
call    0 never executed
        -:  220:
        -:  221:  // Return common loop depth for loads if there are no store ops.
    #####:  222:  if (all_of(targetDstOps,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  223:             [&](Operation *op) { return isa<AffineReadOpInterface>(op); }))
        -:  224:    return loopDepth;
        -:  225:
        -:  226:  // Check dependences on all pairs of ops in 'targetDstOps' and store the
        -:  227:  // minimum loop depth at which a dependence is satisfied.
    #####:  228:  for (unsigned i = 0, e = targetDstOps.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  229:    auto *srcOpInst = targetDstOps[i];
branch  0 never executed
branch  1 never executed
    #####:  230:    MemRefAccess srcAccess(srcOpInst);
    #####:  231:    for (unsigned j = 0; j < e; ++j) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  232:      auto *dstOpInst = targetDstOps[j];
branch  0 never executed
branch  1 never executed
    #####:  233:      MemRefAccess dstAccess(dstOpInst);
call    0 never executed
        -:  234:
    #####:  235:      unsigned numCommonLoops =
    #####:  236:          getNumCommonSurroundingLoops(*srcOpInst, *dstOpInst);
    #####:  237:      for (unsigned d = 1; d <= numCommonLoops + 1; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  238:        FlatAffineValueConstraints dependenceConstraints;
call    0 never executed
call    1 never executed
        -:  239:        // TODO: Cache dependence analysis results, check cache here.
    #####:  240:        DependenceResult result = checkMemrefAccessDependence(
        -:  241:            srcAccess, dstAccess, d, &dependenceConstraints,
    #####:  242:            /*dependenceComponents=*/nullptr);
call    0 never executed
    #####:  243:        if (hasDependence(result)) {
branch  0 never executed
branch  1 never executed
        -:  244:          // Store minimum loop depth and break because we want the min 'd' at
        -:  245:          // which there is a dependence.
    #####:  246:          loopDepth = std::min(loopDepth, d - 1);
branch  0 never executed
branch  1 never executed
    #####:  247:          break;
call    0 never executed
        -:  248:        }
        -:  249:      }
        -:  250:    }
        -:  251:  }
        -:  252:
    #####:  253:  return loopDepth;
        -:  254:}
        -:  255:
        -:  256:// TODO: Prevent fusion of loop nests with side-effecting operations.
        -:  257:// TODO: This pass performs some computation that is the same for all the depths
        -:  258:// (e.g., getMaxLoopDepth). Implement a version of this utility that processes
        -:  259:// all the depths at once or only the legal maximal depth for maximal fusion.
function _ZN4mlir12canFuseLoopsENS_11AffineForOpES0_jPNS_21ComputationSliceStateENS_14FusionStrategyE called 0 returned 0% blocks executed 0%
    #####:  260:FusionResult mlir::canFuseLoops(AffineForOp srcForOp, AffineForOp dstForOp,
        -:  261:                                unsigned dstLoopDepth,
        -:  262:                                ComputationSliceState *srcSlice,
        -:  263:                                FusionStrategy fusionStrategy) {
        -:  264:  // Return 'failure' if 'dstLoopDepth == 0'.
    #####:  265:  if (dstLoopDepth == 0) {
branch  0 never executed
branch  1 never executed
    #####:  266:    LLVM_DEBUG(llvm::dbgs() << "Cannot fuse loop nests at depth 0\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  267:    return FusionResult::FailPrecondition;
        -:  268:  }
        -:  269:  // Return 'failure' if 'srcForOp' and 'dstForOp' are not in the same block.
    #####:  270:  auto *block = srcForOp->getBlock();
branch  0 never executed
branch  1 never executed
    #####:  271:  if (block != dstForOp->getBlock()) {
branch  0 never executed
branch  1 never executed
    #####:  272:    LLVM_DEBUG(llvm::dbgs() << "Cannot fuse loop nests in different blocks\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  273:    return FusionResult::FailPrecondition;
        -:  274:  }
        -:  275:
        -:  276:  // Return 'failure' if no valid insertion point for fused loop nest in 'block'
        -:  277:  // exists which would preserve dependences.
    #####:  278:  if (!getFusedLoopNestInsertionPoint(srcForOp, dstForOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  279:    LLVM_DEBUG(llvm::dbgs() << "Fusion would violate dependences in block\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  280:    return FusionResult::FailBlockDependence;
        -:  281:  }
        -:  282:
        -:  283:  // Check if 'srcForOp' precedes 'dstForOp' in 'block'.
    #####:  284:  bool isSrcForOpBeforeDstForOp =
    #####:  285:      srcForOp->isBeforeInBlock(dstForOp.getOperation());
call    0 never executed
        -:  286:  // 'forOpA' executes before 'forOpB' in 'block'.
    #####:  287:  auto forOpA = isSrcForOpBeforeDstForOp ? srcForOp : dstForOp;
branch  0 never executed
branch  1 never executed
    #####:  288:  auto forOpB = isSrcForOpBeforeDstForOp ? dstForOp : srcForOp;
branch  0 never executed
branch  1 never executed
        -:  289:
        -:  290:  // Gather all load and store from 'forOpA' which precedes 'forOpB' in 'block'.
    #####:  291:  SmallVector<Operation *, 4> opsA;
call    0 never executed
    #####:  292:  if (!gatherLoadsAndStores(forOpA, opsA)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  293:    LLVM_DEBUG(llvm::dbgs() << "Fusing loops with affine.if unsupported\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  294:    return FusionResult::FailPrecondition;
        -:  295:  }
        -:  296:
        -:  297:  // Gather all load and store from 'forOpB' which succeeds 'forOpA' in 'block'.
    #####:  298:  SmallVector<Operation *, 4> opsB;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  299:  if (!gatherLoadsAndStores(forOpB, opsB)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  300:    LLVM_DEBUG(llvm::dbgs() << "Fusing loops with affine.if unsupported\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  301:    return FusionResult::FailPrecondition;
        -:  302:  }
        -:  303:
        -:  304:  // Return 'failure' if fusing loops at depth 'dstLoopDepth' wouldn't preserve
        -:  305:  // loop dependences.
        -:  306:  // TODO: Enable this check for sibling and more generic loop fusion
        -:  307:  // strategies.
    #####:  308:  if (fusionStrategy.getStrategy() == FusionStrategy::ProducerConsumer) {
branch  0 never executed
branch  1 never executed
        -:  309:    // TODO: 'getMaxLoopDepth' does not support forward slice fusion.
    #####:  310:    assert(isSrcForOpBeforeDstForOp && "Unexpected forward slice fusion");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  311:    if (getMaxLoopDepth(opsA, opsB) < dstLoopDepth) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  312:      LLVM_DEBUG(llvm::dbgs() << "Fusion would violate loop dependences\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  313:      return FusionResult::FailFusionDependence;
        -:  314:    }
        -:  315:  }
        -:  316:
        -:  317:  // Calculate the number of common loops surrounding 'srcForOp' and 'dstForOp'.
    #####:  318:  unsigned numCommonLoops = mlir::getNumCommonSurroundingLoops(
    #####:  319:      *srcForOp.getOperation(), *dstForOp.getOperation());
call    0 never executed
        -:  320:
        -:  321:  // Filter out ops in 'opsA' to compute the slice union based on the
        -:  322:  // assumptions made by the fusion strategy.
    #####:  323:  SmallVector<Operation *, 4> strategyOpsA;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  324:  switch (fusionStrategy.getStrategy()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  325:  case FusionStrategy::Generic:
        -:  326:    // Generic fusion. Take into account all the memory operations to compute
        -:  327:    // the slice union.
    #####:  328:    strategyOpsA.append(opsA.begin(), opsA.end());
call    0 never executed
    #####:  329:    break;
call    0 never executed
    #####:  330:  case FusionStrategy::ProducerConsumer:
        -:  331:    // Producer-consumer fusion (AffineLoopFusion pass) only takes into
        -:  332:    // account stores in 'srcForOp' to compute the slice union.
    #####:  333:    for (Operation *op : opsA) {
branch  0 never executed
branch  1 never executed
    #####:  334:      if (isa<AffineWriteOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:        strategyOpsA.push_back(op);
call    0 never executed
        -:  336:    }
        -:  337:    break;
    #####:  338:  case FusionStrategy::Sibling:
        -:  339:    // Sibling fusion (AffineLoopFusion pass) only takes into account the loads
        -:  340:    // to 'memref' in 'srcForOp' to compute the slice union.
    #####:  341:    for (Operation *op : opsA) {
branch  0 never executed
branch  1 never executed
    #####:  342:      auto load = dyn_cast<AffineReadOpInterface>(op);
call    0 never executed
    #####:  343:      if (load && load.getMemRef() == fusionStrategy.getSiblingFusionMemRef())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  344:        strategyOpsA.push_back(op);
call    0 never executed
        -:  345:    }
        -:  346:    break;
        -:  347:  }
        -:  348:
        -:  349:  // Compute union of computation slices computed between all pairs of ops
        -:  350:  // from 'forOpA' and 'forOpB'.
    #####:  351:  SliceComputationResult sliceComputationResult =
        -:  352:      mlir::computeSliceUnion(strategyOpsA, opsB, dstLoopDepth, numCommonLoops,
    #####:  353:                              isSrcForOpBeforeDstForOp, srcSlice);
call    0 never executed
    #####:  354:  if (sliceComputationResult.value == SliceComputationResult::GenericFailure) {
branch  0 never executed
branch  1 never executed
    #####:  355:    LLVM_DEBUG(llvm::dbgs() << "computeSliceUnion failed\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  356:    return FusionResult::FailPrecondition;
        -:  357:  }
    #####:  358:  if (sliceComputationResult.value ==
branch  0 never executed
branch  1 never executed
        -:  359:      SliceComputationResult::IncorrectSliceFailure) {
    #####:  360:    LLVM_DEBUG(llvm::dbgs() << "Incorrect slice computation\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  361:    return FusionResult::FailIncorrectSlice;
        -:  362:  }
        -:  363:
    #####:  364:  return FusionResult::Success;
        -:  365:}
        -:  366:
        -:  367:/// Patch the loop body of a forOp that is a single iteration reduction loop
        -:  368:/// into its containing block.
function _Z30promoteSingleIterReductionLoopN4mlir11AffineForOpEb called 0 returned 0% blocks executed 0%
    #####:  369:LogicalResult promoteSingleIterReductionLoop(AffineForOp forOp,
        -:  370:                                             bool siblingFusionUser) {
        -:  371:  // Check if the reduction loop is a single iteration loop.
    #####:  372:  Optional<uint64_t> tripCount = getConstantTripCount(forOp);
call    0 never executed
    #####:  373:  if (!tripCount || *tripCount != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  374:    return failure();
    #####:  375:  auto iterOperands = forOp.getIterOperands();
call    0 never executed
    #####:  376:  auto *parentOp = forOp->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  377:  if (!isa<AffineForOp>(parentOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  378:    return failure();
    #####:  379:  auto newOperands = forOp.getBody()->getTerminator()->getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  380:  OpBuilder b(parentOp);
call    0 never executed
        -:  381:  // Replace the parent loop and add iteroperands and results from the `forOp`.
    #####:  382:  AffineForOp parentForOp = forOp->getParentOfType<AffineForOp>();
call    0 never executed
    #####:  383:  AffineForOp newLoop = replaceForOpWithNewYields(
    #####:  384:      b, parentForOp, iterOperands, newOperands, forOp.getRegionIterArgs());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  385:
        -:  386:  // For sibling-fusion users, collect operations that use the results of the
        -:  387:  // `forOp` outside the new parent loop that has absorbed all its iter args
        -:  388:  // and operands. These operations will be moved later after the results
        -:  389:  // have been replaced.
    #####:  390:  SetVector<Operation *> forwardSlice;
call    0 never executed
call    1 never executed
    #####:  391:  if (siblingFusionUser) {
branch  0 never executed
branch  1 never executed
    #####:  392:    for (unsigned i = 0, e = forOp.getNumResults(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  393:      SetVector<Operation *> tmpForwardSlice;
call    0 never executed
    #####:  394:      getForwardSlice(forOp.getResult(i), &tmpForwardSlice);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  395:      forwardSlice.set_union(tmpForwardSlice);
call    0 never executed
        -:  396:    }
        -:  397:  }
        -:  398:  // Update the results of the `forOp` in the new loop.
    #####:  399:  for (unsigned i = 0, e = forOp.getNumResults(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  400:    forOp.getResult(i).replaceAllUsesWith(
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  401:        newLoop.getResult(i + parentOp->getNumResults()));
branch  0 never executed
branch  1 never executed
        -:  402:  }
        -:  403:  // For sibling-fusion users, move operations that use the results of the
        -:  404:  // `forOp` outside the new parent loop
    #####:  405:  if (siblingFusionUser) {
branch  0 never executed
branch  1 never executed
    #####:  406:    topologicalSort(forwardSlice);
call    0 never executed
call    1 never executed
    #####:  407:    for (Operation *op : llvm::reverse(forwardSlice))
branch  0 never executed
branch  1 never executed
    #####:  408:      op->moveAfter(newLoop);
call    0 never executed
        -:  409:  }
        -:  410:  // Replace the induction variable.
    #####:  411:  auto iv = forOp.getInductionVar();
call    0 never executed
    #####:  412:  iv.replaceAllUsesWith(newLoop.getInductionVar());
call    0 never executed
call    1 never executed
        -:  413:  // Replace the iter args.
    #####:  414:  auto forOpIterArgs = forOp.getRegionIterArgs();
call    0 never executed
    #####:  415:  for (auto it : llvm::zip(forOpIterArgs, newLoop.getRegionIterArgs().take_back(
call    0 never executed
    #####:  416:                                              forOpIterArgs.size()))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  417:    std::get<0>(it).replaceAllUsesWith(std::get<1>(it));
call    0 never executed
        -:  418:  }
        -:  419:  // Move the loop body operations, except for its terminator, to the loop's
        -:  420:  // containing block.
    #####:  421:  forOp.getBody()->back().erase();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  422:  auto *parentBlock = forOp->getBlock();
call    0 never executed
    #####:  423:  parentBlock->getOperations().splice(Block::iterator(forOp),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  424:                                      forOp.getBody()->getOperations());
call    0 never executed
call    1 never executed
    #####:  425:  forOp.erase();
call    0 never executed
    #####:  426:  parentForOp.erase();
call    0 never executed
    #####:  427:  return success();
call    0 never executed
        -:  428:}
        -:  429:
        -:  430:/// Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point
        -:  431:/// and source slice loop bounds specified in 'srcSlice'.
function _ZN4mlir9fuseLoopsENS_11AffineForOpES0_RKNS_21ComputationSliceStateEb called 0 returned 0% blocks executed 0%
    #####:  432:void mlir::fuseLoops(AffineForOp srcForOp, AffineForOp dstForOp,
        -:  433:                     const ComputationSliceState &srcSlice,
        -:  434:                     bool isInnermostSiblingInsertion) {
        -:  435:  // Clone 'srcForOp' into 'dstForOp' at 'srcSlice->insertPoint'.
    #####:  436:  OpBuilder b(srcSlice.insertPoint->getBlock(), srcSlice.insertPoint);
call    0 never executed
call    1 never executed
    #####:  437:  BlockAndValueMapping mapper;
call    0 never executed
    #####:  438:  b.clone(*srcForOp, mapper);
call    0 never executed
        -:  439:
        -:  440:  // Update 'sliceLoopNest' upper and lower bounds from computed 'srcSlice'.
    #####:  441:  SmallVector<AffineForOp, 4> sliceLoops;
call    0 never executed
    #####:  442:  for (unsigned i = 0, e = srcSlice.ivs.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  443:    auto loopIV = mapper.lookupOrNull(srcSlice.ivs[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  444:    if (!loopIV)
branch  0 never executed
branch  1 never executed
    #####:  445:      continue;
    #####:  446:    auto forOp = getForInductionVarOwner(loopIV);
call    0 never executed
    #####:  447:    sliceLoops.push_back(forOp);
call    0 never executed
    #####:  448:    if (AffineMap lbMap = srcSlice.lbs[i]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  449:      auto lbOperands = srcSlice.lbOperands[i];
branch  0 never executed
branch  1 never executed
    #####:  450:      canonicalizeMapAndOperands(&lbMap, &lbOperands);
call    0 never executed
    #####:  451:      forOp.setLowerBound(lbOperands, lbMap);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  452:    }
    #####:  453:    if (AffineMap ubMap = srcSlice.ubs[i]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  454:      auto ubOperands = srcSlice.ubOperands[i];
branch  0 never executed
branch  1 never executed
    #####:  455:      canonicalizeMapAndOperands(&ubMap, &ubOperands);
call    0 never executed
    #####:  456:      forOp.setUpperBound(ubOperands, ubMap);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  457:    }
        -:  458:  }
        -:  459:
    #####:  460:  llvm::SmallDenseMap<Operation *, uint64_t, 8> sliceTripCountMap;
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZN4mlir9fuseLoopsENS_11AffineForOpES0_RKNS_21ComputationSliceStateEbENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  461:  auto srcIsUnitSlice = [&]() {
    #####:  462:    return (buildSliceTripCountMap(srcSlice, &sliceTripCountMap) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  463:            (getSliceIterationCount(sliceTripCountMap) == 1));
call    0 never executed
    #####:  464:  };
        -:  465:  // Fix up and if possible, eliminate single iteration loops.
    #####:  466:  for (AffineForOp forOp : sliceLoops) {
branch  0 never executed
branch  1 never executed
    #####:  467:    if (isLoopParallelAndContainsReduction(forOp) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  468:        isInnermostSiblingInsertion && srcIsUnitSlice())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  469:      // Patch reduction loop - only ones that are sibling-fused with the
        -:  470:      // destination loop - into the parent loop.
    #####:  471:      (void)promoteSingleIterReductionLoop(forOp, true);
call    0 never executed
        -:  472:    else
        -:  473:      // Promote any single iteration slice loops.
    #####:  474:      (void)promoteIfSingleIteration(forOp);
call    0 never executed
        -:  475:  }
    #####:  476:}
        -:  477:
        -:  478:/// Collect loop nest statistics (eg. loop trip count and operation count)
        -:  479:/// in 'stats' for loop nest rooted at 'forOp'. Returns true on success,
        -:  480:/// returns false otherwise.
function _ZN4mlir16getLoopNestStatsENS_11AffineForOpEPNS_13LoopNestStatsE called 0 returned 0% blocks executed 0%
    #####:  481:bool mlir::getLoopNestStats(AffineForOp forOpRoot, LoopNestStats *stats) {
function _ZZN4mlir16getLoopNestStatsENS_11AffineForOpEPNS_13LoopNestStatsEENKUlS0_E_clES0_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  482:  auto walkResult = forOpRoot.walk([&](AffineForOp forOp) {
    #####:  483:    auto *childForOp = forOp.getOperation();
branch  0 never executed
branch  1 never executed
    #####:  484:    auto *parentForOp = forOp->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  485:    if (!llvm::isa<func::FuncOp>(parentForOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  486:      if (!isa<AffineForOp>(parentForOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  487:        LLVM_DEBUG(llvm::dbgs() << "Expected parent AffineForOp\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  488:        return WalkResult::interrupt();
        -:  489:      }
        -:  490:      // Add mapping to 'forOp' from its parent AffineForOp.
    #####:  491:      stats->loopMap[parentForOp].push_back(forOp);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  492:    }
        -:  493:
        -:  494:    // Record the number of op operations in the body of 'forOp'.
    #####:  495:    unsigned count = 0;
    #####:  496:    stats->opCountMap[childForOp] = 0;
call    0 never executed
    #####:  497:    for (auto &op : *forOp.getBody()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  498:      if (!isa<AffineForOp, AffineIfOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:        ++count;
        -:  500:    }
    #####:  501:    stats->opCountMap[childForOp] = count;
call    0 never executed
        -:  502:
        -:  503:    // Record trip count for 'forOp'. Set flag if trip count is not
        -:  504:    // constant.
    #####:  505:    Optional<uint64_t> maybeConstTripCount = getConstantTripCount(forOp);
call    0 never executed
    #####:  506:    if (!maybeConstTripCount) {
branch  0 never executed
branch  1 never executed
        -:  507:      // Currently only constant trip count loop nests are supported.
    #####:  508:      LLVM_DEBUG(llvm::dbgs() << "Non-constant trip count unsupported\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  509:      return WalkResult::interrupt();
        -:  510:    }
        -:  511:
    #####:  512:    stats->tripCountMap[childForOp] = *maybeConstTripCount;
call    0 never executed
    #####:  513:    return WalkResult::advance();
    #####:  514:  });
call    0 never executed
    #####:  515:  return !walkResult.wasInterrupted();
        -:  516:}
        -:  517:
        -:  518:// Computes the total cost of the loop nest rooted at 'forOp'.
        -:  519:// Currently, the total cost is computed by counting the total operation
        -:  520:// instance count (i.e. total number of operations in the loop bodyloop
        -:  521:// operation count * loop trip count) for the entire loop nest.
        -:  522:// If 'tripCountOverrideMap' is non-null, overrides the trip count for loops
        -:  523:// specified in the map when computing the total op instance count.
        -:  524:// NOTEs: 1) This is used to compute the cost of computation slices, which are
        -:  525:// sliced along the iteration dimension, and thus reduce the trip count.
        -:  526:// If 'computeCostMap' is non-null, the total op count for forOps specified
        -:  527:// in the map is increased (not overridden) by adding the op count from the
        -:  528:// map to the existing op count for the for loop. This is done before
        -:  529:// multiplying by the loop's trip count, and is used to model the cost of
        -:  530:// inserting a sliced loop nest of known cost into the loop's body.
        -:  531:// 2) This is also used to compute the cost of fusing a slice of some loop nest
        -:  532:// within another loop.
function _ZL20getComputeCostHelperPN4mlir9OperationERNS_13LoopNestStatsEPN4llvm13SmallDenseMapIS1_mLj8ENS4_12DenseMapInfoIS1_vEENS4_6detail12DenseMapPairIS1_mEEEEPNS4_8DenseMapIS1_lS7_NS9_IS1_lEEEE called 0 returned 0% blocks executed 0%
    #####:  533:static int64_t getComputeCostHelper(
        -:  534:    Operation *forOp, LoopNestStats &stats,
        -:  535:    llvm::SmallDenseMap<Operation *, uint64_t, 8> *tripCountOverrideMap,
        -:  536:    DenseMap<Operation *, int64_t> *computeCostMap) {
        -:  537:  // 'opCount' is the total number operations in one iteration of 'forOp' body,
        -:  538:  // minus terminator op which is a no-op.
    #####:  539:  int64_t opCount = stats.opCountMap[forOp] - 1;
call    0 never executed
    #####:  540:  if (stats.loopMap.count(forOp) > 0) {
call    0 never executed
    #####:  541:    for (auto childForOp : stats.loopMap[forOp]) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  542:      opCount += getComputeCostHelper(childForOp.getOperation(), stats,
call    0 never executed
        -:  543:                                      tripCountOverrideMap, computeCostMap);
        -:  544:    }
        -:  545:  }
        -:  546:  // Add in additional op instances from slice (if specified in map).
    #####:  547:  if (computeCostMap != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  548:    auto it = computeCostMap->find(forOp);
call    0 never executed
    #####:  549:    if (it != computeCostMap->end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  550:      opCount += it->second;
call    0 never executed
        -:  551:    }
        -:  552:  }
        -:  553:  // Override trip count (if specified in map).
    #####:  554:  int64_t tripCount = stats.tripCountMap[forOp];
call    0 never executed
    #####:  555:  if (tripCountOverrideMap != nullptr) {
branch  0 never executed
branch  1 never executed
    #####:  556:    auto it = tripCountOverrideMap->find(forOp);
call    0 never executed
    #####:  557:    if (it != tripCountOverrideMap->end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  558:      tripCount = it->second;
call    0 never executed
        -:  559:    }
        -:  560:  }
        -:  561:  // Returns the total number of dynamic instances of operations in loop body.
    #####:  562:  return tripCount * opCount;
        -:  563:}
        -:  564:
        -:  565:/// Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.
        -:  566:/// Currently, the total cost is computed by counting the total operation
        -:  567:/// instance count (i.e. total number of operations in the loop body * loop
        -:  568:/// trip count) for the entire loop nest.
function _ZN4mlir14getComputeCostENS_11AffineForOpERNS_13LoopNestStatsE called 0 returned 0% blocks executed 0%
    #####:  569:int64_t mlir::getComputeCost(AffineForOp forOp, LoopNestStats &stats) {
    #####:  570:  return getComputeCostHelper(forOp.getOperation(), stats,
call    0 never executed
        -:  571:                              /*tripCountOverrideMap=*/nullptr,
    #####:  572:                              /*computeCostMap=*/nullptr);
        -:  573:}
        -:  574:
        -:  575:/// Computes and returns in 'computeCost', the total compute cost of fusing the
        -:  576:/// 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. Currently,
        -:  577:/// the total cost is computed by counting the total operation instance count
        -:  578:/// (i.e. total number of operations in the loop body * loop trip count) for
        -:  579:/// the entire loop nest.
function _ZN4mlir20getFusionComputeCostENS_11AffineForOpERNS_13LoopNestStatsES0_S2_RKNS_21ComputationSliceStateEPl called 0 returned 0% blocks executed 0%
    #####:  580:bool mlir::getFusionComputeCost(AffineForOp srcForOp, LoopNestStats &srcStats,
        -:  581:                                AffineForOp dstForOp, LoopNestStats &dstStats,
        -:  582:                                const ComputationSliceState &slice,
        -:  583:                                int64_t *computeCost) {
    #####:  584:  llvm::SmallDenseMap<Operation *, uint64_t, 8> sliceTripCountMap;
call    0 never executed
    #####:  585:  DenseMap<Operation *, int64_t> computeCostMap;
call    0 never executed
call    1 never executed
        -:  586:
        -:  587:  // Build trip count map for computation slice.
    #####:  588:  if (!buildSliceTripCountMap(slice, &sliceTripCountMap))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  589:    return false;
        -:  590:  // Checks whether a store to load forwarding will happen.
    #####:  591:  int64_t sliceIterationCount = getSliceIterationCount(sliceTripCountMap);
call    0 never executed
    #####:  592:  assert(sliceIterationCount > 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  593:  bool storeLoadFwdGuaranteed = (sliceIterationCount == 1);
    #####:  594:  auto *insertPointParent = slice.insertPoint->getParentOp();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  595:
        -:  596:  // The store and loads to this memref will disappear.
        -:  597:  // TODO: Add load coalescing to memref data flow opt pass.
    #####:  598:  if (storeLoadFwdGuaranteed) {
branch  0 never executed
branch  1 never executed
        -:  599:    // Subtract from operation count the loads/store we expect load/store
        -:  600:    // forwarding to remove.
    #####:  601:    unsigned storeCount = 0;
    #####:  602:    llvm::SmallDenseSet<Value, 4> storeMemrefs;
call    0 never executed
function _ZZN4mlir20getFusionComputeCostENS_11AffineForOpERNS_13LoopNestStatsES0_S2_RKNS_21ComputationSliceStateEPlENKUlPNS_9OperationEE_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  603:    srcForOp.walk([&](Operation *op) {
call    0 never executed
    #####:  604:      if (auto storeOp = dyn_cast<AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  605:        storeMemrefs.insert(storeOp.getMemRef());
call    0 never executed
call    1 never executed
    #####:  606:        ++storeCount;
        -:  607:      }
    #####:  608:    });
        -:  609:    // Subtract out any store ops in single-iteration src slice loop nest.
    #####:  610:    if (storeCount > 0)
branch  0 never executed
branch  1 never executed
    #####:  611:      computeCostMap[insertPointParent] = -storeCount;
call    0 never executed
        -:  612:    // Subtract out any load users of 'storeMemrefs' nested below
        -:  613:    // 'insertPointParent'.
    #####:  614:    for (auto value : storeMemrefs) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  615:      for (auto *user : value.getUsers()) {
branch  0 never executed
branch  1 never executed
    #####:  616:        if (auto loadOp = dyn_cast<AffineReadOpInterface>(user)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  617:          SmallVector<AffineForOp, 4> loops;
call    0 never executed
        -:  618:          // Check if any loop in loop nest surrounding 'user' is
        -:  619:          // 'insertPointParent'.
    #####:  620:          getLoopIVs(*user, &loops);
call    0 never executed
    #####:  621:          if (llvm::is_contained(loops, cast<AffineForOp>(insertPointParent))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  622:            if (auto forOp =
branch  0 never executed
branch  1 never executed
    #####:  623:                    dyn_cast_or_null<AffineForOp>(user->getParentOp())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  624:              if (computeCostMap.count(forOp) == 0)
call    0 never executed
    #####:  625:                computeCostMap[forOp] = 0;
call    0 never executed
    #####:  626:              computeCostMap[forOp] -= 1;
call    0 never executed
        -:  627:            }
        -:  628:          }
        -:  629:        }
        -:  630:      }
        -:  631:    }
        -:  632:  }
        -:  633:
        -:  634:  // Compute op instance count for the src loop nest with iteration slicing.
    #####:  635:  int64_t sliceComputeCost = getComputeCostHelper(
call    0 never executed
        -:  636:      srcForOp.getOperation(), srcStats, &sliceTripCountMap, &computeCostMap);
        -:  637:
        -:  638:  // Compute cost of fusion for this depth.
    #####:  639:  computeCostMap[insertPointParent] = sliceComputeCost;
call    0 never executed
        -:  640:
    #####:  641:  *computeCost =
    #####:  642:      getComputeCostHelper(dstForOp.getOperation(), dstStats,
call    0 never executed
        -:  643:                           /*tripCountOverrideMap=*/nullptr, &computeCostMap);
    #####:  644:  return true;
        -:  645:}
        -:  646:
        -:  647:/// Returns in 'producerConsumerMemrefs' the memrefs involved in a
        -:  648:/// producer-consumer dependence between write ops in 'srcOps' and read ops in
        -:  649:/// 'dstOps'.
function _ZN4mlir29gatherProducerConsumerMemrefsEN4llvm8ArrayRefIPNS_9OperationEEES4_RNS0_8DenseSetINS_5ValueENS0_12DenseMapInfoIS6_vEEEE called 0 returned 0% blocks executed 0%
    #####:  650:void mlir::gatherProducerConsumerMemrefs(
        -:  651:    ArrayRef<Operation *> srcOps, ArrayRef<Operation *> dstOps,
        -:  652:    DenseSet<Value> &producerConsumerMemrefs) {
        -:  653:  // Gather memrefs from stores in 'srcOps'.
    #####:  654:  DenseSet<Value> srcStoreMemRefs;
call    0 never executed
    #####:  655:  for (Operation *op : srcOps)
branch  0 never executed
branch  1 never executed
    #####:  656:    if (auto storeOp = dyn_cast<AffineWriteOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  657:      srcStoreMemRefs.insert(storeOp.getMemRef());
call    0 never executed
call    1 never executed
        -:  658:
        -:  659:  // Compute the intersection between memrefs from stores in 'srcOps' and
        -:  660:  // memrefs from loads in 'dstOps'.
    #####:  661:  for (Operation *op : dstOps)
branch  0 never executed
branch  1 never executed
    #####:  662:    if (auto loadOp = dyn_cast<AffineReadOpInterface>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  663:      if (srcStoreMemRefs.count(loadOp.getMemRef()) > 0)
call    0 never executed
call    1 never executed
    #####:  664:        producerConsumerMemrefs.insert(loadOp.getMemRef());
call    0 never executed
call    1 never executed
    #####:  665:}
