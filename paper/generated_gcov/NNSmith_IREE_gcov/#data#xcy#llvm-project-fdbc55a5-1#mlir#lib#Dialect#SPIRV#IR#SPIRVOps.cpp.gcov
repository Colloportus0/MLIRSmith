        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVOps.cpp.gcda
        -:    0:Runs:325553
        -:    1://===- SPIRVOps.cpp - MLIR SPIR-V operations ------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the operations in the SPIR-V dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   14:
        -:   15:#include "mlir/Dialect/SPIRV/IR/ParserUtils.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVAttributes.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   18:#include "mlir/Dialect/SPIRV/IR/SPIRVEnums.h"
        -:   19:#include "mlir/Dialect/SPIRV/IR/SPIRVOpTraits.h"
        -:   20:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   21:#include "mlir/Dialect/SPIRV/IR/TargetAndABI.h"
        -:   22:#include "mlir/IR/Builders.h"
        -:   23:#include "mlir/IR/BuiltinTypes.h"
        -:   24:#include "mlir/IR/FunctionImplementation.h"
        -:   25:#include "mlir/IR/OpDefinition.h"
        -:   26:#include "mlir/IR/OpImplementation.h"
        -:   27:#include "mlir/IR/TypeUtilities.h"
        -:   28:#include "mlir/Interfaces/CallInterfaces.h"
        -:   29:#include "llvm/ADT/APFloat.h"
        -:   30:#include "llvm/ADT/APInt.h"
        -:   31:#include "llvm/ADT/STLExtras.h"
        -:   32:#include "llvm/ADT/StringExtras.h"
        -:   33:#include "llvm/ADT/bit.h"
        -:   34:#include <numeric>
        -:   35:
        -:   36:using namespace mlir;
        -:   37:
        -:   38:// TODO: generate these strings using ODS.
        -:   39:constexpr char kMemoryAccessAttrName[] = "memory_access";
        -:   40:constexpr char kSourceMemoryAccessAttrName[] = "source_memory_access";
        -:   41:constexpr char kAlignmentAttrName[] = "alignment";
        -:   42:constexpr char kSourceAlignmentAttrName[] = "source_alignment";
        -:   43:constexpr char kBranchWeightAttrName[] = "branch_weights";
        -:   44:constexpr char kCallee[] = "callee";
        -:   45:constexpr char kClusterSize[] = "cluster_size";
        -:   46:constexpr char kControl[] = "control";
        -:   47:constexpr char kDefaultValueAttrName[] = "default_value";
        -:   48:constexpr char kExecutionScopeAttrName[] = "execution_scope";
        -:   49:constexpr char kEqualSemanticsAttrName[] = "equal_semantics";
        -:   50:constexpr char kFnNameAttrName[] = "fn";
        -:   51:constexpr char kGroupOperationAttrName[] = "group_operation";
        -:   52:constexpr char kIndicesAttrName[] = "indices";
        -:   53:constexpr char kInitializerAttrName[] = "initializer";
        -:   54:constexpr char kInterfaceAttrName[] = "interface";
        -:   55:constexpr char kMemoryScopeAttrName[] = "memory_scope";
        -:   56:constexpr char kSemanticsAttrName[] = "semantics";
        -:   57:constexpr char kSpecIdAttrName[] = "spec_id";
        -:   58:constexpr char kTypeAttrName[] = "type";
        -:   59:constexpr char kUnequalSemanticsAttrName[] = "unequal_semantics";
        -:   60:constexpr char kValueAttrName[] = "value";
        -:   61:constexpr char kValuesAttrName[] = "values";
        -:   62:constexpr char kCompositeSpecConstituentsName[] = "constituents";
        -:   63:
        -:   64://===----------------------------------------------------------------------===//
        -:   65:// Common utility functions
        -:   66://===----------------------------------------------------------------------===//
        -:   67:
function _ZL31parseOneResultSameOperandTypeOpRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:   68:static ParseResult parseOneResultSameOperandTypeOp(OpAsmParser &parser,
        -:   69:                                                   OperationState &result) {
    #####:   70:  SmallVector<OpAsmParser::UnresolvedOperand, 2> ops;
call    0 never executed
    #####:   71:  Type type;
        -:   72:  // If the operand list is in-between parentheses, then we have a generic form.
        -:   73:  // (see the fallback in `printOneResultOp`).
    #####:   74:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:   75:  if (!parser.parseOptionalLParen()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   76:    if (parser.parseOperandList(ops) || parser.parseRParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   77:        parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   78:        parser.parseColon() || parser.parseType(type))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:   79:      return failure();
    #####:   80:    auto fnType = type.dyn_cast<FunctionType>();
call    0 never executed
    #####:   81:    if (!fnType) {
branch  0 never executed
branch  1 never executed
    #####:   82:      parser.emitError(loc, "expected function type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   83:      return failure();
        -:   84:    }
    #####:   85:    if (parser.resolveOperands(ops, fnType.getInputs(), loc, result.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   86:      return failure();
    #####:   87:    result.addTypes(fnType.getResults());
call    0 never executed
call    1 never executed
    #####:   88:    return success();
        -:   89:  }
    #####:   90:  return failure(parser.parseOperandList(ops) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   91:                 parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   92:                 parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   93:                 parser.resolveOperands(ops, type, result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:   94:                 parser.addTypeToList(type, result.types));
call    0 never executed
        -:   95:}
        -:   96:
function _ZL16printOneResultOpPN4mlir9OperationERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:   97:static void printOneResultOp(Operation *op, OpAsmPrinter &p) {
    #####:   98:  assert(op->getNumResults() == 1 && "op should have one result");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   99:
        -:  100:  // If not all the operand and result types are the same, just use the
        -:  101:  // generic assembly form to avoid omitting information in printing.
    #####:  102:  auto resultType = op->getResult(0).getType();
call    0 never executed
    #####:  103:  if (llvm::any_of(op->getOperandTypes(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  104:                   [&](Type type) { return type != resultType; })) {
    #####:  105:    p.printGenericOp(op, /*printOpName=*/false);
call    0 never executed
    #####:  106:    return;
        -:  107:  }
        -:  108:
    #####:  109:  p << ' ';
call    0 never executed
    #####:  110:  p.printOperands(op->getOperands());
call    0 never executed
call    1 never executed
    #####:  111:  p.printOptionalAttrDict(op->getAttrs());
call    0 never executed
call    1 never executed
        -:  112:  // Now we can output only one type for all operands and the result.
    #####:  113:  p << " : " << resultType;
call    0 never executed
call    1 never executed
        -:  114:}
        -:  115:
        -:  116:/// Returns true if the given op is a function-like op or nested in a
        -:  117:/// function-like op without a module-like op in the middle.
function _ZL29isNestedInFunctionOpInterfacePN4mlir9OperationE called 512 returned 100% blocks executed 70%
      512:  118:static bool isNestedInFunctionOpInterface(Operation *op) {
      512:  119:  if (!op)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:    return false;
      512:  121:  if (op->hasTrait<OpTrait::SymbolTable>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  122:    return false;
      512:  123:  if (isa<FunctionOpInterface>(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  124:    return true;
    #####:  125:  return isNestedInFunctionOpInterface(op->getParentOp());
branch  0 never executed
branch  1 never executed
        -:  126:}
        -:  127:
        -:  128:/// Returns true if the given op is an module-like op that maintains a symbol
        -:  129:/// table.
     542*:  130:static bool isDirectInModuleLikeOp(Operation *op) {
    1084*:  131:  return op && op->hasTrait<OpTrait::SymbolTable>();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
        -:  132:}
        -:  133:
function _ZL23extractValueFromConstOpPN4mlir9OperationERi called 0 returned 0% blocks executed 0%
    #####:  134:static LogicalResult extractValueFromConstOp(Operation *op, int32_t &value) {
    #####:  135:  auto constOp = dyn_cast_or_null<spirv::ConstantOp>(op);
branch  0 never executed
branch  1 never executed
    #####:  136:  if (!constOp) {
branch  0 never executed
branch  1 never executed
    #####:  137:    return failure();
        -:  138:  }
    #####:  139:  auto valueAttr = constOp.getValue();
call    0 never executed
    #####:  140:  auto integerValueAttr = valueAttr.dyn_cast<IntegerAttr>();
call    0 never executed
    #####:  141:  if (!integerValueAttr) {
branch  0 never executed
branch  1 never executed
    #####:  142:    return failure();
        -:  143:  }
        -:  144:
    #####:  145:  if (integerValueAttr.getType().isSignlessInteger())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  146:    value = integerValueAttr.getInt();
call    0 never executed
        -:  147:  else
    #####:  148:    value = integerValueAttr.getSInt();
call    0 never executed
        -:  149:
    #####:  150:  return success();
        -:  151:}
        -:  152:
        -:  153:template <typename Ty>
        -:  154:static ArrayAttr
        -:  155:getStrArrayAttrForEnumList(Builder &builder, ArrayRef<Ty> enumValues,
        -:  156:                           function_ref<StringRef(Ty)> stringifyFn) {
        -:  157:  if (enumValues.empty()) {
        -:  158:    return nullptr;
        -:  159:  }
        -:  160:  SmallVector<StringRef, 1> enumValStrs;
        -:  161:  enumValStrs.reserve(enumValues.size());
        -:  162:  for (auto val : enumValues) {
        -:  163:    enumValStrs.emplace_back(stringifyFn(val));
        -:  164:  }
        -:  165:  return builder.getStrArrayAttr(enumValStrs);
        -:  166:}
        -:  167:
        -:  168:/// Parses the next string attribute in `parser` as an enumerant of the given
        -:  169:/// `EnumClass`.
        -:  170:template <typename EnumClass>
        -:  171:static ParseResult
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
    #####:  185:  if (!attrOptional)
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv15FunctionControlEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv15FunctionControlEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv13ExecutionModeEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv13ExecutionModeEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv14ExecutionModelEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv14ExecutionModelEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv14GroupOperationEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv14GroupOperationEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv15MemorySemanticsEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv15MemorySemanticsEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv5ScopeEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv5ScopeEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv12MemoryAccessEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv12MemoryAccessEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv12StorageClassEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv12StorageClassEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv13ImageOperandsEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv13ImageOperandsEENS0_11ParseResultERT_RNS0_11OpAsmParserEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  172:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser,
        -:  173:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  174:  Attribute attrVal;
call    0 never executed
    #####:  175:  NamedAttrList attr;
    #####:  176:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  177:  if (parser.parseAttribute(attrVal, parser.getBuilder().getNoneType(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  178:                            attrName, attr))
    #####:  179:    return failure();
    #####:  180:  if (!attrVal.isa<StringAttr>())
branch  0 never executed
branch  1 never executed
    #####:  181:    return parser.emitError(loc, "expected ")
    #####:  182:           << attrName << " attribute specified as string";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  183:  auto attrOptional =
    #####:  184:      spirv::symbolizeEnum<EnumClass>(attrVal.cast<StringAttr>().getValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:  if (!attrOptional)
branch  0 never executed
branch  1 never executed
    #####:  186:    return parser.emitError(loc, "invalid ")
    #####:  187:           << attrName << " attribute specification: " << attrVal;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  188:  value = *attrOptional;
    #####:  189:  return success();
        -:  190:}
------------------
        -:  191:
        -:  192:/// Parses the next string attribute in `parser` as an enumerant of the given
        -:  193:/// `EnumClass` and inserts the enumerant into `state` as an 32-bit integer
        -:  194:/// attribute with the enum class's name as attribute name.
        -:  195:template <typename EnumAttrClass,
        -:  196:          typename EnumClass = typename EnumAttrClass::ValueType>
        -:  197:static ParseResult
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv19FunctionControlAttrENS1_15FunctionControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv19FunctionControlAttrENS1_15FunctionControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv17ExecutionModeAttrENS1_13ExecutionModeEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv17ExecutionModeAttrENS1_13ExecutionModeEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv18ExecutionModelAttrENS1_14ExecutionModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv18ExecutionModelAttrENS1_14ExecutionModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv18GroupOperationAttrENS1_14GroupOperationEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv18GroupOperationAttrENS1_14GroupOperationEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv19MemorySemanticsAttrENS1_15MemorySemanticsEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv19MemorySemanticsAttrENS1_15MemorySemanticsEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv9ScopeAttrENS1_5ScopeEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv9ScopeAttrENS1_5ScopeEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
_Z16parseEnumStrAttrIN4mlir5spirv16MemoryAccessAttrENS1_12MemoryAccessEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z16parseEnumStrAttrIN4mlir5spirv16MemoryAccessAttrENS1_12MemoryAccessEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  198:parseEnumStrAttr(EnumClass &value, OpAsmParser &parser, OperationState &state,
call    0 never executed
        -:  199:                 StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  200:  if (parseEnumStrAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return failure();
    #####:  202:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  203:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  204:  return success();
        -:  205:}
------------------
        -:  206:
        -:  207:/// Parses the next keyword in `parser` as an enumerant of the given `EnumClass`
        -:  208:/// and inserts the enumerant into `state` as an 32-bit integer attribute with
        -:  209:/// the enum class's name as attribute name.
        -:  210:template <typename EnumAttrClass,
        -:  211:          typename EnumClass = typename EnumAttrClass::ValueType>
        -:  212:static ParseResult
    #####:  213:parseEnumKeywordAttr(EnumClass &value, OpAsmParser &parser,
        -:  214:                     OperationState &state,
        -:  215:                     StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  216:  if (parseEnumKeywordAttr(value, parser))
    #####:  217:    return failure();
    #####:  218:  state.addAttribute(attrName,
    #####:  219:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
    #####:  220:  return success();
        -:  221:}
------------------
_Z20parseEnumKeywordAttrIN4mlir5spirv20SelectionControlAttrENS1_16SelectionControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z20parseEnumKeywordAttrIN4mlir5spirv20SelectionControlAttrENS1_16SelectionControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  213:parseEnumKeywordAttr(EnumClass &value, OpAsmParser &parser,
call    0 never executed
        -:  214:                     OperationState &state,
        -:  215:                     StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  216:  if (parseEnumKeywordAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:    return failure();
    #####:  218:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  219:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  220:  return success();
        -:  221:}
------------------
_Z20parseEnumKeywordAttrIN4mlir5spirv15LoopControlAttrENS1_11LoopControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z20parseEnumKeywordAttrIN4mlir5spirv15LoopControlAttrENS1_11LoopControlEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  213:parseEnumKeywordAttr(EnumClass &value, OpAsmParser &parser,
call    0 never executed
        -:  214:                     OperationState &state,
        -:  215:                     StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  216:  if (parseEnumKeywordAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:    return failure();
    #####:  218:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  219:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  220:  return success();
        -:  221:}
------------------
_Z20parseEnumKeywordAttrIN4mlir5spirv15MemoryModelAttrENS1_11MemoryModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z20parseEnumKeywordAttrIN4mlir5spirv15MemoryModelAttrENS1_11MemoryModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  213:parseEnumKeywordAttr(EnumClass &value, OpAsmParser &parser,
call    0 never executed
        -:  214:                     OperationState &state,
        -:  215:                     StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  216:  if (parseEnumKeywordAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:    return failure();
    #####:  218:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  219:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  220:  return success();
        -:  221:}
------------------
_Z20parseEnumKeywordAttrIN4mlir5spirv19AddressingModelAttrENS1_15AddressingModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z20parseEnumKeywordAttrIN4mlir5spirv19AddressingModelAttrENS1_15AddressingModelEENS0_11ParseResultERT0_RNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  213:parseEnumKeywordAttr(EnumClass &value, OpAsmParser &parser,
call    0 never executed
        -:  214:                     OperationState &state,
        -:  215:                     StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  216:  if (parseEnumKeywordAttr(value, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  217:    return failure();
    #####:  218:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  219:                     parser.getBuilder().getAttr<EnumAttrClass>(value));
call    0 never executed
    #####:  220:  return success();
        -:  221:}
------------------
        -:  222:
        -:  223:/// Parses Function, Selection and Loop control attributes. If no control is
        -:  224:/// specified, "None" is used as a default.
        -:  225:template <typename EnumAttrClass, typename EnumClass>
        -:  226:static ParseResult
    #####:  227:parseControlAttribute(OpAsmParser &parser, OperationState &state,
        -:  228:                      StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  229:  if (succeeded(parser.parseOptionalKeyword(kControl))) {
        -:  230:    EnumClass control;
    #####:  231:    if (parser.parseLParen() ||
    #####:  232:        parseEnumKeywordAttr<EnumAttrClass>(control, parser, state) ||
    #####:  233:        parser.parseRParen())
    #####:  234:      return failure();
    #####:  235:    return success();
        -:  236:  }
        -:  237:  // Set control to "None" otherwise.
    #####:  238:  Builder builder = parser.getBuilder();
    #####:  239:  state.addAttribute(attrName,
    #####:  240:                     builder.getAttr<EnumAttrClass>(static_cast<EnumClass>(0)));
    #####:  241:  return success();
        -:  242:}
------------------
_Z21parseControlAttributeIN4mlir5spirv20SelectionControlAttrENS1_16SelectionControlEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z21parseControlAttributeIN4mlir5spirv20SelectionControlAttrENS1_16SelectionControlEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  227:parseControlAttribute(OpAsmParser &parser, OperationState &state,
        -:  228:                      StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  229:  if (succeeded(parser.parseOptionalKeyword(kControl))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  230:    EnumClass control;
    #####:  231:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  232:        parseEnumKeywordAttr<EnumAttrClass>(control, parser, state) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  233:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  234:      return failure();
    #####:  235:    return success();
        -:  236:  }
        -:  237:  // Set control to "None" otherwise.
    #####:  238:  Builder builder = parser.getBuilder();
call    0 never executed
    #####:  239:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  240:                     builder.getAttr<EnumAttrClass>(static_cast<EnumClass>(0)));
    #####:  241:  return success();
        -:  242:}
------------------
_Z21parseControlAttributeIN4mlir5spirv15LoopControlAttrENS1_11LoopControlEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE:
function _Z21parseControlAttributeIN4mlir5spirv15LoopControlAttrENS1_11LoopControlEENS0_11ParseResultERNS0_11OpAsmParserERNS0_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  227:parseControlAttribute(OpAsmParser &parser, OperationState &state,
        -:  228:                      StringRef attrName = spirv::attributeName<EnumClass>()) {
    #####:  229:  if (succeeded(parser.parseOptionalKeyword(kControl))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  230:    EnumClass control;
    #####:  231:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  232:        parseEnumKeywordAttr<EnumAttrClass>(control, parser, state) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  233:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  234:      return failure();
    #####:  235:    return success();
        -:  236:  }
        -:  237:  // Set control to "None" otherwise.
    #####:  238:  Builder builder = parser.getBuilder();
call    0 never executed
    #####:  239:  state.addAttribute(attrName,
call    0 never executed
call    1 never executed
    #####:  240:                     builder.getAttr<EnumAttrClass>(static_cast<EnumClass>(0)));
    #####:  241:  return success();
        -:  242:}
------------------
        -:  243:
        -:  244:/// Parses optional memory access attributes attached to a memory access
        -:  245:/// operand/pointer. Specifically, parses the following syntax:
        -:  246:///     (`[` memory-access `]`)?
        -:  247:/// where:
        -:  248:///     memory-access ::= `"None"` | `"Volatile"` | `"Aligned", `
        -:  249:///         integer-literal | `"NonTemporal"`
function _ZL27parseMemoryAccessAttributesRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  250:static ParseResult parseMemoryAccessAttributes(OpAsmParser &parser,
        -:  251:                                               OperationState &state) {
        -:  252:  // Parse an optional list of attributes staring with '['
    #####:  253:  if (parser.parseOptionalLSquare()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  254:    // Nothing to do
    #####:  255:    return success();
        -:  256:  }
        -:  257:
    #####:  258:  spirv::MemoryAccess memoryAccessAttr;
    #####:  259:  if (parseEnumStrAttr<spirv::MemoryAccessAttr>(memoryAccessAttr, parser, state,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  260:                                                kMemoryAccessAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  261:    return failure();
        -:  262:
    #####:  263:  if (spirv::bitEnumContainsAll(memoryAccessAttr,
branch  0 never executed
branch  1 never executed
        -:  264:                                spirv::MemoryAccess::Aligned)) {
        -:  265:    // Parse integer attribute for alignment.
    #####:  266:    Attribute alignmentAttr;
    #####:  267:    Type i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####:  268:    if (parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  269:        parser.parseAttribute(alignmentAttr, i32Type, kAlignmentAttrName,
    #####:  270:                              state.attributes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  271:      return failure();
        -:  272:    }
        -:  273:  }
    #####:  274:  return parser.parseRSquare();
call    0 never executed
        -:  275:}
        -:  276:
        -:  277:// TODO Make sure to merge this and the previous function into one template
        -:  278:// parameterized by memory access attribute name and alignment. Doing so now
        -:  279:// results in VS2017 in producing an internal error (at the call site) that's
        -:  280:// not detailed enough to understand what is happening.
function _ZL33parseSourceMemoryAccessAttributesRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  281:static ParseResult parseSourceMemoryAccessAttributes(OpAsmParser &parser,
        -:  282:                                                     OperationState &state) {
        -:  283:  // Parse an optional list of attributes staring with '['
    #####:  284:  if (parser.parseOptionalLSquare()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  285:    // Nothing to do
    #####:  286:    return success();
        -:  287:  }
        -:  288:
    #####:  289:  spirv::MemoryAccess memoryAccessAttr;
    #####:  290:  if (parseEnumStrAttr<spirv::MemoryAccessAttr>(memoryAccessAttr, parser, state,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  291:                                                kSourceMemoryAccessAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  292:    return failure();
        -:  293:
    #####:  294:  if (spirv::bitEnumContainsAll(memoryAccessAttr,
branch  0 never executed
branch  1 never executed
        -:  295:                                spirv::MemoryAccess::Aligned)) {
        -:  296:    // Parse integer attribute for alignment.
    #####:  297:    Attribute alignmentAttr;
    #####:  298:    Type i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####:  299:    if (parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  300:        parser.parseAttribute(alignmentAttr, i32Type, kSourceAlignmentAttrName,
    #####:  301:                              state.attributes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  302:      return failure();
        -:  303:    }
        -:  304:  }
    #####:  305:  return parser.parseRSquare();
call    0 never executed
        -:  306:}
        -:  307:
        -:  308:template <typename MemoryOpTy>
        -:  309:static void printMemoryAccessAttribute(
        -:  310:    MemoryOpTy memoryOp, OpAsmPrinter &printer,
        -:  311:    SmallVectorImpl<StringRef> &elidedAttrs,
        -:  312:    Optional<spirv::MemoryAccess> memoryAccessAtrrValue = None,
        -:  313:    Optional<uint32_t> alignmentAttrValue = None) {
        -:  314:  // Print optional memory access attribute.
        -:  315:  if (auto memAccess = (memoryAccessAtrrValue ? memoryAccessAtrrValue
        -:  316:                                              : memoryOp.getMemoryAccess())) {
        -:  317:    elidedAttrs.push_back(kMemoryAccessAttrName);
        -:  318:
        -:  319:    printer << " [\"" << stringifyMemoryAccess(*memAccess) << "\"";
        -:  320:
        -:  321:    if (spirv::bitEnumContainsAll(*memAccess, spirv::MemoryAccess::Aligned)) {
        -:  322:      // Print integer alignment attribute.
        -:  323:      if (auto alignment = (alignmentAttrValue ? alignmentAttrValue
        -:  324:                                               : memoryOp.getAlignment())) {
        -:  325:        elidedAttrs.push_back(kAlignmentAttrName);
        -:  326:        printer << ", " << alignment;
        -:  327:      }
        -:  328:    }
        -:  329:    printer << "]";
        -:  330:  }
        -:  331:  elidedAttrs.push_back(spirv::attributeName<spirv::StorageClass>());
        -:  332:}
        -:  333:
        -:  334:// TODO Make sure to merge this and the previous function into one template
        -:  335:// parameterized by memory access attribute name and alignment. Doing so now
        -:  336:// results in VS2017 in producing an internal error (at the call site) that's
        -:  337:// not detailed enough to understand what is happening.
        -:  338:template <typename MemoryOpTy>
        -:  339:static void printSourceMemoryAccessAttribute(
        -:  340:    MemoryOpTy memoryOp, OpAsmPrinter &printer,
        -:  341:    SmallVectorImpl<StringRef> &elidedAttrs,
        -:  342:    Optional<spirv::MemoryAccess> memoryAccessAtrrValue = None,
        -:  343:    Optional<uint32_t> alignmentAttrValue = None) {
        -:  344:
        -:  345:  printer << ", ";
        -:  346:
        -:  347:  // Print optional memory access attribute.
        -:  348:  if (auto memAccess = (memoryAccessAtrrValue ? memoryAccessAtrrValue
        -:  349:                                              : memoryOp.getMemoryAccess())) {
        -:  350:    elidedAttrs.push_back(kSourceMemoryAccessAttrName);
        -:  351:
        -:  352:    printer << " [\"" << stringifyMemoryAccess(*memAccess) << "\"";
        -:  353:
        -:  354:    if (spirv::bitEnumContainsAll(*memAccess, spirv::MemoryAccess::Aligned)) {
        -:  355:      // Print integer alignment attribute.
        -:  356:      if (auto alignment = (alignmentAttrValue ? alignmentAttrValue
        -:  357:                                               : memoryOp.getAlignment())) {
        -:  358:        elidedAttrs.push_back(kSourceAlignmentAttrName);
        -:  359:        printer << ", " << alignment;
        -:  360:      }
        -:  361:    }
        -:  362:    printer << "]";
        -:  363:  }
        -:  364:  elidedAttrs.push_back(spirv::attributeName<spirv::StorageClass>());
        -:  365:}
        -:  366:
function _ZL18parseImageOperandsRN4mlir11OpAsmParserERNS_5spirv17ImageOperandsAttrE called 0 returned 0% blocks executed 0%
    #####:  367:static ParseResult parseImageOperands(OpAsmParser &parser,
        -:  368:                                      spirv::ImageOperandsAttr &attr) {
        -:  369:  // Expect image operands
    #####:  370:  if (parser.parseOptionalLSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  371:    return success();
        -:  372:
    #####:  373:  spirv::ImageOperands imageOperands;
    #####:  374:  if (parseEnumStrAttr(imageOperands, parser))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  375:    return failure();
        -:  376:
    #####:  377:  attr = spirv::ImageOperandsAttr::get(parser.getContext(), imageOperands);
call    0 never executed
call    1 never executed
        -:  378:
    #####:  379:  return parser.parseRSquare();
call    0 never executed
        -:  380:}
        -:  381:
        -:  382:static void printImageOperands(OpAsmPrinter &printer, Operation *imageOp,
        -:  383:                               spirv::ImageOperandsAttr attr) {
        -:  384:  if (attr) {
        -:  385:    auto strImageOperands = stringifyImageOperands(attr.getValue());
        -:  386:    printer << "[\"" << strImageOperands << "\"]";
        -:  387:  }
        -:  388:}
        -:  389:
        -:  390:template <typename Op>
        -:  391:static LogicalResult verifyImageOperands(Op imageOp,
        -:  392:                                         spirv::ImageOperandsAttr attr,
        -:  393:                                         Operation::operand_range operands) {
        -:  394:  if (!attr) {
        -:  395:    if (operands.empty())
        -:  396:      return success();
        -:  397:
        -:  398:    return imageOp.emitError("the Image Operands should encode what operands "
        -:  399:                             "follow, as per Image Operands");
        -:  400:  }
        -:  401:
        -:  402:  // TODO: Add the validation rules for the following Image Operands.
        -:  403:  spirv::ImageOperands noSupportOperands =
        -:  404:      spirv::ImageOperands::Bias | spirv::ImageOperands::Lod |
        -:  405:      spirv::ImageOperands::Grad | spirv::ImageOperands::ConstOffset |
        -:  406:      spirv::ImageOperands::Offset | spirv::ImageOperands::ConstOffsets |
        -:  407:      spirv::ImageOperands::Sample | spirv::ImageOperands::MinLod |
        -:  408:      spirv::ImageOperands::MakeTexelAvailable |
        -:  409:      spirv::ImageOperands::MakeTexelVisible |
        -:  410:      spirv::ImageOperands::SignExtend | spirv::ImageOperands::ZeroExtend;
        -:  411:
        -:  412:  if (spirv::bitEnumContainsAll(attr.getValue(), noSupportOperands))
        -:  413:    llvm_unreachable("unimplemented operands of Image Operands");
        -:  414:
        -:  415:  return success();
        -:  416:}
        -:  417:
function _ZL12verifyCastOpPN4mlir9OperationEbb called 0 returned 0% blocks executed 0%
    #####:  418:static LogicalResult verifyCastOp(Operation *op,
        -:  419:                                  bool requireSameBitWidth = true,
        -:  420:                                  bool skipBitWidthCheck = false) {
        -:  421:  // Some CastOps have no limit on bit widths for result and operand type.
    #####:  422:  if (skipBitWidthCheck)
branch  0 never executed
branch  1 never executed
    #####:  423:    return success();
        -:  424:
    #####:  425:  Type operandType = op->getOperand(0).getType();
call    0 never executed
call    1 never executed
    #####:  426:  Type resultType = op->getResult(0).getType();
call    0 never executed
        -:  427:
        -:  428:  // ODS checks that result type and operand type have the same shape.
    #####:  429:  if (auto vectorType = operandType.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  430:    operandType = vectorType.getElementType();
call    0 never executed
    #####:  431:    resultType = resultType.cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
        -:  432:  }
        -:  433:
    #####:  434:  if (auto coopMatrixType =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  435:          operandType.dyn_cast<spirv::CooperativeMatrixNVType>()) {
branch  0 never executed
branch  1 never executed
    #####:  436:    operandType = coopMatrixType.getElementType();
call    0 never executed
    #####:  437:    resultType =
call    0 never executed
    #####:  438:        resultType.cast<spirv::CooperativeMatrixNVType>().getElementType();
call    0 never executed
        -:  439:  }
        -:  440:
    #####:  441:  if (auto jointMatrixType =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  442:          operandType.dyn_cast<spirv::JointMatrixINTELType>()) {
branch  0 never executed
branch  1 never executed
    #####:  443:    operandType = jointMatrixType.getElementType();
call    0 never executed
    #####:  444:    resultType =
call    0 never executed
    #####:  445:        resultType.cast<spirv::JointMatrixINTELType>().getElementType();
call    0 never executed
        -:  446:  }
        -:  447:
    #####:  448:  auto operandTypeBitWidth = operandType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  449:  auto resultTypeBitWidth = resultType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  450:  auto isSameBitWidth = operandTypeBitWidth == resultTypeBitWidth;
        -:  451:
    #####:  452:  if (requireSameBitWidth) {
branch  0 never executed
branch  1 never executed
    #####:  453:    if (!isSameBitWidth) {
branch  0 never executed
branch  1 never executed
    #####:  454:      return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  455:                 "expected the same bit widths for operand type and result "
        -:  456:                 "type, but provided ")
    #####:  457:             << operandType << " and " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  458:    }
    #####:  459:    return success();
        -:  460:  }
        -:  461:
    #####:  462:  if (isSameBitWidth) {
branch  0 never executed
branch  1 never executed
    #####:  463:    return op->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  464:               "expected the different bit widths for operand type and result "
        -:  465:               "type, but provided ")
    #####:  466:           << operandType << " and " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  467:  }
    #####:  468:  return success();
        -:  469:}
        -:  470:
        -:  471:template <typename MemoryOpTy>
    #####:  472:static LogicalResult verifyMemoryAccessAttribute(MemoryOpTy memoryOp) {
        -:  473:  // ODS checks for attributes values. Just need to verify that if the
        -:  474:  // memory-access attribute is Aligned, then the alignment attribute must be
        -:  475:  // present.
    #####:  476:  auto *op = memoryOp.getOperation();
    #####:  477:  auto memAccessAttr = op->getAttr(kMemoryAccessAttrName);
    #####:  478:  if (!memAccessAttr) {
        -:  479:    // Alignment attribute shouldn't be present if memory access attribute is
        -:  480:    // not present.
    #####:  481:    if (op->getAttr(kAlignmentAttrName)) {
        -:  482:      return memoryOp.emitOpError(
        -:  483:          "invalid alignment specification without aligned memory access "
    #####:  484:          "specification");
        -:  485:    }
    #####:  486:    return success();
        -:  487:  }
        -:  488:
    #####:  489:  auto memAccess = memAccessAttr.template cast<spirv::MemoryAccessAttr>();
        -:  490:
    #####:  491:  if (!memAccess) {
        -:  492:    return memoryOp.emitOpError("invalid memory access specifier: ")
    #####:  493:           << memAccessAttr;
        -:  494:  }
        -:  495:
    #####:  496:  if (spirv::bitEnumContainsAll(memAccess.getValue(),
        -:  497:                                spirv::MemoryAccess::Aligned)) {
    #####:  498:    if (!op->getAttr(kAlignmentAttrName)) {
    #####:  499:      return memoryOp.emitOpError("missing alignment value");
        -:  500:    }
        -:  501:  } else {
    #####:  502:    if (op->getAttr(kAlignmentAttrName)) {
        -:  503:      return memoryOp.emitOpError(
        -:  504:          "invalid alignment specification with non-aligned memory access "
    #####:  505:          "specification");
        -:  506:    }
        -:  507:  }
    #####:  508:  return success();
        -:  509:}
------------------
_Z27verifyMemoryAccessAttributeIN4mlir5spirv12CopyMemoryOpEENS0_13LogicalResultET_:
function _Z27verifyMemoryAccessAttributeIN4mlir5spirv12CopyMemoryOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  472:static LogicalResult verifyMemoryAccessAttribute(MemoryOpTy memoryOp) {
        -:  473:  // ODS checks for attributes values. Just need to verify that if the
        -:  474:  // memory-access attribute is Aligned, then the alignment attribute must be
        -:  475:  // present.
    #####:  476:  auto *op = memoryOp.getOperation();
call    0 never executed
    #####:  477:  auto memAccessAttr = op->getAttr(kMemoryAccessAttrName);
call    0 never executed
    #####:  478:  if (!memAccessAttr) {
branch  0 never executed
branch  1 never executed
        -:  479:    // Alignment attribute shouldn't be present if memory access attribute is
        -:  480:    // not present.
    #####:  481:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  482:      return memoryOp.emitOpError(
        -:  483:          "invalid alignment specification without aligned memory access "
    #####:  484:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  485:    }
    #####:  486:    return success();
        -:  487:  }
        -:  488:
    #####:  489:  auto memAccess = memAccessAttr.template cast<spirv::MemoryAccessAttr>();
        -:  490:
    #####:  491:  if (!memAccess) {
branch  0 never executed
branch  1 never executed
        -:  492:    return memoryOp.emitOpError("invalid memory access specifier: ")
    #####:  493:           << memAccessAttr;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  494:  }
        -:  495:
    #####:  496:  if (spirv::bitEnumContainsAll(memAccess.getValue(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  497:                                spirv::MemoryAccess::Aligned)) {
    #####:  498:    if (!op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:      return memoryOp.emitOpError("missing alignment value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  500:    }
        -:  501:  } else {
    #####:  502:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  503:      return memoryOp.emitOpError(
        -:  504:          "invalid alignment specification with non-aligned memory access "
    #####:  505:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  506:    }
        -:  507:  }
    #####:  508:  return success();
        -:  509:}
------------------
_Z27verifyMemoryAccessAttributeIN4mlir5spirv7StoreOpEENS0_13LogicalResultET_:
function _Z27verifyMemoryAccessAttributeIN4mlir5spirv7StoreOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  472:static LogicalResult verifyMemoryAccessAttribute(MemoryOpTy memoryOp) {
        -:  473:  // ODS checks for attributes values. Just need to verify that if the
        -:  474:  // memory-access attribute is Aligned, then the alignment attribute must be
        -:  475:  // present.
    #####:  476:  auto *op = memoryOp.getOperation();
call    0 never executed
    #####:  477:  auto memAccessAttr = op->getAttr(kMemoryAccessAttrName);
call    0 never executed
    #####:  478:  if (!memAccessAttr) {
branch  0 never executed
branch  1 never executed
        -:  479:    // Alignment attribute shouldn't be present if memory access attribute is
        -:  480:    // not present.
    #####:  481:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  482:      return memoryOp.emitOpError(
        -:  483:          "invalid alignment specification without aligned memory access "
    #####:  484:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  485:    }
    #####:  486:    return success();
        -:  487:  }
        -:  488:
    #####:  489:  auto memAccess = memAccessAttr.template cast<spirv::MemoryAccessAttr>();
        -:  490:
    #####:  491:  if (!memAccess) {
branch  0 never executed
branch  1 never executed
        -:  492:    return memoryOp.emitOpError("invalid memory access specifier: ")
    #####:  493:           << memAccessAttr;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  494:  }
        -:  495:
    #####:  496:  if (spirv::bitEnumContainsAll(memAccess.getValue(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  497:                                spirv::MemoryAccess::Aligned)) {
    #####:  498:    if (!op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:      return memoryOp.emitOpError("missing alignment value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  500:    }
        -:  501:  } else {
    #####:  502:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  503:      return memoryOp.emitOpError(
        -:  504:          "invalid alignment specification with non-aligned memory access "
    #####:  505:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  506:    }
        -:  507:  }
    #####:  508:  return success();
        -:  509:}
------------------
_Z27verifyMemoryAccessAttributeIN4mlir5spirv6LoadOpEENS0_13LogicalResultET_:
function _Z27verifyMemoryAccessAttributeIN4mlir5spirv6LoadOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  472:static LogicalResult verifyMemoryAccessAttribute(MemoryOpTy memoryOp) {
        -:  473:  // ODS checks for attributes values. Just need to verify that if the
        -:  474:  // memory-access attribute is Aligned, then the alignment attribute must be
        -:  475:  // present.
    #####:  476:  auto *op = memoryOp.getOperation();
call    0 never executed
    #####:  477:  auto memAccessAttr = op->getAttr(kMemoryAccessAttrName);
call    0 never executed
    #####:  478:  if (!memAccessAttr) {
branch  0 never executed
branch  1 never executed
        -:  479:    // Alignment attribute shouldn't be present if memory access attribute is
        -:  480:    // not present.
    #####:  481:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  482:      return memoryOp.emitOpError(
        -:  483:          "invalid alignment specification without aligned memory access "
    #####:  484:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  485:    }
    #####:  486:    return success();
        -:  487:  }
        -:  488:
    #####:  489:  auto memAccess = memAccessAttr.template cast<spirv::MemoryAccessAttr>();
        -:  490:
    #####:  491:  if (!memAccess) {
branch  0 never executed
branch  1 never executed
        -:  492:    return memoryOp.emitOpError("invalid memory access specifier: ")
    #####:  493:           << memAccessAttr;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  494:  }
        -:  495:
    #####:  496:  if (spirv::bitEnumContainsAll(memAccess.getValue(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  497:                                spirv::MemoryAccess::Aligned)) {
    #####:  498:    if (!op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:      return memoryOp.emitOpError("missing alignment value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  500:    }
        -:  501:  } else {
    #####:  502:    if (op->getAttr(kAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  503:      return memoryOp.emitOpError(
        -:  504:          "invalid alignment specification with non-aligned memory access "
    #####:  505:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  506:    }
        -:  507:  }
    #####:  508:  return success();
        -:  509:}
------------------
        -:  510:
        -:  511:// TODO Make sure to merge this and the previous function into one template
        -:  512:// parameterized by memory access attribute name and alignment. Doing so now
        -:  513:// results in VS2017 in producing an internal error (at the call site) that's
        -:  514:// not detailed enough to understand what is happening.
        -:  515:template <typename MemoryOpTy>
function _Z33verifySourceMemoryAccessAttributeIN4mlir5spirv12CopyMemoryOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  516:static LogicalResult verifySourceMemoryAccessAttribute(MemoryOpTy memoryOp) {
        -:  517:  // ODS checks for attributes values. Just need to verify that if the
        -:  518:  // memory-access attribute is Aligned, then the alignment attribute must be
        -:  519:  // present.
    #####:  520:  auto *op = memoryOp.getOperation();
call    0 never executed
    #####:  521:  auto memAccessAttr = op->getAttr(kSourceMemoryAccessAttrName);
call    0 never executed
    #####:  522:  if (!memAccessAttr) {
branch  0 never executed
branch  1 never executed
        -:  523:    // Alignment attribute shouldn't be present if memory access attribute is
        -:  524:    // not present.
    #####:  525:    if (op->getAttr(kSourceAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  526:      return memoryOp.emitOpError(
        -:  527:          "invalid alignment specification without aligned memory access "
    #####:  528:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  529:    }
    #####:  530:    return success();
        -:  531:  }
        -:  532:
    #####:  533:  auto memAccess = memAccessAttr.template cast<spirv::MemoryAccessAttr>();
        -:  534:
    #####:  535:  if (!memAccess) {
branch  0 never executed
branch  1 never executed
        -:  536:    return memoryOp.emitOpError("invalid memory access specifier: ")
    #####:  537:           << memAccess;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  538:  }
        -:  539:
    #####:  540:  if (spirv::bitEnumContainsAll(memAccess.getValue(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  541:                                spirv::MemoryAccess::Aligned)) {
    #####:  542:    if (!op->getAttr(kSourceAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  543:      return memoryOp.emitOpError("missing alignment value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  544:    }
        -:  545:  } else {
    #####:  546:    if (op->getAttr(kSourceAlignmentAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  547:      return memoryOp.emitOpError(
        -:  548:          "invalid alignment specification with non-aligned memory access "
    #####:  549:          "specification");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  550:    }
        -:  551:  }
    #####:  552:  return success();
        -:  553:}
        -:  554:
        -:  555:static LogicalResult
function _ZL21verifyMemorySemanticsPN4mlir9OperationENS_5spirv15MemorySemanticsE called 0 returned 0% blocks executed 0%
    #####:  556:verifyMemorySemantics(Operation *op, spirv::MemorySemantics memorySemantics) {
        -:  557:  // According to the SPIR-V specification:
        -:  558:  // "Despite being a mask and allowing multiple bits to be combined, it is
        -:  559:  // invalid for more than one of these four bits to be set: Acquire, Release,
        -:  560:  // AcquireRelease, or SequentiallyConsistent. Requesting both Acquire and
        -:  561:  // Release semantics is done by setting the AcquireRelease bit, not by setting
        -:  562:  // two bits."
    #####:  563:  auto atMostOneInSet = spirv::MemorySemantics::Acquire |
        -:  564:                        spirv::MemorySemantics::Release |
        -:  565:                        spirv::MemorySemantics::AcquireRelease |
        -:  566:                        spirv::MemorySemantics::SequentiallyConsistent;
        -:  567:
    #####:  568:  auto bitCount = llvm::countPopulation(
branch  0 never executed
branch  1 never executed
    #####:  569:      static_cast<uint32_t>(memorySemantics & atMostOneInSet));
branch  0 never executed
branch  1 never executed
    #####:  570:  if (bitCount > 1) {
branch  0 never executed
branch  1 never executed
    #####:  571:    return op->emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  572:        "expected at most one of these four memory constraints "
        -:  573:        "to be set: `Acquire`, `Release`,"
    #####:  574:        "`AcquireRelease` or `SequentiallyConsistent`");
call    0 never executed
        -:  575:  }
    #####:  576:  return success();
        -:  577:}
        -:  578:
        -:  579:template <typename LoadStoreOpTy>
    #####:  580:static LogicalResult verifyLoadStorePtrAndValTypes(LoadStoreOpTy op, Value ptr,
        -:  581:                                                   Value val) {
        -:  582:  // ODS already checks ptr is spirv::PointerType. Just check that the pointee
        -:  583:  // type of the pointer and the type of the value are the same
        -:  584:  //
        -:  585:  // TODO: Check that the value type satisfies restrictions of
        -:  586:  // SPIR-V OpLoad/OpStore operations
    #####:  587:  if (val.getType() !=
    #####:  588:      ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
    #####:  589:    return op.emitOpError("mismatch in result type and pointer type");
        -:  590:  }
    #####:  591:  return success();
        -:  592:}
------------------
_Z29verifyLoadStorePtrAndValTypesIN4mlir5spirv7StoreOpEENS0_13LogicalResultET_NS0_5ValueES5_:
function _Z29verifyLoadStorePtrAndValTypesIN4mlir5spirv7StoreOpEENS0_13LogicalResultET_NS0_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####:  580:static LogicalResult verifyLoadStorePtrAndValTypes(LoadStoreOpTy op, Value ptr,
        -:  581:                                                   Value val) {
        -:  582:  // ODS already checks ptr is spirv::PointerType. Just check that the pointee
        -:  583:  // type of the pointer and the type of the value are the same
        -:  584:  //
        -:  585:  // TODO: Check that the value type satisfies restrictions of
        -:  586:  // SPIR-V OpLoad/OpStore operations
    #####:  587:  if (val.getType() !=
branch  0 never executed
branch  1 never executed
    #####:  588:      ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:    return op.emitOpError("mismatch in result type and pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  590:  }
    #####:  591:  return success();
        -:  592:}
------------------
_Z29verifyLoadStorePtrAndValTypesIN4mlir5spirv6LoadOpEENS0_13LogicalResultET_NS0_5ValueES5_:
function _Z29verifyLoadStorePtrAndValTypesIN4mlir5spirv6LoadOpEENS0_13LogicalResultET_NS0_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####:  580:static LogicalResult verifyLoadStorePtrAndValTypes(LoadStoreOpTy op, Value ptr,
        -:  581:                                                   Value val) {
        -:  582:  // ODS already checks ptr is spirv::PointerType. Just check that the pointee
        -:  583:  // type of the pointer and the type of the value are the same
        -:  584:  //
        -:  585:  // TODO: Check that the value type satisfies restrictions of
        -:  586:  // SPIR-V OpLoad/OpStore operations
    #####:  587:  if (val.getType() !=
branch  0 never executed
branch  1 never executed
    #####:  588:      ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:    return op.emitOpError("mismatch in result type and pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  590:  }
    #####:  591:  return success();
        -:  592:}
------------------
        -:  593:
        -:  594:template <typename BlockReadWriteOpTy>
    #####:  595:static LogicalResult verifyBlockReadWritePtrAndValTypes(BlockReadWriteOpTy op,
        -:  596:                                                        Value ptr, Value val) {
    #####:  597:  auto valType = val.getType();
    #####:  598:  if (auto valVecTy = valType.dyn_cast<VectorType>())
    #####:  599:    valType = valVecTy.getElementType();
        -:  600:
    #####:  601:  if (valType != ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
    #####:  602:    return op.emitOpError("mismatch in result type and pointer type");
        -:  603:  }
    #####:  604:  return success();
        -:  605:}
------------------
_Z34verifyBlockReadWritePtrAndValTypesIN4mlir5spirv25INTELSubgroupBlockWriteOpEENS0_13LogicalResultET_NS0_5ValueES5_:
function _Z34verifyBlockReadWritePtrAndValTypesIN4mlir5spirv25INTELSubgroupBlockWriteOpEENS0_13LogicalResultET_NS0_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####:  595:static LogicalResult verifyBlockReadWritePtrAndValTypes(BlockReadWriteOpTy op,
        -:  596:                                                        Value ptr, Value val) {
    #####:  597:  auto valType = val.getType();
call    0 never executed
    #####:  598:  if (auto valVecTy = valType.dyn_cast<VectorType>())
branch  0 never executed
branch  1 never executed
    #####:  599:    valType = valVecTy.getElementType();
call    0 never executed
        -:  600:
    #####:  601:  if (valType != ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  602:    return op.emitOpError("mismatch in result type and pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  603:  }
    #####:  604:  return success();
        -:  605:}
------------------
_Z34verifyBlockReadWritePtrAndValTypesIN4mlir5spirv24INTELSubgroupBlockReadOpEENS0_13LogicalResultET_NS0_5ValueES5_:
function _Z34verifyBlockReadWritePtrAndValTypesIN4mlir5spirv24INTELSubgroupBlockReadOpEENS0_13LogicalResultET_NS0_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####:  595:static LogicalResult verifyBlockReadWritePtrAndValTypes(BlockReadWriteOpTy op,
        -:  596:                                                        Value ptr, Value val) {
    #####:  597:  auto valType = val.getType();
call    0 never executed
    #####:  598:  if (auto valVecTy = valType.dyn_cast<VectorType>())
branch  0 never executed
branch  1 never executed
    #####:  599:    valType = valVecTy.getElementType();
call    0 never executed
        -:  600:
    #####:  601:  if (valType != ptr.getType().cast<spirv::PointerType>().getPointeeType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  602:    return op.emitOpError("mismatch in result type and pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  603:  }
    #####:  604:  return success();
        -:  605:}
------------------
        -:  606:
function _ZL24parseVariableDecorationsRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  607:static ParseResult parseVariableDecorations(OpAsmParser &parser,
        -:  608:                                            OperationState &state) {
    #####:  609:  auto builtInName = llvm::convertToSnakeFromCamelCase(
    #####:  610:      stringifyDecoration(spirv::Decoration::BuiltIn));
call    0 never executed
call    1 never executed
    #####:  611:  if (succeeded(parser.parseOptionalKeyword("bind"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  612:    Attribute set, binding;
        -:  613:    // Parse optional descriptor binding
    #####:  614:    auto descriptorSetName = llvm::convertToSnakeFromCamelCase(
    #####:  615:        stringifyDecoration(spirv::Decoration::DescriptorSet));
call    0 never executed
call    1 never executed
    #####:  616:    auto bindingName = llvm::convertToSnakeFromCamelCase(
    #####:  617:        stringifyDecoration(spirv::Decoration::Binding));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  618:    Type i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####:  619:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  620:        parser.parseAttribute(set, i32Type, descriptorSetName,
    #####:  621:                              state.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  622:        parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  623:        parser.parseAttribute(binding, i32Type, bindingName,
    #####:  624:                              state.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  625:        parser.parseRParen()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  626:      return failure();
branch  0 never executed
branch  1 never executed
        -:  627:    }
    #####:  628:  } else if (succeeded(parser.parseOptionalKeyword(builtInName))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  629:    StringAttr builtIn;
    #####:  630:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  631:        parser.parseAttribute(builtIn, builtInName, state.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  632:        parser.parseRParen()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  633:      return failure();
        -:  634:    }
        -:  635:  }
        -:  636:
        -:  637:  // Parse other attributes
    #####:  638:  if (parser.parseOptionalAttrDict(state.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  639:    return failure();
        -:  640:
    #####:  641:  return success();
        -:  642:}
        -:  643:
function _ZL24printVariableDecorationsPN4mlir9OperationERNS_12OpAsmPrinterERN4llvm15SmallVectorImplINS4_9StringRefEEE called 0 returned 0% blocks executed 0%
    #####:  644:static void printVariableDecorations(Operation *op, OpAsmPrinter &printer,
        -:  645:                                     SmallVectorImpl<StringRef> &elidedAttrs) {
        -:  646:  // Print optional descriptor binding
    #####:  647:  auto descriptorSetName = llvm::convertToSnakeFromCamelCase(
    #####:  648:      stringifyDecoration(spirv::Decoration::DescriptorSet));
call    0 never executed
call    1 never executed
    #####:  649:  auto bindingName = llvm::convertToSnakeFromCamelCase(
    #####:  650:      stringifyDecoration(spirv::Decoration::Binding));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  651:  auto descriptorSet = op->getAttrOfType<IntegerAttr>(descriptorSetName);
call    0 never executed
    #####:  652:  auto binding = op->getAttrOfType<IntegerAttr>(bindingName);
call    0 never executed
    #####:  653:  if (descriptorSet && binding) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  654:    elidedAttrs.push_back(descriptorSetName);
call    0 never executed
    #####:  655:    elidedAttrs.push_back(bindingName);
call    0 never executed
    #####:  656:    printer << " bind(" << descriptorSet.getInt() << ", " << binding.getInt()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  657:            << ")";
call    0 never executed
        -:  658:  }
        -:  659:
        -:  660:  // Print BuiltIn attribute if present
    #####:  661:  auto builtInName = llvm::convertToSnakeFromCamelCase(
    #####:  662:      stringifyDecoration(spirv::Decoration::BuiltIn));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  663:  if (auto builtin = op->getAttrOfType<StringAttr>(builtInName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  664:    printer << " " << builtInName << "(\"" << builtin.getValue() << "\")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  665:    elidedAttrs.push_back(builtInName);
call    0 never executed
        -:  666:  }
        -:  667:
    #####:  668:  printer.printOptionalAttrDict(op->getAttrs(), elidedAttrs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  669:}
        -:  670:
        -:  671:// Get bit width of types.
function _ZL11getBitWidthN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:  672:static unsigned getBitWidth(Type type) {
    #####:  673:  if (type.isa<spirv::PointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  674:    // Just return 64 bits for pointer types for now.
        -:  675:    // TODO: Make sure not caller relies on the actual pointer width value.
        -:  676:    return 64;
        -:  677:  }
        -:  678:
    #####:  679:  if (type.isIntOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  680:    return type.getIntOrFloatBitWidth();
call    0 never executed
        -:  681:
    #####:  682:  if (auto vectorType = type.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  683:    assert(vectorType.getElementType().isIntOrFloat());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  684:    return vectorType.getNumElements() *
call    0 never executed
    #####:  685:           vectorType.getElementType().getIntOrFloatBitWidth();
call    0 never executed
call    1 never executed
        -:  686:  }
    #####:  687:  llvm_unreachable("unhandled bit width computation for type");
call    0 never executed
        -:  688:}
        -:  689:
        -:  690:/// Walks the given type hierarchy with the given indices, potentially down
        -:  691:/// to component granularity, to select an element type. Returns null type and
        -:  692:/// emits errors with the given loc on failure.
        -:  693:static Type
function _ZL14getElementTypeN4mlir4TypeEN4llvm8ArrayRefIiEENS1_12function_refIFNS_18InFlightDiagnosticENS1_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  694:getElementType(Type type, ArrayRef<int32_t> indices,
        -:  695:               function_ref<InFlightDiagnostic(StringRef)> emitErrorFn) {
    #####:  696:  if (indices.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  697:    emitErrorFn("expected at least one index for spirv.CompositeExtract");
call    0 never executed
call    1 never executed
    #####:  698:    return nullptr;
        -:  699:  }
        -:  700:
    #####:  701:  for (auto index : indices) {
branch  0 never executed
branch  1 never executed
    #####:  702:    if (auto cType = type.dyn_cast<spirv::CompositeType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  703:      if (cType.hasCompileTimeKnownNumElements() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  704:          (index < 0 ||
branch  0 never executed
branch  1 never executed
    #####:  705:           static_cast<uint64_t>(index) >= cType.getNumElements())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  706:        emitErrorFn("index ") << index << " out of bounds for " << type;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  707:        return nullptr;
        -:  708:      }
    #####:  709:      type = cType.getElementType(index);
call    0 never executed
        -:  710:    } else {
    #####:  711:      emitErrorFn("cannot extract from non-composite type ")
call    0 never executed
call    1 never executed
    #####:  712:          << type << " with index " << index;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  713:      return nullptr;
        -:  714:    }
        -:  715:  }
    #####:  716:  return type;
        -:  717:}
        -:  718:
        -:  719:static Type
function _ZL14getElementTypeN4mlir4TypeENS_9AttributeEN4llvm12function_refIFNS_18InFlightDiagnosticENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####:  720:getElementType(Type type, Attribute indices,
        -:  721:               function_ref<InFlightDiagnostic(StringRef)> emitErrorFn) {
    #####:  722:  auto indicesArrayAttr = indices.dyn_cast<ArrayAttr>();
call    0 never executed
    #####:  723:  if (!indicesArrayAttr) {
branch  0 never executed
branch  1 never executed
    #####:  724:    emitErrorFn("expected a 32-bit integer array attribute for 'indices'");
call    0 never executed
call    1 never executed
    #####:  725:    return nullptr;
        -:  726:  }
    #####:  727:  if (indicesArrayAttr.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  728:    emitErrorFn("expected at least one index for spirv.CompositeExtract");
call    0 never executed
call    1 never executed
    #####:  729:    return nullptr;
        -:  730:  }
        -:  731:
    #####:  732:  SmallVector<int32_t, 2> indexVals;
call    0 never executed
    #####:  733:  for (auto indexAttr : indicesArrayAttr) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  734:    auto indexIntAttr = indexAttr.dyn_cast<IntegerAttr>();
call    0 never executed
    #####:  735:    if (!indexIntAttr) {
branch  0 never executed
branch  1 never executed
    #####:  736:      emitErrorFn("expected an 32-bit integer for index, but found '")
call    0 never executed
call    1 never executed
    #####:  737:          << indexAttr << "'";
call    0 never executed
call    1 never executed
    #####:  738:      return nullptr;
        -:  739:    }
    #####:  740:    indexVals.push_back(indexIntAttr.getInt());
call    0 never executed
call    1 never executed
        -:  741:  }
    #####:  742:  return getElementType(type, indexVals, emitErrorFn);
call    0 never executed
        -:  743:}
        -:  744:
    #####:  745:static Type getElementType(Type type, Attribute indices, Location loc) {
    #####:  746:  auto errorFn = [&](StringRef err) -> InFlightDiagnostic {
    #####:  747:    return ::mlir::emitError(loc, err);
call    0 never executed
call    1 never executed
    #####:  748:  };
    #####:  749:  return getElementType(type, indices, errorFn);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  750:}
        -:  751:
    #####:  752:static Type getElementType(Type type, Attribute indices, OpAsmParser &parser,
        -:  753:                           SMLoc loc) {
    #####:  754:  auto errorFn = [&](StringRef err) -> InFlightDiagnostic {
    #####:  755:    return parser.emitError(loc, err);
call    0 never executed
call    1 never executed
    #####:  756:  };
    #####:  757:  return getElementType(type, indices, errorFn);
        -:  758:}
        -:  759:
        -:  760:/// Returns true if the given `block` only contains one `spirv.mlir.merge` op.
function _ZL12isMergeBlockRN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  761:static inline bool isMergeBlock(Block &block) {
    #####:  762:  return !block.empty() && std::next(block.begin()) == block.end() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  763:         isa<spirv::MergeOp>(block.front());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  764:}
        -:  765:
        -:  766://===----------------------------------------------------------------------===//
        -:  767:// Common parsers and printers
        -:  768://===----------------------------------------------------------------------===//
        -:  769:
        -:  770:// Parses an atomic update op. If the update op does not take a value (like
        -:  771:// AtomicIIncrement) `hasValue` must be false.
function _ZL19parseAtomicUpdateOpRN4mlir11OpAsmParserERNS_14OperationStateEb called 0 returned 0% blocks executed 0%
    #####:  772:static ParseResult parseAtomicUpdateOp(OpAsmParser &parser,
        -:  773:                                       OperationState &state, bool hasValue) {
    #####:  774:  spirv::Scope scope;
    #####:  775:  spirv::MemorySemantics memoryScope;
    #####:  776:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandInfo;
call    0 never executed
    #####:  777:  OpAsmParser::UnresolvedOperand ptrInfo, valueInfo;
call    0 never executed
    #####:  778:  Type type;
    #####:  779:  SMLoc loc;
    #####:  780:  if (parseEnumStrAttr<spirv::ScopeAttr>(scope, parser, state,
call    0 never executed
    #####:  781:                                         kMemoryScopeAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  782:      parseEnumStrAttr<spirv::MemorySemanticsAttr>(memoryScope, parser, state,
    #####:  783:                                                   kSemanticsAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  784:      parser.parseOperandList(operandInfo, (hasValue ? 2 : 1)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  785:      parser.getCurrentLocation(&loc) || parser.parseColonType(type))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  786:    return failure();
        -:  787:
    #####:  788:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####:  789:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####:  790:    return parser.emitError(loc, "expected pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  791:
    #####:  792:  SmallVector<Type, 2> operandTypes;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:  operandTypes.push_back(ptrType);
call    0 never executed
    #####:  794:  if (hasValue)
branch  0 never executed
branch  1 never executed
    #####:  795:    operandTypes.push_back(ptrType.getPointeeType());
call    0 never executed
call    1 never executed
    #####:  796:  if (parser.resolveOperands(operandInfo, operandTypes, parser.getNameLoc(),
branch  0 never executed
branch  1 never executed
    #####:  797:                             state.operands))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  798:    return failure();
    #####:  799:  return parser.addTypeToList(ptrType.getPointeeType(), state.types);
call    0 never executed
call    1 never executed
        -:  800:}
        -:  801:
        -:  802:// Prints an atomic update op.
function _ZL19printAtomicUpdateOpPN4mlir9OperationERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  803:static void printAtomicUpdateOp(Operation *op, OpAsmPrinter &printer) {
    #####:  804:  printer << " \"";
call    0 never executed
    #####:  805:  auto scopeAttr = op->getAttrOfType<spirv::ScopeAttr>(kMemoryScopeAttrName);
call    0 never executed
    #####:  806:  printer << spirv::stringifyScope(scopeAttr.getValue()) << "\" \"";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  807:  auto memorySemanticsAttr =
call    0 never executed
    #####:  808:      op->getAttrOfType<spirv::MemorySemanticsAttr>(kSemanticsAttrName);
call    0 never executed
    #####:  809:  printer << spirv::stringifyMemorySemantics(memorySemanticsAttr.getValue())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  810:          << "\" " << op->getOperands() << " : " << op->getOperand(0).getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  811:}
        -:  812:
        -:  813:template <typename T>
        -:  814:static StringRef stringifyTypeName();
        -:  815:
        -:  816:template <>
    #####:  817:StringRef stringifyTypeName<IntegerType>() {
    #####:  818:  return "integer";
        -:  819:}
        -:  820:
        -:  821:template <>
    #####:  822:StringRef stringifyTypeName<FloatType>() {
    #####:  823:  return "float";
        -:  824:}
        -:  825:
        -:  826:// Verifies an atomic update op.
        -:  827:template <typename ExpectedElementType>
    #####:  828:static LogicalResult verifyAtomicUpdateOp(Operation *op) {
    #####:  829:  auto ptrType = op->getOperand(0).getType().cast<spirv::PointerType>();
    #####:  830:  auto elementType = ptrType.getPointeeType();
    #####:  831:  if (!elementType.isa<ExpectedElementType>())
    #####:  832:    return op->emitOpError() << "pointer operand must point to an "
    #####:  833:                             << stringifyTypeName<ExpectedElementType>()
    #####:  834:                             << " value, found " << elementType;
        -:  835:
    #####:  836:  if (op->getNumOperands() > 1) {
    #####:  837:    auto valueType = op->getOperand(1).getType();
    #####:  838:    if (valueType != elementType)
        -:  839:      return op->emitOpError("expected value to have the same type as the "
        -:  840:                             "pointer operand's pointee type ")
    #####:  841:             << elementType << ", but found " << valueType;
        -:  842:  }
        -:  843:  auto memorySemantics =
    #####:  844:      op->getAttrOfType<spirv::MemorySemanticsAttr>(kSemanticsAttrName)
    #####:  845:          .getValue();
    #####:  846:  if (failed(verifyMemorySemantics(op, memorySemantics))) {
    #####:  847:    return failure();
        -:  848:  }
    #####:  849:  return success();
        -:  850:}
------------------
_Z20verifyAtomicUpdateOpIN4mlir9FloatTypeEENS0_13LogicalResultEPNS0_9OperationE:
function _Z20verifyAtomicUpdateOpIN4mlir9FloatTypeEENS0_13LogicalResultEPNS0_9OperationE called 0 returned 0% blocks executed 0%
    #####:  828:static LogicalResult verifyAtomicUpdateOp(Operation *op) {
call    0 never executed
    #####:  829:  auto ptrType = op->getOperand(0).getType().cast<spirv::PointerType>();
call    0 never executed
    #####:  830:  auto elementType = ptrType.getPointeeType();
call    0 never executed
call    1 never executed
    #####:  831:  if (!elementType.isa<ExpectedElementType>())
branch  0 never executed
branch  1 never executed
    #####:  832:    return op->emitOpError() << "pointer operand must point to an "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  833:                             << stringifyTypeName<ExpectedElementType>()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  834:                             << " value, found " << elementType;
call    0 never executed
call    1 never executed
        -:  835:
    #####:  836:  if (op->getNumOperands() > 1) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  837:    auto valueType = op->getOperand(1).getType();
branch  0 never executed
branch  1 never executed
    #####:  838:    if (valueType != elementType)
branch  0 never executed
branch  1 never executed
        -:  839:      return op->emitOpError("expected value to have the same type as the "
        -:  840:                             "pointer operand's pointee type ")
    #####:  841:             << elementType << ", but found " << valueType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  842:  }
        -:  843:  auto memorySemantics =
    #####:  844:      op->getAttrOfType<spirv::MemorySemanticsAttr>(kSemanticsAttrName)
call    0 never executed
    #####:  845:          .getValue();
call    0 never executed
    #####:  846:  if (failed(verifyMemorySemantics(op, memorySemantics))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  847:    return failure();
        -:  848:  }
    #####:  849:  return success();
        -:  850:}
------------------
_Z20verifyAtomicUpdateOpIN4mlir11IntegerTypeEENS0_13LogicalResultEPNS0_9OperationE:
function _Z20verifyAtomicUpdateOpIN4mlir11IntegerTypeEENS0_13LogicalResultEPNS0_9OperationE called 0 returned 0% blocks executed 0%
    #####:  828:static LogicalResult verifyAtomicUpdateOp(Operation *op) {
call    0 never executed
    #####:  829:  auto ptrType = op->getOperand(0).getType().cast<spirv::PointerType>();
call    0 never executed
    #####:  830:  auto elementType = ptrType.getPointeeType();
call    0 never executed
call    1 never executed
    #####:  831:  if (!elementType.isa<ExpectedElementType>())
branch  0 never executed
branch  1 never executed
    #####:  832:    return op->emitOpError() << "pointer operand must point to an "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  833:                             << stringifyTypeName<ExpectedElementType>()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  834:                             << " value, found " << elementType;
call    0 never executed
call    1 never executed
        -:  835:
    #####:  836:  if (op->getNumOperands() > 1) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  837:    auto valueType = op->getOperand(1).getType();
branch  0 never executed
branch  1 never executed
    #####:  838:    if (valueType != elementType)
branch  0 never executed
branch  1 never executed
        -:  839:      return op->emitOpError("expected value to have the same type as the "
        -:  840:                             "pointer operand's pointee type ")
    #####:  841:             << elementType << ", but found " << valueType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  842:  }
        -:  843:  auto memorySemantics =
    #####:  844:      op->getAttrOfType<spirv::MemorySemanticsAttr>(kSemanticsAttrName)
call    0 never executed
    #####:  845:          .getValue();
call    0 never executed
    #####:  846:  if (failed(verifyMemorySemantics(op, memorySemantics))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  847:    return failure();
        -:  848:  }
    #####:  849:  return success();
        -:  850:}
------------------
        -:  851:
function _ZL32parseGroupNonUniformArithmeticOpRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  852:static ParseResult parseGroupNonUniformArithmeticOp(OpAsmParser &parser,
        -:  853:                                                    OperationState &state) {
    #####:  854:  spirv::Scope executionScope;
    #####:  855:  spirv::GroupOperation groupOperation;
    #####:  856:  OpAsmParser::UnresolvedOperand valueInfo;
call    0 never executed
    #####:  857:  if (parseEnumStrAttr<spirv::ScopeAttr>(executionScope, parser, state,
call    0 never executed
    #####:  858:                                         kExecutionScopeAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  859:      parseEnumStrAttr<spirv::GroupOperationAttr>(groupOperation, parser, state,
    #####:  860:                                                  kGroupOperationAttrName) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  861:      parser.parseOperand(valueInfo))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  862:    return failure();
        -:  863:
    #####:  864:  Optional<OpAsmParser::UnresolvedOperand> clusterSizeInfo;
    #####:  865:  if (succeeded(parser.parseOptionalKeyword(kClusterSize))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  866:    clusterSizeInfo = OpAsmParser::UnresolvedOperand();
branch  0 never executed
branch  1 never executed
    #####:  867:    if (parser.parseLParen() || parser.parseOperand(*clusterSizeInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  868:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  869:      return failure();
        -:  870:  }
        -:  871:
    #####:  872:  Type resultType;
    #####:  873:  if (parser.parseColonType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  874:    return failure();
        -:  875:
    #####:  876:  if (parser.resolveOperand(valueInfo, resultType, state.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  877:    return failure();
        -:  878:
    #####:  879:  if (clusterSizeInfo) {
branch  0 never executed
branch  1 never executed
    #####:  880:    Type i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####:  881:    if (parser.resolveOperand(*clusterSizeInfo, i32Type, state.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  882:      return failure();
        -:  883:  }
        -:  884:
    #####:  885:  return parser.addTypeToList(resultType, state.types);
call    0 never executed
        -:  886:}
        -:  887:
function _ZL32printGroupNonUniformArithmeticOpPN4mlir9OperationERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  888:static void printGroupNonUniformArithmeticOp(Operation *groupOp,
        -:  889:                                             OpAsmPrinter &printer) {
    #####:  890:  printer
call    0 never executed
    #####:  891:      << " \""
call    0 never executed
    #####:  892:      << stringifyScope(
    #####:  893:             groupOp->getAttrOfType<spirv::ScopeAttr>(kExecutionScopeAttrName)
call    0 never executed
    #####:  894:                 .getValue())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  895:      << "\" \""
call    0 never executed
    #####:  896:      << stringifyGroupOperation(groupOp
    #####:  897:                                     ->getAttrOfType<spirv::GroupOperationAttr>(
    #####:  898:                                         kGroupOperationAttrName)
call    0 never executed
    #####:  899:                                     .getValue())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  900:      << "\" " << groupOp->getOperand(0);
call    0 never executed
call    1 never executed
        -:  901:
    #####:  902:  if (groupOp->getNumOperands() > 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  903:    printer << " " << kClusterSize << '(' << groupOp->getOperand(1) << ')';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  904:  printer << " : " << groupOp->getResult(0).getType();
call    0 never executed
call    1 never executed
    #####:  905:}
        -:  906:
function _ZL33verifyGroupNonUniformArithmeticOpPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  907:static LogicalResult verifyGroupNonUniformArithmeticOp(Operation *groupOp) {
    #####:  908:  spirv::Scope scope =
call    0 never executed
    #####:  909:      groupOp->getAttrOfType<spirv::ScopeAttr>(kExecutionScopeAttrName)
call    0 never executed
    #####:  910:          .getValue();
call    0 never executed
    #####:  911:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####:  912:    return groupOp->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  913:        "execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
        -:  914:
    #####:  915:  spirv::GroupOperation operation =
call    0 never executed
    #####:  916:      groupOp->getAttrOfType<spirv::GroupOperationAttr>(kGroupOperationAttrName)
call    0 never executed
    #####:  917:          .getValue();
call    0 never executed
    #####:  918:  if (operation == spirv::GroupOperation::ClusteredReduce &&
branch  0 never executed
branch  1 never executed
    #####:  919:      groupOp->getNumOperands() == 1)
branch  0 never executed
branch  1 never executed
    #####:  920:    return groupOp->emitOpError("cluster size operand must be provided for "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  921:                                "'ClusteredReduce' group operation");
call    0 never executed
    #####:  922:  if (groupOp->getNumOperands() > 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  923:    Operation *sizeOp = groupOp->getOperand(1).getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  924:    int32_t clusterSize = 0;
        -:  925:
        -:  926:    // TODO: support specialization constant here.
    #####:  927:    if (failed(extractValueFromConstOp(sizeOp, clusterSize)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  928:      return groupOp->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  929:          "cluster size operand must come from a constant op");
call    0 never executed
        -:  930:
    #####:  931:    if (!llvm::isPowerOf2_32(clusterSize))
branch  0 never executed
branch  1 never executed
    #####:  932:      return groupOp->emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  933:          "cluster size operand must be a power of two");
call    0 never executed
        -:  934:  }
    #####:  935:  return success();
        -:  936:}
        -:  937:
        -:  938:/// Result of a logical op must be a scalar or vector of boolean type.
function _ZL20getUnaryOpResultTypeN4mlir4TypeE called 0 returned 0% blocks executed 0%
    #####:  939:static Type getUnaryOpResultType(Type operandType) {
    #####:  940:  Builder builder(operandType.getContext());
call    0 never executed
call    1 never executed
    #####:  941:  Type resultType = builder.getIntegerType(1);
call    0 never executed
    #####:  942:  if (auto vecType = operandType.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  943:    return VectorType::get(vecType.getNumElements(), resultType);
call    0 never executed
call    1 never executed
    #####:  944:  return resultType;
        -:  945:}
        -:  946:
function _ZL13verifyShiftOpPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  947:static LogicalResult verifyShiftOp(Operation *op) {
    #####:  948:  if (op->getOperand(0).getType() != op->getResult(0).getType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  949:    return op->emitError("expected the same type for the first operand and "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  950:                         "result, but provided ")
    #####:  951:           << op->getOperand(0).getType() << " and "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  952:           << op->getResult(0).getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  953:  }
    #####:  954:  return success();
        -:  955:}
        -:  956:
function _ZL20buildLogicalBinaryOpRN4mlir9OpBuilderERNS_14OperationStateENS_5ValueES4_ called 0 returned 0% blocks executed 0%
    #####:  957:static void buildLogicalBinaryOp(OpBuilder &builder, OperationState &state,
        -:  958:                                 Value lhs, Value rhs) {
    #####:  959:  assert(lhs.getType() == rhs.getType());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  960:
    #####:  961:  Type boolType = builder.getI1Type();
call    0 never executed
    #####:  962:  if (auto vecType = lhs.getType().dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  963:    boolType = VectorType::get(vecType.getShape(), boolType);
call    0 never executed
call    1 never executed
    #####:  964:  state.addTypes(boolType);
call    0 never executed
        -:  965:
    #####:  966:  state.addOperands({lhs, rhs});
call    0 never executed
call    1 never executed
    #####:  967:}
        -:  968:
function _ZL19buildLogicalUnaryOpRN4mlir9OpBuilderERNS_14OperationStateENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  969:static void buildLogicalUnaryOp(OpBuilder &builder, OperationState &state,
        -:  970:                                Value value) {
    #####:  971:  Type boolType = builder.getI1Type();
call    0 never executed
    #####:  972:  if (auto vecType = value.getType().dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  973:    boolType = VectorType::get(vecType.getShape(), boolType);
call    0 never executed
call    1 never executed
    #####:  974:  state.addTypes(boolType);
call    0 never executed
        -:  975:
    #####:  976:  state.addOperands(value);
call    0 never executed
call    1 never executed
    #####:  977:}
        -:  978:
        -:  979://===----------------------------------------------------------------------===//
        -:  980:// spirv.AccessChainOp
        -:  981://===----------------------------------------------------------------------===//
        -:  982:
function _ZL17getElementPtrTypeN4mlir4TypeENS_10ValueRangeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  983:static Type getElementPtrType(Type type, ValueRange indices, Location baseLoc) {
    #####:  984:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####:  985:  if (!ptrType) {
branch  0 never executed
branch  1 never executed
    #####:  986:    emitError(baseLoc, "'spirv.AccessChain' op expected a pointer "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  987:                       "to composite type, but provided ")
    #####:  988:        << type;
call    0 never executed
    #####:  989:    return nullptr;
        -:  990:  }
        -:  991:
    #####:  992:  auto resultType = ptrType.getPointeeType();
call    0 never executed
    #####:  993:  auto resultStorageClass = ptrType.getStorageClass();
call    0 never executed
    #####:  994:  int32_t index = 0;
        -:  995:
    #####:  996:  for (auto indexSSA : indices) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  997:    auto cType = resultType.dyn_cast<spirv::CompositeType>();
call    0 never executed
    #####:  998:    if (!cType) {
branch  0 never executed
branch  1 never executed
    #####:  999:      emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1000:          baseLoc,
        -: 1001:          "'spirv.AccessChain' op cannot extract from non-composite type ")
    #####: 1002:          << resultType << " with index " << index;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1003:      return nullptr;
        -: 1004:    }
    #####: 1005:    index = 0;
    #####: 1006:    if (resultType.isa<spirv::StructType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1007:      Operation *op = indexSSA.getDefiningOp();
call    0 never executed
    #####: 1008:      if (!op) {
branch  0 never executed
branch  1 never executed
    #####: 1009:        emitError(baseLoc, "'spirv.AccessChain' op index must be an "
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1010:                           "integer spirv.Constant to access "
        -: 1011:                           "element of spirv.struct");
    #####: 1012:        return nullptr;
        -: 1013:      }
        -: 1014:
        -: 1015:      // TODO: this should be relaxed to allow
        -: 1016:      // integer literals of other bitwidths.
    #####: 1017:      if (failed(extractValueFromConstOp(op, index))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1018:        emitError(
call    0 never executed
call    1 never executed
        -: 1019:            baseLoc,
        -: 1020:            "'spirv.AccessChain' index must be an integer spirv.Constant to "
        -: 1021:            "access element of spirv.struct, but provided ")
    #####: 1022:            << op->getName();
call    0 never executed
call    1 never executed
    #####: 1023:        return nullptr;
        -: 1024:      }
    #####: 1025:      if (index < 0 || static_cast<uint64_t>(index) >= cType.getNumElements()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1026:        emitError(baseLoc, "'spirv.AccessChain' op index ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1027:            << index << " out of bounds for " << resultType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1028:        return nullptr;
        -: 1029:      }
        -: 1030:    }
    #####: 1031:    resultType = cType.getElementType(index);
call    0 never executed
        -: 1032:  }
    #####: 1033:  return spirv::PointerType::get(resultType, resultStorageClass);
call    0 never executed
        -: 1034:}
        -: 1035:
function _ZN4mlir5spirv13AccessChainOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1036:void spirv::AccessChainOp::build(OpBuilder &builder, OperationState &state,
        -: 1037:                                 Value basePtr, ValueRange indices) {
    #####: 1038:  auto type = getElementPtrType(basePtr.getType(), indices, state.location);
call    0 never executed
    #####: 1039:  assert(type && "Unable to deduce return type based on basePtr and indices");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1040:  build(builder, state, type, basePtr, indices);
call    0 never executed
    #####: 1041:}
        -: 1042:
function _ZN4mlir5spirv13AccessChainOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1043:ParseResult spirv::AccessChainOp::parse(OpAsmParser &parser,
        -: 1044:                                        OperationState &result) {
    #####: 1045:  OpAsmParser::UnresolvedOperand ptrInfo;
call    0 never executed
    #####: 1046:  SmallVector<OpAsmParser::UnresolvedOperand, 4> indicesInfo;
call    0 never executed
    #####: 1047:  Type type;
    #####: 1048:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 1049:  SmallVector<Type, 4> indicesTypes;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1050:
    #####: 1051:  if (parser.parseOperand(ptrInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1052:      parser.parseOperandList(indicesInfo, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1053:      parser.parseColonType(type) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1054:      parser.resolveOperand(ptrInfo, type, result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1055:    return failure();
        -: 1056:  }
        -: 1057:
        -: 1058:  // Check that the provided indices list is not empty before parsing their
        -: 1059:  // type list.
    #####: 1060:  if (indicesInfo.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1061:    return mlir::emitError(result.location,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1062:                           "'spirv.AccessChain' op expected at "
    #####: 1063:                           "least one index ");
call    0 never executed
        -: 1064:  }
        -: 1065:
    #####: 1066:  if (parser.parseComma() || parser.parseTypeList(indicesTypes))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1067:    return failure();
        -: 1068:
        -: 1069:  // Check that the indices types list is not empty and that it has a one-to-one
        -: 1070:  // mapping to the provided indices.
    #####: 1071:  if (indicesTypes.size() != indicesInfo.size()) {
branch  0 never executed
branch  1 never executed
    #####: 1072:    return mlir::emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1073:        result.location, "'spirv.AccessChain' op indices types' count must be "
    #####: 1074:                         "equal to indices info count");
call    0 never executed
        -: 1075:  }
        -: 1076:
    #####: 1077:  if (parser.resolveOperands(indicesInfo, indicesTypes, loc, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1078:    return failure();
        -: 1079:
    #####: 1080:  auto resultType = getElementPtrType(
    #####: 1081:      type, llvm::makeArrayRef(result.operands).drop_front(), result.location);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1082:  if (!resultType) {
branch  0 never executed
branch  1 never executed
    #####: 1083:    return failure();
        -: 1084:  }
        -: 1085:
    #####: 1086:  result.addTypes(resultType);
call    0 never executed
    #####: 1087:  return success();
        -: 1088:}
        -: 1089:
        -: 1090:template <typename Op>
    #####: 1091:static void printAccessChain(Op op, ValueRange indices, OpAsmPrinter &printer) {
    #####: 1092:  printer << ' ' << op.getBasePtr() << '[' << indices
    #####: 1093:          << "] : " << op.getBasePtr().getType() << ", " << indices.getTypes();
    #####: 1094:}
------------------
_Z16printAccessChainIN4mlir5spirv16PtrAccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE:
function _Z16printAccessChainIN4mlir5spirv16PtrAccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1091:static void printAccessChain(Op op, ValueRange indices, OpAsmPrinter &printer) {
    #####: 1092:  printer << ' ' << op.getBasePtr() << '[' << indices
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1093:          << "] : " << op.getBasePtr().getType() << ", " << indices.getTypes();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1094:}
------------------
_Z16printAccessChainIN4mlir5spirv24InBoundsPtrAccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE:
function _Z16printAccessChainIN4mlir5spirv24InBoundsPtrAccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1091:static void printAccessChain(Op op, ValueRange indices, OpAsmPrinter &printer) {
    #####: 1092:  printer << ' ' << op.getBasePtr() << '[' << indices
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1093:          << "] : " << op.getBasePtr().getType() << ", " << indices.getTypes();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1094:}
------------------
_Z16printAccessChainIN4mlir5spirv13AccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE:
function _Z16printAccessChainIN4mlir5spirv13AccessChainOpEEvT_NS0_10ValueRangeERNS0_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1091:static void printAccessChain(Op op, ValueRange indices, OpAsmPrinter &printer) {
    #####: 1092:  printer << ' ' << op.getBasePtr() << '[' << indices
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1093:          << "] : " << op.getBasePtr().getType() << ", " << indices.getTypes();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1094:}
------------------
        -: 1095:
function _ZN4mlir5spirv13AccessChainOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1096:void spirv::AccessChainOp::print(OpAsmPrinter &printer) {
    #####: 1097:  printAccessChain(*this, getIndices(), printer);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1098:}
        -: 1099:
        -: 1100:template <typename Op>
    #####: 1101:static LogicalResult verifyAccessChain(Op accessChainOp, ValueRange indices) {
    #####: 1102:  auto resultType = getElementPtrType(accessChainOp.getBasePtr().getType(),
        -: 1103:                                      indices, accessChainOp.getLoc());
    #####: 1104:  if (!resultType)
    #####: 1105:    return failure();
        -: 1106:
    #####: 1107:  auto providedResultType =
    #####: 1108:      accessChainOp.getType().template dyn_cast<spirv::PointerType>();
    #####: 1109:  if (!providedResultType)
        -: 1110:    return accessChainOp.emitOpError(
        -: 1111:               "result type must be a pointer, but provided")
    #####: 1112:           << providedResultType;
        -: 1113:
    #####: 1114:  if (resultType != providedResultType)
        -: 1115:    return accessChainOp.emitOpError("invalid result type: expected ")
    #####: 1116:           << resultType << ", but provided " << providedResultType;
        -: 1117:
    #####: 1118:  return success();
        -: 1119:}
------------------
_Z17verifyAccessChainIN4mlir5spirv16PtrAccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE:
function _Z17verifyAccessChainIN4mlir5spirv16PtrAccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1101:static LogicalResult verifyAccessChain(Op accessChainOp, ValueRange indices) {
    #####: 1102:  auto resultType = getElementPtrType(accessChainOp.getBasePtr().getType(),
call    0 never executed
call    1 never executed
        -: 1103:                                      indices, accessChainOp.getLoc());
    #####: 1104:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 1105:    return failure();
        -: 1106:
    #####: 1107:  auto providedResultType =
    #####: 1108:      accessChainOp.getType().template dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 1109:  if (!providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1110:    return accessChainOp.emitOpError(
        -: 1111:               "result type must be a pointer, but provided")
    #####: 1112:           << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1113:
    #####: 1114:  if (resultType != providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1115:    return accessChainOp.emitOpError("invalid result type: expected ")
    #####: 1116:           << resultType << ", but provided " << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 1117:
    #####: 1118:  return success();
        -: 1119:}
------------------
_Z17verifyAccessChainIN4mlir5spirv24InBoundsPtrAccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE:
function _Z17verifyAccessChainIN4mlir5spirv24InBoundsPtrAccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1101:static LogicalResult verifyAccessChain(Op accessChainOp, ValueRange indices) {
    #####: 1102:  auto resultType = getElementPtrType(accessChainOp.getBasePtr().getType(),
call    0 never executed
call    1 never executed
        -: 1103:                                      indices, accessChainOp.getLoc());
    #####: 1104:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 1105:    return failure();
        -: 1106:
    #####: 1107:  auto providedResultType =
    #####: 1108:      accessChainOp.getType().template dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 1109:  if (!providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1110:    return accessChainOp.emitOpError(
        -: 1111:               "result type must be a pointer, but provided")
    #####: 1112:           << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1113:
    #####: 1114:  if (resultType != providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1115:    return accessChainOp.emitOpError("invalid result type: expected ")
    #####: 1116:           << resultType << ", but provided " << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 1117:
    #####: 1118:  return success();
        -: 1119:}
------------------
_Z17verifyAccessChainIN4mlir5spirv13AccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE:
function _Z17verifyAccessChainIN4mlir5spirv13AccessChainOpEENS0_13LogicalResultET_NS0_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1101:static LogicalResult verifyAccessChain(Op accessChainOp, ValueRange indices) {
    #####: 1102:  auto resultType = getElementPtrType(accessChainOp.getBasePtr().getType(),
call    0 never executed
call    1 never executed
        -: 1103:                                      indices, accessChainOp.getLoc());
    #####: 1104:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 1105:    return failure();
        -: 1106:
    #####: 1107:  auto providedResultType =
    #####: 1108:      accessChainOp.getType().template dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 1109:  if (!providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1110:    return accessChainOp.emitOpError(
        -: 1111:               "result type must be a pointer, but provided")
    #####: 1112:           << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1113:
    #####: 1114:  if (resultType != providedResultType)
branch  0 never executed
branch  1 never executed
        -: 1115:    return accessChainOp.emitOpError("invalid result type: expected ")
    #####: 1116:           << resultType << ", but provided " << providedResultType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -: 1117:
    #####: 1118:  return success();
        -: 1119:}
------------------
        -: 1120:
function _ZN4mlir5spirv13AccessChainOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1121:LogicalResult spirv::AccessChainOp::verify() {
    #####: 1122:  return verifyAccessChain(*this, getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1123:}
        -: 1124:
        -: 1125://===----------------------------------------------------------------------===//
        -: 1126:// spirv.mlir.addressof
        -: 1127://===----------------------------------------------------------------------===//
        -: 1128:
function _ZN4mlir5spirv11AddressOfOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_16GlobalVariableOpE called 0 returned 0% blocks executed 0%
    #####: 1129:void spirv::AddressOfOp::build(OpBuilder &builder, OperationState &state,
        -: 1130:                               spirv::GlobalVariableOp var) {
    #####: 1131:  build(builder, state, var.getType(), SymbolRefAttr::get(var));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1132:}
        -: 1133:
function _ZN4mlir5spirv11AddressOfOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1134:LogicalResult spirv::AddressOfOp::verify() {
    #####: 1135:  auto varOp = dyn_cast_or_null<spirv::GlobalVariableOp>(
        -: 1136:      SymbolTable::lookupNearestSymbolFrom((*this)->getParentOp(),
    #####: 1137:                                           getVariableAttr()));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1138:  if (!varOp) {
branch  0 never executed
branch  1 never executed
    #####: 1139:    return emitOpError("expected spirv.GlobalVariable symbol");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1140:  }
    #####: 1141:  if (getPointer().getType() != varOp.getType()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1142:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1143:        "result type mismatch with the referenced global variable's type");
call    0 never executed
        -: 1144:  }
    #####: 1145:  return success();
        -: 1146:}
        -: 1147:
        -: 1148:template <typename T>
    #####: 1149:static void printAtomicCompareExchangeImpl(T atomOp, OpAsmPrinter &printer) {
    #####: 1150:  printer << " \"" << stringifyScope(atomOp.getMemoryScope()) << "\" \""
    #####: 1151:          << stringifyMemorySemantics(atomOp.getEqualSemantics()) << "\" \""
    #####: 1152:          << stringifyMemorySemantics(atomOp.getUnequalSemantics()) << "\" "
    #####: 1153:          << atomOp.getOperands() << " : " << atomOp.getPointer().getType();
    #####: 1154:}
------------------
_Z30printAtomicCompareExchangeImplIN4mlir5spirv27AtomicCompareExchangeWeakOpEEvT_RNS0_12OpAsmPrinterE:
function _Z30printAtomicCompareExchangeImplIN4mlir5spirv27AtomicCompareExchangeWeakOpEEvT_RNS0_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1149:static void printAtomicCompareExchangeImpl(T atomOp, OpAsmPrinter &printer) {
call    0 never executed
    #####: 1150:  printer << " \"" << stringifyScope(atomOp.getMemoryScope()) << "\" \""
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1151:          << stringifyMemorySemantics(atomOp.getEqualSemantics()) << "\" \""
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1152:          << stringifyMemorySemantics(atomOp.getUnequalSemantics()) << "\" "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1153:          << atomOp.getOperands() << " : " << atomOp.getPointer().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1154:}
------------------
_Z30printAtomicCompareExchangeImplIN4mlir5spirv23AtomicCompareExchangeOpEEvT_RNS0_12OpAsmPrinterE:
function _Z30printAtomicCompareExchangeImplIN4mlir5spirv23AtomicCompareExchangeOpEEvT_RNS0_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1149:static void printAtomicCompareExchangeImpl(T atomOp, OpAsmPrinter &printer) {
call    0 never executed
    #####: 1150:  printer << " \"" << stringifyScope(atomOp.getMemoryScope()) << "\" \""
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1151:          << stringifyMemorySemantics(atomOp.getEqualSemantics()) << "\" \""
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1152:          << stringifyMemorySemantics(atomOp.getUnequalSemantics()) << "\" "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1153:          << atomOp.getOperands() << " : " << atomOp.getPointer().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1154:}
------------------
        -: 1155:
function _ZL30parseAtomicCompareExchangeImplRN4mlir11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1156:static ParseResult parseAtomicCompareExchangeImpl(OpAsmParser &parser,
        -: 1157:                                                  OperationState &state) {
    #####: 1158:  spirv::Scope memoryScope;
    #####: 1159:  spirv::MemorySemantics equalSemantics, unequalSemantics;
    #####: 1160:  SmallVector<OpAsmParser::UnresolvedOperand, 3> operandInfo;
call    0 never executed
    #####: 1161:  Type type;
    #####: 1162:  if (parseEnumStrAttr<spirv::ScopeAttr>(memoryScope, parser, state,
call    0 never executed
    #####: 1163:                                         kMemoryScopeAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1164:      parseEnumStrAttr<spirv::MemorySemanticsAttr>(
    #####: 1165:          equalSemantics, parser, state, kEqualSemanticsAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1166:      parseEnumStrAttr<spirv::MemorySemanticsAttr>(
    #####: 1167:          unequalSemantics, parser, state, kUnequalSemanticsAttrName) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1168:      parser.parseOperandList(operandInfo, 3))
branch  0 never executed
branch  1 never executed
    #####: 1169:    return failure();
        -: 1170:
    #####: 1171:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 1172:  if (parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1173:    return failure();
        -: 1174:
    #####: 1175:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 1176:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 1177:    return parser.emitError(loc, "expected pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1178:
    #####: 1179:  if (parser.resolveOperands(
branch  0 never executed
branch  1 never executed
        -: 1180:          operandInfo,
    #####: 1181:          {ptrType, ptrType.getPointeeType(), ptrType.getPointeeType()},
call    0 never executed
    #####: 1182:          parser.getNameLoc(), state.operands))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1183:    return failure();
        -: 1184:
    #####: 1185:  return parser.addTypeToList(ptrType.getPointeeType(), state.types);
call    0 never executed
call    1 never executed
        -: 1186:}
        -: 1187:
        -: 1188:template <typename T>
    #####: 1189:static LogicalResult verifyAtomicCompareExchangeImpl(T atomOp) {
        -: 1190:  // According to the spec:
        -: 1191:  // "The type of Value must be the same as Result Type. The type of the value
        -: 1192:  // pointed to by Pointer must be the same as Result Type. This type must also
        -: 1193:  // match the type of Comparator."
    #####: 1194:  if (atomOp.getType() != atomOp.getValue().getType())
        -: 1195:    return atomOp.emitOpError("value operand must have the same type as the op "
        -: 1196:                              "result, but found ")
    #####: 1197:           << atomOp.getValue().getType() << " vs " << atomOp.getType();
        -: 1198:
    #####: 1199:  if (atomOp.getType() != atomOp.getComparator().getType())
        -: 1200:    return atomOp.emitOpError(
        -: 1201:               "comparator operand must have the same type as the op "
        -: 1202:               "result, but found ")
    #####: 1203:           << atomOp.getComparator().getType() << " vs " << atomOp.getType();
        -: 1204:
    #####: 1205:  Type pointeeType = atomOp.getPointer()
    #####: 1206:                         .getType()
    #####: 1207:                         .template cast<spirv::PointerType>()
    #####: 1208:                         .getPointeeType();
    #####: 1209:  if (atomOp.getType() != pointeeType)
        -: 1210:    return atomOp.emitOpError(
        -: 1211:               "pointer operand's pointee type must have the same "
        -: 1212:               "as the op result type, but found ")
    #####: 1213:           << pointeeType << " vs " << atomOp.getType();
        -: 1214:
        -: 1215:  // TODO: Unequal cannot be set to Release or Acquire and Release.
        -: 1216:  // In addition, Unequal cannot be set to a stronger memory-order then Equal.
        -: 1217:
    #####: 1218:  return success();
        -: 1219:}
------------------
_Z31verifyAtomicCompareExchangeImplIN4mlir5spirv27AtomicCompareExchangeWeakOpEENS0_13LogicalResultET_:
function _Z31verifyAtomicCompareExchangeImplIN4mlir5spirv27AtomicCompareExchangeWeakOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 1189:static LogicalResult verifyAtomicCompareExchangeImpl(T atomOp) {
        -: 1190:  // According to the spec:
        -: 1191:  // "The type of Value must be the same as Result Type. The type of the value
        -: 1192:  // pointed to by Pointer must be the same as Result Type. This type must also
        -: 1193:  // match the type of Comparator."
    #####: 1194:  if (atomOp.getType() != atomOp.getValue().getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1195:    return atomOp.emitOpError("value operand must have the same type as the op "
        -: 1196:                              "result, but found ")
    #####: 1197:           << atomOp.getValue().getType() << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1198:
    #####: 1199:  if (atomOp.getType() != atomOp.getComparator().getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1200:    return atomOp.emitOpError(
        -: 1201:               "comparator operand must have the same type as the op "
        -: 1202:               "result, but found ")
    #####: 1203:           << atomOp.getComparator().getType() << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1204:
    #####: 1205:  Type pointeeType = atomOp.getPointer()
    #####: 1206:                         .getType()
    #####: 1207:                         .template cast<spirv::PointerType>()
call    0 never executed
    #####: 1208:                         .getPointeeType();
call    0 never executed
call    1 never executed
    #####: 1209:  if (atomOp.getType() != pointeeType)
branch  0 never executed
branch  1 never executed
        -: 1210:    return atomOp.emitOpError(
        -: 1211:               "pointer operand's pointee type must have the same "
        -: 1212:               "as the op result type, but found ")
    #####: 1213:           << pointeeType << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1214:
        -: 1215:  // TODO: Unequal cannot be set to Release or Acquire and Release.
        -: 1216:  // In addition, Unequal cannot be set to a stronger memory-order then Equal.
        -: 1217:
    #####: 1218:  return success();
        -: 1219:}
------------------
_Z31verifyAtomicCompareExchangeImplIN4mlir5spirv23AtomicCompareExchangeOpEENS0_13LogicalResultET_:
function _Z31verifyAtomicCompareExchangeImplIN4mlir5spirv23AtomicCompareExchangeOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 1189:static LogicalResult verifyAtomicCompareExchangeImpl(T atomOp) {
        -: 1190:  // According to the spec:
        -: 1191:  // "The type of Value must be the same as Result Type. The type of the value
        -: 1192:  // pointed to by Pointer must be the same as Result Type. This type must also
        -: 1193:  // match the type of Comparator."
    #####: 1194:  if (atomOp.getType() != atomOp.getValue().getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1195:    return atomOp.emitOpError("value operand must have the same type as the op "
        -: 1196:                              "result, but found ")
    #####: 1197:           << atomOp.getValue().getType() << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1198:
    #####: 1199:  if (atomOp.getType() != atomOp.getComparator().getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1200:    return atomOp.emitOpError(
        -: 1201:               "comparator operand must have the same type as the op "
        -: 1202:               "result, but found ")
    #####: 1203:           << atomOp.getComparator().getType() << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1204:
    #####: 1205:  Type pointeeType = atomOp.getPointer()
    #####: 1206:                         .getType()
    #####: 1207:                         .template cast<spirv::PointerType>()
call    0 never executed
    #####: 1208:                         .getPointeeType();
call    0 never executed
call    1 never executed
    #####: 1209:  if (atomOp.getType() != pointeeType)
branch  0 never executed
branch  1 never executed
        -: 1210:    return atomOp.emitOpError(
        -: 1211:               "pointer operand's pointee type must have the same "
        -: 1212:               "as the op result type, but found ")
    #####: 1213:           << pointeeType << " vs " << atomOp.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1214:
        -: 1215:  // TODO: Unequal cannot be set to Release or Acquire and Release.
        -: 1216:  // In addition, Unequal cannot be set to a stronger memory-order then Equal.
        -: 1217:
    #####: 1218:  return success();
        -: 1219:}
------------------
        -: 1220:
        -: 1221://===----------------------------------------------------------------------===//
        -: 1222:// spirv.AtomicAndOp
        -: 1223://===----------------------------------------------------------------------===//
        -: 1224:
function _ZN4mlir5spirv11AtomicAndOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1225:LogicalResult spirv::AtomicAndOp::verify() {
    #####: 1226:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1227:}
        -: 1228:
function _ZN4mlir5spirv11AtomicAndOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1229:ParseResult spirv::AtomicAndOp::parse(OpAsmParser &parser,
        -: 1230:                                      OperationState &result) {
    #####: 1231:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1232:}
function _ZN4mlir5spirv11AtomicAndOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1233:void spirv::AtomicAndOp::print(OpAsmPrinter &p) {
    #####: 1234:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1235:}
        -: 1236:
        -: 1237://===----------------------------------------------------------------------===//
        -: 1238:// spirv.AtomicCompareExchangeOp
        -: 1239://===----------------------------------------------------------------------===//
        -: 1240:
function _ZN4mlir5spirv23AtomicCompareExchangeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1241:LogicalResult spirv::AtomicCompareExchangeOp::verify() {
    #####: 1242:  return ::verifyAtomicCompareExchangeImpl(*this);
call    0 never executed
call    1 never executed
        -: 1243:}
        -: 1244:
function _ZN4mlir5spirv23AtomicCompareExchangeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1245:ParseResult spirv::AtomicCompareExchangeOp::parse(OpAsmParser &parser,
        -: 1246:                                                  OperationState &result) {
    #####: 1247:  return ::parseAtomicCompareExchangeImpl(parser, result);
call    0 never executed
        -: 1248:}
function _ZN4mlir5spirv23AtomicCompareExchangeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1249:void spirv::AtomicCompareExchangeOp::print(OpAsmPrinter &p) {
    #####: 1250:  ::printAtomicCompareExchangeImpl(*this, p);
call    0 never executed
    #####: 1251:}
        -: 1252:
        -: 1253://===----------------------------------------------------------------------===//
        -: 1254:// spirv.AtomicCompareExchangeWeakOp
        -: 1255://===----------------------------------------------------------------------===//
        -: 1256:
function _ZN4mlir5spirv27AtomicCompareExchangeWeakOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1257:LogicalResult spirv::AtomicCompareExchangeWeakOp::verify() {
    #####: 1258:  return ::verifyAtomicCompareExchangeImpl(*this);
call    0 never executed
call    1 never executed
        -: 1259:}
        -: 1260:
function _ZN4mlir5spirv27AtomicCompareExchangeWeakOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1261:ParseResult spirv::AtomicCompareExchangeWeakOp::parse(OpAsmParser &parser,
        -: 1262:                                                      OperationState &result) {
    #####: 1263:  return ::parseAtomicCompareExchangeImpl(parser, result);
call    0 never executed
        -: 1264:}
function _ZN4mlir5spirv27AtomicCompareExchangeWeakOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1265:void spirv::AtomicCompareExchangeWeakOp::print(OpAsmPrinter &p) {
    #####: 1266:  ::printAtomicCompareExchangeImpl(*this, p);
call    0 never executed
    #####: 1267:}
        -: 1268:
        -: 1269://===----------------------------------------------------------------------===//
        -: 1270:// spirv.AtomicExchange
        -: 1271://===----------------------------------------------------------------------===//
        -: 1272:
function _ZN4mlir5spirv16AtomicExchangeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1273:void spirv::AtomicExchangeOp::print(OpAsmPrinter &printer) {
    #####: 1274:  printer << " \"" << stringifyScope(getMemoryScope()) << "\" \""
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1275:          << stringifyMemorySemantics(getSemantics()) << "\" " << getOperands()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1276:          << " : " << getPointer().getType();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1277:}
        -: 1278:
function _ZN4mlir5spirv16AtomicExchangeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1279:ParseResult spirv::AtomicExchangeOp::parse(OpAsmParser &parser,
        -: 1280:                                           OperationState &result) {
    #####: 1281:  spirv::Scope memoryScope;
    #####: 1282:  spirv::MemorySemantics semantics;
    #####: 1283:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandInfo;
call    0 never executed
    #####: 1284:  Type type;
    #####: 1285:  if (parseEnumStrAttr<spirv::ScopeAttr>(memoryScope, parser, result,
call    0 never executed
    #####: 1286:                                         kMemoryScopeAttrName) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1287:      parseEnumStrAttr<spirv::MemorySemanticsAttr>(semantics, parser, result,
    #####: 1288:                                                   kSemanticsAttrName) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1289:      parser.parseOperandList(operandInfo, 2))
branch  0 never executed
branch  1 never executed
    #####: 1290:    return failure();
        -: 1291:
    #####: 1292:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 1293:  if (parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1294:    return failure();
        -: 1295:
    #####: 1296:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 1297:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 1298:    return parser.emitError(loc, "expected pointer type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1299:
    #####: 1300:  if (parser.resolveOperands(operandInfo, {ptrType, ptrType.getPointeeType()},
branch  0 never executed
branch  1 never executed
    #####: 1301:                             parser.getNameLoc(), result.operands))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1302:    return failure();
        -: 1303:
    #####: 1304:  return parser.addTypeToList(ptrType.getPointeeType(), result.types);
call    0 never executed
call    1 never executed
        -: 1305:}
        -: 1306:
function _ZN4mlir5spirv16AtomicExchangeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1307:LogicalResult spirv::AtomicExchangeOp::verify() {
    #####: 1308:  if (getType() != getValue().getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1309:    return emitOpError("value operand must have the same type as the op "
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1310:                       "result, but found ")
    #####: 1311:           << getValue().getType() << " vs " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1312:
    #####: 1313:  Type pointeeType =
call    0 never executed
    #####: 1314:      getPointer().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
    #####: 1315:  if (getType() != pointeeType)
branch  0 never executed
branch  1 never executed
    #####: 1316:    return emitOpError("pointer operand's pointee type must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1317:                       "as the op result type, but found ")
    #####: 1318:           << pointeeType << " vs " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1319:
    #####: 1320:  return success();
        -: 1321:}
        -: 1322:
        -: 1323://===----------------------------------------------------------------------===//
        -: 1324:// spirv.AtomicIAddOp
        -: 1325://===----------------------------------------------------------------------===//
        -: 1326:
function _ZN4mlir5spirv12AtomicIAddOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1327:LogicalResult spirv::AtomicIAddOp::verify() {
    #####: 1328:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1329:}
        -: 1330:
function _ZN4mlir5spirv12AtomicIAddOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1331:ParseResult spirv::AtomicIAddOp::parse(OpAsmParser &parser,
        -: 1332:                                       OperationState &result) {
    #####: 1333:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1334:}
function _ZN4mlir5spirv12AtomicIAddOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1335:void spirv::AtomicIAddOp::print(OpAsmPrinter &p) {
    #####: 1336:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1337:}
        -: 1338:
        -: 1339://===----------------------------------------------------------------------===//
        -: 1340:// spirv.EXT.AtomicFAddOp
        -: 1341://===----------------------------------------------------------------------===//
        -: 1342:
function _ZN4mlir5spirv15EXTAtomicFAddOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1343:LogicalResult spirv::EXTAtomicFAddOp::verify() {
    #####: 1344:  return ::verifyAtomicUpdateOp<FloatType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1345:}
        -: 1346:
function _ZN4mlir5spirv15EXTAtomicFAddOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1347:ParseResult spirv::EXTAtomicFAddOp::parse(OpAsmParser &parser,
        -: 1348:                                          OperationState &result) {
    #####: 1349:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1350:}
function _ZN4mlir5spirv15EXTAtomicFAddOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1351:void spirv::EXTAtomicFAddOp::print(OpAsmPrinter &p) {
    #####: 1352:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1353:}
        -: 1354:
        -: 1355://===----------------------------------------------------------------------===//
        -: 1356:// spirv.AtomicIDecrementOp
        -: 1357://===----------------------------------------------------------------------===//
        -: 1358:
function _ZN4mlir5spirv18AtomicIDecrementOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1359:LogicalResult spirv::AtomicIDecrementOp::verify() {
    #####: 1360:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1361:}
        -: 1362:
function _ZN4mlir5spirv18AtomicIDecrementOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1363:ParseResult spirv::AtomicIDecrementOp::parse(OpAsmParser &parser,
        -: 1364:                                             OperationState &result) {
    #####: 1365:  return ::parseAtomicUpdateOp(parser, result, false);
call    0 never executed
        -: 1366:}
function _ZN4mlir5spirv18AtomicIDecrementOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1367:void spirv::AtomicIDecrementOp::print(OpAsmPrinter &p) {
    #####: 1368:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1369:}
        -: 1370:
        -: 1371://===----------------------------------------------------------------------===//
        -: 1372:// spirv.AtomicIIncrementOp
        -: 1373://===----------------------------------------------------------------------===//
        -: 1374:
function _ZN4mlir5spirv18AtomicIIncrementOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1375:LogicalResult spirv::AtomicIIncrementOp::verify() {
    #####: 1376:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1377:}
        -: 1378:
function _ZN4mlir5spirv18AtomicIIncrementOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1379:ParseResult spirv::AtomicIIncrementOp::parse(OpAsmParser &parser,
        -: 1380:                                             OperationState &result) {
    #####: 1381:  return ::parseAtomicUpdateOp(parser, result, false);
call    0 never executed
        -: 1382:}
function _ZN4mlir5spirv18AtomicIIncrementOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1383:void spirv::AtomicIIncrementOp::print(OpAsmPrinter &p) {
    #####: 1384:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1385:}
        -: 1386:
        -: 1387://===----------------------------------------------------------------------===//
        -: 1388:// spirv.AtomicISubOp
        -: 1389://===----------------------------------------------------------------------===//
        -: 1390:
function _ZN4mlir5spirv12AtomicISubOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1391:LogicalResult spirv::AtomicISubOp::verify() {
    #####: 1392:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1393:}
        -: 1394:
function _ZN4mlir5spirv12AtomicISubOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1395:ParseResult spirv::AtomicISubOp::parse(OpAsmParser &parser,
        -: 1396:                                       OperationState &result) {
    #####: 1397:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1398:}
function _ZN4mlir5spirv12AtomicISubOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1399:void spirv::AtomicISubOp::print(OpAsmPrinter &p) {
    #####: 1400:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1401:}
        -: 1402:
        -: 1403://===----------------------------------------------------------------------===//
        -: 1404:// spirv.AtomicOrOp
        -: 1405://===----------------------------------------------------------------------===//
        -: 1406:
function _ZN4mlir5spirv10AtomicOrOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1407:LogicalResult spirv::AtomicOrOp::verify() {
    #####: 1408:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1409:}
        -: 1410:
function _ZN4mlir5spirv10AtomicOrOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1411:ParseResult spirv::AtomicOrOp::parse(OpAsmParser &parser,
        -: 1412:                                     OperationState &result) {
    #####: 1413:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1414:}
function _ZN4mlir5spirv10AtomicOrOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1415:void spirv::AtomicOrOp::print(OpAsmPrinter &p) {
    #####: 1416:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1417:}
        -: 1418:
        -: 1419://===----------------------------------------------------------------------===//
        -: 1420:// spirv.AtomicSMaxOp
        -: 1421://===----------------------------------------------------------------------===//
        -: 1422:
function _ZN4mlir5spirv12AtomicSMaxOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1423:LogicalResult spirv::AtomicSMaxOp::verify() {
    #####: 1424:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1425:}
        -: 1426:
function _ZN4mlir5spirv12AtomicSMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1427:ParseResult spirv::AtomicSMaxOp::parse(OpAsmParser &parser,
        -: 1428:                                       OperationState &result) {
    #####: 1429:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1430:}
function _ZN4mlir5spirv12AtomicSMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1431:void spirv::AtomicSMaxOp::print(OpAsmPrinter &p) {
    #####: 1432:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1433:}
        -: 1434:
        -: 1435://===----------------------------------------------------------------------===//
        -: 1436:// spirv.AtomicSMinOp
        -: 1437://===----------------------------------------------------------------------===//
        -: 1438:
function _ZN4mlir5spirv12AtomicSMinOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1439:LogicalResult spirv::AtomicSMinOp::verify() {
    #####: 1440:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1441:}
        -: 1442:
function _ZN4mlir5spirv12AtomicSMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1443:ParseResult spirv::AtomicSMinOp::parse(OpAsmParser &parser,
        -: 1444:                                       OperationState &result) {
    #####: 1445:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1446:}
function _ZN4mlir5spirv12AtomicSMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1447:void spirv::AtomicSMinOp::print(OpAsmPrinter &p) {
    #####: 1448:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1449:}
        -: 1450:
        -: 1451://===----------------------------------------------------------------------===//
        -: 1452:// spirv.AtomicUMaxOp
        -: 1453://===----------------------------------------------------------------------===//
        -: 1454:
function _ZN4mlir5spirv12AtomicUMaxOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1455:LogicalResult spirv::AtomicUMaxOp::verify() {
    #####: 1456:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1457:}
        -: 1458:
function _ZN4mlir5spirv12AtomicUMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1459:ParseResult spirv::AtomicUMaxOp::parse(OpAsmParser &parser,
        -: 1460:                                       OperationState &result) {
    #####: 1461:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1462:}
function _ZN4mlir5spirv12AtomicUMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1463:void spirv::AtomicUMaxOp::print(OpAsmPrinter &p) {
    #####: 1464:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1465:}
        -: 1466:
        -: 1467://===----------------------------------------------------------------------===//
        -: 1468:// spirv.AtomicUMinOp
        -: 1469://===----------------------------------------------------------------------===//
        -: 1470:
function _ZN4mlir5spirv12AtomicUMinOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1471:LogicalResult spirv::AtomicUMinOp::verify() {
    #####: 1472:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1473:}
        -: 1474:
function _ZN4mlir5spirv12AtomicUMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1475:ParseResult spirv::AtomicUMinOp::parse(OpAsmParser &parser,
        -: 1476:                                       OperationState &result) {
    #####: 1477:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1478:}
function _ZN4mlir5spirv12AtomicUMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1479:void spirv::AtomicUMinOp::print(OpAsmPrinter &p) {
    #####: 1480:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1481:}
        -: 1482:
        -: 1483://===----------------------------------------------------------------------===//
        -: 1484:// spirv.AtomicXorOp
        -: 1485://===----------------------------------------------------------------------===//
        -: 1486:
function _ZN4mlir5spirv11AtomicXorOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1487:LogicalResult spirv::AtomicXorOp::verify() {
    #####: 1488:  return ::verifyAtomicUpdateOp<IntegerType>(getOperation());
call    0 never executed
call    1 never executed
        -: 1489:}
        -: 1490:
function _ZN4mlir5spirv11AtomicXorOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1491:ParseResult spirv::AtomicXorOp::parse(OpAsmParser &parser,
        -: 1492:                                      OperationState &result) {
    #####: 1493:  return ::parseAtomicUpdateOp(parser, result, true);
call    0 never executed
        -: 1494:}
function _ZN4mlir5spirv11AtomicXorOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1495:void spirv::AtomicXorOp::print(OpAsmPrinter &p) {
    #####: 1496:  ::printAtomicUpdateOp(*this, p);
call    0 never executed
    #####: 1497:}
        -: 1498:
        -: 1499://===----------------------------------------------------------------------===//
        -: 1500:// spirv.BitcastOp
        -: 1501://===----------------------------------------------------------------------===//
        -: 1502:
function _ZN4mlir5spirv9BitcastOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1503:LogicalResult spirv::BitcastOp::verify() {
        -: 1504:  // TODO: The SPIR-V spec validation rules are different for different
        -: 1505:  // versions.
    #####: 1506:  auto operandType = getOperand().getType();
call    0 never executed
call    1 never executed
    #####: 1507:  auto resultType = getResult().getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1508:  if (operandType == resultType) {
branch  0 never executed
branch  1 never executed
    #####: 1509:    return emitError("result type must be different from operand type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1510:  }
    #####: 1511:  if (operandType.isa<spirv::PointerType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1512:      !resultType.isa<spirv::PointerType>()) {
branch  0 never executed
branch  1 never executed
    #####: 1513:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1514:        "unhandled bit cast conversion from pointer type to non-pointer type");
call    0 never executed
        -: 1515:  }
    #####: 1516:  if (!operandType.isa<spirv::PointerType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1517:      resultType.isa<spirv::PointerType>()) {
branch  0 never executed
branch  1 never executed
    #####: 1518:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1519:        "unhandled bit cast conversion from non-pointer type to pointer type");
call    0 never executed
        -: 1520:  }
    #####: 1521:  auto operandBitWidth = getBitWidth(operandType);
call    0 never executed
    #####: 1522:  auto resultBitWidth = getBitWidth(resultType);
call    0 never executed
    #####: 1523:  if (operandBitWidth != resultBitWidth) {
branch  0 never executed
branch  1 never executed
    #####: 1524:    return emitOpError("mismatch in result type bitwidth ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1525:           << resultBitWidth << " and operand type bitwidth "
call    0 never executed
call    1 never executed
    #####: 1526:           << operandBitWidth;
call    0 never executed
        -: 1527:  }
    #####: 1528:  return success();
        -: 1529:}
        -: 1530:
        -: 1531://===----------------------------------------------------------------------===//
        -: 1532:// spirv.PtrCastToGenericOp
        -: 1533://===----------------------------------------------------------------------===//
        -: 1534:
function _ZN4mlir5spirv18PtrCastToGenericOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1535:LogicalResult spirv::PtrCastToGenericOp::verify() {
    #####: 1536:  auto operandType = getPointer().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####: 1537:  auto resultType = getResult().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
        -: 1538:
    #####: 1539:  spirv::StorageClass operandStorage = operandType.getStorageClass();
call    0 never executed
    #####: 1540:  if (operandStorage != spirv::StorageClass::Workgroup &&
    #####: 1541:      operandStorage != spirv::StorageClass::CrossWorkgroup &&
    #####: 1542:      operandStorage != spirv::StorageClass::Function)
branch  0 never executed
branch  1 never executed
    #####: 1543:    return emitError("pointer must point to the Workgroup, CrossWorkgroup"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1544:                     ", or Function Storage Class");
call    0 never executed
        -: 1545:
    #####: 1546:  spirv::StorageClass resultStorage = resultType.getStorageClass();
call    0 never executed
    #####: 1547:  if (resultStorage != spirv::StorageClass::Generic)
branch  0 never executed
branch  1 never executed
    #####: 1548:    return emitError("result type must be of storage class Generic");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1549:
    #####: 1550:  Type operandPointeeType = operandType.getPointeeType();
call    0 never executed
    #####: 1551:  Type resultPointeeType = resultType.getPointeeType();
call    0 never executed
    #####: 1552:  if (operandPointeeType != resultPointeeType)
branch  0 never executed
branch  1 never executed
    #####: 1553:    return emitOpError("pointer operand's pointee type must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1554:                       "as the op result type, but found ")
    #####: 1555:           << operandPointeeType << " vs " << resultPointeeType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1556:  return success();
        -: 1557:}
        -: 1558:
        -: 1559://===----------------------------------------------------------------------===//
        -: 1560:// spirv.GenericCastToPtrOp
        -: 1561://===----------------------------------------------------------------------===//
        -: 1562:
function _ZN4mlir5spirv18GenericCastToPtrOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1563:LogicalResult spirv::GenericCastToPtrOp::verify() {
    #####: 1564:  auto operandType = getPointer().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####: 1565:  auto resultType = getResult().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
        -: 1566:
    #####: 1567:  spirv::StorageClass operandStorage = operandType.getStorageClass();
call    0 never executed
    #####: 1568:  if (operandStorage != spirv::StorageClass::Generic)
branch  0 never executed
branch  1 never executed
    #####: 1569:    return emitError("pointer type must be of storage class Generic");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1570:
    #####: 1571:  spirv::StorageClass resultStorage = resultType.getStorageClass();
call    0 never executed
    #####: 1572:  if (resultStorage != spirv::StorageClass::Workgroup &&
    #####: 1573:      resultStorage != spirv::StorageClass::CrossWorkgroup &&
    #####: 1574:      resultStorage != spirv::StorageClass::Function)
branch  0 never executed
branch  1 never executed
    #####: 1575:    return emitError("result must point to the Workgroup, CrossWorkgroup, "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1576:                     "or Function Storage Class");
call    0 never executed
        -: 1577:
    #####: 1578:  Type operandPointeeType = operandType.getPointeeType();
call    0 never executed
    #####: 1579:  Type resultPointeeType = resultType.getPointeeType();
call    0 never executed
    #####: 1580:  if (operandPointeeType != resultPointeeType)
branch  0 never executed
branch  1 never executed
    #####: 1581:    return emitOpError("pointer operand's pointee type must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1582:                       "as the op result type, but found ")
    #####: 1583:           << operandPointeeType << " vs " << resultPointeeType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1584:  return success();
        -: 1585:}
        -: 1586:
        -: 1587://===----------------------------------------------------------------------===//
        -: 1588:// spirv.GenericCastToPtrExplicitOp
        -: 1589://===----------------------------------------------------------------------===//
        -: 1590:
function _ZN4mlir5spirv26GenericCastToPtrExplicitOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1591:LogicalResult spirv::GenericCastToPtrExplicitOp::verify() {
    #####: 1592:  auto operandType = getPointer().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####: 1593:  auto resultType = getResult().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
        -: 1594:
    #####: 1595:  spirv::StorageClass operandStorage = operandType.getStorageClass();
call    0 never executed
    #####: 1596:  if (operandStorage != spirv::StorageClass::Generic)
branch  0 never executed
branch  1 never executed
    #####: 1597:    return emitError("pointer type must be of storage class Generic");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1598:
    #####: 1599:  spirv::StorageClass resultStorage = resultType.getStorageClass();
call    0 never executed
    #####: 1600:  if (resultStorage != spirv::StorageClass::Workgroup &&
    #####: 1601:      resultStorage != spirv::StorageClass::CrossWorkgroup &&
    #####: 1602:      resultStorage != spirv::StorageClass::Function)
branch  0 never executed
branch  1 never executed
    #####: 1603:    return emitError("result must point to the Workgroup, CrossWorkgroup, "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1604:                     "or Function Storage Class");
call    0 never executed
        -: 1605:
    #####: 1606:  Type operandPointeeType = operandType.getPointeeType();
call    0 never executed
    #####: 1607:  Type resultPointeeType = resultType.getPointeeType();
call    0 never executed
    #####: 1608:  if (operandPointeeType != resultPointeeType)
branch  0 never executed
branch  1 never executed
    #####: 1609:    return emitOpError("pointer operand's pointee type must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1610:                       "as the op result type, but found ")
    #####: 1611:           << operandPointeeType << " vs " << resultPointeeType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1612:  return success();
        -: 1613:}
        -: 1614:
        -: 1615://===----------------------------------------------------------------------===//
        -: 1616:// spirv.BranchOp
        -: 1617://===----------------------------------------------------------------------===//
        -: 1618:
function _ZN4mlir5spirv8BranchOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####: 1619:SuccessorOperands spirv::BranchOp::getSuccessorOperands(unsigned index) {
    #####: 1620:  assert(index == 0 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1621:  return SuccessorOperands(0, getTargetOperandsMutable());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1622:}
        -: 1623:
        -: 1624://===----------------------------------------------------------------------===//
        -: 1625:// spirv.BranchConditionalOp
        -: 1626://===----------------------------------------------------------------------===//
        -: 1627:
        -: 1628:SuccessorOperands
function _ZN4mlir5spirv19BranchConditionalOp20getSuccessorOperandsEj called 0 returned 0% blocks executed 0%
    #####: 1629:spirv::BranchConditionalOp::getSuccessorOperands(unsigned index) {
    #####: 1630:  assert(index < 2 && "invalid successor index");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1631:  return SuccessorOperands(index == kTrueIndex
    #####: 1632:                               ? getTrueTargetOperandsMutable()
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1633:                               : getFalseTargetOperandsMutable());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1634:}
        -: 1635:
function _ZN4mlir5spirv19BranchConditionalOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1636:ParseResult spirv::BranchConditionalOp::parse(OpAsmParser &parser,
        -: 1637:                                              OperationState &result) {
    #####: 1638:  auto &builder = parser.getBuilder();
call    0 never executed
    #####: 1639:  OpAsmParser::UnresolvedOperand condInfo;
call    0 never executed
    #####: 1640:  Block *dest;
        -: 1641:
        -: 1642:  // Parse the condition.
    #####: 1643:  Type boolTy = builder.getI1Type();
call    0 never executed
    #####: 1644:  if (parser.parseOperand(condInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1645:      parser.resolveOperand(condInfo, boolTy, result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1646:    return failure();
        -: 1647:
        -: 1648:  // Parse the optional branch weights.
    #####: 1649:  if (succeeded(parser.parseOptionalLSquare())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1650:    IntegerAttr trueWeight, falseWeight;
    #####: 1651:    NamedAttrList weights;
call    0 never executed
        -: 1652:
    #####: 1653:    auto i32Type = builder.getIntegerType(32);
call    0 never executed
    #####: 1654:    if (parser.parseAttribute(trueWeight, i32Type, "weight", weights) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1655:        parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1656:        parser.parseAttribute(falseWeight, i32Type, "weight", weights) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1657:        parser.parseRSquare())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1658:      return failure();
branch  0 never executed
branch  1 never executed
        -: 1659:
    #####: 1660:    result.addAttribute(kBranchWeightAttrName,
call    0 never executed
    #####: 1661:                        builder.getArrayAttr({trueWeight, falseWeight}));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1662:  }
        -: 1663:
        -: 1664:  // Parse the true branch.
    #####: 1665:  SmallVector<Value, 4> trueOperands;
call    0 never executed
    #####: 1666:  if (parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1667:      parser.parseSuccessorAndUseList(dest, trueOperands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1668:    return failure();
    #####: 1669:  result.addSuccessors(dest);
call    0 never executed
    #####: 1670:  result.addOperands(trueOperands);
call    0 never executed
call    1 never executed
        -: 1671:
        -: 1672:  // Parse the false branch.
    #####: 1673:  SmallVector<Value, 4> falseOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1674:  if (parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1675:      parser.parseSuccessorAndUseList(dest, falseOperands))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1676:    return failure();
    #####: 1677:  result.addSuccessors(dest);
call    0 never executed
    #####: 1678:  result.addOperands(falseOperands);
call    0 never executed
call    1 never executed
    #####: 1679:  result.addAttribute(spirv::BranchConditionalOp::getOperandSegmentSizeAttr(),
call    0 never executed
    #####: 1680:                      builder.getDenseI32ArrayAttr(
    #####: 1681:                          {1, static_cast<int32_t>(trueOperands.size()),
    #####: 1682:                           static_cast<int32_t>(falseOperands.size())}));
call    0 never executed
        -: 1683:
    #####: 1684:  return success();
        -: 1685:}
        -: 1686:
function _ZN4mlir5spirv19BranchConditionalOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1687:void spirv::BranchConditionalOp::print(OpAsmPrinter &printer) {
    #####: 1688:  printer << ' ' << getCondition();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1689:
    #####: 1690:  if (auto weights = getBranchWeights()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1691:    printer << " [";
call    0 never executed
function _ZZN4mlir5spirv19BranchConditionalOp5printERNS_12OpAsmPrinterEENKUlNS_9AttributeEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1692:    llvm::interleaveComma(weights->getValue(), printer, [&](Attribute a) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1693:      printer << a.cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1694:    });
    #####: 1695:    printer << "]";
call    0 never executed
        -: 1696:  }
        -: 1697:
    #####: 1698:  printer << ", ";
call    0 never executed
    #####: 1699:  printer.printSuccessorAndUseList(getTrueBlock(), getTrueBlockArguments());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1700:  printer << ", ";
call    0 never executed
    #####: 1701:  printer.printSuccessorAndUseList(getFalseBlock(), getFalseBlockArguments());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1702:}
        -: 1703:
function _ZN4mlir5spirv19BranchConditionalOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1704:LogicalResult spirv::BranchConditionalOp::verify() {
    #####: 1705:  if (auto weights = getBranchWeights()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1706:    if (weights->getValue().size() != 2) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1707:      return emitOpError("must have exactly two branch weights");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1708:    }
function _ZZN4mlir5spirv19BranchConditionalOp6verifyEvENKUlNS_9AttributeEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1709:    if (llvm::all_of(*weights, [](Attribute attr) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1710:          return attr.cast<IntegerAttr>().getValue().isNullValue();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1711:        }))
    #####: 1712:      return emitOpError("branch weights cannot both be zero");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1713:  }
        -: 1714:
    #####: 1715:  return success();
        -: 1716:}
        -: 1717:
        -: 1718://===----------------------------------------------------------------------===//
        -: 1719:// spirv.CompositeConstruct
        -: 1720://===----------------------------------------------------------------------===//
        -: 1721:
function _ZN4mlir5spirv20CompositeConstructOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1722:LogicalResult spirv::CompositeConstructOp::verify() {
    #####: 1723:  auto cType = getType().cast<spirv::CompositeType>();
call    0 never executed
    #####: 1724:  operand_range constituents = this->getConstituents();
call    0 never executed
        -: 1725:
    #####: 1726:  if (auto coopType = cType.dyn_cast<spirv::CooperativeMatrixNVType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1727:    if (constituents.size() != 1)
branch  0 never executed
branch  1 never executed
    #####: 1728:      return emitOpError("has incorrect number of operands: expected ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1729:             << "1, but provided " << constituents.size();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1730:    if (coopType.getElementType() != constituents.front().getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1731:      return emitOpError("operand type mismatch: expected operand type ")
call    0 never executed
call    1 never executed
    #####: 1732:             << coopType.getElementType() << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1733:             << constituents.front().getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1734:    return success();
        -: 1735:  }
        -: 1736:
    #####: 1737:  if (auto jointType = cType.dyn_cast<spirv::JointMatrixINTELType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1738:    if (constituents.size() != 1)
branch  0 never executed
branch  1 never executed
    #####: 1739:      return emitOpError("has incorrect number of operands: expected ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1740:             << "1, but provided " << constituents.size();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1741:    if (jointType.getElementType() != constituents.front().getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1742:      return emitOpError("operand type mismatch: expected operand type ")
call    0 never executed
call    1 never executed
    #####: 1743:             << jointType.getElementType() << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1744:             << constituents.front().getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1745:    return success();
        -: 1746:  }
        -: 1747:
    #####: 1748:  if (constituents.size() == cType.getNumElements()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1749:    for (auto index : llvm::seq<uint32_t>(0, constituents.size())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1750:      if (constituents[index].getType() != cType.getElementType(index)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1751:        return emitOpError("operand type mismatch: expected operand type ")
call    0 never executed
call    1 never executed
    #####: 1752:               << cType.getElementType(index) << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1753:               << constituents[index].getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1754:      }
        -: 1755:    }
    #####: 1756:    return success();
        -: 1757:  }
        -: 1758:
        -: 1759:  // If not constructing a cooperative matrix type, then we must be constructing
        -: 1760:  // a vector type.
    #####: 1761:  auto resultType = cType.dyn_cast<VectorType>();
call    0 never executed
    #####: 1762:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 1763:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1764:        "expected to return a vector or cooperative matrix when the number of "
    #####: 1765:        "constituents is less than what the result needs");
call    0 never executed
        -: 1766:
    #####: 1767:  SmallVector<unsigned> sizes;
    #####: 1768:  for (Value component : constituents) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1769:    if (!component.getType().isa<VectorType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1770:        !component.getType().isIntOrFloat())
call    0 never executed
    #####: 1771:      return emitOpError("operand type mismatch: expected operand to have "
call    0 never executed
call    1 never executed
        -: 1772:                         "a scalar or vector type, but provided ")
    #####: 1773:             << component.getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1774:
    #####: 1775:    Type elementType = component.getType();
call    0 never executed
    #####: 1776:    if (auto vectorType = component.getType().dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1777:      sizes.push_back(vectorType.getNumElements());
call    0 never executed
call    1 never executed
    #####: 1778:      elementType = vectorType.getElementType();
call    0 never executed
        -: 1779:    } else {
    #####: 1780:      sizes.push_back(1);
call    0 never executed
        -: 1781:    }
        -: 1782:
    #####: 1783:    if (elementType != resultType.getElementType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1784:      return emitOpError("operand element type mismatch: expected to be ")
call    0 never executed
call    1 never executed
    #####: 1785:             << resultType.getElementType() << ", but provided " << elementType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 1786:  }
    #####: 1787:  unsigned totalCount = std::accumulate(sizes.begin(), sizes.end(), 0);
    #####: 1788:  if (totalCount != cType.getNumElements())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1789:    return emitOpError("has incorrect number of operands: expected ")
call    0 never executed
call    1 never executed
    #####: 1790:           << cType.getNumElements() << ", but provided " << totalCount;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1791:  return success();
branch  0 never executed
branch  1 never executed
        -: 1792:}
        -: 1793:
        -: 1794://===----------------------------------------------------------------------===//
        -: 1795:// spirv.CompositeExtractOp
        -: 1796://===----------------------------------------------------------------------===//
        -: 1797:
function _ZN4mlir5spirv18CompositeExtractOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEN4llvm8ArrayRefIiEE called 0 returned 0% blocks executed 0%
    #####: 1798:void spirv::CompositeExtractOp::build(OpBuilder &builder, OperationState &state,
        -: 1799:                                      Value composite,
        -: 1800:                                      ArrayRef<int32_t> indices) {
    #####: 1801:  auto indexAttr = builder.getI32ArrayAttr(indices);
call    0 never executed
    #####: 1802:  auto elementType =
    #####: 1803:      getElementType(composite.getType(), indexAttr, state.location);
call    0 never executed
    #####: 1804:  if (!elementType) {
branch  0 never executed
branch  1 never executed
    #####: 1805:    return;
        -: 1806:  }
    #####: 1807:  build(builder, state, elementType, composite, indexAttr);
call    0 never executed
        -: 1808:}
        -: 1809:
function _ZN4mlir5spirv18CompositeExtractOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1810:ParseResult spirv::CompositeExtractOp::parse(OpAsmParser &parser,
        -: 1811:                                             OperationState &result) {
    #####: 1812:  OpAsmParser::UnresolvedOperand compositeInfo;
call    0 never executed
    #####: 1813:  Attribute indicesAttr;
    #####: 1814:  Type compositeType;
    #####: 1815:  SMLoc attrLocation;
        -: 1816:
    #####: 1817:  if (parser.parseOperand(compositeInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1818:      parser.getCurrentLocation(&attrLocation) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1819:      parser.parseAttribute(indicesAttr, kIndicesAttrName, result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1820:      parser.parseColonType(compositeType) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1821:      parser.resolveOperand(compositeInfo, compositeType, result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1822:    return failure();
        -: 1823:  }
        -: 1824:
    #####: 1825:  Type resultType =
call    0 never executed
    #####: 1826:      getElementType(compositeType, indicesAttr, parser, attrLocation);
    #####: 1827:  if (!resultType) {
branch  0 never executed
branch  1 never executed
    #####: 1828:    return failure();
        -: 1829:  }
    #####: 1830:  result.addTypes(resultType);
call    0 never executed
    #####: 1831:  return success();
        -: 1832:}
        -: 1833:
function _ZN4mlir5spirv18CompositeExtractOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1834:void spirv::CompositeExtractOp::print(OpAsmPrinter &printer) {
    #####: 1835:  printer << ' ' << getComposite() << getIndices() << " : "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 1836:          << getComposite().getType();
call    0 never executed
    #####: 1837:}
        -: 1838:
function _ZN4mlir5spirv18CompositeExtractOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1839:LogicalResult spirv::CompositeExtractOp::verify() {
    #####: 1840:  auto indicesArrayAttr = getIndices().dyn_cast<ArrayAttr>();
call    0 never executed
call    1 never executed
    #####: 1841:  auto resultType =
    #####: 1842:      getElementType(getComposite().getType(), indicesArrayAttr, getLoc());
call    0 never executed
call    1 never executed
    #####: 1843:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 1844:    return failure();
        -: 1845:
    #####: 1846:  if (resultType != getType()) {
branch  0 never executed
branch  1 never executed
    #####: 1847:    return emitOpError("invalid result type: expected ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1848:           << resultType << " but provided " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1849:  }
        -: 1850:
    #####: 1851:  return success();
        -: 1852:}
        -: 1853:
        -: 1854://===----------------------------------------------------------------------===//
        -: 1855:// spirv.CompositeInsert
        -: 1856://===----------------------------------------------------------------------===//
        -: 1857:
function _ZN4mlir5spirv17CompositeInsertOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_N4llvm8ArrayRefIiEE called 0 returned 0% blocks executed 0%
    #####: 1858:void spirv::CompositeInsertOp::build(OpBuilder &builder, OperationState &state,
        -: 1859:                                     Value object, Value composite,
        -: 1860:                                     ArrayRef<int32_t> indices) {
    #####: 1861:  auto indexAttr = builder.getI32ArrayAttr(indices);
call    0 never executed
    #####: 1862:  build(builder, state, composite.getType(), object, composite, indexAttr);
call    0 never executed
    #####: 1863:}
        -: 1864:
function _ZN4mlir5spirv17CompositeInsertOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1865:ParseResult spirv::CompositeInsertOp::parse(OpAsmParser &parser,
        -: 1866:                                            OperationState &result) {
    #####: 1867:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operands;
call    0 never executed
    #####: 1868:  Type objectType, compositeType;
    #####: 1869:  Attribute indicesAttr;
    #####: 1870:  auto loc = parser.getCurrentLocation();
call    0 never executed
        -: 1871:
    #####: 1872:  return failure(
call    0 never executed
    #####: 1873:      parser.parseOperandList(operands, 2) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1874:      parser.parseAttribute(indicesAttr, kIndicesAttrName, result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1875:      parser.parseColonType(objectType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1876:      parser.parseKeywordType("into", compositeType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1877:      parser.resolveOperands(operands, {objectType, compositeType}, loc,
    #####: 1878:                             result.operands) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1879:      parser.addTypesToList(compositeType, result.types));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1880:}
        -: 1881:
function _ZN4mlir5spirv17CompositeInsertOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1882:LogicalResult spirv::CompositeInsertOp::verify() {
    #####: 1883:  auto indicesArrayAttr = getIndices().dyn_cast<ArrayAttr>();
call    0 never executed
call    1 never executed
    #####: 1884:  auto objectType =
    #####: 1885:      getElementType(getComposite().getType(), indicesArrayAttr, getLoc());
call    0 never executed
call    1 never executed
    #####: 1886:  if (!objectType)
branch  0 never executed
branch  1 never executed
    #####: 1887:    return failure();
        -: 1888:
    #####: 1889:  if (objectType != getObject().getType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1890:    return emitOpError("object operand type should be ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1891:           << objectType << ", but found " << getObject().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1892:  }
        -: 1893:
    #####: 1894:  if (getComposite().getType() != getType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1895:    return emitOpError("result type should be the same as "
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1896:                       "the composite type, but found ")
    #####: 1897:           << getComposite().getType() << " vs " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1898:  }
        -: 1899:
    #####: 1900:  return success();
        -: 1901:}
        -: 1902:
function _ZN4mlir5spirv17CompositeInsertOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1903:void spirv::CompositeInsertOp::print(OpAsmPrinter &printer) {
    #####: 1904:  printer << " " << getObject() << ", " << getComposite() << getIndices()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 1905:          << " : " << getObject().getType() << " into "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1906:          << getComposite().getType();
call    0 never executed
    #####: 1907:}
        -: 1908:
        -: 1909://===----------------------------------------------------------------------===//
        -: 1910:// spirv.Constant
        -: 1911://===----------------------------------------------------------------------===//
        -: 1912:
function _ZN4mlir5spirv10ConstantOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1913:ParseResult spirv::ConstantOp::parse(OpAsmParser &parser,
        -: 1914:                                     OperationState &result) {
    #####: 1915:  Attribute value;
    #####: 1916:  if (parser.parseAttribute(value, kValueAttrName, result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1917:    return failure();
        -: 1918:
    #####: 1919:  Type type = NoneType::get(parser.getContext());
call    0 never executed
call    1 never executed
    #####: 1920:  if (auto typedAttr = value.dyn_cast<TypedAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1921:    type = typedAttr.getType();
call    0 never executed
    #####: 1922:  if (type.isa<NoneType, TensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1923:    if (parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1924:      return failure();
        -: 1925:  }
        -: 1926:
    #####: 1927:  return parser.addTypeToList(type, result.types);
call    0 never executed
        -: 1928:}
        -: 1929:
function _ZN4mlir5spirv10ConstantOp5printERNS_12OpAsmPrinterE called 30 returned 100% blocks executed 60%
       30: 1930:void spirv::ConstantOp::print(OpAsmPrinter &printer) {
       30: 1931:  printer << ' ' << getValue();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
       30: 1932:  if (getType().isa<spirv::ArrayType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1933:    printer << " : " << getType();
call    0 never executed
call    1 never executed
       30: 1934:}
        -: 1935:
function _ZL18verifyConstantTypeN4mlir5spirv10ConstantOpENS_9AttributeENS_4TypeE called 156 returned 100% blocks executed 28%
      156: 1936:static LogicalResult verifyConstantType(spirv::ConstantOp op, Attribute value,
        -: 1937:                                        Type opType) {
      156: 1938:  if (value.isa<IntegerAttr, FloatAttr>()) {
call    0 returned 100%
branch  1 taken 87% (fallthrough)
branch  2 taken 13%
      136: 1939:    auto valueType = value.cast<TypedAttr>().getType();
call    0 returned 100%
call    1 returned 100%
      136: 1940:    if (valueType != opType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1941:      return op.emitOpError("result type (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1942:             << opType << ") does not match value type (" << valueType << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      136: 1943:    return success();
        -: 1944:  }
       20: 1945:  if (value.isa<DenseIntOrFPElementsAttr, SparseElementsAttr>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       20: 1946:    auto valueType = value.cast<TypedAttr>().getType();
call    0 returned 100%
call    1 returned 100%
       20: 1947:    if (valueType == opType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1948:      return success();
       20: 1949:    auto arrayType = opType.dyn_cast<spirv::ArrayType>();
call    0 returned 100%
       20: 1950:    auto shapedType = valueType.dyn_cast<ShapedType>();
call    0 returned 100%
       20: 1951:    if (!arrayType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1952:      return op.emitOpError("result or element type (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1953:             << opType << ") does not match value type (" << valueType
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1954:             << "), must be the same or spirv.array";
call    0 never executed
        -: 1955:
       20: 1956:    int numElements = arrayType.getNumElements();
call    0 returned 100%
       20: 1957:    auto opElemType = arrayType.getElementType();
call    0 returned 100%
      20*: 1958:    while (auto t = opElemType.dyn_cast<spirv::ArrayType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1959:      numElements *= t.getNumElements();
call    0 never executed
    #####: 1960:      opElemType = t.getElementType();
call    0 never executed
    #####: 1961:    }
       20: 1962:    if (!opElemType.isIntOrFloat())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1963:      return op.emitOpError("only support nested array result type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1964:
       20: 1965:    auto valueElemType = shapedType.getElementType();
call    0 returned 100%
       20: 1966:    if (valueElemType != opElemType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1967:      return op.emitOpError("result element type (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1968:             << opElemType << ") does not match value element type ("
call    0 never executed
call    1 never executed
    #####: 1969:             << valueElemType << ")";
call    0 never executed
call    1 never executed
        -: 1970:    }
        -: 1971:
       20: 1972:    if (numElements != shapedType.getNumElements()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1973:      return op.emitOpError("result number of elements (")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1974:             << numElements << ") does not match value number of elements ("
call    0 never executed
    #####: 1975:             << shapedType.getNumElements() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1976:    }
       20: 1977:    return success();
        -: 1978:  }
    #####: 1979:  if (auto arrayAttr = value.dyn_cast<ArrayAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1980:    auto arrayType = opType.dyn_cast<spirv::ArrayType>();
call    0 never executed
    #####: 1981:    if (!arrayType)
branch  0 never executed
branch  1 never executed
    #####: 1982:      return op.emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1983:          "must have spirv.array result type for array value");
call    0 never executed
    #####: 1984:    Type elemType = arrayType.getElementType();
call    0 never executed
    #####: 1985:    for (Attribute element : arrayAttr.getValue()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1986:      // Verify array elements recursively.
    #####: 1987:      if (failed(verifyConstantType(op, element, elemType)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1988:        return failure();
        -: 1989:    }
    #####: 1990:    return success();
        -: 1991:  }
    #####: 1992:  return op.emitOpError("cannot have attribute: ") << value;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1993:}
        -: 1994:
function _ZN4mlir5spirv10ConstantOp6verifyEv called 156 returned 100% blocks executed 100%
      156: 1995:LogicalResult spirv::ConstantOp::verify() {
        -: 1996:  // ODS already generates checks to make sure the result type is valid. We just
        -: 1997:  // need to additionally check that the value's attribute type is consistent
        -: 1998:  // with the result type.
      156: 1999:  return verifyConstantType(*this, getValueAttr(), getType());
call    0 returned 100%
call    1 returned 100%
        -: 2000:}
        -: 2001:
function _ZN4mlir5spirv10ConstantOp15isBuildableWithENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2002:bool spirv::ConstantOp::isBuildableWith(Type type) {
        -: 2003:  // Must be valid SPIR-V type first.
    #####: 2004:  if (!type.isa<spirv::SPIRVType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2005:    return false;
        -: 2006:
    #####: 2007:  if (isa<SPIRVDialect>(type.getDialect())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2008:    // TODO: support constant struct
    #####: 2009:    return type.isa<spirv::ArrayType>();
call    0 never executed
        -: 2010:  }
        -: 2011:
        -: 2012:  return true;
        -: 2013:}
        -: 2014:
function _ZN4mlir5spirv10ConstantOp7getZeroENS_4TypeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####: 2015:spirv::ConstantOp spirv::ConstantOp::getZero(Type type, Location loc,
        -: 2016:                                             OpBuilder &builder) {
    #####: 2017:  if (auto intType = type.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2018:    unsigned width = intType.getWidth();
call    0 never executed
    #####: 2019:    if (width == 1)
branch  0 never executed
branch  1 never executed
    #####: 2020:      return builder.create<spirv::ConstantOp>(loc, type,
    #####: 2021:                                               builder.getBoolAttr(false));
call    0 never executed
call    1 never executed
    #####: 2022:    return builder.create<spirv::ConstantOp>(
    #####: 2023:        loc, type, builder.getIntegerAttr(type, APInt(width, 0)));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2024:  }
    #####: 2025:  if (auto floatType = type.dyn_cast<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2026:    return builder.create<spirv::ConstantOp>(
    #####: 2027:        loc, type, builder.getFloatAttr(floatType, 0.0));
call    0 never executed
call    1 never executed
        -: 2028:  }
    #####: 2029:  if (auto vectorType = type.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2030:    Type elemType = vectorType.getElementType();
call    0 never executed
    #####: 2031:    if (elemType.isa<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2032:      return builder.create<spirv::ConstantOp>(
        -: 2033:          loc, type,
    #####: 2034:          DenseElementsAttr::get(vectorType,
    #####: 2035:                                 IntegerAttr::get(elemType, 0.0).getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 2036:    }
    #####: 2037:    if (elemType.isa<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2038:      return builder.create<spirv::ConstantOp>(
        -: 2039:          loc, type,
    #####: 2040:          DenseFPElementsAttr::get(vectorType,
    #####: 2041:                                   FloatAttr::get(elemType, 0.0).getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 2042:    }
        -: 2043:  }
        -: 2044:
    #####: 2045:  llvm_unreachable("unimplemented types for ConstantOp::getZero()");
call    0 never executed
        -: 2046:}
        -: 2047:
function _ZN4mlir5spirv10ConstantOp6getOneENS_4TypeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####: 2048:spirv::ConstantOp spirv::ConstantOp::getOne(Type type, Location loc,
        -: 2049:                                            OpBuilder &builder) {
    #####: 2050:  if (auto intType = type.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2051:    unsigned width = intType.getWidth();
call    0 never executed
    #####: 2052:    if (width == 1)
branch  0 never executed
branch  1 never executed
    #####: 2053:      return builder.create<spirv::ConstantOp>(loc, type,
    #####: 2054:                                               builder.getBoolAttr(true));
call    0 never executed
call    1 never executed
    #####: 2055:    return builder.create<spirv::ConstantOp>(
    #####: 2056:        loc, type, builder.getIntegerAttr(type, APInt(width, 1)));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 2057:  }
    #####: 2058:  if (auto floatType = type.dyn_cast<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2059:    return builder.create<spirv::ConstantOp>(
    #####: 2060:        loc, type, builder.getFloatAttr(floatType, 1.0));
call    0 never executed
call    1 never executed
        -: 2061:  }
    #####: 2062:  if (auto vectorType = type.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2063:    Type elemType = vectorType.getElementType();
call    0 never executed
    #####: 2064:    if (elemType.isa<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2065:      return builder.create<spirv::ConstantOp>(
        -: 2066:          loc, type,
    #####: 2067:          DenseElementsAttr::get(vectorType,
    #####: 2068:                                 IntegerAttr::get(elemType, 1.0).getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 2069:    }
    #####: 2070:    if (elemType.isa<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2071:      return builder.create<spirv::ConstantOp>(
        -: 2072:          loc, type,
    #####: 2073:          DenseFPElementsAttr::get(vectorType,
    #####: 2074:                                   FloatAttr::get(elemType, 1.0).getValue()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 2075:    }
        -: 2076:  }
        -: 2077:
    #####: 2078:  llvm_unreachable("unimplemented types for ConstantOp::getOne()");
call    0 never executed
        -: 2079:}
        -: 2080:
function _ZN4mlir5spirv10ConstantOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 88 returned 100% blocks executed 53%
       88: 2081:void mlir::spirv::ConstantOp::getAsmResultNames(
        -: 2082:    llvm::function_ref<void(mlir::Value, llvm::StringRef)> setNameFn) {
       88: 2083:  Type type = getType();
call    0 returned 100%
        -: 2084:
      176: 2085:  SmallString<32> specialNameBuffer;
call    0 returned 100%
      176: 2086:  llvm::raw_svector_ostream specialName(specialNameBuffer);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       88: 2087:  specialName << "cst";
call    0 returned 100%
        -: 2088:
       88: 2089:  IntegerType intTy = type.dyn_cast<IntegerType>();
call    0 returned 100%
        -: 2090:
       88: 2091:  if (IntegerAttr intCst = getValue().dyn_cast<IntegerAttr>()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 60% (fallthrough)
branch  3 taken 40%
       53: 2092:    if (intTy && intTy.getWidth() == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2093:      return setNameFn(getResult(), (intCst.getInt() ? "true" : "false"));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -: 2094:    }
        -: 2095:
       53: 2096:    if (intTy.isSignless()) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
       53: 2097:      specialName << intCst.getInt();
call    0 returned 100%
call    1 returned 100%
        -: 2098:    } else {
    #####: 2099:      specialName << intCst.getSInt();
call    0 never executed
call    1 never executed
        -: 2100:    }
        -: 2101:  }
        -: 2102:
      123: 2103:  if (intTy || type.isa<FloatType>()) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
branch  2 taken 69% (fallthrough)
branch  3 taken 31%
      154: 2104:    specialName << '_' << type;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -: 2105:  }
        -: 2106:
       88: 2107:  if (auto vecType = type.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2108:    specialName << "_vec_";
call    0 never executed
    #####: 2109:    specialName << vecType.getDimSize(0);
call    0 never executed
call    1 never executed
        -: 2110:
    #####: 2111:    Type elementType = vecType.getElementType();
call    0 never executed
        -: 2112:
    #####: 2113:    if (elementType.isa<IntegerType>() || elementType.isa<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2114:      specialName << "x" << elementType;
call    0 never executed
call    1 never executed
        -: 2115:    }
        -: 2116:  }
        -: 2117:
       88: 2118:  setNameFn(getResult(), specialName.str());
call    0 returned 100%
call    1 returned 100%
        -: 2119:}
        -: 2120:
function _ZN4mlir5spirv11AddressOfOp17getAsmResultNamesEN4llvm12function_refIFvNS_5ValueENS2_9StringRefEEEE called 0 returned 0% blocks executed 0%
    #####: 2121:void mlir::spirv::AddressOfOp::getAsmResultNames(
        -: 2122:    llvm::function_ref<void(mlir::Value, llvm::StringRef)> setNameFn) {
    #####: 2123:  SmallString<32> specialNameBuffer;
call    0 never executed
    #####: 2124:  llvm::raw_svector_ostream specialName(specialNameBuffer);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2125:  specialName << getVariable() << "_addr";
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2126:  setNameFn(getResult(), specialName.str());
call    0 never executed
call    1 never executed
    #####: 2127:}
        -: 2128:
        -: 2129://===----------------------------------------------------------------------===//
        -: 2130:// spirv.ControlBarrierOp
        -: 2131://===----------------------------------------------------------------------===//
        -: 2132:
function _ZN4mlir5spirv16ControlBarrierOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2133:LogicalResult spirv::ControlBarrierOp::verify() {
    #####: 2134:  return verifyMemorySemantics(getOperation(), getMemorySemantics());
call    0 never executed
call    1 never executed
        -: 2135:}
        -: 2136:
        -: 2137://===----------------------------------------------------------------------===//
        -: 2138:// spirv.ConvertFToSOp
        -: 2139://===----------------------------------------------------------------------===//
        -: 2140:
function _ZN4mlir5spirv13ConvertFToSOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2141:LogicalResult spirv::ConvertFToSOp::verify() {
    #####: 2142:  return verifyCastOp(*this, /*requireSameBitWidth=*/false,
    #####: 2143:                      /*skipBitWidthCheck=*/true);
call    0 never executed
call    1 never executed
        -: 2144:}
        -: 2145:
        -: 2146://===----------------------------------------------------------------------===//
        -: 2147:// spirv.ConvertFToUOp
        -: 2148://===----------------------------------------------------------------------===//
        -: 2149:
function _ZN4mlir5spirv13ConvertFToUOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2150:LogicalResult spirv::ConvertFToUOp::verify() {
    #####: 2151:  return verifyCastOp(*this, /*requireSameBitWidth=*/false,
    #####: 2152:                      /*skipBitWidthCheck=*/true);
call    0 never executed
call    1 never executed
        -: 2153:}
        -: 2154:
        -: 2155://===----------------------------------------------------------------------===//
        -: 2156:// spirv.ConvertSToFOp
        -: 2157://===----------------------------------------------------------------------===//
        -: 2158:
function _ZN4mlir5spirv13ConvertSToFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2159:LogicalResult spirv::ConvertSToFOp::verify() {
    #####: 2160:  return verifyCastOp(*this, /*requireSameBitWidth=*/false,
    #####: 2161:                      /*skipBitWidthCheck=*/true);
call    0 never executed
call    1 never executed
        -: 2162:}
        -: 2163:
        -: 2164://===----------------------------------------------------------------------===//
        -: 2165:// spirv.ConvertUToFOp
        -: 2166://===----------------------------------------------------------------------===//
        -: 2167:
function _ZN4mlir5spirv13ConvertUToFOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2168:LogicalResult spirv::ConvertUToFOp::verify() {
    #####: 2169:  return verifyCastOp(*this, /*requireSameBitWidth=*/false,
    #####: 2170:                      /*skipBitWidthCheck=*/true);
call    0 never executed
call    1 never executed
        -: 2171:}
        -: 2172:
        -: 2173://===----------------------------------------------------------------------===//
        -: 2174:// spirv.EntryPoint
        -: 2175://===----------------------------------------------------------------------===//
        -: 2176:
function _ZN4mlir5spirv12EntryPointOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_14ExecutionModelENS0_6FuncOpEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####: 2177:void spirv::EntryPointOp::build(OpBuilder &builder, OperationState &state,
        -: 2178:                                spirv::ExecutionModel executionModel,
        -: 2179:                                spirv::FuncOp function,
        -: 2180:                                ArrayRef<Attribute> interfaceVars) {
    #####: 2181:  build(builder, state,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2182:        spirv::ExecutionModelAttr::get(builder.getContext(), executionModel),
        -: 2183:        SymbolRefAttr::get(function), builder.getArrayAttr(interfaceVars));
    #####: 2184:}
        -: 2185:
function _ZN4mlir5spirv12EntryPointOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2186:ParseResult spirv::EntryPointOp::parse(OpAsmParser &parser,
        -: 2187:                                       OperationState &result) {
    #####: 2188:  spirv::ExecutionModel execModel;
    #####: 2189:  SmallVector<OpAsmParser::UnresolvedOperand, 0> identifiers;
call    0 never executed
    #####: 2190:  SmallVector<Type, 0> idTypes;
    #####: 2191:  SmallVector<Attribute, 4> interfaceVars;
        -: 2192:
    #####: 2193:  FlatSymbolRefAttr fn;
    #####: 2194:  if (parseEnumStrAttr<spirv::ExecutionModelAttr>(execModel, parser, result) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2195:      parser.parseAttribute(fn, Type(), kFnNameAttrName, result.attributes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2196:    return failure();
        -: 2197:  }
        -: 2198:
    #####: 2199:  if (!parser.parseOptionalComma()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2200:    // Parse the interface variables
function _ZZN4mlir5spirv12EntryPointOp5parseERNS_11OpAsmParserERNS_14OperationStateEENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2201:    if (parser.parseCommaSeparatedList([&]() -> ParseResult {
branch  0 never executed
branch  1 never executed
        -: 2202:          // The name of the interface variable attribute isnt important
    #####: 2203:          FlatSymbolRefAttr var;
    #####: 2204:          NamedAttrList attrs;
call    0 never executed
    #####: 2205:          if (parser.parseAttribute(var, Type(), "var_symbol", attrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2206:            return failure();
    #####: 2207:          interfaceVars.push_back(var);
call    0 never executed
    #####: 2208:          return success();
    #####: 2209:        }))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2210:      return failure();
        -: 2211:  }
    #####: 2212:  result.addAttribute(kInterfaceAttrName,
call    0 never executed
    #####: 2213:                      parser.getBuilder().getArrayAttr(interfaceVars));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2214:  return success();
        -: 2215:}
        -: 2216:
function _ZN4mlir5spirv12EntryPointOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2217:void spirv::EntryPointOp::print(OpAsmPrinter &printer) {
    #####: 2218:  printer << " \"" << stringifyExecutionModel(getExecutionModel()) << "\" ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2219:  printer.printSymbolName(getFn());
call    0 never executed
call    1 never executed
    #####: 2220:  auto interfaceVars = getInterface().getValue();
call    0 never executed
call    1 never executed
    #####: 2221:  if (!interfaceVars.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2222:    printer << ", ";
call    0 never executed
    #####: 2223:    llvm::interleaveComma(interfaceVars, printer);
call    0 never executed
        -: 2224:  }
    #####: 2225:}
        -: 2226:
function _ZN4mlir5spirv12EntryPointOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2227:LogicalResult spirv::EntryPointOp::verify() {
        -: 2228:  // Checks for fn and interface symbol reference are done in spirv::ModuleOp
        -: 2229:  // verification.
    #####: 2230:  return success();
        -: 2231:}
        -: 2232:
        -: 2233://===----------------------------------------------------------------------===//
        -: 2234:// spirv.ExecutionMode
        -: 2235://===----------------------------------------------------------------------===//
        -: 2236:
function _ZN4mlir5spirv15ExecutionModeOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_6FuncOpENS0_13ExecutionModeEN4llvm8ArrayRefIiEE called 0 returned 0% blocks executed 0%
    #####: 2237:void spirv::ExecutionModeOp::build(OpBuilder &builder, OperationState &state,
        -: 2238:                                   spirv::FuncOp function,
        -: 2239:                                   spirv::ExecutionMode executionMode,
        -: 2240:                                   ArrayRef<int32_t> params) {
    #####: 2241:  build(builder, state, SymbolRefAttr::get(function),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2242:        spirv::ExecutionModeAttr::get(builder.getContext(), executionMode),
        -: 2243:        builder.getI32ArrayAttr(params));
    #####: 2244:}
        -: 2245:
function _ZN4mlir5spirv15ExecutionModeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2246:ParseResult spirv::ExecutionModeOp::parse(OpAsmParser &parser,
        -: 2247:                                          OperationState &result) {
    #####: 2248:  spirv::ExecutionMode execMode;
    #####: 2249:  Attribute fn;
    #####: 2250:  if (parser.parseAttribute(fn, kFnNameAttrName, result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2251:      parseEnumStrAttr<spirv::ExecutionModeAttr>(execMode, parser, result)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2252:    return failure();
        -: 2253:  }
        -: 2254:
    #####: 2255:  SmallVector<int32_t, 4> values;
call    0 never executed
    #####: 2256:  Type i32Type = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####: 2257:  while (!parser.parseOptionalComma()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2258:    NamedAttrList attr;
call    0 never executed
    #####: 2259:    Attribute value;
    #####: 2260:    if (parser.parseAttribute(value, i32Type, "value", attr)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2261:      return failure();
branch  0 never executed
branch  1 never executed
        -: 2262:    }
    #####: 2263:    values.push_back(value.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2264:  }
    #####: 2265:  result.addAttribute(kValuesAttrName,
call    0 never executed
    #####: 2266:                      parser.getBuilder().getI32ArrayAttr(values));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2267:  return success();
        -: 2268:}
        -: 2269:
function _ZN4mlir5spirv15ExecutionModeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2270:void spirv::ExecutionModeOp::print(OpAsmPrinter &printer) {
    #####: 2271:  printer << " ";
call    0 never executed
    #####: 2272:  printer.printSymbolName(getFn());
call    0 never executed
call    1 never executed
    #####: 2273:  printer << " \"" << stringifyExecutionMode(getExecutionMode()) << "\"";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2274:  auto values = this->getValues();
call    0 never executed
    #####: 2275:  if (values.empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2276:    return;
    #####: 2277:  printer << ", ";
call    0 never executed
function _ZZN4mlir5spirv15ExecutionModeOp5printERNS_12OpAsmPrinterEENKUlNS_9AttributeEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2278:  llvm::interleaveComma(values, printer, [&](Attribute a) {
call    0 never executed
    #####: 2279:    printer << a.cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2280:  });
        -: 2281:}
        -: 2282:
        -: 2283://===----------------------------------------------------------------------===//
        -: 2284:// spirv.FConvertOp
        -: 2285://===----------------------------------------------------------------------===//
        -: 2286:
function _ZN4mlir5spirv10FConvertOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2287:LogicalResult spirv::FConvertOp::verify() {
    #####: 2288:  return verifyCastOp(*this, /*requireSameBitWidth=*/false);
call    0 never executed
call    1 never executed
        -: 2289:}
        -: 2290:
        -: 2291://===----------------------------------------------------------------------===//
        -: 2292:// spirv.SConvertOp
        -: 2293://===----------------------------------------------------------------------===//
        -: 2294:
function _ZN4mlir5spirv10SConvertOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2295:LogicalResult spirv::SConvertOp::verify() {
    #####: 2296:  return verifyCastOp(*this, /*requireSameBitWidth=*/false);
call    0 never executed
call    1 never executed
        -: 2297:}
        -: 2298:
        -: 2299://===----------------------------------------------------------------------===//
        -: 2300:// spirv.UConvertOp
        -: 2301://===----------------------------------------------------------------------===//
        -: 2302:
function _ZN4mlir5spirv10UConvertOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2303:LogicalResult spirv::UConvertOp::verify() {
    #####: 2304:  return verifyCastOp(*this, /*requireSameBitWidth=*/false);
call    0 never executed
call    1 never executed
        -: 2305:}
        -: 2306:
        -: 2307://===----------------------------------------------------------------------===//
        -: 2308:// spirv.func
        -: 2309://===----------------------------------------------------------------------===//
        -: 2310:
function _ZN4mlir5spirv6FuncOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2311:ParseResult spirv::FuncOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2312:  SmallVector<OpAsmParser::Argument> entryArgs;
call    0 never executed
    #####: 2313:  SmallVector<DictionaryAttr> resultAttrs;
branch  0 never executed
branch  1 never executed
    #####: 2314:  SmallVector<Type> resultTypes;
branch  0 never executed
branch  1 never executed
    #####: 2315:  auto &builder = parser.getBuilder();
call    0 never executed
        -: 2316:
        -: 2317:  // Parse the name as a symbol.
    #####: 2318:  StringAttr nameAttr;
    #####: 2319:  if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
branch  0 never executed
branch  1 never executed
    #####: 2320:                             result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2321:    return failure();
        -: 2322:
        -: 2323:  // Parse the function signature.
    #####: 2324:  bool isVariadic = false;
    #####: 2325:  if (function_interface_impl::parseFunctionSignature(
branch  0 never executed
branch  1 never executed
        -: 2326:          parser, /*allowVariadic=*/false, entryArgs, isVariadic, resultTypes,
    #####: 2327:          resultAttrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2328:    return failure();
        -: 2329:
    #####: 2330:  SmallVector<Type> argTypes;
branch  0 never executed
branch  1 never executed
    #####: 2331:  for (auto &arg : entryArgs)
branch  0 never executed
branch  1 never executed
    #####: 2332:    argTypes.push_back(arg.type);
call    0 never executed
    #####: 2333:  auto fnType = builder.getFunctionType(argTypes, resultTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2334:  result.addAttribute(FunctionOpInterface::getTypeAttrName(),
call    0 never executed
    #####: 2335:                      TypeAttr::get(fnType));
call    0 never executed
        -: 2336:
        -: 2337:  // Parse the optional function control keyword.
    #####: 2338:  spirv::FunctionControl fnControl;
    #####: 2339:  if (parseEnumStrAttr<spirv::FunctionControlAttr>(fnControl, parser, result))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2340:    return failure();
        -: 2341:
        -: 2342:  // If additional attributes are present, parse them.
    #####: 2343:  if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2344:    return failure();
        -: 2345:
        -: 2346:  // Add the attributes to the function arguments.
    #####: 2347:  assert(resultAttrs.size() == resultTypes.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2348:  function_interface_impl::addArgAndResultAttrs(builder, result, entryArgs,
call    0 never executed
        -: 2349:                                                resultAttrs);
        -: 2350:
        -: 2351:  // Parse the optional function body.
    #####: 2352:  auto *body = result.addRegion();
call    0 never executed
    #####: 2353:  OptionalParseResult parseResult =
    #####: 2354:      parser.parseOptionalRegion(*body, entryArgs);
call    0 never executed
    #####: 2355:  return failure(parseResult.has_value() && failed(*parseResult));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2356:}
        -: 2357:
function _ZN4mlir5spirv6FuncOp5printERNS_12OpAsmPrinterE called 18 returned 100% blocks executed 86%
       18: 2358:void spirv::FuncOp::print(OpAsmPrinter &printer) {
        -: 2359:  // Print function name, signature, and control.
       18: 2360:  printer << " ";
call    0 returned 100%
       36: 2361:  printer.printSymbolName(getSymName());
call    0 returned 100%
call    1 returned 100%
       18: 2362:  auto fnType = getFunctionType();
call    0 returned 100%
       18: 2363:  function_interface_impl::printFunctionSignature(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2364:      printer, *this, fnType.getInputs(),
        -: 2365:      /*isVariadic=*/false, fnType.getResults());
       54: 2366:  printer << " \"" << spirv::stringifyFunctionControl(getFunctionControl())
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
       18: 2367:          << "\"";
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       18: 2368:  function_interface_impl::printFunctionAttributes(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 2369:      printer, *this, fnType.getNumInputs(), fnType.getNumResults(),
       18: 2370:      {spirv::attributeName<spirv::FunctionControl>()});
call    0 returned 100%
        -: 2371:
        -: 2372:  // Print the body if this is not an external function.
       18: 2373:  Region &body = this->getBody();
call    0 returned 100%
       18: 2374:  if (!body.empty()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2375:    printer << ' ';
call    0 never executed
    #####: 2376:    printer.printRegion(body, /*printEntryBlockArgs=*/false,
    #####: 2377:                        /*printBlockTerminators=*/true);
call    0 never executed
        -: 2378:  }
       18: 2379:}
        -: 2380:
function _ZN4mlir5spirv6FuncOp10verifyTypeEv called 542 returned 100% blocks executed 43%
      542: 2381:LogicalResult spirv::FuncOp::verifyType() {
      542: 2382:  auto type = getFunctionTypeAttr().getValue();
call    0 returned 100%
call    1 returned 100%
      542: 2383:  if (!type.isa<FunctionType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2384:    return emitOpError("requires '" + getTypeAttrName() +
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2385:                       "' attribute of function type");
call    0 never executed
call    1 never executed
call    2 never executed
      542: 2386:  if (getFunctionType().getNumResults() > 1)
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 2387:    return emitOpError("cannot have more than one result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
      542: 2388:  return success();
        -: 2389:}
        -: 2390:
function _ZN4mlir5spirv6FuncOp10verifyBodyEv called 542 returned 100% blocks executed 100%
      542: 2391:LogicalResult spirv::FuncOp::verifyBody() {
      542: 2392:  FunctionType fnType = getFunctionType();
call    0 returned 100%
        -: 2393:
function _ZZN4mlir5spirv6FuncOp10verifyBodyEvENKUlPNS_9OperationEE_clES3_ called 4673 returned 100% blocks executed 36%
     5215: 2394:  auto walkResult = walk([fnType](Operation *op) -> WalkResult {
     4673: 2395:    if (auto retOp = dyn_cast<spirv::ReturnOp>(op)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2396:      if (fnType.getNumResults() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2397:        return retOp.emitOpError("cannot be used in functions returning value");
call    0 never executed
call    1 never executed
call    2 never executed
     4673: 2398:    } else if (auto retOp = dyn_cast<spirv::ReturnValueOp>(op)) {
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
      512: 2399:      if (fnType.getNumResults() != 1)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2400:        return retOp.emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2401:                   "returns 1 value but enclosing function requires ")
    #####: 2402:               << fnType.getNumResults() << " results";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2403:
      512: 2404:      auto retOperandType = retOp.getValue().getType();
call    0 returned 100%
call    1 returned 100%
      512: 2405:      auto fnResultType = fnType.getResult(0);
call    0 returned 100%
      512: 2406:      if (retOperandType != fnResultType)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2407:        return retOp.emitOpError(" return value's type (")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2408:               << retOperandType << ") mismatch with function's result type ("
call    0 never executed
call    1 never executed
    #####: 2409:               << fnResultType << ")";
call    0 never executed
call    1 never executed
        -: 2410:    }
     4673: 2411:    return WalkResult::advance();
      542: 2412:  });
call    0 returned 100%
        -: 2413:
        -: 2414:  // TODO: verify other bits like linkage type.
        -: 2415:
      542: 2416:  return failure(walkResult.wasInterrupted());
        -: 2417:}
        -: 2418:
function _ZN4mlir5spirv6FuncOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm9StringRefENS_12FunctionTypeENS0_15FunctionControlENS6_8ArrayRefINS_14NamedAttributeEEE called 522 returned 100% blocks executed 100%
      522: 2419:void spirv::FuncOp::build(OpBuilder &builder, OperationState &state,
        -: 2420:                          StringRef name, FunctionType type,
        -: 2421:                          spirv::FunctionControl control,
        -: 2422:                          ArrayRef<NamedAttribute> attrs) {
      522: 2423:  state.addAttribute(SymbolTable::getSymbolAttrName(),
call    0 returned 100%
      522: 2424:                     builder.getStringAttr(name));
call    0 returned 100%
call    1 returned 100%
      522: 2425:  state.addAttribute(getTypeAttrName(), TypeAttr::get(type));
call    0 returned 100%
call    1 returned 100%
      522: 2426:  state.addAttribute(spirv::attributeName<spirv::FunctionControl>(),
call    0 returned 100%
      522: 2427:                     builder.getAttr<spirv::FunctionControlAttr>(control));
call    0 returned 100%
call    1 returned 100%
      522: 2428:  state.attributes.append(attrs.begin(), attrs.end());
call    0 returned 100%
      522: 2429:  state.addRegion();
call    0 returned 100%
      522: 2430:}
        -: 2431:
        -: 2432:// CallableOpInterface
function _ZN4mlir5spirv6FuncOp17getCallableRegionEv called 2 returned 100% blocks executed 75%
        2: 2433:Region *spirv::FuncOp::getCallableRegion() {
       2*: 2434:  return isExternal() ? nullptr : &getBody();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 2435:}
        -: 2436:
        -: 2437:// CallableOpInterface
function _ZN4mlir5spirv6FuncOp18getCallableResultsEv called 0 returned 0% blocks executed 0%
    #####: 2438:ArrayRef<Type> spirv::FuncOp::getCallableResults() {
    #####: 2439:  return getFunctionType().getResults();
call    0 never executed
call    1 never executed
        -: 2440:}
        -: 2441:
        -: 2442://===----------------------------------------------------------------------===//
        -: 2443:// spirv.FunctionCall
        -: 2444://===----------------------------------------------------------------------===//
        -: 2445:
function _ZN4mlir5spirv14FunctionCallOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2446:LogicalResult spirv::FunctionCallOp::verify() {
    #####: 2447:  auto fnName = getCalleeAttr();
call    0 never executed
        -: 2448:
    #####: 2449:  auto funcOp = dyn_cast_or_null<spirv::FuncOp>(
    #####: 2450:      SymbolTable::lookupNearestSymbolFrom((*this)->getParentOp(), fnName));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2451:  if (!funcOp) {
branch  0 never executed
branch  1 never executed
    #####: 2452:    return emitOpError("callee function '")
call    0 never executed
call    1 never executed
    #####: 2453:           << fnName.getValue() << "' not found in nearest symbol table";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2454:  }
        -: 2455:
    #####: 2456:  auto functionType = funcOp.getFunctionType();
call    0 never executed
        -: 2457:
    #####: 2458:  if (getNumResults() > 1) {
branch  0 never executed
branch  1 never executed
    #####: 2459:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2460:               "expected callee function to have 0 or 1 result, but provided ")
    #####: 2461:           << getNumResults();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2462:  }
        -: 2463:
    #####: 2464:  if (functionType.getNumInputs() != getNumOperands()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2465:    return emitOpError("has incorrect number of operands for callee: expected ")
call    0 never executed
call    1 never executed
    #####: 2466:           << functionType.getNumInputs() << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2467:           << getNumOperands();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2468:  }
        -: 2469:
    #####: 2470:  for (uint32_t i = 0, e = functionType.getNumInputs(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2471:    if (getOperand(i).getType() != functionType.getInput(i)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2472:      return emitOpError("operand type mismatch: expected operand type ")
call    0 never executed
call    1 never executed
    #####: 2473:             << functionType.getInput(i) << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2474:             << getOperand(i).getType() << " for operand number " << i;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 2475:    }
        -: 2476:  }
        -: 2477:
    #####: 2478:  if (functionType.getNumResults() != getNumResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2479:    return emitOpError(
call    0 never executed
call    1 never executed
        -: 2480:               "has incorrect number of results has for callee: expected ")
    #####: 2481:           << functionType.getNumResults() << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2482:           << getNumResults();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2483:  }
        -: 2484:
    #####: 2485:  if (getNumResults() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2486:      (getResult(0).getType() != functionType.getResult(0))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2487:    return emitOpError("result type mismatch: expected ")
call    0 never executed
call    1 never executed
    #####: 2488:           << functionType.getResult(0) << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2489:           << getResult(0).getType();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2490:  }
        -: 2491:
    #####: 2492:  return success();
        -: 2493:}
        -: 2494:
function _ZN4mlir5spirv14FunctionCallOp20getCallableForCalleeEv called 0 returned 0% blocks executed 0%
    #####: 2495:CallInterfaceCallable spirv::FunctionCallOp::getCallableForCallee() {
    #####: 2496:  return (*this)->getAttrOfType<SymbolRefAttr>(kCallee);
call    0 never executed
call    1 never executed
        -: 2497:}
        -: 2498:
function _ZN4mlir5spirv14FunctionCallOp14getArgOperandsEv called 0 returned 0% blocks executed 0%
    #####: 2499:Operation::operand_range spirv::FunctionCallOp::getArgOperands() {
    #####: 2500:  return getArguments();
call    0 never executed
        -: 2501:}
        -: 2502:
        -: 2503://===----------------------------------------------------------------------===//
        -: 2504:// spirv.GLFClampOp
        -: 2505://===----------------------------------------------------------------------===//
        -: 2506:
function _ZN4mlir5spirv10GLFClampOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2507:ParseResult spirv::GLFClampOp::parse(OpAsmParser &parser,
        -: 2508:                                     OperationState &result) {
    #####: 2509:  return parseOneResultSameOperandTypeOp(parser, result);
call    0 never executed
        -: 2510:}
function _ZN4mlir5spirv10GLFClampOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2511:void spirv::GLFClampOp::print(OpAsmPrinter &p) { printOneResultOp(*this, p); }
call    0 never executed
        -: 2512:
        -: 2513://===----------------------------------------------------------------------===//
        -: 2514:// spirv.GLUClampOp
        -: 2515://===----------------------------------------------------------------------===//
        -: 2516:
function _ZN4mlir5spirv10GLUClampOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2517:ParseResult spirv::GLUClampOp::parse(OpAsmParser &parser,
        -: 2518:                                     OperationState &result) {
    #####: 2519:  return parseOneResultSameOperandTypeOp(parser, result);
call    0 never executed
        -: 2520:}
function _ZN4mlir5spirv10GLUClampOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2521:void spirv::GLUClampOp::print(OpAsmPrinter &p) { printOneResultOp(*this, p); }
call    0 never executed
        -: 2522:
        -: 2523://===----------------------------------------------------------------------===//
        -: 2524:// spirv.GLSClampOp
        -: 2525://===----------------------------------------------------------------------===//
        -: 2526:
function _ZN4mlir5spirv10GLSClampOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2527:ParseResult spirv::GLSClampOp::parse(OpAsmParser &parser,
        -: 2528:                                     OperationState &result) {
    #####: 2529:  return parseOneResultSameOperandTypeOp(parser, result);
call    0 never executed
        -: 2530:}
function _ZN4mlir5spirv10GLSClampOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2531:void spirv::GLSClampOp::print(OpAsmPrinter &p) { printOneResultOp(*this, p); }
call    0 never executed
        -: 2532:
        -: 2533://===----------------------------------------------------------------------===//
        -: 2534:// spirv.GLFmaOp
        -: 2535://===----------------------------------------------------------------------===//
        -: 2536:
function _ZN4mlir5spirv7GLFmaOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2537:ParseResult spirv::GLFmaOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 2538:  return parseOneResultSameOperandTypeOp(parser, result);
call    0 never executed
        -: 2539:}
function _ZN4mlir5spirv7GLFmaOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2540:void spirv::GLFmaOp::print(OpAsmPrinter &p) { printOneResultOp(*this, p); }
call    0 never executed
        -: 2541:
        -: 2542://===----------------------------------------------------------------------===//
        -: 2543:// spirv.GlobalVariable
        -: 2544://===----------------------------------------------------------------------===//
        -: 2545:
function _ZN4mlir5spirv16GlobalVariableOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeEN4llvm9StringRefEjj called 0 returned 0% blocks executed 0%
    #####: 2546:void spirv::GlobalVariableOp::build(OpBuilder &builder, OperationState &state,
        -: 2547:                                    Type type, StringRef name,
        -: 2548:                                    unsigned descriptorSet, unsigned binding) {
    #####: 2549:  build(builder, state, TypeAttr::get(type), builder.getStringAttr(name));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2550:  state.addAttribute(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2551:      spirv::SPIRVDialect::getAttributeName(spirv::Decoration::DescriptorSet),
call    0 never executed
call    1 never executed
    #####: 2552:      builder.getI32IntegerAttr(descriptorSet));
call    0 never executed
    #####: 2553:  state.addAttribute(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2554:      spirv::SPIRVDialect::getAttributeName(spirv::Decoration::Binding),
call    0 never executed
call    1 never executed
    #####: 2555:      builder.getI32IntegerAttr(binding));
call    0 never executed
    #####: 2556:}
        -: 2557:
function _ZN4mlir5spirv16GlobalVariableOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeEN4llvm9StringRefENS0_7BuiltInE called 0 returned 0% blocks executed 0%
    #####: 2558:void spirv::GlobalVariableOp::build(OpBuilder &builder, OperationState &state,
        -: 2559:                                    Type type, StringRef name,
        -: 2560:                                    spirv::BuiltIn builtin) {
    #####: 2561:  build(builder, state, TypeAttr::get(type), builder.getStringAttr(name));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 2562:  state.addAttribute(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2563:      spirv::SPIRVDialect::getAttributeName(spirv::Decoration::BuiltIn),
call    0 never executed
call    1 never executed
    #####: 2564:      builder.getStringAttr(spirv::stringifyBuiltIn(builtin)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2565:}
        -: 2566:
function _ZN4mlir5spirv16GlobalVariableOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2567:ParseResult spirv::GlobalVariableOp::parse(OpAsmParser &parser,
        -: 2568:                                           OperationState &result) {
        -: 2569:  // Parse variable name.
    #####: 2570:  StringAttr nameAttr;
    #####: 2571:  if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
branch  0 never executed
branch  1 never executed
    #####: 2572:                             result.attributes)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2573:    return failure();
        -: 2574:  }
        -: 2575:
        -: 2576:  // Parse optional initializer
    #####: 2577:  if (succeeded(parser.parseOptionalKeyword(kInitializerAttrName))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2578:    FlatSymbolRefAttr initSymbol;
    #####: 2579:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2580:        parser.parseAttribute(initSymbol, Type(), kInitializerAttrName,
    #####: 2581:                              result.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2582:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2583:      return failure();
        -: 2584:  }
        -: 2585:
    #####: 2586:  if (parseVariableDecorations(parser, result)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2587:    return failure();
        -: 2588:  }
        -: 2589:
    #####: 2590:  Type type;
    #####: 2591:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 2592:  if (parser.parseColonType(type)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2593:    return failure();
        -: 2594:  }
    #####: 2595:  if (!type.isa<spirv::PointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2596:    return parser.emitError(loc, "expected spirv.ptr type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2597:  }
    #####: 2598:  result.addAttribute(kTypeAttrName, TypeAttr::get(type));
call    0 never executed
call    1 never executed
        -: 2599:
    #####: 2600:  return success();
        -: 2601:}
        -: 2602:
function _ZN4mlir5spirv16GlobalVariableOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2603:void spirv::GlobalVariableOp::print(OpAsmPrinter &printer) {
    #####: 2604:  SmallVector<StringRef, 4> elidedAttrs{
call    0 never executed
    #####: 2605:      spirv::attributeName<spirv::StorageClass>()};
call    0 never executed
        -: 2606:
        -: 2607:  // Print variable name.
    #####: 2608:  printer << ' ';
call    0 never executed
    #####: 2609:  printer.printSymbolName(getSymName());
call    0 never executed
call    1 never executed
    #####: 2610:  elidedAttrs.push_back(SymbolTable::getSymbolAttrName());
call    0 never executed
        -: 2611:
        -: 2612:  // Print optional initializer
    #####: 2613:  if (auto initializer = this->getInitializer()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2614:    printer << " " << kInitializerAttrName << '(';
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2615:    printer.printSymbolName(*initializer);
call    0 never executed
    #####: 2616:    printer << ')';
call    0 never executed
    #####: 2617:    elidedAttrs.push_back(kInitializerAttrName);
call    0 never executed
        -: 2618:  }
        -: 2619:
    #####: 2620:  elidedAttrs.push_back(kTypeAttrName);
call    0 never executed
    #####: 2621:  printVariableDecorations(*this, printer, elidedAttrs);
call    0 never executed
    #####: 2622:  printer << " : " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2623:}
        -: 2624:
function _ZN4mlir5spirv16GlobalVariableOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2625:LogicalResult spirv::GlobalVariableOp::verify() {
        -: 2626:  // SPIR-V spec: "Storage Class is the Storage Class of the memory holding the
        -: 2627:  // object. It cannot be Generic. It must be the same as the Storage Class
        -: 2628:  // operand of the Result Type."
        -: 2629:  // Also, Function storage class is reserved by spirv.Variable.
    #####: 2630:  auto storageClass = this->storageClass();
call    0 never executed
    #####: 2631:  if (storageClass == spirv::StorageClass::Generic ||
branch  0 never executed
branch  1 never executed
        -: 2632:      storageClass == spirv::StorageClass::Function) {
    #####: 2633:    return emitOpError("storage class cannot be '")
call    0 never executed
call    1 never executed
    #####: 2634:           << stringifyStorageClass(storageClass) << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2635:  }
        -: 2636:
    #####: 2637:  if (auto init =
branch  0 never executed
branch  1 never executed
    #####: 2638:          (*this)->getAttrOfType<FlatSymbolRefAttr>(kInitializerAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2639:    Operation *initOp = SymbolTable::lookupNearestSymbolFrom(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2640:        (*this)->getParentOp(), init.getAttr());
        -: 2641:    // TODO: Currently only variable initialization with specialization
        -: 2642:    // constants and other variables is supported. They could be normal
        -: 2643:    // constants in the module scope as well.
    #####: 2644:    if (!initOp ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2645:        !isa<spirv::GlobalVariableOp, spirv::SpecConstantOp>(initOp)) {
call    0 never executed
    #####: 2646:      return emitOpError("initializer must be result of a "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2647:                         "spirv.SpecConstant or spirv.GlobalVariable op");
call    0 never executed
        -: 2648:    }
        -: 2649:  }
        -: 2650:
    #####: 2651:  return success();
        -: 2652:}
        -: 2653:
        -: 2654://===----------------------------------------------------------------------===//
        -: 2655:// spirv.GroupBroadcast
        -: 2656://===----------------------------------------------------------------------===//
        -: 2657:
function _ZN4mlir5spirv16GroupBroadcastOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2658:LogicalResult spirv::GroupBroadcastOp::verify() {
    #####: 2659:  spirv::Scope scope = getExecutionScope();
call    0 never executed
    #####: 2660:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2661:    return emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2662:
    #####: 2663:  if (auto localIdTy = getLocalid().getType().dyn_cast<VectorType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2664:    if (localIdTy.getNumElements() != 2 && localIdTy.getNumElements() != 3)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2665:      return emitOpError("localid is a vector and can be with only "
call    0 never executed
call    1 never executed
        -: 2666:                         " 2 or 3 components, actual number is ")
    #####: 2667:             << localIdTy.getNumElements();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2668:
    #####: 2669:  return success();
        -: 2670:}
        -: 2671:
        -: 2672://===----------------------------------------------------------------------===//
        -: 2673:// spirv.GroupNonUniformBallotOp
        -: 2674://===----------------------------------------------------------------------===//
        -: 2675:
function _ZN4mlir5spirv23GroupNonUniformBallotOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2676:LogicalResult spirv::GroupNonUniformBallotOp::verify() {
    #####: 2677:  spirv::Scope scope = getExecutionScope();
call    0 never executed
    #####: 2678:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2679:    return emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2680:
    #####: 2681:  return success();
        -: 2682:}
        -: 2683:
        -: 2684://===----------------------------------------------------------------------===//
        -: 2685:// spirv.GroupNonUniformBroadcast
        -: 2686://===----------------------------------------------------------------------===//
        -: 2687:
function _ZN4mlir5spirv26GroupNonUniformBroadcastOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2688:LogicalResult spirv::GroupNonUniformBroadcastOp::verify() {
    #####: 2689:  spirv::Scope scope = getExecutionScope();
call    0 never executed
    #####: 2690:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2691:    return emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2692:
        -: 2693:  // SPIR-V spec: "Before version 1.5, Id must come from a
        -: 2694:  // constant instruction.
    #####: 2695:  auto targetEnv = spirv::getDefaultTargetEnv(getContext());
call    0 never executed
call    1 never executed
    #####: 2696:  if (auto spirvModule = (*this)->getParentOfType<spirv::ModuleOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2697:    targetEnv = spirv::lookupTargetEnvOrDefault(spirvModule);
call    0 never executed
        -: 2698:
    #####: 2699:  if (targetEnv.getVersion() < spirv::Version::V_1_5) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2700:    auto *idOp = getId().getDefiningOp();
call    0 never executed
call    1 never executed
    #####: 2701:    if (!idOp || !isa<spirv::ConstantOp,           // for normal constant
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2702:                      spirv::ReferenceOfOp>(idOp)) // for spec constant
call    0 never executed
    #####: 2703:      return emitOpError("id must be the result of a constant op");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2704:  }
        -: 2705:
    #####: 2706:  return success();
        -: 2707:}
        -: 2708:
        -: 2709://===----------------------------------------------------------------------===//
        -: 2710:// spirv.GroupNonUniformShuffle*
        -: 2711://===----------------------------------------------------------------------===//
        -: 2712:
        -: 2713:template <typename OpTy>
    #####: 2714:static LogicalResult verifyGroupNonUniformShuffleOp(OpTy op) {
    #####: 2715:  spirv::Scope scope = op.getExecutionScope();
    #####: 2716:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
    #####: 2717:    return op.emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
        -: 2718:
    #####: 2719:  if (op.getOperands().back().getType().isSignedInteger())
    #####: 2720:    return op.emitOpError("second operand must be a singless/unsigned integer");
        -: 2721:
    #####: 2722:  return success();
        -: 2723:}
------------------
_Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv27GroupNonUniformShuffleXorOpEENS0_13LogicalResultET_:
function _Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv27GroupNonUniformShuffleXorOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 2714:static LogicalResult verifyGroupNonUniformShuffleOp(OpTy op) {
call    0 never executed
    #####: 2715:  spirv::Scope scope = op.getExecutionScope();
    #####: 2716:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2717:    return op.emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2718:
    #####: 2719:  if (op.getOperands().back().getType().isSignedInteger())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2720:    return op.emitOpError("second operand must be a singless/unsigned integer");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2721:
    #####: 2722:  return success();
        -: 2723:}
------------------
_Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv26GroupNonUniformShuffleUpOpEENS0_13LogicalResultET_:
function _Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv26GroupNonUniformShuffleUpOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 2714:static LogicalResult verifyGroupNonUniformShuffleOp(OpTy op) {
call    0 never executed
    #####: 2715:  spirv::Scope scope = op.getExecutionScope();
    #####: 2716:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2717:    return op.emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2718:
    #####: 2719:  if (op.getOperands().back().getType().isSignedInteger())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2720:    return op.emitOpError("second operand must be a singless/unsigned integer");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2721:
    #####: 2722:  return success();
        -: 2723:}
------------------
_Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv28GroupNonUniformShuffleDownOpEENS0_13LogicalResultET_:
function _Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv28GroupNonUniformShuffleDownOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 2714:static LogicalResult verifyGroupNonUniformShuffleOp(OpTy op) {
call    0 never executed
    #####: 2715:  spirv::Scope scope = op.getExecutionScope();
    #####: 2716:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2717:    return op.emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2718:
    #####: 2719:  if (op.getOperands().back().getType().isSignedInteger())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2720:    return op.emitOpError("second operand must be a singless/unsigned integer");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2721:
    #####: 2722:  return success();
        -: 2723:}
------------------
_Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv24GroupNonUniformShuffleOpEENS0_13LogicalResultET_:
function _Z30verifyGroupNonUniformShuffleOpIN4mlir5spirv24GroupNonUniformShuffleOpEENS0_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####: 2714:static LogicalResult verifyGroupNonUniformShuffleOp(OpTy op) {
call    0 never executed
    #####: 2715:  spirv::Scope scope = op.getExecutionScope();
    #####: 2716:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2717:    return op.emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2718:
    #####: 2719:  if (op.getOperands().back().getType().isSignedInteger())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2720:    return op.emitOpError("second operand must be a singless/unsigned integer");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2721:
    #####: 2722:  return success();
        -: 2723:}
------------------
        -: 2724:
function _ZN4mlir5spirv24GroupNonUniformShuffleOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2725:LogicalResult spirv::GroupNonUniformShuffleOp::verify() {
    #####: 2726:  return verifyGroupNonUniformShuffleOp(*this);
call    0 never executed
call    1 never executed
        -: 2727:}
function _ZN4mlir5spirv28GroupNonUniformShuffleDownOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2728:LogicalResult spirv::GroupNonUniformShuffleDownOp::verify() {
    #####: 2729:  return verifyGroupNonUniformShuffleOp(*this);
call    0 never executed
call    1 never executed
        -: 2730:}
function _ZN4mlir5spirv26GroupNonUniformShuffleUpOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2731:LogicalResult spirv::GroupNonUniformShuffleUpOp::verify() {
    #####: 2732:  return verifyGroupNonUniformShuffleOp(*this);
call    0 never executed
call    1 never executed
        -: 2733:}
function _ZN4mlir5spirv27GroupNonUniformShuffleXorOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2734:LogicalResult spirv::GroupNonUniformShuffleXorOp::verify() {
    #####: 2735:  return verifyGroupNonUniformShuffleOp(*this);
call    0 never executed
call    1 never executed
        -: 2736:}
        -: 2737:
        -: 2738://===----------------------------------------------------------------------===//
        -: 2739:// spirv.INTEL.SubgroupBlockRead
        -: 2740://===----------------------------------------------------------------------===//
        -: 2741:
function _ZN4mlir5spirv24INTELSubgroupBlockReadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2742:ParseResult spirv::INTELSubgroupBlockReadOp::parse(OpAsmParser &parser,
        -: 2743:                                                   OperationState &result) {
        -: 2744:  // Parse the storage class specification
    #####: 2745:  spirv::StorageClass storageClass;
    #####: 2746:  OpAsmParser::UnresolvedOperand ptrInfo;
call    0 never executed
    #####: 2747:  Type elementType;
    #####: 2748:  if (parseEnumStrAttr(storageClass, parser) || parser.parseOperand(ptrInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2749:      parser.parseColon() || parser.parseType(elementType)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 2750:    return failure();
        -: 2751:  }
        -: 2752:
    #####: 2753:  auto ptrType = spirv::PointerType::get(elementType, storageClass);
call    0 never executed
    #####: 2754:  if (auto valVecTy = elementType.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2755:    ptrType = spirv::PointerType::get(valVecTy.getElementType(), storageClass);
call    0 never executed
call    1 never executed
        -: 2756:
    #####: 2757:  if (parser.resolveOperand(ptrInfo, ptrType, result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2758:    return failure();
        -: 2759:  }
        -: 2760:
    #####: 2761:  result.addTypes(elementType);
call    0 never executed
    #####: 2762:  return success();
        -: 2763:}
        -: 2764:
function _ZN4mlir5spirv24INTELSubgroupBlockReadOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2765:void spirv::INTELSubgroupBlockReadOp::print(OpAsmPrinter &printer) {
    #####: 2766:  printer << " " << getPtr() << " : " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 2767:}
        -: 2768:
function _ZN4mlir5spirv24INTELSubgroupBlockReadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2769:LogicalResult spirv::INTELSubgroupBlockReadOp::verify() {
    #####: 2770:  if (failed(verifyBlockReadWritePtrAndValTypes(*this, getPtr(), getValue())))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2771:    return failure();
        -: 2772:
    #####: 2773:  return success();
        -: 2774:}
        -: 2775:
        -: 2776://===----------------------------------------------------------------------===//
        -: 2777:// spirv.INTEL.SubgroupBlockWrite
        -: 2778://===----------------------------------------------------------------------===//
        -: 2779:
function _ZN4mlir5spirv25INTELSubgroupBlockWriteOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2780:ParseResult spirv::INTELSubgroupBlockWriteOp::parse(OpAsmParser &parser,
        -: 2781:                                                    OperationState &result) {
        -: 2782:  // Parse the storage class specification
    #####: 2783:  spirv::StorageClass storageClass;
    #####: 2784:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandInfo;
call    0 never executed
    #####: 2785:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 2786:  Type elementType;
    #####: 2787:  if (parseEnumStrAttr(storageClass, parser) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2788:      parser.parseOperandList(operandInfo, 2) || parser.parseColon() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 2789:      parser.parseType(elementType)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2790:    return failure();
        -: 2791:  }
        -: 2792:
    #####: 2793:  auto ptrType = spirv::PointerType::get(elementType, storageClass);
call    0 never executed
    #####: 2794:  if (auto valVecTy = elementType.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2795:    ptrType = spirv::PointerType::get(valVecTy.getElementType(), storageClass);
call    0 never executed
call    1 never executed
        -: 2796:
    #####: 2797:  if (parser.resolveOperands(operandInfo, {ptrType, elementType}, loc,
branch  0 never executed
branch  1 never executed
    #####: 2798:                             result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2799:    return failure();
        -: 2800:  }
    #####: 2801:  return success();
        -: 2802:}
        -: 2803:
function _ZN4mlir5spirv25INTELSubgroupBlockWriteOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2804:void spirv::INTELSubgroupBlockWriteOp::print(OpAsmPrinter &printer) {
    #####: 2805:  printer << " " << getPtr() << ", " << getValue() << " : "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####: 2806:          << getValue().getType();
call    0 never executed
    #####: 2807:}
        -: 2808:
function _ZN4mlir5spirv25INTELSubgroupBlockWriteOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2809:LogicalResult spirv::INTELSubgroupBlockWriteOp::verify() {
    #####: 2810:  if (failed(verifyBlockReadWritePtrAndValTypes(*this, getPtr(), getValue())))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2811:    return failure();
        -: 2812:
    #####: 2813:  return success();
        -: 2814:}
        -: 2815:
        -: 2816://===----------------------------------------------------------------------===//
        -: 2817:// spirv.GroupNonUniformElectOp
        -: 2818://===----------------------------------------------------------------------===//
        -: 2819:
function _ZN4mlir5spirv22GroupNonUniformElectOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2820:LogicalResult spirv::GroupNonUniformElectOp::verify() {
    #####: 2821:  spirv::Scope scope = getExecutionScope();
call    0 never executed
    #####: 2822:  if (scope != spirv::Scope::Workgroup && scope != spirv::Scope::Subgroup)
branch  0 never executed
branch  1 never executed
    #####: 2823:    return emitOpError("execution scope must be 'Workgroup' or 'Subgroup'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2824:
    #####: 2825:  return success();
        -: 2826:}
        -: 2827:
        -: 2828://===----------------------------------------------------------------------===//
        -: 2829:// spirv.GroupNonUniformFAddOp
        -: 2830://===----------------------------------------------------------------------===//
        -: 2831:
function _ZN4mlir5spirv21GroupNonUniformFAddOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2832:LogicalResult spirv::GroupNonUniformFAddOp::verify() {
    #####: 2833:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2834:}
        -: 2835:
function _ZN4mlir5spirv21GroupNonUniformFAddOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2836:ParseResult spirv::GroupNonUniformFAddOp::parse(OpAsmParser &parser,
        -: 2837:                                                OperationState &result) {
    #####: 2838:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2839:}
function _ZN4mlir5spirv21GroupNonUniformFAddOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2840:void spirv::GroupNonUniformFAddOp::print(OpAsmPrinter &p) {
    #####: 2841:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2842:}
        -: 2843:
        -: 2844://===----------------------------------------------------------------------===//
        -: 2845:// spirv.GroupNonUniformFMaxOp
        -: 2846://===----------------------------------------------------------------------===//
        -: 2847:
function _ZN4mlir5spirv21GroupNonUniformFMaxOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2848:LogicalResult spirv::GroupNonUniformFMaxOp::verify() {
    #####: 2849:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2850:}
        -: 2851:
function _ZN4mlir5spirv21GroupNonUniformFMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2852:ParseResult spirv::GroupNonUniformFMaxOp::parse(OpAsmParser &parser,
        -: 2853:                                                OperationState &result) {
    #####: 2854:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2855:}
function _ZN4mlir5spirv21GroupNonUniformFMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2856:void spirv::GroupNonUniformFMaxOp::print(OpAsmPrinter &p) {
    #####: 2857:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2858:}
        -: 2859:
        -: 2860://===----------------------------------------------------------------------===//
        -: 2861:// spirv.GroupNonUniformFMinOp
        -: 2862://===----------------------------------------------------------------------===//
        -: 2863:
function _ZN4mlir5spirv21GroupNonUniformFMinOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2864:LogicalResult spirv::GroupNonUniformFMinOp::verify() {
    #####: 2865:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2866:}
        -: 2867:
function _ZN4mlir5spirv21GroupNonUniformFMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2868:ParseResult spirv::GroupNonUniformFMinOp::parse(OpAsmParser &parser,
        -: 2869:                                                OperationState &result) {
    #####: 2870:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2871:}
function _ZN4mlir5spirv21GroupNonUniformFMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2872:void spirv::GroupNonUniformFMinOp::print(OpAsmPrinter &p) {
    #####: 2873:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2874:}
        -: 2875:
        -: 2876://===----------------------------------------------------------------------===//
        -: 2877:// spirv.GroupNonUniformFMulOp
        -: 2878://===----------------------------------------------------------------------===//
        -: 2879:
function _ZN4mlir5spirv21GroupNonUniformFMulOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2880:LogicalResult spirv::GroupNonUniformFMulOp::verify() {
    #####: 2881:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2882:}
        -: 2883:
function _ZN4mlir5spirv21GroupNonUniformFMulOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2884:ParseResult spirv::GroupNonUniformFMulOp::parse(OpAsmParser &parser,
        -: 2885:                                                OperationState &result) {
    #####: 2886:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2887:}
function _ZN4mlir5spirv21GroupNonUniformFMulOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2888:void spirv::GroupNonUniformFMulOp::print(OpAsmPrinter &p) {
    #####: 2889:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2890:}
        -: 2891:
        -: 2892://===----------------------------------------------------------------------===//
        -: 2893:// spirv.GroupNonUniformIAddOp
        -: 2894://===----------------------------------------------------------------------===//
        -: 2895:
function _ZN4mlir5spirv21GroupNonUniformIAddOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2896:LogicalResult spirv::GroupNonUniformIAddOp::verify() {
    #####: 2897:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2898:}
        -: 2899:
function _ZN4mlir5spirv21GroupNonUniformIAddOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2900:ParseResult spirv::GroupNonUniformIAddOp::parse(OpAsmParser &parser,
        -: 2901:                                                OperationState &result) {
    #####: 2902:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2903:}
function _ZN4mlir5spirv21GroupNonUniformIAddOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2904:void spirv::GroupNonUniformIAddOp::print(OpAsmPrinter &p) {
    #####: 2905:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2906:}
        -: 2907:
        -: 2908://===----------------------------------------------------------------------===//
        -: 2909:// spirv.GroupNonUniformIMulOp
        -: 2910://===----------------------------------------------------------------------===//
        -: 2911:
function _ZN4mlir5spirv21GroupNonUniformIMulOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2912:LogicalResult spirv::GroupNonUniformIMulOp::verify() {
    #####: 2913:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2914:}
        -: 2915:
function _ZN4mlir5spirv21GroupNonUniformIMulOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2916:ParseResult spirv::GroupNonUniformIMulOp::parse(OpAsmParser &parser,
        -: 2917:                                                OperationState &result) {
    #####: 2918:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2919:}
function _ZN4mlir5spirv21GroupNonUniformIMulOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2920:void spirv::GroupNonUniformIMulOp::print(OpAsmPrinter &p) {
    #####: 2921:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2922:}
        -: 2923:
        -: 2924://===----------------------------------------------------------------------===//
        -: 2925:// spirv.GroupNonUniformSMaxOp
        -: 2926://===----------------------------------------------------------------------===//
        -: 2927:
function _ZN4mlir5spirv21GroupNonUniformSMaxOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2928:LogicalResult spirv::GroupNonUniformSMaxOp::verify() {
    #####: 2929:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2930:}
        -: 2931:
function _ZN4mlir5spirv21GroupNonUniformSMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2932:ParseResult spirv::GroupNonUniformSMaxOp::parse(OpAsmParser &parser,
        -: 2933:                                                OperationState &result) {
    #####: 2934:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2935:}
function _ZN4mlir5spirv21GroupNonUniformSMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2936:void spirv::GroupNonUniformSMaxOp::print(OpAsmPrinter &p) {
    #####: 2937:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2938:}
        -: 2939:
        -: 2940://===----------------------------------------------------------------------===//
        -: 2941:// spirv.GroupNonUniformSMinOp
        -: 2942://===----------------------------------------------------------------------===//
        -: 2943:
function _ZN4mlir5spirv21GroupNonUniformSMinOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2944:LogicalResult spirv::GroupNonUniformSMinOp::verify() {
    #####: 2945:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2946:}
        -: 2947:
function _ZN4mlir5spirv21GroupNonUniformSMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2948:ParseResult spirv::GroupNonUniformSMinOp::parse(OpAsmParser &parser,
        -: 2949:                                                OperationState &result) {
    #####: 2950:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2951:}
function _ZN4mlir5spirv21GroupNonUniformSMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2952:void spirv::GroupNonUniformSMinOp::print(OpAsmPrinter &p) {
    #####: 2953:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2954:}
        -: 2955:
        -: 2956://===----------------------------------------------------------------------===//
        -: 2957:// spirv.GroupNonUniformUMaxOp
        -: 2958://===----------------------------------------------------------------------===//
        -: 2959:
function _ZN4mlir5spirv21GroupNonUniformUMaxOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2960:LogicalResult spirv::GroupNonUniformUMaxOp::verify() {
    #####: 2961:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2962:}
        -: 2963:
function _ZN4mlir5spirv21GroupNonUniformUMaxOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2964:ParseResult spirv::GroupNonUniformUMaxOp::parse(OpAsmParser &parser,
        -: 2965:                                                OperationState &result) {
    #####: 2966:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2967:}
function _ZN4mlir5spirv21GroupNonUniformUMaxOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2968:void spirv::GroupNonUniformUMaxOp::print(OpAsmPrinter &p) {
    #####: 2969:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2970:}
        -: 2971:
        -: 2972://===----------------------------------------------------------------------===//
        -: 2973:// spirv.GroupNonUniformUMinOp
        -: 2974://===----------------------------------------------------------------------===//
        -: 2975:
function _ZN4mlir5spirv21GroupNonUniformUMinOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2976:LogicalResult spirv::GroupNonUniformUMinOp::verify() {
    #####: 2977:  return verifyGroupNonUniformArithmeticOp(*this);
call    0 never executed
call    1 never executed
        -: 2978:}
        -: 2979:
function _ZN4mlir5spirv21GroupNonUniformUMinOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 2980:ParseResult spirv::GroupNonUniformUMinOp::parse(OpAsmParser &parser,
        -: 2981:                                                OperationState &result) {
    #####: 2982:  return parseGroupNonUniformArithmeticOp(parser, result);
call    0 never executed
        -: 2983:}
function _ZN4mlir5spirv21GroupNonUniformUMinOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 2984:void spirv::GroupNonUniformUMinOp::print(OpAsmPrinter &p) {
    #####: 2985:  printGroupNonUniformArithmeticOp(*this, p);
call    0 never executed
    #####: 2986:}
        -: 2987:
        -: 2988://===----------------------------------------------------------------------===//
        -: 2989:// spirv.IAddCarryOp
        -: 2990://===----------------------------------------------------------------------===//
        -: 2991:
function _ZN4mlir5spirv11IAddCarryOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 2992:LogicalResult spirv::IAddCarryOp::verify() {
    #####: 2993:  auto resultType = getType().cast<spirv::StructType>();
call    0 never executed
    #####: 2994:  if (resultType.getNumElements() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2995:    return emitOpError("expected result struct type containing two members");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 2996:
    #####: 2997:  if (!llvm::all_equal({getOperand1().getType(), getOperand2().getType(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2998:                        resultType.getElementType(0),
call    0 never executed
    #####: 2999:                        resultType.getElementType(1)}))
call    0 never executed
    #####: 3000:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3001:        "expected all operand types and struct member types are the same");
call    0 never executed
        -: 3002:
    #####: 3003:  return success();
        -: 3004:}
        -: 3005:
function _ZN4mlir5spirv11IAddCarryOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3006:ParseResult spirv::IAddCarryOp::parse(OpAsmParser &parser,
        -: 3007:                                      OperationState &result) {
    #####: 3008:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operands;
call    0 never executed
    #####: 3009:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3010:      parser.parseOperandList(operands) || parser.parseColon())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3011:    return failure();
        -: 3012:
    #####: 3013:  Type resultType;
    #####: 3014:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####: 3015:  if (parser.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3016:    return failure();
        -: 3017:
    #####: 3018:  auto structType = resultType.dyn_cast<spirv::StructType>();
call    0 never executed
    #####: 3019:  if (!structType || structType.getNumElements() != 2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3020:    return parser.emitError(loc, "expected spirv.struct type with two members");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3021:
    #####: 3022:  SmallVector<Type, 2> operandTypes(2, structType.getElementType(0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3023:  if (parser.resolveOperands(operands, operandTypes, loc, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3024:    return failure();
        -: 3025:
    #####: 3026:  result.addTypes(resultType);
call    0 never executed
    #####: 3027:  return success();
        -: 3028:}
        -: 3029:
function _ZN4mlir5spirv11IAddCarryOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3030:void spirv::IAddCarryOp::print(OpAsmPrinter &printer) {
    #####: 3031:  printer << ' ';
call    0 never executed
    #####: 3032:  printer.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 3033:  printer.printOperands((*this)->getOperands());
call    0 never executed
call    1 never executed
    #####: 3034:  printer << " : " << getType();
call    0 never executed
call    1 never executed
    #####: 3035:}
        -: 3036:
        -: 3037://===----------------------------------------------------------------------===//
        -: 3038:// spirv.ISubBorrowOp
        -: 3039://===----------------------------------------------------------------------===//
        -: 3040:
function _ZN4mlir5spirv12ISubBorrowOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3041:LogicalResult spirv::ISubBorrowOp::verify() {
    #####: 3042:  auto resultType = getType().cast<spirv::StructType>();
call    0 never executed
    #####: 3043:  if (resultType.getNumElements() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3044:    return emitOpError("expected result struct type containing two members");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3045:
    #####: 3046:  if (!llvm::all_equal({getOperand1().getType(), getOperand2().getType(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3047:                        resultType.getElementType(0),
call    0 never executed
    #####: 3048:                        resultType.getElementType(1)}))
call    0 never executed
    #####: 3049:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3050:        "expected all operand types and struct member types are the same");
call    0 never executed
        -: 3051:
    #####: 3052:  return success();
        -: 3053:}
        -: 3054:
function _ZN4mlir5spirv12ISubBorrowOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3055:ParseResult spirv::ISubBorrowOp::parse(OpAsmParser &parser,
        -: 3056:                                       OperationState &result) {
    #####: 3057:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operands;
call    0 never executed
    #####: 3058:  if (parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3059:      parser.parseOperandList(operands) || parser.parseColon())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3060:    return failure();
        -: 3061:
    #####: 3062:  Type resultType;
    #####: 3063:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 3064:  if (parser.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3065:    return failure();
        -: 3066:
    #####: 3067:  auto structType = resultType.dyn_cast<spirv::StructType>();
call    0 never executed
    #####: 3068:  if (!structType || structType.getNumElements() != 2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3069:    return parser.emitError(loc, "expected spirv.struct type with two members");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3070:
    #####: 3071:  SmallVector<Type, 2> operandTypes(2, structType.getElementType(0));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3072:  if (parser.resolveOperands(operands, operandTypes, loc, result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3073:    return failure();
        -: 3074:
    #####: 3075:  result.addTypes(resultType);
call    0 never executed
    #####: 3076:  return success();
        -: 3077:}
        -: 3078:
function _ZN4mlir5spirv12ISubBorrowOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3079:void spirv::ISubBorrowOp::print(OpAsmPrinter &printer) {
    #####: 3080:  printer << ' ';
call    0 never executed
    #####: 3081:  printer.printOptionalAttrDict((*this)->getAttrs());
call    0 never executed
call    1 never executed
    #####: 3082:  printer.printOperands((*this)->getOperands());
call    0 never executed
call    1 never executed
    #####: 3083:  printer << " : " << getType();
call    0 never executed
call    1 never executed
    #####: 3084:}
        -: 3085:
        -: 3086://===----------------------------------------------------------------------===//
        -: 3087:// spirv.LoadOp
        -: 3088://===----------------------------------------------------------------------===//
        -: 3089:
function _ZN4mlir5spirv6LoadOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueENS0_16MemoryAccessAttrENS_11IntegerAttrE called 0 returned 0% blocks executed 0%
    #####: 3090:void spirv::LoadOp::build(OpBuilder &builder, OperationState &state,
        -: 3091:                          Value basePtr, MemoryAccessAttr memoryAccess,
        -: 3092:                          IntegerAttr alignment) {
    #####: 3093:  auto ptrType = basePtr.getType().cast<spirv::PointerType>();
call    0 never executed
    #####: 3094:  build(builder, state, ptrType.getPointeeType(), basePtr, memoryAccess,
call    0 never executed
call    1 never executed
        -: 3095:        alignment);
    #####: 3096:}
        -: 3097:
function _ZN4mlir5spirv6LoadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3098:ParseResult spirv::LoadOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 3099:  // Parse the storage class specification
    #####: 3100:  spirv::StorageClass storageClass;
    #####: 3101:  OpAsmParser::UnresolvedOperand ptrInfo;
call    0 never executed
    #####: 3102:  Type elementType;
    #####: 3103:  if (parseEnumStrAttr(storageClass, parser) || parser.parseOperand(ptrInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3104:      parseMemoryAccessAttributes(parser, result) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3105:      parser.parseOptionalAttrDict(result.attributes) || parser.parseColon() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 3106:      parser.parseType(elementType)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3107:    return failure();
        -: 3108:  }
        -: 3109:
    #####: 3110:  auto ptrType = spirv::PointerType::get(elementType, storageClass);
call    0 never executed
    #####: 3111:  if (parser.resolveOperand(ptrInfo, ptrType, result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3112:    return failure();
        -: 3113:  }
        -: 3114:
    #####: 3115:  result.addTypes(elementType);
call    0 never executed
    #####: 3116:  return success();
        -: 3117:}
        -: 3118:
function _ZN4mlir5spirv6LoadOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3119:void spirv::LoadOp::print(OpAsmPrinter &printer) {
    #####: 3120:  SmallVector<StringRef, 4> elidedAttrs;
call    0 never executed
    #####: 3121:  StringRef sc = stringifyStorageClass(
call    0 never executed
    #####: 3122:      getPtr().getType().cast<spirv::PointerType>().getStorageClass());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3123:  printer << " \"" << sc << "\" " << getPtr();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3124:
    #####: 3125:  printMemoryAccessAttribute(*this, printer, elidedAttrs);
call    0 never executed
        -: 3126:
    #####: 3127:  printer.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
call    0 never executed
call    1 never executed
    #####: 3128:  printer << " : " << getType();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3129:}
        -: 3130:
function _ZN4mlir5spirv6LoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3131:LogicalResult spirv::LoadOp::verify() {
        -: 3132:  // SPIR-V spec : "Result Type is the type of the loaded object. It must be a
        -: 3133:  // type with fixed size; i.e., it cannot be, nor include, any
        -: 3134:  // OpTypeRuntimeArray types."
    #####: 3135:  if (failed(verifyLoadStorePtrAndValTypes(*this, getPtr(), getValue()))) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3136:    return failure();
        -: 3137:  }
    #####: 3138:  return verifyMemoryAccessAttribute(*this);
call    0 never executed
        -: 3139:}
        -: 3140:
        -: 3141://===----------------------------------------------------------------------===//
        -: 3142:// spirv.mlir.loop
        -: 3143://===----------------------------------------------------------------------===//
        -: 3144:
function _ZN4mlir5spirv6LoopOp5buildERNS_9OpBuilderERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3145:void spirv::LoopOp::build(OpBuilder &builder, OperationState &state) {
    #####: 3146:  state.addAttribute("loop_control", builder.getAttr<spirv::LoopControlAttr>(
call    0 never executed
    #####: 3147:                                         spirv::LoopControl::None));
call    0 never executed
call    1 never executed
    #####: 3148:  state.addRegion();
call    0 never executed
    #####: 3149:}
        -: 3150:
function _ZN4mlir5spirv6LoopOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3151:ParseResult spirv::LoopOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 3152:  if (parseControlAttribute<spirv::LoopControlAttr, spirv::LoopControl>(parser,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3153:                                                                        result))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3154:    return failure();
    #####: 3155:  return parser.parseRegion(*result.addRegion(), /*arguments=*/{});
call    0 never executed
call    1 never executed
        -: 3156:}
        -: 3157:
function _ZN4mlir5spirv6LoopOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3158:void spirv::LoopOp::print(OpAsmPrinter &printer) {
    #####: 3159:  auto control = getLoopControl();
call    0 never executed
    #####: 3160:  if (control != spirv::LoopControl::None)
branch  0 never executed
branch  1 never executed
    #####: 3161:    printer << " control(" << spirv::stringifyLoopControl(control) << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3162:  printer << ' ';
call    0 never executed
    #####: 3163:  printer.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
call    0 never executed
    #####: 3164:                      /*printBlockTerminators=*/true);
call    0 never executed
    #####: 3165:}
        -: 3166:
        -: 3167:/// Returns true if the given `srcBlock` contains only one `spirv.Branch` to the
        -: 3168:/// given `dstBlock`.
function _ZL16hasOneBranchOpToRN4mlir5BlockES1_ called 0 returned 0% blocks executed 0%
    #####: 3169:static inline bool hasOneBranchOpTo(Block &srcBlock, Block &dstBlock) {
        -: 3170:  // Check that there is only one op in the `srcBlock`.
    #####: 3171:  if (!llvm::hasSingleElement(srcBlock))
branch  0 never executed
branch  1 never executed
        -: 3172:    return false;
        -: 3173:
    #####: 3174:  auto branchOp = dyn_cast<spirv::BranchOp>(srcBlock.back());
call    0 never executed
call    1 never executed
    #####: 3175:  return branchOp && branchOp.getSuccessor() == &dstBlock;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3176:}
        -: 3177:
function _ZN4mlir5spirv6LoopOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 3178:LogicalResult spirv::LoopOp::verifyRegions() {
    #####: 3179:  auto *op = getOperation();
call    0 never executed
        -: 3180:
        -: 3181:  // We need to verify that the blocks follow the following layout:
        -: 3182:  //
        -: 3183:  //                     +-------------+
        -: 3184:  //                     | entry block |
        -: 3185:  //                     +-------------+
        -: 3186:  //                            |
        -: 3187:  //                            v
        -: 3188:  //                     +-------------+
        -: 3189:  //                     | loop header | <-----+
        -: 3190:  //                     +-------------+       |
        -: 3191:  //                                           |
        -: 3192:  //                           ...             |
        -: 3193:  //                          \ | /            |
        -: 3194:  //                            v              |
        -: 3195:  //                    +---------------+      |
        -: 3196:  //                    | loop continue | -----+
        -: 3197:  //                    +---------------+
        -: 3198:  //
        -: 3199:  //                           ...
        -: 3200:  //                          \ | /
        -: 3201:  //                            v
        -: 3202:  //                     +-------------+
        -: 3203:  //                     | merge block |
        -: 3204:  //                     +-------------+
        -: 3205:
    #####: 3206:  auto &region = op->getRegion(0);
call    0 never executed
        -: 3207:  // Allow empty region as a degenerated case, which can come from
        -: 3208:  // optimizations.
    #####: 3209:  if (region.empty())
branch  0 never executed
branch  1 never executed
    #####: 3210:    return success();
        -: 3211:
        -: 3212:  // The last block is the merge block.
    #####: 3213:  Block &merge = region.back();
call    0 never executed
    #####: 3214:  if (!isMergeBlock(merge))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3215:    return emitOpError("last block must be the merge block with only one "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3216:                       "'spirv.mlir.merge' op");
call    0 never executed
        -: 3217:
    #####: 3218:  if (std::next(region.begin()) == region.end())
branch  0 never executed
branch  1 never executed
    #####: 3219:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3220:        "must have an entry block branching to the loop header block");
call    0 never executed
        -: 3221:  // The first block is the entry block.
    #####: 3222:  Block &entry = region.front();
call    0 never executed
        -: 3223:
    #####: 3224:  if (std::next(region.begin(), 2) == region.end())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3225:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3226:        "must have a loop header block branched from the entry block");
call    0 never executed
        -: 3227:  // The second block is the loop header block.
    #####: 3228:  Block &header = *std::next(region.begin(), 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3229:
    #####: 3230:  if (!hasOneBranchOpTo(entry, header))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3231:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3232:        "entry block must only have one 'spirv.Branch' op to the second block");
call    0 never executed
        -: 3233:
    #####: 3234:  if (std::next(region.begin(), 3) == region.end())
branch  0 never executed
branch  1 never executed
    #####: 3235:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3236:        "requires a loop continue block branching to the loop header block");
call    0 never executed
        -: 3237:  // The second to last block is the loop continue block.
    #####: 3238:  Block &cont = *std::prev(region.end(), 2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3239:
        -: 3240:  // Make sure that we have a branch from the loop continue block to the loop
        -: 3241:  // header block.
    #####: 3242:  if (llvm::none_of(
    #####: 3243:          llvm::seq<unsigned>(0, cont.getNumSuccessors()),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3244:          [&](unsigned index) { return cont.getSuccessor(index) == &header; }))
call    0 never executed
    #####: 3245:    return emitOpError("second to last block must be the loop continue "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3246:                       "block that branches to the loop header block");
call    0 never executed
        -: 3247:
        -: 3248:  // Make sure that no other blocks (except the entry and loop continue block)
        -: 3249:  // branches to the loop header block.
    #####: 3250:  for (auto &block : llvm::make_range(std::next(region.begin(), 2),
    #####: 3251:                                      std::prev(region.end(), 2))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3252:    for (auto i : llvm::seq<unsigned>(0, block.getNumSuccessors())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3253:      if (block.getSuccessor(i) == &header) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3254:        return emitOpError("can only have the entry and loop continue "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3255:                           "block branching to the loop header block");
call    0 never executed
        -: 3256:      }
        -: 3257:    }
        -: 3258:  }
        -: 3259:
    #####: 3260:  return success();
        -: 3261:}
        -: 3262:
function _ZN4mlir5spirv6LoopOp13getEntryBlockEv called 0 returned 0% blocks executed 0%
    #####: 3263:Block *spirv::LoopOp::getEntryBlock() {
    #####: 3264:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3265:  return &getBody().front();
call    0 never executed
        -: 3266:}
        -: 3267:
function _ZN4mlir5spirv6LoopOp14getHeaderBlockEv called 0 returned 0% blocks executed 0%
    #####: 3268:Block *spirv::LoopOp::getHeaderBlock() {
    #####: 3269:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3270:  // The second block is the loop header block.
    #####: 3271:  return &*std::next(getBody().begin());
branch  0 never executed
branch  1 never executed
        -: 3272:}
        -: 3273:
function _ZN4mlir5spirv6LoopOp16getContinueBlockEv called 0 returned 0% blocks executed 0%
    #####: 3274:Block *spirv::LoopOp::getContinueBlock() {
    #####: 3275:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3276:  // The second to last block is the loop continue block.
    #####: 3277:  return &*std::prev(getBody().end(), 2);
branch  0 never executed
branch  1 never executed
        -: 3278:}
        -: 3279:
function _ZN4mlir5spirv6LoopOp13getMergeBlockEv called 0 returned 0% blocks executed 0%
    #####: 3280:Block *spirv::LoopOp::getMergeBlock() {
    #####: 3281:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3282:  // The last block is the loop merge block.
    #####: 3283:  return &getBody().back();
call    0 never executed
        -: 3284:}
        -: 3285:
function _ZN4mlir5spirv6LoopOp21addEntryAndMergeBlockEv called 0 returned 0% blocks executed 0%
    #####: 3286:void spirv::LoopOp::addEntryAndMergeBlock() {
    #####: 3287:  assert(getBody().empty() && "entry and merge block already exist");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3288:  getBody().push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3289:  auto *mergeBlock = new Block();
call    0 never executed
call    1 never executed
    #####: 3290:  getBody().push_back(mergeBlock);
call    0 never executed
call    1 never executed
    #####: 3291:  OpBuilder builder = OpBuilder::atBlockEnd(mergeBlock);
call    0 never executed
        -: 3292:
        -: 3293:  // Add a spirv.mlir.merge op into the merge block.
    #####: 3294:  builder.create<spirv::MergeOp>(getLoc());
call    0 never executed
    #####: 3295:}
        -: 3296:
        -: 3297://===----------------------------------------------------------------------===//
        -: 3298:// spirv.MemoryBarrierOp
        -: 3299://===----------------------------------------------------------------------===//
        -: 3300:
function _ZN4mlir5spirv15MemoryBarrierOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3301:LogicalResult spirv::MemoryBarrierOp::verify() {
    #####: 3302:  return verifyMemorySemantics(getOperation(), getMemorySemantics());
call    0 never executed
call    1 never executed
        -: 3303:}
        -: 3304:
        -: 3305://===----------------------------------------------------------------------===//
        -: 3306:// spirv.mlir.merge
        -: 3307://===----------------------------------------------------------------------===//
        -: 3308:
function _ZN4mlir5spirv7MergeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3309:LogicalResult spirv::MergeOp::verify() {
    #####: 3310:  auto *parentOp = (*this)->getParentOp();
branch  0 never executed
branch  1 never executed
    #####: 3311:  if (!parentOp || !isa<spirv::SelectionOp, spirv::LoopOp>(parentOp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3312:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3313:        "expected parent op to be 'spirv.mlir.selection' or 'spirv.mlir.loop'");
call    0 never executed
        -: 3314:
        -: 3315:  // TODO: This check should be done in `verifyRegions` of parent op.
    #####: 3316:  Block &parentLastBlock = (*this)->getParentRegion()->back();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3317:  if (getOperation() != parentLastBlock.getTerminator())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3318:    return emitOpError("can only be used in the last block of "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3319:                       "'spirv.mlir.selection' or 'spirv.mlir.loop'");
call    0 never executed
    #####: 3320:  return success();
        -: 3321:}
        -: 3322:
        -: 3323://===----------------------------------------------------------------------===//
        -: 3324:// spirv.module
        -: 3325://===----------------------------------------------------------------------===//
        -: 3326:
function _ZN4mlir5spirv8ModuleOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm8OptionalINS6_9StringRefEEE called 0 returned 0% blocks executed 0%
    #####: 3327:void spirv::ModuleOp::build(OpBuilder &builder, OperationState &state,
        -: 3328:                            Optional<StringRef> name) {
    #####: 3329:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 3330:  builder.createBlock(state.addRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3331:  if (name) {
branch  0 never executed
branch  1 never executed
    #####: 3332:    state.attributes.append(mlir::SymbolTable::getSymbolAttrName(),
call    0 never executed
    #####: 3333:                            builder.getStringAttr(*name));
call    0 never executed
call    1 never executed
        -: 3334:  }
    #####: 3335:}
        -: 3336:
function _ZN4mlir5spirv8ModuleOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_15AddressingModelENS0_11MemoryModelEN4llvm8OptionalINS0_13VerCapExtAttrEEENS9_INS8_9StringRefEEE called 0 returned 0% blocks executed 0%
    #####: 3337:void spirv::ModuleOp::build(OpBuilder &builder, OperationState &state,
        -: 3338:                            spirv::AddressingModel addressingModel,
        -: 3339:                            spirv::MemoryModel memoryModel,
        -: 3340:                            Optional<VerCapExtAttr> vceTriple,
        -: 3341:                            Optional<StringRef> name) {
    #####: 3342:  state.addAttribute(
call    0 never executed
        -: 3343:      "addressing_model",
    #####: 3344:      builder.getAttr<spirv::AddressingModelAttr>(addressingModel));
call    0 never executed
call    1 never executed
    #####: 3345:  state.addAttribute("memory_model",
call    0 never executed
    #####: 3346:                     builder.getAttr<spirv::MemoryModelAttr>(memoryModel));
call    0 never executed
call    1 never executed
    #####: 3347:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 3348:  builder.createBlock(state.addRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3349:  if (vceTriple)
branch  0 never executed
branch  1 never executed
    #####: 3350:    state.addAttribute(getVCETripleAttrName(), *vceTriple);
call    0 never executed
    #####: 3351:  if (name)
branch  0 never executed
branch  1 never executed
    #####: 3352:    state.addAttribute(mlir::SymbolTable::getSymbolAttrName(),
call    0 never executed
    #####: 3353:                       builder.getStringAttr(*name));
call    0 never executed
call    1 never executed
    #####: 3354:}
        -: 3355:
function _ZN4mlir5spirv8ModuleOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3356:ParseResult spirv::ModuleOp::parse(OpAsmParser &parser,
        -: 3357:                                   OperationState &result) {
    #####: 3358:  Region *body = result.addRegion();
call    0 never executed
        -: 3359:
        -: 3360:  // If the name is present, parse it.
    #####: 3361:  StringAttr nameAttr;
    #####: 3362:  (void)parser.parseOptionalSymbolName(
    #####: 3363:      nameAttr, mlir::SymbolTable::getSymbolAttrName(), result.attributes);
call    0 never executed
        -: 3364:
        -: 3365:  // Parse attributes
    #####: 3366:  spirv::AddressingModel addrModel;
    #####: 3367:  spirv::MemoryModel memoryModel;
    #####: 3368:  if (::parseEnumKeywordAttr<spirv::AddressingModelAttr>(addrModel, parser,
call    0 never executed
    #####: 3369:                                                         result) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3370:      ::parseEnumKeywordAttr<spirv::MemoryModelAttr>(memoryModel, parser,
    #####: 3371:                                                     result))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3372:    return failure();
        -: 3373:
    #####: 3374:  if (succeeded(parser.parseOptionalKeyword("requires"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3375:    spirv::VerCapExtAttr vceTriple;
    #####: 3376:    if (parser.parseAttribute(vceTriple,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3377:                              spirv::ModuleOp::getVCETripleAttrName(),
    #####: 3378:                              result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3379:      return failure();
        -: 3380:  }
        -: 3381:
    #####: 3382:  if (parser.parseOptionalAttrDictWithKeyword(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3383:      parser.parseRegion(*body, /*arguments=*/{}))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3384:    return failure();
        -: 3385:
        -: 3386:  // Make sure we have at least one block.
    #####: 3387:  if (body->empty())
branch  0 never executed
branch  1 never executed
    #####: 3388:    body->push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3389:
    #####: 3390:  return success();
        -: 3391:}
        -: 3392:
function _ZN4mlir5spirv8ModuleOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3393:void spirv::ModuleOp::print(OpAsmPrinter &printer) {
    #####: 3394:  if (Optional<StringRef> name = getName()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3395:    printer << ' ';
call    0 never executed
    #####: 3396:    printer.printSymbolName(*name);
call    0 never executed
        -: 3397:  }
        -: 3398:
    #####: 3399:  SmallVector<StringRef, 2> elidedAttrs;
call    0 never executed
        -: 3400:
    #####: 3401:  printer << " " << spirv::stringifyAddressingModel(getAddressingModel()) << " "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 3402:          << spirv::stringifyMemoryModel(getMemoryModel());
call    0 never executed
call    1 never executed
    #####: 3403:  auto addressingModelAttrName = spirv::attributeName<spirv::AddressingModel>();
call    0 never executed
    #####: 3404:  auto memoryModelAttrName = spirv::attributeName<spirv::MemoryModel>();
call    0 never executed
    #####: 3405:  elidedAttrs.assign({addressingModelAttrName, memoryModelAttrName,
call    0 never executed
    #####: 3406:                      mlir::SymbolTable::getSymbolAttrName()});
call    0 never executed
        -: 3407:
    #####: 3408:  if (Optional<spirv::VerCapExtAttr> triple = getVceTriple()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3409:    printer << " requires " << *triple;
call    0 never executed
call    1 never executed
    #####: 3410:    elidedAttrs.push_back(spirv::ModuleOp::getVCETripleAttrName());
call    0 never executed
        -: 3411:  }
        -: 3412:
    #####: 3413:  printer.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
call    0 never executed
call    1 never executed
    #####: 3414:  printer << ' ';
call    0 never executed
    #####: 3415:  printer.printRegion(getRegion());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3416:}
        -: 3417:
function _ZN4mlir5spirv8ModuleOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 3418:LogicalResult spirv::ModuleOp::verifyRegions() {
    #####: 3419:  Dialect *dialect = (*this)->getDialect();
branch  0 never executed
branch  1 never executed
    #####: 3420:  DenseMap<std::pair<spirv::FuncOp, spirv::ExecutionModel>, spirv::EntryPointOp>
call    0 never executed
    #####: 3421:      entryPoints;
    #####: 3422:  mlir::SymbolTable table(*this);
call    0 never executed
call    1 never executed
        -: 3423:
    #####: 3424:  for (auto &op : *getBody()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3425:    if (op.getDialect() != dialect)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3426:      return op.emitError("'spirv.module' can only contain spirv.* ops");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3427:
        -: 3428:    // For EntryPoint op, check that the function and execution model is not
        -: 3429:    // duplicated in EntryPointOps. Also verify that the interface specified
        -: 3430:    // comes from globalVariables here to make this check cheaper.
    #####: 3431:    if (auto entryPointOp = dyn_cast<spirv::EntryPointOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3432:      auto funcOp = table.lookup<spirv::FuncOp>(entryPointOp.getFn());
call    0 never executed
call    1 never executed
    #####: 3433:      if (!funcOp) {
branch  0 never executed
branch  1 never executed
    #####: 3434:        return entryPointOp.emitError("function '")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3435:               << entryPointOp.getFn() << "' not found in 'spirv.module'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3436:      }
    #####: 3437:      if (auto interface = entryPointOp.getInterface()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3438:        for (Attribute varRef : interface) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3439:          auto varSymRef = varRef.dyn_cast<FlatSymbolRefAttr>();
call    0 never executed
    #####: 3440:          if (!varSymRef) {
branch  0 never executed
branch  1 never executed
    #####: 3441:            return entryPointOp.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3442:                       "expected symbol reference for interface "
        -: 3443:                       "specification instead of '")
    #####: 3444:                   << varRef;
call    0 never executed
        -: 3445:          }
    #####: 3446:          auto variableOp =
    #####: 3447:              table.lookup<spirv::GlobalVariableOp>(varSymRef.getValue());
call    0 never executed
call    1 never executed
    #####: 3448:          if (!variableOp) {
branch  0 never executed
branch  1 never executed
    #####: 3449:            return entryPointOp.emitError("expected spirv.GlobalVariable "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3450:                                          "symbol reference instead of'")
    #####: 3451:                   << varSymRef << "'";
call    0 never executed
call    1 never executed
        -: 3452:          }
        -: 3453:        }
        -: 3454:      }
        -: 3455:
    #####: 3456:      auto key = std::pair<spirv::FuncOp, spirv::ExecutionModel>(
call    0 never executed
    #####: 3457:          funcOp, entryPointOp.getExecutionModel());
call    0 never executed
    #####: 3458:      auto entryPtIt = entryPoints.find(key);
call    0 never executed
    #####: 3459:      if (entryPtIt != entryPoints.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3460:        return entryPointOp.emitError("duplicate of a previous EntryPointOp");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3461:      }
    #####: 3462:      entryPoints[key] = entryPointOp;
call    0 never executed
    #####: 3463:    } else if (auto funcOp = dyn_cast<spirv::FuncOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3464:      if (funcOp.isExternal())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3465:        return op.emitError("'spirv.module' cannot contain external functions");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3466:
        -: 3467:      // TODO: move this check to spirv.func.
    #####: 3468:      for (auto &block : funcOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3469:        for (auto &op : block) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3470:          if (op.getDialect() != dialect)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3471:            return op.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3472:                "functions in 'spirv.module' can only contain spirv.* ops");
call    0 never executed
        -: 3473:        }
        -: 3474:    }
        -: 3475:  }
        -: 3476:
    #####: 3477:  return success();
call    0 never executed
        -: 3478:}
        -: 3479:
        -: 3480://===----------------------------------------------------------------------===//
        -: 3481:// spirv.mlir.referenceof
        -: 3482://===----------------------------------------------------------------------===//
        -: 3483:
function _ZN4mlir5spirv13ReferenceOfOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3484:LogicalResult spirv::ReferenceOfOp::verify() {
    #####: 3485:  auto *specConstSym = SymbolTable::lookupNearestSymbolFrom(
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 3486:      (*this)->getParentOp(), getSpecConstAttr());
call    0 never executed
    #####: 3487:  Type constType;
        -: 3488:
    #####: 3489:  auto specConstOp = dyn_cast_or_null<spirv::SpecConstantOp>(specConstSym);
branch  0 never executed
branch  1 never executed
    #####: 3490:  if (specConstOp)
branch  0 never executed
branch  1 never executed
    #####: 3491:    constType = specConstOp.getDefaultValue().getType();
call    0 never executed
call    1 never executed
        -: 3492:
    #####: 3493:  auto specConstCompositeOp =
branch  0 never executed
branch  1 never executed
    #####: 3494:      dyn_cast_or_null<spirv::SpecConstantCompositeOp>(specConstSym);
    #####: 3495:  if (specConstCompositeOp)
branch  0 never executed
branch  1 never executed
    #####: 3496:    constType = specConstCompositeOp.getType();
call    0 never executed
        -: 3497:
    #####: 3498:  if (!specConstOp && !specConstCompositeOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3499:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3500:        "expected spirv.SpecConstant or spirv.SpecConstantComposite symbol");
call    0 never executed
        -: 3501:
    #####: 3502:  if (getReference().getType() != constType)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3503:    return emitOpError("result type mismatch with the referenced "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3504:                       "specialization constant's type");
call    0 never executed
        -: 3505:
    #####: 3506:  return success();
        -: 3507:}
        -: 3508:
        -: 3509://===----------------------------------------------------------------------===//
        -: 3510:// spirv.Return
        -: 3511://===----------------------------------------------------------------------===//
        -: 3512:
function _ZN4mlir5spirv8ReturnOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3513:LogicalResult spirv::ReturnOp::verify() {
        -: 3514:  // Verification is performed in spirv.func op.
    #####: 3515:  return success();
        -: 3516:}
        -: 3517:
        -: 3518://===----------------------------------------------------------------------===//
        -: 3519:// spirv.ReturnValue
        -: 3520://===----------------------------------------------------------------------===//
        -: 3521:
function _ZN4mlir5spirv13ReturnValueOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3522:LogicalResult spirv::ReturnValueOp::verify() {
        -: 3523:  // Verification is performed in spirv.func op.
    #####: 3524:  return success();
        -: 3525:}
        -: 3526:
        -: 3527://===----------------------------------------------------------------------===//
        -: 3528:// spirv.Select
        -: 3529://===----------------------------------------------------------------------===//
        -: 3530:
function _ZN4mlir5spirv8SelectOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3531:LogicalResult spirv::SelectOp::verify() {
    #####: 3532:  if (auto conditionTy = getCondition().getType().dyn_cast<VectorType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3533:    auto resultVectorTy = getResult().getType().dyn_cast<VectorType>();
call    0 never executed
call    1 never executed
    #####: 3534:    if (!resultVectorTy) {
branch  0 never executed
branch  1 never executed
    #####: 3535:      return emitOpError("result expected to be of vector type when "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3536:                         "condition is of vector type");
call    0 never executed
        -: 3537:    }
    #####: 3538:    if (resultVectorTy.getNumElements() != conditionTy.getNumElements()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3539:      return emitOpError("result should have the same number of elements as "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3540:                         "the condition when condition is of vector type");
call    0 never executed
        -: 3541:    }
        -: 3542:  }
    #####: 3543:  return success();
        -: 3544:}
        -: 3545:
        -: 3546://===----------------------------------------------------------------------===//
        -: 3547:// spirv.mlir.selection
        -: 3548://===----------------------------------------------------------------------===//
        -: 3549:
function _ZN4mlir5spirv11SelectionOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3550:ParseResult spirv::SelectionOp::parse(OpAsmParser &parser,
        -: 3551:                                      OperationState &result) {
    #####: 3552:  if (parseControlAttribute<spirv::SelectionControlAttr,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3553:                            spirv::SelectionControl>(parser, result))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3554:    return failure();
    #####: 3555:  return parser.parseRegion(*result.addRegion(), /*arguments=*/{});
call    0 never executed
call    1 never executed
        -: 3556:}
        -: 3557:
function _ZN4mlir5spirv11SelectionOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3558:void spirv::SelectionOp::print(OpAsmPrinter &printer) {
    #####: 3559:  auto control = getSelectionControl();
call    0 never executed
    #####: 3560:  if (control != spirv::SelectionControl::None)
branch  0 never executed
branch  1 never executed
    #####: 3561:    printer << " control(" << spirv::stringifySelectionControl(control) << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3562:  printer << ' ';
call    0 never executed
    #####: 3563:  printer.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
call    0 never executed
    #####: 3564:                      /*printBlockTerminators=*/true);
call    0 never executed
    #####: 3565:}
        -: 3566:
function _ZN4mlir5spirv11SelectionOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 3567:LogicalResult spirv::SelectionOp::verifyRegions() {
    #####: 3568:  auto *op = getOperation();
call    0 never executed
        -: 3569:
        -: 3570:  // We need to verify that the blocks follow the following layout:
        -: 3571:  //
        -: 3572:  //                     +--------------+
        -: 3573:  //                     | header block |
        -: 3574:  //                     +--------------+
        -: 3575:  //                          / | \
        -: 3576:  //                           ...
        -: 3577:  //
        -: 3578:  //
        -: 3579:  //         +---------+   +---------+   +---------+
        -: 3580:  //         | case #0 |   | case #1 |   | case #2 |  ...
        -: 3581:  //         +---------+   +---------+   +---------+
        -: 3582:  //
        -: 3583:  //
        -: 3584:  //                           ...
        -: 3585:  //                          \ | /
        -: 3586:  //                            v
        -: 3587:  //                     +-------------+
        -: 3588:  //                     | merge block |
        -: 3589:  //                     +-------------+
        -: 3590:
    #####: 3591:  auto &region = op->getRegion(0);
call    0 never executed
        -: 3592:  // Allow empty region as a degenerated case, which can come from
        -: 3593:  // optimizations.
    #####: 3594:  if (region.empty())
branch  0 never executed
branch  1 never executed
    #####: 3595:    return success();
        -: 3596:
        -: 3597:  // The last block is the merge block.
    #####: 3598:  if (!isMergeBlock(region.back()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3599:    return emitOpError("last block must be the merge block with only one "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3600:                       "'spirv.mlir.merge' op");
call    0 never executed
        -: 3601:
    #####: 3602:  if (std::next(region.begin()) == region.end())
branch  0 never executed
branch  1 never executed
    #####: 3603:    return emitOpError("must have a selection header block");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3604:
    #####: 3605:  return success();
        -: 3606:}
        -: 3607:
function _ZN4mlir5spirv11SelectionOp14getHeaderBlockEv called 0 returned 0% blocks executed 0%
    #####: 3608:Block *spirv::SelectionOp::getHeaderBlock() {
    #####: 3609:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3610:  // The first block is the loop header block.
    #####: 3611:  return &getBody().front();
call    0 never executed
        -: 3612:}
        -: 3613:
function _ZN4mlir5spirv11SelectionOp13getMergeBlockEv called 0 returned 0% blocks executed 0%
    #####: 3614:Block *spirv::SelectionOp::getMergeBlock() {
    #####: 3615:  assert(!getBody().empty() && "op region should not be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 3616:  // The last block is the loop merge block.
    #####: 3617:  return &getBody().back();
call    0 never executed
        -: 3618:}
        -: 3619:
function _ZN4mlir5spirv11SelectionOp13addMergeBlockEv called 0 returned 0% blocks executed 0%
    #####: 3620:void spirv::SelectionOp::addMergeBlock() {
    #####: 3621:  assert(getBody().empty() && "entry and merge block already exist");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 3622:  auto *mergeBlock = new Block();
call    0 never executed
call    1 never executed
    #####: 3623:  getBody().push_back(mergeBlock);
call    0 never executed
call    1 never executed
    #####: 3624:  OpBuilder builder = OpBuilder::atBlockEnd(mergeBlock);
call    0 never executed
        -: 3625:
        -: 3626:  // Add a spirv.mlir.merge op into the merge block.
    #####: 3627:  builder.create<spirv::MergeOp>(getLoc());
call    0 never executed
    #####: 3628:}
        -: 3629:
function _ZN4mlir5spirv11SelectionOp12createIfThenENS_8LocationENS_5ValueEN4llvm12function_refIFvRNS_9OpBuilderEEEES7_ called 0 returned 0% blocks executed 0%
    #####: 3630:spirv::SelectionOp spirv::SelectionOp::createIfThen(
        -: 3631:    Location loc, Value condition,
        -: 3632:    function_ref<void(OpBuilder &builder)> thenBody, OpBuilder &builder) {
    #####: 3633:  auto selectionOp =
    #####: 3634:      builder.create<spirv::SelectionOp>(loc, spirv::SelectionControl::None);
call    0 never executed
        -: 3635:
    #####: 3636:  selectionOp.addMergeBlock();
call    0 never executed
    #####: 3637:  Block *mergeBlock = selectionOp.getMergeBlock();
call    0 never executed
    #####: 3638:  Block *thenBlock = nullptr;
        -: 3639:
        -: 3640:  // Build the "then" block.
    #####: 3641:  {
    #####: 3642:    OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 3643:    thenBlock = builder.createBlock(mergeBlock);
call    0 never executed
call    1 never executed
    #####: 3644:    thenBody(builder);
call    0 never executed
    #####: 3645:    builder.create<spirv::BranchOp>(loc, mergeBlock);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3646:  }
        -: 3647:
        -: 3648:  // Build the header block.
    #####: 3649:  {
    #####: 3650:    OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####: 3651:    builder.createBlock(thenBlock);
call    0 never executed
call    1 never executed
    #####: 3652:    builder.create<spirv::BranchConditionalOp>(
        -: 3653:        loc, condition, thenBlock,
    #####: 3654:        /*trueArguments=*/ArrayRef<Value>(), mergeBlock,
call    0 never executed
    #####: 3655:        /*falseArguments=*/ArrayRef<Value>());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3656:  }
        -: 3657:
    #####: 3658:  return selectionOp;
        -: 3659:}
        -: 3660:
        -: 3661://===----------------------------------------------------------------------===//
        -: 3662:// spirv.SpecConstant
        -: 3663://===----------------------------------------------------------------------===//
        -: 3664:
function _ZN4mlir5spirv14SpecConstantOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3665:ParseResult spirv::SpecConstantOp::parse(OpAsmParser &parser,
        -: 3666:                                         OperationState &result) {
    #####: 3667:  StringAttr nameAttr;
    #####: 3668:  Attribute valueAttr;
        -: 3669:
    #####: 3670:  if (parser.parseSymbolName(nameAttr, SymbolTable::getSymbolAttrName(),
branch  0 never executed
branch  1 never executed
    #####: 3671:                             result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3672:    return failure();
        -: 3673:
        -: 3674:  // Parse optional spec_id.
    #####: 3675:  if (succeeded(parser.parseOptionalKeyword(kSpecIdAttrName))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3676:    IntegerAttr specIdAttr;
    #####: 3677:    if (parser.parseLParen() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3678:        parser.parseAttribute(specIdAttr, kSpecIdAttrName, result.attributes) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 3679:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3680:      return failure();
        -: 3681:  }
        -: 3682:
    #####: 3683:  if (parser.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 3684:      parser.parseAttribute(valueAttr, kDefaultValueAttrName,
    #####: 3685:                            result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3686:    return failure();
        -: 3687:
    #####: 3688:  return success();
        -: 3689:}
        -: 3690:
function _ZN4mlir5spirv14SpecConstantOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3691:void spirv::SpecConstantOp::print(OpAsmPrinter &printer) {
    #####: 3692:  printer << ' ';
call    0 never executed
    #####: 3693:  printer.printSymbolName(getSymName());
call    0 never executed
call    1 never executed
    #####: 3694:  if (auto specID = (*this)->getAttrOfType<IntegerAttr>(kSpecIdAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3695:    printer << ' ' << kSpecIdAttrName << '(' << specID.getInt() << ')';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 3696:  printer << " = " << getDefaultValue();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3697:}
        -: 3698:
function _ZN4mlir5spirv14SpecConstantOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3699:LogicalResult spirv::SpecConstantOp::verify() {
    #####: 3700:  if (auto specID = (*this)->getAttrOfType<IntegerAttr>(kSpecIdAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3701:    if (specID.getValue().isNegative())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3702:      return emitOpError("SpecId cannot be negative");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3703:
    #####: 3704:  auto value = getDefaultValue();
call    0 never executed
    #####: 3705:  if (value.isa<IntegerAttr, FloatAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3706:    // Make sure bitwidth is allowed.
    #####: 3707:    if (!value.getType().isa<spirv::SPIRVType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3708:      return emitOpError("default value bitwidth disallowed");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3709:    return success();
        -: 3710:  }
    #####: 3711:  return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3712:      "default value can only be a bool, integer, or float scalar");
call    0 never executed
        -: 3713:}
        -: 3714:
        -: 3715://===----------------------------------------------------------------------===//
        -: 3716:// spirv.StoreOp
        -: 3717://===----------------------------------------------------------------------===//
        -: 3718:
function _ZN4mlir5spirv7StoreOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3719:ParseResult spirv::StoreOp::parse(OpAsmParser &parser, OperationState &result) {
        -: 3720:  // Parse the storage class specification
    #####: 3721:  spirv::StorageClass storageClass;
    #####: 3722:  SmallVector<OpAsmParser::UnresolvedOperand, 2> operandInfo;
call    0 never executed
    #####: 3723:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 3724:  Type elementType;
    #####: 3725:  if (parseEnumStrAttr(storageClass, parser) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3726:      parser.parseOperandList(operandInfo, 2) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3727:      parseMemoryAccessAttributes(parser, result) || parser.parseColon() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 3728:      parser.parseType(elementType)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3729:    return failure();
        -: 3730:  }
        -: 3731:
    #####: 3732:  auto ptrType = spirv::PointerType::get(elementType, storageClass);
call    0 never executed
    #####: 3733:  if (parser.resolveOperands(operandInfo, {ptrType, elementType}, loc,
branch  0 never executed
branch  1 never executed
    #####: 3734:                             result.operands)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3735:    return failure();
        -: 3736:  }
    #####: 3737:  return success();
        -: 3738:}
        -: 3739:
function _ZN4mlir5spirv7StoreOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3740:void spirv::StoreOp::print(OpAsmPrinter &printer) {
    #####: 3741:  SmallVector<StringRef, 4> elidedAttrs;
call    0 never executed
    #####: 3742:  StringRef sc = stringifyStorageClass(
call    0 never executed
    #####: 3743:      getPtr().getType().cast<spirv::PointerType>().getStorageClass());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3744:  printer << " \"" << sc << "\" " << getPtr() << ", " << getValue();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 3745:
    #####: 3746:  printMemoryAccessAttribute(*this, printer, elidedAttrs);
call    0 never executed
        -: 3747:
    #####: 3748:  printer << " : " << getValue().getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3749:  printer.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3750:}
        -: 3751:
function _ZN4mlir5spirv7StoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3752:LogicalResult spirv::StoreOp::verify() {
        -: 3753:  // SPIR-V spec : "Pointer is the pointer to store through. Its type must be an
        -: 3754:  // OpTypePointer whose Type operand is the same as the type of Object."
    #####: 3755:  if (failed(verifyLoadStorePtrAndValTypes(*this, getPtr(), getValue())))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3756:    return failure();
    #####: 3757:  return verifyMemoryAccessAttribute(*this);
call    0 never executed
        -: 3758:}
        -: 3759:
        -: 3760://===----------------------------------------------------------------------===//
        -: 3761:// spirv.Unreachable
        -: 3762://===----------------------------------------------------------------------===//
        -: 3763:
function _ZN4mlir5spirv13UnreachableOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3764:LogicalResult spirv::UnreachableOp::verify() {
    #####: 3765:  auto *block = (*this)->getBlock();
call    0 never executed
        -: 3766:  // Fast track: if this is in entry block, its invalid. Otherwise, if no
        -: 3767:  // predecessors, it's valid.
    #####: 3768:  if (block->isEntryBlock())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3769:    return emitOpError("cannot be used in reachable block");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3770:  if (block->hasNoPredecessors())
branch  0 never executed
branch  1 never executed
    #####: 3771:    return success();
        -: 3772:
        -: 3773:  // TODO: further verification needs to analyze reachability from
        -: 3774:  // the entry block.
        -: 3775:
    #####: 3776:  return success();
        -: 3777:}
        -: 3778:
        -: 3779://===----------------------------------------------------------------------===//
        -: 3780:// spirv.Variable
        -: 3781://===----------------------------------------------------------------------===//
        -: 3782:
function _ZN4mlir5spirv10VariableOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3783:ParseResult spirv::VariableOp::parse(OpAsmParser &parser,
        -: 3784:                                     OperationState &result) {
        -: 3785:  // Parse optional initializer
    #####: 3786:  Optional<OpAsmParser::UnresolvedOperand> initInfo;
    #####: 3787:  if (succeeded(parser.parseOptionalKeyword("init"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3788:    initInfo = OpAsmParser::UnresolvedOperand();
branch  0 never executed
branch  1 never executed
    #####: 3789:    if (parser.parseLParen() || parser.parseOperand(*initInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 3790:        parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3791:      return failure();
        -: 3792:  }
        -: 3793:
    #####: 3794:  if (parseVariableDecorations(parser, result)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3795:    return failure();
        -: 3796:  }
        -: 3797:
        -: 3798:  // Parse result pointer type
    #####: 3799:  Type type;
    #####: 3800:  if (parser.parseColon())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3801:    return failure();
    #####: 3802:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 3803:  if (parser.parseType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3804:    return failure();
        -: 3805:
    #####: 3806:  auto ptrType = type.dyn_cast<spirv::PointerType>();
call    0 never executed
    #####: 3807:  if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####: 3808:    return parser.emitError(loc, "expected spirv.ptr type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3809:  result.addTypes(ptrType);
call    0 never executed
        -: 3810:
        -: 3811:  // Resolve the initializer operand
    #####: 3812:  if (initInfo) {
branch  0 never executed
branch  1 never executed
    #####: 3813:    if (parser.resolveOperand(*initInfo, ptrType.getPointeeType(),
branch  0 never executed
branch  1 never executed
    #####: 3814:                              result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3815:      return failure();
        -: 3816:  }
        -: 3817:
    #####: 3818:  auto attr = parser.getBuilder().getAttr<spirv::StorageClassAttr>(
call    0 never executed
    #####: 3819:      ptrType.getStorageClass());
call    0 never executed
call    1 never executed
    #####: 3820:  result.addAttribute(spirv::attributeName<spirv::StorageClass>(), attr);
call    0 never executed
        -: 3821:
    #####: 3822:  return success();
        -: 3823:}
        -: 3824:
function _ZN4mlir5spirv10VariableOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3825:void spirv::VariableOp::print(OpAsmPrinter &printer) {
    #####: 3826:  SmallVector<StringRef, 4> elidedAttrs{
call    0 never executed
    #####: 3827:      spirv::attributeName<spirv::StorageClass>()};
call    0 never executed
        -: 3828:  // Print optional initializer
    #####: 3829:  if (getNumOperands() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3830:    printer << " init(" << getInitializer() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3831:
    #####: 3832:  printVariableDecorations(*this, printer, elidedAttrs);
call    0 never executed
    #####: 3833:  printer << " : " << getType();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3834:}
        -: 3835:
function _ZN4mlir5spirv10VariableOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3836:LogicalResult spirv::VariableOp::verify() {
        -: 3837:  // SPIR-V spec: "Storage Class is the Storage Class of the memory holding the
        -: 3838:  // object. It cannot be Generic. It must be the same as the Storage Class
        -: 3839:  // operand of the Result Type."
    #####: 3840:  if (getStorageClass() != spirv::StorageClass::Function) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3841:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3842:        "can only be used to model function-level variables. Use "
    #####: 3843:        "spirv.GlobalVariable for module-level variables.");
call    0 never executed
        -: 3844:  }
        -: 3845:
    #####: 3846:  auto pointerType = getPointer().getType().cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####: 3847:  if (getStorageClass() != pointerType.getStorageClass())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3848:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3849:        "storage class must match result pointer's storage class");
call    0 never executed
        -: 3850:
    #####: 3851:  if (getNumOperands() != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3852:    // SPIR-V spec: "Initializer must be an <id> from a constant instruction or
        -: 3853:    // a global (module scope) OpVariable instruction".
    #####: 3854:    auto *initOp = getOperand(0).getDefiningOp();
call    0 never executed
call    1 never executed
    #####: 3855:    if (!initOp || !isa<spirv::ConstantOp,    // for normal constant
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3856:                        spirv::ReferenceOfOp, // for spec constant
    #####: 3857:                        spirv::AddressOfOp>(initOp))
call    0 never executed
    #####: 3858:      return emitOpError("initializer must be the result of a "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3859:                         "constant or spirv.GlobalVariable op");
call    0 never executed
        -: 3860:  }
        -: 3861:
        -: 3862:  // TODO: generate these strings using ODS.
    #####: 3863:  auto *op = getOperation();
call    0 never executed
    #####: 3864:  auto descriptorSetName = llvm::convertToSnakeFromCamelCase(
    #####: 3865:      stringifyDecoration(spirv::Decoration::DescriptorSet));
call    0 never executed
call    1 never executed
    #####: 3866:  auto bindingName = llvm::convertToSnakeFromCamelCase(
    #####: 3867:      stringifyDecoration(spirv::Decoration::Binding));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3868:  auto builtInName = llvm::convertToSnakeFromCamelCase(
    #####: 3869:      stringifyDecoration(spirv::Decoration::BuiltIn));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 3870:
    #####: 3871:  for (const auto &attr : {descriptorSetName, bindingName, builtInName}) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 3872:    if (op->getAttr(attr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3873:      return emitOpError("cannot have '")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3874:             << attr << "' attribute (only allowed in spirv.GlobalVariable)";
call    0 never executed
call    1 never executed
        -: 3875:  }
        -: 3876:
    #####: 3877:  return success();
branch  0 never executed
branch  1 never executed
        -: 3878:}
        -: 3879:
        -: 3880://===----------------------------------------------------------------------===//
        -: 3881:// spirv.VectorShuffle
        -: 3882://===----------------------------------------------------------------------===//
        -: 3883:
function _ZN4mlir5spirv15VectorShuffleOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3884:LogicalResult spirv::VectorShuffleOp::verify() {
    #####: 3885:  VectorType resultType = getType().cast<VectorType>();
call    0 never executed
call    1 never executed
        -: 3886:
    #####: 3887:  size_t numResultElements = resultType.getNumElements();
call    0 never executed
    #####: 3888:  if (numResultElements != getComponents().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3889:    return emitOpError("result type element count (")
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3890:           << numResultElements
call    0 never executed
    #####: 3891:           << ") mismatch with the number of component selectors ("
call    0 never executed
    #####: 3892:           << getComponents().size() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 3893:
    #####: 3894:  size_t totalSrcElements =
    #####: 3895:      getVector1().getType().cast<VectorType>().getNumElements() +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 3896:      getVector2().getType().cast<VectorType>().getNumElements();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3897:
    #####: 3898:  for (const auto &selector : getComponents().getAsValueRange<IntegerAttr>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 3899:    uint32_t index = selector.getZExtValue();
call    0 never executed
    #####: 3900:    if (index >= totalSrcElements &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3901:        index != std::numeric_limits<uint32_t>().max())
    #####: 3902:      return emitOpError("component selector ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3903:             << index << " out of range: expected to be in [0, "
call    0 never executed
call    1 never executed
    #####: 3904:             << totalSrcElements << ") or 0xffffffff";
call    0 never executed
call    1 never executed
        -: 3905:  }
    #####: 3906:  return success();
        -: 3907:}
        -: 3908:
        -: 3909://===----------------------------------------------------------------------===//
        -: 3910:// spirv.NV.CooperativeMatrixLoad
        -: 3911://===----------------------------------------------------------------------===//
        -: 3912:
function _ZN4mlir5spirv25NVCooperativeMatrixLoadOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3913:ParseResult spirv::NVCooperativeMatrixLoadOp::parse(OpAsmParser &parser,
        -: 3914:                                                    OperationState &result) {
    #####: 3915:  SmallVector<OpAsmParser::UnresolvedOperand, 3> operandInfo;
call    0 never executed
    #####: 3916:  Type strideType = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####: 3917:  Type columnMajorType = parser.getBuilder().getIntegerType(1);
call    0 never executed
call    1 never executed
    #####: 3918:  Type ptrType;
    #####: 3919:  Type elementType;
    #####: 3920:  if (parser.parseOperandList(operandInfo, 3) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3921:      parseMemoryAccessAttributes(parser, result) || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3922:      parser.parseType(ptrType) || parser.parseKeywordType("as", elementType)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3923:    return failure();
        -: 3924:  }
    #####: 3925:  if (parser.resolveOperands(operandInfo,
branch  0 never executed
branch  1 never executed
        -: 3926:                             {ptrType, strideType, columnMajorType},
    #####: 3927:                             parser.getNameLoc(), result.operands)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3928:    return failure();
        -: 3929:  }
        -: 3930:
    #####: 3931:  result.addTypes(elementType);
call    0 never executed
    #####: 3932:  return success();
        -: 3933:}
        -: 3934:
function _ZN4mlir5spirv25NVCooperativeMatrixLoadOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3935:void spirv::NVCooperativeMatrixLoadOp::print(OpAsmPrinter &printer) {
    #####: 3936:  printer << " " << getPointer() << ", " << getStride() << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####: 3937:          << getColumnmajor();
call    0 never executed
call    1 never executed
        -: 3938:  // Print optional memory access attribute.
    #####: 3939:  if (auto memAccess = getMemoryAccess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3940:    printer << " [\"" << stringifyMemoryAccess(*memAccess) << "\"]";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3941:  printer << " : " << getPointer().getType() << " as " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 3942:}
        -: 3943:
        -: 3944:static LogicalResult verifyPointerAndCoopMatrixType(Operation *op, Type pointer,
        -: 3945:                                                    Type coopMatrix) {
        -: 3946:  Type pointeeType = pointer.cast<spirv::PointerType>().getPointeeType();
        -: 3947:  if (!pointeeType.isa<spirv::ScalarType>() && !pointeeType.isa<VectorType>())
        -: 3948:    return op->emitError(
        -: 3949:               "Pointer must point to a scalar or vector type but provided ")
        -: 3950:           << pointeeType;
        -: 3951:  spirv::StorageClass storage =
        -: 3952:      pointer.cast<spirv::PointerType>().getStorageClass();
        -: 3953:  if (storage != spirv::StorageClass::Workgroup &&
        -: 3954:      storage != spirv::StorageClass::StorageBuffer &&
        -: 3955:      storage != spirv::StorageClass::PhysicalStorageBuffer)
        -: 3956:    return op->emitError(
        -: 3957:               "Pointer storage class must be Workgroup, StorageBuffer or "
        -: 3958:               "PhysicalStorageBufferEXT but provided ")
        -: 3959:           << stringifyStorageClass(storage);
        -: 3960:  return success();
        -: 3961:}
        -: 3962:
function _ZN4mlir5spirv25NVCooperativeMatrixLoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 3963:LogicalResult spirv::NVCooperativeMatrixLoadOp::verify() {
    #####: 3964:  return verifyPointerAndCoopMatrixType(*this, getPointer().getType(),
    #####: 3965:                                        getResult().getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3966:}
        -: 3967:
        -: 3968://===----------------------------------------------------------------------===//
        -: 3969:// spirv.NV.CooperativeMatrixStore
        -: 3970://===----------------------------------------------------------------------===//
        -: 3971:
function _ZN4mlir5spirv26NVCooperativeMatrixStoreOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 3972:ParseResult spirv::NVCooperativeMatrixStoreOp::parse(OpAsmParser &parser,
        -: 3973:                                                     OperationState &result) {
    #####: 3974:  SmallVector<OpAsmParser::UnresolvedOperand, 4> operandInfo;
call    0 never executed
    #####: 3975:  Type strideType = parser.getBuilder().getIntegerType(32);
call    0 never executed
call    1 never executed
    #####: 3976:  Type columnMajorType = parser.getBuilder().getIntegerType(1);
call    0 never executed
call    1 never executed
    #####: 3977:  Type ptrType;
    #####: 3978:  Type elementType;
    #####: 3979:  if (parser.parseOperandList(operandInfo, 4) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3980:      parseMemoryAccessAttributes(parser, result) || parser.parseColon() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 3981:      parser.parseType(ptrType) || parser.parseComma() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 3982:      parser.parseType(elementType)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3983:    return failure();
        -: 3984:  }
    #####: 3985:  if (parser.resolveOperands(
branch  0 never executed
branch  1 never executed
        -: 3986:          operandInfo, {ptrType, elementType, strideType, columnMajorType},
    #####: 3987:          parser.getNameLoc(), result.operands)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3988:    return failure();
        -: 3989:  }
        -: 3990:
    #####: 3991:  return success();
        -: 3992:}
        -: 3993:
function _ZN4mlir5spirv26NVCooperativeMatrixStoreOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 3994:void spirv::NVCooperativeMatrixStoreOp::print(OpAsmPrinter &printer) {
    #####: 3995:  printer << " " << getPointer() << ", " << getObject() << ", " << getStride()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 3996:          << ", " << getColumnmajor();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3997:  // Print optional memory access attribute.
    #####: 3998:  if (auto memAccess = getMemoryAccess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3999:    printer << " [\"" << stringifyMemoryAccess(*memAccess) << "\"]";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4000:  printer << " : " << getPointer().getType() << ", " << getOperand(1).getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 4001:}
        -: 4002:
function _ZN4mlir5spirv26NVCooperativeMatrixStoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4003:LogicalResult spirv::NVCooperativeMatrixStoreOp::verify() {
    #####: 4004:  return verifyPointerAndCoopMatrixType(*this, getPointer().getType(),
call    0 never executed
    #####: 4005:                                        getObject().getType());
call    0 never executed
call    1 never executed
        -: 4006:}
        -: 4007:
        -: 4008://===----------------------------------------------------------------------===//
        -: 4009:// spirv.NV.CooperativeMatrixMulAdd
        -: 4010://===----------------------------------------------------------------------===//
        -: 4011:
        -: 4012:static LogicalResult
function _ZL22verifyCoopMatrixMulAddN4mlir5spirv27NVCooperativeMatrixMulAddOpE called 0 returned 0% blocks executed 0%
    #####: 4013:verifyCoopMatrixMulAdd(spirv::NVCooperativeMatrixMulAddOp op) {
    #####: 4014:  if (op.getC().getType() != op.getResult().getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4015:    return op.emitOpError("result and third operand must have the same type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4016:  auto typeA = op.getA().getType().cast<spirv::CooperativeMatrixNVType>();
call    0 never executed
call    1 never executed
    #####: 4017:  auto typeB = op.getB().getType().cast<spirv::CooperativeMatrixNVType>();
call    0 never executed
call    1 never executed
    #####: 4018:  auto typeC = op.getC().getType().cast<spirv::CooperativeMatrixNVType>();
call    0 never executed
call    1 never executed
    #####: 4019:  auto typeR = op.getResult().getType().cast<spirv::CooperativeMatrixNVType>();
call    0 never executed
call    1 never executed
    #####: 4020:  if (typeA.getRows() != typeR.getRows() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4021:      typeA.getColumns() != typeB.getRows() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4022:      typeB.getColumns() != typeR.getColumns())
call    0 never executed
call    1 never executed
    #####: 4023:    return op.emitOpError("matrix size must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4024:  if (typeR.getScope() != typeA.getScope() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4025:      typeR.getScope() != typeB.getScope() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4026:      typeR.getScope() != typeC.getScope())
call    0 never executed
call    1 never executed
    #####: 4027:    return op.emitOpError("matrix scope must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4028:  if (typeA.getElementType() != typeB.getElementType() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4029:      typeR.getElementType() != typeC.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4030:    return op.emitOpError("matrix element type must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4031:  return success();
        -: 4032:}
        -: 4033:
function _ZN4mlir5spirv27NVCooperativeMatrixMulAddOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4034:LogicalResult spirv::NVCooperativeMatrixMulAddOp::verify() {
    #####: 4035:  return verifyCoopMatrixMulAdd(*this);
call    0 never executed
call    1 never executed
        -: 4036:}
        -: 4037:
        -: 4038:static LogicalResult
        -: 4039:verifyPointerAndJointMatrixType(Operation *op, Type pointer, Type jointMatrix) {
        -: 4040:  Type pointeeType = pointer.cast<spirv::PointerType>().getPointeeType();
        -: 4041:  if (!pointeeType.isa<spirv::ScalarType>() && !pointeeType.isa<VectorType>())
        -: 4042:    return op->emitError(
        -: 4043:               "Pointer must point to a scalar or vector type but provided ")
        -: 4044:           << pointeeType;
        -: 4045:  spirv::StorageClass storage =
        -: 4046:      pointer.cast<spirv::PointerType>().getStorageClass();
        -: 4047:  if (storage != spirv::StorageClass::Workgroup &&
        -: 4048:      storage != spirv::StorageClass::CrossWorkgroup &&
        -: 4049:      storage != spirv::StorageClass::UniformConstant &&
        -: 4050:      storage != spirv::StorageClass::Generic)
        -: 4051:    return op->emitError("Pointer storage class must be Workgroup or "
        -: 4052:                         "CrossWorkgroup but provided ")
        -: 4053:           << stringifyStorageClass(storage);
        -: 4054:  return success();
        -: 4055:}
        -: 4056:
        -: 4057://===----------------------------------------------------------------------===//
        -: 4058:// spirv.INTEL.JointMatrixLoad
        -: 4059://===----------------------------------------------------------------------===//
        -: 4060:
function _ZN4mlir5spirv22INTELJointMatrixLoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4061:LogicalResult spirv::INTELJointMatrixLoadOp::verify() {
    #####: 4062:  return verifyPointerAndJointMatrixType(*this, getPointer().getType(),
    #####: 4063:                                         getResult().getType());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4064:}
        -: 4065:
        -: 4066://===----------------------------------------------------------------------===//
        -: 4067:// spirv.INTEL.JointMatrixStore
        -: 4068://===----------------------------------------------------------------------===//
        -: 4069:
function _ZN4mlir5spirv23INTELJointMatrixStoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4070:LogicalResult spirv::INTELJointMatrixStoreOp::verify() {
    #####: 4071:  return verifyPointerAndJointMatrixType(*this, getPointer().getType(),
call    0 never executed
    #####: 4072:                                         getObject().getType());
call    0 never executed
call    1 never executed
        -: 4073:}
        -: 4074:
        -: 4075://===----------------------------------------------------------------------===//
        -: 4076:// spirv.INTEL.JointMatrixMad
        -: 4077://===----------------------------------------------------------------------===//
        -: 4078:
function _ZL20verifyJointMatrixMadN4mlir5spirv21INTELJointMatrixMadOpE called 0 returned 0% blocks executed 0%
    #####: 4079:static LogicalResult verifyJointMatrixMad(spirv::INTELJointMatrixMadOp op) {
    #####: 4080:  if (op.getC().getType() != op.getResult().getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4081:    return op.emitOpError("result and third operand must have the same type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4082:  auto typeA = op.getA().getType().cast<spirv::JointMatrixINTELType>();
call    0 never executed
call    1 never executed
    #####: 4083:  auto typeB = op.getB().getType().cast<spirv::JointMatrixINTELType>();
call    0 never executed
call    1 never executed
    #####: 4084:  auto typeC = op.getC().getType().cast<spirv::JointMatrixINTELType>();
call    0 never executed
call    1 never executed
    #####: 4085:  auto typeR = op.getResult().getType().cast<spirv::JointMatrixINTELType>();
call    0 never executed
call    1 never executed
    #####: 4086:  if (typeA.getRows() != typeR.getRows() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4087:      typeA.getColumns() != typeB.getRows() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4088:      typeB.getColumns() != typeR.getColumns())
call    0 never executed
call    1 never executed
    #####: 4089:    return op.emitOpError("matrix size must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4090:  if (typeR.getScope() != typeA.getScope() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4091:      typeR.getScope() != typeB.getScope() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4092:      typeR.getScope() != typeC.getScope())
call    0 never executed
call    1 never executed
    #####: 4093:    return op.emitOpError("matrix scope must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4094:  if (typeA.getElementType() != typeB.getElementType() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4095:      typeR.getElementType() != typeC.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4096:    return op.emitOpError("matrix element type must match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4097:  return success();
        -: 4098:}
        -: 4099:
function _ZN4mlir5spirv21INTELJointMatrixMadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4100:LogicalResult spirv::INTELJointMatrixMadOp::verify() {
    #####: 4101:  return verifyJointMatrixMad(*this);
call    0 never executed
call    1 never executed
        -: 4102:}
        -: 4103:
        -: 4104://===----------------------------------------------------------------------===//
        -: 4105:// spirv.MatrixTimesScalar
        -: 4106://===----------------------------------------------------------------------===//
        -: 4107:
function _ZN4mlir5spirv19MatrixTimesScalarOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4108:LogicalResult spirv::MatrixTimesScalarOp::verify() {
        -: 4109:  // We already checked that result and matrix are both of matrix type in the
        -: 4110:  // auto-generated verify method.
        -: 4111:
    #####: 4112:  auto inputMatrix = getMatrix().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
    #####: 4113:  auto resultMatrix = getResult().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
        -: 4114:
        -: 4115:  // Check that the scalar type is the same as the matrix element type.
    #####: 4116:  if (getScalar().getType() != inputMatrix.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4117:    return emitError("input matrix components' type and scaling value must "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4118:                     "have the same type");
call    0 never executed
        -: 4119:
        -: 4120:  // Note that the next three checks could be done using the AllTypesMatch
        -: 4121:  // trait in the Op definition file but it generates a vague error message.
        -: 4122:
        -: 4123:  // Check that the input and result matrices have the same columns' count
    #####: 4124:  if (inputMatrix.getNumColumns() != resultMatrix.getNumColumns())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4125:    return emitError("input and result matrices must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4126:                     "number of columns");
call    0 never executed
        -: 4127:
        -: 4128:  // Check that the input and result matrices' have the same rows count
    #####: 4129:  if (inputMatrix.getNumRows() != resultMatrix.getNumRows())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4130:    return emitError("input and result matrices' columns must have "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4131:                     "the same size");
call    0 never executed
        -: 4132:
        -: 4133:  // Check that the input and result matrices' have the same component type
    #####: 4134:  if (inputMatrix.getElementType() != resultMatrix.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4135:    return emitError("input and result matrices' columns must have "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4136:                     "the same component type");
call    0 never executed
        -: 4137:
    #####: 4138:  return success();
        -: 4139:}
        -: 4140:
        -: 4141://===----------------------------------------------------------------------===//
        -: 4142:// spirv.CopyMemory
        -: 4143://===----------------------------------------------------------------------===//
        -: 4144:
function _ZN4mlir5spirv12CopyMemoryOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4145:void spirv::CopyMemoryOp::print(OpAsmPrinter &printer) {
    #####: 4146:  printer << ' ';
call    0 never executed
        -: 4147:
    #####: 4148:  StringRef targetStorageClass = stringifyStorageClass(
call    0 never executed
    #####: 4149:      getTarget().getType().cast<spirv::PointerType>().getStorageClass());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4150:  printer << " \"" << targetStorageClass << "\" " << getTarget() << ", ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -: 4151:
    #####: 4152:  StringRef sourceStorageClass = stringifyStorageClass(
call    0 never executed
    #####: 4153:      getSource().getType().cast<spirv::PointerType>().getStorageClass());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4154:  printer << " \"" << sourceStorageClass << "\" " << getSource();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4155:
    #####: 4156:  SmallVector<StringRef, 4> elidedAttrs;
call    0 never executed
    #####: 4157:  printMemoryAccessAttribute(*this, printer, elidedAttrs);
call    0 never executed
    #####: 4158:  printSourceMemoryAccessAttribute(*this, printer, elidedAttrs,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4159:                                   getSourceMemoryAccess(),
        -: 4160:                                   getSourceAlignment());
        -: 4161:
    #####: 4162:  printer.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
call    0 never executed
call    1 never executed
        -: 4163:
    #####: 4164:  Type pointeeType =
call    0 never executed
    #####: 4165:      getTarget().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
    #####: 4166:  printer << " : " << pointeeType;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4167:}
        -: 4168:
function _ZN4mlir5spirv12CopyMemoryOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4169:ParseResult spirv::CopyMemoryOp::parse(OpAsmParser &parser,
        -: 4170:                                       OperationState &result) {
    #####: 4171:  spirv::StorageClass targetStorageClass;
    #####: 4172:  OpAsmParser::UnresolvedOperand targetPtrInfo;
call    0 never executed
        -: 4173:
    #####: 4174:  spirv::StorageClass sourceStorageClass;
    #####: 4175:  OpAsmParser::UnresolvedOperand sourcePtrInfo;
        -: 4176:
    #####: 4177:  Type elementType;
        -: 4178:
    #####: 4179:  if (parseEnumStrAttr(targetStorageClass, parser) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4180:      parser.parseOperand(targetPtrInfo) || parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 4181:      parseEnumStrAttr(sourceStorageClass, parser) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4182:      parser.parseOperand(sourcePtrInfo) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 4183:      parseMemoryAccessAttributes(parser, result)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4184:    return failure();
        -: 4185:  }
        -: 4186:
    #####: 4187:  if (!parser.parseOptionalComma()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4188:    // Parse 2nd memory access attributes.
    #####: 4189:    if (parseSourceMemoryAccessAttributes(parser, result)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4190:      return failure();
        -: 4191:    }
        -: 4192:  }
        -: 4193:
    #####: 4194:  if (parser.parseColon() || parser.parseType(elementType))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4195:    return failure();
        -: 4196:
    #####: 4197:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4198:    return failure();
        -: 4199:
    #####: 4200:  auto targetPtrType = spirv::PointerType::get(elementType, targetStorageClass);
call    0 never executed
    #####: 4201:  auto sourcePtrType = spirv::PointerType::get(elementType, sourceStorageClass);
call    0 never executed
        -: 4202:
    #####: 4203:  if (parser.resolveOperand(targetPtrInfo, targetPtrType, result.operands) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4204:      parser.resolveOperand(sourcePtrInfo, sourcePtrType, result.operands)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4205:    return failure();
        -: 4206:  }
        -: 4207:
    #####: 4208:  return success();
        -: 4209:}
        -: 4210:
function _ZN4mlir5spirv12CopyMemoryOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4211:LogicalResult spirv::CopyMemoryOp::verify() {
    #####: 4212:  Type targetType =
call    0 never executed
    #####: 4213:      getTarget().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
        -: 4214:
    #####: 4215:  Type sourceType =
call    0 never executed
    #####: 4216:      getSource().getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
        -: 4217:
    #####: 4218:  if (targetType != sourceType)
branch  0 never executed
branch  1 never executed
    #####: 4219:    return emitOpError("both operands must be pointers to the same type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4220:
    #####: 4221:  if (failed(verifyMemoryAccessAttribute(*this)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4222:    return failure();
        -: 4223:
        -: 4224:  // TODO - According to the spec:
        -: 4225:  //
        -: 4226:  // If two masks are present, the first applies to Target and cannot include
        -: 4227:  // MakePointerVisible, and the second applies to Source and cannot include
        -: 4228:  // MakePointerAvailable.
        -: 4229:  //
        -: 4230:  // Add such verification here.
        -: 4231:
    #####: 4232:  return verifySourceMemoryAccessAttribute(*this);
call    0 never executed
        -: 4233:}
        -: 4234:
        -: 4235://===----------------------------------------------------------------------===//
        -: 4236:// spirv.Transpose
        -: 4237://===----------------------------------------------------------------------===//
        -: 4238:
function _ZN4mlir5spirv11TransposeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4239:LogicalResult spirv::TransposeOp::verify() {
    #####: 4240:  auto inputMatrix = getMatrix().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
    #####: 4241:  auto resultMatrix = getResult().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
        -: 4242:
        -: 4243:  // Verify that the input and output matrices have correct shapes.
    #####: 4244:  if (inputMatrix.getNumRows() != resultMatrix.getNumColumns())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4245:    return emitError("input matrix rows count must be equal to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4246:                     "output matrix columns count");
call    0 never executed
        -: 4247:
    #####: 4248:  if (inputMatrix.getNumColumns() != resultMatrix.getNumRows())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4249:    return emitError("input matrix columns count must be equal to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4250:                     "output matrix rows count");
call    0 never executed
        -: 4251:
        -: 4252:  // Verify that the input and output matrices have the same component type
    #####: 4253:  if (inputMatrix.getElementType() != resultMatrix.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4254:    return emitError("input and output matrices must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4255:                     "component type");
call    0 never executed
        -: 4256:
    #####: 4257:  return success();
        -: 4258:}
        -: 4259:
        -: 4260://===----------------------------------------------------------------------===//
        -: 4261:// spirv.MatrixTimesMatrix
        -: 4262://===----------------------------------------------------------------------===//
        -: 4263:
function _ZN4mlir5spirv19MatrixTimesMatrixOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4264:LogicalResult spirv::MatrixTimesMatrixOp::verify() {
    #####: 4265:  auto leftMatrix = getLeftmatrix().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
    #####: 4266:  auto rightMatrix = getRightmatrix().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
    #####: 4267:  auto resultMatrix = getResult().getType().cast<spirv::MatrixType>();
call    0 never executed
call    1 never executed
        -: 4268:
        -: 4269:  // left matrix columns' count and right matrix rows' count must be equal
    #####: 4270:  if (leftMatrix.getNumColumns() != rightMatrix.getNumRows())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4271:    return emitError("left matrix columns' count must be equal to "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4272:                     "the right matrix rows' count");
call    0 never executed
        -: 4273:
        -: 4274:  // right and result matrices columns' count must be the same
    #####: 4275:  if (rightMatrix.getNumColumns() != resultMatrix.getNumColumns())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4276:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4277:        "right and result matrices must have equal columns' count");
call    0 never executed
        -: 4278:
        -: 4279:  // right and result matrices component type must be the same
    #####: 4280:  if (rightMatrix.getElementType() != resultMatrix.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4281:    return emitError("right and result matrices' component type must"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4282:                     " be the same");
call    0 never executed
        -: 4283:
        -: 4284:  // left and result matrices component type must be the same
    #####: 4285:  if (leftMatrix.getElementType() != resultMatrix.getElementType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4286:    return emitError("left and result matrices' component type"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4287:                     " must be the same");
call    0 never executed
        -: 4288:
        -: 4289:  // left and result matrices rows count must be the same
    #####: 4290:  if (leftMatrix.getNumRows() != resultMatrix.getNumRows())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4291:    return emitError("left and result matrices must have equal rows' count");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4292:
    #####: 4293:  return success();
        -: 4294:}
        -: 4295:
        -: 4296://===----------------------------------------------------------------------===//
        -: 4297:// spirv.SpecConstantComposite
        -: 4298://===----------------------------------------------------------------------===//
        -: 4299:
function _ZN4mlir5spirv23SpecConstantCompositeOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4300:ParseResult spirv::SpecConstantCompositeOp::parse(OpAsmParser &parser,
        -: 4301:                                                  OperationState &result) {
        -: 4302:
    #####: 4303:  StringAttr compositeName;
    #####: 4304:  if (parser.parseSymbolName(compositeName, SymbolTable::getSymbolAttrName(),
branch  0 never executed
branch  1 never executed
    #####: 4305:                             result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4306:    return failure();
        -: 4307:
    #####: 4308:  if (parser.parseLParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4309:    return failure();
        -: 4310:
    #####: 4311:  SmallVector<Attribute, 4> constituents;
        -: 4312:
    #####: 4313:  do {
        -: 4314:    // The name of the constituent attribute isn't important
    #####: 4315:    const char *attrName = "spec_const";
    #####: 4316:    FlatSymbolRefAttr specConstRef;
    #####: 4317:    NamedAttrList attrs;
call    0 never executed
        -: 4318:
    #####: 4319:    if (parser.parseAttribute(specConstRef, Type(), attrName, attrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4320:      return failure();
branch  0 never executed
branch  1 never executed
        -: 4321:
    #####: 4322:    constituents.push_back(specConstRef);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4323:  } while (!parser.parseOptionalComma());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4324:
    #####: 4325:  if (parser.parseRParen())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4326:    return failure();
        -: 4327:
    #####: 4328:  result.addAttribute(kCompositeSpecConstituentsName,
call    0 never executed
    #####: 4329:                      parser.getBuilder().getArrayAttr(constituents));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4330:
    #####: 4331:  Type type;
    #####: 4332:  if (parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4333:    return failure();
        -: 4334:
    #####: 4335:  result.addAttribute(kTypeAttrName, TypeAttr::get(type));
call    0 never executed
call    1 never executed
        -: 4336:
    #####: 4337:  return success();
        -: 4338:}
        -: 4339:
function _ZN4mlir5spirv23SpecConstantCompositeOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4340:void spirv::SpecConstantCompositeOp::print(OpAsmPrinter &printer) {
    #####: 4341:  printer << " ";
call    0 never executed
    #####: 4342:  printer.printSymbolName(getSymName());
call    0 never executed
call    1 never executed
    #####: 4343:  printer << " (";
call    0 never executed
    #####: 4344:  auto constituents = this->getConstituents().getValue();
call    0 never executed
call    1 never executed
        -: 4345:
    #####: 4346:  if (!constituents.empty())
branch  0 never executed
branch  1 never executed
    #####: 4347:    llvm::interleaveComma(constituents, printer);
call    0 never executed
        -: 4348:
    #####: 4349:  printer << ") : " << getType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4350:}
        -: 4351:
function _ZN4mlir5spirv23SpecConstantCompositeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4352:LogicalResult spirv::SpecConstantCompositeOp::verify() {
    #####: 4353:  auto cType = getType().dyn_cast<spirv::CompositeType>();
call    0 never executed
call    1 never executed
    #####: 4354:  auto constituents = this->getConstituents().getValue();
call    0 never executed
call    1 never executed
        -: 4355:
    #####: 4356:  if (!cType)
branch  0 never executed
branch  1 never executed
    #####: 4357:    return emitError("result type must be a composite type, but provided ")
call    0 never executed
call    1 never executed
    #####: 4358:           << getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4359:
    #####: 4360:  if (cType.isa<spirv::CooperativeMatrixNVType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4361:    return emitError("unsupported composite type  ") << cType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 4362:  if (cType.isa<spirv::JointMatrixINTELType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4363:    return emitError("unsupported composite type  ") << cType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 4364:  if (constituents.size() != cType.getNumElements())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4365:    return emitError("has incorrect number of operands: expected ")
call    0 never executed
call    1 never executed
    #####: 4366:           << cType.getNumElements() << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4367:           << constituents.size();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4368:
    #####: 4369:  for (auto index : llvm::seq<uint32_t>(0, constituents.size())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 4370:    auto constituent = constituents[index].cast<FlatSymbolRefAttr>();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 4371:
    #####: 4372:    auto constituentSpecConstOp =
call    0 never executed
        -: 4373:        dyn_cast<spirv::SpecConstantOp>(SymbolTable::lookupNearestSymbolFrom(
    #####: 4374:            (*this)->getParentOp(), constituent.getAttr()));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 4375:
    #####: 4376:    if (constituentSpecConstOp.getDefaultValue().getType() !=
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 4377:        cType.getElementType(index))
    #####: 4378:      return emitError("has incorrect types of operands: expected ")
call    0 never executed
call    1 never executed
    #####: 4379:             << cType.getElementType(index) << ", but provided "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4380:             << constituentSpecConstOp.getDefaultValue().getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4381:  }
        -: 4382:
    #####: 4383:  return success();
        -: 4384:}
        -: 4385:
        -: 4386://===----------------------------------------------------------------------===//
        -: 4387:// spirv.SpecConstantOperation
        -: 4388://===----------------------------------------------------------------------===//
        -: 4389:
function _ZN4mlir5spirv23SpecConstantOperationOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4390:ParseResult spirv::SpecConstantOperationOp::parse(OpAsmParser &parser,
        -: 4391:                                                  OperationState &result) {
    #####: 4392:  Region *body = result.addRegion();
call    0 never executed
        -: 4393:
    #####: 4394:  if (parser.parseKeyword("wraps"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4395:    return failure();
        -: 4396:
    #####: 4397:  body->push_back(new Block);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4398:  Block &block = body->back();
call    0 never executed
    #####: 4399:  Operation *wrappedOp = parser.parseGenericOperation(&block, block.begin());
call    0 never executed
        -: 4400:
    #####: 4401:  if (!wrappedOp)
branch  0 never executed
branch  1 never executed
    #####: 4402:    return failure();
        -: 4403:
    #####: 4404:  OpBuilder builder(parser.getContext());
call    0 never executed
call    1 never executed
    #####: 4405:  builder.setInsertionPointToEnd(&block);
call    0 never executed
    #####: 4406:  builder.create<spirv::YieldOp>(wrappedOp->getLoc(), wrappedOp->getResult(0));
call    0 never executed
    #####: 4407:  result.location = wrappedOp->getLoc();
call    0 never executed
        -: 4408:
    #####: 4409:  result.addTypes(wrappedOp->getResult(0).getType());
call    0 never executed
        -: 4410:
    #####: 4411:  if (parser.parseOptionalAttrDict(result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4412:    return failure();
        -: 4413:
    #####: 4414:  return success();
        -: 4415:}
        -: 4416:
function _ZN4mlir5spirv23SpecConstantOperationOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4417:void spirv::SpecConstantOperationOp::print(OpAsmPrinter &printer) {
    #####: 4418:  printer << " wraps ";
call    0 never executed
    #####: 4419:  printer.printGenericOp(&getBody().front().front());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4420:}
        -: 4421:
function _ZN4mlir5spirv23SpecConstantOperationOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 4422:LogicalResult spirv::SpecConstantOperationOp::verifyRegions() {
    #####: 4423:  Block &block = getRegion().getBlocks().front();
call    0 never executed
call    1 never executed
        -: 4424:
    #####: 4425:  if (block.getOperations().size() != 2)
branch  0 never executed
branch  1 never executed
    #####: 4426:    return emitOpError("expected exactly 2 nested ops");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4427:
    #####: 4428:  Operation &enclosedOp = block.getOperations().front();
call    0 never executed
        -: 4429:
    #####: 4430:  if (!enclosedOp.hasTrait<OpTrait::spirv::UsableInSpecConstantOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4431:    return emitOpError("invalid enclosed op");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4432:
    #####: 4433:  for (auto operand : enclosedOp.getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 4434:    if (!isa<spirv::ConstantOp, spirv::ReferenceOfOp,
    #####: 4435:             spirv::SpecConstantOperationOp>(operand.getDefiningOp()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4436:      return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4437:          "invalid operand, must be defined by a constant operation");
call    0 never executed
        -: 4438:
    #####: 4439:  return success();
        -: 4440:}
        -: 4441:
        -: 4442://===----------------------------------------------------------------------===//
        -: 4443:// spirv.GL.FrexpStruct
        -: 4444://===----------------------------------------------------------------------===//
        -: 4445:
function _ZN4mlir5spirv15GLFrexpStructOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4446:LogicalResult spirv::GLFrexpStructOp::verify() {
    #####: 4447:  spirv::StructType structTy =
    #####: 4448:      getResult().getType().dyn_cast<spirv::StructType>();
call    0 never executed
call    1 never executed
        -: 4449:
    #####: 4450:  if (structTy.getNumElements() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4451:    return emitError("result type must be a struct type with two memebers");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4452:
    #####: 4453:  Type significandTy = structTy.getElementType(0);
call    0 never executed
    #####: 4454:  Type exponentTy = structTy.getElementType(1);
call    0 never executed
    #####: 4455:  VectorType exponentVecTy = exponentTy.dyn_cast<VectorType>();
call    0 never executed
    #####: 4456:  IntegerType exponentIntTy = exponentTy.dyn_cast<IntegerType>();
call    0 never executed
        -: 4457:
    #####: 4458:  Type operandTy = getOperand().getType();
call    0 never executed
call    1 never executed
    #####: 4459:  VectorType operandVecTy = operandTy.dyn_cast<VectorType>();
call    0 never executed
    #####: 4460:  FloatType operandFTy = operandTy.dyn_cast<FloatType>();
call    0 never executed
        -: 4461:
    #####: 4462:  if (significandTy != operandTy)
branch  0 never executed
branch  1 never executed
    #####: 4463:    return emitError("member zero of the resulting struct type must be the "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4464:                     "same type as the operand");
call    0 never executed
        -: 4465:
    #####: 4466:  if (exponentVecTy) {
branch  0 never executed
branch  1 never executed
    #####: 4467:    IntegerType componentIntTy =
    #####: 4468:        exponentVecTy.getElementType().dyn_cast<IntegerType>();
call    0 never executed
call    1 never executed
    #####: 4469:    if (!componentIntTy || componentIntTy.getWidth() != 32)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4470:      return emitError("member one of the resulting struct type must"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4471:                       "be a scalar or vector of 32 bit integer type");
call    0 never executed
    #####: 4472:  } else if (!exponentIntTy || exponentIntTy.getWidth() != 32) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4473:    return emitError("member one of the resulting struct type "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4474:                     "must be a scalar or vector of 32 bit integer type");
call    0 never executed
        -: 4475:  }
        -: 4476:
        -: 4477:  // Check that the two member types have the same number of components
    #####: 4478:  if (operandVecTy && exponentVecTy &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4479:      (exponentVecTy.getNumElements() == operandVecTy.getNumElements()))
call    0 never executed
call    1 never executed
    #####: 4480:    return success();
        -: 4481:
    #####: 4482:  if (operandFTy && exponentIntTy)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4483:    return success();
        -: 4484:
    #####: 4485:  return emitError("member one of the resulting struct type must have the same "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4486:                   "number of components as the operand type");
call    0 never executed
        -: 4487:}
        -: 4488:
        -: 4489://===----------------------------------------------------------------------===//
        -: 4490:// spirv.GL.Ldexp
        -: 4491://===----------------------------------------------------------------------===//
        -: 4492:
function _ZN4mlir5spirv9GLLdexpOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4493:LogicalResult spirv::GLLdexpOp::verify() {
    #####: 4494:  Type significandType = getX().getType();
call    0 never executed
call    1 never executed
    #####: 4495:  Type exponentType = getExp().getType();
call    0 never executed
call    1 never executed
        -: 4496:
    #####: 4497:  if (significandType.isa<FloatType>() != exponentType.isa<IntegerType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4498:    return emitOpError("operands must both be scalars or vectors");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4499:
function _ZZN4mlir5spirv9GLLdexpOp6verifyEvENKUlNS_4TypeEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 4500:  auto getNumElements = [](Type type) -> unsigned {
    #####: 4501:    if (auto vectorType = type.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4502:      return vectorType.getNumElements();
call    0 never executed
    #####: 4503:    return 1;
        -: 4504:  };
        -: 4505:
    #####: 4506:  if (getNumElements(significandType) != getNumElements(exponentType))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4507:    return emitOpError("operands must have the same number of elements");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4508:
    #####: 4509:  return success();
        -: 4510:}
        -: 4511:
        -: 4512://===----------------------------------------------------------------------===//
        -: 4513:// spirv.ImageDrefGather
        -: 4514://===----------------------------------------------------------------------===//
        -: 4515:
function _ZN4mlir5spirv17ImageDrefGatherOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4516:LogicalResult spirv::ImageDrefGatherOp::verify() {
    #####: 4517:  VectorType resultType = getResult().getType().cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4518:  auto sampledImageType =
call    0 never executed
    #####: 4519:      getSampledimage().getType().cast<spirv::SampledImageType>();
call    0 never executed
    #####: 4520:  auto imageType = sampledImageType.getImageType().cast<spirv::ImageType>();
call    0 never executed
call    1 never executed
        -: 4521:
    #####: 4522:  if (resultType.getNumElements() != 4)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4523:    return emitOpError("result type must be a vector of four components");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4524:
    #####: 4525:  Type elementType = resultType.getElementType();
call    0 never executed
    #####: 4526:  Type sampledElementType = imageType.getElementType();
call    0 never executed
    #####: 4527:  if (!sampledElementType.isa<NoneType>() && elementType != sampledElementType)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4528:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4529:        "the component type of result must be the same as sampled type of the "
    #####: 4530:        "underlying image type");
call    0 never executed
        -: 4531:
    #####: 4532:  spirv::Dim imageDim = imageType.getDim();
call    0 never executed
    #####: 4533:  spirv::ImageSamplingInfo imageMS = imageType.getSamplingInfo();
call    0 never executed
        -: 4534:
    #####: 4535:  if (imageDim != spirv::Dim::Dim2D && imageDim != spirv::Dim::Cube &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4536:      imageDim != spirv::Dim::Rect)
    #####: 4537:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4538:        "the Dim operand of the underlying image type must be 2D, Cube, or "
    #####: 4539:        "Rect");
call    0 never executed
        -: 4540:
    #####: 4541:  if (imageMS != spirv::ImageSamplingInfo::SingleSampled)
branch  0 never executed
branch  1 never executed
    #####: 4542:    return emitOpError("the MS operand of the underlying image type must be 0");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 4543:
    #####: 4544:  spirv::ImageOperandsAttr attr = getImageoperandsAttr();
call    0 never executed
    #####: 4545:  auto operandArguments = getOperandArguments();
call    0 never executed
        -: 4546:
    #####: 4547:  return verifyImageOperands(*this, attr, operandArguments);
call    0 never executed
        -: 4548:}
        -: 4549:
        -: 4550://===----------------------------------------------------------------------===//
        -: 4551:// spirv.ShiftLeftLogicalOp
        -: 4552://===----------------------------------------------------------------------===//
        -: 4553:
function _ZN4mlir5spirv18ShiftLeftLogicalOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4554:LogicalResult spirv::ShiftLeftLogicalOp::verify() {
    #####: 4555:  return verifyShiftOp(*this);
call    0 never executed
call    1 never executed
        -: 4556:}
        -: 4557:
        -: 4558://===----------------------------------------------------------------------===//
        -: 4559:// spirv.ShiftRightArithmeticOp
        -: 4560://===----------------------------------------------------------------------===//
        -: 4561:
function _ZN4mlir5spirv22ShiftRightArithmeticOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4562:LogicalResult spirv::ShiftRightArithmeticOp::verify() {
    #####: 4563:  return verifyShiftOp(*this);
call    0 never executed
call    1 never executed
        -: 4564:}
        -: 4565:
        -: 4566://===----------------------------------------------------------------------===//
        -: 4567:// spirv.ShiftRightLogicalOp
        -: 4568://===----------------------------------------------------------------------===//
        -: 4569:
function _ZN4mlir5spirv19ShiftRightLogicalOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4570:LogicalResult spirv::ShiftRightLogicalOp::verify() {
    #####: 4571:  return verifyShiftOp(*this);
call    0 never executed
call    1 never executed
        -: 4572:}
        -: 4573:
        -: 4574://===----------------------------------------------------------------------===//
        -: 4575:// spirv.ImageQuerySize
        -: 4576://===----------------------------------------------------------------------===//
        -: 4577:
function _ZN4mlir5spirv16ImageQuerySizeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4578:LogicalResult spirv::ImageQuerySizeOp::verify() {
    #####: 4579:  spirv::ImageType imageType = getImage().getType().cast<spirv::ImageType>();
call    0 never executed
call    1 never executed
    #####: 4580:  Type resultType = getResult().getType();
call    0 never executed
call    1 never executed
        -: 4581:
    #####: 4582:  spirv::Dim dim = imageType.getDim();
call    0 never executed
    #####: 4583:  spirv::ImageSamplingInfo samplingInfo = imageType.getSamplingInfo();
call    0 never executed
    #####: 4584:  spirv::ImageSamplerUseInfo samplerInfo = imageType.getSamplerUseInfo();
call    0 never executed
    #####: 4585:  switch (dim) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4586:  case spirv::Dim::Dim1D:
    #####: 4587:  case spirv::Dim::Dim2D:
    #####: 4588:  case spirv::Dim::Dim3D:
    #####: 4589:  case spirv::Dim::Cube:
    #####: 4590:    if (samplingInfo != spirv::ImageSamplingInfo::MultiSampled &&
    #####: 4591:        samplerInfo != spirv::ImageSamplerUseInfo::SamplerUnknown &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4592:        samplerInfo != spirv::ImageSamplerUseInfo::NoSampler)
    #####: 4593:      return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4594:          "if Dim is 1D, 2D, 3D, or Cube, "
    #####: 4595:          "it must also have either an MS of 1 or a Sampled of 0 or 2");
call    0 never executed
        -: 4596:    break;
        -: 4597:  case spirv::Dim::Buffer:
        -: 4598:  case spirv::Dim::Rect:
        -: 4599:    break;
    #####: 4600:  default:
    #####: 4601:    return emitError("the Dim operand of the image type must "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4602:                     "be 1D, 2D, 3D, Buffer, Cube, or Rect");
call    0 never executed
        -: 4603:  }
        -: 4604:
    #####: 4605:  unsigned componentNumber = 0;
    #####: 4606:  switch (dim) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4607:  case spirv::Dim::Dim1D:
    #####: 4608:  case spirv::Dim::Buffer:
    #####: 4609:    componentNumber = 1;
    #####: 4610:    break;
    #####: 4611:  case spirv::Dim::Dim2D:
    #####: 4612:  case spirv::Dim::Cube:
    #####: 4613:  case spirv::Dim::Rect:
    #####: 4614:    componentNumber = 2;
    #####: 4615:    break;
    #####: 4616:  case spirv::Dim::Dim3D:
    #####: 4617:    componentNumber = 3;
    #####: 4618:    break;
        -: 4619:  default:
        -: 4620:    break;
        -: 4621:  }
        -: 4622:
    #####: 4623:  if (imageType.getArrayedInfo() == spirv::ImageArrayedInfo::Arrayed)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4624:    componentNumber += 1;
        -: 4625:
    #####: 4626:  unsigned resultComponentNumber = 1;
    #####: 4627:  if (auto resultVectorType = resultType.dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4628:    resultComponentNumber = resultVectorType.getNumElements();
call    0 never executed
        -: 4629:
    #####: 4630:  if (componentNumber != resultComponentNumber)
branch  0 never executed
branch  1 never executed
    #####: 4631:    return emitError("expected the result to have ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4632:           << componentNumber << " component(s), but found "
call    0 never executed
call    1 never executed
    #####: 4633:           << resultComponentNumber << " component(s)";
call    0 never executed
call    1 never executed
        -: 4634:
    #####: 4635:  return success();
        -: 4636:}
        -: 4637:
function _ZL25parsePtrAccessChainOpImplN4llvm9StringRefERN4mlir11OpAsmParserERNS1_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4638:static ParseResult parsePtrAccessChainOpImpl(StringRef opName,
        -: 4639:                                             OpAsmParser &parser,
        -: 4640:                                             OperationState &state) {
    #####: 4641:  OpAsmParser::UnresolvedOperand ptrInfo;
call    0 never executed
    #####: 4642:  SmallVector<OpAsmParser::UnresolvedOperand, 4> indicesInfo;
call    0 never executed
    #####: 4643:  Type type;
    #####: 4644:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####: 4645:  SmallVector<Type, 4> indicesTypes;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 4646:
    #####: 4647:  if (parser.parseOperand(ptrInfo) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4648:      parser.parseOperandList(indicesInfo, OpAsmParser::Delimiter::Square) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4649:      parser.parseColonType(type) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 4650:      parser.resolveOperand(ptrInfo, type, state.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4651:    return failure();
        -: 4652:
        -: 4653:  // Check that the provided indices list is not empty before parsing their
        -: 4654:  // type list.
    #####: 4655:  if (indicesInfo.empty())
branch  0 never executed
branch  1 never executed
    #####: 4656:    return emitError(state.location) << opName << " expected element";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 4657:
    #####: 4658:  if (parser.parseComma() || parser.parseTypeList(indicesTypes))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4659:    return failure();
        -: 4660:
        -: 4661:  // Check that the indices types list is not empty and that it has a one-to-one
        -: 4662:  // mapping to the provided indices.
    #####: 4663:  if (indicesTypes.size() != indicesInfo.size())
branch  0 never executed
branch  1 never executed
    #####: 4664:    return emitError(state.location)
call    0 never executed
call    1 never executed
    #####: 4665:           << opName
call    0 never executed
    #####: 4666:           << " indices types' count must be equal to indices info count";
call    0 never executed
call    1 never executed
        -: 4667:
    #####: 4668:  if (parser.resolveOperands(indicesInfo, indicesTypes, loc, state.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4669:    return failure();
        -: 4670:
    #####: 4671:  auto resultType = getElementPtrType(
    #####: 4672:      type, llvm::makeArrayRef(state.operands).drop_front(2), state.location);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4673:  if (!resultType)
branch  0 never executed
branch  1 never executed
    #####: 4674:    return failure();
        -: 4675:
    #####: 4676:  state.addTypes(resultType);
call    0 never executed
    #####: 4677:  return success();
        -: 4678:}
        -: 4679:
        -: 4680:template <typename Op>
    #####: 4681:static auto concatElemAndIndices(Op op) {
    #####: 4682:  SmallVector<Value> ret(op.getIndices().size() + 1);
    #####: 4683:  ret[0] = op.getElement();
    #####: 4684:  llvm::copy(op.getIndices(), ret.begin() + 1);
    #####: 4685:  return ret;
        -: 4686:}
------------------
_Z20concatElemAndIndicesIN4mlir5spirv16PtrAccessChainOpEEDaT_:
function _Z20concatElemAndIndicesIN4mlir5spirv16PtrAccessChainOpEEDaT_ called 0 returned 0% blocks executed 0%
    #####: 4681:static auto concatElemAndIndices(Op op) {
call    0 never executed
    #####: 4682:  SmallVector<Value> ret(op.getIndices().size() + 1);
call    0 never executed
call    1 never executed
    #####: 4683:  ret[0] = op.getElement();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4684:  llvm::copy(op.getIndices(), ret.begin() + 1);
call    0 never executed
call    1 never executed
    #####: 4685:  return ret;
        -: 4686:}
------------------
_Z20concatElemAndIndicesIN4mlir5spirv24InBoundsPtrAccessChainOpEEDaT_:
function _Z20concatElemAndIndicesIN4mlir5spirv24InBoundsPtrAccessChainOpEEDaT_ called 0 returned 0% blocks executed 0%
    #####: 4681:static auto concatElemAndIndices(Op op) {
call    0 never executed
    #####: 4682:  SmallVector<Value> ret(op.getIndices().size() + 1);
call    0 never executed
call    1 never executed
    #####: 4683:  ret[0] = op.getElement();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4684:  llvm::copy(op.getIndices(), ret.begin() + 1);
call    0 never executed
call    1 never executed
    #####: 4685:  return ret;
        -: 4686:}
------------------
        -: 4687:
        -: 4688://===----------------------------------------------------------------------===//
        -: 4689:// spirv.InBoundsPtrAccessChainOp
        -: 4690://===----------------------------------------------------------------------===//
        -: 4691:
function _ZN4mlir5spirv24InBoundsPtrAccessChainOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 4692:void spirv::InBoundsPtrAccessChainOp::build(OpBuilder &builder,
        -: 4693:                                            OperationState &state,
        -: 4694:                                            Value basePtr, Value element,
        -: 4695:                                            ValueRange indices) {
    #####: 4696:  auto type = getElementPtrType(basePtr.getType(), indices, state.location);
call    0 never executed
    #####: 4697:  assert(type && "Unable to deduce return type based on basePtr and indices");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4698:  build(builder, state, type, basePtr, element, indices);
call    0 never executed
    #####: 4699:}
        -: 4700:
function _ZN4mlir5spirv24InBoundsPtrAccessChainOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4701:ParseResult spirv::InBoundsPtrAccessChainOp::parse(OpAsmParser &parser,
        -: 4702:                                                   OperationState &result) {
    #####: 4703:  return parsePtrAccessChainOpImpl(
    #####: 4704:      spirv::InBoundsPtrAccessChainOp::getOperationName(), parser, result);
call    0 never executed
        -: 4705:}
        -: 4706:
function _ZN4mlir5spirv24InBoundsPtrAccessChainOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4707:void spirv::InBoundsPtrAccessChainOp::print(OpAsmPrinter &printer) {
    #####: 4708:  printAccessChain(*this, concatElemAndIndices(*this), printer);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4709:}
        -: 4710:
function _ZN4mlir5spirv24InBoundsPtrAccessChainOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4711:LogicalResult spirv::InBoundsPtrAccessChainOp::verify() {
    #####: 4712:  return verifyAccessChain(*this, getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4713:}
        -: 4714:
        -: 4715://===----------------------------------------------------------------------===//
        -: 4716:// spirv.PtrAccessChainOp
        -: 4717://===----------------------------------------------------------------------===//
        -: 4718:
function _ZN4mlir5spirv16PtrAccessChainOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_NS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 4719:void spirv::PtrAccessChainOp::build(OpBuilder &builder, OperationState &state,
        -: 4720:                                    Value basePtr, Value element,
        -: 4721:                                    ValueRange indices) {
    #####: 4722:  auto type = getElementPtrType(basePtr.getType(), indices, state.location);
call    0 never executed
    #####: 4723:  assert(type && "Unable to deduce return type based on basePtr and indices");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 4724:  build(builder, state, type, basePtr, element, indices);
call    0 never executed
    #####: 4725:}
        -: 4726:
function _ZN4mlir5spirv16PtrAccessChainOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 4727:ParseResult spirv::PtrAccessChainOp::parse(OpAsmParser &parser,
        -: 4728:                                           OperationState &result) {
    #####: 4729:  return parsePtrAccessChainOpImpl(spirv::PtrAccessChainOp::getOperationName(),
    #####: 4730:                                   parser, result);
call    0 never executed
        -: 4731:}
        -: 4732:
function _ZN4mlir5spirv16PtrAccessChainOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 4733:void spirv::PtrAccessChainOp::print(OpAsmPrinter &printer) {
    #####: 4734:  printAccessChain(*this, concatElemAndIndices(*this), printer);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4735:}
        -: 4736:
function _ZN4mlir5spirv16PtrAccessChainOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4737:LogicalResult spirv::PtrAccessChainOp::verify() {
    #####: 4738:  return verifyAccessChain(*this, getIndices());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 4739:}
        -: 4740:
        -: 4741://===----------------------------------------------------------------------===//
        -: 4742:// spirv.VectorTimesScalarOp
        -: 4743://===----------------------------------------------------------------------===//
        -: 4744:
function _ZN4mlir5spirv19VectorTimesScalarOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 4745:LogicalResult spirv::VectorTimesScalarOp::verify() {
    #####: 4746:  if (getVector().getType() != getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 4747:    return emitOpError("vector operand and result type mismatch");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4748:  auto scalarType = getType().cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 4749:  if (getScalar().getType() != scalarType)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4750:    return emitOpError("scalar operand and result element type match");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 4751:  return success();
        -: 4752:}
        -: 4753:
        -: 4754:// TableGen'erated operation interfaces for querying versions, extensions, and
        -: 4755:// capabilities.
        -: 4756:#include "mlir/Dialect/SPIRV/IR/SPIRVAvailability.cpp.inc"
        -: 4757:
        -: 4758:// TablenGen'erated operation definitions.
        -: 4759:#define GET_OP_CLASSES
        -: 4760:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.cpp.inc"
        -: 4761:
        -: 4762:namespace mlir {
        -: 4763:namespace spirv {
        -: 4764:// TableGen'erated operation availability interface implementations.
        -: 4765:#include "mlir/Dialect/SPIRV/IR/SPIRVOpAvailabilityImpl.inc"
        -: 4766:} // namespace spirv
        -: 4767:} // namespace mlir
