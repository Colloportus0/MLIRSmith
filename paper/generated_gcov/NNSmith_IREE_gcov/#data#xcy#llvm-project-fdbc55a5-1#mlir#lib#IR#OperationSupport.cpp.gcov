        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/OperationSupport.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- OperationSupport.cpp -----------------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains out-of-line implementations of the support types that
        -:   10:// Operation and related classes build on top of.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/OperationSupport.h"
        -:   15:#include "mlir/IR/BuiltinAttributes.h"
        -:   16:#include "mlir/IR/BuiltinTypes.h"
        -:   17:#include "mlir/IR/OpDefinition.h"
        -:   18:#include "llvm/ADT/BitVector.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23://===----------------------------------------------------------------------===//
        -:   24:// NamedAttrList
        -:   25://===----------------------------------------------------------------------===//
        -:   26:
function _ZN4mlir13NamedAttrListC2EN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:   27:NamedAttrList::NamedAttrList(ArrayRef<NamedAttribute> attributes) {
call    0 never executed
 4971442*:   28:  assign(attributes.begin(), attributes.end());
call    0 returned 100%
call    1 never executed
    #####:   29:}
        -:   30:
function _ZN4mlir13NamedAttrListC2ENS_14DictionaryAttrE called 4971443 returned 100% blocks executed 86%
  4971443:   31:NamedAttrList::NamedAttrList(DictionaryAttr attributes)
  4971443:   32:    : NamedAttrList(attributes ? attributes.getValue()
call    0 returned 100%
  9942885:   33:                               : ArrayRef<NamedAttribute>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
  4971386:   34:  dictionarySorted.setPointerAndInt(attributes, true);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  4971386:   35:}
        -:   36:
function _ZN4mlir13NamedAttrListC2EPKNS_14NamedAttributeES3_ called 0 returned 0% blocks executed 0%
      73*:   37:NamedAttrList::NamedAttrList(const_iterator inStart, const_iterator inEnd) {
call    0 returned 100%
call    1 never executed
     146*:   38:  assign(inStart, inEnd);
    #####:   39:}
        -:   40:
function _ZNK4mlir13NamedAttrList8getAttrsEv called 0 returned 0% blocks executed 0%
    #####:   41:ArrayRef<NamedAttribute> NamedAttrList::getAttrs() const { return attrs; }
        -:   42:
function _ZNK4mlir13NamedAttrList13findDuplicateEv called 662424 returned 100% blocks executed 100%
   662424:   43:Optional<NamedAttribute> NamedAttrList::findDuplicate() const {
   662424:   44:  Optional<NamedAttribute> duplicate =
call    0 returned 100%
   662424:   45:      DictionaryAttr::findDuplicate(attrs, isSorted());
call    0 returned 100%
        -:   46:  // DictionaryAttr::findDuplicate will sort the list, so reset the sorted
        -:   47:  // state.
   662424:   48:  if (!isSorted())
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
   220808:   49:    dictionarySorted.setPointerAndInt(nullptr, true);
   662424:   50:  return duplicate;
        -:   51:}
        -:   52:
function _ZNK4mlir13NamedAttrList13getDictionaryEPNS_11MLIRContextE called 10849397 returned 100% blocks executed 100%
 10849397:   53:DictionaryAttr NamedAttrList::getDictionary(MLIRContext *context) const {
 10849397:   54:  if (!isSorted()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    36387:   55:    DictionaryAttr::sortInPlace(attrs);
call    0 returned 100%
    36387:   56:    dictionarySorted.setPointerAndInt(nullptr, true);
        -:   57:  }
 10849397:   58:  if (!dictionarySorted.getPointer())
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
  5965767:   59:    dictionarySorted.setPointer(DictionaryAttr::getWithSorted(context, attrs));
call    0 returned 100%
call    1 returned 100%
 10849449:   60:  return dictionarySorted.getPointer().cast<DictionaryAttr>();
call    0 returned 100%
        -:   61:}
        -:   62:
        -:   63:/// Add an attribute with the specified name.
function _ZN4mlir13NamedAttrList6appendEN4llvm9StringRefENS_9AttributeE called 269621 returned 100% blocks executed 100%
   269621:   64:void NamedAttrList::append(StringRef name, Attribute attr) {
   269621:   65:  append(StringAttr::get(attr.getContext(), name), attr);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   269621:   66:}
        -:   67:
        -:   68:/// Replaces the attributes with new list of attributes.
function _ZN4mlir13NamedAttrList6assignEPKNS_14NamedAttributeES3_ called 0 returned 0% blocks executed 0%
 4971515*:   69:void NamedAttrList::assign(const_iterator inStart, const_iterator inEnd) {
 4971515*:   70:  DictionaryAttr::sort(ArrayRef<NamedAttribute>{inStart, inEnd}, attrs);
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 never executed
 4971459*:   71:  dictionarySorted.setPointerAndInt(nullptr, true);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   72:}
        -:   73:
function _ZN4mlir13NamedAttrList9push_backENS_14NamedAttributeE called 5143792 returned 100% blocks executed 100%
  5143792:   74:void NamedAttrList::push_back(NamedAttribute newAttribute) {
  5143792:   75:  if (isSorted())
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
  4970113:   76:    dictionarySorted.setInt(attrs.empty() || attrs.back() < newAttribute);
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 55% (fallthrough)
branch  5 taken 45%
  5143792:   77:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
  5143827:   78:  attrs.push_back(newAttribute);
call    0 returned 100%
  5143820:   79:}
        -:   80:
        -:   81:/// Return the specified attribute if present, null otherwise.
function _ZNK4mlir13NamedAttrList3getEN4llvm9StringRefE called 786327 returned 100% blocks executed 80%
   786327:   82:Attribute NamedAttrList::get(StringRef name) const {
   786327:   83:  auto it = findAttr(*this, name);
call    0 returned 100%
  786327*:   84:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   85:}
function _ZNK4mlir13NamedAttrList3getENS_10StringAttrE called 1413 returned 100% blocks executed 100%
     1413:   86:Attribute NamedAttrList::get(StringAttr name) const {
     1413:   87:  auto it = findAttr(*this, name);
call    0 returned 100%
     1413:   88:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
        -:   89:}
        -:   90:
        -:   91:/// Return the specified named attribute if present, None otherwise.
function _ZNK4mlir13NamedAttrList8getNamedEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   92:Optional<NamedAttribute> NamedAttrList::getNamed(StringRef name) const {
    #####:   93:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   94:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:   95:}
function _ZNK4mlir13NamedAttrList8getNamedENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:   96:Optional<NamedAttribute> NamedAttrList::getNamed(StringAttr name) const {
    #####:   97:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   98:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:   99:}
        -:  100:
        -:  101:/// If the an attribute exists with the specified name, change it to the new
        -:  102:/// value.  Otherwise, add a new attribute with the specified name/value.
function _ZN4mlir13NamedAttrList3setENS_10StringAttrENS_9AttributeE called 47175 returned 100% blocks executed 89%
    47175:  103:Attribute NamedAttrList::set(StringAttr name, Attribute value) {
   47175*:  104:  assert(value && "attributes may never be null");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  105:
        -:  106:  // Look for an existing attribute with the given name, and set its value
        -:  107:  // in-place. Return the previous value of the attribute, if there was one.
    47175:  108:  auto it = findAttr(*this, name);
call    0 returned 100%
    47174:  109:  if (it.second) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:  110:    // Update the existing attribute by swapping out the old value for the new
        -:  111:    // value. Return the old value.
    23895:  112:    Attribute oldValue = it.first->getValue();
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    23895:  113:    if (it.first->getValue() != value) {
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
    13912:  114:      it.first->setValue(value);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:
        -:  116:      // If the attributes have changed, the dictionary is invalidated.
    13912:  117:      dictionarySorted.setPointer(nullptr);
call    0 returned 100%
        -:  118:    }
    23895:  119:    return oldValue;
        -:  120:  }
        -:  121:  // Perform a string lookup to insert the new attribute into its sorted
        -:  122:  // position.
    23279:  123:  if (isSorted())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    23279:  124:    it = findAttr(*this, name.strref());
call    0 returned 100%
call    1 returned 100%
    23280:  125:  attrs.insert(it.first, {name, value});
call    0 returned 100%
call    1 returned 100%
        -:  126:  // Invalidate the dictionary. Return null as there was no previous value.
    23283:  127:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
    23283:  128:  return Attribute();
        -:  129:}
        -:  130:
function _ZN4mlir13NamedAttrList3setEN4llvm9StringRefENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  131:Attribute NamedAttrList::set(StringRef name, Attribute value) {
    #####:  132:  assert(value && "attributes may never be null");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  133:  return set(mlir::StringAttr::get(value.getContext(), name), value);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  134:}
        -:  135:
        -:  136:Attribute
function _ZN4mlir13NamedAttrList9eraseImplEPNS_14NamedAttributeE called 7 returned 100% blocks executed 100%
        7:  137:NamedAttrList::eraseImpl(SmallVectorImpl<NamedAttribute>::iterator it) {
        -:  138:  // Erasing does not affect the sorted property.
        7:  139:  Attribute attr = it->getValue();
call    0 returned 100%
        7:  140:  attrs.erase(it);
call    0 returned 100%
        7:  141:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
        7:  142:  return attr;
        -:  143:}
        -:  144:
function _ZN4mlir13NamedAttrList5eraseENS_10StringAttrE called 43367 returned 100% blocks executed 100%
    43367:  145:Attribute NamedAttrList::erase(StringAttr name) {
    43367:  146:  auto it = findAttr(*this, name);
call    0 returned 100%
    43370:  147:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  148:}
        -:  149:
function _ZN4mlir13NamedAttrList5eraseEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  150:Attribute NamedAttrList::erase(StringRef name) {
    #####:  151:  auto it = findAttr(*this, name);
call    0 never executed
    #####:  152:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  153:}
        -:  154:
        -:  155:NamedAttrList &
function _ZN4mlir13NamedAttrListaSERKN4llvm15SmallVectorImplINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  156:NamedAttrList::operator=(const SmallVectorImpl<NamedAttribute> &rhs) {
    #####:  157:  assign(rhs.begin(), rhs.end());
call    0 never executed
    #####:  158:  return *this;
        -:  159:}
        -:  160:
function _ZNK4mlir13NamedAttrListcvN4llvm8ArrayRefINS_14NamedAttributeEEEEv called 0 returned 0% blocks executed 0%
    #####:  161:NamedAttrList::operator ArrayRef<NamedAttribute>() const { return attrs; }
        -:  162:
        -:  163://===----------------------------------------------------------------------===//
        -:  164:// OperationState
        -:  165://===----------------------------------------------------------------------===//
        -:  166:
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefE called 3833255 returned 100% blocks executed 100%
  3833255:  167:OperationState::OperationState(Location location, StringRef name)
  3833255:  168:    : location(location), name(name, location->getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  169:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameE called 1093583 returned 100% blocks executed 100%
  1093583:  170:OperationState::OperationState(Location location, OperationName name)
  1093583:  171:    : location(location), name(name) {}
call    0 returned 100%
        -:  172:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameENS_10ValueRangeENS_9TypeRangeEN4llvm8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS5_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 73 returned 100% blocks executed 78%
       73:  173:OperationState::OperationState(Location location, OperationName name,
        -:  174:                               ValueRange operands, TypeRange types,
        -:  175:                               ArrayRef<NamedAttribute> attributes,
        -:  176:                               BlockRange successors,
       73:  177:                               MutableArrayRef<std::unique_ptr<Region>> regions)
        -:  178:    : location(location), name(name),
        -:  179:      operands(operands.begin(), operands.end()),
        -:  180:      types(types.begin(), types.end()),
        -:  181:      attributes(attributes.begin(), attributes.end()),
       73:  182:      successors(successors.begin(), successors.end()) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      73*:  183:  for (std::unique_ptr<Region> &r : regions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  184:    this->regions.push_back(std::move(r));
call    0 never executed
       73:  185:}
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefENS_10ValueRangeENS_9TypeRangeENS2_8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS2_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 73 returned 100% blocks executed 100%
       73:  186:OperationState::OperationState(Location location, StringRef name,
        -:  187:                               ValueRange operands, TypeRange types,
        -:  188:                               ArrayRef<NamedAttribute> attributes,
        -:  189:                               BlockRange successors,
       73:  190:                               MutableArrayRef<std::unique_ptr<Region>> regions)
call    0 returned 100%
        -:  191:    : OperationState(location, OperationName(name, location.getContext()),
       73:  192:                     operands, types, attributes, successors, regions) {}
call    0 returned 100%
call    1 returned 100%
        -:  193:
function _ZN4mlir14OperationState11addOperandsENS_10ValueRangeE called 39847 returned 100% blocks executed 100%
    39847:  194:void OperationState::addOperands(ValueRange newOperands) {
    39847:  195:  operands.append(newOperands.begin(), newOperands.end());
call    0 returned 100%
    39847:  196:}
        -:  197:
function _ZN4mlir14OperationState13addSuccessorsENS_10BlockRangeE called 0 returned 0% blocks executed 0%
    #####:  198:void OperationState::addSuccessors(BlockRange newSuccessors) {
    #####:  199:  successors.append(newSuccessors.begin(), newSuccessors.end());
call    0 never executed
    #####:  200:}
        -:  201:
function _ZN4mlir14OperationState9addRegionEv called 554028 returned 100% blocks executed 100%
   554028:  202:Region *OperationState::addRegion() {
   554028:  203:  regions.emplace_back(new Region);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   554028:  204:  return regions.back().get();
call    0 returned 100%
        -:  205:}
        -:  206:
function _ZN4mlir14OperationState9addRegionEOSt10unique_ptrINS_6RegionESt14default_deleteIS2_EE called 219869 returned 100% blocks executed 100%
  219869*:  207:void OperationState::addRegion(std::unique_ptr<Region> &&region) {
  219869*:  208:  regions.push_back(std::move(region));
call    0 never executed
call    1 returned 100%
   219869:  209:}
        -:  210:
function _ZN4mlir14OperationState10addRegionsEN4llvm15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteIS4_EEEE called 0 returned 0% blocks executed 0%
    #####:  211:void OperationState::addRegions(
        -:  212:    MutableArrayRef<std::unique_ptr<Region>> regions) {
    #####:  213:  for (std::unique_ptr<Region> &region : regions)
branch  0 never executed
branch  1 never executed
    #####:  214:    addRegion(std::move(region));
call    0 never executed
    #####:  215:}
        -:  216:
        -:  217://===----------------------------------------------------------------------===//
        -:  218:// OperandStorage
        -:  219://===----------------------------------------------------------------------===//
        -:  220:
function _ZN4mlir6detail14OperandStorageC2EPNS_9OperationEPNS_9OpOperandENS_10ValueRangeE called 2742244 returned 100% blocks executed 100%
  2742244:  221:detail::OperandStorage::OperandStorage(Operation *owner,
        -:  222:                                       OpOperand *trailingOperands,
  2742244:  223:                                       ValueRange values)
  2742244:  224:    : isStorageDynamic(false), operandStorage(trailingOperands) {
  2742244:  225:  numOperands = capacity = values.size();
  7516161:  226:  for (unsigned i = 0; i < numOperands; ++i)
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
  5313861:  227:    new (&operandStorage[i]) OpOperand(owner, values[i]);
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
  2742244:  228:}
        -:  229:
function _ZN4mlir6detail14OperandStorageD2Ev called 2739196 returned 100% blocks executed 100%
  5478392:  230:detail::OperandStorage::~OperandStorage() {
  7585940:  231:  for (auto &operand : getOperands())
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
  4870081:  232:    operand.~OpOperand();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  233:
        -:  234:  // If the storage is dynamic, deallocate it.
  2739196:  235:  if (isStorageDynamic)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    45306:  236:    free(operandStorage);
  2739196:  237:}
        -:  238:
        -:  239:/// Replace the operands contained in the storage with the ones provided in
        -:  240:/// 'values'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationENS_10ValueRangeE called 48114 returned 100% blocks executed 92%
    48114:  241:void detail::OperandStorage::setOperands(Operation *owner, ValueRange values) {
    48114:  242:  MutableArrayRef<OpOperand> storageOperands = resize(owner, values.size());
call    0 returned 100%
   132659:  243:  for (unsigned i = 0, e = values.size(); i != e; ++i)
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
   169090:  244:    storageOperands[i].set(values[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 8% (fallthrough)
branch  4 taken 92%
    48114:  245:}
        -:  246:
        -:  247:/// Replace the operands beginning at 'start' and ending at 'start' + 'length'
        -:  248:/// with the ones provided in 'operands'. 'operands' may be smaller or larger
        -:  249:/// than the range pointed to by 'start'+'length'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationEjjNS_10ValueRangeE called 1732 returned 100% blocks executed 35%
     1732:  250:void detail::OperandStorage::setOperands(Operation *owner, unsigned start,
        -:  251:                                         unsigned length, ValueRange operands) {
        -:  252:  // If the new size is the same, we can update inplace.
     1732:  253:  unsigned newSize = operands.size();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1732:  254:  if (newSize == length) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1732:  255:    MutableArrayRef<OpOperand> storageOperands = getOperands();
     5793:  256:    for (unsigned i = 0, e = length; i != e; ++i)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
     8122:  257:      storageOperands[start + i].set(operands[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  258:    return;
        -:  259:  }
        -:  260:  // If the new size is greater, remove the extra operands and set the rest
        -:  261:  // inplace.
    #####:  262:  if (newSize < length) {
branch  0 never executed
branch  1 never executed
    #####:  263:    eraseOperands(start + operands.size(), length - newSize);
call    0 never executed
    #####:  264:    setOperands(owner, start, newSize, operands);
    #####:  265:    return;
call    0 never executed
        -:  266:  }
        -:  267:  // Otherwise, the new size is greater so we need to grow the storage.
    #####:  268:  auto storageOperands = resize(owner, size() + (newSize - length));
call    0 never executed
        -:  269:
        -:  270:  // Shift operands to the right to make space for the new operands.
    #####:  271:  unsigned rotateSize = storageOperands.size() - (start + length);
branch  0 never executed
branch  1 never executed
    #####:  272:  auto rbegin = storageOperands.rbegin();
branch  0 never executed
branch  1 never executed
    #####:  273:  std::rotate(rbegin, std::next(rbegin, newSize - length), rbegin + rotateSize);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  274:
        -:  275:  // Update the operands inplace.
    #####:  276:  for (unsigned i = 0, e = operands.size(); i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  277:    storageOperands[start + i].set(operands[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  278:}
        -:  279:
        -:  280:/// Erase an operand held by the storage.
function _ZN4mlir6detail14OperandStorage13eraseOperandsEjj called 0 returned 0% blocks executed 0%
    #####:  281:void detail::OperandStorage::eraseOperands(unsigned start, unsigned length) {
    #####:  282:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 never executed
branch  1 never executed
    #####:  283:  assert((start + length) <= operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  284:  numOperands -= length;
        -:  285:
        -:  286:  // Shift all operands down if the operand to remove is not at the end.
    #####:  287:  if (start != numOperands) {
branch  0 never executed
branch  1 never executed
    #####:  288:    auto *indexIt = std::next(operands.begin(), start);
branch  0 never executed
branch  1 never executed
    #####:  289:    std::rotate(indexIt, std::next(indexIt, length), operands.end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  290:  }
    #####:  291:  for (unsigned i = 0; i != length; ++i)
branch  0 never executed
branch  1 never executed
    #####:  292:    operands[numOperands + i].~OpOperand();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  293:}
        -:  294:
function _ZN4mlir6detail14OperandStorage13eraseOperandsERKN4llvm9BitVectorE called 0 returned 0% blocks executed 0%
    #####:  295:void detail::OperandStorage::eraseOperands(const BitVector &eraseIndices) {
    #####:  296:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 never executed
branch  1 never executed
    #####:  297:  assert(eraseIndices.size() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  298:
        -:  299:  // Check that at least one operand is erased.
    #####:  300:  int firstErasedIndice = eraseIndices.find_first();
call    0 never executed
    #####:  301:  if (firstErasedIndice == -1)
branch  0 never executed
branch  1 never executed
    #####:  302:    return;
        -:  303:
        -:  304:  // Shift all of the removed operands to the end, and destroy them.
    #####:  305:  numOperands = firstErasedIndice;
    #####:  306:  for (unsigned i = firstErasedIndice + 1, e = operands.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  307:    if (!eraseIndices.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  308:      operands[numOperands++] = std::move(operands[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  309:  for (OpOperand &operand : operands.drop_front(numOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  310:    operand.~OpOperand();
branch  0 never executed
branch  1 never executed
        -:  311:}
        -:  312:
        -:  313:/// Resize the storage to the given size. Returns the array containing the new
        -:  314:/// operands.
function _ZN4mlir6detail14OperandStorage6resizeEPNS_9OperationEj called 48114 returned 100% blocks executed 51%
    48114:  315:MutableArrayRef<OpOperand> detail::OperandStorage::resize(Operation *owner,
        -:  316:                                                          unsigned newSize) {
        -:  317:  // If the number of operands is less than or equal to the current amount, we
        -:  318:  // can just update in place.
    48114:  319:  MutableArrayRef<OpOperand> origOperands = getOperands();
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    48114:  320:  if (newSize <= numOperands) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  321:    // If the number of new size is less than the current, remove any extra
        -:  322:    // operands.
    2808*:  323:    for (unsigned i = newSize; i != numOperands; ++i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  324:      origOperands[i].~OpOperand();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
     2808:  325:    numOperands = newSize;
     2808:  326:    return origOperands.take_front(newSize);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  327:  }
        -:  328:
        -:  329:  // If the new size is within the original inline capacity, grow inplace.
    45306:  330:  if (newSize <= capacity) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  331:    OpOperand *opBegin = origOperands.data();
    #####:  332:    for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 never executed
branch  1 never executed
    #####:  333:      new (&opBegin[numOperands]) OpOperand(owner);
    #####:  334:    return MutableArrayRef<OpOperand>(opBegin, newSize);
        -:  335:  }
        -:  336:
        -:  337:  // Otherwise, we need to allocate a new storage.
    45306:  338:  unsigned newCapacity =
    45306:  339:      std::max(unsigned(llvm::NextPowerOf2(capacity + 2)), newSize);
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    45306:  340:  OpOperand *newOperandStorage =
    45306:  341:      reinterpret_cast<OpOperand *>(malloc(sizeof(OpOperand) * newCapacity));
        -:  342:
        -:  343:  // Move the current operands to the new storage.
    45306:  344:  MutableArrayRef<OpOperand> newOperands(newOperandStorage, newSize);
    45306:  345:  std::uninitialized_move(origOperands.begin(), origOperands.end(),
        -:  346:                          newOperands.begin());
        -:  347:
        -:  348:  // Destroy the original operands.
   45306*:  349:  for (auto &operand : origOperands)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####:  350:    operand.~OpOperand();
branch  0 never executed
branch  1 never executed
        -:  351:
        -:  352:  // Initialize any new operands.
   123366:  353:  for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
    78060:  354:    new (&newOperands[numOperands]) OpOperand(owner);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  355:
        -:  356:  // If the current storage is dynamic, free it.
    45306:  357:  if (isStorageDynamic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  358:    free(operandStorage);
        -:  359:
        -:  360:  // Update the storage representation to use the new dynamic storage.
    45306:  361:  operandStorage = newOperandStorage;
    45306:  362:  capacity = newCapacity;
    45306:  363:  isStorageDynamic = true;
    45306:  364:  return newOperands;
        -:  365:}
        -:  366:
        -:  367://===----------------------------------------------------------------------===//
        -:  368:// Operation Value-Iterators
        -:  369://===----------------------------------------------------------------------===//
        -:  370:
        -:  371://===----------------------------------------------------------------------===//
        -:  372:// OperandRange
        -:  373:
function _ZNK4mlir12OperandRange20getBeginOperandIndexEv called 0 returned 0% blocks executed 0%
    #####:  374:unsigned OperandRange::getBeginOperandIndex() const {
    #####:  375:  assert(!empty() && "range must not be empty");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  376:  return base->getOperandNumber();
call    0 never executed
        -:  377:}
        -:  378:
function _ZNK4mlir12OperandRange5splitENS_6detail18DenseArrayAttrImplIiEE called 0 returned 0% blocks executed 0%
    #####:  379:OperandRangeRange OperandRange::split(DenseI32ArrayAttr segmentSizes) const {
    #####:  380:  return OperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  381:}
        -:  382:
        -:  383://===----------------------------------------------------------------------===//
        -:  384:// OperandRangeRange
        -:  385:
function _ZN4mlir17OperandRangeRangeC2ENS_12OperandRangeENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  386:OperandRangeRange::OperandRangeRange(OperandRange operands,
    #####:  387:                                     Attribute operandSegments)
call    0 never executed
        -:  388:    : OperandRangeRange(OwnerT(operands.getBase(), operandSegments), 0,
    #####:  389:                        operandSegments.cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
        -:  390:
function _ZNK4mlir17OperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  391:OperandRange OperandRangeRange::join() const {
    #####:  392:  const OwnerT &owner = getBase();
call    0 never executed
    #####:  393:  ArrayRef<int32_t> sizeData = owner.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  394:  return OperandRange(owner.first,
    #####:  395:                      std::accumulate(sizeData.begin(), sizeData.end(), 0));
        -:  396:}
        -:  397:
function _ZN4mlir17OperandRangeRange11dereferenceERKSt4pairIPNS_9OpOperandENS_9AttributeEEl called 0 returned 0% blocks executed 0%
    #####:  398:OperandRange OperandRangeRange::dereference(const OwnerT &object,
        -:  399:                                            ptrdiff_t index) {
    #####:  400:  ArrayRef<int32_t> sizeData = object.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  401:  uint32_t startIndex =
    #####:  402:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  403:  return OperandRange(object.first + startIndex, *(sizeData.begin() + index));
        -:  404:}
        -:  405:
        -:  406://===----------------------------------------------------------------------===//
        -:  407:// MutableOperandRange
        -:  408:
        -:  409:/// Construct a new mutable range from the given operand, operand start index,
        -:  410:/// and range length.
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationEjjN4llvm8ArrayRefISt4pairIjNS_14NamedAttributeEEEE called 1732 returned 100% blocks executed 75%
     1732:  411:MutableOperandRange::MutableOperandRange(
        -:  412:    Operation *owner, unsigned start, unsigned length,
     1732:  413:    ArrayRef<OperandSegment> operandSegments)
        -:  414:    : owner(owner), start(start), length(length),
     1732:  415:      operandSegments(operandSegments.begin(), operandSegments.end()) {
call    0 returned 100%
    3464*:  416:  assert((start + length) <= owner->getNumOperands() && "invalid range");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
     1732:  417:}
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  418:MutableOperandRange::MutableOperandRange(Operation *owner)
branch  0 never executed
branch  1 never executed
    #####:  419:    : MutableOperandRange(owner, /*start=*/0, owner->getNumOperands()) {}
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  420:
        -:  421:/// Slice this range into a sub range, with the additional operand segment.
        -:  422:MutableOperandRange
function _ZNK4mlir19MutableOperandRange5sliceEjjN4llvm8OptionalISt4pairIjNS_14NamedAttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  423:MutableOperandRange::slice(unsigned subStart, unsigned subLen,
        -:  424:                           Optional<OperandSegment> segment) const {
    #####:  425:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  426:  MutableOperandRange subSlice(owner, start + subStart, subLen,
    #####:  427:                               operandSegments);
call    0 never executed
    #####:  428:  if (segment)
branch  0 never executed
branch  1 never executed
    #####:  429:    subSlice.operandSegments.push_back(*segment);
call    0 never executed
    #####:  430:  return subSlice;
        -:  431:}
        -:  432:
        -:  433:/// Append the given values to the range.
function _ZN4mlir19MutableOperandRange6appendENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  434:void MutableOperandRange::append(ValueRange values) {
    #####:  435:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  436:    return;
    #####:  437:  owner->insertOperands(start + length, values);
call    0 never executed
    #####:  438:  updateLength(length + values.size());
call    0 never executed
        -:  439:}
        -:  440:
        -:  441:/// Assign this range to the given values.
function _ZN4mlir19MutableOperandRange6assignENS_10ValueRangeE called 1732 returned 100% blocks executed 75%
     1732:  442:void MutableOperandRange::assign(ValueRange values) {
     1732:  443:  owner->setOperands(start, length, values);
call    0 returned 100%
     1732:  444:  if (length != values.size())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  445:    updateLength(/*newLength=*/values.size());
call    0 never executed
     1732:  446:}
        -:  447:
        -:  448:/// Assign the range to the given value.
function _ZN4mlir19MutableOperandRange6assignENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  449:void MutableOperandRange::assign(Value value) {
    #####:  450:  if (length == 1) {
branch  0 never executed
branch  1 never executed
    #####:  451:    owner->setOperand(start, value);
call    0 never executed
        -:  452:  } else {
    #####:  453:    owner->setOperands(start, length, value);
call    0 never executed
call    1 never executed
    #####:  454:    updateLength(/*newLength=*/1);
call    0 never executed
        -:  455:  }
    #####:  456:}
        -:  457:
        -:  458:/// Erase the operands within the given sub-range.
function _ZN4mlir19MutableOperandRange5eraseEjj called 0 returned 0% blocks executed 0%
    #####:  459:void MutableOperandRange::erase(unsigned subStart, unsigned subLen) {
    #####:  460:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  461:  if (length == 0)
branch  0 never executed
branch  1 never executed
        -:  462:    return;
    #####:  463:  owner->eraseOperands(start + subStart, subLen);
call    0 never executed
    #####:  464:  updateLength(length - subLen);
call    0 never executed
        -:  465:}
        -:  466:
        -:  467:/// Clear this range and erase all of the operands.
function _ZN4mlir19MutableOperandRange5clearEv called 0 returned 0% blocks executed 0%
    #####:  468:void MutableOperandRange::clear() {
    #####:  469:  if (length != 0) {
branch  0 never executed
branch  1 never executed
    #####:  470:    owner->eraseOperands(start, length);
call    0 never executed
    #####:  471:    updateLength(/*newLength=*/0);
call    0 never executed
        -:  472:  }
    #####:  473:}
        -:  474:
        -:  475:/// Allow implicit conversion to an OperandRange.
function _ZNK4mlir19MutableOperandRangecvNS_12OperandRangeEEv called 0 returned 0% blocks executed 0%
    #####:  476:MutableOperandRange::operator OperandRange() const {
    #####:  477:  return owner->getOperands().slice(start, length);
call    0 never executed
call    1 never executed
        -:  478:}
        -:  479:
        -:  480:MutableOperandRangeRange
function _ZNK4mlir19MutableOperandRange5splitENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  481:MutableOperandRange::split(NamedAttribute segmentSizes) const {
    #####:  482:  return MutableOperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  483:}
        -:  484:
        -:  485:/// Update the length of this range to the one provided.
function _ZN4mlir19MutableOperandRange12updateLengthEj called 0 returned 0% blocks executed 0%
    #####:  486:void MutableOperandRange::updateLength(unsigned newLength) {
    #####:  487:  int32_t diff = int32_t(newLength) - int32_t(length);
    #####:  488:  length = newLength;
        -:  489:
        -:  490:  // Update any of the provided segment attributes.
    #####:  491:  for (OperandSegment &segment : operandSegments) {
branch  0 never executed
branch  1 never executed
    #####:  492:    auto attr = segment.second.getValue().cast<DenseI32ArrayAttr>();
call    0 never executed
    #####:  493:    SmallVector<int32_t, 8> segments(attr.asArrayRef());
call    0 never executed
call    1 never executed
    #####:  494:    segments[segment.first] += diff;
branch  0 never executed
branch  1 never executed
    #####:  495:    segment.second.setValue(
call    0 never executed
    #####:  496:        DenseI32ArrayAttr::get(attr.getContext(), segments));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  497:    owner->setAttr(segment.second.getName(), segment.second.getValue());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  498:  }
    #####:  499:}
        -:  500:
        -:  501://===----------------------------------------------------------------------===//
        -:  502:// MutableOperandRangeRange
        -:  503:
function _ZN4mlir24MutableOperandRangeRangeC2ERKNS_19MutableOperandRangeENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  504:MutableOperandRangeRange::MutableOperandRangeRange(
    #####:  505:    const MutableOperandRange &operands, NamedAttribute operandSegmentAttr)
        -:  506:    : MutableOperandRangeRange(
    #####:  507:          OwnerT(operands, operandSegmentAttr), 0,
call    0 never executed
    #####:  508:          operandSegmentAttr.getValue().cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  509:
function _ZNK4mlir24MutableOperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  510:MutableOperandRange MutableOperandRangeRange::join() const {
    #####:  511:  return getBase().first;
branch  0 never executed
branch  1 never executed
        -:  512:}
        -:  513:
function _ZNK4mlir24MutableOperandRangeRangecvNS_17OperandRangeRangeEEv called 0 returned 0% blocks executed 0%
    #####:  514:MutableOperandRangeRange::operator OperandRangeRange() const {
    #####:  515:  return OperandRangeRange(getBase().first, getBase().second.getValue());
call    0 never executed
call    1 never executed
        -:  516:}
        -:  517:
function _ZN4mlir24MutableOperandRangeRange11dereferenceERKSt4pairINS_19MutableOperandRangeENS_14NamedAttributeEEl called 0 returned 0% blocks executed 0%
    #####:  518:MutableOperandRange MutableOperandRangeRange::dereference(const OwnerT &object,
        -:  519:                                                          ptrdiff_t index) {
    #####:  520:  ArrayRef<int32_t> sizeData =
    #####:  521:      object.second.getValue().cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  522:  uint32_t startIndex =
    #####:  523:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  524:  return object.first.slice(
    #####:  525:      startIndex, *(sizeData.begin() + index),
call    0 never executed
    #####:  526:      MutableOperandRange::OperandSegment(index, object.second));
call    0 never executed
        -:  527:}
        -:  528:
        -:  529://===----------------------------------------------------------------------===//
        -:  530:// ResultRange
        -:  531:
function _ZN4mlir11ResultRangeC2ENS_8OpResultE called 2039 returned 100% blocks executed 100%
     2039:  532:ResultRange::ResultRange(OpResult result)
     2039:  533:    : ResultRange(static_cast<detail::OpResultImpl *>(Value(result).getImpl()),
     2039:  534:                  1) {}
        -:  535:
function _ZNK4mlir11ResultRange7getUsesEv called 1746 returned 100% blocks executed 100%
     1746:  536:ResultRange::use_range ResultRange::getUses() const {
     3492:  537:  return {use_begin(), use_end()};
        -:  538:}
function _ZNK4mlir11ResultRange9use_beginEv called 27750 returned 100% blocks executed 100%
   29496*:  539:ResultRange::use_iterator ResultRange::use_begin() const {
   58992*:  540:  return use_iterator(*this);
        -:  541:}
function _ZNK4mlir11ResultRange7use_endEv called 27750 returned 100% blocks executed 100%
   29496*:  542:ResultRange::use_iterator ResultRange::use_end() const {
   29496*:  543:  return use_iterator(*this, /*end=*/true);
        -:  544:}
function _ZN4mlir11ResultRange8getUsersEv called 0 returned 0% blocks executed 0%
    #####:  545:ResultRange::user_range ResultRange::getUsers() {
    #####:  546:  return {user_begin(), user_end()};
call    0 never executed
        -:  547:}
function _ZN4mlir11ResultRange10user_beginEv called 0 returned 0% blocks executed 0%
    #####:  548:ResultRange::user_iterator ResultRange::user_begin() {
    #####:  549:  return user_iterator(use_begin());
        -:  550:}
function _ZN4mlir11ResultRange8user_endEv called 0 returned 0% blocks executed 0%
    #####:  551:ResultRange::user_iterator ResultRange::user_end() {
    #####:  552:  return user_iterator(use_end());
        -:  553:}
        -:  554:
function _ZN4mlir11ResultRange11UseIteratorC2ES0_b called 0 returned 0% blocks executed 0%
   58992*:  555:ResultRange::UseIterator::UseIterator(ResultRange results, bool end)
   29496*:  556:    : it(end ? results.end() : results.begin()), endIt(results.end()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 97% (fallthrough)
branch  7 taken 3%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
        -:  557:  // Only initialize current use if there are results/can be uses.
   29496*:  558:  if (it != endIt)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 97% (fallthrough)
branch  5 taken 3%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
   28557*:  559:    skipOverResultsWithNoUsers();
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 returned 100%
    #####:  560:}
        -:  561:
function _ZN4mlir11ResultRange11UseIteratorppEv called 23672 returned 100% blocks executed 100%
    23672:  562:ResultRange::UseIterator &ResultRange::UseIterator::operator++() {
        -:  563:  // We increment over uses, if we reach the last use then move to next
        -:  564:  // result.
    23672:  565:  if (use != (*it).use_end())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    23672:  566:    ++use;
    23672:  567:  if (use == (*it).use_end()) {
call    0 returned 100%
branch  1 taken 79% (fallthrough)
branch  2 taken 21%
    18787:  568:    ++it;
call    0 returned 100%
    18787:  569:    skipOverResultsWithNoUsers();
call    0 returned 100%
        -:  570:  }
    23672:  571:  return *this;
        -:  572:}
        -:  573:
function _ZN4mlir11ResultRange11UseIterator26skipOverResultsWithNoUsersEv called 47344 returned 100% blocks executed 100%
    47344:  574:void ResultRange::UseIterator::skipOverResultsWithNoUsers() {
    28557:  575:  while (it != endIt && (*it).use_empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
    47352:  576:    ++it;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  577:
        -:  578:  // If we are at the last result, then set use to first use of
        -:  579:  // first result (sentinel value used for end).
    47344:  580:  if (it == endIt)
branch  0 taken 100%
branch  1 taken 0%
    18795:  581:    use = {};
        -:  582:  else
    28549:  583:    use = (*it).use_begin();
call    0 returned 100%
    47344:  584:}
        -:  585:
function _ZN4mlir11ResultRange18replaceAllUsesWithEPNS_9OperationE called 1287 returned 100% blocks executed 100%
     1287:  586:void ResultRange::replaceAllUsesWith(Operation *op) {
     2574:  587:  replaceAllUsesWith(op->getResults());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     1287:  588:}
        -:  589:
        -:  590://===----------------------------------------------------------------------===//
        -:  591:// ValueRange
        -:  592:
function _ZN4mlir10ValueRangeC2EN4llvm8ArrayRefINS_5ValueEEE called 4989983 returned 100% blocks executed 100%
  5006007:  593:ValueRange::ValueRange(ArrayRef<Value> values)
  5006007:  594:    : ValueRange(values.data(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
function _ZN4mlir10ValueRangeC2ENS_12OperandRangeE called 72023 returned 100% blocks executed 100%
   142669:  595:ValueRange::ValueRange(OperandRange values)
   142669:  596:    : ValueRange(values.begin().getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
function _ZN4mlir10ValueRangeC2ENS_11ResultRangeE called 102802 returned 100% blocks executed 100%
  172664*:  597:ValueRange::ValueRange(ResultRange values)
  172664*:  598:    : ValueRange(values.getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 returned 100%
        -:  599:
        -:  600:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange11offset_baseERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 240 returned 100% blocks executed 38%
      240:  601:ValueRange::OwnerT ValueRange::offset_base(const OwnerT &owner,
        -:  602:                                           ptrdiff_t index) {
      240:  603:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      240:  604:    return {value + index};
call    0 returned 100%
    #####:  605:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  606:    return {operand + index};
call    0 never executed
    #####:  607:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  608:}
        -:  609:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange20dereference_iteratorERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 5110366 returned 100% blocks executed 100%
  5110366:  610:Value ValueRange::dereference_iterator(const OwnerT &owner, ptrdiff_t index) {
  5110366:  611:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
  4957208:  612:    return value[index];
   153158:  613:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 returned 100%
branch  1 taken 96% (fallthrough)
branch  2 taken 4%
   146869:  614:    return operand[index].get();
     6289:  615:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 returned 100%
call    1 returned 100%
        -:  616:}
        -:  617:
        -:  618://===----------------------------------------------------------------------===//
        -:  619:// Operation Equivalency
        -:  620://===----------------------------------------------------------------------===//
        -:  621:
function _ZN4mlir20OperationEquivalence11computeHashEPNS_9OperationEN4llvm12function_refIFNS3_9hash_codeENS_5ValueEEEES8_NS0_5FlagsE called 69862 returned 100% blocks executed 97%
    69862:  622:llvm::hash_code OperationEquivalence::computeHash(
        -:  623:    Operation *op, function_ref<llvm::hash_code(Value)> hashOperands,
        -:  624:    function_ref<llvm::hash_code(Value)> hashResults, Flags flags) {
        -:  625:  // Hash operations based upon their:
        -:  626:  //   - Operation Name
        -:  627:  //   - Attributes
        -:  628:  //   - Result Types
    69862:  629:  llvm::hash_code hash = llvm::hash_combine(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    69862:  630:      op->getName(), op->getAttrDictionary(), op->getResultTypes());
call    0 returned 100%
        -:  631:
        -:  632:  //   - Operands
    69862:  633:  ValueRange operands = op->getOperands();
call    0 returned 100%
call    1 returned 100%
    69862:  634:  SmallVector<Value> operandStorage;
call    0 returned 100%
    69862:  635:  if (op->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 22% (fallthrough)
branch  2 taken 78%
    15480:  636:    operandStorage.append(operands.begin(), operands.end());
call    0 returned 100%
    15480:  637:    llvm::sort(operandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  638:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  639:    });
    15480:  640:    operands = operandStorage;
call    0 returned 100%
        -:  641:  }
   234588:  642:  for (Value operand : operands)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
    82363:  643:    hash = llvm::hash_combine(hash, hashOperands(operand));
call    0 returned 100%
call    1 returned 100%
        -:  644:
        -:  645:  //   - Operands
   209586:  646:  for (Value result : op->getResults())
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
    69862:  647:    hash = llvm::hash_combine(hash, hashResults(result));
call    0 returned 100%
call    1 returned 100%
    69862:  648:  return hash;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  649:}
        -:  650:
        -:  651:static bool
function _ZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsE called 0 returned 0% blocks executed 0%
    #####:  652:isRegionEquivalentTo(Region *lhs, Region *rhs,
        -:  653:                     function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  654:                     function_ref<LogicalResult(Value, Value)> mapResults,
        -:  655:                     OperationEquivalence::Flags flags) {
    #####:  656:  DenseMap<Block *, Block *> blocksMap;
call    0 never executed
function _ZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ called 0 returned 0% blocks executed 0%
    #####:  657:  auto blocksEquivalent = [&](Block &lBlock, Block &rBlock) {
        -:  658:    // Check block arguments.
    #####:  659:    if (lBlock.getNumArguments() != rBlock.getNumArguments())
branch  0 never executed
branch  1 never executed
        -:  660:      return false;
        -:  661:
        -:  662:    // Map the two blocks.
    #####:  663:    auto insertion = blocksMap.insert({&lBlock, &rBlock});
call    0 never executed
    #####:  664:    if (insertion.first->getSecond() != &rBlock)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  665:      return false;
        -:  666:
    #####:  667:    for (auto argPair :
    #####:  668:         llvm::zip(lBlock.getArguments(), rBlock.getArguments())) {
branch  0 never executed
branch  1 never executed
    #####:  669:      Value curArg = std::get<0>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  670:      Value otherArg = std::get<1>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  671:      if (curArg.getType() != otherArg.getType())
branch  0 never executed
branch  1 never executed
    #####:  672:        return false;
    #####:  673:      if (!(flags & OperationEquivalence::IgnoreLocations) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  674:          curArg.getLoc() != otherArg.getLoc())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  675:        return false;
        -:  676:      // Check if this value was already mapped to another value.
    #####:  677:      if (failed(mapOperands(curArg, otherArg)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  678:        return false;
        -:  679:    }
        -:  680:
function _ZZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ENKUlRNS_9OperationESE_E_clESE_SE_ called 0 returned 0% blocks executed 0%
    #####:  681:    auto opsEquivalent = [&](Operation &lOp, Operation &rOp) {
        -:  682:      // Check for op equality (recursively).
    #####:  683:      if (!OperationEquivalence::isEquivalentTo(&lOp, &rOp, mapOperands,
branch  0 never executed
branch  1 never executed
    #####:  684:                                                mapResults, flags))
call    0 never executed
        -:  685:        return false;
        -:  686:      // Check successor mapping.
    #####:  687:      for (auto successorsPair :
call    0 never executed
    #####:  688:           llvm::zip(lOp.getSuccessors(), rOp.getSuccessors())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  689:        Block *curSuccessor = std::get<0>(successorsPair);
call    0 never executed
    #####:  690:        Block *otherSuccessor = std::get<1>(successorsPair);
call    0 never executed
    #####:  691:        auto insertion = blocksMap.insert({curSuccessor, otherSuccessor});
call    0 never executed
    #####:  692:        if (insertion.first->getSecond() != otherSuccessor)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  693:          return false;
        -:  694:      }
    #####:  695:      return true;
    #####:  696:    };
    #####:  697:    return llvm::all_of_zip(lBlock, rBlock, opsEquivalent);
call    0 never executed
    #####:  698:  };
    #####:  699:  return llvm::all_of_zip(*lhs, *rhs, blocksEquivalent);
call    0 never executed
call    1 never executed
        -:  700:}
        -:  701:
function _ZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsE called 14056 returned 100% blocks executed 58%
    14056:  702:bool OperationEquivalence::isEquivalentTo(
        -:  703:    Operation *lhs, Operation *rhs,
        -:  704:    function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  705:    function_ref<LogicalResult(Value, Value)> mapResults, Flags flags) {
    14056:  706:  if (lhs == rhs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  707:    return true;
        -:  708:
        -:  709:  // Compare the operation properties.
    14056:  710:  if (lhs->getName() != rhs->getName() ||
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
     1536:  711:      lhs->getAttrDictionary() != rhs->getAttrDictionary() ||
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
      392:  712:      lhs->getNumRegions() != rhs->getNumRegions() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      392:  713:      lhs->getNumSuccessors() != rhs->getNumSuccessors() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    14840:  714:      lhs->getNumOperands() != rhs->getNumOperands() ||
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
      392:  715:      lhs->getNumResults() != rhs->getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  716:    return false;
     392*:  717:  if (!(flags & IgnoreLocations) && lhs->getLoc() != rhs->getLoc())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  718:    return false;
        -:  719:
      392:  720:  ValueRange lhsOperands = lhs->getOperands(), rhsOperands = rhs->getOperands();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      784:  721:  SmallVector<Value> lhsOperandStorage, rhsOperandStorage;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      392:  722:  if (lhs->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 69% (fallthrough)
branch  2 taken 31%
      272:  723:    lhsOperandStorage.append(lhsOperands.begin(), lhsOperands.end());
call    0 returned 100%
      272:  724:    llvm::sort(lhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  725:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  726:    });
      272:  727:    lhsOperands = lhsOperandStorage;
call    0 returned 100%
        -:  728:
      272:  729:    rhsOperandStorage.append(rhsOperands.begin(), rhsOperands.end());
call    0 returned 100%
      272:  730:    llvm::sort(rhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  731:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  732:    });
      272:  733:    rhsOperands = rhsOperandStorage;
call    0 returned 100%
        -:  734:  }
      392:  735:  auto checkValueRangeMapping =
function _ZZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsEENKUlNS_10ValueRangeESA_S8_E1_clESA_SA_S8_.isra.0 called 392 returned 100% blocks executed 80%
      392:  736:      [](ValueRange lhs, ValueRange rhs,
        -:  737:         function_ref<LogicalResult(Value, Value)> mapValues) {
     392*:  738:        for (auto operandPair : llvm::zip(lhs, rhs)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      392:  739:          Value curArg = std::get<0>(operandPair);
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
      392:  740:          Value otherArg = std::get<1>(operandPair);
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
      392:  741:          if (curArg.getType() != otherArg.getType())
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
      392:  742:            return false;
      308:  743:          if (failed(mapValues(curArg, otherArg)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  744:            return false;
        -:  745:        }
    #####:  746:        return true;
        -:  747:      };
        -:  748:  // Check mapping of operands and results.
      392:  749:  if (!checkValueRangeMapping(lhsOperands, rhsOperands, mapOperands))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  750:    return false;
    #####:  751:  if (!checkValueRangeMapping(lhs->getResults(), rhs->getResults(), mapResults))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  752:    return false;
    #####:  753:  for (auto regionPair : llvm::zip(lhs->getRegions(), rhs->getRegions()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  754:    if (!isRegionEquivalentTo(&std::get<0>(regionPair),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:                              &std::get<1>(regionPair), mapOperands, mapResults,
call    0 never executed
        -:  756:                              flags))
    #####:  757:      return false;
    #####:  758:  return true;
        -:  759:}
