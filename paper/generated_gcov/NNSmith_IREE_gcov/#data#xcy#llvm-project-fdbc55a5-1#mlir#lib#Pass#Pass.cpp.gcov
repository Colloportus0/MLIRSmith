        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Pass/Pass.cpp
        -:    0:Graph:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/Pass.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/Pass.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- Pass.cpp - Pass infrastructure implementation ----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements common pass infrastructure.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Pass/Pass.h"
        -:   14:#include "PassDetail.h"
        -:   15:#include "mlir/IR/Diagnostics.h"
        -:   16:#include "mlir/IR/Dialect.h"
        -:   17:#include "mlir/IR/OpDefinition.h"
        -:   18:#include "mlir/IR/Threading.h"
        -:   19:#include "mlir/IR/Verifier.h"
        -:   20:#include "mlir/Support/FileUtilities.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/ScopeExit.h"
        -:   23:#include "llvm/Support/CommandLine.h"
        -:   24:#include "llvm/Support/CrashRecoveryContext.h"
        -:   25:#include "llvm/Support/Mutex.h"
        -:   26:#include "llvm/Support/Signals.h"
        -:   27:#include "llvm/Support/Threading.h"
        -:   28:#include "llvm/Support/ToolOutputFile.h"
        -:   29:
        -:   30:using namespace mlir;
        -:   31:using namespace mlir::detail;
        -:   32:
        -:   33://===----------------------------------------------------------------------===//
        -:   34:// Pass
        -:   35://===----------------------------------------------------------------------===//
        -:   36:
        -:   37:/// Out of line virtual method to ensure vtables and metadata are emitted to a
        -:   38:/// single .o file.
function _ZN4mlir4Pass6anchorEv called 0 returned 0% blocks executed 0%
    #####:   39:void Pass::anchor() {}
        -:   40:
        -:   41:/// Attempt to initialize the options of this pass from the given string.
function _ZN4mlir4Pass17initializeOptionsEN4llvm9StringRefE called 295298 returned 100% blocks executed 100%
   295298:   42:LogicalResult Pass::initializeOptions(StringRef options) {
   295298:   43:  return passOptions.parseFromString(options);
call    0 returned 100%
        -:   44:}
        -:   45:
        -:   46:/// Copy the option values from 'other', which is another instance of this
        -:   47:/// pass.
function _ZN4mlir4Pass20copyOptionValuesFromEPKS0_ called 0 returned 0% blocks executed 0%
 6224256*:   48:void Pass::copyOptionValuesFrom(const Pass *other) {
 6224256*:   49:  passOptions.copyOptionValuesFrom(other->passOptions);
call    0 never executed
call    1 returned 100%
    #####:   50:}
        -:   51:
        -:   52:/// Prints out the pass in the textual representation of pipelines. If this is
        -:   53:/// an adaptor pass, print its pass managers.
function _ZN4mlir4Pass22printAsTextualPipelineERN4llvm11raw_ostreamE called 6432 returned 100% blocks executed 100%
     6432:   54:void Pass::printAsTextualPipeline(raw_ostream &os) {
        -:   55:  // Special case for adaptors to print its pass managers.
     6432:   56:  if (auto *adaptor = dyn_cast<OpToOpPassAdaptor>(this)) {
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
     1637:   57:    llvm::interleave(
call    0 returned 100%
     1637:   58:        adaptor->getPassManagers(),
call    0 returned 100%
    1637*:   59:        [&](OpPassManager &pm) { pm.printAsTextualPipeline(os); },
call    0 returned 100%
call    1 never executed
    #####:   60:        [&] { os << ","; });
call    0 never executed
     1637:   61:    return;
        -:   62:  }
        -:   63:  // Otherwise, print the pass argument followed by its options. If the pass
        -:   64:  // doesn't have an argument, print the name of the pass to give some indicator
        -:   65:  // of what pass was run.
     4795:   66:  StringRef argument = getArgument();
call    0 returned 100%
     4795:   67:  if (!argument.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     4774:   68:    os << argument;
call    0 returned 100%
        -:   69:  else
       21:   70:    os << "unknown<" << getName() << ">";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     4795:   71:  passOptions.print(os);
call    0 returned 100%
        -:   72:}
        -:   73:
        -:   74://===----------------------------------------------------------------------===//
        -:   75:// OpPassManagerImpl
        -:   76://===----------------------------------------------------------------------===//
        -:   77:
        -:   78:namespace mlir {
        -:   79:namespace detail {
        -:   80:struct OpPassManagerImpl {
function _ZN4mlir6detail17OpPassManagerImplC2ENS_13OperationNameENS_13OpPassManager7NestingE called 172689 returned 100% blocks executed 80%
   172689:   81:  OpPassManagerImpl(OperationName opName, OpPassManager::Nesting nesting)
   172689:   82:      : name(opName.getStringRef().str()), opName(opName),
call    0 returned 100%
   172689:   83:        initializationGeneration(0), nesting(nesting) {}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
function _ZN4mlir6detail17OpPassManagerImplC2EN4llvm9StringRefENS_13OpPassManager7NestingE called 116425 returned 100% blocks executed 57%
   116425:   84:  OpPassManagerImpl(StringRef name, OpPassManager::Nesting nesting)
  116425*:   85:      : name(name == OpPassManager::getAnyOpAnchorName() ? "" : name.str()),
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  116425*:   86:        initializationGeneration(0), nesting(nesting) {}
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   87:  OpPassManagerImpl(OpPassManager::Nesting nesting)
    #####:   88:      : initializationGeneration(0), nesting(nesting) {}
function _ZN4mlir6detail17OpPassManagerImplC2ERKS1_ called 5348232 returned 100% blocks executed 80%
  5348232:   89:  OpPassManagerImpl(const OpPassManagerImpl &rhs)
  5348232:   90:      : name(rhs.name), opName(rhs.opName),
  5348232:   91:        initializationGeneration(rhs.initializationGeneration),
  5348232:   92:        nesting(rhs.nesting) {
call    0 returned 100%
 11572488:   93:    for (const std::unique_ptr<Pass> &pass : rhs.passes) {
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
call    2 returned 100%
 12448512:   94:      std::unique_ptr<Pass> newPass = pass->clone();
call    0 returned 100%
  6224256:   95:      newPass->threadingSibling = pass.get();
call    0 returned 100%
  6224256:   96:      passes.push_back(std::move(newPass));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   97:    }
  5348232:   98:  }
        -:   99:
        -:  100:  /// Merge the passes of this pass manager into the one provided.
        -:  101:  void mergeInto(OpPassManagerImpl &rhs);
        -:  102:
        -:  103:  /// Nest a new operation pass manager for the given operation kind under this
        -:  104:  /// pass manager.
function _ZN4mlir6detail17OpPassManagerImpl4nestENS_13OperationNameE called 0 returned 0% blocks executed 0%
    #####:  105:  OpPassManager &nest(OperationName nestedName) {
    #####:  106:    return nest(OpPassManager(nestedName, nesting));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  107:  }
function _ZN4mlir6detail17OpPassManagerImpl4nestEN4llvm9StringRefE called 113461 returned 100% blocks executed 80%
   113461:  108:  OpPassManager &nest(StringRef nestedName) {
   113461:  109:    return nest(OpPassManager(nestedName, nesting));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  110:  }
function _ZN4mlir6detail17OpPassManagerImpl7nestAnyEv called 0 returned 0% blocks executed 0%
    #####:  111:  OpPassManager &nestAny() { return nest(OpPassManager(nesting)); }
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  112:
        -:  113:  /// Nest the given pass manager under this pass manager.
        -:  114:  OpPassManager &nest(OpPassManager &&nested);
        -:  115:
        -:  116:  /// Add the given pass to this pass manager. If this pass has a concrete
        -:  117:  /// operation type, it must be the same type as this pass manager.
        -:  118:  void addPass(std::unique_ptr<Pass> pass);
        -:  119:
        -:  120:  /// Clear the list of passes in this pass manager, other options are
        -:  121:  /// preserved.
        -:  122:  void clear();
        -:  123:
        -:  124:  /// Finalize the pass list in preparation for execution. This includes
        -:  125:  /// coalescing adjacent pass managers when possible, verifying scheduled
        -:  126:  /// passes, etc.
        -:  127:  LogicalResult finalizePassList(MLIRContext *ctx);
        -:  128:
        -:  129:  /// Return the operation name of this pass manager.
function _ZN4mlir6detail17OpPassManagerImpl9getOpNameERNS_11MLIRContextE called 520879 returned 100% blocks executed 88%
   520879:  130:  Optional<OperationName> getOpName(MLIRContext &context) {
   520879:  131:    if (!name.empty() && !opName)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 18% (fallthrough)
branch  3 taken 82%
   187641:  132:      opName = OperationName(name, &context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   520878:  133:    return opName;
        -:  134:  }
   915868:  135:  Optional<StringRef> getOpName() const {
  915868*:  136:    return name.empty() ? Optional<StringRef>() : Optional<StringRef>(name);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  137:  }
        -:  138:
        -:  139:  /// Return the name used to anchor this pass manager. This is either the name
        -:  140:  /// of an operation, or the result of `getAnyOpAnchorName()` in the case of an
        -:  141:  /// op-agnostic pass manager.
function _ZNK4mlir6detail17OpPassManagerImpl15getOpAnchorNameEv called 65928 returned 100% blocks executed 83%
    65928:  142:  StringRef getOpAnchorName() const {
   131856:  143:    return getOpName().value_or(OpPassManager::getAnyOpAnchorName());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  144:  }
        -:  145:
        -:  146:  /// Indicate if the current pass manager can be scheduled on the given
        -:  147:  /// operation type.
        -:  148:  bool canScheduleOn(MLIRContext &context, OperationName opName);
        -:  149:
        -:  150:  /// The name of the operation that passes of this pass manager operate on.
        -:  151:  std::string name;
        -:  152:
        -:  153:  /// The cached OperationName (internalized in the context) for the name of the
        -:  154:  /// operation that passes of this pass manager operate on.
        -:  155:  Optional<OperationName> opName;
        -:  156:
        -:  157:  /// The set of passes to run as part of this pass manager.
        -:  158:  std::vector<std::unique_ptr<Pass>> passes;
        -:  159:
        -:  160:  /// The current initialization generation of this pass manager. This is used
        -:  161:  /// to indicate when a pass manager should be reinitialized.
        -:  162:  unsigned initializationGeneration;
        -:  163:
        -:  164:  /// Control the implicit nesting of passes that mismatch the name set for this
        -:  165:  /// OpPassManager.
        -:  166:  OpPassManager::Nesting nesting;
        -:  167:};
        -:  168:} // namespace detail
        -:  169:} // namespace mlir
        -:  170:
function _ZN4mlir6detail17OpPassManagerImpl9mergeIntoERS1_ called 21506 returned 100% blocks executed 79%
    21506:  171:void OpPassManagerImpl::mergeInto(OpPassManagerImpl &rhs) {
   21506*:  172:  assert(name == rhs.name && "merging unrelated pass managers");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    43022:  173:  for (auto &pass : passes)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
    21516:  174:    rhs.passes.push_back(std::move(pass));
call    0 returned 100%
    21506:  175:  passes.clear();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    21506:  176:}
        -:  177:
function _ZN4mlir6detail17OpPassManagerImpl4nestEONS_13OpPassManagerE called 113461 returned 100% blocks executed 67%
   113461:  178:OpPassManager &OpPassManagerImpl::nest(OpPassManager &&nested) {
   113461:  179:  auto *adaptor = new OpToOpPassAdaptor(std::move(nested));
call    0 returned 100%
call    1 returned 100%
   113461:  180:  addPass(std::unique_ptr<Pass>(adaptor));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   113461:  181:  return adaptor->getPassManagers().front();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  182:}
        -:  183:
function _ZN4mlir6detail17OpPassManagerImpl7addPassESt10unique_ptrINS_4PassESt14default_deleteIS3_EE called 542750 returned 100% blocks executed 38%
   542750:  184:void OpPassManagerImpl::addPass(std::unique_ptr<Pass> pass) {
        -:  185:  // If this pass runs on a different operation than this pass manager, then
        -:  186:  // implicitly nest a pass manager for this operation if enabled.
   542750:  187:  Optional<StringRef> pmOpName = getOpName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   542750:  188:  Optional<StringRef> passOpName = pass->getOpName();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   542750:  189:  if (pmOpName && passOpName && *pmOpName != *passOpName) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 54% (fallthrough)
branch  3 taken 46%
branch  4 taken 34% (fallthrough)
branch  5 taken 66%
    97825:  190:    if (nesting == OpPassManager::Nesting::Implicit)
branch  0 taken 100%
branch  1 taken 0%
    97825:  191:      return nest(*passOpName).addPass(std::move(pass));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  192:    llvm::report_fatal_error(llvm::Twine("Can't add pass '") + pass->getName() +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  193:                             "' restricted to '" + *passOpName +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  194:                             "' on a PassManager intended to run on '" +
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  195:                             getOpAnchorName() + "', did you intend to nest?");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  196:  }
        -:  197:
   444925:  198:  passes.emplace_back(std::move(pass));
call    0 returned 100%
        -:  199:}
        -:  200:
function _ZN4mlir6detail17OpPassManagerImpl5clearEv called 0 returned 0% blocks executed 0%
    #####:  201:void OpPassManagerImpl::clear() { passes.clear(); }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  202:
function _ZN4mlir6detail17OpPassManagerImpl16finalizePassListEPNS_11MLIRContextE called 266510 returned 100% blocks executed 92%
   266510:  203:LogicalResult OpPassManagerImpl::finalizePassList(MLIRContext *ctx) {
function _ZZN4mlir6detail17OpPassManagerImpl16finalizePassListEPNS_11MLIRContextEENKUlPNS0_17OpToOpPassAdaptorEE_clES5_.isra.0 called 87731 returned 100% blocks executed 89%
   179686:  204:  auto finalizeAdaptor = [ctx](OpToOpPassAdaptor *adaptor) {
call    0 returned 100%
   179686:  205:    for (auto &pm : adaptor->getPassManagers())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    91955:  206:      if (failed(pm.getImpl().finalizePassList(ctx)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        return failure();
    87731:  208:    return success();
   266510:  209:  };
        -:  210:
        -:  211:  // Walk the pass list and merge adjacent adaptors.
   266510:  212:  OpToOpPassAdaptor *lastAdaptor = nullptr;
   711449:  213:  for (auto &pass : passes) {
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
call    2 returned 100%
        -:  214:    // Check to see if this pass is an adaptor.
   444938:  215:    if (auto *currentAdaptor = dyn_cast<OpToOpPassAdaptor>(pass.get())) {
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
        -:  216:      // If it is the first adaptor in a possible chain, remember it and
        -:  217:      // continue.
   113461:  218:      if (!lastAdaptor) {
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
    87731:  219:        lastAdaptor = currentAdaptor;
    87731:  220:        continue;
        -:  221:      }
        -:  222:
        -:  223:      // Otherwise, try to merge into the existing adaptor and delete the
        -:  224:      // current one. If merging fails, just remember this as the last adaptor.
    25730:  225:      if (succeeded(currentAdaptor->tryMergeInto(ctx, *lastAdaptor)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   470669:  226:        pass.reset();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  227:      else
        -:  228:        lastAdaptor = currentAdaptor;
   331478:  229:    } else if (lastAdaptor) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:  230:      // If this pass isn't an adaptor, finalize it and forget the last adaptor.
    34811:  231:      if (failed(finalizeAdaptor(lastAdaptor)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  232:        return failure();
        -:  233:      lastAdaptor = nullptr;
        -:  234:    }
        -:  235:  }
        -:  236:
        -:  237:  // If there was an adaptor at the end of the manager, finalize it as well.
   266511:  238:  if (lastAdaptor && failed(finalizeAdaptor(lastAdaptor)))
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  239:    return failure();
        -:  240:
        -:  241:  // Now that the adaptors have been merged, erase any empty slots corresponding
        -:  242:  // to the merged adaptors that were nulled-out in the loop above.
   266511:  243:  llvm::erase_if(passes, std::logical_not<std::unique_ptr<Pass>>());
call    0 returned 100%
        -:  244:
        -:  245:  // If this is a op-agnostic pass manager, there is nothing left to do.
   266508:  246:  Optional<OperationName> rawOpName = getOpName(*ctx);
call    0 returned 100%
   266509:  247:  if (!rawOpName)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  248:    return success();
        -:  249:
        -:  250:  // Otherwise, verify that all of the passes are valid for the current
        -:  251:  // operation anchor.
   266509:  252:  Optional<RegisteredOperationName> opName = rawOpName->getRegisteredInfo();
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
   658213:  253:  for (std::unique_ptr<Pass> &pass : passes) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
   400645:  254:    if (opName && !pass->canScheduleOn(*opName)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
call    2 returned 100%
branch  3 taken 98% (fallthrough)
branch  4 taken 2%
    17884:  255:      return emitError(UnknownLoc::get(ctx))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
     8942:  256:             << "unable to schedule pass '" << pass->getName()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    17884:  257:             << "' on a PassManager intended to run on '" << getOpAnchorName()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     8942:  258:             << "'!";
call    0 returned 100%
        -:  259:    }
        -:  260:  }
   257568:  261:  return success();
        -:  262:}
        -:  263:
function _ZN4mlir6detail17OpPassManagerImpl13canScheduleOnERNS_11MLIRContextENS_13OperationNameE called 74829 returned 100% blocks executed 36%
    74829:  264:bool OpPassManagerImpl::canScheduleOn(MLIRContext &context,
        -:  265:                                      OperationName opName) {
        -:  266:  // If this pass manager is op-specific, we simply check if the provided
        -:  267:  // operation name is the same as this one.
    74829:  268:  Optional<OperationName> pmOpName = getOpName(context);
call    0 returned 100%
    74830:  269:  if (pmOpName)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    74830:  270:    return pmOpName == opName;
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:  271:
        -:  272:  // Otherwise, this is an op-agnostic pass manager. Check that the operation
        -:  273:  // can be scheduled on all passes within the manager.
    #####:  274:  Optional<RegisteredOperationName> registeredInfo = opName.getRegisteredInfo();
branch  0 never executed
branch  1 never executed
    #####:  275:  if (!registeredInfo ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  276:      !registeredInfo->hasTrait<OpTrait::IsIsolatedFromAbove>())
call    0 never executed
    #####:  277:    return false;
function _ZZN4mlir6detail17OpPassManagerImpl13canScheduleOnERNS_11MLIRContextENS_13OperationNameEENKUlRKSt10unique_ptrINS_4PassESt14default_deleteIS6_EEE_clESB_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  278:  return llvm::all_of(passes, [&](const std::unique_ptr<Pass> &pass) {
call    0 never executed
    #####:  279:    return pass->canScheduleOn(*registeredInfo);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  280:  });
        -:  281:}
        -:  282:
        -:  283://===----------------------------------------------------------------------===//
        -:  284:// OpPassManager
        -:  285://===----------------------------------------------------------------------===//
        -:  286:
function _ZN4mlir13OpPassManagerC2ENS0_7NestingE called 0 returned 0% blocks executed 0%
    #####:  287:OpPassManager::OpPassManager(Nesting nesting)
    #####:  288:    : impl(new OpPassManagerImpl(nesting)) {}
call    0 never executed
function _ZN4mlir13OpPassManagerC2EN4llvm9StringRefENS0_7NestingE called 116423 returned 100% blocks executed 100%
   116423:  289:OpPassManager::OpPassManager(StringRef name, Nesting nesting)
   116423:  290:    : impl(new OpPassManagerImpl(name, nesting)) {}
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir13OpPassManagerC2ENS_13OperationNameENS0_7NestingE called 172689 returned 100% blocks executed 100%
   172689:  291:OpPassManager::OpPassManager(OperationName name, Nesting nesting)
   172689:  292:    : impl(new OpPassManagerImpl(name, nesting)) {}
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir13OpPassManagerC2EOS0_ called 866 returned 100% blocks executed 100%
  121766*:  293:OpPassManager::OpPassManager(OpPassManager &&rhs) : impl(std::move(rhs.impl)) {}
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
function _ZN4mlir13OpPassManagerC2ERKS0_ called 0 returned 0% blocks executed 0%
 5348232*:  294:OpPassManager::OpPassManager(const OpPassManager &rhs) { *this = rhs; }
call    0 returned 100%
call    1 never executed
function _ZN4mlir13OpPassManageraSERKS0_ called 5348232 returned 100% blocks executed 80%
  5348232:  295:OpPassManager &OpPassManager::operator=(const OpPassManager &rhs) {
 10696464:  296:  impl = std::make_unique<OpPassManagerImpl>(*rhs.impl);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  5348232:  297:  return *this;
        -:  298:}
        -:  299:
        -:  300:OpPassManager::~OpPassManager() = default;
        -:  301:
function _ZN4mlir13OpPassManager5beginEv called 121544 returned 100% blocks executed 100%
   605502:  302:OpPassManager::pass_iterator OpPassManager::begin() {
   483958:  303:  return MutableArrayRef<std::unique_ptr<Pass>>{impl->passes}.begin();
        -:  304:}
function _ZN4mlir13OpPassManager3endEv called 121544 returned 100% blocks executed 100%
   605502:  305:OpPassManager::pass_iterator OpPassManager::end() {
   483958:  306:  return MutableArrayRef<std::unique_ptr<Pass>>{impl->passes}.end();
        -:  307:}
        -:  308:
function _ZNK4mlir13OpPassManager5beginEv called 0 returned 0% blocks executed 0%
  287244*:  309:OpPassManager::const_pass_iterator OpPassManager::begin() const {
  287244*:  310:  return ArrayRef<std::unique_ptr<Pass>>{impl->passes}.begin();
        -:  311:}
function _ZNK4mlir13OpPassManager3endEv called 0 returned 0% blocks executed 0%
  287244*:  312:OpPassManager::const_pass_iterator OpPassManager::end() const {
  287244*:  313:  return ArrayRef<std::unique_ptr<Pass>>{impl->passes}.end();
        -:  314:}
        -:  315:
        -:  316:/// Nest a new operation pass manager for the given operation kind under this
        -:  317:/// pass manager.
function _ZN4mlir13OpPassManager4nestENS_13OperationNameE called 0 returned 0% blocks executed 0%
    #####:  318:OpPassManager &OpPassManager::nest(OperationName nestedName) {
    #####:  319:  return impl->nest(nestedName);
call    0 never executed
        -:  320:}
function _ZN4mlir13OpPassManager4nestEN4llvm9StringRefE called 15636 returned 100% blocks executed 100%
    15636:  321:OpPassManager &OpPassManager::nest(StringRef nestedName) {
    15636:  322:  return impl->nest(nestedName);
call    0 returned 100%
        -:  323:}
function _ZN4mlir13OpPassManager7nestAnyEv called 0 returned 0% blocks executed 0%
    #####:  324:OpPassManager &OpPassManager::nestAny() { return impl->nestAny(); }
call    0 never executed
        -:  325:
        -:  326:/// Add the given pass to this pass manager. If this pass has a concrete
        -:  327:/// operation type, it must be the same type as this pass manager.
function _ZN4mlir13OpPassManager7addPassESt10unique_ptrINS_4PassESt14default_deleteIS2_EE called 429291 returned 100% blocks executed 60%
   429291:  328:void OpPassManager::addPass(std::unique_ptr<Pass> pass) {
   429291:  329:  impl->addPass(std::move(pass));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   429302:  330:}
        -:  331:
function _ZN4mlir13OpPassManager5clearEv called 0 returned 0% blocks executed 0%
    #####:  332:void OpPassManager::clear() { impl->clear(); }
branch  0 never executed
branch  1 never executed
        -:  333:
        -:  334:/// Returns the number of passes held by this manager.
function _ZNK4mlir13OpPassManager4sizeEv called 0 returned 0% blocks executed 0%
    #####:  335:size_t OpPassManager::size() const { return impl->passes.size(); }
        -:  336:
        -:  337:/// Returns the internal implementation instance.
function _ZN4mlir13OpPassManager7getImplEv called 0 returned 0% blocks executed 0%
   91955*:  338:OpPassManagerImpl &OpPassManager::getImpl() { return *impl; }
call    0 returned 100%
        -:  339:
        -:  340:/// Return the operation name that this pass manager operates on.
function _ZNK4mlir13OpPassManager9getOpNameEv called 295298 returned 100% blocks executed 75%
   307190:  341:Optional<StringRef> OpPassManager::getOpName() const {
   295298:  342:  return impl->getOpName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  343:}
        -:  344:
        -:  345:/// Return the operation name that this pass manager operates on.
function _ZNK4mlir13OpPassManager9getOpNameERNS_11MLIRContextE called 0 returned 0% blocks executed 0%
  179543*:  346:Optional<OperationName> OpPassManager::getOpName(MLIRContext &context) const {
    #####:  347:  return impl->getOpName(context);
call    0 never executed
        -:  348:}
        -:  349:
function _ZNK4mlir13OpPassManager15getOpAnchorNameEv called 976 returned 100% blocks executed 100%
    56986:  350:StringRef OpPassManager::getOpAnchorName() const {
      976:  351:  return impl->getOpAnchorName();
call    0 returned 100%
        -:  352:}
        -:  353:
        -:  354:/// Prints out the passes of the pass manager as the textual representation
        -:  355:/// of pipelines.
function _ZNK4mlir13OpPassManager22printAsTextualPipelineERN4llvm11raw_ostreamE called 2665 returned 100% blocks executed 100%
     2665:  356:void OpPassManager::printAsTextualPipeline(raw_ostream &os) const {
     2665:  357:  os << getOpAnchorName() << "(";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     5330:  358:  llvm::interleave(
     2665:  359:      impl->passes,
call    0 returned 100%
     6432:  360:      [&](const std::unique_ptr<Pass> &pass) {
     6432:  361:        pass->printAsTextualPipeline(os);
call    0 returned 100%
call    1 returned 100%
        -:  362:      },
     4272:  363:      [&]() { os << ","; });
call    0 returned 100%
     2665:  364:  os << ")";
call    0 returned 100%
     2665:  365:}
        -:  366:
function _ZN4mlir13OpPassManager4dumpEv called 1028 returned 100% blocks executed 100%
     1028:  367:void OpPassManager::dump() {
     1028:  368:  llvm::errs() << "Pass Manager with " << impl->passes.size() << " passes:\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     1028:  369:  printAsTextualPipeline(llvm::errs());
call    0 returned 100%
call    1 returned 100%
     1028:  370:  llvm::errs() << "\n";
call    0 returned 100%
call    1 returned 100%
     1028:  371:}
        -:  372:
   287244:  373:static void registerDialectsForPipeline(const OpPassManager &pm,
        -:  374:                                        DialectRegistry &dialects) {
  728318*:  375:  for (const Pass &pass : pm.getPasses())
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
  441074*:  376:    pass.getDependentDialects(dialects);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:  377:}
        -:  378:
function _ZNK4mlir13OpPassManager20getDependentDialectsERNS_15DialectRegistryE called 1094 returned 100% blocks executed 60%
   287244:  379:void OpPassManager::getDependentDialects(DialectRegistry &dialects) const {
     1094:  380:  registerDialectsForPipeline(*this, dialects);
     1094:  381:}
        -:  382:
function _ZN4mlir13OpPassManager10setNestingENS0_7NestingE called 0 returned 0% blocks executed 0%
    #####:  383:void OpPassManager::setNesting(Nesting nesting) { impl->nesting = nesting; }
        -:  384:
function _ZN4mlir13OpPassManager10getNestingEv called 295298 returned 100% blocks executed 100%
   295298:  385:OpPassManager::Nesting OpPassManager::getNesting() { return impl->nesting; }
        -:  386:
function _ZN4mlir13OpPassManager10initializeEPNS_11MLIRContextEj called 247296 returned 100% blocks executed 80%
   247296:  387:LogicalResult OpPassManager::initialize(MLIRContext *context,
        -:  388:                                        unsigned newInitGeneration) {
   247296:  389:  if (impl->initializationGeneration == newInitGeneration)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  390:    return success();
   247296:  391:  impl->initializationGeneration = newInitGeneration;
   607900:  392:  for (Pass &pass : getPasses()) {
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
call    2 returned 100%
        -:  393:    // If this pass isn't an adaptor, directly initialize it.
   360602:  394:    auto *adaptor = dyn_cast<OpToOpPassAdaptor>(&pass);
call    0 returned 100%
   360609:  395:    if (!adaptor) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
   282457:  396:      if (failed(pass.initialize(context)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  397:        return failure();
   282452:  398:      continue;
        -:  399:    }
        -:  400:
        -:  401:    // Otherwise, initialize each of the adaptors pass managers.
   159835:  402:    for (OpPassManager &adaptorPM : adaptor->getPassManagers())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    81683:  403:      if (failed(adaptorPM.initialize(context, newInitGeneration)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  404:        return failure();
        -:  405:  }
   247298:  406:  return success();
        -:  407:}
        -:  408:
        -:  409://===----------------------------------------------------------------------===//
        -:  410:// OpToOpPassAdaptor
        -:  411://===----------------------------------------------------------------------===//
        -:  412:
function _ZN4mlir6detail17OpToOpPassAdaptor3runEPNS_4PassEPNS_9OperationENS_15AnalysisManagerEbj called 316480 returned 100% blocks executed 67%
   316480:  413:LogicalResult OpToOpPassAdaptor::run(Pass *pass, Operation *op,
        -:  414:                                     AnalysisManager am, bool verifyPasses,
        -:  415:                                     unsigned parentInitGeneration) {
   316480:  416:  Optional<RegisteredOperationName> opInfo = op->getRegisteredInfo();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   316480:  417:  if (!opInfo)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  418:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  419:           << "trying to schedule a pass on an unregistered operation";
call    0 never executed
   316480:  420:  if (!opInfo->hasTrait<OpTrait::IsIsolatedFromAbove>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  421:    return op->emitOpError() << "trying to schedule a pass on an operation not "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  422:                                "marked as 'IsolatedFromAbove'";
call    0 never executed
        -:  423:
        -:  424:  // Initialize the pass state with a callback for the pass to dynamically
        -:  425:  // execute a pipeline on the currently visited operation.
   316064:  426:  PassInstrumentor *pi = am.getPassInstrumentor();
call    0 returned 100%
   316073:  427:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
   316640:  428:                                                        pass};
function _ZZN4mlir6detail17OpToOpPassAdaptor3runEPNS_4PassEPNS_9OperationENS_15AnalysisManagerEbjENKUlRNS_13OpPassManagerES5_E_clES8_S5_ called 1867 returned 100% blocks executed 65%
   318507:  429:  auto dynamicPipelineCallback = [&](OpPassManager &pipeline,
        -:  430:                                     Operation *root) -> LogicalResult {
    1867*:  431:    if (!op->isAncestor(root))
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
    #####:  432:      return root->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  433:             << "Trying to schedule a dynamic pipeline on an "
        -:  434:                "operation that isn't "
    #####:  435:                "nested under the current operation the pass is processing";
call    0 never executed
    1867*:  436:    assert(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  437:        pipeline.getImpl().canScheduleOn(*op->getContext(), root->getName()));
        -:  438:
        -:  439:    // Before running, finalize the passes held by the pipeline.
     1866:  440:    if (failed(pipeline.getImpl().finalizePassList(root->getContext())))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  441:      return failure();
        -:  442:
        -:  443:    // Initialize the user provided pipeline and execute the pipeline.
     1866:  444:    if (failed(pipeline.initialize(root->getContext(), parentInitGeneration)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  445:      return failure();
     1870:  446:    AnalysisManager nestedAm = root == op ? am : am.nest(root);
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
call    2 returned 100%
     1870:  447:    return OpToOpPassAdaptor::runPipeline(pipeline, root, nestedAm,
     1870:  448:                                          verifyPasses, parentInitGeneration,
     1870:  449:                                          pi, &parentInfo);
call    0 returned 100%
   316640:  450:  };
   316640:  451:  pass->passState.emplace(op, am, dynamicPipelineCallback);
call    0 returned 100%
        -:  452:
        -:  453:  // Instrument before the pass has run.
   316449:  454:  if (pi)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
    15328:  455:    pi->runBeforePass(pass, op);
call    0 returned 100%
        -:  456:
        -:  457:  // Invoke the virtual runOnOperation method.
   316451:  458:  if (auto *adaptor = dyn_cast<OpToOpPassAdaptor>(pass))
call    0 returned 100%
branch  1 taken 22% (fallthrough)
branch  2 taken 78%
    70232:  459:    adaptor->runOnOperation(verifyPasses);
call    0 returned 100%
        -:  460:  else
   246150:  461:    pass->runOnOperation();
call    0 returned 100%
   316042:  462:  bool passFailed = pass->passState->irAndPassFailed.getInt();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  463:
        -:  464:  // Invalidate any non preserved analyses.
   316042:  465:  am.invalidate(pass->passState->preservedAnalyses);
call    0 returned 100%
        -:  466:
        -:  467:  // When verifyPasses is specified, we run the verifier (unless the pass
        -:  468:  // failed).
   315875:  469:  if (!passFailed && verifyPasses) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
   303191:  470:    bool runVerifierNow = true;
        -:  471:
        -:  472:    // If the pass is an adaptor pass, we don't run the verifier recursively
        -:  473:    // because the nested operations should have already been verified after
        -:  474:    // nested passes had run.
   303191:  475:    bool runVerifierRecursively = !isa<OpToOpPassAdaptor>(pass);
call    0 returned 100%
        -:  476:
        -:  477:    // Reduce compile time by avoiding running the verifier if the pass didn't
        -:  478:    // change the IR since the last time the verifier was run:
        -:  479:    //
        -:  480:    //  1) If the pass said that it preserved all analyses then it can't have
        -:  481:    //     permuted the IR.
        -:  482:    //
        -:  483:    // We run these checks in EXPENSIVE_CHECKS mode out of caution.
        -:  484:#ifndef EXPENSIVE_CHECKS
   303177:  485:    runVerifierNow = !pass->passState->preservedAnalyses.isAll();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  486:#endif
   303165:  487:    if (runVerifierNow)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   301286:  488:      passFailed = failed(verify(op, runVerifierRecursively));
call    0 returned 100%
        -:  489:  }
        -:  490:
        -:  491:  // Instrument after the pass has run.
   315549:  492:  if (pi) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
    15307:  493:    if (passFailed)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
      559:  494:      pi->runAfterPassFailed(pass, op);
call    0 returned 100%
        -:  495:    else
    14748:  496:      pi->runAfterPass(pass, op);
call    0 returned 100%
        -:  497:  }
        -:  498:
        -:  499:  // Return if the pass signaled a failure.
   315571:  500:  return failure(passFailed);
        -:  501:}
        -:  502:
        -:  503:/// Run the given operation and analysis manager on a provided op pass manager.
function _ZN4mlir6detail17OpToOpPassAdaptor11runPipelineERNS_13OpPassManagerEPNS_9OperationENS_15AnalysisManagerEbjPNS_16PassInstrumentorEPKNS_19PassInstrumentation18PipelineParentInfoE called 236659 returned 100% blocks executed 95%
   236659:  504:LogicalResult OpToOpPassAdaptor::runPipeline(
        -:  505:    OpPassManager &pm, Operation *op, AnalysisManager am, bool verifyPasses,
        -:  506:    unsigned parentInitGeneration, PassInstrumentor *instrumentor,
        -:  507:    const PassInstrumentation::PipelineParentInfo *parentInfo) {
  236659*:  508:  assert((!instrumentor || parentInfo) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  509:         "expected parent info if instrumentor is provided");
   472484:  510:  auto scopeExit = llvm::make_scope_exit([&] {
        -:  511:    // Clear out any computed operation analyses. These analyses won't be used
        -:  512:    // any more in this pipeline, and this helps reduce the current working set
        -:  513:    // of memory. If preserving these analyses becomes important in the future
        -:  514:    // we can re-evaluate this.
   235825:  515:    am.clear();
call    0 returned 100%
   472437:  516:  });
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  517:
        -:  518:  // Run the pipeline over the provided operation.
   236659:  519:  if (instrumentor) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     3485:  520:    instrumentor->runBeforePipeline(pm.getOpName(*op->getContext()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  521:                                    *parentInfo);
        -:  522:  }
        -:  523:
   539555:  524:  for (Pass &pass : pm.getPasses())
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
call    2 returned 100%
   316421:  525:    if (failed(run(&pass, op, am, verifyPasses, parentInitGeneration)))
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
    12689:  526:      return failure();
        -:  527:
   223134:  528:  if (instrumentor) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     3372:  529:    instrumentor->runAfterPipeline(pm.getOpName(*op->getContext()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  530:                                   *parentInfo);
        -:  531:  }
   235829:  532:  return success();
call    0 returned 100%
        -:  533:}
        -:  534:
        -:  535:/// Find an operation pass manager with the given anchor name, or nullptr if one
        -:  536:/// does not exist.
        -:  537:static OpPassManager *
    25730:  538:findPassManagerWithAnchor(MutableArrayRef<OpPassManager> mgrs, StringRef name) {
    25730:  539:  auto *it = llvm::find_if(
call    0 returned 100%
function _ZZL25findPassManagerWithAnchorN4llvm15MutableArrayRefIN4mlir13OpPassManagerEEENS_9StringRefEENKUlRS2_E_clES5_.isra.0 called 26624 returned 100% blocks executed 83%
    26624:  540:      mgrs, [&](OpPassManager &mgr) { return mgr.getOpAnchorName() == name; });
call    0 returned 100%
branch  1 taken 81% (fallthrough)
branch  2 taken 19%
    25730:  541:  return it == mgrs.end() ? nullptr : &*it;
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -:  542:}
        -:  543:
        -:  544:/// Find an operation pass manager that can operate on an operation of the given
        -:  545:/// type, or nullptr if one does not exist.
    71218:  546:static OpPassManager *findPassManagerFor(MutableArrayRef<OpPassManager> mgrs,
        -:  547:                                         OperationName name,
        -:  548:                                         MLIRContext &context) {
    71218:  549:  auto *it = llvm::find_if(mgrs, [&](OpPassManager &mgr) {
call    0 returned 100%
call    1 returned 100%
        -:  550:    return mgr.getImpl().canScheduleOn(context, name);
        -:  551:  });
    71218:  552:  return it == mgrs.end() ? nullptr : &*it;
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
branch  2 taken 7% (fallthrough)
branch  3 taken 93%
        -:  553:}
        -:  554:
function _ZN4mlir6detail17OpToOpPassAdaptorC2EONS_13OpPassManagerE called 113461 returned 100% blocks executed 100%
   113461:  555:OpToOpPassAdaptor::OpToOpPassAdaptor(OpPassManager &&mgr) {
call    0 returned 100%
call    1 returned 100%
   113461:  556:  mgrs.emplace_back(std::move(mgr));
call    0 returned 100%
   113461:  557:}
        -:  558:
function _ZNK4mlir6detail17OpToOpPassAdaptor20getDependentDialectsERNS_15DialectRegistryE called 113461 returned 100% blocks executed 100%
   113461:  559:void OpToOpPassAdaptor::getDependentDialects(DialectRegistry &dialects) const {
   226922:  560:  for (auto &pm : mgrs)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   226922:  561:    pm.getDependentDialects(dialects);
   113461:  562:}
        -:  563:
function _ZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ called 25730 returned 100% blocks executed 74%
    25730:  564:LogicalResult OpToOpPassAdaptor::tryMergeInto(MLIRContext *ctx,
        -:  565:                                              OpToOpPassAdaptor &rhs) {
        -:  566:  // Functor used to check if a pass manager is generic, i.e. op-agnostic.
    25730:  567:  auto isGenericPM = [&](OpPassManager &pm) { return !pm.getOpName(); };
        -:  568:
        -:  569:  // Functor used to detect if the given generic pass manager will have a
        -:  570:  // potential schedule conflict with the given `otherPMs`.
   25730*:  571:  auto hasScheduleConflictWith = [&](OpPassManager &genericPM,
        -:  572:                                     MutableArrayRef<OpPassManager> otherPMs) {
function _ZZZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ENKUlRNS_13OpPassManagerEN4llvm15MutableArrayRefIS5_EEE0_clES6_S9_ENKUlS6_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  573:    return llvm::any_of(otherPMs, [&](OpPassManager &pm) {
call    0 never executed
call    1 never executed
        -:  574:      // If this is a non-generic pass manager, a conflict will arise if a
        -:  575:      // non-generic pass manager's operation name can be scheduled on the
        -:  576:      // generic passmanager.
    #####:  577:      if (Optional<OperationName> pmOpName = pm.getOpName(*ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  578:        return genericPM.getImpl().canScheduleOn(*ctx, *pmOpName);
call    0 never executed
        -:  579:      // Otherwise, this is a generic pass manager. We current can't determine
        -:  580:      // when generic pass managers can be merged, so conservatively assume they
        -:  581:      // conflict.
    #####:  582:      return true;
        -:  583:    });
    25730:  584:  };
        -:  585:
        -:  586:  // Check that if either adaptor has a generic pass manager, that pm is
        -:  587:  // compatible within any non-generic pass managers.
        -:  588:  //
        -:  589:  // Check the current adaptor.
    25730:  590:  auto *lhsGenericPMIt = llvm::find_if(mgrs, isGenericPM);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   25730*:  591:  if (lhsGenericPMIt != mgrs.end() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  592:      hasScheduleConflictWith(*lhsGenericPMIt, rhs.mgrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  593:    return failure();
        -:  594:  // Check the rhs adaptor.
    25730:  595:  auto *rhsGenericPMIt = llvm::find_if(rhs.mgrs, isGenericPM);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   25730*:  596:  if (rhsGenericPMIt != rhs.mgrs.end() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  597:      hasScheduleConflictWith(*rhsGenericPMIt, mgrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  598:    return failure();
        -:  599:
    51460:  600:  for (auto &pm : mgrs) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  601:    // If an existing pass manager exists, then merge the given pass manager
        -:  602:    // into it.
    25730:  603:    if (auto *existingPM =
call    0 returned 100%
    51460:  604:            findPassManagerWithAnchor(rhs.mgrs, pm.getOpAnchorName())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    21506:  605:      pm.getImpl().mergeInto(existingPM->getImpl());
call    0 returned 100%
        -:  606:    } else {
        -:  607:      // Otherwise, add the given pass manager to the list.
     4224:  608:      rhs.mgrs.emplace_back(std::move(pm));
call    0 returned 100%
        -:  609:    }
        -:  610:  }
    25730:  611:  mgrs.clear();
call    0 returned 100%
        -:  612:
        -:  613:  // After coalescing, sort the pass managers within rhs by name.
function _ZZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ENKUlPKNS_13OpPassManagerES7_E1_clES7_S7_.isra.0 called 5946 returned 100% blocks executed 69%
    31676:  614:  auto compareFn = [](const OpPassManager *lhs, const OpPassManager *rhs) {
        -:  615:    // Order op-specific pass managers first and op-agnostic pass managers last.
    11892:  616:    if (Optional<StringRef> lhsName = lhs->getOpName()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    11892:  617:      if (Optional<StringRef> rhsName = rhs->getOpName())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     5946:  618:        return lhsName->compare(*rhsName);
    #####:  619:      return -1; // lhs(op-specific) < rhs(op-agnostic)
        -:  620:    }
    #####:  621:    return 1; // lhs(op-agnostic) > rhs(op-specific)
        -:  622:  };
    25730:  623:  llvm::array_pod_sort(rhs.mgrs.begin(), rhs.mgrs.end(), compareFn);
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
    25730:  624:  return success();
        -:  625:}
        -:  626:
        -:  627:/// Returns the adaptor pass name.
function _ZN4mlir6detail17OpToOpPassAdaptor14getAdaptorNameB5cxx11Ev called 856 returned 100% blocks executed 92%
      856:  628:std::string OpToOpPassAdaptor::getAdaptorName() {
      856:  629:  std::string name = "Pipeline Collection : [";
call    0 returned 100%
     1712:  630:  llvm::raw_string_ostream os(name);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
function _ZZN4mlir6detail17OpToOpPassAdaptor14getAdaptorNameB5cxx11EvENKUlRNS_13OpPassManagerEE_clES3_.isra.0 called 991 returned 100% blocks executed 80%
     1847:  631:  llvm::interleaveComma(getPassManagers(), os, [&](OpPassManager &pm) {
call    0 returned 100%
     1982:  632:    os << '\'' << pm.getOpAnchorName() << '\'';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      991:  633:  });
      856:  634:  os << ']';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      856:  635:  return os.str();
call    0 returned 100%
call    1 returned 100%
        -:  636:}
        -:  637:
function _ZN4mlir6detail17OpToOpPassAdaptor14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  638:void OpToOpPassAdaptor::runOnOperation() {
    #####:  639:  llvm_unreachable(
        -:  640:      "Unexpected call to Pass::runOnOperation() on OpToOpPassAdaptor");
        -:  641:}
        -:  642:
        -:  643:/// Run the held pipeline over all nested operations.
function _ZN4mlir6detail17OpToOpPassAdaptor14runOnOperationEb called 70232 returned 100% blocks executed 100%
    70232:  644:void OpToOpPassAdaptor::runOnOperation(bool verifyPasses) {
    70232:  645:  if (getContext().isMultithreadingEnabled())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
    69476:  646:    runOnOperationAsyncImpl(verifyPasses);
call    0 returned 100%
        -:  647:  else
      756:  648:    runOnOperationImpl(verifyPasses);
call    0 returned 100%
    70232:  649:}
        -:  650:
        -:  651:/// Run this pass adaptor synchronously.
function _ZN4mlir6detail17OpToOpPassAdaptor18runOnOperationImplEb called 756 returned 100% blocks executed 91%
      756:  652:void OpToOpPassAdaptor::runOnOperationImpl(bool verifyPasses) {
      756:  653:  auto am = getAnalysisManager();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      756:  654:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
      756:  655:                                                        this};
      756:  656:  auto *instrumentor = am.getPassInstrumentor();
call    0 returned 100%
     2237:  657:  for (auto &region : getOperation()->getRegions()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 51% (fallthrough)
branch  5 taken 49%
     1481:  658:    for (auto &block : region) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1849:  659:      for (auto &op : block) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
call    2 returned 100%
     1124:  660:        auto *mgr = findPassManagerFor(mgrs, op.getName(), *op.getContext());
call    0 returned 100%
call    1 returned 100%
     1124:  661:        if (!mgr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       78:  662:          continue;
        -:  663:
        -:  664:        // Run the held pipeline over the current operation.
     1046:  665:        unsigned initGeneration = mgr->impl->initializationGeneration;
call    0 returned 100%
     1046:  666:        if (failed(runPipeline(*mgr, &op, am.nest(&op), verifyPasses,
call    0 returned 100%
call    1 returned 100%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
        -:  667:                               initGeneration, instrumentor, &parentInfo)))
       31:  668:          return signalPassFailure();
call    0 returned 100%
        -:  669:      }
        -:  670:    }
        -:  671:  }
        -:  672:}
        -:  673:
        -:  674:/// Utility functor that checks if the two ranges of pass managers have a size
        -:  675:/// mismatch.
function _ZL15hasSizeMismatchN4llvm8ArrayRefIN4mlir13OpPassManagerEEES3_ called 0 returned 0% blocks executed 0%
    #####:  676:static bool hasSizeMismatch(ArrayRef<OpPassManager> lhs,
        -:  677:                            ArrayRef<OpPassManager> rhs) {
    #####:  678:  return lhs.size() != rhs.size() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  679:         llvm::any_of(llvm::seq<size_t>(0, lhs.size()),
call    0 never executed
call    1 never executed
function _ZZL15hasSizeMismatchN4llvm8ArrayRefIN4mlir13OpPassManagerEEES3_ENKUlmE_clEm.isra.0 called 0 returned 0% blocks executed 0%
    #####:  680:                      [&](size_t i) { return lhs[i].size() != rhs[i].size(); });
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  681:}
        -:  682:
        -:  683:/// Run this pass adaptor synchronously.
function _ZN4mlir6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEb called 69476 returned 100% blocks executed 88%
    69476:  684:void OpToOpPassAdaptor::runOnOperationAsyncImpl(bool verifyPasses) {
    69476:  685:  AnalysisManager am = getAnalysisManager();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    69476:  686:  MLIRContext *context = &getContext();
call    0 returned 100%
        -:  687:
        -:  688:  // Create the async executors if they haven't been created, or if the main
        -:  689:  // pipeline has changed.
   69476*:  690:  if (asyncExecutors.empty() || hasSizeMismatch(asyncExecutors.front(), mgrs))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
    69476:  691:    asyncExecutors.assign(context->getThreadPool().getThreadCount(), mgrs);
call    0 returned 100%
call    1 returned 100%
        -:  692:
        -:  693:  // This struct represents the information for a single operation to be
        -:  694:  // scheduled on a pass manager.
    69476:  695:  struct OpPMInfo {
    70052:  696:    OpPMInfo(unsigned passManagerIdx, Operation *op, AnalysisManager am)
    70052:  697:        : passManagerIdx(passManagerIdx), op(op), am(am) {}
        -:  698:
        -:  699:    /// The index of the pass manager to schedule the operation on.
        -:  700:    unsigned passManagerIdx;
        -:  701:    /// The operation to schedule.
        -:  702:    Operation *op;
        -:  703:    /// The analysis manager for the operation.
        -:  704:    AnalysisManager am;
        -:  705:  };
        -:  706:
        -:  707:  // Run a prepass over the operation to collect the nested operations to
        -:  708:  // execute over. This ensures that an analysis manager exists for each
        -:  709:  // operation, as well as providing a queue of operations to execute over.
    69476:  710:  std::vector<OpPMInfo> opInfos;
call    0 returned 100%
   138952:  711:  DenseMap<OperationName, Optional<unsigned>> knownOpPMIdx;
call    0 returned 100%
branch  1 taken 92% (fallthrough)
branch  2 taken 8%
   208428:  712:  for (auto &region : getOperation()->getRegions()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
   146431:  713:    for (Operation &op : region.getOps()) {
call    0 returned 100%
branch  1 taken 53% (fallthrough)
branch  2 taken 47%
call    3 returned 100%
        -:  714:      // Get the pass manager index for this operation type.
    76955:  715:      auto pmIdxIt = knownOpPMIdx.try_emplace(op.getName(), llvm::None);
call    0 returned 100%
    76955:  716:      if (pmIdxIt.second) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
   140188:  717:        if (auto *mgr = findPassManagerFor(mgrs, op.getName(), *context))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    64028:  718:          pmIdxIt.first->second = std::distance(mgrs.begin(), mgr);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  719:      }
        -:  720:
        -:  721:      // If this operation can be scheduled, add it to the list.
    76955:  722:      if (pmIdxIt.first->second)
call    0 returned 100%
branch  1 taken 91% (fallthrough)
branch  2 taken 9%
    70052:  723:        opInfos.emplace_back(*pmIdxIt.first->second, &op, am.nest(&op));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -:  724:    }
        -:  725:  }
        -:  726:
        -:  727:  // Get the current thread for this adaptor.
    69476:  728:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
    69476:  729:                                                        this};
    69476:  730:  auto *instrumentor = am.getPassInstrumentor();
call    0 returned 100%
        -:  731:
        -:  732:  // An atomic failure variable for the async executors.
   138952:  733:  std::vector<std::atomic<bool>> activePMs(asyncExecutors.size());
call    0 returned 100%
call    1 returned 100%
    69476:  734:  std::fill(activePMs.begin(), activePMs.end(), false);
function _ZZN4mlir6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbENKUlRZNS1_23runOnOperationAsyncImplEbE8OpPMInfoE_clES3_ called 69998 returned 99% blocks executed 71%
   139474:  735:  auto processFn = [&](OpPMInfo &opInfo) {
        -:  736:    // Find an executor for this operation.
   209136:  737:    auto it = llvm::find_if(activePMs, [](std::atomic<bool> &isActive) {
        -:  738:      bool expectedInactive = false;
        -:  739:      return isActive.compare_exchange_strong(expectedInactive, true);
    69998:  740:    });
call    0 returned 100%
    70008:  741:    unsigned pmIndex = it - activePMs.begin();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  742:
        -:  743:    // Get the pass manager for this operation and execute it.
    70008:  744:    OpPassManager &pm = asyncExecutors[pmIndex][opInfo.passManagerIdx];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    70008:  745:    LogicalResult pipelineResult = runPipeline(
    70008:  746:        pm, opInfo.op, opInfo.am, verifyPasses,
call    0 returned 99%
    70008:  747:        pm.impl->initializationGeneration, instrumentor, &parentInfo);
call    0 returned 99%
        -:  748:
        -:  749:    // Reset the active bit for this pass manager.
    69130:  750:    activePMs[pmIndex].store(false);
    69130:  751:    return pipelineResult;
    69476:  752:  };
        -:  753:
        -:  754:  // Signal a failure if any of the executors failed.
    69476:  755:  if (failed(failableParallelForEach(context, opInfos, processFn)))
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
     2558:  756:    signalPassFailure();
call    0 returned 100%
    69476:  757:}
        -:  758:
        -:  759://===----------------------------------------------------------------------===//
        -:  760:// PassManager
        -:  761://===----------------------------------------------------------------------===//
        -:  762:
function _ZN4mlir11PassManagerC2EPNS_11MLIRContextENS_13OpPassManager7NestingEN4llvm9StringRefE called 172689 returned 100% blocks executed 100%
   172689:  763:PassManager::PassManager(MLIRContext *ctx, Nesting nesting,
   172689:  764:                         StringRef operationName)
        -:  765:    : OpPassManager(OperationName(operationName, ctx), nesting), context(ctx),
   172689:  766:      initializationKey(DenseMapInfo<llvm::hash_code>::getTombstoneKey()),
   172689:  767:      passTiming(false), verifyPasses(true) {}
call    0 returned 100%
call    1 returned 100%
        -:  768:
        -:  769:PassManager::~PassManager() = default;
        -:  770:
function _ZN4mlir11PassManager14enableVerifierEb called 171750 returned 100% blocks executed 100%
   171750:  771:void PassManager::enableVerifier(bool enabled) { verifyPasses = enabled; }
        -:  772:
        -:  773:/// Run the passes within this manager on the provided operation.
function _ZN4mlir11PassManager3runEPNS_9OperationE called 172689 returned 100% blocks executed 90%
   172689:  774:LogicalResult PassManager::run(Operation *op) {
   172689:  775:  MLIRContext *context = getContext();
call    0 returned 100%
  172689*:  776:  assert(op->getName() == getOpName(*context) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
        -:  777:         "operation has a different name than the PassManager or is from a "
        -:  778:         "different context");
        -:  779:
        -:  780:  // Register all dialects for the current pipeline.
   172689:  781:  DialectRegistry dependentDialects;
call    0 returned 100%
   172689:  782:  getDependentDialects(dependentDialects);
   172689:  783:  context->appendDialectRegistry(dependentDialects);
call    0 returned 100%
   627785:  784:  for (StringRef name : dependentDialects.getDialectNames())
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
   455096:  785:    context->getOrLoadDialect(name);
call    0 returned 100%
        -:  786:
        -:  787:  // Before running, make sure to finalize the pipeline pass list.
   172689:  788:  if (failed(getImpl().finalizePassList(context)))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
     8942:  789:    return failure();
        -:  790:
        -:  791:  // Initialize all of the passes within the pass manager with a new generation.
   163747:  792:  llvm::hash_code newInitKey = context->getRegistryHash();
call    0 returned 100%
   163747:  793:  if (newInitKey != initializationKey) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   163747:  794:    if (failed(initialize(context, impl->initializationGeneration + 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  795:      return failure();
   163747:  796:    initializationKey = newInitKey;
        -:  797:  }
        -:  798:
        -:  799:  // Construct a top level analysis manager for the pipeline.
   336054:  800:  ModuleAnalysisManager am(op, instrumentor.get());
call    0 returned 100%
call    1 returned 100%
        -:  801:
        -:  802:  // Notify the context that we start running a pipeline for book keeping.
   163747:  803:  context->enterMultiThreadedExecution();
call    0 returned 100%
        -:  804:
        -:  805:  // If reproducer generation is enabled, run the pass manager with crash
        -:  806:  // handling enabled.
   163747:  807:  LogicalResult result =
  327494*:  808:      crashReproGenerator ? runWithCrashRecovery(op, am) : runPasses(op, am);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  809:
        -:  810:  // Notify the context that the run is done.
   163747:  811:  context->exitMultiThreadedExecution();
call    0 returned 100%
        -:  812:
        -:  813:  // Dump all of the pass statistics if necessary.
   163747:  814:  if (passStatisticsMode)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      941:  815:    dumpStatistics();
call    0 returned 59%
   163365:  816:  return result;
call    0 returned 100%
        -:  817:}
        -:  818:
        -:  819:/// Add the provided instrumentation to the pass manager.
function _ZN4mlir11PassManager18addInstrumentationESt10unique_ptrINS_19PassInstrumentationESt14default_deleteIS2_EE called 4175 returned 100% blocks executed 70%
     4175:  820:void PassManager::addInstrumentation(std::unique_ptr<PassInstrumentation> pi) {
     4175:  821:  if (!instrumentor)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     8304:  822:    instrumentor = std::make_unique<PassInstrumentor>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  823:
     4175:  824:  instrumentor->addInstrumentation(std::move(pi));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     4175:  825:}
        -:  826:
function _ZN4mlir11PassManager9runPassesEPNS_9OperationENS_15AnalysisManagerE called 0 returned 0% blocks executed 0%
  163747*:  827:LogicalResult PassManager::runPasses(Operation *op, AnalysisManager am) {
  163747*:  828:  return OpToOpPassAdaptor::runPipeline(*this, op, am, verifyPasses,
  163747*:  829:                                        impl->initializationGeneration);
call    0 never executed
call    1 returned 100%
        -:  830:}
        -:  831:
        -:  832://===----------------------------------------------------------------------===//
        -:  833:// AnalysisManager
        -:  834://===----------------------------------------------------------------------===//
        -:  835:
        -:  836:/// Get an analysis manager for the given operation, which must be a proper
        -:  837:/// descendant of the current operation represented by this analysis manager.
function _ZN4mlir15AnalysisManager4nestEPNS_9OperationE called 72830 returned 100% blocks executed 33%
    72830:  838:AnalysisManager AnalysisManager::nest(Operation *op) {
    72830:  839:  Operation *currentOp = impl->getOperation();
call    0 returned 100%
   72830*:  840:  assert(currentOp->isProperAncestor(op) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  841:         "expected valid descendant operation");
        -:  842:
        -:  843:  // Check for the base case where the provided operation is immediately nested.
   145660:  844:  if (currentOp == op->getParentOp())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    72830:  845:    return nestImmediate(op);
call    0 returned 100%
        -:  846:
        -:  847:  // Otherwise, we need to collect all ancestors up to the current operation.
    #####:  848:  SmallVector<Operation *, 4> opAncestors;
    #####:  849:  do {
    #####:  850:    opAncestors.push_back(op);
call    0 never executed
    #####:  851:    op = op->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  852:  } while (op != currentOp);
branch  0 never executed
branch  1 never executed
        -:  853:
    #####:  854:  AnalysisManager result = *this;
    #####:  855:  for (Operation *op : llvm::reverse(opAncestors))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  856:    result = result.nestImmediate(op);
call    0 never executed
    #####:  857:  return result;
branch  0 never executed
branch  1 never executed
        -:  858:}
        -:  859:
        -:  860:/// Get an analysis manager for the given immediately nested child operation.
function _ZN4mlir15AnalysisManager13nestImmediateEPNS_9OperationE called 72830 returned 100% blocks executed 88%
    72830:  861:AnalysisManager AnalysisManager::nestImmediate(Operation *op) {
  145660*:  862:  assert(impl->getOperation() == op->getParentOp() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  863:         "expected immediate child operation");
        -:  864:
    72830:  865:  auto it = impl->childAnalyses.find(op);
call    0 returned 100%
    72830:  866:  if (it == impl->childAnalyses.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
   143928:  867:    it = impl->childAnalyses
   143928:  868:             .try_emplace(op, std::make_unique<NestedAnalysisMap>(op, impl))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  869:             .first;
    72830:  870:  return {it->second.get()};
call    0 returned 100%
        -:  871:}
        -:  872:
        -:  873:/// Invalidate any non preserved analyses.
function _ZN4mlir6detail17NestedAnalysisMap10invalidateERKNS0_17PreservedAnalysesE called 316004 returned 100% blocks executed 77%
   316004:  874:void detail::NestedAnalysisMap::invalidate(
        -:  875:    const detail::PreservedAnalyses &pa) {
        -:  876:  // If all analyses were preserved, then there is nothing to do here.
   316004:  877:  if (pa.isAll())
call    0 returned 100%
branch  1 taken 99% (fallthrough)
branch  2 taken 1%
   314966:  878:    return;
        -:  879:
        -:  880:  // Invalidate the analyses for the current operation directly.
   314053:  881:  analyses.invalidate(pa);
call    0 returned 100%
        -:  882:
        -:  883:  // If no analyses were preserved, then just simply clear out the child
        -:  884:  // analysis results.
   314038:  885:  if (pa.isNone()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   313128:  886:    childAnalyses.clear();
   313128:  887:    return;
call    0 returned 100%
        -:  888:  }
        -:  889:
        -:  890:  // Otherwise, invalidate each child analysis map.
     1820:  891:  SmallVector<NestedAnalysisMap *, 8> mapsToInvalidate(1, this);
call    0 returned 100%
     1820:  892:  while (!mapsToInvalidate.empty()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      910:  893:    auto *map = mapsToInvalidate.pop_back_val();
call    0 returned 100%
    1820*:  894:    for (auto &analysisPair : map->childAnalyses) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
    #####:  895:      analysisPair.second->invalidate(pa);
call    0 never executed
    #####:  896:      if (!analysisPair.second->childAnalyses.empty())
branch  0 never executed
branch  1 never executed
    #####:  897:        mapsToInvalidate.push_back(analysisPair.second.get());
call    0 never executed
        -:  898:    }
        -:  899:  }
        -:  900:}
        -:  901:
        -:  902://===----------------------------------------------------------------------===//
        -:  903:// PassInstrumentation
        -:  904://===----------------------------------------------------------------------===//
        -:  905:
        -:  906:PassInstrumentation::~PassInstrumentation() = default;
        -:  907:
function _ZN4mlir19PassInstrumentation17runBeforePipelineEN4llvm8OptionalINS_13OperationNameEEERKNS0_18PipelineParentInfoE called 2461 returned 100% blocks executed 100%
     2461:  908:void PassInstrumentation::runBeforePipeline(
     2461:  909:    Optional<OperationName> name, const PipelineParentInfo &parentInfo) {}
        -:  910:
function _ZN4mlir19PassInstrumentation16runAfterPipelineEN4llvm8OptionalINS_13OperationNameEEERKNS0_18PipelineParentInfoE called 2379 returned 100% blocks executed 100%
     2379:  911:void PassInstrumentation::runAfterPipeline(
     2379:  912:    Optional<OperationName> name, const PipelineParentInfo &parentInfo) {}
        -:  913:
        -:  914://===----------------------------------------------------------------------===//
        -:  915:// PassInstrumentor
        -:  916://===----------------------------------------------------------------------===//
        -:  917:
        -:  918:namespace mlir {
        -:  919:namespace detail {
     4129:  920:struct PassInstrumentorImpl {
        -:  921:  /// Mutex to keep instrumentation access thread-safe.
        -:  922:  llvm::sys::SmartMutex<true> mutex;
        -:  923:
        -:  924:  /// Set of registered instrumentations.
        -:  925:  std::vector<std::unique_ptr<PassInstrumentation>> instrumentations;
        -:  926:};
        -:  927:} // namespace detail
        -:  928:} // namespace mlir
        -:  929:
function _ZN4mlir16PassInstrumentorC2Ev called 4129 returned 100% blocks executed 100%
     4129:  930:PassInstrumentor::PassInstrumentor() : impl(new PassInstrumentorImpl()) {}
call    0 returned 100%
        -:  931:PassInstrumentor::~PassInstrumentor() = default;
        -:  932:
        -:  933:/// See PassInstrumentation::runBeforePipeline for details.
function _ZN4mlir16PassInstrumentor17runBeforePipelineEN4llvm8OptionalINS_13OperationNameEEERKNS_19PassInstrumentation18PipelineParentInfoE called 3484 returned 100% blocks executed 100%
     3484:  934:void PassInstrumentor::runBeforePipeline(
        -:  935:    Optional<OperationName> name,
        -:  936:    const PassInstrumentation::PipelineParentInfo &parentInfo) {
     3484:  937:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     7038:  938:  for (auto &instr : impl->instrumentations)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
     3552:  939:    instr->runBeforePipeline(name, parentInfo);
call    0 returned 100%
     3486:  940:}
        -:  941:
        -:  942:/// See PassInstrumentation::runAfterPipeline for details.
function _ZN4mlir16PassInstrumentor16runAfterPipelineEN4llvm8OptionalINS_13OperationNameEEERKNS_19PassInstrumentation18PipelineParentInfoE called 3372 returned 100% blocks executed 100%
     3372:  943:void PassInstrumentor::runAfterPipeline(
        -:  944:    Optional<OperationName> name,
        -:  945:    const PassInstrumentation::PipelineParentInfo &parentInfo) {
     3372:  946:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     6813:  947:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3439:  948:    instr->runAfterPipeline(name, parentInfo);
call    0 returned 100%
     3374:  949:}
        -:  950:
        -:  951:/// See PassInstrumentation::runBeforePass for details.
function _ZN4mlir16PassInstrumentor13runBeforePassEPNS_4PassEPNS_9OperationE called 15327 returned 100% blocks executed 100%
    15327:  952:void PassInstrumentor::runBeforePass(Pass *pass, Operation *op) {
    15327:  953:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
    30991:  954:  for (auto &instr : impl->instrumentations)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
call    2 returned 100%
    15660:  955:    instr->runBeforePass(pass, op);
call    0 returned 100%
    15331:  956:}
        -:  957:
        -:  958:/// See PassInstrumentation::runAfterPass for details.
function _ZN4mlir16PassInstrumentor12runAfterPassEPNS_4PassEPNS_9OperationE called 14747 returned 100% blocks executed 100%
    14747:  959:void PassInstrumentor::runAfterPass(Pass *pass, Operation *op) {
    14747:  960:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
    29863:  961:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    15091:  962:    instr->runAfterPass(pass, op);
call    0 returned 100%
    14771:  963:}
        -:  964:
        -:  965:/// See PassInstrumentation::runAfterPassFailed for details.
function _ZN4mlir16PassInstrumentor18runAfterPassFailedEPNS_4PassEPNS_9OperationE called 559 returned 100% blocks executed 100%
      559:  966:void PassInstrumentor::runAfterPassFailed(Pass *pass, Operation *op) {
      559:  967:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     1128:  968:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      569:  969:    instr->runAfterPassFailed(pass, op);
call    0 returned 100%
      559:  970:}
        -:  971:
        -:  972:/// See PassInstrumentation::runBeforeAnalysis for details.
function _ZN4mlir16PassInstrumentor17runBeforeAnalysisEN4llvm9StringRefENS_6TypeIDEPNS_9OperationE called 665 returned 100% blocks executed 100%
      665:  973:void PassInstrumentor::runBeforeAnalysis(StringRef name, TypeID id,
        -:  974:                                         Operation *op) {
      665:  975:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     1349:  976:  for (auto &instr : impl->instrumentations)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
call    2 returned 100%
      684:  977:    instr->runBeforeAnalysis(name, id, op);
call    0 returned 100%
      665:  978:}
        -:  979:
        -:  980:/// See PassInstrumentation::runAfterAnalysis for details.
function _ZN4mlir16PassInstrumentor16runAfterAnalysisEN4llvm9StringRefENS_6TypeIDEPNS_9OperationE called 665 returned 100% blocks executed 100%
      665:  981:void PassInstrumentor::runAfterAnalysis(StringRef name, TypeID id,
        -:  982:                                        Operation *op) {
      665:  983:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     1349:  984:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
      684:  985:    instr->runAfterAnalysis(name, id, op);
call    0 returned 100%
      665:  986:}
        -:  987:
        -:  988:/// Add the given instrumentation to the collection.
function _ZN4mlir16PassInstrumentor18addInstrumentationESt10unique_ptrINS_19PassInstrumentationESt14default_deleteIS2_EE called 4175 returned 100% blocks executed 100%
     4175:  989:void PassInstrumentor::addInstrumentation(
        -:  990:    std::unique_ptr<PassInstrumentation> pi) {
     4175:  991:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     4175:  992:  impl->instrumentations.emplace_back(std::move(pi));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     4175:  993:}
