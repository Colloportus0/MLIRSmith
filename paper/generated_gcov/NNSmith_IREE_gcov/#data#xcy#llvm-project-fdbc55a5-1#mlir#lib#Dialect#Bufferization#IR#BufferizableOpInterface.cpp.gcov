        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Bufferization/IR/BufferizableOpInterface.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Bufferization/IR/CMakeFiles/obj.MLIRBufferizationDialect.dir/BufferizableOpInterface.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Bufferization/IR/CMakeFiles/obj.MLIRBufferizationDialect.dir/BufferizableOpInterface.cpp.gcda
        -:    0:Runs:325545
        -:    1://===- BufferizableOpInterface.cpp - Bufferizable Ops  ---=----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h"
        -:   10:#include "mlir/Dialect/Bufferization/IR/Bufferization.h"
        -:   11:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   12:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   13:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   14:#include "mlir/IR/AsmState.h"
        -:   15:#include "mlir/IR/BlockAndValueMapping.h"
        -:   16:#include "mlir/IR/BuiltinOps.h"
        -:   17:#include "mlir/IR/Operation.h"
        -:   18:#include "mlir/IR/TypeUtilities.h"
        -:   19:#include "mlir/IR/Value.h"
        -:   20:#include "mlir/Interfaces/ControlFlowInterfaces.h"
        -:   21:#include "llvm/Support/Debug.h"
        -:   22:
        -:   23://===----------------------------------------------------------------------===//
        -:   24:// BufferizableOpInterface
        -:   25://===----------------------------------------------------------------------===//
        -:   26:
        -:   27:namespace mlir {
        -:   28:namespace bufferization {
        -:   29:
        -:   30:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.cpp.inc"
        -:   31:
        -:   32:} // namespace bufferization
        -:   33:} // namespace mlir
        -:   34:
        -:   35:#define DEBUG_TYPE "bufferizable-op-interface"
        -:   36:#define DBGS() (llvm::dbgs() << '[' << DEBUG_TYPE << "] ")
        -:   37:#define LDBG(X) LLVM_DEBUG(DBGS() << (X))
        -:   38:
        -:   39:using namespace mlir;
        -:   40:using namespace bufferization;
        -:   41:
function _ZN4mlir13bufferization15getOwnerOfValueENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:   42:Operation *bufferization::getOwnerOfValue(Value value) {
    #####:   43:  if (auto opResult = value.dyn_cast<OpResult>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   44:    return opResult.getDefiningOp();
call    0 never executed
    #####:   45:  return value.cast<BlockArgument>().getOwner()->getParentOp();
call    0 never executed
call    1 never executed
        -:   46:}
        -:   47:
function _ZN4mlir13bufferization23allocationDoesNotEscapeENS_8OpResultE called 0 returned 0% blocks executed 0%
    #####:   48:bool bufferization::allocationDoesNotEscape(OpResult opResult) {
        -:   49:#ifndef NDEBUG
    #####:   50:  auto bufferizableOp = opResult.getDefiningOp<BufferizableOpInterface>();
call    0 never executed
    #####:   51:  assert(bufferizableOp && bufferizableOp.bufferizesToAllocation(opResult) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:   52:         "expected op that bufferizes to an allocation");
        -:   53:#endif // NDEBUG
        -:   54:
    #####:   55:  Operation *op = opResult.getDefiningOp();
call    0 never executed
        -:   56:  // If there is no 'escape' attribute, we cannot say for sure.
    #####:   57:  if (!op->hasAttr(BufferizationDialect::kEscapeAttrName))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   58:    return false;
    #####:   59:  auto attr =
    #####:   60:      op->getAttrOfType<ArrayAttr>(BufferizationDialect::kEscapeAttrName);
call    0 never executed
    #####:   61:  return !attr[opResult.getResultNumber()].cast<BoolAttr>().getValue();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   62:}
        -:   63:
        -:   64:/// Create an AllocTensorOp for the given shaped value. If `copy` is set, the
        -:   65:/// shaped value is copied. Otherwise, a tensor with undefined contents is
        -:   66:/// allocated.
function _ZN4mlir13bufferization28allocateTensorForShapedValueERNS_9OpBuilderENS_8LocationENS_5ValueEbRKNS0_20BufferizationOptionsEb called 0 returned 0% blocks executed 0%
    #####:   67:FailureOr<Value> bufferization::allocateTensorForShapedValue(
        -:   68:    OpBuilder &b, Location loc, Value shapedValue, bool escape,
        -:   69:    const BufferizationOptions &options, bool copy) {
    #####:   70:  Value tensor;
    #####:   71:  if (shapedValue.getType().isa<RankedTensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   72:    tensor = shapedValue;
    #####:   73:  } else if (shapedValue.getType().isa<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   74:    tensor = b.create<ToTensorOp>(loc, shapedValue);
call    0 never executed
        -:   75:  } else {
    #####:   76:    llvm_unreachable("expected RankedTensorType or MemRefType");
call    0 never executed
        -:   77:  }
    #####:   78:  RankedTensorType tensorType = tensor.getType().cast<RankedTensorType>();
call    0 never executed
    #####:   79:  SmallVector<Value> dynamicSizes;
branch  0 never executed
branch  1 never executed
    #####:   80:  if (!copy) {
branch  0 never executed
branch  1 never executed
        -:   81:    // Compute the dynamic part of the shape.
        -:   82:    // First try to query the shape via ReifyRankedShapedTypeOpInterface.
    #####:   83:    bool reifiedShapes = false;
    #####:   84:    if (shapedValue.getType().isa<RankedTensorType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   85:        shapedValue.isa<OpResult>()) {
branch  0 never executed
branch  1 never executed
    #####:   86:      if (auto rankedOp = dyn_cast_or_null<ReifyRankedShapedTypeOpInterface>(
branch  0 never executed
branch  1 never executed
    #####:   87:              shapedValue.getDefiningOp())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   88:        ReifiedRankedShapedTypeDims resultDims;
call    0 never executed
call    1 never executed
    #####:   89:        if (succeeded(rankedOp.reifyResultShapes(b, resultDims))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   90:          reifiedShapes = true;
    #####:   91:          auto &shape =
call    0 never executed
    #####:   92:              resultDims[shapedValue.cast<OpResult>().getResultNumber()];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   93:          for (const auto &dim : enumerate(tensorType.getShape()))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   94:            if (ShapedType::isDynamic(dim.value()))
branch  0 never executed
branch  1 never executed
    #####:   95:              dynamicSizes.push_back(shape[dim.index()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:        }
        -:   97:      }
        -:   98:    }
        -:   99:
        -:  100:    // If the shape could not be reified, create DimOps.
    #####:  101:    if (!reifiedShapes)
branch  0 never executed
branch  1 never executed
    #####:  102:      populateDynamicDimSizes(b, loc, tensor, dynamicSizes);
call    0 never executed
        -:  103:  }
        -:  104:
        -:  105:  // Create AllocTensorOp.
    #####:  106:  auto allocTensorOp = b.create<AllocTensorOp>(loc, tensorType, dynamicSizes,
    #####:  107:                                               copy ? tensor : Value());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  108:  allocTensorOp->setAttr(BufferizationDialect::kEscapeAttrName,
call    0 never executed
call    1 never executed
    #####:  109:                         b.getBoolArrayAttr({escape}));
call    0 never executed
        -:  110:
        -:  111:  // Add 'memory_space' attribute. Not needed if 'copy' operand is specified.
    #####:  112:  if (copy)
branch  0 never executed
branch  1 never executed
    #####:  113:    return allocTensorOp.getResult();
call    0 never executed
    #####:  114:  FailureOr<BaseMemRefType> copyBufferType = getBufferType(tensor, options);
call    0 never executed
    #####:  115:  if (failed(copyBufferType))
branch  0 never executed
branch  1 never executed
    #####:  116:    return failure();
    #####:  117:  allocTensorOp.setMemorySpaceAttr(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  118:      b.getIntegerAttr(b.getIntegerType(64, /*isSigned=*/false),
call    0 never executed
    #####:  119:                       copyBufferType->getMemorySpaceAsInt()));
call    0 never executed
    #####:  120:  return allocTensorOp.getResult();
call    0 never executed
        -:  121:}
        -:  122:
function _ZN4mlir13bufferization23BufferizableOpInterface31resolveTensorOpOperandConflictsERNS_12RewriterBaseERKNS0_13AnalysisStateE called 1958 returned 100% blocks executed 28%
     1958:  123:LogicalResult BufferizableOpInterface::resolveTensorOpOperandConflicts(
        -:  124:    RewriterBase &rewriter, const AnalysisState &state) {
     1958:  125:  OpBuilder::InsertionGuard g(rewriter);
call    0 returned 100%
     1958:  126:  Operation *op = getOperation();
call    0 returned 100%
     3916:  127:  SmallVector<OpOperand *> outOfPlaceOpOperands;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     3916:  128:  DenseSet<OpOperand *> copiedOpOperands;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3916:  129:  DenseSet<OpOperand *> escapingOpOperandCopies;
call    0 returned 100%
call    1 returned 100%
     3916:  130:  SmallVector<OpResult> outOfPlaceOpResults;
call    0 returned 100%
call    1 returned 100%
     3916:  131:  DenseSet<OpResult> copiedOpResults;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     3916:  132:  DenseSet<OpResult> escapingOpResultCopies;
call    0 returned 100%
call    1 returned 100%
        -:  133:
        -:  134:  // Find all out-of-place OpOperands.
     4079:  135:  for (OpOperand &opOperand : op->getOpOperands()) {
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
     2121:  136:    Type operandType = opOperand.get().getType();
call    0 returned 100%
     2121:  137:    if (!operandType.isa<TensorType>())
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
     2121:  138:      continue;
     2078:  139:    if (state.isInPlace(opOperand))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     2078:  140:      continue;
    #####:  141:    if (operandType.isa<UnrankedTensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  142:      return op->emitError("copies of unranked tensors are not supported");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  143:
    #####:  144:    SmallVector<OpResult> aliasingOpResults =
    #####:  145:        state.getAliasingOpResult(opOperand);
call    0 never executed
        -:  146:    // Is the result yielded from a block? Or are deallocations turned off
        -:  147:    // entirely? In either case, mark the allocation as "escaping", so that it
        -:  148:    // will not be deallocated.
    #####:  149:    bool escape = !state.getOptions().createDeallocs ||
branch  0 never executed
branch  1 never executed
    #####:  150:                  llvm::any_of(aliasingOpResults, [&](Value v) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  151:                    return state.isTensorYielded(v);
    #####:  152:                  });
        -:  153:
    #####:  154:    if (aliasingOpResults.size() == 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  155:        !state.bufferizesToMemoryWrite(opOperand) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  156:        state.getAliasingOpOperand(aliasingOpResults.front()).size() == 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  157:      // The op itself does not write but may create exactly one alias. Instead
        -:  158:      // of copying the OpOperand, copy the OpResult. The OpResult can sometimes
        -:  159:      // be smaller than the OpOperand (e.g., in the case of an extract_slice,
        -:  160:      // where the result is usually a smaller part of the source).
    #####:  161:      outOfPlaceOpResults.push_back(aliasingOpResults.front());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  162:      if (!state.canOmitTensorCopy(opOperand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  163:        copiedOpResults.insert(aliasingOpResults.front());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  164:      if (escape)
branch  0 never executed
branch  1 never executed
    #####:  165:        escapingOpResultCopies.insert(aliasingOpResults.front());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  166:    } else {
        -:  167:      // In all other cases, make a copy of the OpOperand.
    #####:  168:      outOfPlaceOpOperands.push_back(&opOperand);
call    0 never executed
    #####:  169:      if (!state.canOmitTensorCopy(opOperand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  170:        copiedOpOperands.insert(&opOperand);
call    0 never executed
    #####:  171:      if (escape)
branch  0 never executed
branch  1 never executed
    #####:  172:        escapingOpOperandCopies.insert(&opOperand);
call    0 never executed
        -:  173:    }
        -:  174:  }
        -:  175:
        -:  176:  // Insert copies of OpOperands.
     1958:  177:  rewriter.setInsertionPoint(op);
call    0 returned 100%
    1958*:  178:  for (OpOperand *opOperand : outOfPlaceOpOperands) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  179:    FailureOr<Value> copy = allocateTensorForShapedValue(
        -:  180:        rewriter, op->getLoc(), opOperand->get(),
    #####:  181:        escapingOpOperandCopies.contains(opOperand), state.getOptions(),
call    0 never executed
    #####:  182:        copiedOpOperands.contains(opOperand));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  183:    if (failed(copy))
branch  0 never executed
branch  1 never executed
    #####:  184:      return failure();
function _ZZN4mlir13bufferization23BufferizableOpInterface31resolveTensorOpOperandConflictsERNS_12RewriterBaseERKNS0_13AnalysisStateEENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  185:    rewriter.updateRootInPlace(op, [&]() { opOperand->set(*copy); });
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  186:  }
        -:  187:
        -:  188:  // Insert copies of OpResults.
     1958:  189:  rewriter.setInsertionPointAfter(op);
call    0 returned 100%
    1958*:  190:  for (OpResult opResult : outOfPlaceOpResults) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  191:    FailureOr<Value> copy = allocateTensorForShapedValue(
call    0 never executed
        -:  192:        rewriter, op->getLoc(), opResult,
    #####:  193:        escapingOpResultCopies.contains(opResult), state.getOptions(),
call    0 never executed
    #####:  194:        copiedOpResults.count(opResult));
call    0 never executed
call    1 never executed
    #####:  195:    if (failed(copy))
branch  0 never executed
branch  1 never executed
    #####:  196:      return failure();
    #####:  197:    SmallVector<OpOperand *> uses = llvm::to_vector(llvm::map_range(
call    0 never executed
    #####:  198:        opResult.getUses(), [](OpOperand &use) { return &use; }));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  199:    for (OpOperand *use : uses) {
branch  0 never executed
branch  1 never executed
        -:  200:      // Do not update the alloc_tensor op that we just created.
    #####:  201:      if (use->getOwner() != copy->getDefiningOp())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
function _ZZN4mlir13bufferization23BufferizableOpInterface31resolveTensorOpOperandConflictsERNS_12RewriterBaseERKNS0_13AnalysisStateEENKUlvE2_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####:  202:        rewriter.updateRootInPlace(use->getOwner(), [&]() { use->set(*copy); });
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  203:    }
        -:  204:  }
        -:  205:
     1958:  206:  return success();
call    0 returned 100%
        -:  207:}
        -:  208:
function _ZN4mlir13bufferization24shouldDeallocateOpResultENS_8OpResultERKNS0_20BufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  209:bool bufferization::shouldDeallocateOpResult(
        -:  210:    OpResult opResult, const BufferizationOptions &options) {
    #####:  211:  Operation *op = opResult.getOwner();
call    0 never executed
    #####:  212:  assert(options.dynCastBufferizableOp(op).bufferizesToAllocation(opResult) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  213:         "expected that op allocates");
        -:  214:
    #####:  215:  AnalysisState analysisState(options);
call    0 never executed
    #####:  216:  if (op->hasAttr(BufferizationDialect::kEscapeAttrName)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:    // AllocTensorOp has one result.
    #####:  218:    ArrayAttr escapeAttr =
call    0 never executed
    #####:  219:        op->getAttr(BufferizationDialect::kEscapeAttrName).cast<ArrayAttr>();
call    0 never executed
    #####:  220:    return !escapeAttr[0].cast<BoolAttr>().getValue();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  221:  }
        -:  222:
        -:  223:  // No "escape" annotation found.
    #####:  224:  if (options.createDeallocs) {
branch  0 never executed
branch  1 never executed
        -:  225:    // Perform an ad-hoc analysis.
    #####:  226:    return !analysisState.isTensorYielded(opResult);
call    0 never executed
        -:  227:  }
        -:  228:
        -:  229:  return false;
        -:  230:}
        -:  231:
        -:  232://===----------------------------------------------------------------------===//
        -:  233:// OpFilter
        -:  234://===----------------------------------------------------------------------===//
        -:  235:
function _ZNK4mlir13bufferization8OpFilter11isOpAllowedEPNS_9OperationE called 47018 returned 100% blocks executed 79%
    47018:  236:bool OpFilter::isOpAllowed(Operation *op) const {
        -:  237:  // All other ops: Allow/disallow according to filter.
    47018:  238:  bool isAllowed = !hasAllowRule();
    51748:  239:  for (const Entry &entry : entries) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
     4730:  240:    bool filterResult = entry.fn(op);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     4730:  241:    switch (entry.type) {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
     4730:  242:    case Entry::ALLOW:
     4730:  243:      isAllowed |= filterResult;
     4730:  244:      break;
    #####:  245:    case Entry::DENY:
    #####:  246:      if (filterResult)
branch  0 never executed
branch  1 never executed
        -:  247:        // DENY filter matches. This op is no allowed. (Even if other ALLOW
        -:  248:        // filters may match.)
        -:  249:        return false;
     4730:  250:    };
        -:  251:  }
        -:  252:  return isAllowed;
        -:  253:}
        -:  254:
        -:  255://===----------------------------------------------------------------------===//
        -:  256:// BufferizationOptions
        -:  257://===----------------------------------------------------------------------===//
        -:  258:
        -:  259:/// Default unknown type converter: Use a fully dynamic layout map.
        -:  260:static BaseMemRefType
function _ZL27defaultUnknownTypeConverterN4mlir5ValueEjRKNS_13bufferization20BufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  261:defaultUnknownTypeConverter(Value value, unsigned memorySpace,
        -:  262:                            const BufferizationOptions &options) {
    #####:  263:  return getMemRefTypeWithFullyDynamicLayout(value.getType().cast<TensorType>(),
call    0 never executed
    #####:  264:                                             memorySpace);
call    0 never executed
        -:  265:}
        -:  266:
        -:  267:// Default constructor for BufferizationOptions.
function _ZN4mlir13bufferization20BufferizationOptionsC2Ev called 8692 returned 100% blocks executed 100%
     8692:  268:BufferizationOptions::BufferizationOptions()
     8692:  269:    : unknownTypeConverterFn(defaultUnknownTypeConverter) {}
        -:  270:
function _ZNK4mlir13bufferization20BufferizationOptions11isOpAllowedEPNS_9OperationE called 85075 returned 100% blocks executed 88%
    85075:  271:bool BufferizationOptions::isOpAllowed(Operation *op) const {
        -:  272:  // Special case: If function boundary bufferization is deactivated, do not
        -:  273:  // allow ops that belong to the `func` dialect.
    85075:  274:  bool isFuncBoundaryOp = isa_and_nonnull<func::FuncDialect>(op->getDialect());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    85075:  275:  if (!bufferizeFunctionBoundaries && isFuncBoundaryOp)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
        -:  276:    return false;
        -:  277:
    44450:  278:  return opFilter.isOpAllowed(op);
call    0 returned 100%
        -:  279:}
        -:  280:
        -:  281:BufferizableOpInterface
function _ZNK4mlir13bufferization20BufferizationOptions21dynCastBufferizableOpEPNS_9OperationE called 298368 returned 100% blocks executed 100%
   298368:  282:BufferizationOptions::dynCastBufferizableOp(Operation *op) const {
   298368:  283:  auto bufferizableOp = dyn_cast<BufferizableOpInterface>(op);
call    0 returned 100%
   298349:  284:  if (!bufferizableOp)
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
   231516:  285:    return nullptr;
    66833:  286:  if (!isOpAllowed(op))
call    0 returned 100%
branch  1 taken 46% (fallthrough)
branch  2 taken 54%
    30795:  287:    return nullptr;
    36035:  288:  return bufferizableOp;
        -:  289:}
        -:  290:
        -:  291:BufferizableOpInterface
function _ZNK4mlir13bufferization20BufferizationOptions21dynCastBufferizableOpENS_5ValueE called 4524 returned 100% blocks executed 100%
     4524:  292:BufferizationOptions::dynCastBufferizableOp(Value value) const {
     4524:  293:  if (auto bufferizableOp = value.getDefiningOp<BufferizableOpInterface>())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
       16:  294:    if (isOpAllowed(bufferizableOp.getOperation()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       16:  295:      return bufferizableOp;
     4508:  296:  return nullptr;
        -:  297:}
        -:  298:
function _ZN4mlir13bufferization20BufferizationOptions26addDialectStateInitializerEN4llvm9StringRefERKSt8functionIFSt10unique_ptrINS0_20DialectAnalysisStateESt14default_deleteIS6_EEvEE called 0 returned 0% blocks executed 0%
    #####:  299:void BufferizationOptions::addDialectStateInitializer(
        -:  300:    StringRef name, const DialectStateInitFn &fn) {
    #####:  301:  stateInitializers.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
function _ZZN4mlir13bufferization20BufferizationOptions26addDialectStateInitializerEN4llvm9StringRefERKSt8functionIFSt10unique_ptrINS0_20DialectAnalysisStateESt14default_deleteIS6_EEvEEENKUlRNS0_13AnalysisStateEE_clESF_ called 0 returned 0% blocks executed 0%
    #####:  302:      [=](AnalysisState &state) { state.insertDialectState(name, fn()); });
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  303:}
        -:  304:
        -:  305://===----------------------------------------------------------------------===//
        -:  306:// Helper functions for BufferizableOpInterface
        -:  307://===----------------------------------------------------------------------===//
        -:  308:
function _ZL22setInsertionPointAfterRN4mlir9OpBuilderENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  309:static void setInsertionPointAfter(OpBuilder &b, Value value) {
    #####:  310:  if (auto bbArg = value.dyn_cast<BlockArgument>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  311:    b.setInsertionPointToStart(bbArg.getOwner());
        -:  312:  } else {
    #####:  313:    b.setInsertionPointAfter(value.getDefiningOp());
call    0 never executed
call    1 never executed
        -:  314:  }
    #####:  315:}
        -:  316:
        -:  317:/// Determine which OpOperand* will alias with `result` if the op is bufferized
        -:  318:/// in place. Return an empty vector if the op is not bufferizable.
        -:  319:SmallVector<OpOperand *>
function _ZNK4mlir13bufferization13AnalysisState20getAliasingOpOperandENS_8OpResultE called 0 returned 0% blocks executed 0%
    #####:  320:AnalysisState::getAliasingOpOperand(OpResult result) const {
    #####:  321:  if (Operation *op = result.getDefiningOp())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  322:    if (auto bufferizableOp = getOptions().dynCastBufferizableOp(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  323:      return bufferizableOp.getAliasingOpOperand(result, *this);
call    0 never executed
    #####:  324:  return {};
        -:  325:}
        -:  326:
        -:  327:/// Determine which OpResult will alias with `opOperand` if the op is bufferized
        -:  328:/// in place. Return an empty vector if the op is not bufferizable.
        -:  329:SmallVector<OpResult>
function _ZNK4mlir13bufferization13AnalysisState19getAliasingOpResultERNS_9OpOperandE called 8064 returned 100% blocks executed 83%
     8064:  330:AnalysisState::getAliasingOpResult(OpOperand &opOperand) const {
     8064:  331:  if (auto bufferizableOp =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     8064:  332:          getOptions().dynCastBufferizableOp(opOperand.getOwner()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     8064:  333:    return bufferizableOp.getAliasingOpResult(opOperand, *this);
call    0 returned 100%
    #####:  334:  return {};
        -:  335:}
        -:  336:
        -:  337:/// Return true if `opOperand` bufferizes to a memory read. Return `true` if the
        -:  338:/// op is not bufferizable.
function _ZNK4mlir13bufferization13AnalysisState22bufferizesToMemoryReadERNS_9OpOperandE called 6223 returned 100% blocks executed 100%
     6223:  339:bool AnalysisState::bufferizesToMemoryRead(OpOperand &opOperand) const {
     6223:  340:  if (auto bufferizableOp =
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
     6223:  341:          getOptions().dynCastBufferizableOp(opOperand.getOwner()))
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
     4032:  342:    return bufferizableOp.bufferizesToMemoryRead(opOperand, *this);
call    0 returned 100%
        -:  343:
        -:  344:  // Unknown op that returns a tensor. The inplace analysis does not support it.
        -:  345:  // Conservatively return true.
     2191:  346:  return true;
        -:  347:}
        -:  348:
        -:  349:/// Return true if `opOperand` bufferizes to a memory write. Return
        -:  350:/// `true` if the op is not bufferizable.
function _ZNK4mlir13bufferization13AnalysisState23bufferizesToMemoryWriteERNS_9OpOperandE called 10794 returned 100% blocks executed 100%
    10794:  351:bool AnalysisState::bufferizesToMemoryWrite(OpOperand &opOperand) const {
    10794:  352:  if (auto bufferizableOp =
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
    10794:  353:          getOptions().dynCastBufferizableOp(opOperand.getOwner()))
call    0 returned 100%
branch  1 taken 93% (fallthrough)
branch  2 taken 7%
    10080:  354:    return bufferizableOp.bufferizesToMemoryWrite(opOperand, *this);
call    0 returned 100%
        -:  355:
        -:  356:  // Unknown op that returns a tensor. The inplace analysis does not support it.
        -:  357:  // Conservatively return true.
      714:  358:  return true;
        -:  359:}
        -:  360:
        -:  361:/// Return true if `opOperand` does neither read nor write but bufferizes to an
        -:  362:/// alias. Return false if the op is not bufferizable.
function _ZNK4mlir13bufferization13AnalysisState21bufferizesToAliasOnlyERNS_9OpOperandE called 1715 returned 100% blocks executed 67%
     1715:  363:bool AnalysisState::bufferizesToAliasOnly(OpOperand &opOperand) const {
     1715:  364:  if (auto bufferizableOp =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1715:  365:          getOptions().dynCastBufferizableOp(opOperand.getOwner()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  366:    return bufferizableOp.bufferizesToAliasOnly(opOperand, *this);
call    0 never executed
        -:  367:
        -:  368:  // Unknown op that returns a tensor. The inplace analysis does not support it.
        -:  369:  // Conservatively return false.
     1715:  370:  return false;
        -:  371:}
        -:  372:
        -:  373:/// Return true if the given value is read by an op that bufferizes to a memory
        -:  374:/// read. Also takes into account ops that create an alias but do not read by
        -:  375:/// themselves (e.g., ExtractSliceOp).
function _ZNK4mlir13bufferization13AnalysisState11isValueReadENS_5ValueE called 1715 returned 100% blocks executed 54%
     1715:  376:bool AnalysisState::isValueRead(Value value) const {
    1715*:  377:  assert(value.getType().isa<TensorType>() && "expected TensorType");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     1715:  378:  SmallVector<OpOperand *> workingSet;
     4122:  379:  for (OpOperand &use : value.getUses())
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
     2407:  380:    workingSet.push_back(&use);
call    0 returned 100%
        -:  381:
     1715:  382:  while (!workingSet.empty()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1715:  383:    OpOperand *uMaybeReading = workingSet.pop_back_val();
call    0 returned 100%
        -:  384:    // Skip over all ops that neither read nor write (but create an alias).
     1715:  385:    if (bufferizesToAliasOnly(*uMaybeReading))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  386:      for (OpResult opResult : getAliasingOpResult(*uMaybeReading))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:        for (OpOperand &use : opResult.getUses())
branch  0 never executed
branch  1 never executed
    #####:  388:          workingSet.push_back(&use);
call    0 never executed
     1715:  389:    if (bufferizesToMemoryRead(*uMaybeReading))
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  390:      return true;
        -:  391:  }
        -:  392:
        -:  393:  return false;
        -:  394:}
        -:  395:
        -:  396:// Starting from `value`, follow the use-def chain in reverse, always selecting
        -:  397:// the aliasing OpOperands. Find and return Values for which `condition`
        -:  398:// evaluates to true. OpOperands of such matching Values are not traversed any
        -:  399:// further.
function _ZNK4mlir13bufferization13AnalysisState29findValueInReverseUseDefChainENS_5ValueEN4llvm12function_refIFbS2_EEEb called 4524 returned 100% blocks executed 37%
     4524:  400:llvm::SetVector<Value> AnalysisState::findValueInReverseUseDefChain(
        -:  401:    Value value, llvm::function_ref<bool(Value)> condition,
        -:  402:    bool followEquivalentOnly) const {
     4524:  403:  llvm::SetVector<Value> result, workingSet;
call    0 returned 100%
call    1 returned 100%
     4524:  404:  workingSet.insert(value);
call    0 returned 100%
        -:  405:
     9048:  406:  while (!workingSet.empty()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     4524:  407:    Value value = workingSet.pop_back_val();
call    0 returned 100%
    4524*:  408:    if (condition(value) || value.isa<BlockArgument>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
     4524:  409:      result.insert(value);
call    0 returned 100%
     4524:  410:      continue;
        -:  411:    }
        -:  412:
    #####:  413:    OpResult opResult = value.cast<OpResult>();
call    0 never executed
    #####:  414:    BufferizableOpInterface bufferizableOp =
    #####:  415:        options.dynCastBufferizableOp(opResult.getDefiningOp());
call    0 never executed
call    1 never executed
    #####:  416:    SmallVector<OpOperand *> opOperands = getAliasingOpOperand(opResult);
call    0 never executed
        -:  417:
        -:  418:    // Stop iterating in either one of these cases:
        -:  419:    // * The current op is not bufferizable or excluded in the filter.
        -:  420:    // * There are no OpOperands to follow.
        -:  421:    // * There is an OpOperand, but it is not an equivalent tensor (only if
        -:  422:    //   `followEquivalentOnly` is set).
    #####:  423:    if (!bufferizableOp || opOperands.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  424:        (followEquivalentOnly &&
    #####:  425:         bufferizableOp.bufferRelation(opResult, *this) !=
branch  0 never executed
branch  1 never executed
        -:  426:             BufferRelation::Equivalent)) {
    #####:  427:      result.insert(value);
call    0 never executed
    4524*:  428:      continue;
branch  0 never executed
branch  1 never executed
        -:  429:    }
        -:  430:
    #####:  431:    for (OpOperand *o : opOperands)
branch  0 never executed
branch  1 never executed
    #####:  432:      workingSet.insert(o->get());
call    0 never executed
        -:  433:  }
        -:  434:
     4524:  435:  return result;
call    0 returned 100%
        -:  436:}
        -:  437:
        -:  438:// Find the Values of the last preceding write of a given Value.
        -:  439:llvm::SetVector<Value>
function _ZNK4mlir13bufferization13AnalysisState22findLastPrecedingWriteENS_5ValueE called 4524 returned 100% blocks executed 100%
     4524:  440:AnalysisState::findLastPrecedingWrite(Value value) const {
function _ZZNK4mlir13bufferization13AnalysisState22findLastPrecedingWriteENS_5ValueEENKUlS2_E_clES2_.isra.0 called 4524 returned 100% blocks executed 100%
     9048:  441:  return findValueInReverseUseDefChain(value, [&](Value value) {
     4524:  442:    Operation *op = value.getDefiningOp();
call    0 returned 100%
     4524:  443:    if (!op)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  444:      return true;
     4524:  445:    auto bufferizableOp = options.dynCastBufferizableOp(op);
call    0 returned 100%
     4524:  446:    if (!bufferizableOp)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  447:      return true;
       16:  448:    return bufferizableOp.isMemoryWrite(value.cast<OpResult>(), *this);
call    0 returned 100%
call    1 returned 100%
     4524:  449:  });
call    0 returned 100%
        -:  450:}
        -:  451:
function _ZN4mlir13bufferization13AnalysisStateC2ERKNS0_20BufferizationOptionsE called 17366 returned 100% blocks executed 62%
    17366:  452:AnalysisState::AnalysisState(const BufferizationOptions &options)
    17366:  453:    : options(options) {
call    0 returned 100%
   17395*:  454:  for (const BufferizationOptions::AnalysisStateInitFn &fn :
    17395:  455:       options.stateInitializers)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      22*:  456:    fn(*this);
branch  0 never executed
branch  1 never executed
    17395:  457:}
        -:  458:
function _ZNK4mlir13bufferization13AnalysisState17canOmitTensorCopyERNS_9OpOperandE called 0 returned 0% blocks executed 0%
    #####:  459:bool AnalysisState::canOmitTensorCopy(OpOperand &opOperand) const {
        -:  460:  // Do not copy if the tensor has undefined contents.
    #####:  461:  if (hasUndefinedContents(&opOperand))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  462:    return true;
        -:  463:
        -:  464:  // Do not copy if the buffer of the tensor is entirely overwritten (with
        -:  465:  // values that do not depend on the old tensor).
    #####:  466:  if (bufferizesToMemoryWrite(opOperand) && !bufferizesToMemoryRead(opOperand))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  467:    return true;
        -:  468:
        -:  469:  // Do not copy if the tensor is never read.
    #####:  470:  SmallVector<OpResult> aliasingOpResults = getAliasingOpResult(opOperand);
call    0 never executed
    #####:  471:  if (!bufferizesToMemoryRead(opOperand) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  472:      llvm::none_of(aliasingOpResults,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  473:                    [&](OpResult opResult) { return isValueRead(opResult); }))
    #####:  474:    return true;
        -:  475:
        -:  476:  // Default: Cannot omit the copy.
        -:  477:  return false;
        -:  478:}
        -:  479:
function _ZNK4mlir13bufferization13AnalysisState9isInPlaceERNS_9OpOperandE called 62 returned 100% blocks executed 60%
       62:  480:bool AnalysisState::isInPlace(OpOperand &opOperand) const {
        -:  481:  // ToMemrefOps are always in-place.
       62:  482:  if (isa<ToMemrefOp>(opOperand.getOwner()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  483:    return true;
        -:  484:
        -:  485:  // In the absence of analysis information, OpOperands that bufferize to a
        -:  486:  // memory write are out-of-place, i.e., an alloc and copy is inserted.
    #####:  487:  return !bufferizesToMemoryWrite(opOperand);
call    0 never executed
        -:  488:}
        -:  489:
function _ZNK4mlir13bufferization13AnalysisState29areEquivalentBufferizedValuesENS_5ValueES2_ called 0 returned 0% blocks executed 0%
    #####:  490:bool AnalysisState::areEquivalentBufferizedValues(Value v1, Value v2) const {
        -:  491:  // In the absence of analysis information, we do not know if the values are
        -:  492:  // equivalent. The conservative answer is "false".
    #####:  493:  return false;
        -:  494:}
        -:  495:
function _ZNK4mlir13bufferization13AnalysisState27areAliasingBufferizedValuesENS_5ValueES2_ called 0 returned 0% blocks executed 0%
    #####:  496:bool AnalysisState::areAliasingBufferizedValues(Value v1, Value v2) const {
        -:  497:  // In the absence of analysis information, we do not know if the values may be
        -:  498:  // aliasing. The conservative answer is "true".
    #####:  499:  return true;
        -:  500:}
        -:  501:
function _ZNK4mlir13bufferization13AnalysisState20hasUndefinedContentsEPNS_9OpOperandE called 0 returned 0% blocks executed 0%
    #####:  502:bool AnalysisState::hasUndefinedContents(OpOperand *opOperand) const {
        -:  503:  // In the absence of analysis information, the conservative answer is "false".
    #####:  504:  return false;
        -:  505:}
        -:  506:
function _ZNK4mlir13bufferization13AnalysisState15isTensorYieldedENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  507:bool AnalysisState::isTensorYielded(Value tensor) const {
        -:  508:  // In the absence of analysis information, the conservative answer is "true".
    #####:  509:  if (!tensor.getDefiningOp<AllocTensorOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  510:    return true;
        -:  511:
        -:  512:  // For AllocTensorOp results, we can do better: They do not alias with any
        -:  513:  // preceding value, so we can follow SSA use-def chains and do a simple
        -:  514:  // analysis.
    #####:  515:  SmallVector<OpOperand *> worklist;
    #####:  516:  for (OpOperand &use : tensor.getUses())
branch  0 never executed
branch  1 never executed
    #####:  517:    worklist.push_back(&use);
call    0 never executed
        -:  518:
    #####:  519:  while (!worklist.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  520:    OpOperand *operand = worklist.pop_back_val();
call    0 never executed
    #####:  521:    Operation *op = operand->getOwner();
call    0 never executed
        -:  522:
        -:  523:    // If the op is not bufferizable, we can safely assume that the value is not
        -:  524:    // yielded. (When bufferizing that op, it must handle such cases.)
    #####:  525:    if (!options.dynCastBufferizableOp(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  526:      continue;
        -:  527:
        -:  528:    // We cannot analyze through ToMemrefOps, so we have to conservatively
        -:  529:    // assume that the value is yielded.
    #####:  530:    if (isa<ToMemrefOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  531:      return true;
branch  0 never executed
branch  1 never executed
        -:  532:
        -:  533:    // Check if the op is returning/yielding.
    #####:  534:    if (isRegionReturnLike(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  535:      return true;
        -:  536:
        -:  537:    // Add all aliasing OpResults to the worklist.
        -:  538:    // Note: In the absence of detailed analysis information (e.g., there may be
        -:  539:    // no function call analysis information), this `getAliasingOpResult` is
        -:  540:    // conservative and may report additional OpResults as potentially aliasing.
    #####:  541:    for (OpResult opResult : getAliasingOpResult(*operand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  542:      for (OpOperand &use : opResult.getUses())
branch  0 never executed
branch  1 never executed
    #####:  543:        worklist.push_back(&use);
call    0 never executed
        -:  544:  }
        -:  545:
        -:  546:  // No ReturnLike op found: The value is not yielded.
        -:  547:  return false;
        -:  548:}
        -:  549:
        -:  550:// bufferization.to_memref is not allowed to change the rank.
function _ZL23ensureToMemrefOpIsValidN4mlir5ValueENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  551:static void ensureToMemrefOpIsValid(Value tensor, Type memrefType) {
        -:  552:#ifndef NDEBUG
    #####:  553:  auto rankedTensorType = tensor.getType().dyn_cast<RankedTensorType>();
call    0 never executed
    #####:  554:  assert((!rankedTensorType || memrefType.cast<MemRefType>().getRank() ==
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  555:                                   rankedTensorType.getRank()) &&
        -:  556:         "to_memref would be invalid: mismatching ranks");
        -:  557:#endif
    #####:  558:}
        -:  559:
function _ZN4mlir13bufferization9getBufferERNS_12RewriterBaseENS_5ValueERKNS0_20BufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  560:FailureOr<Value> bufferization::getBuffer(RewriterBase &rewriter, Value value,
        -:  561:                                          const BufferizationOptions &options) {
        -:  562:#ifndef NDEBUG
    #####:  563:  auto tensorType = value.getType().dyn_cast<TensorType>();
call    0 never executed
    #####:  564:  assert(tensorType && "unexpected non-tensor type");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  565:#endif // NDEBUG
        -:  566:
        -:  567:  // Replace "%t = to_tensor %m" with %m.
    #####:  568:  if (auto toTensorOp = value.getDefiningOp<bufferization::ToTensorOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  569:    return toTensorOp.getMemref();
call    0 never executed
        -:  570:
        -:  571:  // Insert to_memref op.
    #####:  572:  OpBuilder::InsertionGuard g(rewriter);
call    0 never executed
    #####:  573:  setInsertionPointAfter(rewriter, value);
call    0 never executed
    #####:  574:  FailureOr<BaseMemRefType> memrefType = getBufferType(value, options);
call    0 never executed
    #####:  575:  if (failed(memrefType))
branch  0 never executed
branch  1 never executed
    #####:  576:    return failure();
    #####:  577:  ensureToMemrefOpIsValid(value, *memrefType);
call    0 never executed
    #####:  578:  return rewriter
    #####:  579:      .create<bufferization::ToMemrefOp>(value.getLoc(), *memrefType, value)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  580:      .getResult();
        -:  581:}
        -:  582:
function _ZN4mlir13bufferization6detail20defaultGetBufferTypeENS_5ValueERKNS0_20BufferizationOptionsERKN4llvm8DenseMapIS2_NS_14BaseMemRefTypeENS6_12DenseMapInfoIS2_vEENS6_6detail12DenseMapPairIS2_S8_EEEE called 0 returned 0% blocks executed 0%
    #####:  583:FailureOr<BaseMemRefType> bufferization::detail::defaultGetBufferType(
        -:  584:    Value value, const BufferizationOptions &options,
        -:  585:    const DenseMap<Value, BaseMemRefType> &fixedTypes) {
    #####:  586:  assert(value.getType().isa<TensorType>() && "expected tensor type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  587:
        -:  588:  // No further analysis is possible for a block argument.
    #####:  589:  if (value.isa<BlockArgument>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  590:    return bufferization::getMemRefType(value, options);
call    0 never executed
call    1 never executed
        -:  591:
        -:  592:  // Value is an OpResult.
    #####:  593:  Operation *op = getOwnerOfValue(value);
call    0 never executed
    #####:  594:  auto opResult = value.cast<OpResult>();
call    0 never executed
    #####:  595:  auto bufferizableOp = cast<BufferizableOpInterface>(op);
call    0 never executed
    #####:  596:  AnalysisState state(options);
call    0 never executed
    #####:  597:  auto aliasingOperands = bufferizableOp.getAliasingOpOperand(opResult, state);
call    0 never executed
call    1 never executed
    #####:  598:  if (!aliasingOperands.empty() &&
branch  0 never executed
branch  1 never executed
    #####:  599:      bufferizableOp.bufferRelation(opResult, state) ==
branch  0 never executed
branch  1 never executed
        -:  600:          BufferRelation::Equivalent) {
        -:  601:    // If the OpResult has an equivalent OpOperand, both OpResult and
        -:  602:    // OpOperand bufferize to the exact same buffer type.
    #####:  603:    Value equivalentOperand = aliasingOperands.front()->get();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  604:    return getBufferType(equivalentOperand, options, fixedTypes);
call    0 never executed
        -:  605:  }
        -:  606:
        -:  607:  // If we do not know the memory space and there is no default memory space,
        -:  608:  // report a failure.
    #####:  609:  if (!options.defaultMemorySpace.has_value())
branch  0 never executed
branch  1 never executed
    #####:  610:    return op->emitError("could not infer memory space");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  611:
    #####:  612:  return getMemRefType(value, options, /*layout=*/{},
    #####:  613:                       *options.defaultMemorySpace);
call    0 never executed
call    1 never executed
        -:  614:}
        -:  615:
        -:  616:/// Return the buffer type for a given Value (tensor) after bufferization.
        -:  617:FailureOr<BaseMemRefType>
function _ZN4mlir13bufferization13getBufferTypeENS_5ValueERKNS0_20BufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  618:bufferization::getBufferType(Value value, const BufferizationOptions &options) {
    #####:  619:  DenseMap<Value, BaseMemRefType> fixedTypes;
call    0 never executed
    #####:  620:  return getBufferType(value, options, fixedTypes);
call    0 never executed
call    1 never executed
        -:  621:}
        -:  622:
        -:  623:/// Return the buffer type for a given Value (tensor) after bufferization.
function _ZN4mlir13bufferization13getBufferTypeENS_5ValueERKNS0_20BufferizationOptionsERKN4llvm8DenseMapIS1_NS_14BaseMemRefTypeENS5_12DenseMapInfoIS1_vEENS5_6detail12DenseMapPairIS1_S7_EEEE called 0 returned 0% blocks executed 0%
    #####:  624:FailureOr<BaseMemRefType> bufferization::getBufferType(
        -:  625:    Value value, const BufferizationOptions &options,
        -:  626:    const DenseMap<Value, BaseMemRefType> &fixedTypes) {
    #####:  627:  assert(value.getType().isa<TensorType>() && "unexpected non-tensor type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  628:
        -:  629:  // If the `value` is in `fixedTypes`, return the mapped type.
    #####:  630:  const auto &it = fixedTypes.find(value);
call    0 never executed
    #####:  631:  if (it != fixedTypes.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  632:    return it->second;
call    0 never executed
        -:  633:
        -:  634:  // Try querying BufferizableOpInterface.
    #####:  635:  Operation *op = getOwnerOfValue(value);
call    0 never executed
    #####:  636:  auto bufferizableOp = options.dynCastBufferizableOp(op);
call    0 never executed
    #####:  637:  if (bufferizableOp)
branch  0 never executed
branch  1 never executed
    #####:  638:    return bufferizableOp.getBufferType(value, options, fixedTypes);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  639:
        -:  640:  // Op is not bufferizable.
    #####:  641:  if (!options.defaultMemorySpace.has_value())
branch  0 never executed
branch  1 never executed
    #####:  642:    return op->emitError("could not infer memory space");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  643:
    #####:  644:  return getMemRefType(value, options, /*layout=*/{},
    #####:  645:                       *options.defaultMemorySpace);
call    0 never executed
call    1 never executed
        -:  646:}
        -:  647:
function _ZN4mlir13bufferization29replaceOpWithBufferizedValuesERNS_12RewriterBaseEPNS_9OperationENS_10ValueRangeE called 52 returned 100% blocks executed 80%
       52:  648:void bufferization::replaceOpWithBufferizedValues(RewriterBase &rewriter,
        -:  649:                                                  Operation *op,
        -:  650:                                                  ValueRange values) {
      52*:  651:  assert(values.size() == op->getNumResults() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  652:         "expected one value per OpResult");
       52:  653:  OpBuilder::InsertionGuard g(rewriter);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  654:
        -:  655:  // Replace all OpResults with the given values.
      104:  656:  SmallVector<Value> replacements;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      156:  657:  for (OpResult opResult : op->getOpResults()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
       52:  658:    Value replacement = values[opResult.getResultNumber()];
call    0 returned 100%
call    1 returned 100%
       52:  659:    if (opResult.getType().isa<TensorType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  660:      // The OpResult is a tensor. Such values are replaced with memrefs during
        -:  661:      // bufferization.
      52*:  662:      assert((replacement.getType().isa<MemRefType>() ||
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  663:              replacement.getType().isa<UnrankedMemRefType>()) &&
        -:  664:             "tensor op result should be replaced with a memref value");
        -:  665:      // The existing uses of the OpResult still expect a tensor. Insert a
        -:  666:      // ToTensorOp. Throughout bufferization, this ToTensorOp will gradually
        -:  667:      // loose all of its users and eventually DCE away.
       52:  668:      rewriter.setInsertionPointAfter(op);
call    0 returned 100%
       52:  669:      replacement = rewriter.create<bufferization::ToTensorOp>(
       52:  670:          replacement.getLoc(), replacement);
call    0 returned 100%
call    1 returned 100%
        -:  671:    }
       52:  672:    replacements.push_back(replacement);
call    0 returned 100%
        -:  673:  }
        -:  674:
       52:  675:  rewriter.replaceOp(op, replacements);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0%
branch  3 taken 100%
       52:  676:}
        -:  677:
        -:  678://===----------------------------------------------------------------------===//
        -:  679:// Bufferization-specific scoped alloc/dealloc insertion support.
        -:  680://===----------------------------------------------------------------------===//
        -:  681:
        -:  682:/// Create a memref allocation with the given type and dynamic extents.
function _ZNK4mlir13bufferization20BufferizationOptions11createAllocERNS_9OpBuilderENS_8LocationENS_10MemRefTypeENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  683:FailureOr<Value> BufferizationOptions::createAlloc(OpBuilder &b, Location loc,
        -:  684:                                                   MemRefType type,
        -:  685:                                                   ValueRange dynShape) const {
    #####:  686:  if (allocationFn)
branch  0 never executed
branch  1 never executed
    #####:  687:    return (*allocationFn)(b, loc, type, dynShape, bufferAlignment);
branch  0 never executed
branch  1 never executed
        -:  688:
        -:  689:  // Default bufferallocation via AllocOp.
    #####:  690:  if (bufferAlignment != 0)
branch  0 never executed
branch  1 never executed
    #####:  691:    return b
    #####:  692:        .create<memref::AllocOp>(loc, type, dynShape,
    #####:  693:                                 b.getI64IntegerAttr(bufferAlignment))
call    0 never executed
call    1 never executed
    #####:  694:        .getResult();
    #####:  695:  return b.create<memref::AllocOp>(loc, type, dynShape).getResult();
call    0 never executed
        -:  696:}
        -:  697:
        -:  698:/// Creates a memref deallocation. The given memref buffer must have been
        -:  699:/// allocated using `createAlloc`.
function _ZNK4mlir13bufferization20BufferizationOptions13createDeallocERNS_9OpBuilderENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  700:LogicalResult BufferizationOptions::createDealloc(OpBuilder &b, Location loc,
        -:  701:                                                  Value allocatedBuffer) const {
    #####:  702:  if (deallocationFn)
branch  0 never executed
branch  1 never executed
    #####:  703:    return (*deallocationFn)(b, loc, allocatedBuffer);
branch  0 never executed
branch  1 never executed
        -:  704:
        -:  705:  // Default buffer deallocation via DeallocOp.
    #####:  706:  b.create<memref::DeallocOp>(loc, allocatedBuffer);
call    0 never executed
    #####:  707:  return success();
        -:  708:}
        -:  709:
        -:  710:/// Create a memory copy between two memref buffers.
function _ZNK4mlir13bufferization20BufferizationOptions12createMemCpyERNS_9OpBuilderENS_8LocationENS_5ValueES5_ called 0 returned 0% blocks executed 0%
    #####:  711:LogicalResult BufferizationOptions::createMemCpy(OpBuilder &b, Location loc,
        -:  712:                                                 Value from, Value to) const {
    #####:  713:  if (memCpyFn)
branch  0 never executed
branch  1 never executed
    #####:  714:    return (*memCpyFn)(b, loc, from, to);
branch  0 never executed
branch  1 never executed
        -:  715:
    #####:  716:  b.create<memref::CopyOp>(loc, from, to);
call    0 never executed
    #####:  717:  return success();
        -:  718:}
        -:  719:
        -:  720://===----------------------------------------------------------------------===//
        -:  721:// Bufferization-specific BlockAndValueMapping support with debugging.
        -:  722://===----------------------------------------------------------------------===//
        -:  723:
function _ZN4mlir13bufferization18isFunctionArgumentENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  724:bool bufferization::isFunctionArgument(Value value) {
    #####:  725:  auto bbArg = value.dyn_cast<BlockArgument>();
call    0 never executed
    #####:  726:  if (!bbArg)
branch  0 never executed
branch  1 never executed
        -:  727:    return false;
    #####:  728:  return isa<func::FuncOp>(bbArg.getOwner()->getParentOp());
call    0 never executed
call    1 never executed
        -:  729:}
        -:  730:
function _ZN4mlir13bufferization13getMemRefTypeENS_5ValueERKNS0_20BufferizationOptionsENS_25MemRefLayoutAttrInterfaceEj called 0 returned 0% blocks executed 0%
    #####:  731:BaseMemRefType bufferization::getMemRefType(Value value,
        -:  732:                                            const BufferizationOptions &options,
        -:  733:                                            MemRefLayoutAttrInterface layout,
        -:  734:                                            unsigned memorySpace) {
    #####:  735:  auto tensorType = value.getType().cast<TensorType>();
call    0 never executed
    #####:  736:  auto memorySpaceAttr = IntegerAttr::get(
    #####:  737:      IntegerType::get(tensorType.getContext(), 64), memorySpace);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  738:
        -:  739:  // Case 1: Unranked memref type.
    #####:  740:  if (auto unrankedTensorType = tensorType.dyn_cast<UnrankedTensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  741:    assert(!layout && "UnrankedTensorType cannot have a layout map");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  742:    return UnrankedMemRefType::get(unrankedTensorType.getElementType(),
    #####:  743:                                   memorySpaceAttr);
call    0 never executed
call    1 never executed
        -:  744:  }
        -:  745:
        -:  746:  // Case 2: Ranked memref type with specified layout.
    #####:  747:  auto rankedTensorType = tensorType.cast<RankedTensorType>();
call    0 never executed
    #####:  748:  if (layout) {
branch  0 never executed
branch  1 never executed
    #####:  749:    return MemRefType::get(rankedTensorType.getShape(),
        -:  750:                           rankedTensorType.getElementType(), layout,
    #####:  751:                           memorySpaceAttr);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  752:  }
        -:  753:
    #####:  754:  return options.unknownTypeConverterFn(value, memorySpace, options);
branch  0 never executed
branch  1 never executed
        -:  755:}
        -:  756:
        -:  757:BaseMemRefType
function _ZN4mlir13bufferization35getMemRefTypeWithFullyDynamicLayoutENS_10TensorTypeEj called 0 returned 0% blocks executed 0%
    #####:  758:bufferization::getMemRefTypeWithFullyDynamicLayout(TensorType tensorType,
        -:  759:                                                   unsigned memorySpace) {
        -:  760:  // Case 1: Unranked memref type.
    #####:  761:  if (auto unrankedTensorType = tensorType.dyn_cast<UnrankedTensorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  762:    return UnrankedMemRefType::get(unrankedTensorType.getElementType(),
    #####:  763:                                   memorySpace);
call    0 never executed
call    1 never executed
        -:  764:  }
        -:  765:
        -:  766:  // Case 2: Ranked memref type.
    #####:  767:  auto memorySpaceAttr = IntegerAttr::get(
    #####:  768:      IntegerType::get(tensorType.getContext(), 64), memorySpace);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  769:  auto rankedTensorType = tensorType.cast<RankedTensorType>();
call    0 never executed
    #####:  770:  int64_t dynamicOffset = ShapedType::kDynamicStrideOrOffset;
    #####:  771:  SmallVector<int64_t> dynamicStrides(rankedTensorType.getRank(),
call    0 never executed
    #####:  772:                                      ShapedType::kDynamicStrideOrOffset);
call    0 never executed
    #####:  773:  auto stridedLayout = StridedLayoutAttr::get(tensorType.getContext(),
call    0 never executed
    #####:  774:                                              dynamicOffset, dynamicStrides);
call    0 never executed
call    1 never executed
    #####:  775:  return MemRefType::get(rankedTensorType.getShape(),
call    0 never executed
        -:  776:                         rankedTensorType.getElementType(), stridedLayout,
    #####:  777:                         memorySpaceAttr);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  778:}
        -:  779:
        -:  780:/// Return a MemRef type with a static identity layout (i.e., no layout map). If
        -:  781:/// the given tensor type is unranked, return an unranked MemRef type.
        -:  782:BaseMemRefType
function _ZN4mlir13bufferization37getMemRefTypeWithStaticIdentityLayoutENS_10TensorTypeEj called 5446 returned 100% blocks executed 80%
     5446:  783:bufferization::getMemRefTypeWithStaticIdentityLayout(TensorType tensorType,
        -:  784:                                                     unsigned memorySpace) {
        -:  785:  // Case 1: Unranked memref type.
     5446:  786:  if (auto unrankedTensorType = tensorType.dyn_cast<UnrankedTensorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  787:    return UnrankedMemRefType::get(unrankedTensorType.getElementType(),
    #####:  788:                                   memorySpace);
call    0 never executed
call    1 never executed
        -:  789:  }
        -:  790:
        -:  791:  // Case 2: Ranked memref type.
     5446:  792:  auto rankedTensorType = tensorType.cast<RankedTensorType>();
call    0 returned 100%
     5446:  793:  auto memorySpaceAttr = IntegerAttr::get(
     5446:  794:      IntegerType::get(tensorType.getContext(), 64), memorySpace);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     5446:  795:  MemRefLayoutAttrInterface layout = {};
call    0 returned 100%
    10892:  796:  return MemRefType::get(rankedTensorType.getShape(),
        -:  797:                         rankedTensorType.getElementType(), layout,
     5446:  798:                         memorySpaceAttr);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  799:}
        -:  800:
function _ZN4mlir13bufferization6detail25defaultIsRepetitiveRegionENS0_23BufferizableOpInterfaceEj called 4508 returned 100% blocks executed 67%
     4508:  801:bool bufferization::detail::defaultIsRepetitiveRegion(
        -:  802:    BufferizableOpInterface bufferizableOp, unsigned index) {
    4508*:  803:  assert(index < bufferizableOp->getNumRegions() && "invalid region index");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     4508:  804:  auto regionInterface =
     4508:  805:      dyn_cast<RegionBranchOpInterface>(bufferizableOp.getOperation());
call    0 returned 100%
     4508:  806:  if (!regionInterface)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  807:    return false;
    #####:  808:  return regionInterface.isRepetitiveRegion(index);
call    0 never executed
        -:  809:}
