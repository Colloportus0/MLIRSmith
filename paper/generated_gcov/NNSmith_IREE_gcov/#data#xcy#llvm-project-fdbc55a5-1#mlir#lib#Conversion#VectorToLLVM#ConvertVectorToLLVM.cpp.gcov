        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Conversion/VectorToLLVM/ConvertVectorToLLVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/VectorToLLVM/CMakeFiles/obj.MLIRVectorToLLVM.dir/ConvertVectorToLLVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/VectorToLLVM/CMakeFiles/obj.MLIRVectorToLLVM.dir/ConvertVectorToLLVM.cpp.gcda
        -:    0:Runs:325560
        -:    1://===- VectorToLLVM.cpp - Conversion from Vector to the LLVM dialect ------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/VectorToLLVM/ConvertVectorToLLVM.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/VectorPattern.h"
        -:   12:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   13:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   14:#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
        -:   15:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   16:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   17:#include "mlir/Dialect/Vector/Transforms/VectorTransforms.h"
        -:   18:#include "mlir/IR/BuiltinTypes.h"
        -:   19:#include "mlir/IR/TypeUtilities.h"
        -:   20:#include "mlir/Support/MathExtras.h"
        -:   21:#include "mlir/Target/LLVMIR/TypeToLLVM.h"
        -:   22:#include "mlir/Transforms/DialectConversion.h"
        -:   23:
        -:   24:using namespace mlir;
        -:   25:using namespace mlir::vector;
        -:   26:
        -:   27:// Helper to reduce vector type by one rank at front.
function _ZL22reducedVectorTypeFrontN4mlir10VectorTypeE called 0 returned 0% blocks executed 0%
    #####:   28:static VectorType reducedVectorTypeFront(VectorType tp) {
    #####:   29:  assert((tp.getRank() > 1) && "unlowerable vector type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   30:  unsigned numScalableDims = tp.getNumScalableDims();
call    0 never executed
    #####:   31:  if (tp.getShape().size() == numScalableDims)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   32:    --numScalableDims;
    #####:   33:  return VectorType::get(tp.getShape().drop_front(), tp.getElementType(),
call    0 never executed
    #####:   34:                         numScalableDims);
call    0 never executed
call    1 never executed
call    2 never executed
        -:   35:}
        -:   36:
        -:   37:// Helper to reduce vector type by *all* but one rank at back.
function _ZL21reducedVectorTypeBackN4mlir10VectorTypeE called 0 returned 0% blocks executed 0%
    #####:   38:static VectorType reducedVectorTypeBack(VectorType tp) {
    #####:   39:  assert((tp.getRank() > 1) && "unlowerable vector type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   40:  unsigned numScalableDims = tp.getNumScalableDims();
call    0 never executed
    #####:   41:  if (numScalableDims > 0)
branch  0 never executed
branch  1 never executed
    #####:   42:    --numScalableDims;
    #####:   43:  return VectorType::get(tp.getShape().take_back(), tp.getElementType(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   44:                         numScalableDims);
call    0 never executed
call    1 never executed
        -:   45:}
        -:   46:
        -:   47:// Helper that picks the proper sequence for inserting.
function _ZL9insertOneRN4mlir25ConversionPatternRewriterERNS_17LLVMTypeConverterENS_8LocationENS_5ValueES5_NS_4TypeEll called 0 returned 0% blocks executed 0%
    #####:   48:static Value insertOne(ConversionPatternRewriter &rewriter,
        -:   49:                       LLVMTypeConverter &typeConverter, Location loc,
        -:   50:                       Value val1, Value val2, Type llvmType, int64_t rank,
        -:   51:                       int64_t pos) {
    #####:   52:  assert(rank > 0 && "0-D vector corner case should have been handled already");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   53:  if (rank == 1) {
branch  0 never executed
branch  1 never executed
    #####:   54:    auto idxType = rewriter.getIndexType();
call    0 never executed
    #####:   55:    auto constant = rewriter.create<LLVM::ConstantOp>(
    #####:   56:        loc, typeConverter.convertType(idxType),
call    0 never executed
    #####:   57:        rewriter.getIntegerAttr(idxType, pos));
call    0 never executed
call    1 never executed
    #####:   58:    return rewriter.create<LLVM::InsertElementOp>(loc, llvmType, val1, val2,
    #####:   59:                                                  constant);
call    0 never executed
        -:   60:  }
    #####:   61:  return rewriter.create<LLVM::InsertValueOp>(loc, val1, val2, pos);
call    0 never executed
        -:   62:}
        -:   63:
        -:   64:// Helper that picks the proper sequence for extracting.
function _ZL10extractOneRN4mlir25ConversionPatternRewriterERNS_17LLVMTypeConverterENS_8LocationENS_5ValueENS_4TypeEll called 0 returned 0% blocks executed 0%
    #####:   65:static Value extractOne(ConversionPatternRewriter &rewriter,
        -:   66:                        LLVMTypeConverter &typeConverter, Location loc,
        -:   67:                        Value val, Type llvmType, int64_t rank, int64_t pos) {
    #####:   68:  if (rank <= 1) {
branch  0 never executed
branch  1 never executed
    #####:   69:    auto idxType = rewriter.getIndexType();
call    0 never executed
    #####:   70:    auto constant = rewriter.create<LLVM::ConstantOp>(
    #####:   71:        loc, typeConverter.convertType(idxType),
call    0 never executed
    #####:   72:        rewriter.getIntegerAttr(idxType, pos));
call    0 never executed
call    1 never executed
    #####:   73:    return rewriter.create<LLVM::ExtractElementOp>(loc, llvmType, val,
    #####:   74:                                                   constant);
call    0 never executed
        -:   75:  }
    #####:   76:  return rewriter.create<LLVM::ExtractValueOp>(loc, val, pos);
call    0 never executed
        -:   77:}
        -:   78:
        -:   79:// Helper that returns data layout alignment of a memref.
function _Z18getMemRefAlignmentRN4mlir17LLVMTypeConverterENS_10MemRefTypeERj called 0 returned 0% blocks executed 0%
    #####:   80:LogicalResult getMemRefAlignment(LLVMTypeConverter &typeConverter,
        -:   81:                                 MemRefType memrefType, unsigned &align) {
    #####:   82:  Type elementTy = typeConverter.convertType(memrefType.getElementType());
call    0 never executed
call    1 never executed
    #####:   83:  if (!elementTy)
branch  0 never executed
branch  1 never executed
    #####:   84:    return failure();
        -:   85:
        -:   86:  // TODO: this should use the MLIR data layout when it becomes available and
        -:   87:  // stop depending on translation.
    #####:   88:  llvm::LLVMContext llvmContext;
call    0 never executed
call    1 never executed
    #####:   89:  align = LLVM::TypeToLLVMIRTranslator(llvmContext)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   90:              .getPreferredAlignment(elementTy, typeConverter.getDataLayout());
call    0 never executed
    #####:   91:  return success();
call    0 never executed
        -:   92:}
        -:   93:
        -:   94:// Check if the last stride is non-unit or the memory space is not zero.
function _ZL21isMemRefTypeSupportedN4mlir10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:   95:static LogicalResult isMemRefTypeSupported(MemRefType memRefType) {
    #####:   96:  int64_t offset;
    #####:   97:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:   98:  auto successStrides = getStridesAndOffset(memRefType, strides, offset);
call    0 never executed
    #####:   99:  if (failed(successStrides) || strides.back() != 1 ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  100:      memRefType.getMemorySpaceAsInt() != 0)
call    0 never executed
    #####:  101:    return failure();
    #####:  102:  return success();
branch  0 never executed
branch  1 never executed
        -:  103:}
        -:  104:
        -:  105:// Add an index vector component to a base pointer.
function _ZL14getIndexedPtrsRN4mlir25ConversionPatternRewriterENS_8LocationENS_10MemRefTypeENS_5ValueES4_S4_m called 0 returned 0% blocks executed 0%
    #####:  106:static Value getIndexedPtrs(ConversionPatternRewriter &rewriter, Location loc,
        -:  107:                            MemRefType memRefType, Value llvmMemref, Value base,
        -:  108:                            Value index, uint64_t vLen) {
    #####:  109:  assert(succeeded(isMemRefTypeSupported(memRefType)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  110:         "unsupported memref type");
    #####:  111:  auto pType = MemRefDescriptor(llvmMemref).getElementPtrType();
call    0 never executed
call    1 never executed
    #####:  112:  auto ptrsType = LLVM::getFixedVectorType(pType, vLen);
call    0 never executed
    #####:  113:  return rewriter.create<LLVM::GEPOp>(loc, ptrsType, base, index);
call    0 never executed
        -:  114:}
        -:  115:
        -:  116:// Casts a strided element pointer to a vector pointer.  The vector pointer
        -:  117:// will be in the same address space as the incoming memref type.
function _ZL11castDataPtrRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueENS_10MemRefTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  118:static Value castDataPtr(ConversionPatternRewriter &rewriter, Location loc,
        -:  119:                         Value ptr, MemRefType memRefType, Type vt) {
    #####:  120:  auto pType = LLVM::LLVMPointerType::get(vt, memRefType.getMemorySpaceAsInt());
call    0 never executed
call    1 never executed
    #####:  121:  return rewriter.create<LLVM::BitcastOp>(loc, pType, ptr);
call    0 never executed
        -:  122:}
        -:  123:
        -:  124:namespace {
        -:  125:
        -:  126:/// Trivial Vector to LLVM conversions
        -:  127:using VectorScaleOpConversion =
        -:  128:    OneToOneConvertToLLVMPattern<vector::VectorScaleOp, LLVM::vscale>;
        -:  129:
        -:  130:/// Conversion pattern for a vector.bitcast.
        -:  131:class VectorBitCastOpConversion
        -:  132:    : public ConvertOpToLLVMPattern<vector::BitCastOp> {
        -:  133:public:
     1773:  134:  using ConvertOpToLLVMPattern<vector::BitCastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  135:
        -:  136:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorBitCastOpConversion15matchAndRewriteEN4mlir6vector9BitCastOpENS2_16BitCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  137:  matchAndRewrite(vector::BitCastOp bitCastOp, OpAdaptor adaptor,
        -:  138:                  ConversionPatternRewriter &rewriter) const override {
        -:  139:    // Only 0-D and 1-D vectors can be lowered to LLVM.
    #####:  140:    VectorType resultTy = bitCastOp.getResultVectorType();
call    0 never executed
    #####:  141:    if (resultTy.getRank() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  142:      return failure();
    #####:  143:    Type newResultTy = typeConverter->convertType(resultTy);
call    0 never executed
    #####:  144:    rewriter.replaceOpWithNewOp<LLVM::BitcastOp>(bitCastOp, newResultTy,
    #####:  145:                                                 adaptor.getOperands()[0]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  146:    return success();
        -:  147:  }
        -:  148:};
        -:  149:
        -:  150:/// Conversion pattern for a vector.matrix_multiply.
        -:  151:/// This is lowered directly to the proper llvm.intr.matrix.multiply.
        -:  152:class VectorMatmulOpConversion
        -:  153:    : public ConvertOpToLLVMPattern<vector::MatmulOp> {
        -:  154:public:
     1752:  155:  using ConvertOpToLLVMPattern<vector::MatmulOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  156:
        -:  157:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorMatmulOpConversion15matchAndRewriteEN4mlir6vector8MatmulOpENS2_15MatmulOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  158:  matchAndRewrite(vector::MatmulOp matmulOp, OpAdaptor adaptor,
        -:  159:                  ConversionPatternRewriter &rewriter) const override {
    #####:  160:    rewriter.replaceOpWithNewOp<LLVM::MatrixMultiplyOp>(
    #####:  161:        matmulOp, typeConverter->convertType(matmulOp.getRes().getType()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  162:        adaptor.getLhs(), adaptor.getRhs(), matmulOp.getLhsRows(),
call    0 never executed
call    1 never executed
    #####:  163:        matmulOp.getLhsColumns(), matmulOp.getRhsColumns());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  164:    return success();
        -:  165:  }
        -:  166:};
        -:  167:
        -:  168:/// Conversion pattern for a vector.flat_transpose.
        -:  169:/// This is lowered directly to the proper llvm.intr.matrix.transpose.
        -:  170:class VectorFlatTransposeOpConversion
        -:  171:    : public ConvertOpToLLVMPattern<vector::FlatTransposeOp> {
        -:  172:public:
     1752:  173:  using ConvertOpToLLVMPattern<vector::FlatTransposeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  174:
        -:  175:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorFlatTransposeOpConversion15matchAndRewriteEN4mlir6vector15FlatTransposeOpENS2_22FlatTransposeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  176:  matchAndRewrite(vector::FlatTransposeOp transOp, OpAdaptor adaptor,
        -:  177:                  ConversionPatternRewriter &rewriter) const override {
    #####:  178:    rewriter.replaceOpWithNewOp<LLVM::MatrixTransposeOp>(
    #####:  179:        transOp, typeConverter->convertType(transOp.getRes().getType()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  180:        adaptor.getMatrix(), transOp.getRows(), transOp.getColumns());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  181:    return success();
        -:  182:  }
        -:  183:};
        -:  184:
        -:  185:/// Overloaded utility that replaces a vector.load, vector.store,
        -:  186:/// vector.maskedload and vector.maskedstore with their respective LLVM
        -:  187:/// couterparts.
    #####:  188:static void replaceLoadOrStoreOp(vector::LoadOp loadOp,
        -:  189:                                 vector::LoadOpAdaptor adaptor,
        -:  190:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  191:                                 ConversionPatternRewriter &rewriter) {
    #####:  192:  rewriter.replaceOpWithNewOp<LLVM::LoadOp>(loadOp, ptr, align);
        -:  193:}
        -:  194:
function _ZN12_GLOBAL__N_1L20replaceLoadOrStoreOpEN4mlir6vector12MaskedLoadOpENS1_19MaskedLoadOpAdaptorENS0_10VectorTypeENS0_5ValueEjRNS0_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  195:static void replaceLoadOrStoreOp(vector::MaskedLoadOp loadOp,
        -:  196:                                 vector::MaskedLoadOpAdaptor adaptor,
        -:  197:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  198:                                 ConversionPatternRewriter &rewriter) {
    #####:  199:  rewriter.replaceOpWithNewOp<LLVM::MaskedLoadOp>(
    #####:  200:      loadOp, vectorTy, ptr, adaptor.getMask(), adaptor.getPassThru(), align);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  201:}
        -:  202:
    #####:  203:static void replaceLoadOrStoreOp(vector::StoreOp storeOp,
        -:  204:                                 vector::StoreOpAdaptor adaptor,
        -:  205:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  206:                                 ConversionPatternRewriter &rewriter) {
    #####:  207:  rewriter.replaceOpWithNewOp<LLVM::StoreOp>(storeOp, adaptor.getValueToStore(),
    #####:  208:                                             ptr, align);
call    0 never executed
        -:  209:}
        -:  210:
        -:  211:static void replaceLoadOrStoreOp(vector::MaskedStoreOp storeOp,
        -:  212:                                 vector::MaskedStoreOpAdaptor adaptor,
        -:  213:                                 VectorType vectorTy, Value ptr, unsigned align,
        -:  214:                                 ConversionPatternRewriter &rewriter) {
        -:  215:  rewriter.replaceOpWithNewOp<LLVM::MaskedStoreOp>(
        -:  216:      storeOp, adaptor.getValueToStore(), ptr, adaptor.getMask(), align);
        -:  217:}
        -:  218:
        -:  219:/// Conversion pattern for a vector.load, vector.store, vector.maskedload, and
        -:  220:/// vector.maskedstore.
        -:  221:template <class LoadOrStoreOp, class LoadOrStoreOpAdaptor>
        -:  222:class VectorLoadStoreConversion : public ConvertOpToLLVMPattern<LoadOrStoreOp> {
        -:  223:public:
     7092:  224:  using ConvertOpToLLVMPattern<LoadOrStoreOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  225:
        -:  226:  LogicalResult
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
    #####:  232:    if (vectorTy.getRank() > 1)
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
    #####:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector6LoadOpENS2_13LoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector6LoadOpENS2_13LoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 never executed
call    1 never executed
    #####:  232:    if (vectorTy.getRank() > 1)
branch  0 never executed
branch  1 never executed
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 never executed
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 never executed
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 never executed
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 never executed
    #####:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector12MaskedLoadOpENS2_19MaskedLoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector12MaskedLoadOpENS2_19MaskedLoadOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 never executed
call    1 never executed
    #####:  232:    if (vectorTy.getRank() > 1)
branch  0 never executed
branch  1 never executed
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 never executed
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 never executed
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 never executed
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 never executed
    #####:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector7StoreOpENS2_14StoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector7StoreOpENS2_14StoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 never executed
call    1 never executed
    #####:  232:    if (vectorTy.getRank() > 1)
branch  0 never executed
branch  1 never executed
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 never executed
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 never executed
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 never executed
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 never executed
    #####:  251:    return success();
        -:  252:  }
------------------
_ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector13MaskedStoreOpENS2_20MaskedStoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_125VectorLoadStoreConversionIN4mlir6vector13MaskedStoreOpENS2_20MaskedStoreOpAdaptorEE15matchAndRewriteES3_S4_RNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  227:  matchAndRewrite(LoadOrStoreOp loadOrStoreOp,
        -:  228:                  typename LoadOrStoreOp::Adaptor adaptor,
        -:  229:                  ConversionPatternRewriter &rewriter) const override {
        -:  230:    // Only 1-D vectors can be lowered to LLVM.
    #####:  231:    VectorType vectorTy = loadOrStoreOp.getVectorType();
call    0 never executed
call    1 never executed
    #####:  232:    if (vectorTy.getRank() > 1)
branch  0 never executed
branch  1 never executed
    #####:  233:      return failure();
        -:  234:
    #####:  235:    auto loc = loadOrStoreOp->getLoc();
call    0 never executed
    #####:  236:    MemRefType memRefTy = loadOrStoreOp.getMemRefType();
call    0 never executed
        -:  237:
        -:  238:    // Resolve alignment.
        -:  239:    unsigned align;
    #####:  240:    if (failed(getMemRefAlignment(*this->getTypeConverter(), memRefTy, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  241:      return failure();
        -:  242:
        -:  243:    // Resolve address.
    #####:  244:    auto vtype = this->typeConverter->convertType(loadOrStoreOp.getVectorType())
    #####:  245:                     .template cast<VectorType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  246:    Value dataPtr = this->getStridedElementPtr(loc, memRefTy, adaptor.getBase(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  247:                                               adaptor.getIndices(), rewriter);
    #####:  248:    Value ptr = castDataPtr(rewriter, loc, dataPtr, memRefTy, vtype);
call    0 never executed
        -:  249:
    #####:  250:    replaceLoadOrStoreOp(loadOrStoreOp, adaptor, vtype, ptr, align, rewriter);
call    0 never executed
    #####:  251:    return success();
        -:  252:  }
------------------
        -:  253:};
        -:  254:
        -:  255:/// Conversion pattern for a vector.gather.
        -:  256:class VectorGatherOpConversion
        -:  257:    : public ConvertOpToLLVMPattern<vector::GatherOp> {
        -:  258:public:
     1773:  259:  using ConvertOpToLLVMPattern<vector::GatherOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  260:
        -:  261:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorGatherOpConversion15matchAndRewriteEN4mlir6vector8GatherOpENS2_15GatherOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  262:  matchAndRewrite(vector::GatherOp gather, OpAdaptor adaptor,
        -:  263:                  ConversionPatternRewriter &rewriter) const override {
    #####:  264:    MemRefType memRefType = gather.getBaseType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  265:    assert(memRefType && "The base should be bufferized");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  266:
    #####:  267:    if (failed(isMemRefTypeSupported(memRefType)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  268:      return failure();
        -:  269:
    #####:  270:    auto loc = gather->getLoc();
call    0 never executed
        -:  271:
        -:  272:    // Resolve alignment.
    #####:  273:    unsigned align;
    #####:  274:    if (failed(getMemRefAlignment(*getTypeConverter(), memRefType, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  275:      return failure();
        -:  276:
    #####:  277:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  278:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  279:    Value base = adaptor.getBase();
call    0 never executed
        -:  280:
    #####:  281:    auto llvmNDVectorTy = adaptor.getIndexVec().getType();
call    0 never executed
call    1 never executed
        -:  282:    // Handle the simple case of 1-D vector.
    #####:  283:    if (!llvmNDVectorTy.isa<LLVM::LLVMArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  284:      auto vType = gather.getVectorType();
call    0 never executed
        -:  285:      // Resolve address.
    #####:  286:      Value ptrs = getIndexedPtrs(rewriter, loc, memRefType, base, ptr,
        -:  287:                                  adaptor.getIndexVec(),
    #####:  288:                                  /*vLen=*/vType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  289:      // Replace with the gather intrinsic.
    #####:  290:      rewriter.replaceOpWithNewOp<LLVM::masked_gather>(
    #####:  291:          gather, typeConverter->convertType(vType), ptrs, adaptor.getMask(),
call    0 never executed
call    1 never executed
    #####:  292:          adaptor.getPassThru(), rewriter.getI32IntegerAttr(align));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  293:      return success();
        -:  294:    }
        -:  295:
function _ZZNK12_GLOBAL__N_124VectorGatherOpConversion15matchAndRewriteEN4mlir6vector8GatherOpENS2_15GatherOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_4TypeENS1_10ValueRangeEE_clES7_S8_ called 0 returned 0% blocks executed 0%
    #####:  296:    auto callback = [align, memRefType, base, ptr, loc, &rewriter](
    #####:  297:                        Type llvm1DVectorTy, ValueRange vectorOperands) {
        -:  298:      // Resolve address.
    #####:  299:      Value ptrs = getIndexedPtrs(
        -:  300:          rewriter, loc, memRefType, base, ptr, /*index=*/vectorOperands[0],
    #####:  301:          LLVM::getVectorNumElements(llvm1DVectorTy).getFixedValue());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  302:      // Create the gather intrinsic.
    #####:  303:      return rewriter.create<LLVM::masked_gather>(
    #####:  304:          loc, llvm1DVectorTy, ptrs, /*mask=*/vectorOperands[1],
call    0 never executed
    #####:  305:          /*passThru=*/vectorOperands[2], rewriter.getI32IntegerAttr(align));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  306:    };
    #####:  307:    SmallVector<Value> vectorOperands = {
    #####:  308:        adaptor.getIndexVec(), adaptor.getMask(), adaptor.getPassThru()};
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  309:    return LLVM::detail::handleMultidimensionalVectors(
call    0 never executed
    #####:  310:        gather, vectorOperands, *getTypeConverter(), callback, rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  311:  }
        -:  312:};
        -:  313:
        -:  314:/// Conversion pattern for a vector.scatter.
        -:  315:class VectorScatterOpConversion
        -:  316:    : public ConvertOpToLLVMPattern<vector::ScatterOp> {
        -:  317:public:
     1773:  318:  using ConvertOpToLLVMPattern<vector::ScatterOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  319:
        -:  320:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorScatterOpConversion15matchAndRewriteEN4mlir6vector9ScatterOpENS2_16ScatterOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  321:  matchAndRewrite(vector::ScatterOp scatter, OpAdaptor adaptor,
        -:  322:                  ConversionPatternRewriter &rewriter) const override {
    #####:  323:    auto loc = scatter->getLoc();
call    0 never executed
    #####:  324:    MemRefType memRefType = scatter.getMemRefType();
call    0 never executed
        -:  325:
    #####:  326:    if (failed(isMemRefTypeSupported(memRefType)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:      return failure();
        -:  328:
        -:  329:    // Resolve alignment.
    #####:  330:    unsigned align;
    #####:  331:    if (failed(getMemRefAlignment(*getTypeConverter(), memRefType, align)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  332:      return failure();
        -:  333:
        -:  334:    // Resolve address.
    #####:  335:    VectorType vType = scatter.getVectorType();
call    0 never executed
    #####:  336:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  337:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  338:    Value ptrs =
        -:  339:        getIndexedPtrs(rewriter, loc, memRefType, adaptor.getBase(), ptr,
    #####:  340:                       adaptor.getIndexVec(), /*vLen=*/vType.getDimSize(0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  341:
        -:  342:    // Replace with the scatter intrinsic.
    #####:  343:    rewriter.replaceOpWithNewOp<LLVM::masked_scatter>(
    #####:  344:        scatter, adaptor.getValueToStore(), ptrs, adaptor.getMask(),
call    0 never executed
call    1 never executed
    #####:  345:        rewriter.getI32IntegerAttr(align));
call    0 never executed
call    1 never executed
    #####:  346:    return success();
        -:  347:  }
        -:  348:};
        -:  349:
        -:  350:/// Conversion pattern for a vector.expandload.
        -:  351:class VectorExpandLoadOpConversion
        -:  352:    : public ConvertOpToLLVMPattern<vector::ExpandLoadOp> {
        -:  353:public:
     1773:  354:  using ConvertOpToLLVMPattern<vector::ExpandLoadOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  355:
        -:  356:  LogicalResult
function _ZNK12_GLOBAL__N_128VectorExpandLoadOpConversion15matchAndRewriteEN4mlir6vector12ExpandLoadOpENS2_19ExpandLoadOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  357:  matchAndRewrite(vector::ExpandLoadOp expand, OpAdaptor adaptor,
        -:  358:                  ConversionPatternRewriter &rewriter) const override {
    #####:  359:    auto loc = expand->getLoc();
call    0 never executed
    #####:  360:    MemRefType memRefType = expand.getMemRefType();
call    0 never executed
        -:  361:
        -:  362:    // Resolve address.
    #####:  363:    auto vtype = typeConverter->convertType(expand.getVectorType());
call    0 never executed
call    1 never executed
    #####:  364:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  365:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  366:
    #####:  367:    rewriter.replaceOpWithNewOp<LLVM::masked_expandload>(
    #####:  368:        expand, vtype, ptr, adaptor.getMask(), adaptor.getPassThru());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  369:    return success();
        -:  370:  }
        -:  371:};
        -:  372:
        -:  373:/// Conversion pattern for a vector.compressstore.
        -:  374:class VectorCompressStoreOpConversion
        -:  375:    : public ConvertOpToLLVMPattern<vector::CompressStoreOp> {
        -:  376:public:
     1773:  377:  using ConvertOpToLLVMPattern<vector::CompressStoreOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  378:
        -:  379:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorCompressStoreOpConversion15matchAndRewriteEN4mlir6vector15CompressStoreOpENS2_22CompressStoreOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  380:  matchAndRewrite(vector::CompressStoreOp compress, OpAdaptor adaptor,
        -:  381:                  ConversionPatternRewriter &rewriter) const override {
    #####:  382:    auto loc = compress->getLoc();
call    0 never executed
    #####:  383:    MemRefType memRefType = compress.getMemRefType();
call    0 never executed
        -:  384:
        -:  385:    // Resolve address.
    #####:  386:    Value ptr = getStridedElementPtr(loc, memRefType, adaptor.getBase(),
    #####:  387:                                     adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  388:
    #####:  389:    rewriter.replaceOpWithNewOp<LLVM::masked_compressstore>(
    #####:  390:        compress, adaptor.getValueToStore(), ptr, adaptor.getMask());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  391:    return success();
        -:  392:  }
        -:  393:};
        -:  394:
        -:  395:/// Helper method to lower a `vector.reduction` op that performs an arithmetic
        -:  396:/// operation like add,mul, etc.. `VectorOp` is the LLVM vector intrinsic to use
        -:  397:/// and `ScalarOp` is the scalar operation used to add the accumulation value if
        -:  398:/// non-null.
        -:  399:template <class VectorOp, class ScalarOp>
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
    #####:  404:  if (accumulator)
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
    #####:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_xorENS2_5XOrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_xorENS2_5XOrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  404:  if (accumulator)
branch  0 never executed
branch  1 never executed
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
    #####:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM16vector_reduce_orENS2_4OrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM16vector_reduce_orENS2_4OrOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  404:  if (accumulator)
branch  0 never executed
branch  1 never executed
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
    #####:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_andENS2_5AndOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_andENS2_5AndOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  404:  if (accumulator)
branch  0 never executed
branch  1 never executed
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
    #####:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_mulENS2_5MulOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_mulENS2_5MulOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  404:  if (accumulator)
branch  0 never executed
branch  1 never executed
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
    #####:  406:  return result;
        -:  407:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_addENS2_5AddOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_:
function _ZN12_GLOBAL__N_1L42createIntegerReductionArithmeticOpLoweringIN4mlir4LLVM17vector_reduce_addENS2_5AddOpEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  400:static Value createIntegerReductionArithmeticOpLowering(
        -:  401:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  402:    Value vectorOperand, Value accumulator) {
    #####:  403:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  404:  if (accumulator)
branch  0 never executed
branch  1 never executed
    #####:  405:    result = rewriter.create<ScalarOp>(loc, accumulator, result);
call    0 never executed
    #####:  406:  return result;
        -:  407:}
------------------
        -:  408:
        -:  409:/// Helper method to lower a `vector.reduction` operation that performs
        -:  410:/// a comparison operation like `min`/`max`. `VectorOp` is the LLVM vector
        -:  411:/// intrinsic to use and `predicate` is the predicate to use to compare+combine
        -:  412:/// the accumulator value if non-null.
        -:  413:template <class VectorOp>
    #####:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
    #####:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
    #####:  418:  if (accumulator) {
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
        -:  422:  }
    #####:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_smaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_smaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 0 returned 0% blocks executed 0%
    #####:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
    #####:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:  if (accumulator) {
branch  0 never executed
branch  1 never executed
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
    #####:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_umaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_umaxEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 0 returned 0% blocks executed 0%
    #####:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
    #####:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:  if (accumulator) {
branch  0 never executed
branch  1 never executed
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
    #####:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_sminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_sminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 0 returned 0% blocks executed 0%
    #####:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
    #####:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:  if (accumulator) {
branch  0 never executed
branch  1 never executed
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
    #####:  423:  return result;
        -:  424:}
------------------
_ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_uminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE:
function _ZN12_GLOBAL__N_1L42createIntegerReductionComparisonOpLoweringIN4mlir4LLVM18vector_reduce_uminEEENS1_5ValueERNS1_25ConversionPatternRewriterENS1_8LocationENS1_4TypeES4_S4_NS2_13ICmpPredicateE called 0 returned 0% blocks executed 0%
    #####:  414:static Value createIntegerReductionComparisonOpLowering(
        -:  415:    ConversionPatternRewriter &rewriter, Location loc, Type llvmType,
        -:  416:    Value vectorOperand, Value accumulator, LLVM::ICmpPredicate predicate) {
    #####:  417:  Value result = rewriter.create<VectorOp>(loc, llvmType, vectorOperand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  418:  if (accumulator) {
branch  0 never executed
branch  1 never executed
    #####:  419:    Value cmp =
    #####:  420:        rewriter.create<LLVM::ICmpOp>(loc, predicate, accumulator, result);
call    0 never executed
call    1 never executed
    #####:  421:    result = rewriter.create<LLVM::SelectOp>(loc, cmp, accumulator, result);
call    0 never executed
        -:  422:  }
    #####:  423:  return result;
        -:  424:}
------------------
        -:  425:
        -:  426:/// Create lowering of minf/maxf op. We cannot use llvm.maximum/llvm.minimum
        -:  427:/// with vector types.
function _ZN12_GLOBAL__N_1L13createMinMaxFERN4mlir9OpBuilderENS0_8LocationENS0_5ValueES4_b called 0 returned 0% blocks executed 0%
    #####:  428:static Value createMinMaxF(OpBuilder &builder, Location loc, Value lhs,
        -:  429:                           Value rhs, bool isMin) {
    #####:  430:  auto floatType = getElementTypeOrSelf(lhs.getType()).cast<FloatType>();
call    0 never executed
call    1 never executed
    #####:  431:  Type i1Type = builder.getI1Type();
call    0 never executed
    #####:  432:  if (auto vecType = lhs.getType().dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  433:    i1Type = VectorType::get(vecType.getShape(), i1Type);
call    0 never executed
call    1 never executed
    #####:  434:  Value cmp = builder.create<LLVM::FCmpOp>(
    #####:  435:      loc, i1Type, isMin ? LLVM::FCmpPredicate::olt : LLVM::FCmpPredicate::ogt,
branch  0 never executed
branch  1 never executed
    #####:  436:      lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  437:  Value sel = builder.create<LLVM::SelectOp>(loc, cmp, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  438:  Value isNan = builder.create<LLVM::FCmpOp>(
    #####:  439:      loc, i1Type, LLVM::FCmpPredicate::uno, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:  440:  Value nan = builder.create<LLVM::ConstantOp>(
    #####:  441:      loc, lhs.getType(),
call    0 never executed
    #####:  442:      builder.getFloatAttr(floatType,
call    0 never executed
    #####:  443:                           APFloat::getQNaN(floatType.getFloatSemantics())));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  444:  return builder.create<LLVM::SelectOp>(loc, isNan, nan, sel);
call    0 never executed
        -:  445:}
        -:  446:
        -:  447:/// Conversion pattern for all vector reductions.
        -:  448:class VectorReductionOpConversion
        -:  449:    : public ConvertOpToLLVMPattern<vector::ReductionOp> {
        -:  450:public:
        -:  451:  explicit VectorReductionOpConversion(LLVMTypeConverter &typeConv,
        -:  452:                                       bool reassociateFPRed)
        -:  453:      : ConvertOpToLLVMPattern<vector::ReductionOp>(typeConv),
        -:  454:        reassociateFPReductions(reassociateFPRed) {}
        -:  455:
        -:  456:  LogicalResult
function _ZNK12_GLOBAL__N_127VectorReductionOpConversion15matchAndRewriteEN4mlir6vector11ReductionOpENS2_18ReductionOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  457:  matchAndRewrite(vector::ReductionOp reductionOp, OpAdaptor adaptor,
        -:  458:                  ConversionPatternRewriter &rewriter) const override {
    #####:  459:    auto kind = reductionOp.getKind();
call    0 never executed
    #####:  460:    Type eltType = reductionOp.getDest().getType();
call    0 never executed
call    1 never executed
    #####:  461:    Type llvmType = typeConverter->convertType(eltType);
call    0 never executed
    #####:  462:    Value operand = adaptor.getVector();
call    0 never executed
    #####:  463:    Value acc = adaptor.getAcc();
call    0 never executed
    #####:  464:    Location loc = reductionOp.getLoc();
call    0 never executed
    #####:  465:    if (eltType.isIntOrIndex()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  466:      // Integer reductions: add/mul/min/max/and/or/xor.
    #####:  467:      Value result;
    #####:  468:      switch (kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  469:      case vector::CombiningKind::ADD:
    #####:  470:        result =
        -:  471:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_add,
        -:  472:                                                       LLVM::AddOp>(
    #####:  473:                rewriter, loc, llvmType, operand, acc);
    #####:  474:        break;
call    0 never executed
    #####:  475:      case vector::CombiningKind::MUL:
    #####:  476:        result =
        -:  477:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_mul,
        -:  478:                                                       LLVM::MulOp>(
    #####:  479:                rewriter, loc, llvmType, operand, acc);
    #####:  480:        break;
call    0 never executed
    #####:  481:      case vector::CombiningKind::MINUI:
    #####:  482:        result = createIntegerReductionComparisonOpLowering<
        -:  483:            LLVM::vector_reduce_umin>(rewriter, loc, llvmType, operand, acc,
    #####:  484:                                      LLVM::ICmpPredicate::ule);
    #####:  485:        break;
call    0 never executed
    #####:  486:      case vector::CombiningKind::MINSI:
    #####:  487:        result = createIntegerReductionComparisonOpLowering<
        -:  488:            LLVM::vector_reduce_smin>(rewriter, loc, llvmType, operand, acc,
    #####:  489:                                      LLVM::ICmpPredicate::sle);
    #####:  490:        break;
call    0 never executed
    #####:  491:      case vector::CombiningKind::MAXUI:
    #####:  492:        result = createIntegerReductionComparisonOpLowering<
        -:  493:            LLVM::vector_reduce_umax>(rewriter, loc, llvmType, operand, acc,
    #####:  494:                                      LLVM::ICmpPredicate::uge);
    #####:  495:        break;
call    0 never executed
    #####:  496:      case vector::CombiningKind::MAXSI:
    #####:  497:        result = createIntegerReductionComparisonOpLowering<
        -:  498:            LLVM::vector_reduce_smax>(rewriter, loc, llvmType, operand, acc,
    #####:  499:                                      LLVM::ICmpPredicate::sge);
    #####:  500:        break;
call    0 never executed
    #####:  501:      case vector::CombiningKind::AND:
    #####:  502:        result =
        -:  503:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_and,
        -:  504:                                                       LLVM::AndOp>(
    #####:  505:                rewriter, loc, llvmType, operand, acc);
    #####:  506:        break;
call    0 never executed
    #####:  507:      case vector::CombiningKind::OR:
    #####:  508:        result =
        -:  509:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_or,
        -:  510:                                                       LLVM::OrOp>(
    #####:  511:                rewriter, loc, llvmType, operand, acc);
    #####:  512:        break;
call    0 never executed
    #####:  513:      case vector::CombiningKind::XOR:
    #####:  514:        result =
        -:  515:            createIntegerReductionArithmeticOpLowering<LLVM::vector_reduce_xor,
        -:  516:                                                       LLVM::XOrOp>(
    #####:  517:                rewriter, loc, llvmType, operand, acc);
    #####:  518:        break;
call    0 never executed
    #####:  519:      default:
    #####:  520:        return failure();
        -:  521:      }
    #####:  522:      rewriter.replaceOp(reductionOp, result);
call    0 never executed
call    1 never executed
        -:  523:
    #####:  524:      return success();
        -:  525:    }
        -:  526:
    #####:  527:    if (!eltType.isa<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  528:      return failure();
        -:  529:
        -:  530:    // Floating-point reductions: add/mul/min/max
    #####:  531:    if (kind == vector::CombiningKind::ADD) {
branch  0 never executed
branch  1 never executed
        -:  532:      // Optional accumulator (or zero).
    #####:  533:      Value acc = adaptor.getOperands().size() > 1
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  534:                      ? adaptor.getOperands()[1]
call    0 never executed
call    1 never executed
    #####:  535:                      : rewriter.create<LLVM::ConstantOp>(
        -:  536:                            reductionOp->getLoc(), llvmType,
    #####:  537:                            rewriter.getZeroAttr(eltType));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  538:      rewriter.replaceOpWithNewOp<LLVM::vector_reduce_fadd>(
        -:  539:          reductionOp, llvmType, acc, operand,
    #####:  540:          rewriter.getBoolAttr(reassociateFPReductions));
call    0 never executed
call    1 never executed
    #####:  541:    } else if (kind == vector::CombiningKind::MUL) {
branch  0 never executed
branch  1 never executed
        -:  542:      // Optional accumulator (or one).
    #####:  543:      Value acc = adaptor.getOperands().size() > 1
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  544:                      ? adaptor.getOperands()[1]
call    0 never executed
call    1 never executed
    #####:  545:                      : rewriter.create<LLVM::ConstantOp>(
        -:  546:                            reductionOp->getLoc(), llvmType,
    #####:  547:                            rewriter.getFloatAttr(eltType, 1.0));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  548:      rewriter.replaceOpWithNewOp<LLVM::vector_reduce_fmul>(
        -:  549:          reductionOp, llvmType, acc, operand,
    #####:  550:          rewriter.getBoolAttr(reassociateFPReductions));
call    0 never executed
call    1 never executed
    #####:  551:    } else if (kind == vector::CombiningKind::MINF) {
branch  0 never executed
branch  1 never executed
        -:  552:      // FIXME: MLIR's 'minf' and LLVM's 'vector_reduce_fmin' do not handle
        -:  553:      // NaNs/-0.0/+0.0 in the same way.
    #####:  554:      Value result =
    #####:  555:          rewriter.create<LLVM::vector_reduce_fmin>(loc, llvmType, operand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  556:      if (acc)
branch  0 never executed
branch  1 never executed
    #####:  557:        result = createMinMaxF(rewriter, loc, result, acc, /*isMin=*/true);
call    0 never executed
    #####:  558:      rewriter.replaceOp(reductionOp, result);
call    0 never executed
call    1 never executed
    #####:  559:    } else if (kind == vector::CombiningKind::MAXF) {
branch  0 never executed
branch  1 never executed
        -:  560:      // FIXME: MLIR's 'maxf' and LLVM's 'vector_reduce_fmax' do not handle
        -:  561:      // NaNs/-0.0/+0.0 in the same way.
    #####:  562:      Value result =
    #####:  563:          rewriter.create<LLVM::vector_reduce_fmax>(loc, llvmType, operand);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  564:      if (acc)
branch  0 never executed
branch  1 never executed
    #####:  565:        result = createMinMaxF(rewriter, loc, result, acc, /*isMin=*/false);
call    0 never executed
    #####:  566:      rewriter.replaceOp(reductionOp, result);
call    0 never executed
call    1 never executed
        -:  567:    } else
    #####:  568:      return failure();
        -:  569:
    #####:  570:    return success();
        -:  571:  }
        -:  572:
        -:  573:private:
        -:  574:  const bool reassociateFPReductions;
        -:  575:};
        -:  576:
        -:  577:class VectorShuffleOpConversion
        -:  578:    : public ConvertOpToLLVMPattern<vector::ShuffleOp> {
        -:  579:public:
     1773:  580:  using ConvertOpToLLVMPattern<vector::ShuffleOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  581:
        -:  582:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorShuffleOpConversion15matchAndRewriteEN4mlir6vector9ShuffleOpENS2_16ShuffleOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  583:  matchAndRewrite(vector::ShuffleOp shuffleOp, OpAdaptor adaptor,
        -:  584:                  ConversionPatternRewriter &rewriter) const override {
    #####:  585:    auto loc = shuffleOp->getLoc();
call    0 never executed
    #####:  586:    auto v1Type = shuffleOp.getV1VectorType();
call    0 never executed
    #####:  587:    auto v2Type = shuffleOp.getV2VectorType();
call    0 never executed
    #####:  588:    auto vectorType = shuffleOp.getVectorType();
call    0 never executed
    #####:  589:    Type llvmType = typeConverter->convertType(vectorType);
call    0 never executed
    #####:  590:    auto maskArrayAttr = shuffleOp.getMask();
call    0 never executed
        -:  591:
        -:  592:    // Bail if result type cannot be lowered.
    #####:  593:    if (!llvmType)
branch  0 never executed
branch  1 never executed
    #####:  594:      return failure();
        -:  595:
        -:  596:    // Get rank and dimension sizes.
    #####:  597:    int64_t rank = vectorType.getRank();
call    0 never executed
        -:  598:#ifndef NDEBUG
    #####:  599:    bool wellFormed0DCase =
call    0 never executed
    #####:  600:        v1Type.getRank() == 0 && v2Type.getRank() == 0 && rank == 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  601:    bool wellFormedNDCase =
call    0 never executed
    #####:  602:        v1Type.getRank() == rank && v2Type.getRank() == rank;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  603:    assert((wellFormed0DCase || wellFormedNDCase) && "op is not well-formed");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  604:#endif
        -:  605:
        -:  606:    // For rank 0 and 1, where both operands have *exactly* the same vector
        -:  607:    // type, there is direct shuffle support in LLVM. Use it!
    #####:  608:    if (rank <= 1 && v1Type == v2Type) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  609:      Value llvmShuffleOp = rewriter.create<LLVM::ShuffleVectorOp>(
    #####:  610:          loc, adaptor.getV1(), adaptor.getV2(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  611:          LLVM::convertArrayToIndices<int32_t>(maskArrayAttr));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  612:      rewriter.replaceOp(shuffleOp, llvmShuffleOp);
call    0 never executed
call    1 never executed
    #####:  613:      return success();
        -:  614:    }
        -:  615:
        -:  616:    // For all other cases, insert the individual values individually.
    #####:  617:    int64_t v1Dim = v1Type.getDimSize(0);
call    0 never executed
    #####:  618:    Type eltType;
    #####:  619:    if (auto arrayType = llvmType.dyn_cast<LLVM::LLVMArrayType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  620:      eltType = arrayType.getElementType();
call    0 never executed
        -:  621:    else
    #####:  622:      eltType = llvmType.cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
    #####:  623:    Value insert = rewriter.create<LLVM::UndefOp>(loc, llvmType);
call    0 never executed
call    1 never executed
    #####:  624:    int64_t insPos = 0;
    #####:  625:    for (const auto &en : llvm::enumerate(maskArrayAttr)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  626:      int64_t extPos = en.value().cast<IntegerAttr>().getInt();
call    0 never executed
call    1 never executed
    #####:  627:      Value value = adaptor.getV1();
call    0 never executed
    #####:  628:      if (extPos >= v1Dim) {
branch  0 never executed
branch  1 never executed
    #####:  629:        extPos -= v1Dim;
    #####:  630:        value = adaptor.getV2();
call    0 never executed
        -:  631:      }
    #####:  632:      Value extract = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 never executed
    #####:  633:                                 eltType, rank, extPos);
call    0 never executed
    #####:  634:      insert = insertOne(rewriter, *getTypeConverter(), loc, insert, extract,
    #####:  635:                         llvmType, rank, insPos++);
call    0 never executed
call    1 never executed
        -:  636:    }
    #####:  637:    rewriter.replaceOp(shuffleOp, insert);
call    0 never executed
call    1 never executed
    #####:  638:    return success();
        -:  639:  }
        -:  640:};
        -:  641:
        -:  642:class VectorExtractElementOpConversion
        -:  643:    : public ConvertOpToLLVMPattern<vector::ExtractElementOp> {
        -:  644:public:
        -:  645:  using ConvertOpToLLVMPattern<
     1773:  646:      vector::ExtractElementOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  647:
        -:  648:  LogicalResult
function _ZNK12_GLOBAL__N_132VectorExtractElementOpConversion15matchAndRewriteEN4mlir6vector16ExtractElementOpENS2_23ExtractElementOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  649:  matchAndRewrite(vector::ExtractElementOp extractEltOp, OpAdaptor adaptor,
        -:  650:                  ConversionPatternRewriter &rewriter) const override {
    #####:  651:    auto vectorType = extractEltOp.getVectorType();
call    0 never executed
    #####:  652:    auto llvmType = typeConverter->convertType(vectorType.getElementType());
call    0 never executed
call    1 never executed
        -:  653:
        -:  654:    // Bail if result type cannot be lowered.
    #####:  655:    if (!llvmType)
branch  0 never executed
branch  1 never executed
    #####:  656:      return failure();
        -:  657:
    #####:  658:    if (vectorType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  659:      Location loc = extractEltOp.getLoc();
call    0 never executed
    #####:  660:      auto idxType = rewriter.getIndexType();
call    0 never executed
    #####:  661:      auto zero = rewriter.create<LLVM::ConstantOp>(
    #####:  662:          loc, typeConverter->convertType(idxType),
call    0 never executed
    #####:  663:          rewriter.getIntegerAttr(idxType, 0));
call    0 never executed
call    1 never executed
    #####:  664:      rewriter.replaceOpWithNewOp<LLVM::ExtractElementOp>(
    #####:  665:          extractEltOp, llvmType, adaptor.getVector(), zero);
call    0 never executed
call    1 never executed
    #####:  666:      return success();
        -:  667:    }
        -:  668:
    #####:  669:    rewriter.replaceOpWithNewOp<LLVM::ExtractElementOp>(
    #####:  670:        extractEltOp, llvmType, adaptor.getVector(), adaptor.getPosition());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  671:    return success();
        -:  672:  }
        -:  673:};
        -:  674:
        -:  675:class VectorExtractOpConversion
        -:  676:    : public ConvertOpToLLVMPattern<vector::ExtractOp> {
        -:  677:public:
     1773:  678:  using ConvertOpToLLVMPattern<vector::ExtractOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  679:
        -:  680:  LogicalResult
function _ZNK12_GLOBAL__N_125VectorExtractOpConversion15matchAndRewriteEN4mlir6vector9ExtractOpENS2_16ExtractOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  681:  matchAndRewrite(vector::ExtractOp extractOp, OpAdaptor adaptor,
        -:  682:                  ConversionPatternRewriter &rewriter) const override {
    #####:  683:    auto loc = extractOp->getLoc();
call    0 never executed
    #####:  684:    auto resultType = extractOp.getResult().getType();
call    0 never executed
    #####:  685:    auto llvmResultType = typeConverter->convertType(resultType);
call    0 never executed
    #####:  686:    auto positionArrayAttr = extractOp.getPosition();
call    0 never executed
        -:  687:
        -:  688:    // Bail if result type cannot be lowered.
    #####:  689:    if (!llvmResultType)
branch  0 never executed
branch  1 never executed
    #####:  690:      return failure();
        -:  691:
        -:  692:    // Extract entire vector. Should be handled by folder, but just to be safe.
    #####:  693:    if (positionArrayAttr.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  694:      rewriter.replaceOp(extractOp, adaptor.getVector());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  695:      return success();
        -:  696:    }
        -:  697:
        -:  698:    // One-shot extraction of vector from array (only requires extractvalue).
    #####:  699:    if (resultType.isa<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  700:      SmallVector<int64_t> indices;
call    0 never executed
    #####:  701:      for (auto idx : positionArrayAttr.getAsRange<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  702:        indices.push_back(idx.getInt());
call    0 never executed
call    1 never executed
    #####:  703:      Value extracted = rewriter.create<LLVM::ExtractValueOp>(
    #####:  704:          loc, adaptor.getVector(), indices);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  705:      rewriter.replaceOp(extractOp, extracted);
call    0 never executed
call    1 never executed
    #####:  706:      return success();
branch  0 never executed
branch  1 never executed
        -:  707:    }
        -:  708:
        -:  709:    // Potential extraction of 1-D vector from array.
    #####:  710:    Value extracted = adaptor.getVector();
call    0 never executed
    #####:  711:    auto positionAttrs = positionArrayAttr.getValue();
call    0 never executed
    #####:  712:    if (positionAttrs.size() > 1) {
branch  0 never executed
branch  1 never executed
    #####:  713:      SmallVector<int64_t> nMinusOnePosition;
call    0 never executed
    #####:  714:      for (auto idx : positionAttrs.drop_back())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  715:        nMinusOnePosition.push_back(idx.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  716:      extracted = rewriter.create<LLVM::ExtractValueOp>(loc, extracted,
branch  0 never executed
branch  1 never executed
    #####:  717:                                                        nMinusOnePosition);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  718:    }
        -:  719:
        -:  720:    // Remaining extraction of element from 1-D LLVM vector
    #####:  721:    auto position = positionAttrs.back().cast<IntegerAttr>();
call    0 never executed
call    1 never executed
    #####:  722:    auto i64Type = IntegerType::get(rewriter.getContext(), 64);
call    0 never executed
    #####:  723:    auto constant = rewriter.create<LLVM::ConstantOp>(loc, i64Type, position);
call    0 never executed
    #####:  724:    extracted =
    #####:  725:        rewriter.create<LLVM::ExtractElementOp>(loc, extracted, constant);
call    0 never executed
call    1 never executed
    #####:  726:    rewriter.replaceOp(extractOp, extracted);
call    0 never executed
call    1 never executed
        -:  727:
    #####:  728:    return success();
        -:  729:  }
        -:  730:};
        -:  731:
        -:  732:/// Conversion pattern that turns a vector.fma on a 1-D vector
        -:  733:/// into an llvm.intr.fmuladd. This is a trivial 1-1 conversion.
        -:  734:/// This does not match vectors of n >= 2 rank.
        -:  735:///
        -:  736:/// Example:
        -:  737:/// ```
        -:  738:///  vector.fma %a, %a, %a : vector<8xf32>
        -:  739:/// ```
        -:  740:/// is converted to:
        -:  741:/// ```
        -:  742:///  llvm.intr.fmuladd %va, %va, %va:
        -:  743:///    (!llvm."<8 x f32>">, !llvm<"<8 x f32>">, !llvm<"<8 x f32>">)
        -:  744:///    -> !llvm."<8 x f32>">
        -:  745:/// ```
        -:  746:class VectorFMAOp1DConversion : public ConvertOpToLLVMPattern<vector::FMAOp> {
        -:  747:public:
     1773:  748:  using ConvertOpToLLVMPattern<vector::FMAOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  749:
        -:  750:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorFMAOp1DConversion15matchAndRewriteEN4mlir6vector5FMAOpENS2_12FMAOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  751:  matchAndRewrite(vector::FMAOp fmaOp, OpAdaptor adaptor,
        -:  752:                  ConversionPatternRewriter &rewriter) const override {
    #####:  753:    VectorType vType = fmaOp.getVectorType();
call    0 never executed
    #####:  754:    if (vType.getRank() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:      return failure();
    #####:  756:    rewriter.replaceOpWithNewOp<LLVM::FMulAddOp>(
    #####:  757:        fmaOp, adaptor.getLhs(), adaptor.getRhs(), adaptor.getAcc());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  758:    return success();
        -:  759:  }
        -:  760:};
        -:  761:
        -:  762:class VectorInsertElementOpConversion
        -:  763:    : public ConvertOpToLLVMPattern<vector::InsertElementOp> {
        -:  764:public:
     1773:  765:  using ConvertOpToLLVMPattern<vector::InsertElementOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  766:
        -:  767:  LogicalResult
function _ZNK12_GLOBAL__N_131VectorInsertElementOpConversion15matchAndRewriteEN4mlir6vector15InsertElementOpENS2_22InsertElementOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  768:  matchAndRewrite(vector::InsertElementOp insertEltOp, OpAdaptor adaptor,
        -:  769:                  ConversionPatternRewriter &rewriter) const override {
    #####:  770:    auto vectorType = insertEltOp.getDestVectorType();
call    0 never executed
    #####:  771:    auto llvmType = typeConverter->convertType(vectorType);
call    0 never executed
        -:  772:
        -:  773:    // Bail if result type cannot be lowered.
    #####:  774:    if (!llvmType)
branch  0 never executed
branch  1 never executed
    #####:  775:      return failure();
        -:  776:
    #####:  777:    if (vectorType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  778:      Location loc = insertEltOp.getLoc();
call    0 never executed
    #####:  779:      auto idxType = rewriter.getIndexType();
call    0 never executed
    #####:  780:      auto zero = rewriter.create<LLVM::ConstantOp>(
    #####:  781:          loc, typeConverter->convertType(idxType),
call    0 never executed
    #####:  782:          rewriter.getIntegerAttr(idxType, 0));
call    0 never executed
call    1 never executed
    #####:  783:      rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
    #####:  784:          insertEltOp, llvmType, adaptor.getDest(), adaptor.getSource(), zero);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  785:      return success();
        -:  786:    }
        -:  787:
    #####:  788:    rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
    #####:  789:        insertEltOp, llvmType, adaptor.getDest(), adaptor.getSource(),
call    0 never executed
call    1 never executed
    #####:  790:        adaptor.getPosition());
call    0 never executed
call    1 never executed
    #####:  791:    return success();
        -:  792:  }
        -:  793:};
        -:  794:
        -:  795:class VectorInsertOpConversion
        -:  796:    : public ConvertOpToLLVMPattern<vector::InsertOp> {
        -:  797:public:
     1773:  798:  using ConvertOpToLLVMPattern<vector::InsertOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  799:
        -:  800:  LogicalResult
function _ZNK12_GLOBAL__N_124VectorInsertOpConversion15matchAndRewriteEN4mlir6vector8InsertOpENS2_15InsertOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  801:  matchAndRewrite(vector::InsertOp insertOp, OpAdaptor adaptor,
        -:  802:                  ConversionPatternRewriter &rewriter) const override {
    #####:  803:    auto loc = insertOp->getLoc();
call    0 never executed
    #####:  804:    auto sourceType = insertOp.getSourceType();
call    0 never executed
    #####:  805:    auto destVectorType = insertOp.getDestVectorType();
call    0 never executed
    #####:  806:    auto llvmResultType = typeConverter->convertType(destVectorType);
call    0 never executed
    #####:  807:    auto positionArrayAttr = insertOp.getPosition();
call    0 never executed
        -:  808:
        -:  809:    // Bail if result type cannot be lowered.
    #####:  810:    if (!llvmResultType)
branch  0 never executed
branch  1 never executed
    #####:  811:      return failure();
        -:  812:
        -:  813:    // Overwrite entire vector with value. Should be handled by folder, but
        -:  814:    // just to be safe.
    #####:  815:    if (positionArrayAttr.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:      rewriter.replaceOp(insertOp, adaptor.getSource());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  817:      return success();
        -:  818:    }
        -:  819:
        -:  820:    // One-shot insertion of a vector into an array (only requires insertvalue).
    #####:  821:    if (sourceType.isa<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  822:      Value inserted = rewriter.create<LLVM::InsertValueOp>(
    #####:  823:          loc, adaptor.getDest(), adaptor.getSource(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  824:          LLVM::convertArrayToIndices(positionArrayAttr));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  825:      rewriter.replaceOp(insertOp, inserted);
call    0 never executed
call    1 never executed
    #####:  826:      return success();
        -:  827:    }
        -:  828:
        -:  829:    // Potential extraction of 1-D vector from array.
    #####:  830:    Value extracted = adaptor.getDest();
call    0 never executed
    #####:  831:    auto positionAttrs = positionArrayAttr.getValue();
call    0 never executed
    #####:  832:    auto position = positionAttrs.back().cast<IntegerAttr>();
call    0 never executed
call    1 never executed
    #####:  833:    auto oneDVectorType = destVectorType;
    #####:  834:    if (positionAttrs.size() > 1) {
branch  0 never executed
branch  1 never executed
    #####:  835:      oneDVectorType = reducedVectorTypeBack(destVectorType);
call    0 never executed
    #####:  836:      extracted = rewriter.create<LLVM::ExtractValueOp>(
branch  0 never executed
branch  1 never executed
        -:  837:          loc, extracted,
    #####:  838:          LLVM::convertArrayToIndices(positionAttrs.drop_back()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  839:    }
        -:  840:
        -:  841:    // Insertion of an element into a 1-D LLVM vector.
    #####:  842:    auto i64Type = IntegerType::get(rewriter.getContext(), 64);
call    0 never executed
    #####:  843:    auto constant = rewriter.create<LLVM::ConstantOp>(loc, i64Type, position);
call    0 never executed
    #####:  844:    Value inserted = rewriter.create<LLVM::InsertElementOp>(
    #####:  845:        loc, typeConverter->convertType(oneDVectorType), extracted,
call    0 never executed
    #####:  846:        adaptor.getSource(), constant);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  847:
        -:  848:    // Potential insertion of resulting 1-D vector into array.
    #####:  849:    if (positionAttrs.size() > 1) {
branch  0 never executed
branch  1 never executed
    #####:  850:      inserted = rewriter.create<LLVM::InsertValueOp>(
    #####:  851:          loc, adaptor.getDest(), inserted,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  852:          LLVM::convertArrayToIndices(positionAttrs.drop_back()));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  853:    }
        -:  854:
    #####:  855:    rewriter.replaceOp(insertOp, inserted);
call    0 never executed
call    1 never executed
    #####:  856:    return success();
        -:  857:  }
        -:  858:};
        -:  859:
        -:  860:/// Rank reducing rewrite for n-D FMA into (n-1)-D FMA where n > 1.
        -:  861:///
        -:  862:/// Example:
        -:  863:/// ```
        -:  864:///   %d = vector.fma %a, %b, %c : vector<2x4xf32>
        -:  865:/// ```
        -:  866:/// is rewritten into:
        -:  867:/// ```
        -:  868:///  %r = splat %f0: vector<2x4xf32>
        -:  869:///  %va = vector.extractvalue %a[0] : vector<2x4xf32>
        -:  870:///  %vb = vector.extractvalue %b[0] : vector<2x4xf32>
        -:  871:///  %vc = vector.extractvalue %c[0] : vector<2x4xf32>
        -:  872:///  %vd = vector.fma %va, %vb, %vc : vector<4xf32>
        -:  873:///  %r2 = vector.insertvalue %vd, %r[0] : vector<4xf32> into vector<2x4xf32>
        -:  874:///  %va2 = vector.extractvalue %a2[1] : vector<2x4xf32>
        -:  875:///  %vb2 = vector.extractvalue %b2[1] : vector<2x4xf32>
        -:  876:///  %vc2 = vector.extractvalue %c2[1] : vector<2x4xf32>
        -:  877:///  %vd2 = vector.fma %va2, %vb2, %vc2 : vector<4xf32>
        -:  878:///  %r3 = vector.insertvalue %vd2, %r2[1] : vector<4xf32> into vector<2x4xf32>
        -:  879:///  // %r3 holds the final value.
        -:  880:/// ```
        -:  881:class VectorFMAOpNDRewritePattern : public OpRewritePattern<FMAOp> {
        -:  882:public:
        -:  883:  using OpRewritePattern<FMAOp>::OpRewritePattern;
        -:  884:
        -:  885:  void initialize() {
        -:  886:    // This pattern recursively unpacks one dimension at a time. The recursion
        -:  887:    // bounded as the rank is strictly decreasing.
        -:  888:    setHasBoundedRewriteRecursion();
        -:  889:  }
        -:  890:
function _ZNK12_GLOBAL__N_127VectorFMAOpNDRewritePattern15matchAndRewriteEN4mlir6vector5FMAOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  891:  LogicalResult matchAndRewrite(FMAOp op,
        -:  892:                                PatternRewriter &rewriter) const override {
    #####:  893:    auto vType = op.getVectorType();
call    0 never executed
    #####:  894:    if (vType.getRank() < 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  895:      return failure();
        -:  896:
    #####:  897:    auto loc = op.getLoc();
call    0 never executed
    #####:  898:    auto elemType = vType.getElementType();
call    0 never executed
    #####:  899:    Value zero = rewriter.create<arith::ConstantOp>(
    #####:  900:        loc, elemType, rewriter.getZeroAttr(elemType));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  901:    Value desc = rewriter.create<vector::SplatOp>(loc, vType, zero);
call    0 never executed
call    1 never executed
    #####:  902:    for (int64_t i = 0, e = vType.getShape().front(); i != e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  903:      Value extrLHS = rewriter.create<ExtractOp>(loc, op.getLhs(), i);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  904:      Value extrRHS = rewriter.create<ExtractOp>(loc, op.getRhs(), i);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  905:      Value extrACC = rewriter.create<ExtractOp>(loc, op.getAcc(), i);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  906:      Value fma = rewriter.create<FMAOp>(loc, extrLHS, extrRHS, extrACC);
call    0 never executed
call    1 never executed
    #####:  907:      desc = rewriter.create<InsertOp>(loc, fma, desc, i);
call    0 never executed
        -:  908:    }
    #####:  909:    rewriter.replaceOp(op, desc);
call    0 never executed
call    1 never executed
    #####:  910:    return success();
        -:  911:  }
        -:  912:};
        -:  913:
        -:  914:/// Returns the strides if the memory underlying `memRefType` has a contiguous
        -:  915:/// static layout.
        -:  916:static llvm::Optional<SmallVector<int64_t, 4>>
function _ZN12_GLOBAL__N_1L24computeContiguousStridesEN4mlir10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  917:computeContiguousStrides(MemRefType memRefType) {
    #####:  918:  int64_t offset;
    #####:  919:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  920:  if (failed(getStridesAndOffset(memRefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  921:    return None;
    #####:  922:  if (!strides.empty() && strides.back() != 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  923:    return None;
        -:  924:  // If no layout or identity layout, this is contiguous by definition.
    #####:  925:  if (memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  926:    return strides;
branch  0 never executed
branch  1 never executed
        -:  927:
        -:  928:  // Otherwise, we must determine contiguity form shapes. This can only ever
        -:  929:  // work in static cases because MemRefType is underspecified to represent
        -:  930:  // contiguous dynamic shapes in other ways than with just empty/identity
        -:  931:  // layout.
    #####:  932:  auto sizes = memRefType.getShape();
call    0 never executed
    #####:  933:  for (int index = 0, e = strides.size() - 1; index < e; ++index) {
branch  0 never executed
branch  1 never executed
    #####:  934:    if (ShapedType::isDynamic(sizes[index + 1]) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  935:        ShapedType::isDynamicStrideOrOffset(strides[index]) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  936:        ShapedType::isDynamicStrideOrOffset(strides[index + 1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  937:      return None;
    #####:  938:    if (strides[index] != strides[index + 1] * sizes[index + 1])
branch  0 never executed
branch  1 never executed
    #####:  939:      return None;
        -:  940:  }
    #####:  941:  return strides;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  942:}
        -:  943:
        -:  944:class VectorTypeCastOpConversion
        -:  945:    : public ConvertOpToLLVMPattern<vector::TypeCastOp> {
        -:  946:public:
     1773:  947:  using ConvertOpToLLVMPattern<vector::TypeCastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  948:
        -:  949:  LogicalResult
function _ZNK12_GLOBAL__N_126VectorTypeCastOpConversion15matchAndRewriteEN4mlir6vector10TypeCastOpENS2_17TypeCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  950:  matchAndRewrite(vector::TypeCastOp castOp, OpAdaptor adaptor,
        -:  951:                  ConversionPatternRewriter &rewriter) const override {
    #####:  952:    auto loc = castOp->getLoc();
call    0 never executed
    #####:  953:    MemRefType sourceMemRefType =
call    0 never executed
    #####:  954:        castOp.getOperand().getType().cast<MemRefType>();
call    0 never executed
    #####:  955:    MemRefType targetMemRefType = castOp.getType();
call    0 never executed
        -:  956:
        -:  957:    // Only static shape casts supported atm.
    #####:  958:    if (!sourceMemRefType.hasStaticShape() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  959:        !targetMemRefType.hasStaticShape())
call    0 never executed
    #####:  960:      return failure();
        -:  961:
    #####:  962:    auto llvmSourceDescriptorTy =
    #####:  963:        adaptor.getOperands()[0].getType().dyn_cast<LLVM::LLVMStructType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  964:    if (!llvmSourceDescriptorTy)
branch  0 never executed
branch  1 never executed
    #####:  965:      return failure();
    #####:  966:    MemRefDescriptor sourceMemRef(adaptor.getOperands()[0]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  967:
    #####:  968:    auto llvmTargetDescriptorTy = typeConverter->convertType(targetMemRefType)
call    0 never executed
call    1 never executed
    #####:  969:                                      .dyn_cast_or_null<LLVM::LLVMStructType>();
    #####:  970:    if (!llvmTargetDescriptorTy)
branch  0 never executed
branch  1 never executed
    #####:  971:      return failure();
        -:  972:
        -:  973:    // Only contiguous source buffers supported atm.
    #####:  974:    auto sourceStrides = computeContiguousStrides(sourceMemRefType);
call    0 never executed
    #####:  975:    if (!sourceStrides)
branch  0 never executed
branch  1 never executed
    #####:  976:      return failure();
    #####:  977:    auto targetStrides = computeContiguousStrides(targetMemRefType);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  978:    if (!targetStrides)
branch  0 never executed
branch  1 never executed
    #####:  979:      return failure();
        -:  980:    // Only support static strides for now, regardless of contiguity.
    #####:  981:    if (llvm::any_of(*targetStrides, ShapedType::isDynamicStrideOrOffset))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  982:      return failure();
        -:  983:
    #####:  984:    auto int64Ty = IntegerType::get(rewriter.getContext(), 64);
call    0 never executed
        -:  985:
        -:  986:    // Create descriptor.
    #####:  987:    auto desc = MemRefDescriptor::undef(rewriter, loc, llvmTargetDescriptorTy);
call    0 never executed
    #####:  988:    Type llvmTargetElementTy = desc.getElementPtrType();
call    0 never executed
        -:  989:    // Set allocated ptr.
    #####:  990:    Value allocated = sourceMemRef.allocatedPtr(rewriter, loc);
call    0 never executed
    #####:  991:    allocated =
    #####:  992:        rewriter.create<LLVM::BitcastOp>(loc, llvmTargetElementTy, allocated);
call    0 never executed
call    1 never executed
    #####:  993:    desc.setAllocatedPtr(rewriter, loc, allocated);
call    0 never executed
        -:  994:    // Set aligned ptr.
    #####:  995:    Value ptr = sourceMemRef.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  996:    ptr = rewriter.create<LLVM::BitcastOp>(loc, llvmTargetElementTy, ptr);
call    0 never executed
call    1 never executed
    #####:  997:    desc.setAlignedPtr(rewriter, loc, ptr);
call    0 never executed
        -:  998:    // Fill offset 0.
    #####:  999:    auto attr = rewriter.getIntegerAttr(rewriter.getIndexType(), 0);
call    0 never executed
call    1 never executed
    #####: 1000:    auto zero = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, attr);
call    0 never executed
    #####: 1001:    desc.setOffset(rewriter, loc, zero);
call    0 never executed
        -: 1002:
        -: 1003:    // Fill size and stride descriptors in memref.
    #####: 1004:    for (const auto &indexedSize :
    #####: 1005:         llvm::enumerate(targetMemRefType.getShape())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1006:      int64_t index = indexedSize.index();
call    0 never executed
    #####: 1007:      auto sizeAttr =
    #####: 1008:          rewriter.getIntegerAttr(rewriter.getIndexType(), indexedSize.value());
call    0 never executed
call    1 never executed
    #####: 1009:      auto size = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, sizeAttr);
call    0 never executed
    #####: 1010:      desc.setSize(rewriter, loc, index, size);
call    0 never executed
    #####: 1011:      auto strideAttr = rewriter.getIntegerAttr(rewriter.getIndexType(),
    #####: 1012:                                                (*targetStrides)[index]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####: 1013:      auto stride = rewriter.create<LLVM::ConstantOp>(loc, int64Ty, strideAttr);
call    0 never executed
    #####: 1014:      desc.setStride(rewriter, loc, index, stride);
call    0 never executed
        -: 1015:    }
        -: 1016:
    #####: 1017:    rewriter.replaceOp(castOp, {desc});
call    0 never executed
call    1 never executed
    #####: 1018:    return success();
branch  0 never executed
branch  1 never executed
        -: 1019:  }
        -: 1020:};
        -: 1021:
        -: 1022:/// Conversion pattern for a `vector.create_mask` (1-D scalable vectors only).
        -: 1023:/// Non-scalable versions of this operation are handled in Vector Transforms.
        -: 1024:class VectorCreateMaskOpRewritePattern
        -: 1025:    : public OpRewritePattern<vector::CreateMaskOp> {
        -: 1026:public:
function _ZN12_GLOBAL__N_132VectorCreateMaskOpRewritePatternC2EPN4mlir11MLIRContextEb called 1773 returned 100% blocks executed 100%
     1773: 1027:  explicit VectorCreateMaskOpRewritePattern(MLIRContext *context,
        -: 1028:                                            bool enableIndexOpt)
     1773: 1029:      : OpRewritePattern<vector::CreateMaskOp>(context),
     1773: 1030:        force32BitVectorIndices(enableIndexOpt) {}
call    0 returned 100%
call    1 returned 100%
        -: 1031:
function _ZNK12_GLOBAL__N_132VectorCreateMaskOpRewritePattern15matchAndRewriteEN4mlir6vector12CreateMaskOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1032:  LogicalResult matchAndRewrite(vector::CreateMaskOp op,
        -: 1033:                                PatternRewriter &rewriter) const override {
    #####: 1034:    auto dstType = op.getType();
call    0 never executed
    #####: 1035:    if (dstType.getRank() != 1 || !dstType.cast<VectorType>().isScalable())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1036:      return failure();
    #####: 1037:    IntegerType idxType =
    #####: 1038:        force32BitVectorIndices ? rewriter.getI32Type() : rewriter.getI64Type();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1039:    auto loc = op->getLoc();
call    0 never executed
    #####: 1040:    Value indices = rewriter.create<LLVM::StepVectorOp>(
    #####: 1041:        loc, LLVM::getVectorType(idxType, dstType.getShape()[0],
branch  0 never executed
branch  1 never executed
    #####: 1042:                                 /*isScalable=*/true));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1043:    auto bound = getValueOrCreateCastToIndexLike(rewriter, loc, idxType,
call    0 never executed
    #####: 1044:                                                 op.getOperand(0));
call    0 never executed
    #####: 1045:    Value bounds = rewriter.create<SplatOp>(loc, indices.getType(), bound);
call    0 never executed
call    1 never executed
    #####: 1046:    Value comp = rewriter.create<arith::CmpIOp>(loc, arith::CmpIPredicate::slt,
    #####: 1047:                                                indices, bounds);
call    0 never executed
call    1 never executed
    #####: 1048:    rewriter.replaceOp(op, comp);
call    0 never executed
call    1 never executed
    #####: 1049:    return success();
        -: 1050:  }
        -: 1051:
        -: 1052:private:
        -: 1053:  const bool force32BitVectorIndices;
        -: 1054:};
        -: 1055:
        -: 1056:class VectorPrintOpConversion : public ConvertOpToLLVMPattern<vector::PrintOp> {
        -: 1057:public:
     1773: 1058:  using ConvertOpToLLVMPattern<vector::PrintOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1059:
        -: 1060:  // Proof-of-concept lowering implementation that relies on a small
        -: 1061:  // runtime support library, which only needs to provide a few
        -: 1062:  // printing methods (single value for all data types, opening/closing
        -: 1063:  // bracket, comma, newline). The lowering fully unrolls a vector
        -: 1064:  // in terms of these elementary printing operations. The advantage
        -: 1065:  // of this approach is that the library can remain unaware of all
        -: 1066:  // low-level implementation details of vectors while still supporting
        -: 1067:  // output of any shaped and dimensioned vector. Due to full unrolling,
        -: 1068:  // this approach is less suited for very large vectors though.
        -: 1069:  //
        -: 1070:  // TODO: rely solely on libc in future? something else?
        -: 1071:  //
        -: 1072:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorPrintOpConversion15matchAndRewriteEN4mlir6vector7PrintOpENS2_14PrintOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1073:  matchAndRewrite(vector::PrintOp printOp, OpAdaptor adaptor,
        -: 1074:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1075:    Type printType = printOp.getPrintType();
call    0 never executed
        -: 1076:
    #####: 1077:    if (typeConverter->convertType(printType) == nullptr)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1078:      return failure();
        -: 1079:
        -: 1080:    // Make sure element type has runtime support.
    #####: 1081:    PrintConversion conversion = PrintConversion::None;
    #####: 1082:    VectorType vectorType = printType.dyn_cast<VectorType>();
call    0 never executed
    #####: 1083:    Type eltType = vectorType ? vectorType.getElementType() : printType;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1084:    Operation *printer;
    #####: 1085:    if (eltType.isF32()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1086:      printer =
    #####: 1087:          LLVM::lookupOrCreatePrintF32Fn(printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
    #####: 1088:    } else if (eltType.isF64()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1089:      printer =
    #####: 1090:          LLVM::lookupOrCreatePrintF64Fn(printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
    #####: 1091:    } else if (eltType.isIndex()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1092:      printer =
    #####: 1093:          LLVM::lookupOrCreatePrintU64Fn(printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
    #####: 1094:    } else if (auto intTy = eltType.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1095:      // Integers need a zero or sign extension on the operand
        -: 1096:      // (depending on the source type) as well as a signed or
        -: 1097:      // unsigned print method. Up to 64-bit is supported.
    #####: 1098:      unsigned width = intTy.getWidth();
call    0 never executed
    #####: 1099:      if (intTy.isUnsigned()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1100:        if (width <= 64) {
branch  0 never executed
branch  1 never executed
    #####: 1101:          if (width < 64)
branch  0 never executed
branch  1 never executed
    #####: 1102:            conversion = PrintConversion::ZeroExt64;
    #####: 1103:          printer = LLVM::lookupOrCreatePrintU64Fn(
    #####: 1104:              printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
        -: 1105:        } else {
    #####: 1106:          return failure();
        -: 1107:        }
        -: 1108:      } else {
    #####: 1109:        assert(intTy.isSignless() || intTy.isSigned());
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1110:        if (width <= 64) {
branch  0 never executed
branch  1 never executed
        -: 1111:          // Note that we *always* zero extend booleans (1-bit integers),
        -: 1112:          // so that true/false is printed as 1/0 rather than -1/0.
    #####: 1113:          if (width == 1)
branch  0 never executed
branch  1 never executed
        -: 1114:            conversion = PrintConversion::ZeroExt64;
    #####: 1115:          else if (width < 64)
branch  0 never executed
branch  1 never executed
    #####: 1116:            conversion = PrintConversion::SignExt64;
    #####: 1117:          printer = LLVM::lookupOrCreatePrintI64Fn(
    #####: 1118:              printOp->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
        -: 1119:        } else {
    #####: 1120:          return failure();
        -: 1121:        }
        -: 1122:      }
        -: 1123:    } else {
    #####: 1124:      return failure();
        -: 1125:    }
        -: 1126:
        -: 1127:    // Unroll vector into elementary print calls.
    #####: 1128:    int64_t rank = vectorType ? vectorType.getRank() : 0;
branch  0 never executed
branch  1 never executed
    #####: 1129:    Type type = vectorType ? vectorType : eltType;
branch  0 never executed
branch  1 never executed
    #####: 1130:    emitRanks(rewriter, printOp, adaptor.getSource(), type, printer, rank,
call    0 never executed
call    1 never executed
        -: 1131:              conversion);
    #####: 1132:    emitCall(rewriter, printOp->getLoc(),
call    0 never executed
call    1 never executed
    #####: 1133:             LLVM::lookupOrCreatePrintNewlineFn(
    #####: 1134:                 printOp->getParentOfType<ModuleOp>()));
call    0 never executed
call    1 never executed
    #####: 1135:    rewriter.eraseOp(printOp);
call    0 never executed
    #####: 1136:    return success();
        -: 1137:  }
        -: 1138:
        -: 1139:private:
        -: 1140:  enum class PrintConversion {
        -: 1141:    // clang-format off
        -: 1142:    None,
        -: 1143:    ZeroExt64,
        -: 1144:    SignExt64
        -: 1145:    // clang-format on
        -: 1146:  };
        -: 1147:
function _ZNK12_GLOBAL__N_123VectorPrintOpConversion9emitRanksERN4mlir25ConversionPatternRewriterEPNS1_9OperationENS1_5ValueENS1_4TypeES5_lNS0_15PrintConversionE called 0 returned 0% blocks executed 0%
    #####: 1148:  void emitRanks(ConversionPatternRewriter &rewriter, Operation *op,
        -: 1149:                 Value value, Type type, Operation *printer, int64_t rank,
        -: 1150:                 PrintConversion conversion) const {
    #####: 1151:    VectorType vectorType = type.dyn_cast<VectorType>();
call    0 never executed
    #####: 1152:    Location loc = op->getLoc();
branch  0 never executed
branch  1 never executed
    #####: 1153:    if (!vectorType) {
branch  0 never executed
branch  1 never executed
    #####: 1154:      assert(rank == 0 && "The scalar case expects rank == 0");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1155:      switch (conversion) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1156:      case PrintConversion::ZeroExt64:
    #####: 1157:        value = rewriter.create<arith::ExtUIOp>(
    #####: 1158:            loc, IntegerType::get(rewriter.getContext(), 64), value);
call    0 never executed
call    1 never executed
    #####: 1159:        break;
    #####: 1160:      case PrintConversion::SignExt64:
    #####: 1161:        value = rewriter.create<arith::ExtSIOp>(
    #####: 1162:            loc, IntegerType::get(rewriter.getContext(), 64), value);
call    0 never executed
call    1 never executed
    #####: 1163:        break;
        -: 1164:      case PrintConversion::None:
        -: 1165:        break;
        -: 1166:      }
    #####: 1167:      emitCall(rewriter, loc, printer, value);
call    0 never executed
call    1 never executed
    #####: 1168:      return;
        -: 1169:    }
        -: 1170:
    #####: 1171:    emitCall(rewriter, loc,
call    0 never executed
call    1 never executed
    #####: 1172:             LLVM::lookupOrCreatePrintOpenFn(op->getParentOfType<ModuleOp>()));
call    0 never executed
call    1 never executed
    #####: 1173:    Operation *printComma =
    #####: 1174:        LLVM::lookupOrCreatePrintCommaFn(op->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1175:
    #####: 1176:    if (rank <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1177:      auto reducedType = vectorType.getElementType();
call    0 never executed
    #####: 1178:      auto llvmType = typeConverter->convertType(reducedType);
call    0 never executed
    #####: 1179:      int64_t dim = rank == 0 ? 1 : vectorType.getDimSize(0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1180:      for (int64_t d = 0; d < dim; ++d) {
branch  0 never executed
branch  1 never executed
    #####: 1181:        Value nestedVal = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 never executed
    #####: 1182:                                     llvmType, /*rank=*/0, /*pos=*/d);
call    0 never executed
    #####: 1183:        emitRanks(rewriter, op, nestedVal, reducedType, printer, /*rank=*/0,
call    0 never executed
        -: 1184:                  conversion);
    #####: 1185:        if (d != dim - 1)
branch  0 never executed
branch  1 never executed
    #####: 1186:          emitCall(rewriter, loc, printComma);
call    0 never executed
call    1 never executed
        -: 1187:      }
    #####: 1188:      emitCall(
call    0 never executed
call    1 never executed
        -: 1189:          rewriter, loc,
    #####: 1190:          LLVM::lookupOrCreatePrintCloseFn(op->getParentOfType<ModuleOp>()));
call    0 never executed
call    1 never executed
    #####: 1191:      return;
        -: 1192:    }
        -: 1193:
    #####: 1194:    int64_t dim = vectorType.getDimSize(0);
    #####: 1195:    for (int64_t d = 0; d < dim; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1196:      auto reducedType = reducedVectorTypeFront(vectorType);
call    0 never executed
    #####: 1197:      auto llvmType = typeConverter->convertType(reducedType);
call    0 never executed
    #####: 1198:      Value nestedVal = extractOne(rewriter, *getTypeConverter(), loc, value,
call    0 never executed
    #####: 1199:                                   llvmType, rank, d);
call    0 never executed
    #####: 1200:      emitRanks(rewriter, op, nestedVal, reducedType, printer, rank - 1,
call    0 never executed
        -: 1201:                conversion);
    #####: 1202:      if (d != dim - 1)
branch  0 never executed
branch  1 never executed
    #####: 1203:        emitCall(rewriter, loc, printComma);
call    0 never executed
call    1 never executed
        -: 1204:    }
    #####: 1205:    emitCall(rewriter, loc,
call    0 never executed
call    1 never executed
    #####: 1206:             LLVM::lookupOrCreatePrintCloseFn(op->getParentOfType<ModuleOp>()));
call    0 never executed
call    1 never executed
        -: 1207:  }
        -: 1208:
        -: 1209:  // Helper to emit a call.
function _ZN12_GLOBAL__N_123VectorPrintOpConversion8emitCallERN4mlir25ConversionPatternRewriterENS1_8LocationEPNS1_9OperationENS1_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1210:  static void emitCall(ConversionPatternRewriter &rewriter, Location loc,
        -: 1211:                       Operation *ref, ValueRange params = ValueRange()) {
    #####: 1212:    rewriter.create<LLVM::CallOp>(loc, TypeRange(), SymbolRefAttr::get(ref),
call    0 never executed
    #####: 1213:                                  params);
call    0 never executed
call    1 never executed
    #####: 1214:  }
        -: 1215:};
        -: 1216:
        -: 1217:/// The Splat operation is lowered to an insertelement + a shufflevector
        -: 1218:/// operation. Splat to only 0-d and 1-d vector result types are lowered.
        -: 1219:struct VectorSplatOpLowering : public ConvertOpToLLVMPattern<vector::SplatOp> {
     1773: 1220:  using ConvertOpToLLVMPattern<vector::SplatOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1221:
        -: 1222:  LogicalResult
function _ZNK12_GLOBAL__N_121VectorSplatOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1223:  matchAndRewrite(vector::SplatOp splatOp, OpAdaptor adaptor,
        -: 1224:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1225:    VectorType resultType = splatOp.getType().cast<VectorType>();
call    0 never executed
call    1 never executed
    #####: 1226:    if (resultType.getRank() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1227:      return failure();
        -: 1228:
        -: 1229:    // First insert it into an undef vector so we can shuffle it.
    #####: 1230:    auto vectorType = typeConverter->convertType(splatOp.getType());
call    0 never executed
call    1 never executed
    #####: 1231:    Value undef = rewriter.create<LLVM::UndefOp>(splatOp.getLoc(), vectorType);
call    0 never executed
call    1 never executed
    #####: 1232:    auto zero = rewriter.create<LLVM::ConstantOp>(
        -: 1233:        splatOp.getLoc(),
    #####: 1234:        typeConverter->convertType(rewriter.getIntegerType(32)),
call    0 never executed
call    1 never executed
    #####: 1235:        rewriter.getZeroAttr(rewriter.getIntegerType(32)));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1236:
        -: 1237:    // For 0-d vector, we simply do `insertelement`.
    #####: 1238:    if (resultType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1239:      rewriter.replaceOpWithNewOp<LLVM::InsertElementOp>(
    #####: 1240:          splatOp, vectorType, undef, adaptor.getInput(), zero);
call    0 never executed
call    1 never executed
    #####: 1241:      return success();
        -: 1242:    }
        -: 1243:
        -: 1244:    // For 1-d vector, we additionally do a `vectorshuffle`.
    #####: 1245:    auto v = rewriter.create<LLVM::InsertElementOp>(
    #####: 1246:        splatOp.getLoc(), vectorType, undef, adaptor.getInput(), zero);
call    0 never executed
call    1 never executed
        -: 1247:
    #####: 1248:    int64_t width = splatOp.getType().cast<VectorType>().getDimSize(0);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1249:    SmallVector<int32_t> zeroValues(width, 0);
call    0 never executed
        -: 1250:
        -: 1251:    // Shuffle the value across the desired number of elements.
    #####: 1252:    rewriter.replaceOpWithNewOp<LLVM::ShuffleVectorOp>(splatOp, v, undef,
    #####: 1253:                                                       zeroValues);
call    0 never executed
    #####: 1254:    return success();
branch  0 never executed
branch  1 never executed
        -: 1255:  }
        -: 1256:};
        -: 1257:
        -: 1258:/// The Splat operation is lowered to an insertelement + a shufflevector
        -: 1259:/// operation. Splat to only 2+-d vector result types are lowered by the
        -: 1260:/// SplatNdOpLowering, the 1-d case is handled by SplatOpLowering.
        -: 1261:struct VectorSplatNdOpLowering : public ConvertOpToLLVMPattern<SplatOp> {
     1773: 1262:  using ConvertOpToLLVMPattern<SplatOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1263:
        -: 1264:  LogicalResult
function _ZNK12_GLOBAL__N_123VectorSplatNdOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1265:  matchAndRewrite(SplatOp splatOp, OpAdaptor adaptor,
        -: 1266:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1267:    VectorType resultType = splatOp.getType();
call    0 never executed
    #####: 1268:    if (resultType.getRank() <= 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1269:      return failure();
        -: 1270:
        -: 1271:    // First insert it into an undef vector so we can shuffle it.
    #####: 1272:    auto loc = splatOp.getLoc();
call    0 never executed
    #####: 1273:    auto vectorTypeInfo =
    #####: 1274:        LLVM::detail::extractNDVectorTypeInfo(resultType, *getTypeConverter());
call    0 never executed
call    1 never executed
    #####: 1275:    auto llvmNDVectorTy = vectorTypeInfo.llvmNDVectorTy;
    #####: 1276:    auto llvm1DVectorTy = vectorTypeInfo.llvm1DVectorTy;
    #####: 1277:    if (!llvmNDVectorTy || !llvm1DVectorTy)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1278:      return failure();
        -: 1279:
        -: 1280:    // Construct returned value.
    #####: 1281:    Value desc = rewriter.create<LLVM::UndefOp>(loc, llvmNDVectorTy);
call    0 never executed
call    1 never executed
        -: 1282:
        -: 1283:    // Construct a 1-D vector with the splatted value that we insert in all the
        -: 1284:    // places within the returned descriptor.
    #####: 1285:    Value vdesc = rewriter.create<LLVM::UndefOp>(loc, llvm1DVectorTy);
call    0 never executed
call    1 never executed
    #####: 1286:    auto zero = rewriter.create<LLVM::ConstantOp>(
    #####: 1287:        loc, typeConverter->convertType(rewriter.getIntegerType(32)),
call    0 never executed
call    1 never executed
    #####: 1288:        rewriter.getZeroAttr(rewriter.getIntegerType(32)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1289:    Value v = rewriter.create<LLVM::InsertElementOp>(loc, llvm1DVectorTy, vdesc,
    #####: 1290:                                                     adaptor.getInput(), zero);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1291:
        -: 1292:    // Shuffle the value across the desired number of elements.
    #####: 1293:    int64_t width = resultType.getDimSize(resultType.getRank() - 1);
call    0 never executed
call    1 never executed
    #####: 1294:    SmallVector<int32_t> zeroValues(width, 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1295:    v = rewriter.create<LLVM::ShuffleVectorOp>(loc, v, v, zeroValues);
call    0 never executed
call    1 never executed
        -: 1296:
        -: 1297:    // Iterate of linear index, convert to coords space and insert splatted 1-D
        -: 1298:    // vector in each position.
function _ZZNK12_GLOBAL__N_123VectorSplatNdOpLowering15matchAndRewriteEN4mlir6vector7SplatOpENS2_14SplatOpAdaptorERNS1_25ConversionPatternRewriterEENKUlN4llvm8ArrayRefIlEEE_clES9_ called 0 returned 0% blocks executed 0%
    #####: 1299:    nDVectorIterate(vectorTypeInfo, rewriter, [&](ArrayRef<int64_t> position) {
call    0 never executed
    #####: 1300:      desc = rewriter.create<LLVM::InsertValueOp>(loc, desc, v, position);
call    0 never executed
    #####: 1301:    });
    #####: 1302:    rewriter.replaceOp(splatOp, desc);
call    0 never executed
call    1 never executed
    #####: 1303:    return success();
branch  0 never executed
branch  1 never executed
        -: 1304:  }
        -: 1305:};
        -: 1306:
        -: 1307:} // namespace
        -: 1308:
        -: 1309:/// Populate the given list with patterns that convert from Vector to LLVM.
function _ZN4mlir38populateVectorToLLVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetEbb called 1773 returned 100% blocks executed 100%
     1773: 1310:void mlir::populateVectorToLLVMConversionPatterns(
        -: 1311:    LLVMTypeConverter &converter, RewritePatternSet &patterns,
        -: 1312:    bool reassociateFPReductions, bool force32BitVectorIndices) {
     1773: 1313:  MLIRContext *ctx = converter.getDialect()->getContext();
call    0 returned 100%
     1773: 1314:  patterns.add<VectorFMAOpNDRewritePattern>(ctx);
call    0 returned 100%
     1773: 1315:  populateVectorInsertExtractStridedSliceTransforms(patterns);
call    0 returned 100%
call    1 returned 100%
     1773: 1316:  patterns.add<VectorReductionOpConversion>(converter, reassociateFPReductions);
call    0 returned 100%
     1773: 1317:  patterns.add<VectorCreateMaskOpRewritePattern>(ctx, force32BitVectorIndices);
call    0 returned 100%
     1773: 1318:  patterns
        -: 1319:      .add<VectorBitCastOpConversion, VectorShuffleOpConversion,
        -: 1320:           VectorExtractElementOpConversion, VectorExtractOpConversion,
        -: 1321:           VectorFMAOp1DConversion, VectorInsertElementOpConversion,
        -: 1322:           VectorInsertOpConversion, VectorPrintOpConversion,
        -: 1323:           VectorTypeCastOpConversion, VectorScaleOpConversion,
        -: 1324:           VectorLoadStoreConversion<vector::LoadOp, vector::LoadOpAdaptor>,
        -: 1325:           VectorLoadStoreConversion<vector::MaskedLoadOp,
        -: 1326:                                     vector::MaskedLoadOpAdaptor>,
        -: 1327:           VectorLoadStoreConversion<vector::StoreOp, vector::StoreOpAdaptor>,
        -: 1328:           VectorLoadStoreConversion<vector::MaskedStoreOp,
        -: 1329:                                     vector::MaskedStoreOpAdaptor>,
        -: 1330:           VectorGatherOpConversion, VectorScatterOpConversion,
        -: 1331:           VectorExpandLoadOpConversion, VectorCompressStoreOpConversion,
     1773: 1332:           VectorSplatOpLowering, VectorSplatNdOpLowering>(converter);
call    0 returned 100%
        -: 1333:  // Transfer ops with rank > 1 are handled by VectorToSCF.
     1773: 1334:  populateVectorTransferLoweringPatterns(patterns, /*maxTransferRank=*/1);
call    0 returned 100%
call    1 returned 100%
     1773: 1335:}
        -: 1336:
function _ZN4mlir44populateVectorToLLVMMatrixConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 1752 returned 100% blocks executed 100%
     1752: 1337:void mlir::populateVectorToLLVMMatrixConversionPatterns(
        -: 1338:    LLVMTypeConverter &converter, RewritePatternSet &patterns) {
     1752: 1339:  patterns.add<VectorMatmulOpConversion>(converter);
call    0 returned 100%
     1752: 1340:  patterns.add<VectorFlatTransposeOpConversion>(converter);
call    0 returned 100%
     1752: 1341:}
