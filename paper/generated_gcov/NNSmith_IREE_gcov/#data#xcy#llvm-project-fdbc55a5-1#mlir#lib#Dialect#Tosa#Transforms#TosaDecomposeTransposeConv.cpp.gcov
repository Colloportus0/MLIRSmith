        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Tosa/Transforms/TosaDecomposeTransposeConv.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Tosa/Transforms/CMakeFiles/obj.MLIRTosaTransforms.dir/TosaDecomposeTransposeConv.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Tosa/Transforms/CMakeFiles/obj.MLIRTosaTransforms.dir/TosaDecomposeTransposeConv.cpp.gcda
        -:    0:Runs:325556
        -:    1://===- TosaDecomposeTransposeConv.cpp -------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Decompose TOSA TransposeConv operation to a series of TOSA Ops specifically
        -:   10:// (1) Convert a Dilated TransposeConv2D to Conv2D including reversing/reshaping
        -:   11:// etc.. of the weights (2) Convert a Strided TransposeConv2D to Conv2D
        -:   12:// including transposing/reversing/reshaping etc..
        -:   13://     of the weights and input/output tenors and reversing/reshaping etc .. of
        -:   14://     the weights
        -:   15://
        -:   16://===----------------------------------------------------------------------===//
        -:   17:
        -:   18:#include "mlir/Dialect/Tosa/IR/TosaOps.h"
        -:   19:#include "mlir/Dialect/Tosa/Transforms/Passes.h"
        -:   20:#include "mlir/Dialect/Tosa/Utils/ShapeUtils.h"
        -:   21:#include "mlir/Pass/Pass.h"
        -:   22:
        -:   23:using namespace mlir;
        -:   24:using namespace mlir::tosa;
        -:   25:
        -:   26:namespace {
        -:   27:
        -:   28:template <typename T>
function _ZN12_GLOBAL__N_1L30getValuesFromIntArrayAttributeIlEEvN4mlir9ArrayAttrERN4llvm11SmallVectorIT_XsrNS3_42CalculateSmallVectorDefaultInlinedElementsIS5_EE5valueEEE called 0 returned 0% blocks executed 0%
    #####:   29:static void getValuesFromIntArrayAttribute(ArrayAttr attr,
        -:   30:                                           SmallVector<T> &arrayValues) {
    #####:   31:  for (Attribute val : attr.getValue()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   32:    arrayValues.push_back(val.cast<IntegerAttr>().getValue().getSExtValue());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:   33:  }
    #####:   34:}
        -:   35:
        -:   36:template <typename TosaOp, typename... Args>
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
    #####:   43:  if (!shapeInterface)
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
    #####:   59:  auto predictedShape = returnedShapes[0];
    #####:   60:  auto currentKnowledge =
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
    #####:   68:  if (predictedShape.hasRank()) {
    #####:   69:    for (auto dim : predictedShape.getDims()) {
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
    #####:   78:  result.setType(newTy);
    #####:   79:  return op;
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5AddOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5AddOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa7SliceOpEJRNS1_5ValueENS1_9ArrayAttrES6_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa7SliceOpEJRNS1_5ValueENS1_9ArrayAttrES6_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa8Conv2DOpEJRNS1_5ValueES5_RNS2_7ConstOpENS1_9ArrayAttrES8_S8_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa8Conv2DOpEJRNS1_5ValueES5_RNS2_7ConstOpENS1_9ArrayAttrES8_S8_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa8Conv2DOpEJRNS1_5ValueES5_RNS2_7ConstOpENS1_9ArrayAttrES8_S8_NS2_22ConvOpQuantizationAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa8Conv2DOpEJRNS1_5ValueES5_RNS2_7ConstOpENS1_9ArrayAttrES8_S8_NS2_22ConvOpQuantizationAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa9ReverseOpEJRNS1_5ValueENS1_11IntegerAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa9ReverseOpEJRNS1_5ValueENS1_11IntegerAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa11TransposeOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa11TransposeOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa9ReshapeOpEJRNS1_5ValueENS1_9ArrayAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa9ReshapeOpEJRNS1_5ValueENS1_9ArrayAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5PadOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5PadOpEJRNS1_5ValueES5_EEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5PadOpEJRNS1_5ValueES5_DnNS2_21PadOpQuantizationAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa5PadOpEJRNS1_5ValueES5_DnNS2_21PadOpQuantizationAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
_ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa7ConstOpEJRNS1_17DenseElementsAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_:
function _ZN12_GLOBAL__N_116createOpAndInferIN4mlir4tosa7ConstOpEJRNS1_17DenseElementsAttrEEEET_RNS1_15PatternRewriterENS1_8LocationENS1_4TypeEDpOT0_ called 0 returned 0% blocks executed 0%
    #####:   37:TosaOp createOpAndInfer(PatternRewriter &rewriter, Location loc, Type resultTy,
        -:   38:                        Args &&...args) {
    #####:   39:  auto op = rewriter.create<TosaOp>(loc, resultTy, args...);
call    0 never executed
        -:   40:
        -:   41:  InferShapedTypeOpInterface shapeInterface =
    #####:   42:      dyn_cast<InferShapedTypeOpInterface>(op.getOperation());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   43:  if (!shapeInterface)
branch  0 never executed
branch  1 never executed
    #####:   44:    return op;
        -:   45:
    #####:   46:  SmallVector<ShapedTypeComponents> returnedShapes;
    #####:   47:  if (shapeInterface
branch  0 never executed
branch  1 never executed
        -:   48:          .inferReturnTypeComponents(op.getContext(), op.getLoc(),
        -:   49:                                     op->getOperands(), op->getAttrDictionary(),
        -:   50:                                     op->getRegions(), returnedShapes)
    #####:   51:          .failed())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   52:    return op;
        -:   53:
        -:   54:  // We need to use the element type of the existing result type to generate
        -:   55:  // the new result shaped type. This is because rescale can include a cast to
        -:   56:  // different bit-width types and does not have a TypeAttr to define the
        -:   57:  // target type.
    #####:   58:  auto result = op->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:   59:  auto predictedShape = returnedShapes[0];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   60:  auto currentKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   61:      mlir::tosa::ValueKnowledge::getKnowledgeFromType(resultTy);
        -:   62:
        -:   63:  // Compute the knowledge based on the inferred type.
    #####:   64:  auto inferredKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   65:      mlir::tosa::ValueKnowledge::getPessimisticValueState();
    #####:   66:  inferredKnowledge.dtype = resultTy.cast<ShapedType>().getElementType();
call    0 never executed
    #####:   67:  inferredKnowledge.hasRank = predictedShape.hasRank();
branch  0 never executed
branch  1 never executed
    #####:   68:  if (predictedShape.hasRank()) {
branch  0 never executed
branch  1 never executed
    #####:   69:    for (auto dim : predictedShape.getDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   70:      inferredKnowledge.sizes.push_back(dim);
call    0 never executed
        -:   71:    }
        -:   72:  }
        -:   73:
        -:   74:  // Compute the new type based on the joined version.
    #####:   75:  auto newKnowledge =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   76:      mlir::tosa::ValueKnowledge::join(currentKnowledge, inferredKnowledge);
    #####:   77:  auto newTy = newKnowledge.getType();
call    0 never executed
    #####:   78:  result.setType(newTy);
call    0 never executed
    #####:   79:  return op;
branch  0 never executed
branch  1 never executed
        -:   80:}
------------------
        -:   81:
        -:   82:class TransposeConvNonStridedConverter
        -:   83:    : public OpRewritePattern<tosa::TransposeConv2DOp> {
        -:   84:public:
        -:   85:  using OpRewritePattern<tosa::TransposeConv2DOp>::OpRewritePattern;
function _ZNK12_GLOBAL__N_132TransposeConvNonStridedConverter15matchAndRewriteEN4mlir4tosa17TransposeConv2DOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   86:  LogicalResult matchAndRewrite(tosa::TransposeConv2DOp op,
        -:   87:                                PatternRewriter &rewriter) const final {
    #####:   88:    Location loc = op->getLoc();
call    0 never executed
    #####:   89:    Value input = op->getOperand(0);
call    0 never executed
    #####:   90:    Value weight = op->getOperand(1);
call    0 never executed
    #####:   91:    Value bias = op->getOperand(2);
call    0 never executed
        -:   92:
    #####:   93:    ShapedType inputTy = input.getType().cast<ShapedType>();
call    0 never executed
    #####:   94:    ShapedType weightTy = weight.getType().cast<ShapedType>();
call    0 never executed
    #####:   95:    ShapedType biasTy = bias.getType().cast<ShapedType>();
call    0 never executed
    #####:   96:    ShapedType resultTy = op->getResult(0).getType().cast<ShapedType>();
call    0 never executed
        -:   97:
    #####:   98:    llvm::SmallVector<int64_t> pad;
call    0 never executed
    #####:   99:    llvm::SmallVector<int64_t> stride;
branch  0 never executed
branch  1 never executed
        -:  100:
    #####:  101:    getValuesFromIntArrayAttribute(op.getOutPad().cast<ArrayAttr>(), pad);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  102:    getValuesFromIntArrayAttribute(op.getStride().cast<ArrayAttr>(), stride);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  103:
        -:  104:    // If striding is all 1 we can modify padding and reverse the kernel along
        -:  105:    // the x/y direction to make it a regular convolution. This is much simpler
        -:  106:    // then handling striding....
    #####:  107:    if (llvm::any_of(stride, [](int64_t v) { return v != 1; }))
branch  0 never executed
branch  1 never executed
    #####:  108:      return failure();
        -:  109:
    #####:  110:    if (!inputTy.hasStaticShape() || !weightTy.hasStaticShape() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  111:        !biasTy.hasStaticShape() || !resultTy.hasStaticShape())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  112:      return failure();
        -:  113:
    #####:  114:    int64_t kernelHeight = weightTy.getDimSize(1);
call    0 never executed
    #####:  115:    int64_t kernelWidth = weightTy.getDimSize(2);
call    0 never executed
        -:  116:
    #####:  117:    llvm::SmallVector<int64_t> convPad(4, 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  118:    convPad[0] = kernelHeight - 1 - pad[0];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  119:    convPad[1] = kernelHeight - 1 - pad[1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  120:    convPad[2] = kernelWidth - 1 - pad[2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  121:    convPad[3] = kernelWidth - 1 - pad[3];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  122:
    #####:  123:    auto reverse1 = rewriter.create<tosa::ReverseOp>(
    #####:  124:        loc, weightTy, weight, rewriter.getI64IntegerAttr(1));
call    0 never executed
call    1 never executed
    #####:  125:    auto reverse2 = rewriter.create<tosa::ReverseOp>(
    #####:  126:        loc, weightTy, reverse1, rewriter.getI64IntegerAttr(2));
call    0 never executed
call    1 never executed
        -:  127:
    #####:  128:    Value conv2d;
    #####:  129:    if (op.getQuantizationInfo()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  130:      conv2d = rewriter.create<tosa::Conv2DOp>(
        -:  131:          loc, resultTy, input, reverse2, bias,
    #####:  132:          rewriter.getI64ArrayAttr(convPad), rewriter.getI64ArrayAttr(stride),
call    0 never executed
call    1 never executed
    #####:  133:          rewriter.getI64ArrayAttr({1, 1}), *op.getQuantizationInfo());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  134:    } else {
    #####:  135:      conv2d = rewriter.create<tosa::Conv2DOp>(
        -:  136:          loc, resultTy, input, reverse2, bias,
    #####:  137:          rewriter.getI64ArrayAttr(convPad), rewriter.getI64ArrayAttr(stride),
call    0 never executed
call    1 never executed
    #####:  138:          rewriter.getI64ArrayAttr({1, 1}));
call    0 never executed
call    1 never executed
        -:  139:    }
        -:  140:
    #####:  141:    rewriter.replaceOp(op, conv2d);
call    0 never executed
call    1 never executed
    #####:  142:    return success();
branch  0 never executed
branch  1 never executed
        -:  143:  }
        -:  144:};
        -:  145:
        -:  146:class TransposeConvStridedConverter
        -:  147:    : public OpRewritePattern<tosa::TransposeConv2DOp> {
        -:  148:public:
        -:  149:  using OpRewritePattern<tosa::TransposeConv2DOp>::OpRewritePattern;
function _ZNK12_GLOBAL__N_129TransposeConvStridedConverter15matchAndRewriteEN4mlir4tosa17TransposeConv2DOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  150:  LogicalResult matchAndRewrite(tosa::TransposeConv2DOp op,
        -:  151:                                PatternRewriter &rewriter) const final {
    #####:  152:    Location loc = op->getLoc();
call    0 never executed
    #####:  153:    Value input = op->getOperand(0);
call    0 never executed
    #####:  154:    Value weight = op->getOperand(1);
call    0 never executed
    #####:  155:    Value bias = op->getOperand(2);
call    0 never executed
        -:  156:
    #####:  157:    ShapedType inputTy = input.getType().cast<ShapedType>();
call    0 never executed
    #####:  158:    ShapedType weightTy = weight.getType().cast<ShapedType>();
call    0 never executed
    #####:  159:    ShapedType biasTy = bias.getType().cast<ShapedType>();
call    0 never executed
    #####:  160:    ShapedType resultTy = op->getResult(0).getType().cast<ShapedType>();
call    0 never executed
        -:  161:
    #####:  162:    Type inputETy = inputTy.getElementType();
call    0 never executed
    #####:  163:    Type weightETy = weightTy.getElementType();
call    0 never executed
    #####:  164:    Type biasETy = biasTy.getElementType();
call    0 never executed
    #####:  165:    Type resultETy = resultTy.getElementType();
call    0 never executed
        -:  166:
    #####:  167:    llvm::SmallVector<int64_t> pad;
call    0 never executed
    #####:  168:    llvm::SmallVector<int64_t> stride;
branch  0 never executed
branch  1 never executed
        -:  169:
    #####:  170:    getValuesFromIntArrayAttribute(op.getOutPad().cast<ArrayAttr>(), pad);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  171:    getValuesFromIntArrayAttribute(op.getStride().cast<ArrayAttr>(), stride);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  172:
        -:  173:    // If striding is all 1 we can modify padding and reverse the kernel along
        -:  174:    // the x/y direction to make it a regular convolution. This is much simpler
        -:  175:    // then handling striding....
        -:  176:
        -:  177:    // If strides are all 1 we dont need to use this one.
    #####:  178:    if (llvm::all_of(stride, [](int64_t v) { return v == 1; }))
branch  0 never executed
branch  1 never executed
    #####:  179:      return failure();
        -:  180:
    #####:  181:    if (!inputTy.hasStaticShape() || !weightTy.hasStaticShape() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  182:        !biasTy.hasStaticShape() || !resultTy.hasStaticShape())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  183:      return failure();
        -:  184:
    #####:  185:    int64_t batch = inputTy.getDimSize(0);
call    0 never executed
        -:  186:
    #####:  187:    int64_t outputChannels = weightTy.getDimSize(0);
call    0 never executed
    #####:  188:    int64_t weightHeight = weightTy.getDimSize(1);
call    0 never executed
    #####:  189:    int64_t weightWidth = weightTy.getDimSize(2);
call    0 never executed
    #####:  190:    int64_t inputChannels = weightTy.getDimSize(3);
call    0 never executed
        -:  191:
        -:  192:    // Pad the weight so that it is modulo of the striding.
    #####:  193:    llvm::SmallVector<int32_t, 8> weightPadding = {0, 0, 0, 0, 0, 0, 0, 0};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:    weightPadding[3] =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  195:        weightHeight % stride[0] ? stride[0] - weightHeight % stride[0] : 0;
branch  0 never executed
branch  1 never executed
    #####:  196:    weightPadding[5] =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  197:        weightWidth % stride[1] ? stride[1] - weightWidth % stride[1] : 0;
branch  0 never executed
branch  1 never executed
    #####:  198:    DenseElementsAttr weightPaddingAttr = DenseIntElementsAttr::get(
    #####:  199:        RankedTensorType::get({4, 2}, rewriter.getI32Type()), weightPadding);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  200:    Value weightPaddingVal = createOpAndInfer<tosa::ConstOp>(
    #####:  201:        rewriter, loc, weightPaddingAttr.getType(), weightPaddingAttr);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  202:
    #####:  203:    if (op.getQuantizationInfo().has_value()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  204:      auto quantInfo = op.getQuantizationInfo().value();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  205:      weight = createOpAndInfer<tosa::PadOp>(
    #####:  206:          rewriter, loc, UnrankedTensorType::get(weightETy), weight,
    #####:  207:          weightPaddingVal, nullptr,
    #####:  208:          rewriter.getAttr<PadOpQuantizationAttr>(quantInfo.getWeightZp()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  209:
        -:  210:    } else {
    #####:  211:      weight = createOpAndInfer<tosa::PadOp>(rewriter, loc,
    #####:  212:                                             UnrankedTensorType::get(weightETy),
call    0 never executed
    #####:  213:                                             weight, weightPaddingVal);
call    0 never executed
        -:  214:    }
        -:  215:
    #####:  216:    weightTy = weight.getType().cast<ShapedType>();
call    0 never executed
    #####:  217:    weightHeight = weightTy.getDimSize(1);
call    0 never executed
    #####:  218:    weightWidth = weightTy.getDimSize(2);
call    0 never executed
        -:  219:
        -:  220:    // Split out the width / height by the stride dimensions.
    #####:  221:    llvm::SmallVector<int64_t, 6> weightReshapeDims0 = {
    #####:  222:        outputChannels, weightHeight / stride[0],
    #####:  223:        stride[0],      weightWidth / stride[1],
branch  0 never executed
branch  1 never executed
    #####:  224:        stride[1],      inputChannels};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  225:    weight = createOpAndInfer<tosa::ReshapeOp>(
    #####:  226:        rewriter, loc, UnrankedTensorType::get(weightETy), weight,
call    0 never executed
    #####:  227:        rewriter.getI64ArrayAttr(weightReshapeDims0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  228:
        -:  229:    // Transpose the factored-out stride to the output channels.
    #####:  230:    Value transposeWeightVal = rewriter.create<tosa::ConstOp>(
    #####:  231:        loc, RankedTensorType::get({6}, rewriter.getI32Type()),
call    0 never executed
call    1 never executed
    #####:  232:        rewriter.getI32TensorAttr({2, 4, 0, 1, 3, 5}));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  233:
    #####:  234:    weight = createOpAndInfer<tosa::TransposeOp>(
    #####:  235:        rewriter, loc, UnrankedTensorType::get(weightETy), weight,
call    0 never executed
    #####:  236:        transposeWeightVal);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  237:
        -:  238:    // Collapse the strides and output channels into a single dimension.
    #####:  239:    llvm::SmallVector<int64_t, 6> weightReshapeDims1 = {
branch  0 never executed
branch  1 never executed
    #####:  240:        outputChannels * stride[0] * stride[1], weightHeight / stride[0],
branch  0 never executed
branch  1 never executed
    #####:  241:        weightWidth / stride[1], inputChannels};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  242:    weight = createOpAndInfer<tosa::ReshapeOp>(
    #####:  243:        rewriter, loc, UnrankedTensorType::get(weightETy), weight,
call    0 never executed
    #####:  244:        rewriter.getI64ArrayAttr(weightReshapeDims1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  245:    ShapedType restridedWeightTy = weight.getType().cast<ShapedType>();
call    0 never executed
        -:  246:
    #####:  247:    weight = createOpAndInfer<tosa::ReverseOp>(
    #####:  248:        rewriter, loc, UnrankedTensorType::get(weightETy), weight,
call    0 never executed
    #####:  249:        rewriter.getI64IntegerAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  250:    weight = createOpAndInfer<tosa::ReverseOp>(
    #####:  251:        rewriter, loc, UnrankedTensorType::get(weightETy), weight,
call    0 never executed
    #####:  252:        rewriter.getI64IntegerAttr(2));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  253:
        -:  254:    // We need to pad the input far enough that we can pull all values.
    #####:  255:    llvm::SmallVector<int32_t, 8> inputPadding = {0, 0, 0, 0, 0, 0, 0, 0};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  256:    inputPadding[2] += restridedWeightTy.getDimSize(1) - 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  257:    inputPadding[3] += restridedWeightTy.getDimSize(1) - 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  258:    inputPadding[4] += restridedWeightTy.getDimSize(2) - 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  259:    inputPadding[5] += restridedWeightTy.getDimSize(2) - 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  260:
    #####:  261:    DenseElementsAttr inputPaddingAttr = DenseIntElementsAttr::get(
    #####:  262:        RankedTensorType::get({4, 2}, rewriter.getI32Type()), inputPadding);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  263:
    #####:  264:    Value inputPaddingVal = createOpAndInfer<tosa::ConstOp>(
    #####:  265:        rewriter, loc, inputPaddingAttr.getType(), inputPaddingAttr);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  266:
    #####:  267:    if (op.getQuantizationInfo().has_value()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  268:      auto quantInfo = op.getQuantizationInfo().value();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  269:      input = createOpAndInfer<tosa::PadOp>(
    #####:  270:          rewriter, loc, UnrankedTensorType::get(inputETy), input,
    #####:  271:          inputPaddingVal, nullptr,
    #####:  272:          rewriter.getAttr<PadOpQuantizationAttr>(quantInfo.getInputZp()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  273:    } else {
    #####:  274:      input = createOpAndInfer<tosa::PadOp>(rewriter, loc,
    #####:  275:                                            UnrankedTensorType::get(inputETy),
call    0 never executed
    #####:  276:                                            input, inputPaddingVal);
call    0 never executed
        -:  277:    }
        -:  278:
        -:  279:    // We use a zero bias as we need to broadcast the bias.
    #####:  280:    auto zeroBias = rewriter.create<tosa::ConstOp>(
        -:  281:        loc,
    #####:  282:        RankedTensorType::get({outputChannels * stride[0] * stride[1]},
branch  0 never executed
branch  1 never executed
    #####:  283:                              biasETy),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  284:        DenseElementsAttr::get(
    #####:  285:            RankedTensorType::get({outputChannels * stride[0] * stride[1]},
branch  0 never executed
branch  1 never executed
    #####:  286:                                  biasETy),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  287:            rewriter.getZeroAttr(biasETy)));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  288:
        -:  289:    // Perform the convolution using the zero bias.
    #####:  290:    Value conv2d;
    #####:  291:    if (op.getQuantizationInfo()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  292:      conv2d = createOpAndInfer<tosa::Conv2DOp>(
    #####:  293:                   rewriter, loc, UnrankedTensorType::get(resultETy), input,
call    0 never executed
        -:  294:                   weight, zeroBias,
    #####:  295:                   /*pad=*/rewriter.getI64ArrayAttr({0, 0, 0, 0}),
call    0 never executed
    #####:  296:                   /*stride=*/rewriter.getI64ArrayAttr({1, 1}),
call    0 never executed
    #####:  297:                   /*dilation=*/rewriter.getI64ArrayAttr({1, 1}),
    #####:  298:                   *op.getQuantizationInfo())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  299:                   .getResult();
        -:  300:    } else {
    #####:  301:      conv2d = createOpAndInfer<tosa::Conv2DOp>(
    #####:  302:                   rewriter, loc, UnrankedTensorType::get(resultETy), input,
call    0 never executed
        -:  303:                   weight, zeroBias,
    #####:  304:                   /*pad=*/rewriter.getI64ArrayAttr({0, 0, 0, 0}),
call    0 never executed
    #####:  305:                   /*stride=*/rewriter.getI64ArrayAttr({1, 1}),
call    0 never executed
    #####:  306:                   /*dilation=*/rewriter.getI64ArrayAttr({1, 1}))
call    0 never executed
call    1 never executed
    #####:  307:                   .getResult();
        -:  308:    }
        -:  309:
        -:  310:    // Factor the resulting width / height.
    #####:  311:    ShapedType convTy = conv2d.getType().cast<ShapedType>();
call    0 never executed
    #####:  312:    Type convETy = convTy.getElementType();
call    0 never executed
        -:  313:
    #####:  314:    int64_t convHeight = convTy.getDimSize(1);
call    0 never executed
    #####:  315:    int64_t convWidth = convTy.getDimSize(2);
call    0 never executed
        -:  316:
        -:  317:    // Factor striding out of the convolution result.
    #####:  318:    llvm::SmallVector<int64_t, 6> convReshapeDims0 = {
    #####:  319:        batch, convHeight, convWidth, stride[0], stride[1], outputChannels};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  320:    conv2d = createOpAndInfer<tosa::ReshapeOp>(
    #####:  321:        rewriter, loc, UnrankedTensorType::get(resultETy), conv2d,
call    0 never executed
    #####:  322:        rewriter.getI64ArrayAttr(convReshapeDims0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  323:
        -:  324:    // Transpose the factored-out stride to the output channels.
    #####:  325:    Value transposeConvVal = rewriter.create<tosa::ConstOp>(
    #####:  326:        loc, RankedTensorType::get({6}, rewriter.getI32Type()),
call    0 never executed
call    1 never executed
    #####:  327:        rewriter.getI32TensorAttr({0, 1, 3, 2, 4, 5}));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  328:
    #####:  329:    conv2d = createOpAndInfer<tosa::TransposeOp>(
    #####:  330:        rewriter, loc, UnrankedTensorType::get(convETy), conv2d,
call    0 never executed
    #####:  331:        transposeConvVal);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  332:
        -:  333:    // Fuse striding behavior back into width / height.
    #####:  334:    llvm::SmallVector<int64_t, 6> convReshapeDims1 = {
    #####:  335:        batch, convHeight * stride[0], convWidth * stride[1], outputChannels};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  336:    conv2d = createOpAndInfer<tosa::ReshapeOp>(
    #####:  337:        rewriter, loc, UnrankedTensorType::get(resultETy), conv2d,
call    0 never executed
    #####:  338:        rewriter.getI64ArrayAttr(convReshapeDims1));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  339:
        -:  340:    // Slice out the final result.
    #####:  341:    llvm::SmallVector<int64_t, 4> sliceBegin = {0, 0, 0, 0};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  342:    llvm::SmallVector<int64_t, 4> sliceSize(resultTy.getShape().begin(),
call    0 never executed
    #####:  343:                                            resultTy.getShape().begin());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  344:    sliceBegin[1] = pad[0];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  345:    sliceBegin[2] = pad[2];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  346:
    #####:  347:    auto slice = createOpAndInfer<tosa::SliceOp>(
    #####:  348:                     rewriter, loc, UnrankedTensorType::get(resultETy), conv2d,
call    0 never executed
    #####:  349:                     rewriter.getI64ArrayAttr(sliceBegin),
call    0 never executed
    #####:  350:                     rewriter.getI64ArrayAttr(resultTy.getShape()))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  351:                     .getResult();
        -:  352:
    #####:  353:    auto addBias =
call    0 never executed
    #####:  354:        createOpAndInfer<tosa::AddOp>(rewriter, loc, op.getType(), slice, bias);
call    0 never executed
        -:  355:
    #####:  356:    rewriter.replaceOp(op, addBias.getResult());
call    0 never executed
call    1 never executed
        -:  357:
    #####:  358:    return success();
branch  0 never executed
branch  1 never executed
        -:  359:  }
        -:  360:};
        -:  361:
        -:  362:} // namespace
        -:  363:
function _ZN4mlir4tosa34populateTosaDecomposeTransposeConvEPNS_11MLIRContextERNS_17RewritePatternSetE called 955 returned 99% blocks executed 100%
      955:  364:void mlir::tosa::populateTosaDecomposeTransposeConv(
        -:  365:    MLIRContext *ctx, RewritePatternSet &patterns) {
      955:  366:  patterns.add<TransposeConvNonStridedConverter>(ctx);
call    0 returned 99%
      946:  367:  patterns.add<TransposeConvStridedConverter>(ctx);
call    0 returned 100%
      945:  368:}
