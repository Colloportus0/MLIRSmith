        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Target/SPIRV/Serialization/SerializeOps.cpp
        -:    0:Graph:../tools/mlir/lib/Target/SPIRV/Serialization/CMakeFiles/obj.MLIRSPIRVSerialization.dir/SerializeOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/SPIRV/Serialization/CMakeFiles/obj.MLIRSPIRVSerialization.dir/SerializeOps.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- SerializeOps.cpp - MLIR SPIR-V Serialization (Ops) -----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the serialization methods for MLIR SPIR-V module ops.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "Serializer.h"
        -:   14:
        -:   15:#include "mlir/Dialect/SPIRV/IR/SPIRVAttributes.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVEnums.h"
        -:   17:#include "mlir/IR/RegionGraphTraits.h"
        -:   18:#include "mlir/Support/LogicalResult.h"
        -:   19:#include "mlir/Target/SPIRV/SPIRVBinaryUtils.h"
        -:   20:#include "llvm/ADT/DepthFirstIterator.h"
        -:   21:#include "llvm/Support/Debug.h"
        -:   22:
        -:   23:#define DEBUG_TYPE "spirv-serialization"
        -:   24:
        -:   25:using namespace mlir;
        -:   26:
        -:   27:/// A pre-order depth-first visitor function for processing basic blocks.
        -:   28:///
        -:   29:/// Visits the basic blocks starting from the given `headerBlock` in pre-order
        -:   30:/// depth-first manner and calls `blockHandler` on each block. Skips handling
        -:   31:/// blocks in the `skipBlocks` list. If `skipHeader` is true, `blockHandler`
        -:   32:/// will not be invoked in `headerBlock` but still handles all `headerBlock`'s
        -:   33:/// successors.
        -:   34:///
        -:   35:/// SPIR-V spec "2.16.1. Universal Validation Rules" requires that "the order
        -:   36:/// of blocks in a function must satisfy the rule that blocks appear before
        -:   37:/// all blocks they dominate." This can be achieved by a pre-order CFG
        -:   38:/// traversal algorithm. To make the serialization output more logical and
        -:   39:/// readable to human, we perform depth-first CFG traversal and delay the
        -:   40:/// serialization of the merge block and the continue block, if exists, until
        -:   41:/// after all other blocks have been processed.
        -:   42:static LogicalResult
function _ZL23visitInPrettyBlockOrderPN4mlir5BlockEN4llvm12function_refIFNS_13LogicalResultES1_EEEbNS_10BlockRangeE called 0 returned 0% blocks executed 0%
    #####:   43:visitInPrettyBlockOrder(Block *headerBlock,
        -:   44:                        function_ref<LogicalResult(Block *)> blockHandler,
        -:   45:                        bool skipHeader = false, BlockRange skipBlocks = {}) {
    #####:   46:  llvm::df_iterator_default_set<Block *, 4> doneBlocks;
call    0 never executed
    #####:   47:  doneBlocks.insert(skipBlocks.begin(), skipBlocks.end());
call    0 never executed
        -:   48:
    #####:   49:  for (Block *block : llvm::depth_first_ext(headerBlock, doneBlocks)) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
    #####:   50:    if (skipHeader && block == headerBlock)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   51:      continue;
    #####:   52:    if (failed(blockHandler(block)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   53:      return failure();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   54:  }
    #####:   55:  return success();
branch  0 never executed
branch  1 never executed
        -:   56:}
        -:   57:
        -:   58:namespace mlir {
        -:   59:namespace spirv {
function _ZN4mlir5spirv10Serializer17processConstantOpENS0_10ConstantOpE called 0 returned 0% blocks executed 0%
    #####:   60:LogicalResult Serializer::processConstantOp(spirv::ConstantOp op) {
    #####:   61:  if (auto resultID =
    #####:   62:          prepareConstant(op.getLoc(), op.getType(), op.getValue())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   63:    valueIDMap[op.getResult()] = resultID;
call    0 never executed
    #####:   64:    return success();
        -:   65:  }
    #####:   66:  return failure();
        -:   67:}
        -:   68:
function _ZN4mlir5spirv10Serializer21processSpecConstantOpENS0_14SpecConstantOpE called 0 returned 0% blocks executed 0%
    #####:   69:LogicalResult Serializer::processSpecConstantOp(spirv::SpecConstantOp op) {
    #####:   70:  if (auto resultID = prepareConstantScalar(op.getLoc(), op.getDefaultValue(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   71:                                            /*isSpec=*/true)) {
        -:   72:    // Emit the OpDecorate instruction for SpecId.
    #####:   73:    if (auto specID = op->getAttrOfType<IntegerAttr>("spec_id")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   74:      auto val = static_cast<uint32_t>(specID.getInt());
call    0 never executed
    #####:   75:      if (failed(emitDecoration(resultID, spirv::Decoration::SpecId, {val})))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   76:        return failure();
        -:   77:    }
        -:   78:
    #####:   79:    specConstIDMap[op.getSymName()] = resultID;
call    0 never executed
call    1 never executed
    #####:   80:    return processName(resultID, op.getSymName());
call    0 never executed
call    1 never executed
        -:   81:  }
    #####:   82:  return failure();
        -:   83:}
        -:   84:
        -:   85:LogicalResult
function _ZN4mlir5spirv10Serializer30processSpecConstantCompositeOpENS0_23SpecConstantCompositeOpE called 0 returned 0% blocks executed 0%
    #####:   86:Serializer::processSpecConstantCompositeOp(spirv::SpecConstantCompositeOp op) {
    #####:   87:  uint32_t typeID = 0;
    #####:   88:  if (failed(processType(op.getLoc(), op.getType(), typeID))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   89:    return failure();
        -:   90:  }
        -:   91:
    #####:   92:  auto resultID = getNextID();
call    0 never executed
        -:   93:
    #####:   94:  SmallVector<uint32_t, 8> operands;
call    0 never executed
    #####:   95:  operands.push_back(typeID);
call    0 never executed
    #####:   96:  operands.push_back(resultID);
call    0 never executed
        -:   97:
    #####:   98:  auto constituents = op.getConstituents();
call    0 never executed
        -:   99:
    #####:  100:  for (auto index : llvm::seq<uint32_t>(0, constituents.size())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  101:    auto constituent = constituents[index].dyn_cast<FlatSymbolRefAttr>();
call    0 never executed
call    1 never executed
        -:  102:
    #####:  103:    auto constituentName = constituent.getValue();
call    0 never executed
    #####:  104:    auto constituentID = getSpecConstID(constituentName);
call    0 never executed
        -:  105:
    #####:  106:    if (!constituentID) {
branch  0 never executed
branch  1 never executed
    #####:  107:      return op.emitError("unknown result <id> for specialization constant ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  108:             << constituentName;
call    0 never executed
        -:  109:    }
        -:  110:
    #####:  111:    operands.push_back(constituentID);
call    0 never executed
        -:  112:  }
        -:  113:
    #####:  114:  encodeInstructionInto(typesGlobalValues,
call    0 never executed
        -:  115:                        spirv::Opcode::OpSpecConstantComposite, operands);
    #####:  116:  specConstIDMap[op.getSymName()] = resultID;
call    0 never executed
call    1 never executed
        -:  117:
    #####:  118:  return processName(resultID, op.getSymName());
call    0 never executed
call    1 never executed
        -:  119:}
        -:  120:
        -:  121:LogicalResult
function _ZN4mlir5spirv10Serializer30processSpecConstantOperationOpENS0_23SpecConstantOperationOpE called 0 returned 0% blocks executed 0%
    #####:  122:Serializer::processSpecConstantOperationOp(spirv::SpecConstantOperationOp op) {
    #####:  123:  uint32_t typeID = 0;
    #####:  124:  if (failed(processType(op.getLoc(), op.getType(), typeID))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  125:    return failure();
        -:  126:  }
        -:  127:
    #####:  128:  auto resultID = getNextID();
call    0 never executed
        -:  129:
    #####:  130:  SmallVector<uint32_t, 8> operands;
call    0 never executed
    #####:  131:  operands.push_back(typeID);
call    0 never executed
    #####:  132:  operands.push_back(resultID);
call    0 never executed
        -:  133:
    #####:  134:  Block &block = op.getRegion().getBlocks().front();
call    0 never executed
call    1 never executed
    #####:  135:  Operation &enclosedOp = block.getOperations().front();
call    0 never executed
        -:  136:
    #####:  137:  std::string enclosedOpName;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  138:  llvm::raw_string_ostream rss(enclosedOpName);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  139:  rss << "Op" << enclosedOp.getName().stripDialect();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  140:  auto enclosedOpcode = spirv::symbolizeOpcode(rss.str());
call    0 never executed
        -:  141:
    #####:  142:  if (!enclosedOpcode) {
branch  0 never executed
branch  1 never executed
    #####:  143:    op.emitError("Couldn't find op code for op ")
call    0 never executed
call    1 never executed
    #####:  144:        << enclosedOp.getName().getStringRef();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  145:    return failure();
        -:  146:  }
        -:  147:
    #####:  148:  operands.push_back(static_cast<uint32_t>(*enclosedOpcode));
call    0 never executed
        -:  149:
        -:  150:  // Append operands to the enclosed op to the list of operands.
    #####:  151:  for (Value operand : enclosedOp.getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  152:    uint32_t id = getValueID(operand);
call    0 never executed
    #####:  153:    assert(id && "use before def!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  154:    operands.push_back(id);
call    0 never executed
        -:  155:  }
        -:  156:
    #####:  157:  encodeInstructionInto(typesGlobalValues, spirv::Opcode::OpSpecConstantOp,
call    0 never executed
        -:  158:                        operands);
    #####:  159:  valueIDMap[op.getResult()] = resultID;
call    0 never executed
call    1 never executed
        -:  160:
    #####:  161:  return success();
call    0 never executed
        -:  162:}
        -:  163:
function _ZN4mlir5spirv10Serializer14processUndefOpENS0_7UndefOpE called 0 returned 0% blocks executed 0%
    #####:  164:LogicalResult Serializer::processUndefOp(spirv::UndefOp op) {
    #####:  165:  auto undefType = op.getType();
call    0 never executed
    #####:  166:  auto &id = undefValIDMap[undefType];
call    0 never executed
    #####:  167:  if (!id) {
branch  0 never executed
branch  1 never executed
    #####:  168:    id = getNextID();
call    0 never executed
    #####:  169:    uint32_t typeID = 0;
    #####:  170:    if (failed(processType(op.getLoc(), undefType, typeID)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  171:      return failure();
    #####:  172:    encodeInstructionInto(typesGlobalValues, spirv::Opcode::OpUndef,
    #####:  173:                          {typeID, id});
call    0 never executed
        -:  174:  }
    #####:  175:  valueIDMap[op.getResult()] = id;
call    0 never executed
call    1 never executed
    #####:  176:  return success();
        -:  177:}
        -:  178:
function _ZN4mlir5spirv10Serializer13processFuncOpENS0_6FuncOpE called 0 returned 0% blocks executed 0%
    #####:  179:LogicalResult Serializer::processFuncOp(spirv::FuncOp op) {
    #####:  180:  LLVM_DEBUG(llvm::dbgs() << "-- start function '" << op.getName() << "' --\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
    #####:  181:  assert(functionHeader.empty() && functionBody.empty());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  182:
    #####:  183:  uint32_t fnTypeID = 0;
        -:  184:  // Generate type of the function.
    #####:  185:  if (failed(processType(op.getLoc(), op.getFunctionType(), fnTypeID)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  186:    return failure();
        -:  187:
        -:  188:  // Add the function definition.
    #####:  189:  SmallVector<uint32_t, 4> operands;
call    0 never executed
    #####:  190:  uint32_t resTypeID = 0;
    #####:  191:  auto resultTypes = op.getFunctionType().getResults();
call    0 never executed
call    1 never executed
    #####:  192:  if (resultTypes.size() > 1) {
branch  0 never executed
branch  1 never executed
    #####:  193:    return op.emitError("cannot serialize function with multiple return types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  194:  }
    #####:  195:  if (failed(processType(op.getLoc(),
branch  0 never executed
branch  1 never executed
    #####:  196:                         (resultTypes.empty() ? getVoidType() : resultTypes[0]),
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  197:                         resTypeID))) {
    #####:  198:    return failure();
        -:  199:  }
    #####:  200:  operands.push_back(resTypeID);
call    0 never executed
    #####:  201:  auto funcID = getOrCreateFunctionID(op.getName());
call    0 never executed
call    1 never executed
    #####:  202:  operands.push_back(funcID);
call    0 never executed
    #####:  203:  operands.push_back(static_cast<uint32_t>(op.getFunctionControl()));
call    0 never executed
call    1 never executed
    #####:  204:  operands.push_back(fnTypeID);
call    0 never executed
    #####:  205:  encodeInstructionInto(functionHeader, spirv::Opcode::OpFunction, operands);
call    0 never executed
        -:  206:
        -:  207:  // Add function name.
    #####:  208:  if (failed(processName(funcID, op.getName()))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  209:    return failure();
        -:  210:  }
        -:  211:
        -:  212:  // Declare the parameters.
    #####:  213:  for (auto arg : op.getArguments()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:    uint32_t argTypeID = 0;
    #####:  215:    if (failed(processType(op.getLoc(), arg.getType(), argTypeID))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  216:      return failure();
        -:  217:    }
    #####:  218:    auto argValueID = getNextID();
call    0 never executed
    #####:  219:    valueIDMap[arg] = argValueID;
call    0 never executed
    #####:  220:    encodeInstructionInto(functionHeader, spirv::Opcode::OpFunctionParameter,
call    0 never executed
        -:  221:                          {argTypeID, argValueID});
        -:  222:  }
        -:  223:
        -:  224:  // Process the body.
    #####:  225:  if (op.isExternal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  226:    return op.emitError("external function is unhandled");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  227:  }
        -:  228:
        -:  229:  // Some instructions (e.g., OpVariable) in a function must be in the first
        -:  230:  // block in the function. These instructions will be put in functionHeader.
        -:  231:  // Thus, we put the label in functionHeader first, and omit it from the first
        -:  232:  // block.
    #####:  233:  encodeInstructionInto(functionHeader, spirv::Opcode::OpLabel,
call    0 never executed
    #####:  234:                        {getOrCreateBlockID(&op.front())});
call    0 never executed
call    1 never executed
    #####:  235:  if (failed(processBlock(&op.front(), /*omitLabel=*/true)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  236:    return failure();
    #####:  237:  if (failed(visitInPrettyBlockOrder(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  238:          &op.front(), [&](Block *block) { return processBlock(block); },
call    0 never executed
call    1 never executed
        -:  239:          /*skipHeader=*/true))) {
    #####:  240:    return failure();
        -:  241:  }
        -:  242:
        -:  243:  // There might be OpPhi instructions who have value references needing to fix.
    #####:  244:  for (const auto &deferredValue : deferredPhiValues) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  245:    Value value = deferredValue.first;
    #####:  246:    uint32_t id = getValueID(value);
call    0 never executed
    #####:  247:    LLVM_DEBUG(llvm::dbgs() << "[phi] fix reference of value " << value
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
        -:  248:                            << " to id = " << id << '\n');
    #####:  249:    assert(id && "OpPhi references undefined value!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  250:    for (size_t offset : deferredValue.second)
branch  0 never executed
branch  1 never executed
    #####:  251:      functionBody[offset] = id;
branch  0 never executed
branch  1 never executed
        -:  252:  }
    #####:  253:  deferredPhiValues.clear();
call    0 never executed
        -:  254:
    #####:  255:  LLVM_DEBUG(llvm::dbgs() << "-- completed function '" << op.getName()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  256:                          << "' --\n");
        -:  257:  // Insert OpFunctionEnd.
    #####:  258:  encodeInstructionInto(functionBody, spirv::Opcode::OpFunctionEnd, {});
call    0 never executed
        -:  259:
    #####:  260:  functions.append(functionHeader.begin(), functionHeader.end());
call    0 never executed
    #####:  261:  functions.append(functionBody.begin(), functionBody.end());
call    0 never executed
    #####:  262:  functionHeader.clear();
    #####:  263:  functionBody.clear();
        -:  264:
    #####:  265:  return success();
branch  0 never executed
branch  1 never executed
        -:  266:}
        -:  267:
function _ZN4mlir5spirv10Serializer17processVariableOpENS0_10VariableOpE called 0 returned 0% blocks executed 0%
    #####:  268:LogicalResult Serializer::processVariableOp(spirv::VariableOp op) {
    #####:  269:  SmallVector<uint32_t, 4> operands;
call    0 never executed
    #####:  270:  SmallVector<StringRef, 2> elidedAttrs;
branch  0 never executed
branch  1 never executed
    #####:  271:  uint32_t resultID = 0;
    #####:  272:  uint32_t resultTypeID = 0;
    #####:  273:  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  274:    return failure();
        -:  275:  }
    #####:  276:  operands.push_back(resultTypeID);
call    0 never executed
    #####:  277:  resultID = getNextID();
call    0 never executed
    #####:  278:  valueIDMap[op.getResult()] = resultID;
call    0 never executed
    #####:  279:  operands.push_back(resultID);
call    0 never executed
    #####:  280:  auto attr = op->getAttr(spirv::attributeName<spirv::StorageClass>());
call    0 never executed
    #####:  281:  if (attr) {
branch  0 never executed
branch  1 never executed
    #####:  282:    operands.push_back(
call    0 never executed
call    1 never executed
    #####:  283:        static_cast<uint32_t>(attr.cast<spirv::StorageClassAttr>().getValue()));
call    0 never executed
        -:  284:  }
    #####:  285:  elidedAttrs.push_back(spirv::attributeName<spirv::StorageClass>());
call    0 never executed
    #####:  286:  for (auto arg : op.getODSOperands(0)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  287:    auto argID = getValueID(arg);
call    0 never executed
    #####:  288:    if (!argID) {
branch  0 never executed
branch  1 never executed
    #####:  289:      return emitError(op.getLoc(), "operand 0 has a use before def");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  290:    }
    #####:  291:    operands.push_back(argID);
call    0 never executed
        -:  292:  }
    #####:  293:  if (failed(emitDebugLine(functionHeader, op.getLoc())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  294:    return failure();
    #####:  295:  encodeInstructionInto(functionHeader, spirv::Opcode::OpVariable, operands);
call    0 never executed
    #####:  296:  for (auto attr : op->getAttrs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  297:    if (llvm::any_of(elidedAttrs, [&](StringRef elided) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  298:          return attr.getName() == elided;
        -:  299:        })) {
    #####:  300:      continue;
        -:  301:    }
    #####:  302:    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  303:      return failure();
        -:  304:    }
        -:  305:  }
    #####:  306:  return success();
branch  0 never executed
branch  1 never executed
        -:  307:}
        -:  308:
        -:  309:LogicalResult
function _ZN4mlir5spirv10Serializer23processGlobalVariableOpENS0_16GlobalVariableOpE called 0 returned 0% blocks executed 0%
    #####:  310:Serializer::processGlobalVariableOp(spirv::GlobalVariableOp varOp) {
        -:  311:  // Get TypeID.
    #####:  312:  uint32_t resultTypeID = 0;
    #####:  313:  SmallVector<StringRef, 4> elidedAttrs;
call    0 never executed
    #####:  314:  if (failed(processType(varOp.getLoc(), varOp.getType(), resultTypeID))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  315:    return failure();
        -:  316:  }
        -:  317:
    #####:  318:  elidedAttrs.push_back("type");
call    0 never executed
    #####:  319:  SmallVector<uint32_t, 4> operands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  320:  operands.push_back(resultTypeID);
call    0 never executed
    #####:  321:  auto resultID = getNextID();
call    0 never executed
        -:  322:
        -:  323:  // Encode the name.
    #####:  324:  auto varName = varOp.getSymName();
call    0 never executed
    #####:  325:  elidedAttrs.push_back(SymbolTable::getSymbolAttrName());
call    0 never executed
    #####:  326:  if (failed(processName(resultID, varName))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:    return failure();
        -:  328:  }
    #####:  329:  globalVarIDMap[varName] = resultID;
call    0 never executed
    #####:  330:  operands.push_back(resultID);
call    0 never executed
        -:  331:
        -:  332:  // Encode StorageClass.
    #####:  333:  operands.push_back(static_cast<uint32_t>(varOp.storageClass()));
call    0 never executed
call    1 never executed
        -:  334:
        -:  335:  // Encode initialization.
    #####:  336:  if (auto initializer = varOp.getInitializer()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  337:    auto initializerID = getVariableID(*initializer);
call    0 never executed
    #####:  338:    if (!initializerID) {
branch  0 never executed
branch  1 never executed
    #####:  339:      return emitError(varOp.getLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  340:                       "invalid usage of undefined variable as initializer");
call    0 never executed
        -:  341:    }
    #####:  342:    operands.push_back(initializerID);
call    0 never executed
    #####:  343:    elidedAttrs.push_back("initializer");
call    0 never executed
        -:  344:  }
        -:  345:
    #####:  346:  if (failed(emitDebugLine(typesGlobalValues, varOp.getLoc())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:    return failure();
    #####:  348:  encodeInstructionInto(typesGlobalValues, spirv::Opcode::OpVariable, operands);
call    0 never executed
    #####:  349:  elidedAttrs.push_back("initializer");
call    0 never executed
        -:  350:
        -:  351:  // Encode decorations.
    #####:  352:  for (auto attr : varOp->getAttrs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  353:    if (llvm::any_of(elidedAttrs, [&](StringRef elided) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  354:          return attr.getName() == elided;
        -:  355:        })) {
    #####:  356:      continue;
        -:  357:    }
    #####:  358:    if (failed(processDecoration(varOp.getLoc(), resultID, attr))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  359:      return failure();
        -:  360:    }
        -:  361:  }
    #####:  362:  return success();
branch  0 never executed
branch  1 never executed
        -:  363:}
        -:  364:
function _ZN4mlir5spirv10Serializer18processSelectionOpENS0_11SelectionOpE called 0 returned 0% blocks executed 0%
    #####:  365:LogicalResult Serializer::processSelectionOp(spirv::SelectionOp selectionOp) {
        -:  366:  // Assign <id>s to all blocks so that branches inside the SelectionOp can
        -:  367:  // resolve properly.
    #####:  368:  auto &body = selectionOp.getBody();
call    0 never executed
    #####:  369:  for (Block &block : body)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  370:    getOrCreateBlockID(&block);
call    0 never executed
        -:  371:
    #####:  372:  auto *headerBlock = selectionOp.getHeaderBlock();
call    0 never executed
    #####:  373:  auto *mergeBlock = selectionOp.getMergeBlock();
call    0 never executed
    #####:  374:  auto headerID = getBlockID(headerBlock);
call    0 never executed
    #####:  375:  auto mergeID = getBlockID(mergeBlock);
call    0 never executed
    #####:  376:  auto loc = selectionOp.getLoc();
call    0 never executed
        -:  377:
        -:  378:  // This SelectionOp is in some MLIR block with preceding and following ops. In
        -:  379:  // the binary format, it should reside in separate SPIR-V blocks from its
        -:  380:  // preceding and following ops. So we need to emit unconditional branches to
        -:  381:  // jump to this SelectionOp's SPIR-V blocks and jumping back to the normal
        -:  382:  // flow afterwards.
    #####:  383:  encodeInstructionInto(functionBody, spirv::Opcode::OpBranch, {headerID});
call    0 never executed
        -:  384:
        -:  385:  // Emit the selection header block, which dominates all other blocks, first.
        -:  386:  // We need to emit an OpSelectionMerge instruction before the selection header
        -:  387:  // block's terminator.
function _ZZN4mlir5spirv10Serializer18processSelectionOpENS0_11SelectionOpEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  388:  auto emitSelectionMerge = [&]() {
    #####:  389:    if (failed(emitDebugLine(functionBody, loc)))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  390:      return failure();
    #####:  391:    lastProcessedWasMergeInst = true;
    #####:  392:    encodeInstructionInto(
call    0 never executed
        -:  393:        functionBody, spirv::Opcode::OpSelectionMerge,
    #####:  394:        {mergeID, static_cast<uint32_t>(selectionOp.getSelectionControl())});
call    0 never executed
    #####:  395:    return success();
    #####:  396:  };
    #####:  397:  if (failed(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  398:          processBlock(headerBlock, /*omitLabel=*/false, emitSelectionMerge)))
    #####:  399:    return failure();
        -:  400:
        -:  401:  // Process all blocks with a depth-first visitor starting from the header
        -:  402:  // block. The selection header block and merge block are skipped by this
        -:  403:  // visitor.
    #####:  404:  if (failed(visitInPrettyBlockOrder(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  405:          headerBlock, [&](Block *block) { return processBlock(block); },
call    0 never executed
        -:  406:          /*skipHeader=*/true, /*skipBlocks=*/{mergeBlock})))
    #####:  407:    return failure();
        -:  408:
        -:  409:  // There is nothing to do for the merge block in the selection, which just
        -:  410:  // contains a spirv.mlir.merge op, itself. But we need to have an OpLabel
        -:  411:  // instruction to start a new SPIR-V block for ops following this SelectionOp.
        -:  412:  // The block should use the <id> for the merge block.
    #####:  413:  encodeInstructionInto(functionBody, spirv::Opcode::OpLabel, {mergeID});
call    0 never executed
    #####:  414:  LLVM_DEBUG(llvm::dbgs() << "done merge ");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  415:  LLVM_DEBUG(printBlock(mergeBlock, llvm::dbgs()));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  416:  LLVM_DEBUG(llvm::dbgs() << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  417:  return success();
        -:  418:}
        -:  419:
function _ZN4mlir5spirv10Serializer13processLoopOpENS0_6LoopOpE called 0 returned 0% blocks executed 0%
    #####:  420:LogicalResult Serializer::processLoopOp(spirv::LoopOp loopOp) {
        -:  421:  // Assign <id>s to all blocks so that branches inside the LoopOp can resolve
        -:  422:  // properly. We don't need to assign for the entry block, which is just for
        -:  423:  // satisfying MLIR region's structural requirement.
    #####:  424:  auto &body = loopOp.getBody();
call    0 never executed
    #####:  425:  for (Block &block : llvm::drop_begin(body))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  426:    getOrCreateBlockID(&block);
call    0 never executed
        -:  427:
    #####:  428:  auto *headerBlock = loopOp.getHeaderBlock();
call    0 never executed
    #####:  429:  auto *continueBlock = loopOp.getContinueBlock();
call    0 never executed
    #####:  430:  auto *mergeBlock = loopOp.getMergeBlock();
call    0 never executed
    #####:  431:  auto headerID = getBlockID(headerBlock);
call    0 never executed
    #####:  432:  auto continueID = getBlockID(continueBlock);
call    0 never executed
    #####:  433:  auto mergeID = getBlockID(mergeBlock);
call    0 never executed
    #####:  434:  auto loc = loopOp.getLoc();
call    0 never executed
        -:  435:
        -:  436:  // This LoopOp is in some MLIR block with preceding and following ops. In the
        -:  437:  // binary format, it should reside in separate SPIR-V blocks from its
        -:  438:  // preceding and following ops. So we need to emit unconditional branches to
        -:  439:  // jump to this LoopOp's SPIR-V blocks and jumping back to the normal flow
        -:  440:  // afterwards.
    #####:  441:  encodeInstructionInto(functionBody, spirv::Opcode::OpBranch, {headerID});
call    0 never executed
        -:  442:
        -:  443:  // LoopOp's entry block is just there for satisfying MLIR's structural
        -:  444:  // requirements so we omit it and start serialization from the loop header
        -:  445:  // block.
        -:  446:
        -:  447:  // Emit the loop header block, which dominates all other blocks, first. We
        -:  448:  // need to emit an OpLoopMerge instruction before the loop header block's
        -:  449:  // terminator.
function _ZZN4mlir5spirv10Serializer13processLoopOpENS0_6LoopOpEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  450:  auto emitLoopMerge = [&]() {
    #####:  451:    if (failed(emitDebugLine(functionBody, loc)))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  452:      return failure();
    #####:  453:    lastProcessedWasMergeInst = true;
    #####:  454:    encodeInstructionInto(
call    0 never executed
        -:  455:        functionBody, spirv::Opcode::OpLoopMerge,
    #####:  456:        {mergeID, continueID, static_cast<uint32_t>(loopOp.getLoopControl())});
call    0 never executed
    #####:  457:    return success();
    #####:  458:  };
    #####:  459:  if (failed(processBlock(headerBlock, /*omitLabel=*/false, emitLoopMerge)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  460:    return failure();
        -:  461:
        -:  462:  // Process all blocks with a depth-first visitor starting from the header
        -:  463:  // block. The loop header block, loop continue block, and loop merge block are
        -:  464:  // skipped by this visitor and handled later in this function.
    #####:  465:  if (failed(visitInPrettyBlockOrder(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  466:          headerBlock, [&](Block *block) { return processBlock(block); },
call    0 never executed
        -:  467:          /*skipHeader=*/true, /*skipBlocks=*/{continueBlock, mergeBlock})))
    #####:  468:    return failure();
        -:  469:
        -:  470:  // We have handled all other blocks. Now get to the loop continue block.
    #####:  471:  if (failed(processBlock(continueBlock)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  472:    return failure();
        -:  473:
        -:  474:  // There is nothing to do for the merge block in the loop, which just contains
        -:  475:  // a spirv.mlir.merge op, itself. But we need to have an OpLabel instruction
        -:  476:  // to start a new SPIR-V block for ops following this LoopOp. The block should
        -:  477:  // use the <id> for the merge block.
    #####:  478:  encodeInstructionInto(functionBody, spirv::Opcode::OpLabel, {mergeID});
call    0 never executed
    #####:  479:  LLVM_DEBUG(llvm::dbgs() << "done merge ");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  480:  LLVM_DEBUG(printBlock(mergeBlock, llvm::dbgs()));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  481:  LLVM_DEBUG(llvm::dbgs() << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  482:  return success();
        -:  483:}
        -:  484:
function _ZN4mlir5spirv10Serializer26processBranchConditionalOpENS0_19BranchConditionalOpE called 0 returned 0% blocks executed 0%
    #####:  485:LogicalResult Serializer::processBranchConditionalOp(
        -:  486:    spirv::BranchConditionalOp condBranchOp) {
    #####:  487:  auto conditionID = getValueID(condBranchOp.getCondition());
call    0 never executed
call    1 never executed
    #####:  488:  auto trueLabelID = getOrCreateBlockID(condBranchOp.getTrueBlock());
call    0 never executed
call    1 never executed
    #####:  489:  auto falseLabelID = getOrCreateBlockID(condBranchOp.getFalseBlock());
call    0 never executed
call    1 never executed
    #####:  490:  SmallVector<uint32_t, 5> arguments{conditionID, trueLabelID, falseLabelID};
call    0 never executed
        -:  491:
    #####:  492:  if (auto weights = condBranchOp.getBranchWeights()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  493:    for (auto val : weights->getValue())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  494:      arguments.push_back(val.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  495:  }
        -:  496:
    #####:  497:  if (failed(emitDebugLine(functionBody, condBranchOp.getLoc())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  498:    return failure();
    #####:  499:  encodeInstructionInto(functionBody, spirv::Opcode::OpBranchConditional,
call    0 never executed
        -:  500:                        arguments);
    #####:  501:  return success();
branch  0 never executed
branch  1 never executed
        -:  502:}
        -:  503:
function _ZN4mlir5spirv10Serializer15processBranchOpENS0_8BranchOpE called 0 returned 0% blocks executed 0%
    #####:  504:LogicalResult Serializer::processBranchOp(spirv::BranchOp branchOp) {
    #####:  505:  if (failed(emitDebugLine(functionBody, branchOp.getLoc())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:    return failure();
    #####:  507:  encodeInstructionInto(functionBody, spirv::Opcode::OpBranch,
call    0 never executed
    #####:  508:                        {getOrCreateBlockID(branchOp.getTarget())});
call    0 never executed
call    1 never executed
    #####:  509:  return success();
        -:  510:}
        -:  511:
function _ZN4mlir5spirv10Serializer18processAddressOfOpENS0_11AddressOfOpE called 0 returned 0% blocks executed 0%
    #####:  512:LogicalResult Serializer::processAddressOfOp(spirv::AddressOfOp addressOfOp) {
    #####:  513:  auto varName = addressOfOp.getVariable();
call    0 never executed
    #####:  514:  auto variableID = getVariableID(varName);
call    0 never executed
    #####:  515:  if (!variableID) {
branch  0 never executed
branch  1 never executed
    #####:  516:    return addressOfOp.emitError("unknown result <id> for variable ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  517:           << varName;
call    0 never executed
        -:  518:  }
    #####:  519:  valueIDMap[addressOfOp.getPointer()] = variableID;
call    0 never executed
call    1 never executed
    #####:  520:  return success();
        -:  521:}
        -:  522:
        -:  523:LogicalResult
function _ZN4mlir5spirv10Serializer20processReferenceOfOpENS0_13ReferenceOfOpE called 0 returned 0% blocks executed 0%
    #####:  524:Serializer::processReferenceOfOp(spirv::ReferenceOfOp referenceOfOp) {
    #####:  525:  auto constName = referenceOfOp.getSpecConst();
call    0 never executed
    #####:  526:  auto constID = getSpecConstID(constName);
call    0 never executed
    #####:  527:  if (!constID) {
branch  0 never executed
branch  1 never executed
    #####:  528:    return referenceOfOp.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  529:               "unknown result <id> for specialization constant ")
    #####:  530:           << constName;
call    0 never executed
        -:  531:  }
    #####:  532:  valueIDMap[referenceOfOp.getReference()] = constID;
call    0 never executed
call    1 never executed
    #####:  533:  return success();
        -:  534:}
        -:  535:
        -:  536:template <>
        -:  537:LogicalResult
function _ZN4mlir5spirv10Serializer9processOpINS0_12EntryPointOpEEENS_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  538:Serializer::processOp<spirv::EntryPointOp>(spirv::EntryPointOp op) {
    #####:  539:  SmallVector<uint32_t, 4> operands;
call    0 never executed
        -:  540:  // Add the ExecutionModel.
    #####:  541:  operands.push_back(static_cast<uint32_t>(op.getExecutionModel()));
call    0 never executed
call    1 never executed
        -:  542:  // Add the function <id>.
    #####:  543:  auto funcID = getFunctionID(op.getFn());
call    0 never executed
call    1 never executed
    #####:  544:  if (!funcID) {
branch  0 never executed
branch  1 never executed
    #####:  545:    return op.emitError("missing <id> for function ")
call    0 never executed
call    1 never executed
    #####:  546:           << op.getFn()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  547:           << "; function needs to be defined before spirv.EntryPoint is "
    #####:  548:              "serialized";
call    0 never executed
        -:  549:  }
    #####:  550:  operands.push_back(funcID);
call    0 never executed
        -:  551:  // Add the name of the function.
    #####:  552:  spirv::encodeStringLiteralInto(operands, op.getFn());
call    0 never executed
call    1 never executed
        -:  553:
        -:  554:  // Add the interface values.
    #####:  555:  if (auto interface = op.getInterface()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  556:    for (auto var : interface.getValue()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  557:      auto id = getVariableID(var.cast<FlatSymbolRefAttr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  558:      if (!id) {
branch  0 never executed
branch  1 never executed
    #####:  559:        return op.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  560:            "referencing undefined global variable."
        -:  561:            "spirv.EntryPoint is at the end of spirv.module. All "
    #####:  562:            "referenced variables should already be defined");
call    0 never executed
        -:  563:      }
    #####:  564:      operands.push_back(id);
call    0 never executed
        -:  565:    }
        -:  566:  }
    #####:  567:  encodeInstructionInto(entryPoints, spirv::Opcode::OpEntryPoint, operands);
call    0 never executed
    #####:  568:  return success();
branch  0 never executed
branch  1 never executed
        -:  569:}
        -:  570:
        -:  571:template <>
        -:  572:LogicalResult
function _ZN4mlir5spirv10Serializer9processOpINS0_15ExecutionModeOpEEENS_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  573:Serializer::processOp<spirv::ExecutionModeOp>(spirv::ExecutionModeOp op) {
    #####:  574:  SmallVector<uint32_t, 4> operands;
call    0 never executed
        -:  575:  // Add the function <id>.
    #####:  576:  auto funcID = getFunctionID(op.getFn());
call    0 never executed
call    1 never executed
    #####:  577:  if (!funcID) {
branch  0 never executed
branch  1 never executed
    #####:  578:    return op.emitError("missing <id> for function ")
call    0 never executed
call    1 never executed
    #####:  579:           << op.getFn()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  580:           << "; function needs to be serialized before ExecutionModeOp is "
    #####:  581:              "serialized";
call    0 never executed
        -:  582:  }
    #####:  583:  operands.push_back(funcID);
call    0 never executed
        -:  584:  // Add the ExecutionMode.
    #####:  585:  operands.push_back(static_cast<uint32_t>(op.getExecutionMode()));
call    0 never executed
call    1 never executed
        -:  586:
        -:  587:  // Serialize values if any.
    #####:  588:  auto values = op.getValues();
call    0 never executed
    #####:  589:  if (values) {
branch  0 never executed
branch  1 never executed
    #####:  590:    for (auto &intVal : values.getValue()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  591:      operands.push_back(static_cast<uint32_t>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  592:          intVal.cast<IntegerAttr>().getValue().getZExtValue()));
call    0 never executed
call    1 never executed
        -:  593:    }
        -:  594:  }
    #####:  595:  encodeInstructionInto(executionModes, spirv::Opcode::OpExecutionMode,
call    0 never executed
        -:  596:                        operands);
    #####:  597:  return success();
branch  0 never executed
branch  1 never executed
        -:  598:}
        -:  599:
        -:  600:template <>
        -:  601:LogicalResult
function _ZN4mlir5spirv10Serializer9processOpINS0_14FunctionCallOpEEENS_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  602:Serializer::processOp<spirv::FunctionCallOp>(spirv::FunctionCallOp op) {
    #####:  603:  auto funcName = op.getCallee();
call    0 never executed
    #####:  604:  uint32_t resTypeID = 0;
        -:  605:
    #####:  606:  Type resultTy = op.getNumResults() ? *op.result_type_begin() : getVoidType();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  607:  if (failed(processType(op.getLoc(), resultTy, resTypeID)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  608:    return failure();
        -:  609:
    #####:  610:  auto funcID = getOrCreateFunctionID(funcName);
call    0 never executed
    #####:  611:  auto funcCallID = getNextID();
call    0 never executed
    #####:  612:  SmallVector<uint32_t, 8> operands{resTypeID, funcCallID, funcID};
call    0 never executed
        -:  613:
    #####:  614:  for (auto value : op.getArguments()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  615:    auto valueID = getValueID(value);
call    0 never executed
    #####:  616:    assert(valueID && "cannot find a value for spirv.FunctionCall");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  617:    operands.push_back(valueID);
call    0 never executed
        -:  618:  }
        -:  619:
    #####:  620:  if (!resultTy.isa<NoneType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  621:    valueIDMap[op.getResult(0)] = funcCallID;
call    0 never executed
        -:  622:
    #####:  623:  encodeInstructionInto(functionBody, spirv::Opcode::OpFunctionCall, operands);
call    0 never executed
    #####:  624:  return success();
branch  0 never executed
branch  1 never executed
        -:  625:}
        -:  626:
        -:  627:template <>
        -:  628:LogicalResult
function _ZN4mlir5spirv10Serializer9processOpINS0_12CopyMemoryOpEEENS_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  629:Serializer::processOp<spirv::CopyMemoryOp>(spirv::CopyMemoryOp op) {
    #####:  630:  SmallVector<uint32_t, 4> operands;
call    0 never executed
    #####:  631:  SmallVector<StringRef, 2> elidedAttrs;
branch  0 never executed
branch  1 never executed
        -:  632:
    #####:  633:  for (Value operand : op->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  634:    auto id = getValueID(operand);
call    0 never executed
    #####:  635:    assert(id && "use before def!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  636:    operands.push_back(id);
call    0 never executed
        -:  637:  }
        -:  638:
    #####:  639:  if (auto attr = op->getAttr("memory_access")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  640:    operands.push_back(
call    0 never executed
call    1 never executed
    #####:  641:        static_cast<uint32_t>(attr.cast<spirv::MemoryAccessAttr>().getValue()));
call    0 never executed
        -:  642:  }
        -:  643:
    #####:  644:  elidedAttrs.push_back("memory_access");
call    0 never executed
        -:  645:
    #####:  646:  if (auto attr = op->getAttr("alignment")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  647:    operands.push_back(static_cast<uint32_t>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  648:        attr.cast<IntegerAttr>().getValue().getZExtValue()));
call    0 never executed
call    1 never executed
        -:  649:  }
        -:  650:
    #####:  651:  elidedAttrs.push_back("alignment");
call    0 never executed
        -:  652:
    #####:  653:  if (auto attr = op->getAttr("source_memory_access")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  654:    operands.push_back(
call    0 never executed
call    1 never executed
    #####:  655:        static_cast<uint32_t>(attr.cast<spirv::MemoryAccessAttr>().getValue()));
call    0 never executed
        -:  656:  }
        -:  657:
    #####:  658:  elidedAttrs.push_back("source_memory_access");
call    0 never executed
        -:  659:
    #####:  660:  if (auto attr = op->getAttr("source_alignment")) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  661:    operands.push_back(static_cast<uint32_t>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  662:        attr.cast<IntegerAttr>().getValue().getZExtValue()));
call    0 never executed
call    1 never executed
        -:  663:  }
        -:  664:
    #####:  665:  elidedAttrs.push_back("source_alignment");
call    0 never executed
    #####:  666:  if (failed(emitDebugLine(functionBody, op.getLoc())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  667:    return failure();
    #####:  668:  encodeInstructionInto(functionBody, spirv::Opcode::OpCopyMemory, operands);
call    0 never executed
        -:  669:
    #####:  670:  return success();
branch  0 never executed
branch  1 never executed
        -:  671:}
        -:  672:template <>
function _ZN4mlir5spirv10Serializer9processOpINS0_26GenericCastToPtrExplicitOpEEENS_13LogicalResultET_ called 0 returned 0% blocks executed 0%
    #####:  673:LogicalResult Serializer::processOp<spirv::GenericCastToPtrExplicitOp>(
        -:  674:    spirv::GenericCastToPtrExplicitOp op) {
    #####:  675:  SmallVector<uint32_t, 4> operands;
call    0 never executed
    #####:  676:  Type resultTy;
    #####:  677:  Location loc = op->getLoc();
call    0 never executed
    #####:  678:  uint32_t resultTypeID = 0;
    #####:  679:  uint32_t resultID = 0;
    #####:  680:  resultTy = op->getResult(0).getType();
call    0 never executed
    #####:  681:  if (failed(processType(loc, resultTy, resultTypeID)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  682:    return failure();
    #####:  683:  operands.push_back(resultTypeID);
call    0 never executed
        -:  684:
    #####:  685:  resultID = getNextID();
call    0 never executed
    #####:  686:  operands.push_back(resultID);
call    0 never executed
    #####:  687:  valueIDMap[op->getResult(0)] = resultID;
call    0 never executed
        -:  688:
    #####:  689:  for (Value operand : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  690:    operands.push_back(getValueID(operand));
call    0 never executed
call    1 never executed
    #####:  691:  spirv::StorageClass resultStorage =
call    0 never executed
    #####:  692:      resultTy.cast<spirv::PointerType>().getStorageClass();
call    0 never executed
    #####:  693:  operands.push_back(static_cast<uint32_t>(resultStorage));
call    0 never executed
    #####:  694:  encodeInstructionInto(functionBody, spirv::Opcode::OpGenericCastToPtrExplicit,
call    0 never executed
        -:  695:                        operands);
    #####:  696:  return success();
branch  0 never executed
branch  1 never executed
        -:  697:}
        -:  698:
        -:  699:// Pull in auto-generated Serializer::dispatchToAutogenSerialization() and
        -:  700:// various Serializer::processOp<...>() specializations.
        -:  701:#define GET_SERIALIZATION_FNS
        -:  702:#include "mlir/Dialect/SPIRV/IR/SPIRVSerialization.inc"
        -:  703:
        -:  704:} // namespace spirv
        -:  705:} // namespace mlir
