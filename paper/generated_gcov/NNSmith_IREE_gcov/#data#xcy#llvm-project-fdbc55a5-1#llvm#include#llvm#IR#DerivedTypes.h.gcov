        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/IR/DerivedTypes.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:325580
        -:    1://===- llvm/DerivedTypes.h - Classes for handling data types ----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains the declarations of classes that represent "derived
        -:   10:// types".  These are things like "arrays of x" or "structure of x, y, z" or
        -:   11:// "function returning x taking (y,z) as parameters", etc...
        -:   12://
        -:   13:// The implementations of these classes live in the Type.cpp file.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_IR_DERIVEDTYPES_H
        -:   18:#define LLVM_IR_DERIVEDTYPES_H
        -:   19:
        -:   20:#include "llvm/ADT/ArrayRef.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/StringRef.h"
        -:   23:#include "llvm/IR/Type.h"
        -:   24:#include "llvm/Support/Casting.h"
        -:   25:#include "llvm/Support/Compiler.h"
        -:   26:#include "llvm/Support/TypeSize.h"
        -:   27:#include <cassert>
        -:   28:#include <cstdint>
        -:   29:
        -:   30:namespace llvm {
        -:   31:
        -:   32:class Value;
        -:   33:class APInt;
        -:   34:class LLVMContext;
        -:   35:
        -:   36:/// Class to represent integer types. Note that this class is also used to
        -:   37:/// represent the built-in integer types: Int1Ty, Int8Ty, Int16Ty, Int32Ty and
        -:   38:/// Int64Ty.
        -:   39:/// Integer representation type
        -:   40:class IntegerType : public Type {
        -:   41:  friend class LLVMContextImpl;
        -:   42:
        -:   43:protected:
        -:   44:  explicit IntegerType(LLVMContext &C, unsigned NumBits) : Type(C, IntegerTyID){
        -:   45:    setSubclassData(NumBits);
        -:   46:  }
        -:   47:
        -:   48:public:
        -:   49:  /// This enum is just used to hold constants we need for IntegerType.
        -:   50:  enum {
        -:   51:    MIN_INT_BITS = 1,        ///< Minimum number of bits that can be specified
        -:   52:    MAX_INT_BITS = (1<<23)   ///< Maximum number of bits that can be specified
        -:   53:      ///< Note that bit width is stored in the Type classes SubclassData field
        -:   54:      ///< which has 24 bits. SelectionDAG type legalization can require a
        -:   55:      ///< power of 2 IntegerType, so limit to the largest representable power
        -:   56:      ///< of 2, 8388608.
        -:   57:  };
        -:   58:
        -:   59:  /// This static method is the primary way of constructing an IntegerType.
        -:   60:  /// If an IntegerType with the same NumBits value was previously instantiated,
        -:   61:  /// that instance will be returned. Otherwise a new one will be created. Only
        -:   62:  /// one instance with a given NumBits value is ever created.
        -:   63:  /// Get or create an IntegerType instance.
        -:   64:  static IntegerType *get(LLVMContext &C, unsigned NumBits);
        -:   65:
        -:   66:  /// Returns type twice as wide the input type.
        -:   67:  IntegerType *getExtendedType() const {
        -:   68:    return Type::getIntNTy(getContext(), 2 * getScalarSizeInBits());
        -:   69:  }
        -:   70:
        -:   71:  /// Get the number of bits in this IntegerType
    #####:   72:  unsigned getBitWidth() const { return getSubclassData(); }
        -:   73:
        -:   74:  /// Return a bitmask with ones set for all of the bits that can be set by an
        -:   75:  /// unsigned version of this type. This is 0xFF for i8, 0xFFFF for i16, etc.
        -:   76:  uint64_t getBitMask() const {
        -:   77:    return ~uint64_t(0UL) >> (64-getBitWidth());
        -:   78:  }
        -:   79:
        -:   80:  /// Return a uint64_t with just the most significant bit set (the sign bit, if
        -:   81:  /// the value is treated as a signed number).
        -:   82:  uint64_t getSignBit() const {
        -:   83:    return 1ULL << (getBitWidth()-1);
        -:   84:  }
        -:   85:
        -:   86:  /// For example, this is 0xFF for an 8 bit integer, 0xFFFF for i16, etc.
        -:   87:  /// @returns a bit mask with ones set for all the bits of this type.
        -:   88:  /// Get a bit mask for this type.
        -:   89:  APInt getMask() const;
        -:   90:
        -:   91:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
    #####:   92:  static bool classof(const Type *T) {
    #####:   93:    return T->getTypeID() == IntegerTyID;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   94:  }
        -:   95:};
        -:   96:
    #####:   97:unsigned Type::getIntegerBitWidth() const {
    #####:   98:  return cast<IntegerType>(this)->getBitWidth();
call    0 never executed
        -:   99:}
        -:  100:
        -:  101:/// Class to represent function types
        -:  102:///
        -:  103:class FunctionType : public Type {
        -:  104:  FunctionType(Type *Result, ArrayRef<Type*> Params, bool IsVarArgs);
        -:  105:
        -:  106:public:
        -:  107:  FunctionType(const FunctionType &) = delete;
        -:  108:  FunctionType &operator=(const FunctionType &) = delete;
        -:  109:
        -:  110:  /// This static method is the primary way of constructing a FunctionType.
        -:  111:  static FunctionType *get(Type *Result,
        -:  112:                           ArrayRef<Type*> Params, bool isVarArg);
        -:  113:
        -:  114:  /// Create a FunctionType taking no parameters.
        -:  115:  static FunctionType *get(Type *Result, bool isVarArg);
        -:  116:
        -:  117:  /// Return true if the specified type is valid as a return type.
        -:  118:  static bool isValidReturnType(Type *RetTy);
        -:  119:
        -:  120:  /// Return true if the specified type is valid as an argument type.
        -:  121:  static bool isValidArgumentType(Type *ArgTy);
        -:  122:
        -:  123:  bool isVarArg() const { return getSubclassData()!=0; }
    #####:  124:  Type *getReturnType() const { return ContainedTys[0]; }
call    0 never executed
call    1 never executed
        -:  125:
        -:  126:  using param_iterator = Type::subtype_iterator;
        -:  127:
        -:  128:  param_iterator param_begin() const { return ContainedTys + 1; }
        -:  129:  param_iterator param_end() const { return &ContainedTys[NumContainedTys]; }
        -:  130:  ArrayRef<Type *> params() const {
        -:  131:    return makeArrayRef(param_begin(), param_end());
        -:  132:  }
        -:  133:
        -:  134:  /// Parameter type accessors.
        -:  135:  Type *getParamType(unsigned i) const { return ContainedTys[i+1]; }
        -:  136:
        -:  137:  /// Return the number of fixed parameters this function type requires.
        -:  138:  /// This does not consider varargs.
        -:  139:  unsigned getNumParams() const { return NumContainedTys - 1; }
        -:  140:
        -:  141:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
    #####:  142:  static bool classof(const Type *T) {
    #####:  143:    return T->getTypeID() == FunctionTyID;
branch  0 never executed
branch  1 never executed
        -:  144:  }
        -:  145:};
        -:  146:static_assert(alignof(FunctionType) >= alignof(Type *),
        -:  147:              "Alignment sufficient for objects appended to FunctionType");
        -:  148:
        -:  149:bool Type::isFunctionVarArg() const {
        -:  150:  return cast<FunctionType>(this)->isVarArg();
        -:  151:}
        -:  152:
        -:  153:Type *Type::getFunctionParamType(unsigned i) const {
        -:  154:  return cast<FunctionType>(this)->getParamType(i);
        -:  155:}
        -:  156:
        -:  157:unsigned Type::getFunctionNumParams() const {
        -:  158:  return cast<FunctionType>(this)->getNumParams();
        -:  159:}
        -:  160:
        -:  161:/// A handy container for a FunctionType+Callee-pointer pair, which can be
        -:  162:/// passed around as a single entity. This assists in replacing the use of
        -:  163:/// PointerType::getElementType() to access the function's type, since that's
        -:  164:/// slated for removal as part of the [opaque pointer types] project.
        -:  165:class FunctionCallee {
        -:  166:public:
        -:  167:  // Allow implicit conversion from types which have a getFunctionType member
        -:  168:  // (e.g. Function and InlineAsm).
        -:  169:  template <typename T, typename U = decltype(&T::getFunctionType)>
    #####:  170:  FunctionCallee(T *Fn)
    #####:  171:      : FnTy(Fn ? Fn->getFunctionType() : nullptr), Callee(Fn) {}
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
branch 21 never executed
branch 22 never executed
call   23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 never executed
branch 45 never executed
branch 46 never executed
call   47 never executed
branch 48 never executed
branch 49 never executed
call   50 never executed
branch 51 never executed
branch 52 never executed
call   53 never executed
branch 54 never executed
branch 55 never executed
call   56 never executed
branch 57 never executed
branch 58 never executed
call   59 never executed
branch 60 never executed
branch 61 never executed
call   62 never executed
branch 63 never executed
branch 64 never executed
call   65 never executed
branch 66 never executed
branch 67 never executed
call   68 never executed
branch 69 never executed
branch 70 never executed
call   71 never executed
branch 72 never executed
branch 73 never executed
call   74 never executed
branch 75 never executed
branch 76 never executed
call   77 never executed
branch 78 never executed
branch 79 never executed
call   80 never executed
branch 81 never executed
branch 82 never executed
call   83 never executed
branch 84 never executed
branch 85 never executed
call   86 never executed
branch 87 never executed
branch 88 never executed
call   89 never executed
branch 90 never executed
branch 91 never executed
call   92 never executed
branch 93 never executed
branch 94 never executed
call   95 never executed
branch 96 never executed
branch 97 never executed
call   98 never executed
branch 99 never executed
branch 100 never executed
call   101 never executed
branch 102 never executed
branch 103 never executed
call   104 never executed
branch 105 never executed
branch 106 never executed
call   107 never executed
branch 108 never executed
branch 109 never executed
call   110 never executed
branch 111 never executed
branch 112 never executed
call   113 never executed
branch 114 never executed
branch 115 never executed
call   116 never executed
branch 117 never executed
branch 118 never executed
call   119 never executed
branch 120 never executed
branch 121 never executed
call   122 never executed
branch 123 never executed
branch 124 never executed
call   125 never executed
branch 126 never executed
branch 127 never executed
call   128 never executed
branch 129 never executed
branch 130 never executed
call   131 never executed
branch 132 never executed
branch 133 never executed
call   134 never executed
branch 135 never executed
branch 136 never executed
call   137 never executed
branch 138 never executed
branch 139 never executed
call   140 never executed
branch 141 never executed
branch 142 never executed
call   143 never executed
branch 144 never executed
branch 145 never executed
call   146 never executed
branch 147 never executed
branch 148 never executed
call   149 never executed
branch 150 never executed
branch 151 never executed
call   152 never executed
branch 153 never executed
branch 154 never executed
call   155 never executed
branch 156 never executed
branch 157 never executed
call   158 never executed
branch 159 never executed
branch 160 never executed
call   161 never executed
branch 162 never executed
branch 163 never executed
call   164 never executed
branch 165 never executed
branch 166 never executed
call   167 never executed
branch 168 never executed
branch 169 never executed
call   170 never executed
branch 171 never executed
branch 172 never executed
call   173 never executed
branch 174 never executed
branch 175 never executed
call   176 never executed
branch 177 never executed
branch 178 never executed
call   179 never executed
branch 180 never executed
branch 181 never executed
call   182 never executed
branch 183 never executed
branch 184 never executed
call   185 never executed
branch 186 never executed
branch 187 never executed
call   188 never executed
branch 189 never executed
branch 190 never executed
call   191 never executed
branch 192 never executed
branch 193 never executed
call   194 never executed
branch 195 never executed
branch 196 never executed
call   197 never executed
branch 198 never executed
branch 199 never executed
call   200 never executed
branch 201 never executed
branch 202 never executed
call   203 never executed
branch 204 never executed
branch 205 never executed
call   206 never executed
branch 207 never executed
branch 208 never executed
call   209 never executed
branch 210 never executed
branch 211 never executed
call   212 never executed
branch 213 never executed
branch 214 never executed
call   215 never executed
branch 216 never executed
branch 217 never executed
call   218 never executed
branch 219 never executed
branch 220 never executed
call   221 never executed
branch 222 never executed
branch 223 never executed
call   224 never executed
branch 225 never executed
branch 226 never executed
call   227 never executed
branch 228 never executed
branch 229 never executed
call   230 never executed
branch 231 never executed
branch 232 never executed
call   233 never executed
branch 234 never executed
branch 235 never executed
call   236 never executed
branch 237 never executed
branch 238 never executed
call   239 never executed
branch 240 never executed
branch 241 never executed
call   242 never executed
branch 243 never executed
branch 244 never executed
call   245 never executed
branch 246 never executed
branch 247 never executed
call   248 never executed
branch 249 never executed
branch 250 never executed
call   251 never executed
branch 252 never executed
branch 253 never executed
call   254 never executed
branch 255 never executed
branch 256 never executed
call   257 never executed
branch 258 never executed
branch 259 never executed
call   260 never executed
branch 261 never executed
branch 262 never executed
call   263 never executed
branch 264 never executed
branch 265 never executed
call   266 never executed
branch 267 never executed
branch 268 never executed
call   269 never executed
branch 270 never executed
branch 271 never executed
call   272 never executed
branch 273 never executed
branch 274 never executed
call   275 never executed
branch 276 never executed
branch 277 never executed
call   278 never executed
branch 279 never executed
branch 280 never executed
call   281 never executed
branch 282 never executed
branch 283 never executed
call   284 never executed
branch 285 never executed
branch 286 never executed
call   287 never executed
branch 288 never executed
branch 289 never executed
call   290 never executed
branch 291 never executed
branch 292 never executed
call   293 never executed
branch 294 never executed
branch 295 never executed
call   296 never executed
branch 297 never executed
branch 298 never executed
call   299 never executed
branch 300 never executed
branch 301 never executed
call   302 never executed
branch 303 never executed
branch 304 never executed
call   305 never executed
branch 306 never executed
branch 307 never executed
call   308 never executed
branch 309 never executed
branch 310 never executed
call   311 never executed
branch 312 never executed
branch 313 never executed
call   314 never executed
branch 315 never executed
branch 316 never executed
call   317 never executed
branch 318 never executed
branch 319 never executed
call   320 never executed
branch 321 never executed
branch 322 never executed
call   323 never executed
branch 324 never executed
branch 325 never executed
call   326 never executed
branch 327 never executed
branch 328 never executed
call   329 never executed
branch 330 never executed
branch 331 never executed
call   332 never executed
branch 333 never executed
branch 334 never executed
call   335 never executed
branch 336 never executed
branch 337 never executed
call   338 never executed
branch 339 never executed
branch 340 never executed
call   341 never executed
branch 342 never executed
branch 343 never executed
call   344 never executed
branch 345 never executed
branch 346 never executed
call   347 never executed
branch 348 never executed
branch 349 never executed
call   350 never executed
branch 351 never executed
branch 352 never executed
call   353 never executed
branch 354 never executed
branch 355 never executed
call   356 never executed
branch 357 never executed
branch 358 never executed
call   359 never executed
branch 360 never executed
branch 361 never executed
call   362 never executed
branch 363 never executed
branch 364 never executed
call   365 never executed
branch 366 never executed
branch 367 never executed
call   368 never executed
branch 369 never executed
branch 370 never executed
call   371 never executed
branch 372 never executed
branch 373 never executed
call   374 never executed
branch 375 never executed
branch 376 never executed
call   377 never executed
branch 378 never executed
branch 379 never executed
call   380 never executed
branch 381 never executed
branch 382 never executed
call   383 never executed
branch 384 never executed
branch 385 never executed
call   386 never executed
branch 387 never executed
branch 388 never executed
call   389 never executed
branch 390 never executed
branch 391 never executed
call   392 never executed
branch 393 never executed
branch 394 never executed
call   395 never executed
branch 396 never executed
branch 397 never executed
call   398 never executed
branch 399 never executed
branch 400 never executed
call   401 never executed
branch 402 never executed
branch 403 never executed
call   404 never executed
branch 405 never executed
branch 406 never executed
call   407 never executed
        -:  172:
        -:  173:  FunctionCallee(FunctionType *FnTy, Value *Callee)
        -:  174:      : FnTy(FnTy), Callee(Callee) {
        -:  175:    assert((FnTy == nullptr) == (Callee == nullptr));
        -:  176:  }
        -:  177:
        -:  178:  FunctionCallee(std::nullptr_t) {}
        -:  179:
        -:  180:  FunctionCallee() = default;
        -:  181:
    #####:  182:  FunctionType *getFunctionType() { return FnTy; }
        -:  183:
    #####:  184:  Value *getCallee() { return Callee; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
call   134 never executed
call   135 never executed
        -:  185:
        -:  186:  explicit operator bool() { return Callee; }
        -:  187:
        -:  188:private:
        -:  189:  FunctionType *FnTy = nullptr;
        -:  190:  Value *Callee = nullptr;
        -:  191:};
        -:  192:
        -:  193:/// Class to represent struct types. There are two different kinds of struct
        -:  194:/// types: Literal structs and Identified structs.
        -:  195:///
        -:  196:/// Literal struct types (e.g. { i32, i32 }) are uniqued structurally, and must
        -:  197:/// always have a body when created.  You can get one of these by using one of
        -:  198:/// the StructType::get() forms.
        -:  199:///
        -:  200:/// Identified structs (e.g. %foo or %42) may optionally have a name and are not
        -:  201:/// uniqued.  The names for identified structs are managed at the LLVMContext
        -:  202:/// level, so there can only be a single identified struct with a given name in
        -:  203:/// a particular LLVMContext.  Identified structs may also optionally be opaque
        -:  204:/// (have no body specified).  You get one of these by using one of the
        -:  205:/// StructType::create() forms.
        -:  206:///
        -:  207:/// Independent of what kind of struct you have, the body of a struct type are
        -:  208:/// laid out in memory consecutively with the elements directly one after the
        -:  209:/// other (if the struct is packed) or (if not packed) with padding between the
        -:  210:/// elements as defined by DataLayout (which is required to match what the code
        -:  211:/// generator for a target expects).
        -:  212:///
        -:  213:class StructType : public Type {
        -:  214:  StructType(LLVMContext &C) : Type(C, StructTyID) {}
        -:  215:
        -:  216:  enum {
        -:  217:    /// This is the contents of the SubClassData field.
        -:  218:    SCDB_HasBody = 1,
        -:  219:    SCDB_Packed = 2,
        -:  220:    SCDB_IsLiteral = 4,
        -:  221:    SCDB_IsSized = 8
        -:  222:  };
        -:  223:
        -:  224:  /// For a named struct that actually has a name, this is a pointer to the
        -:  225:  /// symbol table entry (maintained by LLVMContext) for the struct.
        -:  226:  /// This is null if the type is an literal struct or if it is a identified
        -:  227:  /// type that has an empty name.
        -:  228:  void *SymbolTableEntry = nullptr;
        -:  229:
        -:  230:public:
        -:  231:  StructType(const StructType &) = delete;
        -:  232:  StructType &operator=(const StructType &) = delete;
        -:  233:
        -:  234:  /// This creates an identified struct.
        -:  235:  static StructType *create(LLVMContext &Context, StringRef Name);
        -:  236:  static StructType *create(LLVMContext &Context);
        -:  237:
        -:  238:  static StructType *create(ArrayRef<Type *> Elements, StringRef Name,
        -:  239:                            bool isPacked = false);
        -:  240:  static StructType *create(ArrayRef<Type *> Elements);
        -:  241:  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements,
        -:  242:                            StringRef Name, bool isPacked = false);
        -:  243:  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements);
        -:  244:  template <class... Tys>
        -:  245:  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>
        -:  246:  create(StringRef Name, Type *elt1, Tys *... elts) {
        -:  247:    assert(elt1 && "Cannot create a struct type with no elements with this");
        -:  248:    return create(ArrayRef<Type *>({elt1, elts...}), Name);
        -:  249:  }
        -:  250:
        -:  251:  /// This static method is the primary way to create a literal StructType.
        -:  252:  static StructType *get(LLVMContext &Context, ArrayRef<Type*> Elements,
        -:  253:                         bool isPacked = false);
        -:  254:
        -:  255:  /// Create an empty structure type.
        -:  256:  static StructType *get(LLVMContext &Context, bool isPacked = false);
        -:  257:
        -:  258:  /// This static method is a convenience method for creating structure types by
        -:  259:  /// specifying the elements as arguments. Note that this method always returns
        -:  260:  /// a non-packed struct, and requires at least one element type.
        -:  261:  template <class... Tys>
        -:  262:  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>
        -:  263:  get(Type *elt1, Tys *... elts) {
        -:  264:    assert(elt1 && "Cannot create a struct type with no elements with this");
        -:  265:    LLVMContext &Ctx = elt1->getContext();
        -:  266:    return StructType::get(Ctx, ArrayRef<Type *>({elt1, elts...}));
        -:  267:  }
        -:  268:
        -:  269:  /// Return the type with the specified name, or null if there is none by that
        -:  270:  /// name.
        -:  271:  static StructType *getTypeByName(LLVMContext &C, StringRef Name);
        -:  272:
        -:  273:  bool isPacked() const { return (getSubclassData() & SCDB_Packed) != 0; }
        -:  274:
        -:  275:  /// Return true if this type is uniqued by structural equivalence, false if it
        -:  276:  /// is a struct definition.
        -:  277:  bool isLiteral() const { return (getSubclassData() & SCDB_IsLiteral) != 0; }
        -:  278:
        -:  279:  /// Return true if this is a type with an identity that has no body specified
        -:  280:  /// yet. These prints as 'opaque' in .ll files.
        -:  281:  bool isOpaque() const { return (getSubclassData() & SCDB_HasBody) == 0; }
        -:  282:
        -:  283:  /// isSized - Return true if this is a sized type.
        -:  284:  bool isSized(SmallPtrSetImpl<Type *> *Visited = nullptr) const;
        -:  285:
        -:  286:  /// Returns true if this struct contains a scalable vector.
        -:  287:  bool containsScalableVectorType() const;
        -:  288:
        -:  289:  /// Return true if this is a named struct that has a non-empty name.
        -:  290:  bool hasName() const { return SymbolTableEntry != nullptr; }
        -:  291:
        -:  292:  /// Return the name for this struct type if it has an identity.
        -:  293:  /// This may return an empty string for an unnamed struct type.  Do not call
        -:  294:  /// this on an literal type.
        -:  295:  StringRef getName() const;
        -:  296:
        -:  297:  /// Change the name of this type to the specified name, or to a name with a
        -:  298:  /// suffix if there is a collision. Do not call this on an literal type.
        -:  299:  void setName(StringRef Name);
        -:  300:
        -:  301:  /// Specify a body for an opaque identified type.
        -:  302:  void setBody(ArrayRef<Type*> Elements, bool isPacked = false);
        -:  303:
        -:  304:  template <typename... Tys>
        -:  305:  std::enable_if_t<are_base_of<Type, Tys...>::value, void>
        -:  306:  setBody(Type *elt1, Tys *... elts) {
        -:  307:    assert(elt1 && "Cannot create a struct type with no elements with this");
        -:  308:    setBody(ArrayRef<Type *>({elt1, elts...}));
        -:  309:  }
        -:  310:
        -:  311:  /// Return true if the specified type is valid as a element type.
        -:  312:  static bool isValidElementType(Type *ElemTy);
        -:  313:
        -:  314:  // Iterator access to the elements.
        -:  315:  using element_iterator = Type::subtype_iterator;
        -:  316:
        -:  317:  element_iterator element_begin() const { return ContainedTys; }
        -:  318:  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}
        -:  319:  ArrayRef<Type *> elements() const {
        -:  320:    return makeArrayRef(element_begin(), element_end());
        -:  321:  }
        -:  322:
        -:  323:  /// Return true if this is layout identical to the specified struct.
        -:  324:  bool isLayoutIdentical(StructType *Other) const;
        -:  325:
        -:  326:  /// Random access to the elements
        -:  327:  unsigned getNumElements() const { return NumContainedTys; }
        -:  328:  Type *getElementType(unsigned N) const {
        -:  329:    assert(N < NumContainedTys && "Element number out of range!");
        -:  330:    return ContainedTys[N];
        -:  331:  }
        -:  332:  /// Given an index value into the type, return the type of the element.
        -:  333:  Type *getTypeAtIndex(const Value *V) const;
        -:  334:  Type *getTypeAtIndex(unsigned N) const { return getElementType(N); }
        -:  335:  bool indexValid(const Value *V) const;
        -:  336:  bool indexValid(unsigned Idx) const { return Idx < getNumElements(); }
        -:  337:
        -:  338:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
    #####:  339:  static bool classof(const Type *T) {
    #####:  340:    return T->getTypeID() == StructTyID;
branch  0 never executed
branch  1 never executed
        -:  341:  }
        -:  342:};
        -:  343:
        -:  344:StringRef Type::getStructName() const {
        -:  345:  return cast<StructType>(this)->getName();
        -:  346:}
        -:  347:
        -:  348:unsigned Type::getStructNumElements() const {
        -:  349:  return cast<StructType>(this)->getNumElements();
        -:  350:}
        -:  351:
        -:  352:Type *Type::getStructElementType(unsigned N) const {
        -:  353:  return cast<StructType>(this)->getElementType(N);
        -:  354:}
        -:  355:
        -:  356:/// Class to represent array types.
        -:  357:class ArrayType : public Type {
        -:  358:  /// The element type of the array.
        -:  359:  Type *ContainedType;
        -:  360:  /// Number of elements in the array.
        -:  361:  uint64_t NumElements;
        -:  362:
        -:  363:  ArrayType(Type *ElType, uint64_t NumEl);
        -:  364:
        -:  365:public:
        -:  366:  ArrayType(const ArrayType &) = delete;
        -:  367:  ArrayType &operator=(const ArrayType &) = delete;
        -:  368:
    #####:  369:  uint64_t getNumElements() const { return NumElements; }
    #####:  370:  Type *getElementType() const { return ContainedType; }
call    0 never executed
        -:  371:
        -:  372:  /// This static method is the primary way to construct an ArrayType
        -:  373:  static ArrayType *get(Type *ElementType, uint64_t NumElements);
        -:  374:
        -:  375:  /// Return true if the specified type is valid as a element type.
        -:  376:  static bool isValidElementType(Type *ElemTy);
        -:  377:
        -:  378:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
    #####:  379:  static bool classof(const Type *T) {
    #####:  380:    return T->getTypeID() == ArrayTyID;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  381:  }
        -:  382:};
        -:  383:
        -:  384:uint64_t Type::getArrayNumElements() const {
        -:  385:  return cast<ArrayType>(this)->getNumElements();
        -:  386:}
        -:  387:
        -:  388:/// Base class of all SIMD vector types
        -:  389:class VectorType : public Type {
        -:  390:  /// A fully specified VectorType is of the form <vscale x n x Ty>. 'n' is the
        -:  391:  /// minimum number of elements of type Ty contained within the vector, and
        -:  392:  /// 'vscale x' indicates that the total element count is an integer multiple
        -:  393:  /// of 'n', where the multiple is either guaranteed to be one, or is
        -:  394:  /// statically unknown at compile time.
        -:  395:  ///
        -:  396:  /// If the multiple is known to be 1, then the extra term is discarded in
        -:  397:  /// textual IR:
        -:  398:  ///
        -:  399:  /// <4 x i32>          - a vector containing 4 i32s
        -:  400:  /// <vscale x 4 x i32> - a vector containing an unknown integer multiple
        -:  401:  ///                      of 4 i32s
        -:  402:
        -:  403:  /// The element type of the vector.
        -:  404:  Type *ContainedType;
        -:  405:
        -:  406:protected:
        -:  407:  /// The element quantity of this vector. The meaning of this value depends
        -:  408:  /// on the type of vector:
        -:  409:  /// - For FixedVectorType = <ElementQuantity x ty>, there are
        -:  410:  ///   exactly ElementQuantity elements in this vector.
        -:  411:  /// - For ScalableVectorType = <vscale x ElementQuantity x ty>,
        -:  412:  ///   there are vscale * ElementQuantity elements in this vector, where
        -:  413:  ///   vscale is a runtime-constant integer greater than 0.
        -:  414:  const unsigned ElementQuantity;
        -:  415:
        -:  416:  VectorType(Type *ElType, unsigned EQ, Type::TypeID TID);
        -:  417:
        -:  418:public:
        -:  419:  VectorType(const VectorType &) = delete;
        -:  420:  VectorType &operator=(const VectorType &) = delete;
        -:  421:
    #####:  422:  Type *getElementType() const { return ContainedType; }
call    0 never executed
call    1 never executed
call    2 never executed
        -:  423:
        -:  424:  /// This static method is the primary way to construct an VectorType.
        -:  425:  static VectorType *get(Type *ElementType, ElementCount EC);
        -:  426:
        -:  427:  static VectorType *get(Type *ElementType, unsigned NumElements,
        -:  428:                         bool Scalable) {
        -:  429:    return VectorType::get(ElementType,
        -:  430:                           ElementCount::get(NumElements, Scalable));
        -:  431:  }
        -:  432:
        -:  433:  static VectorType *get(Type *ElementType, const VectorType *Other) {
        -:  434:    return VectorType::get(ElementType, Other->getElementCount());
        -:  435:  }
        -:  436:
        -:  437:  /// This static method gets a VectorType with the same number of elements as
        -:  438:  /// the input type, and the element type is an integer type of the same width
        -:  439:  /// as the input element type.
        -:  440:  static VectorType *getInteger(VectorType *VTy) {
        -:  441:    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
        -:  442:    assert(EltBits && "Element size must be of a non-zero size");
        -:  443:    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits);
        -:  444:    return VectorType::get(EltTy, VTy->getElementCount());
        -:  445:  }
        -:  446:
        -:  447:  /// This static method is like getInteger except that the element types are
        -:  448:  /// twice as wide as the elements in the input type.
        -:  449:  static VectorType *getExtendedElementVectorType(VectorType *VTy) {
        -:  450:    assert(VTy->isIntOrIntVectorTy() && "VTy expected to be a vector of ints.");
        -:  451:    auto *EltTy = cast<IntegerType>(VTy->getElementType());
        -:  452:    return VectorType::get(EltTy->getExtendedType(), VTy->getElementCount());
        -:  453:  }
        -:  454:
        -:  455:  // This static method gets a VectorType with the same number of elements as
        -:  456:  // the input type, and the element type is an integer or float type which
        -:  457:  // is half as wide as the elements in the input type.
        -:  458:  static VectorType *getTruncatedElementVectorType(VectorType *VTy) {
        -:  459:    Type *EltTy;
        -:  460:    if (VTy->getElementType()->isFloatingPointTy()) {
        -:  461:      switch(VTy->getElementType()->getTypeID()) {
        -:  462:      case DoubleTyID:
        -:  463:        EltTy = Type::getFloatTy(VTy->getContext());
        -:  464:        break;
        -:  465:      case FloatTyID:
        -:  466:        EltTy = Type::getHalfTy(VTy->getContext());
        -:  467:        break;
        -:  468:      default:
        -:  469:        llvm_unreachable("Cannot create narrower fp vector element type");
        -:  470:      }
        -:  471:    } else {
        -:  472:      unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();
        -:  473:      assert((EltBits & 1) == 0 &&
        -:  474:             "Cannot truncate vector element with odd bit-width");
        -:  475:      EltTy = IntegerType::get(VTy->getContext(), EltBits / 2);
        -:  476:    }
        -:  477:    return VectorType::get(EltTy, VTy->getElementCount());
        -:  478:  }
        -:  479:
        -:  480:  // This static method returns a VectorType with a smaller number of elements
        -:  481:  // of a larger type than the input element type. For example, a <16 x i8>
        -:  482:  // subdivided twice would return <4 x i32>
        -:  483:  static VectorType *getSubdividedVectorType(VectorType *VTy, int NumSubdivs) {
        -:  484:    for (int i = 0; i < NumSubdivs; ++i) {
        -:  485:      VTy = VectorType::getDoubleElementsVectorType(VTy);
        -:  486:      VTy = VectorType::getTruncatedElementVectorType(VTy);
        -:  487:    }
        -:  488:    return VTy;
        -:  489:  }
        -:  490:
        -:  491:  /// This static method returns a VectorType with half as many elements as the
        -:  492:  /// input type and the same element type.
        -:  493:  static VectorType *getHalfElementsVectorType(VectorType *VTy) {
        -:  494:    auto EltCnt = VTy->getElementCount();
        -:  495:    assert(EltCnt.isKnownEven() &&
        -:  496:           "Cannot halve vector with odd number of elements.");
        -:  497:    return VectorType::get(VTy->getElementType(),
        -:  498:                           EltCnt.divideCoefficientBy(2));
        -:  499:  }
        -:  500:
        -:  501:  /// This static method returns a VectorType with twice as many elements as the
        -:  502:  /// input type and the same element type.
        -:  503:  static VectorType *getDoubleElementsVectorType(VectorType *VTy) {
        -:  504:    auto EltCnt = VTy->getElementCount();
        -:  505:    assert((EltCnt.getKnownMinValue() * 2ull) <= UINT_MAX &&
        -:  506:           "Too many elements in vector");
        -:  507:    return VectorType::get(VTy->getElementType(), EltCnt * 2);
        -:  508:  }
        -:  509:
        -:  510:  /// Return true if the specified type is valid as a element type.
        -:  511:  static bool isValidElementType(Type *ElemTy);
        -:  512:
        -:  513:  /// Return an ElementCount instance to represent the (possibly scalable)
        -:  514:  /// number of elements in the vector.
        -:  515:  inline ElementCount getElementCount() const;
        -:  516:
        -:  517:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
    #####:  518:  static bool classof(const Type *T) {
    #####:  519:    return T->getTypeID() == FixedVectorTyID ||
branch  0 never executed
branch  1 never executed
    #####:  520:           T->getTypeID() == ScalableVectorTyID;
branch  0 never executed
branch  1 never executed
        -:  521:  }
        -:  522:};
        -:  523:
        -:  524:/// Class to represent fixed width SIMD vectors
        -:  525:class FixedVectorType : public VectorType {
        -:  526:protected:
        -:  527:  FixedVectorType(Type *ElTy, unsigned NumElts)
        -:  528:      : VectorType(ElTy, NumElts, FixedVectorTyID) {}
        -:  529:
        -:  530:public:
        -:  531:  static FixedVectorType *get(Type *ElementType, unsigned NumElts);
        -:  532:
        -:  533:  static FixedVectorType *get(Type *ElementType, const FixedVectorType *FVTy) {
        -:  534:    return get(ElementType, FVTy->getNumElements());
        -:  535:  }
        -:  536:
        -:  537:  static FixedVectorType *getInteger(FixedVectorType *VTy) {
        -:  538:    return cast<FixedVectorType>(VectorType::getInteger(VTy));
        -:  539:  }
        -:  540:
        -:  541:  static FixedVectorType *getExtendedElementVectorType(FixedVectorType *VTy) {
        -:  542:    return cast<FixedVectorType>(VectorType::getExtendedElementVectorType(VTy));
        -:  543:  }
        -:  544:
        -:  545:  static FixedVectorType *getTruncatedElementVectorType(FixedVectorType *VTy) {
        -:  546:    return cast<FixedVectorType>(
        -:  547:        VectorType::getTruncatedElementVectorType(VTy));
        -:  548:  }
        -:  549:
        -:  550:  static FixedVectorType *getSubdividedVectorType(FixedVectorType *VTy,
        -:  551:                                                  int NumSubdivs) {
        -:  552:    return cast<FixedVectorType>(
        -:  553:        VectorType::getSubdividedVectorType(VTy, NumSubdivs));
        -:  554:  }
        -:  555:
        -:  556:  static FixedVectorType *getHalfElementsVectorType(FixedVectorType *VTy) {
        -:  557:    return cast<FixedVectorType>(VectorType::getHalfElementsVectorType(VTy));
        -:  558:  }
        -:  559:
        -:  560:  static FixedVectorType *getDoubleElementsVectorType(FixedVectorType *VTy) {
        -:  561:    return cast<FixedVectorType>(VectorType::getDoubleElementsVectorType(VTy));
        -:  562:  }
        -:  563:
        -:  564:  static bool classof(const Type *T) {
        -:  565:    return T->getTypeID() == FixedVectorTyID;
        -:  566:  }
        -:  567:
        -:  568:  unsigned getNumElements() const { return ElementQuantity; }
        -:  569:};
        -:  570:
        -:  571:/// Class to represent scalable SIMD vectors
        -:  572:class ScalableVectorType : public VectorType {
        -:  573:protected:
        -:  574:  ScalableVectorType(Type *ElTy, unsigned MinNumElts)
        -:  575:      : VectorType(ElTy, MinNumElts, ScalableVectorTyID) {}
        -:  576:
        -:  577:public:
        -:  578:  static ScalableVectorType *get(Type *ElementType, unsigned MinNumElts);
        -:  579:
        -:  580:  static ScalableVectorType *get(Type *ElementType,
        -:  581:                                 const ScalableVectorType *SVTy) {
        -:  582:    return get(ElementType, SVTy->getMinNumElements());
        -:  583:  }
        -:  584:
        -:  585:  static ScalableVectorType *getInteger(ScalableVectorType *VTy) {
        -:  586:    return cast<ScalableVectorType>(VectorType::getInteger(VTy));
        -:  587:  }
        -:  588:
        -:  589:  static ScalableVectorType *
        -:  590:  getExtendedElementVectorType(ScalableVectorType *VTy) {
        -:  591:    return cast<ScalableVectorType>(
        -:  592:        VectorType::getExtendedElementVectorType(VTy));
        -:  593:  }
        -:  594:
        -:  595:  static ScalableVectorType *
        -:  596:  getTruncatedElementVectorType(ScalableVectorType *VTy) {
        -:  597:    return cast<ScalableVectorType>(
        -:  598:        VectorType::getTruncatedElementVectorType(VTy));
        -:  599:  }
        -:  600:
        -:  601:  static ScalableVectorType *getSubdividedVectorType(ScalableVectorType *VTy,
        -:  602:                                                     int NumSubdivs) {
        -:  603:    return cast<ScalableVectorType>(
        -:  604:        VectorType::getSubdividedVectorType(VTy, NumSubdivs));
        -:  605:  }
        -:  606:
        -:  607:  static ScalableVectorType *
        -:  608:  getHalfElementsVectorType(ScalableVectorType *VTy) {
        -:  609:    return cast<ScalableVectorType>(VectorType::getHalfElementsVectorType(VTy));
        -:  610:  }
        -:  611:
        -:  612:  static ScalableVectorType *
        -:  613:  getDoubleElementsVectorType(ScalableVectorType *VTy) {
        -:  614:    return cast<ScalableVectorType>(
        -:  615:        VectorType::getDoubleElementsVectorType(VTy));
        -:  616:  }
        -:  617:
        -:  618:  /// Get the minimum number of elements in this vector. The actual number of
        -:  619:  /// elements in the vector is an integer multiple of this value.
        -:  620:  uint64_t getMinNumElements() const { return ElementQuantity; }
        -:  621:
    #####:  622:  static bool classof(const Type *T) {
    #####:  623:    return T->getTypeID() == ScalableVectorTyID;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  624:  }
        -:  625:};
        -:  626:
    #####:  627:inline ElementCount VectorType::getElementCount() const {
    #####:  628:  return ElementCount::get(ElementQuantity, isa<ScalableVectorType>(this));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
        -:  629:}
        -:  630:
        -:  631:/// Class to represent pointers.
        -:  632:class PointerType : public Type {
        -:  633:  explicit PointerType(Type *ElType, unsigned AddrSpace);
        -:  634:  explicit PointerType(LLVMContext &C, unsigned AddrSpace);
        -:  635:
        -:  636:  Type *PointeeTy;
        -:  637:
        -:  638:public:
        -:  639:  PointerType(const PointerType &) = delete;
        -:  640:  PointerType &operator=(const PointerType &) = delete;
        -:  641:
        -:  642:  /// This constructs a pointer to an object of the specified type in a numbered
        -:  643:  /// address space.
        -:  644:  static PointerType *get(Type *ElementType, unsigned AddressSpace);
        -:  645:  /// This constructs an opaque pointer to an object in a numbered address
        -:  646:  /// space.
        -:  647:  static PointerType *get(LLVMContext &C, unsigned AddressSpace);
        -:  648:
        -:  649:  /// This constructs a pointer to an object of the specified type in the
        -:  650:  /// default address space (address space zero).
        -:  651:  static PointerType *getUnqual(Type *ElementType) {
        -:  652:    return PointerType::get(ElementType, 0);
        -:  653:  }
        -:  654:
        -:  655:  /// This constructs an opaque pointer to an object in the
        -:  656:  /// default address space (address space zero).
        -:  657:  static PointerType *getUnqual(LLVMContext &C) {
        -:  658:    return PointerType::get(C, 0);
        -:  659:  }
        -:  660:
        -:  661:  /// This constructs a pointer type with the same pointee type as input
        -:  662:  /// PointerType (or opaque pointer if the input PointerType is opaque) and the
        -:  663:  /// given address space. This is only useful during the opaque pointer
        -:  664:  /// transition.
        -:  665:  /// TODO: remove after opaque pointer transition is complete.
        -:  666:  static PointerType *getWithSamePointeeType(PointerType *PT,
        -:  667:                                             unsigned AddressSpace) {
        -:  668:    if (PT->isOpaque())
        -:  669:      return get(PT->getContext(), AddressSpace);
        -:  670:    return get(PT->PointeeTy, AddressSpace);
        -:  671:  }
        -:  672:
    #####:  673:  bool isOpaque() const { return !PointeeTy; }
branch  0 never executed
branch  1 never executed
        -:  674:
        -:  675:  /// Return true if the specified type is valid as a element type.
        -:  676:  static bool isValidElementType(Type *ElemTy);
        -:  677:
        -:  678:  /// Return true if we can load or store from a pointer to this type.
        -:  679:  static bool isLoadableOrStorableType(Type *ElemTy);
        -:  680:
        -:  681:  /// Return the address space of the Pointer type.
    #####:  682:  inline unsigned getAddressSpace() const { return getSubclassData(); }
call    0 never executed
        -:  683:
        -:  684:  /// Return true if either this is an opaque pointer type or if this pointee
        -:  685:  /// type matches Ty. Primarily used for checking if an instruction's pointer
        -:  686:  /// operands are valid types. Will be useless after non-opaque pointers are
        -:  687:  /// removed.
    #####:  688:  bool isOpaqueOrPointeeTypeMatches(Type *Ty) {
    #####:  689:    return isOpaque() || PointeeTy == Ty;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  690:  }
        -:  691:
        -:  692:  /// Return true if both pointer types have the same element type. Two opaque
        -:  693:  /// pointers are considered to have the same element type, while an opaque
        -:  694:  /// and a non-opaque pointer have different element types.
        -:  695:  /// TODO: Remove after opaque pointer transition is complete.
        -:  696:  bool hasSameElementTypeAs(PointerType *Other) {
        -:  697:    return PointeeTy == Other->PointeeTy;
        -:  698:  }
        -:  699:
        -:  700:  /// Implement support type inquiry through isa, cast, and dyn_cast.
        -:  701:  static bool classof(const Type *T) {
        -:  702:    return T->getTypeID() == PointerTyID;
        -:  703:  }
        -:  704:};
        -:  705:
        -:  706:Type *Type::getExtendedType() const {
        -:  707:  assert(
        -:  708:      isIntOrIntVectorTy() &&
        -:  709:      "Original type expected to be a vector of integers or a scalar integer.");
        -:  710:  if (auto *VTy = dyn_cast<VectorType>(this))
        -:  711:    return VectorType::getExtendedElementVectorType(
        -:  712:        const_cast<VectorType *>(VTy));
        -:  713:  return cast<IntegerType>(this)->getExtendedType();
        -:  714:}
        -:  715:
        -:  716:Type *Type::getWithNewType(Type *EltTy) const {
        -:  717:  if (auto *VTy = dyn_cast<VectorType>(this))
        -:  718:    return VectorType::get(EltTy, VTy->getElementCount());
        -:  719:  return EltTy;
        -:  720:}
        -:  721:
        -:  722:Type *Type::getWithNewBitWidth(unsigned NewBitWidth) const {
        -:  723:  assert(
        -:  724:      isIntOrIntVectorTy() &&
        -:  725:      "Original type expected to be a vector of integers or a scalar integer.");
        -:  726:  return getWithNewType(getIntNTy(getContext(), NewBitWidth));
        -:  727:}
        -:  728:
    #####:  729:unsigned Type::getPointerAddressSpace() const {
    #####:  730:  return cast<PointerType>(getScalarType())->getAddressSpace();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  731:}
        -:  732:
        -:  733:} // end namespace llvm
        -:  734:
        -:  735:#endif // LLVM_IR_DERIVEDTYPES_H
