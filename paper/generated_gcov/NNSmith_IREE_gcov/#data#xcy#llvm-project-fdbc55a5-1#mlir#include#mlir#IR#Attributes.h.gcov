        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/include/mlir/IR/Attributes.h
        -:    0:Graph:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- Attributes.h - MLIR Attribute Classes --------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef MLIR_IR_ATTRIBUTES_H
        -:   10:#define MLIR_IR_ATTRIBUTES_H
        -:   11:
        -:   12:#include "mlir/IR/AttributeSupport.h"
        -:   13:#include "llvm/Support/PointerLikeTypeTraits.h"
        -:   14:
        -:   15:namespace mlir {
        -:   16:class AsmState;
        -:   17:class StringAttr;
        -:   18:
        -:   19:/// Attributes are known-constant values of operations.
        -:   20:///
        -:   21:/// Instances of the Attribute class are references to immortal key-value pairs
        -:   22:/// with immutable, uniqued keys owned by MLIRContext. As such, an Attribute is
        -:   23:/// a thin wrapper around an underlying storage pointer. Attributes are usually
        -:   24:/// passed by value.
        -:   25:class Attribute {
        -:   26:public:
        -:   27:  /// Utility class for implementing attributes.
        -:   28:  template <typename ConcreteType, typename BaseType, typename StorageType,
        -:   29:            template <typename T> class... Traits>
        -:   30:  using AttrBase = detail::StorageUserBase<ConcreteType, BaseType, StorageType,
        -:   31:                                           detail::AttributeUniquer, Traits...>;
        -:   32:
        -:   33:  using ImplType = AttributeStorage;
        -:   34:  using ValueType = void;
        -:   35:  using AbstractTy = AbstractAttribute;
        -:   36:
        -:   37:  constexpr Attribute() = default;
        -:   38:  /* implicit */ Attribute(const ImplType *impl)
        -:   39:      : impl(const_cast<ImplType *>(impl)) {}
        -:   40:
        -:   41:  Attribute(const Attribute &other) = default;
        -:   42:  Attribute &operator=(const Attribute &other) = default;
        -:   43:
        -:   44:  bool operator==(Attribute other) const { return impl == other.impl; }
        -:   45:  bool operator!=(Attribute other) const { return !(*this == other); }
    #####:   46:  explicit operator bool() const { return impl; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   47:
        -:   48:  bool operator!() const { return impl == nullptr; }
        -:   49:
        -:   50:  /// Casting utility functions. These are deprecated and will be removed,
        -:   51:  /// please prefer using the `llvm` namespace variants instead.
        -:   52:  template <typename... Tys>
        -:   53:  bool isa() const;
        -:   54:  template <typename... Tys>
        -:   55:  bool isa_and_nonnull() const;
        -:   56:  template <typename U>
        -:   57:  U dyn_cast() const;
        -:   58:  template <typename U>
        -:   59:  U dyn_cast_or_null() const;
        -:   60:  template <typename U>
        -:   61:  U cast() const;
        -:   62:
        -:   63:  // Support dyn_cast'ing Attribute to itself.
        -:   64:  static bool classof(Attribute) { return true; }
        -:   65:
        -:   66:  /// Return a unique identifier for the concrete attribute type. This is used
        -:   67:  /// to support dynamic type casting.
        -:   68:  TypeID getTypeID() { return impl->getAbstractAttribute().getTypeID(); }
        -:   69:
        -:   70:  /// Return the context this attribute belongs to.
        -:   71:  MLIRContext *getContext() const;
        -:   72:
        -:   73:  /// Get the dialect this attribute is registered to.
        -:   74:  Dialect &getDialect() const {
        -:   75:    return impl->getAbstractAttribute().getDialect();
        -:   76:  }
        -:   77:
        -:   78:  /// Print the attribute. If `elideType` is set, the attribute is printed
        -:   79:  /// without a trailing colon type if it has one.
        -:   80:  void print(raw_ostream &os, bool elideType = false) const;
        -:   81:  void print(raw_ostream &os, AsmState &state, bool elideType = false) const;
        -:   82:  void dump() const;
        -:   83:
        -:   84:  /// Get an opaque pointer to the attribute.
        -:   85:  const void *getAsOpaquePointer() const { return impl; }
        -:   86:  /// Construct an attribute from the opaque pointer representation.
        -:   87:  static Attribute getFromOpaquePointer(const void *ptr) {
        -:   88:    return Attribute(reinterpret_cast<const ImplType *>(ptr));
        -:   89:  }
        -:   90:
        -:   91:  friend ::llvm::hash_code hash_value(Attribute arg);
        -:   92:
        -:   93:  /// Returns true if the type was registered with a particular trait.
        -:   94:  template <template <typename T> class Trait>
        -:   95:  bool hasTrait() {
        -:   96:    return getAbstractAttribute().hasTrait<Trait>();
        -:   97:  }
        -:   98:
        -:   99:  /// Return the abstract descriptor for this attribute.
        -:  100:  const AbstractTy &getAbstractAttribute() const {
        -:  101:    return impl->getAbstractAttribute();
        -:  102:  }
        -:  103:
        -:  104:  /// Return the internal Attribute implementation.
        -:  105:  ImplType *getImpl() const { return impl; }
        -:  106:
        -:  107:protected:
        -:  108:  ImplType *impl{nullptr};
        -:  109:};
        -:  110:
        -:  111:inline raw_ostream &operator<<(raw_ostream &os, Attribute attr) {
        -:  112:  attr.print(os);
        -:  113:  return os;
        -:  114:}
        -:  115:
        -:  116:template <typename... Tys>
        -:  117:bool Attribute::isa() const {
        -:  118:  return llvm::isa<Tys...>(*this);
        -:  119:}
        -:  120:
        -:  121:template <typename... Tys>
        -:  122:bool Attribute::isa_and_nonnull() const {
        -:  123:  return llvm::isa_and_present<Tys...>(*this);
        -:  124:}
        -:  125:
        -:  126:template <typename U>
        -:  127:U Attribute::dyn_cast() const {
        -:  128:  return llvm::dyn_cast<U>(*this);
        -:  129:}
        -:  130:
        -:  131:template <typename U>
        -:  132:U Attribute::dyn_cast_or_null() const {
        -:  133:  return llvm::dyn_cast_if_present<U>(*this);
        -:  134:}
        -:  135:
        -:  136:template <typename U>
        -:  137:U Attribute::cast() const {
        -:  138:  return llvm::cast<U>(*this);
        -:  139:}
        -:  140:
        -:  141:inline ::llvm::hash_code hash_value(Attribute arg) {
        -:  142:  return DenseMapInfo<const Attribute::ImplType *>::getHashValue(arg.impl);
        -:  143:}
        -:  144:
        -:  145://===----------------------------------------------------------------------===//
        -:  146:// NamedAttribute
        -:  147://===----------------------------------------------------------------------===//
        -:  148:
        -:  149:/// NamedAttribute represents a combination of a name and an Attribute value.
        -:  150:class NamedAttribute {
        -:  151:public:
        -:  152:  NamedAttribute(StringAttr name, Attribute value);
        -:  153:
        -:  154:  /// Return the name of the attribute.
        -:  155:  StringAttr getName() const;
        -:  156:
        -:  157:  /// Return the dialect of the name of this attribute, if the name is prefixed
        -:  158:  /// by a dialect namespace. For example, `llvm.fast_math` would return the
        -:  159:  /// LLVM dialect (if it is loaded). Returns nullptr if the dialect isn't
        -:  160:  /// loaded, or if the name is not prefixed by a dialect namespace.
        -:  161:  Dialect *getNameDialect() const;
        -:  162:
        -:  163:  /// Return the value of the attribute.
        -:  164:  Attribute getValue() const { return value; }
        -:  165:
        -:  166:  /// Set the name of this attribute.
        -:  167:  void setName(StringAttr newName);
        -:  168:
        -:  169:  /// Set the value of this attribute.
        -:  170:  void setValue(Attribute newValue) {
        -:  171:    assert(value && "expected valid attribute value");
        -:  172:    value = newValue;
        -:  173:  }
        -:  174:
        -:  175:  /// Compare this attribute to the provided attribute, ordering by name.
        -:  176:  bool operator<(const NamedAttribute &rhs) const;
        -:  177:  /// Compare this attribute to the provided string, ordering by name.
        -:  178:  bool operator<(StringRef rhs) const;
        -:  179:
        -:  180:  bool operator==(const NamedAttribute &rhs) const {
        -:  181:    return name == rhs.name && value == rhs.value;
        -:  182:  }
        -:  183:  bool operator!=(const NamedAttribute &rhs) const { return !(*this == rhs); }
        -:  184:
        -:  185:private:
        -:  186:  NamedAttribute(Attribute name, Attribute value) : name(name), value(value) {}
        -:  187:
        -:  188:  /// Allow access to internals to enable hashing.
        -:  189:  friend ::llvm::hash_code hash_value(const NamedAttribute &arg);
        -:  190:  friend DenseMapInfo<NamedAttribute>;
        -:  191:
        -:  192:  /// The name of the attribute. This is represented as a StringAttr, but
        -:  193:  /// type-erased to Attribute in the field.
        -:  194:  Attribute name;
        -:  195:  /// The value of the attribute.
        -:  196:  Attribute value;
        -:  197:};
        -:  198:
        -:  199:inline ::llvm::hash_code hash_value(const NamedAttribute &arg) {
        -:  200:  using AttrPairT = std::pair<Attribute, Attribute>;
        -:  201:  return DenseMapInfo<AttrPairT>::getHashValue(AttrPairT(arg.name, arg.value));
        -:  202:}
        -:  203:
        -:  204://===----------------------------------------------------------------------===//
        -:  205:// AttributeTraitBase
        -:  206://===----------------------------------------------------------------------===//
        -:  207:
        -:  208:namespace AttributeTrait {
        -:  209:/// This class represents the base of an attribute trait.
        -:  210:template <typename ConcreteType, template <typename> class TraitType>
        -:  211:using TraitBase = detail::StorageUserTraitBase<ConcreteType, TraitType>;
        -:  212:} // namespace AttributeTrait
        -:  213:
        -:  214://===----------------------------------------------------------------------===//
        -:  215:// AttributeInterface
        -:  216://===----------------------------------------------------------------------===//
        -:  217:
        -:  218:/// This class represents the base of an attribute interface. See the definition
        -:  219:/// of `detail::Interface` for requirements on the `Traits` type.
        -:  220:template <typename ConcreteType, typename Traits>
        -:  221:class AttributeInterface
        -:  222:    : public detail::Interface<ConcreteType, Attribute, Traits, Attribute,
        -:  223:                               AttributeTrait::TraitBase> {
        -:  224:public:
        -:  225:  using Base = AttributeInterface<ConcreteType, Traits>;
        -:  226:  using InterfaceBase = detail::Interface<ConcreteType, Attribute, Traits,
        -:  227:                                          Attribute, AttributeTrait::TraitBase>;
        -:  228:  using InterfaceBase::InterfaceBase;
        -:  229:
        -:  230:private:
        -:  231:  /// Returns the impl interface instance for the given type.
        -:  232:  static typename InterfaceBase::Concept *getInterfaceFor(Attribute attr) {
        -:  233:    return attr.getAbstractAttribute().getInterface<ConcreteType>();
        -:  234:  }
        -:  235:
        -:  236:  /// Allow access to 'getInterfaceFor'.
        -:  237:  friend InterfaceBase;
        -:  238:};
        -:  239:
        -:  240://===----------------------------------------------------------------------===//
        -:  241:// Core AttributeTrait
        -:  242://===----------------------------------------------------------------------===//
        -:  243:
        -:  244:/// This trait is used to determine if an attribute is mutable or not. It is
        -:  245:/// attached on an attribute if the corresponding ImplType defines a `mutate`
        -:  246:/// function with proper signature.
        -:  247:namespace AttributeTrait {
        -:  248:template <typename ConcreteType>
        -:  249:using IsMutable = detail::StorageUserTrait::IsMutable<ConcreteType>;
        -:  250:} // namespace AttributeTrait
        -:  251:
        -:  252:} // namespace mlir.
        -:  253:
        -:  254:namespace llvm {
        -:  255:
        -:  256:// Attribute hash just like pointers.
        -:  257:template <>
        -:  258:struct DenseMapInfo<mlir::Attribute> {
        -:  259:  static mlir::Attribute getEmptyKey() {
        -:  260:    auto *pointer = llvm::DenseMapInfo<void *>::getEmptyKey();
        -:  261:    return mlir::Attribute(static_cast<mlir::Attribute::ImplType *>(pointer));
        -:  262:  }
        -:  263:  static mlir::Attribute getTombstoneKey() {
        -:  264:    auto *pointer = llvm::DenseMapInfo<void *>::getTombstoneKey();
        -:  265:    return mlir::Attribute(static_cast<mlir::Attribute::ImplType *>(pointer));
        -:  266:  }
        -:  267:  static unsigned getHashValue(mlir::Attribute val) {
        -:  268:    return mlir::hash_value(val);
        -:  269:  }
        -:  270:  static bool isEqual(mlir::Attribute LHS, mlir::Attribute RHS) {
        -:  271:    return LHS == RHS;
        -:  272:  }
        -:  273:};
        -:  274:template <typename T>
        -:  275:struct DenseMapInfo<
        -:  276:    T, std::enable_if_t<std::is_base_of<mlir::Attribute, T>::value &&
        -:  277:                        !mlir::detail::IsInterface<T>::value>>
        -:  278:    : public DenseMapInfo<mlir::Attribute> {
        -:  279:  static T getEmptyKey() {
        -:  280:    const void *pointer = llvm::DenseMapInfo<const void *>::getEmptyKey();
        -:  281:    return T::getFromOpaquePointer(pointer);
        -:  282:  }
        -:  283:  static T getTombstoneKey() {
        -:  284:    const void *pointer = llvm::DenseMapInfo<const void *>::getTombstoneKey();
        -:  285:    return T::getFromOpaquePointer(pointer);
        -:  286:  }
        -:  287:};
        -:  288:
        -:  289:/// Allow LLVM to steal the low bits of Attributes.
        -:  290:template <>
        -:  291:struct PointerLikeTypeTraits<mlir::Attribute> {
        -:  292:  static inline void *getAsVoidPointer(mlir::Attribute attr) {
        -:  293:    return const_cast<void *>(attr.getAsOpaquePointer());
        -:  294:  }
        -:  295:  static inline mlir::Attribute getFromVoidPointer(void *ptr) {
        -:  296:    return mlir::Attribute::getFromOpaquePointer(ptr);
        -:  297:  }
        -:  298:  static constexpr int NumLowBitsAvailable = llvm::PointerLikeTypeTraits<
        -:  299:      mlir::AttributeStorage *>::NumLowBitsAvailable;
        -:  300:};
        -:  301:
        -:  302:template <>
        -:  303:struct DenseMapInfo<mlir::NamedAttribute> {
        -:  304:  static mlir::NamedAttribute getEmptyKey() {
        -:  305:    auto emptyAttr = llvm::DenseMapInfo<mlir::Attribute>::getEmptyKey();
        -:  306:    return mlir::NamedAttribute(emptyAttr, emptyAttr);
        -:  307:  }
        -:  308:  static mlir::NamedAttribute getTombstoneKey() {
        -:  309:    auto tombAttr = llvm::DenseMapInfo<mlir::Attribute>::getTombstoneKey();
        -:  310:    return mlir::NamedAttribute(tombAttr, tombAttr);
        -:  311:  }
        -:  312:  static unsigned getHashValue(mlir::NamedAttribute val) {
        -:  313:    return mlir::hash_value(val);
        -:  314:  }
        -:  315:  static bool isEqual(mlir::NamedAttribute lhs, mlir::NamedAttribute rhs) {
        -:  316:    return lhs == rhs;
        -:  317:  }
        -:  318:};
        -:  319:
        -:  320:/// Add support for llvm style casts. We provide a cast between To and From if
        -:  321:/// From is mlir::Attribute or derives from it.
        -:  322:template <typename To, typename From>
        -:  323:struct CastInfo<To, From,
        -:  324:                std::enable_if_t<std::is_same_v<mlir::Attribute,
        -:  325:                                                std::remove_const_t<From>> ||
        -:  326:                                 std::is_base_of_v<mlir::Attribute, From>>>
        -:  327:    : NullableValueCastFailed<To>,
        -:  328:      DefaultDoCastIfPossible<To, From, CastInfo<To, From>> {
        -:  329:  /// Arguments are taken as mlir::Attribute here and not as `From`, because
        -:  330:  /// when casting from an intermediate type of the hierarchy to one of its
        -:  331:  /// children, the val.getTypeID() inside T::classof will use the static
        -:  332:  /// getTypeID of the parent instead of the non-static Type::getTypeID that
        -:  333:  /// returns the dynamic ID. This means that T::classof would end up comparing
        -:  334:  /// the static TypeID of the children to the static TypeID of its parent,
        -:  335:  /// making it impossible to downcast from the parent to the child.
        -:  336:  static inline bool isPossible(mlir::Attribute ty) {
        -:  337:    /// Return a constant true instead of a dynamic true when casting to self or
        -:  338:    /// up the hierarchy.
        -:  339:    return std::is_same_v<To, std::remove_const_t<From>> ||
        -:  340:           std::is_base_of_v<To, From> || To::classof(ty);
        -:  341:  }
        -:  342:  static inline To doCast(mlir::Attribute attr) { return To(attr.getImpl()); }
        -:  343:};
        -:  344:
        -:  345:} // namespace llvm
        -:  346:
        -:  347:#endif
