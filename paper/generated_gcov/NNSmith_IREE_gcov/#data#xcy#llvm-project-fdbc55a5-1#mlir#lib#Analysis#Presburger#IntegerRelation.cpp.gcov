        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Analysis/Presburger/IntegerRelation.cpp
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/IntegerRelation.cpp.gcda
        -:    0:Runs:325594
        -:    1://===- IntegerRelation.cpp - MLIR IntegerRelation Class ---------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// A class to represent an relation over integer tuples. A relation is
        -:   10:// represented as a constraint system over a space of tuples of integer valued
        -:   11:// variables supporting symbolic variables and existential quantification.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#include "mlir/Analysis/Presburger/IntegerRelation.h"
        -:   16:#include "mlir/Analysis/Presburger/LinearTransform.h"
        -:   17:#include "mlir/Analysis/Presburger/PWMAFunction.h"
        -:   18:#include "mlir/Analysis/Presburger/PresburgerRelation.h"
        -:   19:#include "mlir/Analysis/Presburger/Simplex.h"
        -:   20:#include "mlir/Analysis/Presburger/Utils.h"
        -:   21:#include "llvm/ADT/DenseMap.h"
        -:   22:#include "llvm/ADT/DenseSet.h"
        -:   23:#include "llvm/Support/Debug.h"
        -:   24:#include <numeric>
        -:   25:
        -:   26:#define DEBUG_TYPE "presburger"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:using namespace presburger;
        -:   30:
        -:   31:using llvm::SmallDenseMap;
        -:   32:using llvm::SmallDenseSet;
        -:   33:
function _ZNK4mlir10presburger15IntegerRelation5cloneEv called 0 returned 0% blocks executed 0%
    #####:   34:std::unique_ptr<IntegerRelation> IntegerRelation::clone() const {
    #####:   35:  return std::make_unique<IntegerRelation>(*this);
call    0 never executed
        -:   36:}
        -:   37:
function _ZNK4mlir10presburger17IntegerPolyhedron5cloneEv called 0 returned 0% blocks executed 0%
    #####:   38:std::unique_ptr<IntegerPolyhedron> IntegerPolyhedron::clone() const {
    #####:   39:  return std::make_unique<IntegerPolyhedron>(*this);
call    0 never executed
        -:   40:}
        -:   41:
function _ZN4mlir10presburger15IntegerRelation8setSpaceERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   42:void IntegerRelation::setSpace(const PresburgerSpace &oSpace) {
    #####:   43:  assert(space.getNumVars() == oSpace.getNumVars() && "invalid space!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   44:  space = oSpace;
call    0 never executed
    #####:   45:}
        -:   46:
function _ZN4mlir10presburger15IntegerRelation20setSpaceExceptLocalsERKNS0_15PresburgerSpaceE called 0 returned 0% blocks executed 0%
    #####:   47:void IntegerRelation::setSpaceExceptLocals(const PresburgerSpace &oSpace) {
    #####:   48:  assert(oSpace.getNumLocalVars() == 0 && "no locals should be present!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   49:  assert(oSpace.getNumVars() <= getNumVars() && "invalid space!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   50:  unsigned newNumLocals = getNumVars() - oSpace.getNumVars();
call    0 never executed
    #####:   51:  space = oSpace;
call    0 never executed
    #####:   52:  space.insertVar(VarKind::Local, 0, newNumLocals);
call    0 never executed
    #####:   53:}
        -:   54:
function _ZN4mlir10presburger15IntegerRelation6appendERKS1_ called 0 returned 0% blocks executed 0%
    #####:   55:void IntegerRelation::append(const IntegerRelation &other) {
    #####:   56:  assert(space.isEqual(other.getSpace()) && "Spaces must be equal.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   57:
    #####:   58:  inequalities.reserveRows(inequalities.getNumRows() +
call    0 never executed
    #####:   59:                           other.getNumInequalities());
call    0 never executed
    #####:   60:  equalities.reserveRows(equalities.getNumRows() + other.getNumEqualities());
call    0 never executed
        -:   61:
    #####:   62:  for (unsigned r = 0, e = other.getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####:   63:    addInequality(other.getInequality(r));
call    0 never executed
call    1 never executed
        -:   64:  }
    #####:   65:  for (unsigned r = 0, e = other.getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####:   66:    addEquality(other.getEquality(r));
call    0 never executed
call    1 never executed
        -:   67:  }
    #####:   68:}
        -:   69:
function _ZNK4mlir10presburger15IntegerRelation9intersectES1_ called 0 returned 0% blocks executed 0%
    #####:   70:IntegerRelation IntegerRelation::intersect(IntegerRelation other) const {
    #####:   71:  IntegerRelation result = *this;
call    0 never executed
    #####:   72:  result.mergeLocalVars(other);
call    0 never executed
call    1 never executed
    #####:   73:  result.append(other);
call    0 never executed
call    1 never executed
    #####:   74:  return result;
        -:   75:}
        -:   76:
function _ZNK4mlir10presburger15IntegerRelation7isEqualERKS1_ called 0 returned 0% blocks executed 0%
    #####:   77:bool IntegerRelation::isEqual(const IntegerRelation &other) const {
    #####:   78:  assert(space.isCompatible(other.getSpace()) && "Spaces must be compatible.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   79:  return PresburgerRelation(*this).isEqual(PresburgerRelation(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   80:}
        -:   81:
function _ZNK4mlir10presburger15IntegerRelation10isSubsetOfERKS1_ called 0 returned 0% blocks executed 0%
    #####:   82:bool IntegerRelation::isSubsetOf(const IntegerRelation &other) const {
    #####:   83:  assert(space.isCompatible(other.getSpace()) && "Spaces must be compatible.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   84:  return PresburgerRelation(*this).isSubsetOf(PresburgerRelation(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   85:}
        -:   86:
        -:   87:MaybeOptimum<SmallVector<Fraction, 8>>
function _ZNK4mlir10presburger15IntegerRelation18findRationalLexMinEv called 0 returned 0% blocks executed 0%
    #####:   88:IntegerRelation::findRationalLexMin() const {
    #####:   89:  assert(getNumSymbolVars() == 0 && "Symbols are not supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   90:  MaybeOptimum<SmallVector<Fraction, 8>> maybeLexMin =
call    0 never executed
    #####:   91:      LexSimplex(*this).findRationalLexMin();
call    0 never executed
call    1 never executed
        -:   92:
    #####:   93:  if (!maybeLexMin.isBounded())
branch  0 never executed
branch  1 never executed
        -:   94:    return maybeLexMin;
        -:   95:
        -:   96:  // The Simplex returns the lexmin over all the variables including locals. But
        -:   97:  // locals are not actually part of the space and should not be returned in the
        -:   98:  // result. Since the locals are placed last in the list of variables, they
        -:   99:  // will be minimized last in the lexmin. So simply truncating out the locals
        -:  100:  // from the end of the answer gives the desired lexmin over the dimensions.
    #####:  101:  assert(maybeLexMin->size() == getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  102:         "Incorrect number of vars in lexMin!");
    #####:  103:  maybeLexMin->resize(getNumDimAndSymbolVars());
call    0 never executed
        -:  104:  return maybeLexMin;
        -:  105:}
        -:  106:
function _ZNK4mlir10presburger15IntegerRelation17findIntegerLexMinEv called 0 returned 0% blocks executed 0%
    #####:  107:MaybeOptimum<SmallVector<MPInt, 8>> IntegerRelation::findIntegerLexMin() const {
    #####:  108:  assert(getNumSymbolVars() == 0 && "Symbols are not supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  109:  MaybeOptimum<SmallVector<MPInt, 8>> maybeLexMin =
call    0 never executed
    #####:  110:      LexSimplex(*this).findIntegerLexMin();
call    0 never executed
call    1 never executed
        -:  111:
    #####:  112:  if (!maybeLexMin.isBounded())
branch  0 never executed
branch  1 never executed
    #####:  113:    return maybeLexMin.getKind();
        -:  114:
        -:  115:  // The Simplex returns the lexmin over all the variables including locals. But
        -:  116:  // locals are not actually part of the space and should not be returned in the
        -:  117:  // result. Since the locals are placed last in the list of variables, they
        -:  118:  // will be minimized last in the lexmin. So simply truncating out the locals
        -:  119:  // from the end of the answer gives the desired lexmin over the dimensions.
    #####:  120:  assert(maybeLexMin->size() == getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  121:         "Incorrect number of vars in lexMin!");
    #####:  122:  maybeLexMin->resize(getNumDimAndSymbolVars());
call    0 never executed
    #####:  123:  return maybeLexMin;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  124:}
        -:  125:
    #####:  126:static bool rangeIsZero(ArrayRef<MPInt> range) {
function _ZZL11rangeIsZeroN4llvm8ArrayRefIN4mlir10presburger5MPIntEEEENKUlRKS3_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  127:  return llvm::all_of(range, [](const MPInt &x) { return x == 0; });
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  128:}
        -:  129:
function _ZL34removeConstraintsInvolvingVarRangeRN4mlir10presburger15IntegerRelationEjj called 0 returned 0% blocks executed 0%
    #####:  130:static void removeConstraintsInvolvingVarRange(IntegerRelation &poly,
        -:  131:                                               unsigned begin, unsigned count) {
        -:  132:  // We loop until i > 0 and index into i - 1 to avoid sign issues.
        -:  133:  //
        -:  134:  // We iterate backwards so that whether we remove constraint i - 1 or not, the
        -:  135:  // next constraint to be tested is always i - 2.
    #####:  136:  for (unsigned i = poly.getNumEqualities(); i > 0; i--)
    #####:  137:    if (!rangeIsZero(poly.getEquality(i - 1).slice(begin, count)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  138:      poly.removeEquality(i - 1);
branch  0 never executed
branch  1 never executed
    #####:  139:  for (unsigned i = poly.getNumInequalities(); i > 0; i--)
    #####:  140:    if (!rangeIsZero(poly.getInequality(i - 1).slice(begin, count)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  141:      poly.removeInequality(i - 1);
branch  0 never executed
branch  1 never executed
    #####:  142:}
        -:  143:
function _ZNK4mlir10presburger15IntegerRelation9getCountsEv called 0 returned 0% blocks executed 0%
    #####:  144:IntegerRelation::CountsSnapshot IntegerRelation::getCounts() const {
    #####:  145:  return {getSpace(), getNumInequalities(), getNumEqualities()};
call    0 never executed
        -:  146:}
        -:  147:
function _ZN4mlir10presburger15IntegerRelation15truncateVarKindENS0_7VarKindEj called 0 returned 0% blocks executed 0%
    #####:  148:void IntegerRelation::truncateVarKind(VarKind kind, unsigned num) {
    #####:  149:  unsigned curNum = getNumVarKind(kind);
call    0 never executed
    #####:  150:  assert(num <= curNum && "Can't truncate to more vars!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  151:  removeVarRange(kind, num, curNum);
call    0 never executed
    #####:  152:}
        -:  153:
function _ZN4mlir10presburger15IntegerRelation15truncateVarKindENS0_7VarKindERKNS1_14CountsSnapshotE called 0 returned 0% blocks executed 0%
    #####:  154:void IntegerRelation::truncateVarKind(VarKind kind,
        -:  155:                                      const CountsSnapshot &counts) {
    #####:  156:  truncateVarKind(kind, counts.getSpace().getNumVarKind(kind));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  157:}
        -:  158:
function _ZN4mlir10presburger15IntegerRelation8truncateERKNS1_14CountsSnapshotE called 0 returned 0% blocks executed 0%
    #####:  159:void IntegerRelation::truncate(const CountsSnapshot &counts) {
    #####:  160:  truncateVarKind(VarKind::Domain, counts);
call    0 never executed
    #####:  161:  truncateVarKind(VarKind::Range, counts);
call    0 never executed
    #####:  162:  truncateVarKind(VarKind::Symbol, counts);
call    0 never executed
    #####:  163:  truncateVarKind(VarKind::Local, counts);
call    0 never executed
    #####:  164:  removeInequalityRange(counts.getNumIneqs(), getNumInequalities());
branch  0 never executed
branch  1 never executed
    #####:  165:  removeEqualityRange(counts.getNumEqs(), getNumEqualities());
branch  0 never executed
branch  1 never executed
    #####:  166:}
        -:  167:
function _ZNK4mlir10presburger15IntegerRelation28computeReprWithOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####:  168:PresburgerRelation IntegerRelation::computeReprWithOnlyDivLocals() const {
        -:  169:  // If there are no locals, we're done.
    #####:  170:  if (getNumLocalVars() == 0)
branch  0 never executed
branch  1 never executed
    #####:  171:    return PresburgerRelation(*this);
call    0 never executed
        -:  172:
        -:  173:  // Move all the non-div locals to the end, as the current API to
        -:  174:  // SymbolicLexMin requires these to form a contiguous range.
        -:  175:  //
        -:  176:  // Take a copy so we can perform mutations.
    #####:  177:  IntegerRelation copy = *this;
call    0 never executed
    #####:  178:  std::vector<MaybeLocalRepr> reprs(getNumLocalVars());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  179:  copy.getLocalReprs(&reprs);
call    0 never executed
call    1 never executed
        -:  180:
        -:  181:  // Iterate through all the locals. The last `numNonDivLocals` are the locals
        -:  182:  // that have been scanned already and do not have division representations.
    #####:  183:  unsigned numNonDivLocals = 0;
    #####:  184:  unsigned offset = copy.getVarKindOffset(VarKind::Local);
call    0 never executed
    #####:  185:  for (unsigned i = 0, e = copy.getNumLocalVars(); i < e - numNonDivLocals;) {
branch  0 never executed
branch  1 never executed
    #####:  186:    if (!reprs[i]) {
branch  0 never executed
branch  1 never executed
        -:  187:      // Whenever we come across a local that does not have a division
        -:  188:      // representation, we swap it to the `numNonDivLocals`-th last position
        -:  189:      // and increment `numNonDivLocal`s. `reprs` also needs to be swapped.
    #####:  190:      copy.swapVar(offset + i, offset + e - numNonDivLocals - 1);
call    0 never executed
    #####:  191:      std::swap(reprs[i], reprs[e - numNonDivLocals - 1]);
    #####:  192:      ++numNonDivLocals;
    #####:  193:      continue;
        -:  194:    }
    #####:  195:    ++i;
        -:  196:  }
        -:  197:
        -:  198:  // If there are no non-div locals, we're done.
    #####:  199:  if (numNonDivLocals == 0)
branch  0 never executed
branch  1 never executed
    #####:  200:    return PresburgerRelation(*this);
call    0 never executed
        -:  201:
        -:  202:  // We computeSymbolicIntegerLexMin by considering the non-div locals as
        -:  203:  // "non-symbols" and considering everything else as "symbols". This will
        -:  204:  // compute a function mapping assignments to "symbols" to the
        -:  205:  // lexicographically minimal valid assignment of "non-symbols", when a
        -:  206:  // satisfying assignment exists. It separately returns the set of assignments
        -:  207:  // to the "symbols" such that a satisfying assignment to the "non-symbols"
        -:  208:  // exists but the lexmin is unbounded. We basically want to find the set of
        -:  209:  // values of the "symbols" such that an assignment to the "non-symbols"
        -:  210:  // exists, which is the union of the domain of the returned lexmin function
        -:  211:  // and the returned set of assignments to the "symbols" that makes the lexmin
        -:  212:  // unbounded.
    #####:  213:  SymbolicLexMin lexminResult =
call    0 never executed
    #####:  214:      SymbolicLexSimplex(copy, /*symbolOffset*/ 0,
call    0 never executed
call    1 never executed
    #####:  215:                         IntegerPolyhedron(PresburgerSpace::getSetSpace(
branch  0 never executed
branch  1 never executed
    #####:  216:                             /*numDims=*/copy.getNumVars() - numNonDivLocals)))
call    0 never executed
    #####:  217:          .computeSymbolicIntegerLexMin();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:  PresburgerRelation result =
    #####:  219:      lexminResult.lexmin.getDomain().unionSet(lexminResult.unboundedDomain);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  220:
        -:  221:  // The result set might lie in the wrong space -- all its ids are dims.
        -:  222:  // Set it to the desired space and return.
    #####:  223:  PresburgerSpace space = getSpace();
call    0 never executed
call    1 never executed
    #####:  224:  space.removeVarRange(VarKind::Local, 0, getNumLocalVars());
call    0 never executed
    #####:  225:  result.setSpace(space);
call    0 never executed
    #####:  226:  return result;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  227:}
        -:  228:
function _ZNK4mlir10presburger15IntegerRelation25findSymbolicIntegerLexMinEv called 0 returned 0% blocks executed 0%
    #####:  229:SymbolicLexMin IntegerRelation::findSymbolicIntegerLexMin() const {
        -:  230:  // Symbol and Domain vars will be used as symbols for symbolic lexmin.
        -:  231:  // In other words, for every value of the symbols and domain, return the
        -:  232:  // lexmin value of the (range, locals).
    #####:  233:  llvm::SmallBitVector isSymbol(getNumVars(), false);
call    0 never executed
    #####:  234:  isSymbol.set(getVarKindOffset(VarKind::Symbol),
call    0 never executed
    #####:  235:               getVarKindEnd(VarKind::Symbol));
call    0 never executed
call    1 never executed
    #####:  236:  isSymbol.set(getVarKindOffset(VarKind::Domain),
call    0 never executed
    #####:  237:               getVarKindEnd(VarKind::Domain));
call    0 never executed
call    1 never executed
        -:  238:  // Compute the symbolic lexmin of the dims and locals, with the symbols being
        -:  239:  // the actual symbols of this set.
        -:  240:  // The resultant space of lexmin is the space of the relation itself.
    #####:  241:  SymbolicLexMin result =
call    0 never executed
    #####:  242:      SymbolicLexSimplex(*this,
call    0 never executed
call    1 never executed
    #####:  243:                         IntegerPolyhedron(PresburgerSpace::getSetSpace(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  244:                             /*numDims=*/getNumDomainVars(),
        -:  245:                             /*numSymbols=*/getNumSymbolVars())),
        -:  246:                         isSymbol)
    #####:  247:          .computeSymbolicIntegerLexMin();
call    0 never executed
        -:  248:
        -:  249:  // We want to return only the lexmin over the dims, so strip the locals from
        -:  250:  // the computed lexmin.
    #####:  251:  result.lexmin.removeOutputs(result.lexmin.getNumOutputs() - getNumLocalVars(),
call    0 never executed
        -:  252:                              result.lexmin.getNumOutputs());
    #####:  253:  return result;
call    0 never executed
        -:  254:}
        -:  255:
        -:  256:PresburgerRelation
function _ZNK4mlir10presburger15IntegerRelation8subtractERKNS0_18PresburgerRelationE called 0 returned 0% blocks executed 0%
    #####:  257:IntegerRelation::subtract(const PresburgerRelation &set) const {
    #####:  258:  return PresburgerRelation(*this).subtract(set);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  259:}
        -:  260:
function _ZN4mlir10presburger15IntegerRelation9insertVarENS0_7VarKindEjj called 0 returned 0% blocks executed 0%
    #####:  261:unsigned IntegerRelation::insertVar(VarKind kind, unsigned pos, unsigned num) {
    #####:  262:  assert(pos <= getNumVarKind(kind));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  263:
    #####:  264:  unsigned insertPos = space.insertVar(kind, pos, num);
call    0 never executed
    #####:  265:  inequalities.insertColumns(insertPos, num);
call    0 never executed
    #####:  266:  equalities.insertColumns(insertPos, num);
call    0 never executed
    #####:  267:  return insertPos;
        -:  268:}
        -:  269:
function _ZN4mlir10presburger15IntegerRelation9appendVarENS0_7VarKindEj called 0 returned 0% blocks executed 0%
    #####:  270:unsigned IntegerRelation::appendVar(VarKind kind, unsigned num) {
    #####:  271:  unsigned pos = getNumVarKind(kind);
call    0 never executed
    #####:  272:  return insertVar(kind, pos, num);
call    0 never executed
        -:  273:}
        -:  274:
function _ZN4mlir10presburger15IntegerRelation11addEqualityEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  275:void IntegerRelation::addEquality(ArrayRef<MPInt> eq) {
    #####:  276:  assert(eq.size() == getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  277:  unsigned row = equalities.appendExtraRow();
call    0 never executed
    #####:  278:  for (unsigned i = 0, e = eq.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  279:    equalities(row, i) = eq[i];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  280:}
        -:  281:
function _ZN4mlir10presburger15IntegerRelation13addInequalityEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  282:void IntegerRelation::addInequality(ArrayRef<MPInt> inEq) {
    #####:  283:  assert(inEq.size() == getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  284:  unsigned row = inequalities.appendExtraRow();
call    0 never executed
    #####:  285:  for (unsigned i = 0, e = inEq.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  286:    inequalities(row, i) = inEq[i];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  287:}
        -:  288:
function _ZN4mlir10presburger15IntegerRelation9removeVarENS0_7VarKindEj called 0 returned 0% blocks executed 0%
    #####:  289:void IntegerRelation::removeVar(VarKind kind, unsigned pos) {
    #####:  290:  removeVarRange(kind, pos, pos + 1);
call    0 never executed
    #####:  291:}
        -:  292:
function _ZN4mlir10presburger15IntegerRelation9removeVarEj called 0 returned 0% blocks executed 0%
    #####:  293:void IntegerRelation::removeVar(unsigned pos) { removeVarRange(pos, pos + 1); }
call    0 never executed
        -:  294:
function _ZN4mlir10presburger15IntegerRelation14removeVarRangeENS0_7VarKindEjj called 0 returned 0% blocks executed 0%
    #####:  295:void IntegerRelation::removeVarRange(VarKind kind, unsigned varStart,
        -:  296:                                     unsigned varLimit) {
    #####:  297:  assert(varLimit <= getNumVarKind(kind));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  298:
    #####:  299:  if (varStart >= varLimit)
branch  0 never executed
branch  1 never executed
        -:  300:    return;
        -:  301:
        -:  302:  // Remove eliminated variables from the constraints.
    #####:  303:  unsigned offset = getVarKindOffset(kind);
call    0 never executed
    #####:  304:  equalities.removeColumns(offset + varStart, varLimit - varStart);
call    0 never executed
    #####:  305:  inequalities.removeColumns(offset + varStart, varLimit - varStart);
call    0 never executed
        -:  306:
        -:  307:  // Remove eliminated variables from the space.
    #####:  308:  space.removeVarRange(kind, varStart, varLimit);
call    0 never executed
        -:  309:}
        -:  310:
function _ZN4mlir10presburger15IntegerRelation14removeVarRangeEjj called 0 returned 0% blocks executed 0%
    #####:  311:void IntegerRelation::removeVarRange(unsigned varStart, unsigned varLimit) {
    #####:  312:  assert(varLimit <= getNumVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  313:
    #####:  314:  if (varStart >= varLimit)
branch  0 never executed
branch  1 never executed
    #####:  315:    return;
        -:  316:
        -:  317:  // Helper function to remove vars of the specified kind in the given range
        -:  318:  // [start, limit), The range is absolute (i.e. it is not relative to the kind
        -:  319:  // of variable). Also updates `limit` to reflect the deleted variables.
function _ZZN4mlir10presburger15IntegerRelation14removeVarRangeEjjENKUlNS0_7VarKindERjS3_E_clES2_S3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  320:  auto removeVarKindInRange = [this](VarKind kind, unsigned &start,
    #####:  321:                                     unsigned &limit) {
    #####:  322:    if (start >= limit)
branch  0 never executed
branch  1 never executed
    #####:  323:      return;
        -:  324:
    #####:  325:    unsigned offset = getVarKindOffset(kind);
call    0 never executed
    #####:  326:    unsigned num = getNumVarKind(kind);
call    0 never executed
        -:  327:
        -:  328:    // Get `start`, `limit` relative to the specified kind.
    #####:  329:    unsigned relativeStart =
    #####:  330:        start <= offset ? 0 : std::min(num, start - offset);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  331:    unsigned relativeLimit =
    #####:  332:        limit <= offset ? 0 : std::min(num, limit - offset);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  333:
        -:  334:    // Remove vars of the specified kind in the relative range.
    #####:  335:    removeVarRange(kind, relativeStart, relativeLimit);
call    0 never executed
        -:  336:
        -:  337:    // Update `limit` to reflect deleted variables.
        -:  338:    // `start` does not need to be updated because any variables that are
        -:  339:    // deleted are after position `start`.
    #####:  340:    limit -= relativeLimit - relativeStart;
    #####:  341:  };
        -:  342:
    #####:  343:  removeVarKindInRange(VarKind::Domain, varStart, varLimit);
call    0 never executed
    #####:  344:  removeVarKindInRange(VarKind::Range, varStart, varLimit);
call    0 never executed
    #####:  345:  removeVarKindInRange(VarKind::Symbol, varStart, varLimit);
call    0 never executed
    #####:  346:  removeVarKindInRange(VarKind::Local, varStart, varLimit);
call    0 never executed
        -:  347:}
        -:  348:
function _ZN4mlir10presburger15IntegerRelation14removeEqualityEj called 0 returned 0% blocks executed 0%
    #####:  349:void IntegerRelation::removeEquality(unsigned pos) {
    #####:  350:  equalities.removeRow(pos);
call    0 never executed
call    1 never executed
    #####:  351:}
        -:  352:
function _ZN4mlir10presburger15IntegerRelation16removeInequalityEj called 0 returned 0% blocks executed 0%
    #####:  353:void IntegerRelation::removeInequality(unsigned pos) {
    #####:  354:  inequalities.removeRow(pos);
call    0 never executed
call    1 never executed
    #####:  355:}
        -:  356:
function _ZN4mlir10presburger15IntegerRelation19removeEqualityRangeEjj called 0 returned 0% blocks executed 0%
    #####:  357:void IntegerRelation::removeEqualityRange(unsigned start, unsigned end) {
    #####:  358:  if (start >= end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  359:    return;
    #####:  360:  equalities.removeRows(start, end - start);
call    0 never executed
call    1 never executed
        -:  361:}
        -:  362:
function _ZN4mlir10presburger15IntegerRelation21removeInequalityRangeEjj called 0 returned 0% blocks executed 0%
    #####:  363:void IntegerRelation::removeInequalityRange(unsigned start, unsigned end) {
    #####:  364:  if (start >= end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  365:    return;
    #####:  366:  inequalities.removeRows(start, end - start);
call    0 never executed
call    1 never executed
        -:  367:}
        -:  368:
function _ZN4mlir10presburger15IntegerRelation7swapVarEjj called 0 returned 0% blocks executed 0%
    #####:  369:void IntegerRelation::swapVar(unsigned posA, unsigned posB) {
    #####:  370:  assert(posA < getNumVars() && "invalid position A");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  371:  assert(posB < getNumVars() && "invalid position B");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  372:
    #####:  373:  if (posA == posB)
branch  0 never executed
branch  1 never executed
        -:  374:    return;
        -:  375:
    #####:  376:  inequalities.swapColumns(posA, posB);
call    0 never executed
    #####:  377:  equalities.swapColumns(posA, posB);
call    0 never executed
        -:  378:}
        -:  379:
function _ZN4mlir10presburger15IntegerRelation16clearConstraintsEv called 0 returned 0% blocks executed 0%
    #####:  380:void IntegerRelation::clearConstraints() {
    #####:  381:  equalities.resizeVertically(0);
call    0 never executed
    #####:  382:  inequalities.resizeVertically(0);
call    0 never executed
call    1 never executed
    #####:  383:}
        -:  384:
        -:  385:/// Gather all lower and upper bounds of the variable at `pos`, and
        -:  386:/// optionally any equalities on it. In addition, the bounds are to be
        -:  387:/// independent of variables in position range [`offset`, `offset` + `num`).
function _ZNK4mlir10presburger15IntegerRelation28getLowerAndUpperBoundIndicesEjPN4llvm15SmallVectorImplIjEES5_S5_jj called 0 returned 0% blocks executed 0%
    #####:  388:void IntegerRelation::getLowerAndUpperBoundIndices(
        -:  389:    unsigned pos, SmallVectorImpl<unsigned> *lbIndices,
        -:  390:    SmallVectorImpl<unsigned> *ubIndices, SmallVectorImpl<unsigned> *eqIndices,
        -:  391:    unsigned offset, unsigned num) const {
    #####:  392:  assert(pos < getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  393:  assert(offset + num < getNumCols() && "invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  394:
        -:  395:  // Checks for a constraint that has a non-zero coeff for the variables in
        -:  396:  // the position range [offset, offset + num) while ignoring `pos`.
function _ZZNK4mlir10presburger15IntegerRelation28getLowerAndUpperBoundIndicesEjPN4llvm15SmallVectorImplIjEES5_S5_jjENKUljbE_clEjb called 0 returned 0% blocks executed 0%
    #####:  397:  auto containsConstraintDependentOnRange = [&](unsigned r, bool isEq) {
    #####:  398:    unsigned c, f;
    #####:  399:    auto cst = isEq ? getEquality(r) : getInequality(r);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  400:    for (c = offset, f = offset + num; c < f; ++c) {
branch  0 never executed
branch  1 never executed
    #####:  401:      if (c == pos)
branch  0 never executed
branch  1 never executed
    #####:  402:        continue;
    #####:  403:      if (cst[c] != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  404:        break;
        -:  405:    }
    #####:  406:    return c < f;
    #####:  407:  };
        -:  408:
        -:  409:  // Gather all lower bounds and upper bounds of the variable. Since the
        -:  410:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -:  411:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
    #####:  412:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -:  413:    // The bounds are to be independent of [offset, offset + num) columns.
    #####:  414:    if (containsConstraintDependentOnRange(r, /*isEq=*/false))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  415:      continue;
    #####:  416:    if (atIneq(r, pos) >= 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  417:      // Lower bound.
    #####:  418:      lbIndices->push_back(r);
call    0 never executed
    #####:  419:    } else if (atIneq(r, pos) <= -1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  420:      // Upper bound.
    #####:  421:      ubIndices->push_back(r);
call    0 never executed
        -:  422:    }
        -:  423:  }
        -:  424:
        -:  425:  // An equality is both a lower and upper bound. Record any equalities
        -:  426:  // involving the pos^th variable.
    #####:  427:  if (!eqIndices)
branch  0 never executed
branch  1 never executed
    #####:  428:    return;
        -:  429:
    #####:  430:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####:  431:    if (atEq(r, pos) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  432:      continue;
    #####:  433:    if (containsConstraintDependentOnRange(r, /*isEq=*/true))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  434:      continue;
    #####:  435:    eqIndices->push_back(r);
call    0 never executed
        -:  436:  }
        -:  437:}
        -:  438:
function _ZNK4mlir10presburger15IntegerRelation18hasConsistentStateEv called 0 returned 0% blocks executed 0%
    #####:  439:bool IntegerRelation::hasConsistentState() const {
    #####:  440:  if (!inequalities.hasConsistentState())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  441:    return false;
    #####:  442:  if (!equalities.hasConsistentState())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  443:    return false;
        -:  444:  return true;
        -:  445:}
        -:  446:
function _ZN4mlir10presburger15IntegerRelation15setAndEliminateEjN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  447:void IntegerRelation::setAndEliminate(unsigned pos, ArrayRef<MPInt> values) {
    #####:  448:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  449:    return;
    #####:  450:  assert(pos + values.size() <= getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  451:         "invalid position or too many values");
        -:  452:  // Setting x_j = p in sum_i a_i x_i + c is equivalent to adding p*a_j to the
        -:  453:  // constant term and removing the var x_j. We do this for all the vars
        -:  454:  // pos, pos + 1, ... pos + values.size() - 1.
    #####:  455:  unsigned constantColPos = getNumCols() - 1;
    #####:  456:  for (unsigned i = 0, numVals = values.size(); i < numVals; ++i)
branch  0 never executed
branch  1 never executed
    #####:  457:    inequalities.addToColumn(i + pos, constantColPos, values[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  458:  for (unsigned i = 0, numVals = values.size(); i < numVals; ++i)
branch  0 never executed
branch  1 never executed
    #####:  459:    equalities.addToColumn(i + pos, constantColPos, values[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  460:  removeVarRange(pos, pos + values.size());
call    0 never executed
        -:  461:}
        -:  462:
function _ZN4mlir10presburger15IntegerRelation16clearAndCopyFromERKS1_ called 0 returned 0% blocks executed 0%
    #####:  463:void IntegerRelation::clearAndCopyFrom(const IntegerRelation &other) {
    #####:  464:  *this = other;
call    0 never executed
    #####:  465:}
        -:  466:
        -:  467:// Searches for a constraint with a non-zero coefficient at `colIdx` in
        -:  468:// equality (isEq=true) or inequality (isEq=false) constraints.
        -:  469:// Returns true and sets row found in search in `rowIdx`, false otherwise.
function _ZNK4mlir10presburger15IntegerRelation27findConstraintWithNonZeroAtEjbPj called 0 returned 0% blocks executed 0%
    #####:  470:bool IntegerRelation::findConstraintWithNonZeroAt(unsigned colIdx, bool isEq,
        -:  471:                                                  unsigned *rowIdx) const {
    #####:  472:  assert(colIdx < getNumCols() && "position out of bounds");
branch  0 never executed
branch  1 never executed
call    2 never executed
function _ZZNK4mlir10presburger15IntegerRelation27findConstraintWithNonZeroAtEjbPjENKUljE_clEj called 0 returned 0% blocks executed 0%
    #####:  473:  auto at = [&](unsigned rowIdx) -> MPInt {
    #####:  474:    return isEq ? atEq(rowIdx, colIdx) : atIneq(rowIdx, colIdx);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  475:  };
    #####:  476:  unsigned e = isEq ? getNumEqualities() : getNumInequalities();
branch  0 never executed
branch  1 never executed
    #####:  477:  for (*rowIdx = 0; *rowIdx < e; ++(*rowIdx)) {
branch  0 never executed
branch  1 never executed
    #####:  478:    if (at(*rowIdx) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  479:      return true;
        -:  480:    }
        -:  481:  }
        -:  482:  return false;
        -:  483:}
        -:  484:
function _ZN4mlir10presburger15IntegerRelation25normalizeConstraintsByGCDEv called 0 returned 0% blocks executed 0%
    #####:  485:void IntegerRelation::normalizeConstraintsByGCD() {
    #####:  486:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  487:    equalities.normalizeRow(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  488:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  489:    inequalities.normalizeRow(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  490:}
        -:  491:
function _ZNK4mlir10presburger15IntegerRelation20hasInvalidConstraintEv called 0 returned 0% blocks executed 0%
    #####:  492:bool IntegerRelation::hasInvalidConstraint() const {
    #####:  493:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
function _ZZNK4mlir10presburger15IntegerRelation20hasInvalidConstraintEvENKUlbE_clEb called 0 returned 0% blocks executed 0%
    #####:  494:  auto check = [&](bool isEq) -> bool {
    #####:  495:    unsigned numCols = getNumCols();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  496:    unsigned numRows = isEq ? getNumEqualities() : getNumInequalities();
branch  0 never executed
branch  1 never executed
    #####:  497:    for (unsigned i = 0, e = numRows; i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -:  498:      unsigned j;
    #####:  499:      for (j = 0; j < numCols - 1; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  500:        MPInt v = isEq ? atEq(i, j) : atIneq(i, j);
branch  0 never executed
branch  1 never executed
        -:  501:        // Skip rows with non-zero variable coefficients.
    #####:  502:        if (v != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  503:          break;
        -:  504:      }
    #####:  505:      if (j < numCols - 1) {
branch  0 never executed
branch  1 never executed
    #####:  506:        continue;
        -:  507:      }
        -:  508:      // Check validity of constant term at 'numCols - 1' w.r.t 'isEq'.
        -:  509:      // Example invalid constraints include: '1 == 0' or '-1 >= 0'
    #####:  510:      MPInt v = isEq ? atEq(i, numCols - 1) : atIneq(i, numCols - 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  511:      if ((isEq && v != 0) || (!isEq && v < 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  512:        return true;
branch  0 never executed
branch  1 never executed
        -:  513:      }
        -:  514:    }
        -:  515:    return false;
    #####:  516:  };
    #####:  517:  if (check(/*isEq=*/true))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  518:    return true;
    #####:  519:  return check(/*isEq=*/false);
call    0 never executed
        -:  520:}
        -:  521:
        -:  522:/// Eliminate variable from constraint at `rowIdx` based on coefficient at
        -:  523:/// pivotRow, pivotCol. Columns in range [elimColStart, pivotCol) will not be
        -:  524:/// updated as they have already been eliminated.
function _ZL23eliminateFromConstraintPN4mlir10presburger15IntegerRelationEjjjjb called 0 returned 0% blocks executed 0%
    #####:  525:static void eliminateFromConstraint(IntegerRelation *constraints,
        -:  526:                                    unsigned rowIdx, unsigned pivotRow,
        -:  527:                                    unsigned pivotCol, unsigned elimColStart,
        -:  528:                                    bool isEq) {
        -:  529:  // Skip if equality 'rowIdx' if same as 'pivotRow'.
    #####:  530:  if (isEq && rowIdx == pivotRow)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  531:    return;
function _ZZL23eliminateFromConstraintPN4mlir10presburger15IntegerRelationEjjjjbENKUljjE_clEjj.isra.0 called 0 returned 0% blocks executed 0%
    #####:  532:  auto at = [&](unsigned i, unsigned j) -> MPInt {
    #####:  533:    return isEq ? constraints->atEq(i, j) : constraints->atIneq(i, j);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  534:  };
    #####:  535:  MPInt leadCoeff = at(rowIdx, pivotCol);
call    0 never executed
        -:  536:  // Skip if leading coefficient at 'rowIdx' is already zero.
    #####:  537:  if (leadCoeff == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  538:    return;
branch  0 never executed
branch  1 never executed
    #####:  539:  MPInt pivotCoeff = constraints->atEq(pivotRow, pivotCol);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  540:  int sign = (leadCoeff * pivotCoeff > 0) ? -1 : 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  541:  MPInt lcm = presburger::lcm(pivotCoeff, leadCoeff);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  542:  MPInt pivotMultiplier = sign * (lcm / abs(pivotCoeff));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  543:  MPInt rowMultiplier = lcm / abs(leadCoeff);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  544:
    #####:  545:  unsigned numCols = constraints->getNumCols();
    #####:  546:  for (unsigned j = 0; j < numCols; ++j) {
branch  0 never executed
branch  1 never executed
        -:  547:    // Skip updating column 'j' if it was just eliminated.
    #####:  548:    if (j >= elimColStart && j < pivotCol)
branch  0 never executed
branch  1 never executed
    #####:  549:      continue;
    #####:  550:    MPInt v = pivotMultiplier * constraints->atEq(pivotRow, j) +
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  551:              rowMultiplier * at(rowIdx, j);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  552:    isEq ? constraints->atEq(rowIdx, j) = v
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  553:         : constraints->atIneq(rowIdx, j) = v;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  554:  }
        -:  555:}
        -:  556:
        -:  557:/// Returns the position of the variable that has the minimum <number of lower
        -:  558:/// bounds> times <number of upper bounds> from the specified range of
        -:  559:/// variables [start, end). It is often best to eliminate in the increasing
        -:  560:/// order of these counts when doing Fourier-Motzkin elimination since FM adds
        -:  561:/// that many new constraints.
function _ZL21getBestVarToEliminateRKN4mlir10presburger15IntegerRelationEjj called 0 returned 0% blocks executed 0%
    #####:  562:static unsigned getBestVarToEliminate(const IntegerRelation &cst,
        -:  563:                                      unsigned start, unsigned end) {
    #####:  564:  assert(start < cst.getNumVars() && end < cst.getNumVars() + 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  565:
function _ZZL21getBestVarToEliminateRKN4mlir10presburger15IntegerRelationEjjENKUljE_clEj.isra.0 called 0 returned 0% blocks executed 0%
    #####:  566:  auto getProductOfNumLowerUpperBounds = [&](unsigned pos) {
    #####:  567:    unsigned numLb = 0;
    #####:  568:    unsigned numUb = 0;
    #####:  569:    for (unsigned r = 0, e = cst.getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####:  570:      if (cst.atIneq(r, pos) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  571:        ++numLb;
    #####:  572:      } else if (cst.atIneq(r, pos) < 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  573:        ++numUb;
        -:  574:      }
        -:  575:    }
    #####:  576:    return numLb * numUb;
    #####:  577:  };
        -:  578:
    #####:  579:  unsigned minLoc = start;
    #####:  580:  unsigned min = getProductOfNumLowerUpperBounds(start);
call    0 never executed
    #####:  581:  for (unsigned c = start + 1; c < end; c++) {
branch  0 never executed
branch  1 never executed
    #####:  582:    unsigned numLbUbProduct = getProductOfNumLowerUpperBounds(c);
call    0 never executed
    #####:  583:    if (numLbUbProduct < min) {
branch  0 never executed
branch  1 never executed
    #####:  584:      min = numLbUbProduct;
    #####:  585:      minLoc = c;
        -:  586:    }
        -:  587:  }
    #####:  588:  return minLoc;
        -:  589:}
        -:  590:
        -:  591:// Checks for emptiness of the set by eliminating variables successively and
        -:  592:// using the GCD test (on all equality constraints) and checking for trivially
        -:  593:// invalid constraints. Returns 'true' if the constraint system is found to be
        -:  594:// empty; false otherwise.
function _ZNK4mlir10presburger15IntegerRelation7isEmptyEv called 0 returned 0% blocks executed 0%
    #####:  595:bool IntegerRelation::isEmpty() const {
    #####:  596:  if (isEmptyByGCDTest() || hasInvalidConstraint())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  597:    return true;
        -:  598:
    #####:  599:  IntegerRelation tmpCst(*this);
call    0 never executed
call    1 never executed
        -:  600:
        -:  601:  // First, eliminate as many local variables as possible using equalities.
    #####:  602:  tmpCst.removeRedundantLocalVars();
call    0 never executed
    #####:  603:  if (tmpCst.isEmptyByGCDTest() || tmpCst.hasInvalidConstraint())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  604:    return true;
        -:  605:
        -:  606:  // Eliminate as many variables as possible using Gaussian elimination.
        -:  607:  unsigned currentPos = 0;
    #####:  608:  while (currentPos < tmpCst.getNumVars()) {
branch  0 never executed
branch  1 never executed
    #####:  609:    tmpCst.gaussianEliminateVars(currentPos, tmpCst.getNumVars());
call    0 never executed
    #####:  610:    ++currentPos;
        -:  611:    // We check emptiness through trivial checks after eliminating each ID to
        -:  612:    // detect emptiness early. Since the checks isEmptyByGCDTest() and
        -:  613:    // hasInvalidConstraint() are linear time and single sweep on the constraint
        -:  614:    // buffer, this appears reasonable - but can optimize in the future.
    #####:  615:    if (tmpCst.hasInvalidConstraint() || tmpCst.isEmptyByGCDTest())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  616:      return true;
        -:  617:  }
        -:  618:
        -:  619:  // Eliminate the remaining using FM.
    #####:  620:  for (unsigned i = 0, e = tmpCst.getNumVars(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####:  621:    tmpCst.fourierMotzkinEliminate(
call    0 never executed
call    1 never executed
        -:  622:        getBestVarToEliminate(tmpCst, 0, tmpCst.getNumVars()));
        -:  623:    // Check for a constraint explosion. This rarely happens in practice, but
        -:  624:    // this check exists as a safeguard against improperly constructed
        -:  625:    // constraint systems or artificially created arbitrarily complex systems
        -:  626:    // that aren't the intended use case for IntegerRelation. This is
        -:  627:    // needed since FM has a worst case exponential complexity in theory.
    #####:  628:    if (tmpCst.getNumConstraints() >= kExplosionFactor * getNumVars()) {
branch  0 never executed
branch  1 never executed
    #####:  629:      LLVM_DEBUG(llvm::dbgs() << "FM constraint explosion detected\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  630:      return false;
        -:  631:    }
        -:  632:
        -:  633:    // FM wouldn't have modified the equalities in any way. So no need to again
        -:  634:    // run GCD test. Check for trivial invalid constraints.
    #####:  635:    if (tmpCst.hasInvalidConstraint())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  636:      return true;
        -:  637:  }
        -:  638:  return false;
        -:  639:}
        -:  640:
        -:  641:// Runs the GCD test on all equality constraints. Returns 'true' if this test
        -:  642:// fails on any equality. Returns 'false' otherwise.
        -:  643:// This test can be used to disprove the existence of a solution. If it returns
        -:  644:// true, no integer solution to the equality constraints can exist.
        -:  645://
        -:  646:// GCD test definition:
        -:  647://
        -:  648:// The equality constraint:
        -:  649://
        -:  650://  c_1*x_1 + c_2*x_2 + ... + c_n*x_n = c_0
        -:  651://
        -:  652:// has an integer solution iff:
        -:  653://
        -:  654://  GCD of c_1, c_2, ..., c_n divides c_0.
function _ZNK4mlir10presburger15IntegerRelation16isEmptyByGCDTestEv called 0 returned 0% blocks executed 0%
    #####:  655:bool IntegerRelation::isEmptyByGCDTest() const {
    #####:  656:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  657:  unsigned numCols = getNumCols();
    #####:  658:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  659:    MPInt gcd = abs(atEq(i, 0));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  660:    for (unsigned j = 1; j < numCols - 1; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  661:      gcd = presburger::gcd(gcd, abs(atEq(i, j)));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
        -:  662:    }
    #####:  663:    MPInt v = abs(atEq(i, numCols - 1));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  664:    if (gcd > 0 && (v % gcd != 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  665:      return true;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  666:    }
        -:  667:  }
        -:  668:  return false;
        -:  669:}
        -:  670:
        -:  671:// Returns a matrix where each row is a vector along which the polytope is
        -:  672:// bounded. The span of the returned vectors is guaranteed to contain all
        -:  673:// such vectors. The returned vectors are NOT guaranteed to be linearly
        -:  674:// independent. This function should not be called on empty sets.
        -:  675://
        -:  676:// It is sufficient to check the perpendiculars of the constraints, as the set
        -:  677:// of perpendiculars which are bounded must span all bounded directions.
function _ZNK4mlir10presburger15IntegerRelation20getBoundedDirectionsEv called 0 returned 0% blocks executed 0%
    #####:  678:Matrix IntegerRelation::getBoundedDirections() const {
        -:  679:  // Note that it is necessary to add the equalities too (which the constructor
        -:  680:  // does) even though we don't need to check if they are bounded; whether an
        -:  681:  // inequality is bounded or not depends on what other constraints, including
        -:  682:  // equalities, are present.
    #####:  683:  Simplex simplex(*this);
call    0 never executed
        -:  684:
    #####:  685:  assert(!simplex.isEmpty() && "It is not meaningful to ask whether a "
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  686:                               "direction is bounded in an empty set.");
        -:  687:
    #####:  688:  SmallVector<unsigned, 8> boundedIneqs;
call    0 never executed
        -:  689:  // The constructor adds the inequalities to the simplex first, so this
        -:  690:  // processes all the inequalities.
    #####:  691:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  692:    if (simplex.isBoundedAlongConstraint(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  693:      boundedIneqs.push_back(i);
call    0 never executed
        -:  694:  }
        -:  695:
        -:  696:  // The direction vector is given by the coefficients and does not include the
        -:  697:  // constant term, so the matrix has one fewer column.
    #####:  698:  unsigned dirsNumCols = getNumCols() - 1;
call    0 never executed
    #####:  699:  Matrix dirs(boundedIneqs.size() + getNumEqualities(), dirsNumCols);
call    0 never executed
        -:  700:
        -:  701:  // Copy the bounded inequalities.
    #####:  702:  unsigned row = 0;
    #####:  703:  for (unsigned i : boundedIneqs) {
branch  0 never executed
branch  1 never executed
    #####:  704:    for (unsigned col = 0; col < dirsNumCols; ++col)
branch  0 never executed
branch  1 never executed
    #####:  705:      dirs(row, col) = atIneq(i, col);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  706:    ++row;
        -:  707:  }
        -:  708:
        -:  709:  // Copy the equalities. All the equalities' perpendiculars are bounded.
    #####:  710:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  711:    for (unsigned col = 0; col < dirsNumCols; ++col)
branch  0 never executed
branch  1 never executed
    #####:  712:      dirs(row, col) = atEq(i, col);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  713:    ++row;
        -:  714:  }
        -:  715:
    #####:  716:  return dirs;
branch  0 never executed
branch  1 never executed
        -:  717:}
        -:  718:
function _ZNK4mlir10presburger15IntegerRelation14isIntegerEmptyEv called 0 returned 0% blocks executed 0%
    #####:  719:bool IntegerRelation::isIntegerEmpty() const { return !findIntegerSample(); }
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  720:
        -:  721:/// Let this set be S. If S is bounded then we directly call into the GBR
        -:  722:/// sampling algorithm. Otherwise, there are some unbounded directions, i.e.,
        -:  723:/// vectors v such that S extends to infinity along v or -v. In this case we
        -:  724:/// use an algorithm described in the integer set library (isl) manual and used
        -:  725:/// by the isl_set_sample function in that library. The algorithm is:
        -:  726:///
        -:  727:/// 1) Apply a unimodular transform T to S to obtain S*T, such that all
        -:  728:/// dimensions in which S*T is bounded lie in the linear span of a prefix of the
        -:  729:/// dimensions.
        -:  730:///
        -:  731:/// 2) Construct a set B by removing all constraints that involve
        -:  732:/// the unbounded dimensions and then deleting the unbounded dimensions. Note
        -:  733:/// that B is a Bounded set.
        -:  734:///
        -:  735:/// 3) Try to obtain a sample from B using the GBR sampling
        -:  736:/// algorithm. If no sample is found, return that S is empty.
        -:  737:///
        -:  738:/// 4) Otherwise, substitute the obtained sample into S*T to obtain a set
        -:  739:/// C. C is a full-dimensional Cone and always contains a sample.
        -:  740:///
        -:  741:/// 5) Obtain an integer sample from C.
        -:  742:///
        -:  743:/// 6) Return T*v, where v is the concatenation of the samples from B and C.
        -:  744:///
        -:  745:/// The following is a sketch of a proof that
        -:  746:/// a) If the algorithm returns empty, then S is empty.
        -:  747:/// b) If the algorithm returns a sample, it is a valid sample in S.
        -:  748:///
        -:  749:/// The algorithm returns empty only if B is empty, in which case S*T is
        -:  750:/// certainly empty since B was obtained by removing constraints and then
        -:  751:/// deleting unconstrained dimensions from S*T. Since T is unimodular, a vector
        -:  752:/// v is in S*T iff T*v is in S. So in this case, since
        -:  753:/// S*T is empty, S is empty too.
        -:  754:///
        -:  755:/// Otherwise, the algorithm substitutes the sample from B into S*T. All the
        -:  756:/// constraints of S*T that did not involve unbounded dimensions are satisfied
        -:  757:/// by this substitution. All dimensions in the linear span of the dimensions
        -:  758:/// outside the prefix are unbounded in S*T (step 1). Substituting values for
        -:  759:/// the bounded dimensions cannot make these dimensions bounded, and these are
        -:  760:/// the only remaining dimensions in C, so C is unbounded along every vector (in
        -:  761:/// the positive or negative direction, or both). C is hence a full-dimensional
        -:  762:/// cone and therefore always contains an integer point.
        -:  763:///
        -:  764:/// Concatenating the samples from B and C gives a sample v in S*T, so the
        -:  765:/// returned sample T*v is a sample in S.
function _ZNK4mlir10presburger15IntegerRelation17findIntegerSampleEv called 0 returned 0% blocks executed 0%
    #####:  766:Optional<SmallVector<MPInt, 8>> IntegerRelation::findIntegerSample() const {
        -:  767:  // First, try the GCD test heuristic.
    #####:  768:  if (isEmptyByGCDTest())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    return {};
        -:  770:
    #####:  771:  Simplex simplex(*this);
call    0 never executed
    #####:  772:  if (simplex.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  773:    return {};
        -:  774:
        -:  775:  // For a bounded set, we directly call into the GBR sampling algorithm.
    #####:  776:  if (!simplex.isUnbounded())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  777:    return simplex.findIntegerSample();
call    0 never executed
        -:  778:
        -:  779:  // The set is unbounded. We cannot directly use the GBR algorithm.
        -:  780:  //
        -:  781:  // m is a matrix containing, in each row, a vector in which S is
        -:  782:  // bounded, such that the linear span of all these dimensions contains all
        -:  783:  // bounded dimensions in S.
    #####:  784:  Matrix m = getBoundedDirections();
call    0 never executed
call    1 never executed
        -:  785:  // In column echelon form, each row of m occupies only the first rank(m)
        -:  786:  // columns and has zeros on the other columns. The transform T that brings S
        -:  787:  // to column echelon form is unimodular as well, so this is a suitable
        -:  788:  // transform to use in step 1 of the algorithm.
    #####:  789:  std::pair<unsigned, LinearTransform> result =
    #####:  790:      LinearTransform::makeTransformToColumnEchelon(m);
call    0 never executed
call    1 never executed
    #####:  791:  const LinearTransform &transform = result.second;
        -:  792:  // 1) Apply T to S to obtain S*T.
    #####:  793:  IntegerRelation transformedSet = transform.applyTo(*this);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  794:
        -:  795:  // 2) Remove the unbounded dimensions and constraints involving them to
        -:  796:  // obtain a bounded set.
    #####:  797:  IntegerRelation boundedSet(transformedSet);
call    0 never executed
    #####:  798:  unsigned numBoundedDims = result.first;
    #####:  799:  unsigned numUnboundedDims = getNumVars() - numBoundedDims;
call    0 never executed
    #####:  800:  removeConstraintsInvolvingVarRange(boundedSet, numBoundedDims,
call    0 never executed
        -:  801:                                     numUnboundedDims);
    #####:  802:  boundedSet.removeVarRange(numBoundedDims, boundedSet.getNumVars());
call    0 never executed
        -:  803:
        -:  804:  // 3) Try to obtain a sample from the bounded set.
    #####:  805:  Optional<SmallVector<MPInt, 8>> boundedSample =
    #####:  806:      Simplex(boundedSet).findIntegerSample();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  807:  if (!boundedSample)
branch  0 never executed
branch  1 never executed
    #####:  808:    return {};
    #####:  809:  assert(boundedSet.containsPoint(*boundedSample) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  810:         "Simplex returned an invalid sample!");
        -:  811:
        -:  812:  // 4) Substitute the values of the bounded dimensions into S*T to obtain a
        -:  813:  // full-dimensional cone, which necessarily contains an integer sample.
    #####:  814:  transformedSet.setAndEliminate(0, *boundedSample);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  815:  IntegerRelation &cone = transformedSet;
        -:  816:
        -:  817:  // 5) Obtain an integer sample from the cone.
        -:  818:  //
        -:  819:  // We shrink the cone such that for any rational point in the shrunken cone,
        -:  820:  // rounding up each of the point's coordinates produces a point that still
        -:  821:  // lies in the original cone.
        -:  822:  //
        -:  823:  // Rounding up a point x adds a number e_i in [0, 1) to each coordinate x_i.
        -:  824:  // For each inequality sum_i a_i x_i + c >= 0 in the original cone, the
        -:  825:  // shrunken cone will have the inequality tightened by some amount s, such
        -:  826:  // that if x satisfies the shrunken cone's tightened inequality, then x + e
        -:  827:  // satisfies the original inequality, i.e.,
        -:  828:  //
        -:  829:  // sum_i a_i x_i + c + s >= 0 implies sum_i a_i (x_i + e_i) + c >= 0
        -:  830:  //
        -:  831:  // for any e_i values in [0, 1). In fact, we will handle the slightly more
        -:  832:  // general case where e_i can be in [0, 1]. For example, consider the
        -:  833:  // inequality 2x_1 - 3x_2 - 7x_3 - 6 >= 0, and let x = (3, 0, 0). How low
        -:  834:  // could the LHS go if we added a number in [0, 1] to each coordinate? The LHS
        -:  835:  // is minimized when we add 1 to the x_i with negative coefficient a_i and
        -:  836:  // keep the other x_i the same. In the example, we would get x = (3, 1, 1),
        -:  837:  // changing the value of the LHS by -3 + -7 = -10.
        -:  838:  //
        -:  839:  // In general, the value of the LHS can change by at most the sum of the
        -:  840:  // negative a_i, so we accomodate this by shifting the inequality by this
        -:  841:  // amount for the shrunken cone.
    #####:  842:  for (unsigned i = 0, e = cone.getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  843:    for (unsigned j = 0; j < cone.getNumVars(); ++j) {
branch  0 never executed
branch  1 never executed
    #####:  844:      MPInt coeff = cone.atIneq(i, j);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  845:      if (coeff < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  846:        cone.atIneq(i, cone.getNumVars()) += coeff;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  847:    }
        -:  848:  }
        -:  849:
        -:  850:  // Obtain an integer sample in the cone by rounding up a rational point from
        -:  851:  // the shrunken cone. Shrinking the cone amounts to shifting its apex
        -:  852:  // "inwards" without changing its "shape"; the shrunken cone is still a
        -:  853:  // full-dimensional cone and is hence non-empty.
    #####:  854:  Simplex shrunkenConeSimplex(cone);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  855:  assert(!shrunkenConeSimplex.isEmpty() && "Shrunken cone cannot be empty!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  856:
        -:  857:  // The sample will always exist since the shrunken cone is non-empty.
    #####:  858:  SmallVector<Fraction, 8> shrunkenConeSample =
    #####:  859:      *shrunkenConeSimplex.getRationalSample();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
        -:  860:
    #####:  861:  SmallVector<MPInt, 8> coneSample(llvm::map_range(shrunkenConeSample, ceil));
call    0 never executed
        -:  862:
        -:  863:  // 6) Return transform * concat(boundedSample, coneSample).
    #####:  864:  SmallVector<MPInt, 8> &sample = *boundedSample;
branch  0 never executed
branch  1 never executed
    #####:  865:  sample.append(coneSample.begin(), coneSample.end());
call    0 never executed
    #####:  866:  return transform.postMultiplyWithColumn(sample);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  867:}
        -:  868:
        -:  869:/// Helper to evaluate an affine expression at a point.
        -:  870:/// The expression is a list of coefficients for the dimensions followed by the
        -:  871:/// constant term.
function _ZL7valueAtN4llvm8ArrayRefIN4mlir10presburger5MPIntEEES4_ called 0 returned 0% blocks executed 0%
    #####:  872:static MPInt valueAt(ArrayRef<MPInt> expr, ArrayRef<MPInt> point) {
    #####:  873:  assert(expr.size() == 1 + point.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  874:         "Dimensionalities of point and expression don't match!");
    #####:  875:  MPInt value = expr.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  876:  for (unsigned i = 0; i < point.size(); ++i)
branch  0 never executed
branch  1 never executed
    #####:  877:    value += expr[i] * point[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  878:  return value;
        -:  879:}
        -:  880:
        -:  881:/// A point satisfies an equality iff the value of the equality at the
        -:  882:/// expression is zero, and it satisfies an inequality iff the value of the
        -:  883:/// inequality at that point is non-negative.
function _ZNK4mlir10presburger15IntegerRelation13containsPointEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  884:bool IntegerRelation::containsPoint(ArrayRef<MPInt> point) const {
    #####:  885:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  886:    if (valueAt(getEquality(i), point) != 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  887:      return false;
        -:  888:  }
    #####:  889:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  890:    if (valueAt(getInequality(i), point) < 0)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  891:      return false;
        -:  892:  }
        -:  893:  return true;
        -:  894:}
        -:  895:
        -:  896:/// Just substitute the values given and check if an integer sample exists for
        -:  897:/// the local vars.
        -:  898:///
        -:  899:/// TODO: this could be made more efficient by handling divisions separately.
        -:  900:/// Instead of finding an integer sample over all the locals, we can first
        -:  901:/// compute the values of the locals that have division representations and
        -:  902:/// only use the integer emptiness check for the locals that don't have this.
        -:  903:/// Handling this correctly requires ordering the divs, though.
        -:  904:Optional<SmallVector<MPInt, 8>>
function _ZNK4mlir10presburger15IntegerRelation20containsPointNoLocalEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  905:IntegerRelation::containsPointNoLocal(ArrayRef<MPInt> point) const {
    #####:  906:  assert(point.size() == getNumVars() - getNumLocalVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  907:         "Point should contain all vars except locals!");
    #####:  908:  assert(getVarKindOffset(VarKind::Local) == getNumVars() - getNumLocalVars() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  909:         "This function depends on locals being stored last!");
    #####:  910:  IntegerRelation copy = *this;
call    0 never executed
call    1 never executed
    #####:  911:  copy.setAndEliminate(0, point);
call    0 never executed
    #####:  912:  return copy.findIntegerSample();
call    0 never executed
        -:  913:}
        -:  914:
        -:  915:DivisionRepr
function _ZNK4mlir10presburger15IntegerRelation13getLocalReprsEPSt6vectorINS0_14MaybeLocalReprESaIS3_EE called 0 returned 0% blocks executed 0%
    #####:  916:IntegerRelation::getLocalReprs(std::vector<MaybeLocalRepr> *repr) const {
    #####:  917:  SmallVector<bool, 8> foundRepr(getNumVars(), false);
call    0 never executed
    #####:  918:  for (unsigned i = 0, e = getNumDimAndSymbolVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  919:    foundRepr[i] = true;
branch  0 never executed
branch  1 never executed
        -:  920:
    #####:  921:  unsigned localOffset = getVarKindOffset(VarKind::Local);
call    0 never executed
    #####:  922:  DivisionRepr divs(getNumVars(), getNumLocalVars());
call    0 never executed
    #####:  923:  bool changed;
    #####:  924:  do {
branch  0 never executed
branch  1 never executed
        -:  925:    // Each time changed is true, at end of this iteration, one or more local
        -:  926:    // vars have been detected as floor divs.
    #####:  927:    changed = false;
    #####:  928:    for (unsigned i = 0, e = getNumLocalVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  929:      if (!foundRepr[i + localOffset]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  930:        MaybeLocalRepr res =
branch  0 never executed
branch  1 never executed
        -:  931:            computeSingleVarRepr(*this, foundRepr, localOffset + i,
    #####:  932:                                 divs.getDividend(i), divs.getDenom(i));
call    0 never executed
call    1 never executed
    #####:  933:        if (!res) {
branch  0 never executed
branch  1 never executed
        -:  934:          // No representation was found, so clear the representation and
        -:  935:          // continue.
    #####:  936:          divs.clearRepr(i);
call    0 never executed
    #####:  937:          continue;
        -:  938:        }
    #####:  939:        foundRepr[localOffset + i] = true;
branch  0 never executed
branch  1 never executed
    #####:  940:        if (repr)
branch  0 never executed
branch  1 never executed
    #####:  941:          (*repr)[i] = res;
    #####:  942:        changed = true;
        -:  943:      }
        -:  944:    }
        -:  945:  } while (changed);
        -:  946:
    #####:  947:  return divs;
branch  0 never executed
branch  1 never executed
        -:  948:}
        -:  949:
        -:  950:/// Tightens inequalities given that we are dealing with integer spaces. This is
        -:  951:/// analogous to the GCD test but applied to inequalities. The constant term can
        -:  952:/// be reduced to the preceding multiple of the GCD of the coefficients, i.e.,
        -:  953:///  64*i - 100 >= 0  =>  64*i - 128 >= 0 (since 'i' is an integer). This is a
        -:  954:/// fast method - linear in the number of coefficients.
        -:  955:// Example on how this affects practical cases: consider the scenario:
        -:  956:// 64*i >= 100, j = 64*i; without a tightening, elimination of i would yield
        -:  957:// j >= 100 instead of the tighter (exact) j >= 128.
function _ZN4mlir10presburger15IntegerRelation22gcdTightenInequalitiesEv called 0 returned 0% blocks executed 0%
    #####:  958:void IntegerRelation::gcdTightenInequalities() {
    #####:  959:  unsigned numCols = getNumCols();
    #####:  960:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -:  961:    // Normalize the constraint and tighten the constant term by the GCD.
    #####:  962:    MPInt gcd = inequalities.normalizeRow(i, getNumCols() - 1);
call    0 never executed
    #####:  963:    if (gcd > 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  964:      atIneq(i, numCols - 1) = floorDiv(atIneq(i, numCols - 1), gcd);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  965:  }
    #####:  966:}
        -:  967:
        -:  968:// Eliminates all variable variables in column range [posStart, posLimit).
        -:  969:// Returns the number of variables eliminated.
function _ZN4mlir10presburger15IntegerRelation21gaussianEliminateVarsEjj called 0 returned 0% blocks executed 0%
    #####:  970:unsigned IntegerRelation::gaussianEliminateVars(unsigned posStart,
        -:  971:                                                unsigned posLimit) {
        -:  972:  // Return if variable positions to eliminate are out of range.
    #####:  973:  assert(posLimit <= getNumVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  974:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  975:
    #####:  976:  if (posStart >= posLimit)
branch  0 never executed
branch  1 never executed
        -:  977:    return 0;
        -:  978:
    #####:  979:  gcdTightenInequalities();
        -:  980:
    #####:  981:  unsigned pivotCol = 0;
    #####:  982:  for (pivotCol = posStart; pivotCol < posLimit; ++pivotCol) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  983:    // Find a row which has a non-zero coefficient in column 'j'.
    #####:  984:    unsigned pivotRow;
    #####:  985:    if (!findConstraintWithNonZeroAt(pivotCol, /*isEq=*/true, &pivotRow)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  986:      // No pivot row in equalities with non-zero at 'pivotCol'.
    #####:  987:      if (!findConstraintWithNonZeroAt(pivotCol, /*isEq=*/false, &pivotRow)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  988:        // If inequalities are also non-zero in 'pivotCol', it can be
        -:  989:        // eliminated.
    #####:  990:        continue;
        -:  991:      }
    #####:  992:      break;
        -:  993:    }
        -:  994:
        -:  995:    // Eliminate variable at 'pivotCol' from each equality row.
    #####:  996:    for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  997:      eliminateFromConstraint(this, i, pivotRow, pivotCol, posStart,
call    0 never executed
        -:  998:                              /*isEq=*/true);
    #####:  999:      equalities.normalizeRow(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1000:    }
        -: 1001:
        -: 1002:    // Eliminate variable at 'pivotCol' from each inequality row.
    #####: 1003:    for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1004:      eliminateFromConstraint(this, i, pivotRow, pivotCol, posStart,
call    0 never executed
        -: 1005:                              /*isEq=*/false);
    #####: 1006:      inequalities.normalizeRow(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1007:    }
    #####: 1008:    removeEquality(pivotRow);
call    0 never executed
    #####: 1009:    gcdTightenInequalities();
call    0 never executed
        -: 1010:  }
        -: 1011:  // Update position limit based on number eliminated.
    #####: 1012:  posLimit = pivotCol;
        -: 1013:  // Remove eliminated columns from all constraints.
    #####: 1014:  removeVarRange(posStart, posLimit);
call    0 never executed
    #####: 1015:  return posLimit - posStart;
        -: 1016:}
        -: 1017:
        -: 1018:// A more complex check to eliminate redundant inequalities. Uses FourierMotzkin
        -: 1019:// to check if a constraint is redundant.
function _ZN4mlir10presburger15IntegerRelation27removeRedundantInequalitiesEv called 0 returned 0% blocks executed 0%
    #####: 1020:void IntegerRelation::removeRedundantInequalities() {
    #####: 1021:  SmallVector<bool, 32> redun(getNumInequalities(), false);
call    0 never executed
        -: 1022:  // To check if an inequality is redundant, we replace the inequality by its
        -: 1023:  // complement (for eg., i - 1 >= 0 by i <= 0), and check if the resulting
        -: 1024:  // system is empty. If it is, the inequality is redundant.
    #####: 1025:  IntegerRelation tmpCst(*this);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1026:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1027:    // Change the inequality to its complement.
    #####: 1028:    tmpCst.inequalities.negateRow(r);
call    0 never executed
    #####: 1029:    --tmpCst.atIneq(r, tmpCst.getNumCols() - 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1030:    if (tmpCst.isEmpty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1031:      redun[r] = true;
branch  0 never executed
branch  1 never executed
        -: 1032:      // Zero fill the redundant inequality.
    #####: 1033:      inequalities.fillRow(r, /*value=*/0);
call    0 never executed
    #####: 1034:      tmpCst.inequalities.fillRow(r, /*value=*/0);
call    0 never executed
        -: 1035:    } else {
        -: 1036:      // Reverse the change (to avoid recreating tmpCst each time).
    #####: 1037:      ++tmpCst.atIneq(r, tmpCst.getNumCols() - 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1038:      tmpCst.inequalities.negateRow(r);
call    0 never executed
        -: 1039:    }
        -: 1040:  }
        -: 1041:
    #####: 1042:  unsigned pos = 0;
    #####: 1043:  for (unsigned r = 0, e = getNumInequalities(); r < e; ++r) {
branch  0 never executed
branch  1 never executed
    #####: 1044:    if (!redun[r])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1045:      inequalities.copyRow(r, pos++);
call    0 never executed
        -: 1046:  }
    #####: 1047:  inequalities.resizeVertically(pos);
call    0 never executed
    #####: 1048:}
        -: 1049:
        -: 1050:// A more complex check to eliminate redundant inequalities and equalities. Uses
        -: 1051:// Simplex to check if a constraint is redundant.
function _ZN4mlir10presburger15IntegerRelation26removeRedundantConstraintsEv called 0 returned 0% blocks executed 0%
    #####: 1052:void IntegerRelation::removeRedundantConstraints() {
        -: 1053:  // First, we run gcdTightenInequalities. This allows us to catch some
        -: 1054:  // constraints which are not redundant when considering rational solutions
        -: 1055:  // but are redundant in terms of integer solutions.
    #####: 1056:  gcdTightenInequalities();
call    0 never executed
    #####: 1057:  Simplex simplex(*this);
call    0 never executed
    #####: 1058:  simplex.detectRedundant();
call    0 never executed
        -: 1059:
    #####: 1060:  unsigned pos = 0;
    #####: 1061:  unsigned numIneqs = getNumInequalities();
        -: 1062:  // Scan to get rid of all inequalities marked redundant, in-place. In Simplex,
        -: 1063:  // the first constraints added are the inequalities.
    #####: 1064:  for (unsigned r = 0; r < numIneqs; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1065:    if (!simplex.isMarkedRedundant(r))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1066:      inequalities.copyRow(r, pos++);
call    0 never executed
        -: 1067:  }
    #####: 1068:  inequalities.resizeVertically(pos);
call    0 never executed
        -: 1069:
        -: 1070:  // Scan to get rid of all equalities marked redundant, in-place. In Simplex,
        -: 1071:  // after the inequalities, a pair of constraints for each equality is added.
        -: 1072:  // An equality is redundant if both the inequalities in its pair are
        -: 1073:  // redundant.
    #####: 1074:  pos = 0;
    #####: 1075:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1076:    if (!(simplex.isMarkedRedundant(numIneqs + 2 * r) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1077:          simplex.isMarkedRedundant(numIneqs + 2 * r + 1)))
call    0 never executed
    #####: 1078:      equalities.copyRow(r, pos++);
call    0 never executed
        -: 1079:  }
    #####: 1080:  equalities.resizeVertically(pos);
call    0 never executed
call    1 never executed
    #####: 1081:}
        -: 1082:
function _ZNK4mlir10presburger15IntegerRelation13computeVolumeEv called 0 returned 0% blocks executed 0%
    #####: 1083:Optional<MPInt> IntegerRelation::computeVolume() const {
    #####: 1084:  assert(getNumSymbolVars() == 0 && "Symbols are not yet supported!");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1085:
    #####: 1086:  Simplex simplex(*this);
call    0 never executed
        -: 1087:  // If the polytope is rationally empty, there are certainly no integer
        -: 1088:  // points.
    #####: 1089:  if (simplex.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1090:    return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1091:
        -: 1092:  // Just find the maximum and minimum integer value of each non-local var
        -: 1093:  // separately, thus finding the number of integer values each such var can
        -: 1094:  // take. Multiplying these together gives a valid overapproximation of the
        -: 1095:  // number of integer points in the relation. The result this gives is
        -: 1096:  // equivalent to projecting (rationally) the relation onto its non-local vars
        -: 1097:  // and returning the number of integer points in a minimal axis-parallel
        -: 1098:  // hyperrectangular overapproximation of that.
        -: 1099:  //
        -: 1100:  // We also handle the special case where one dimension is unbounded and
        -: 1101:  // another dimension can take no integer values. In this case, the volume is
        -: 1102:  // zero.
        -: 1103:  //
        -: 1104:  // If there is no such empty dimension, if any dimension is unbounded we
        -: 1105:  // just return the result as unbounded.
    #####: 1106:  MPInt count(1);
call    0 never executed
call    1 never executed
    #####: 1107:  SmallVector<MPInt, 8> dim(getNumVars() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1108:  bool hasUnboundedVar = false;
    #####: 1109:  for (unsigned i = 0, e = getNumDimAndSymbolVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1110:    dim[i] = 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1111:    auto [min, max] = simplex.computeIntegerBounds(dim);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1112:    dim[i] = 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1113:
    #####: 1114:    assert((!min.isEmpty() && !max.isEmpty()) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1115:           "Polytope should be rationally non-empty!");
        -: 1116:
        -: 1117:    // One of the dimensions is unbounded. Note this fact. We will return
        -: 1118:    // unbounded if none of the other dimensions makes the volume zero.
    #####: 1119:    if (min.isUnbounded() || max.isUnbounded()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1120:      hasUnboundedVar = true;
    #####: 1121:      continue;
call    0 never executed
        -: 1122:    }
        -: 1123:
        -: 1124:    // In this case there are no valid integer points and the volume is
        -: 1125:    // definitely zero.
    #####: 1126:    if (min.getBoundedOptimum() > max.getBoundedOptimum())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1127:      return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1128:
    #####: 1129:    count *= (*max - *min + 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
        -: 1130:  }
        -: 1131:
    #####: 1132:  if (count == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1133:    return MPInt(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1134:  if (hasUnboundedVar)
branch  0 never executed
branch  1 never executed
    #####: 1135:    return {};
    #####: 1136:  return count;
call    0 never executed
call    1 never executed
        -: 1137:}
        -: 1138:
function _ZN4mlir10presburger15IntegerRelation26eliminateRedundantLocalVarEjj called 0 returned 0% blocks executed 0%
    #####: 1139:void IntegerRelation::eliminateRedundantLocalVar(unsigned posA, unsigned posB) {
    #####: 1140:  assert(posA < getNumLocalVars() && "Invalid local var position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1141:  assert(posB < getNumLocalVars() && "Invalid local var position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1142:
    #####: 1143:  unsigned localOffset = getVarKindOffset(VarKind::Local);
call    0 never executed
    #####: 1144:  posA += localOffset;
    #####: 1145:  posB += localOffset;
    #####: 1146:  inequalities.addToColumn(posB, posA, 1);
call    0 never executed
    #####: 1147:  equalities.addToColumn(posB, posA, 1);
call    0 never executed
    #####: 1148:  removeVar(posB);
call    0 never executed
    #####: 1149:}
        -: 1150:
        -: 1151:/// Adds additional local ids to the sets such that they both have the union
        -: 1152:/// of the local ids in each set, without changing the set of points that
        -: 1153:/// lie in `this` and `other`.
        -: 1154:///
        -: 1155:/// To detect local ids that always take the same value, each local id is
        -: 1156:/// represented as a floordiv with constant denominator in terms of other ids.
        -: 1157:/// After extracting these divisions, local ids in `other` with the same
        -: 1158:/// division representation as some other local id in any set are considered
        -: 1159:/// duplicate and are merged.
        -: 1160:///
        -: 1161:/// It is possible that division representation for some local id cannot be
        -: 1162:/// obtained, and thus these local ids are not considered for detecting
        -: 1163:/// duplicates.
function _ZN4mlir10presburger15IntegerRelation14mergeLocalVarsERS1_ called 0 returned 0% blocks executed 0%
    #####: 1164:unsigned IntegerRelation::mergeLocalVars(IntegerRelation &other) {
    #####: 1165:  IntegerRelation &relA = *this;
    #####: 1166:  IntegerRelation &relB = other;
        -: 1167:
    #####: 1168:  unsigned oldALocals = relA.getNumLocalVars();
call    0 never executed
        -: 1169:
        -: 1170:  // Merge function that merges the local variables in both sets by treating
        -: 1171:  // them as the same variable.
function _ZZN4mlir10presburger15IntegerRelation14mergeLocalVarsERS1_ENKUljjE_clEjj called 0 returned 0% blocks executed 0%
    #####: 1172:  auto merge = [&relA, &relB, oldALocals](unsigned i, unsigned j) -> bool {
        -: 1173:    // We only merge from local at pos j to local at pos i, where j > i.
    #####: 1174:    if (i >= j)
branch  0 never executed
branch  1 never executed
        -: 1175:      return false;
        -: 1176:
        -: 1177:    // If i < oldALocals, we are trying to merge duplicate divs. Since we do not
        -: 1178:    // want to merge duplicates in A, we ignore this call.
    #####: 1179:    if (j < oldALocals)
branch  0 never executed
branch  1 never executed
        -: 1180:      return false;
        -: 1181:
        -: 1182:    // Merge local at pos j into local at position i.
    #####: 1183:    relA.eliminateRedundantLocalVar(i, j);
call    0 never executed
    #####: 1184:    relB.eliminateRedundantLocalVar(i, j);
    #####: 1185:    return true;
call    0 never executed
    #####: 1186:  };
        -: 1187:
    #####: 1188:  presburger::mergeLocalVars(*this, other, merge);
call    0 never executed
        -: 1189:
        -: 1190:  // Since we do not remove duplicate divisions in relA, this is guranteed to be
        -: 1191:  // non-negative.
    #####: 1192:  return relA.getNumLocalVars() - oldALocals;
        -: 1193:}
        -: 1194:
function _ZNK4mlir10presburger15IntegerRelation16hasOnlyDivLocalsEv called 0 returned 0% blocks executed 0%
    #####: 1195:bool IntegerRelation::hasOnlyDivLocals() const {
    #####: 1196:  return getLocalReprs().hasAllReprs();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1197:}
        -: 1198:
function _ZN4mlir10presburger15IntegerRelation19removeDuplicateDivsEv called 0 returned 0% blocks executed 0%
    #####: 1199:void IntegerRelation::removeDuplicateDivs() {
    #####: 1200:  DivisionRepr divs = getLocalReprs();
call    0 never executed
    #####: 1201:  auto merge = [this](unsigned i, unsigned j) -> bool {
    #####: 1202:    eliminateRedundantLocalVar(i, j);
call    0 never executed
    #####: 1203:    return true;
    #####: 1204:  };
    #####: 1205:  divs.removeDuplicateDivs(merge);
call    0 never executed
call    1 never executed
    #####: 1206:}
        -: 1207:
        -: 1208:/// Removes local variables using equalities. Each equality is checked if it
        -: 1209:/// can be reduced to the form: `e = affine-expr`, where `e` is a local
        -: 1210:/// variable and `affine-expr` is an affine expression not containing `e`.
        -: 1211:/// If an equality satisfies this form, the local variable is replaced in
        -: 1212:/// each constraint and then removed. The equality used to replace this local
        -: 1213:/// variable is also removed.
function _ZN4mlir10presburger15IntegerRelation24removeRedundantLocalVarsEv called 0 returned 0% blocks executed 0%
    #####: 1214:void IntegerRelation::removeRedundantLocalVars() {
        -: 1215:  // Normalize the equality constraints to reduce coefficients of local
        -: 1216:  // variables to 1 wherever possible.
    #####: 1217:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1218:    equalities.normalizeRow(i);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1219:
    #####: 1220:  while (true) {
    #####: 1221:    unsigned i, e, j, f;
    #####: 1222:    for (i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -: 1223:      // Find a local variable to eliminate using ith equality.
    #####: 1224:      for (j = getNumDimAndSymbolVars(), f = getNumVars(); j < f; ++j)
branch  0 never executed
branch  1 never executed
    #####: 1225:        if (abs(atEq(i, j)) == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 1226:          break;
        -: 1227:
        -: 1228:      // Local variable can be eliminated using ith equality.
    #####: 1229:      if (j < f)
branch  0 never executed
branch  1 never executed
        -: 1230:        break;
        -: 1231:    }
        -: 1232:
        -: 1233:    // No equality can be used to eliminate a local variable.
    #####: 1234:    if (i == e)
branch  0 never executed
branch  1 never executed
        -: 1235:      break;
        -: 1236:
        -: 1237:    // Use the ith equality to simplify other equalities. If any changes
        -: 1238:    // are made to an equality constraint, it is normalized by GCD.
    #####: 1239:    for (unsigned k = 0, t = getNumEqualities(); k < t; ++k) {
branch  0 never executed
branch  1 never executed
    #####: 1240:      if (atEq(k, j) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1241:        eliminateFromConstraint(this, k, i, j, j, /*isEq=*/true);
call    0 never executed
    #####: 1242:        equalities.normalizeRow(k);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1243:      }
        -: 1244:    }
        -: 1245:
        -: 1246:    // Use the ith equality to simplify inequalities.
    #####: 1247:    for (unsigned k = 0, t = getNumInequalities(); k < t; ++k)
branch  0 never executed
branch  1 never executed
    #####: 1248:      eliminateFromConstraint(this, k, i, j, j, /*isEq=*/false);
call    0 never executed
        -: 1249:
        -: 1250:    // Remove the ith equality and the found local variable.
    #####: 1251:    removeVar(j);
call    0 never executed
    #####: 1252:    removeEquality(i);
call    0 never executed
        -: 1253:  }
    #####: 1254:}
        -: 1255:
function _ZN4mlir10presburger15IntegerRelation14convertVarKindENS0_7VarKindEjjS2_j called 0 returned 0% blocks executed 0%
    #####: 1256:void IntegerRelation::convertVarKind(VarKind srcKind, unsigned varStart,
        -: 1257:                                     unsigned varLimit, VarKind dstKind,
        -: 1258:                                     unsigned pos) {
    #####: 1259:  assert(varLimit <= getNumVarKind(srcKind) && "Invalid id range");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1260:
    #####: 1261:  if (varStart >= varLimit)
branch  0 never executed
branch  1 never executed
        -: 1262:    return;
        -: 1263:
        -: 1264:  // Append new local variables corresponding to the dimensions to be converted.
    #####: 1265:  unsigned convertCount = varLimit - varStart;
    #####: 1266:  unsigned newVarsBegin = insertVar(dstKind, pos, convertCount);
call    0 never executed
        -: 1267:
        -: 1268:  // Swap the new local variables with dimensions.
        -: 1269:  //
        -: 1270:  // Essentially, this moves the information corresponding to the specified ids
        -: 1271:  // of kind `srcKind` to the `convertCount` newly created ids of kind
        -: 1272:  // `dstKind`. In particular, this moves the columns in the constraint
        -: 1273:  // matrices, and zeros out the initially occupied columns (because the newly
        -: 1274:  // created ids we're swapping with were zero-initialized).
    #####: 1275:  unsigned offset = getVarKindOffset(srcKind);
call    0 never executed
    #####: 1276:  for (unsigned i = 0; i < convertCount; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1277:    swapVar(offset + varStart + i, newVarsBegin + i);
call    0 never executed
        -: 1278:
        -: 1279:  // Complete the move by deleting the initially occupied columns.
    #####: 1280:  removeVarRange(srcKind, varStart, varLimit);
call    0 never executed
        -: 1281:}
        -: 1282:
function _ZN4mlir10presburger15IntegerRelation8addBoundENS1_9BoundTypeEjRKNS0_5MPIntE called 0 returned 0% blocks executed 0%
    #####: 1283:void IntegerRelation::addBound(BoundType type, unsigned pos,
        -: 1284:                               const MPInt &value) {
    #####: 1285:  assert(pos < getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1286:  if (type == BoundType::EQ) {
branch  0 never executed
branch  1 never executed
    #####: 1287:    unsigned row = equalities.appendExtraRow();
call    0 never executed
    #####: 1288:    equalities(row, pos) = 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1289:    equalities(row, getNumCols() - 1) = -value;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1290:  } else {
    #####: 1291:    unsigned row = inequalities.appendExtraRow();
call    0 never executed
    #####: 1292:    inequalities(row, pos) = type == BoundType::LB ? 1 : -1;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1293:    inequalities(row, getNumCols() - 1) =
branch  0 never executed
branch  1 never executed
    #####: 1294:        type == BoundType::LB ? -value : value;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1295:  }
    #####: 1296:}
        -: 1297:
function _ZN4mlir10presburger15IntegerRelation8addBoundENS1_9BoundTypeEN4llvm8ArrayRefINS0_5MPIntEEERKS5_ called 0 returned 0% blocks executed 0%
    #####: 1298:void IntegerRelation::addBound(BoundType type, ArrayRef<MPInt> expr,
        -: 1299:                               const MPInt &value) {
    #####: 1300:  assert(type != BoundType::EQ && "EQ not implemented");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1301:  assert(expr.size() == getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1302:  unsigned row = inequalities.appendExtraRow();
call    0 never executed
    #####: 1303:  for (unsigned i = 0, e = expr.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1304:    inequalities(row, i) = type == BoundType::LB ? expr[i] : -expr[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
    #####: 1305:  inequalities(inequalities.getNumRows() - 1, getNumCols() - 1) +=
branch  0 never executed
branch  1 never executed
    #####: 1306:      type == BoundType::LB ? -value : value;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1307:}
        -: 1308:
        -: 1309:/// Adds a new local variable as the floordiv of an affine function of other
        -: 1310:/// variables, the coefficients of which are provided in 'dividend' and with
        -: 1311:/// respect to a positive constant 'divisor'. Two constraints are added to the
        -: 1312:/// system to capture equivalence with the floordiv.
        -: 1313:///      q = expr floordiv c    <=>   c*q <= expr <= c*q + c - 1.
function _ZN4mlir10presburger15IntegerRelation16addLocalFloorDivEN4llvm8ArrayRefINS0_5MPIntEEERKS4_ called 0 returned 0% blocks executed 0%
    #####: 1314:void IntegerRelation::addLocalFloorDiv(ArrayRef<MPInt> dividend,
        -: 1315:                                       const MPInt &divisor) {
    #####: 1316:  assert(dividend.size() == getNumCols() && "incorrect dividend size");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1317:  assert(divisor > 0 && "positive divisor expected");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1318:
    #####: 1319:  appendVar(VarKind::Local);
call    0 never executed
        -: 1320:
    #####: 1321:  SmallVector<MPInt, 8> dividendCopy(dividend.begin(), dividend.end());
call    0 never executed
    #####: 1322:  dividendCopy.insert(dividendCopy.end() - 1, MPInt(0));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1323:  addInequality(
call    0 never executed
    #####: 1324:      getDivLowerBound(dividendCopy, divisor, dividendCopy.size() - 2));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1325:  addInequality(
call    0 never executed
    #####: 1326:      getDivUpperBound(dividendCopy, divisor, dividendCopy.size() - 2));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1327:}
        -: 1328:
        -: 1329:/// Finds an equality that equates the specified variable to a constant.
        -: 1330:/// Returns the position of the equality row. If 'symbolic' is set to true,
        -: 1331:/// symbols are also treated like a constant, i.e., an affine function of the
        -: 1332:/// symbols is also treated like a constant. Returns -1 if such an equality
        -: 1333:/// could not be found.
function _ZL22findEqualityToConstantRKN4mlir10presburger15IntegerRelationEjb called 0 returned 0% blocks executed 0%
    #####: 1334:static int findEqualityToConstant(const IntegerRelation &cst, unsigned pos,
        -: 1335:                                  bool symbolic = false) {
    #####: 1336:  assert(pos < cst.getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1337:  for (unsigned r = 0, e = cst.getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1338:    MPInt v = cst.atEq(r, pos);
call    0 never executed
    #####: 1339:    if (v * v != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1340:      continue;
branch  0 never executed
branch  1 never executed
    #####: 1341:    unsigned c;
    #####: 1342:    unsigned f = symbolic ? cst.getNumDimVars() : cst.getNumVars();
branch  0 never executed
branch  1 never executed
        -: 1343:    // This checks for zeros in all positions other than 'pos' in [0, f)
    #####: 1344:    for (c = 0; c < f; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1345:      if (c == pos)
branch  0 never executed
branch  1 never executed
    #####: 1346:        continue;
    #####: 1347:      if (cst.atEq(r, c) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1348:        // Dependent on another variable.
        -: 1349:        break;
        -: 1350:      }
        -: 1351:    }
    #####: 1352:    if (c == f)
branch  0 never executed
branch  1 never executed
        -: 1353:      // Equality is free of other variables.
    #####: 1354:      return r;
branch  0 never executed
branch  1 never executed
        -: 1355:  }
        -: 1356:  return -1;
        -: 1357:}
        -: 1358:
function _ZN4mlir10presburger15IntegerRelation15constantFoldVarEj called 0 returned 0% blocks executed 0%
    #####: 1359:LogicalResult IntegerRelation::constantFoldVar(unsigned pos) {
    #####: 1360:  assert(pos < getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1361:  int rowIdx;
    #####: 1362:  if ((rowIdx = findEqualityToConstant(*this, pos)) == -1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1363:    return failure();
        -: 1364:
        -: 1365:  // atEq(rowIdx, pos) is either -1 or 1.
    #####: 1366:  assert(atEq(rowIdx, pos) * atEq(rowIdx, pos) == 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
    #####: 1367:  MPInt constVal = -atEq(rowIdx, getNumCols() - 1) / atEq(rowIdx, pos);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1368:  setAndEliminate(pos, constVal);
call    0 never executed
    #####: 1369:  return success();
branch  0 never executed
branch  1 never executed
        -: 1370:}
        -: 1371:
function _ZN4mlir10presburger15IntegerRelation20constantFoldVarRangeEjj called 0 returned 0% blocks executed 0%
    #####: 1372:void IntegerRelation::constantFoldVarRange(unsigned pos, unsigned num) {
    #####: 1373:  for (unsigned s = pos, t = pos, e = pos + num; s < e; s++) {
branch  0 never executed
branch  1 never executed
    #####: 1374:    if (failed(constantFoldVar(t)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1375:      t++;
        -: 1376:  }
    #####: 1377:}
        -: 1378:
        -: 1379:/// Returns a non-negative constant bound on the extent (upper bound - lower
        -: 1380:/// bound) of the specified variable if it is found to be a constant; returns
        -: 1381:/// None if it's not a constant. This methods treats symbolic variables
        -: 1382:/// specially, i.e., it looks for constant differences between affine
        -: 1383:/// expressions involving only the symbolic variables. See comments at
        -: 1384:/// function definition for example. 'lb', if provided, is set to the lower
        -: 1385:/// bound associated with the constant difference. Note that 'lb' is purely
        -: 1386:/// symbolic and thus will contain the coefficients of the symbolic variables
        -: 1387:/// and the constant coefficient.
        -: 1388://  Egs: 0 <= i <= 15, return 16.
        -: 1389://       s0 + 2 <= i <= s0 + 17, returns 16. (s0 has to be a symbol)
        -: 1390://       s0 + s1 + 16 <= d0 <= s0 + s1 + 31, returns 16.
        -: 1391://       s0 - 7 <= 8*j <= s0 returns 1 with lb = s0, lbDivisor = 8 (since lb =
        -: 1392://       ceil(s0 - 7 / 8) = floor(s0 / 8)).
function _ZNK4mlir10presburger15IntegerRelation25getConstantBoundOnDimSizeEjPN4llvm15SmallVectorImplINS0_5MPIntEEEPS4_S6_PjS8_ called 0 returned 0% blocks executed 0%
    #####: 1393:Optional<MPInt> IntegerRelation::getConstantBoundOnDimSize(
        -: 1394:    unsigned pos, SmallVectorImpl<MPInt> *lb, MPInt *boundFloorDivisor,
        -: 1395:    SmallVectorImpl<MPInt> *ub, unsigned *minLbPos, unsigned *minUbPos) const {
    #####: 1396:  assert(pos < getNumDimVars() && "Invalid variable position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1397:
        -: 1398:  // Find an equality for 'pos'^th variable that equates it to some function
        -: 1399:  // of the symbolic variables (+ constant).
    #####: 1400:  int eqPos = findEqualityToConstant(*this, pos, /*symbolic=*/true);
call    0 never executed
    #####: 1401:  if (eqPos != -1) {
branch  0 never executed
branch  1 never executed
    #####: 1402:    auto eq = getEquality(eqPos);
call    0 never executed
        -: 1403:    // If the equality involves a local var, punt for now.
        -: 1404:    // TODO: this can be handled in the future by using the explicit
        -: 1405:    // representation of the local vars.
    #####: 1406:    if (!std::all_of(eq.begin() + getNumDimAndSymbolVars(), eq.end() - 1,
call    0 never executed
branch  1 never executed
branch  2 never executed
function _ZZNK4mlir10presburger15IntegerRelation25getConstantBoundOnDimSizeEjPN4llvm15SmallVectorImplINS0_5MPIntEEEPS4_S6_PjS8_ENKUlRKS4_E_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1407:                     [](const MPInt &coeff) { return coeff == 0; }))
branch  0 never executed
branch  1 never executed
    #####: 1408:      return None;
        -: 1409:
        -: 1410:    // This variable can only take a single value.
    #####: 1411:    if (lb) {
branch  0 never executed
branch  1 never executed
        -: 1412:      // Set lb to that symbolic value.
    #####: 1413:      lb->resize(getNumSymbolVars() + 1);
call    0 never executed
    #####: 1414:      if (ub)
branch  0 never executed
branch  1 never executed
    #####: 1415:        ub->resize(getNumSymbolVars() + 1);
call    0 never executed
    #####: 1416:      for (unsigned c = 0, f = getNumSymbolVars() + 1; c < f; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1417:        MPInt v = atEq(eqPos, pos);
call    0 never executed
        -: 1418:        // atEq(eqRow, pos) is either -1 or 1.
    #####: 1419:        assert(v * v == 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 1420:        (*lb)[c] = v < 0 ? atEq(eqPos, getNumDimVars() + c) / -v
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
    #####: 1421:                         : -atEq(eqPos, getNumDimVars() + c) / v;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
        -: 1422:        // Since this is an equality, ub = lb.
    #####: 1423:        if (ub)
branch  0 never executed
branch  1 never executed
    #####: 1424:          (*ub)[c] = (*lb)[c];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1425:      }
    #####: 1426:      assert(boundFloorDivisor &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1427:             "both lb and divisor or none should be provided");
    #####: 1428:      *boundFloorDivisor = 1;
branch  0 never executed
branch  1 never executed
        -: 1429:    }
    #####: 1430:    if (minLbPos)
branch  0 never executed
branch  1 never executed
    #####: 1431:      *minLbPos = eqPos;
    #####: 1432:    if (minUbPos)
branch  0 never executed
branch  1 never executed
    #####: 1433:      *minUbPos = eqPos;
    #####: 1434:    return MPInt(1);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1435:  }
        -: 1436:
        -: 1437:  // Check if the variable appears at all in any of the inequalities.
    #####: 1438:  unsigned r, e;
    #####: 1439:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1440:    if (atIneq(r, pos) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1441:      break;
        -: 1442:  }
    #####: 1443:  if (r == e)
branch  0 never executed
branch  1 never executed
        -: 1444:    // If it doesn't, there isn't a bound on it.
    #####: 1445:    return None;
        -: 1446:
        -: 1447:  // Positions of constraints that are lower/upper bounds on the variable.
    #####: 1448:  SmallVector<unsigned, 4> lbIndices, ubIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1449:
        -: 1450:  // Gather all symbolic lower bounds and upper bounds of the variable, i.e.,
        -: 1451:  // the bounds can only involve symbolic (and local) variables. Since the
        -: 1452:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -: 1453:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
    #####: 1454:  getLowerAndUpperBoundIndices(pos, &lbIndices, &ubIndices,
call    0 never executed
        -: 1455:                               /*eqIndices=*/nullptr, /*offset=*/0,
        -: 1456:                               /*num=*/getNumDimVars());
        -: 1457:
    #####: 1458:  Optional<MPInt> minDiff;
branch  0 never executed
branch  1 never executed
    #####: 1459:  unsigned minLbPosition = 0, minUbPosition = 0;
    #####: 1460:  for (auto ubPos : ubIndices) {
branch  0 never executed
branch  1 never executed
    #####: 1461:    for (auto lbPos : lbIndices) {
branch  0 never executed
branch  1 never executed
        -: 1462:      // Look for a lower bound and an upper bound that only differ by a
        -: 1463:      // constant, i.e., pairs of the form  0 <= c_pos - f(c_i's) <= diffConst.
        -: 1464:      // For example, if ii is the pos^th variable, we are looking for
        -: 1465:      // constraints like ii >= i, ii <= ii + 50, 50 being the difference. The
        -: 1466:      // minimum among all such constant differences is kept since that's the
        -: 1467:      // constant bounding the extent of the pos^th variable.
    #####: 1468:      unsigned j, e;
    #####: 1469:      for (j = 0, e = getNumCols() - 1; j < e; j++)
branch  0 never executed
branch  1 never executed
    #####: 1470:        if (atIneq(ubPos, j) != -atIneq(lbPos, j)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -: 1471:          break;
        -: 1472:        }
    #####: 1473:      if (j < getNumCols() - 1)
branch  0 never executed
branch  1 never executed
    #####: 1474:        continue;
    #####: 1475:      MPInt diff = ceilDiv(atIneq(ubPos, getNumCols() - 1) +
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1476:                               atIneq(lbPos, getNumCols() - 1) + 1,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1477:                           atIneq(lbPos, pos));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1478:      // This bound is non-negative by definition.
    #####: 1479:      diff = std::max<MPInt>(diff, MPInt(0));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1480:      if (minDiff == None || diff < minDiff) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1481:        minDiff = diff;
call    0 never executed
    #####: 1482:        minLbPosition = lbPos;
    #####: 1483:        minUbPosition = ubPos;
call    0 never executed
        -: 1484:      }
        -: 1485:    }
        -: 1486:  }
    #####: 1487:  if (lb && minDiff) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1488:    // Set lb to the symbolic lower bound.
    #####: 1489:    lb->resize(getNumSymbolVars() + 1);
call    0 never executed
    #####: 1490:    if (ub)
branch  0 never executed
branch  1 never executed
    #####: 1491:      ub->resize(getNumSymbolVars() + 1);
call    0 never executed
        -: 1492:    // The lower bound is the ceildiv of the lb constraint over the coefficient
        -: 1493:    // of the variable at 'pos'. We express the ceildiv equivalently as a floor
        -: 1494:    // for uniformity. For eg., if the lower bound constraint was: 32*d0 - N +
        -: 1495:    // 31 >= 0, the lower bound for d0 is ceil(N - 31, 32), i.e., floor(N, 32).
    #####: 1496:    *boundFloorDivisor = atIneq(minLbPosition, pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1497:    assert(*boundFloorDivisor == -atIneq(minUbPosition, pos));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1498:    for (unsigned c = 0, e = getNumSymbolVars() + 1; c < e; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1499:      (*lb)[c] = -atIneq(minLbPosition, getNumDimVars() + c);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1500:    }
    #####: 1501:    if (ub) {
branch  0 never executed
branch  1 never executed
    #####: 1502:      for (unsigned c = 0, e = getNumSymbolVars() + 1; c < e; c++)
branch  0 never executed
branch  1 never executed
    #####: 1503:        (*ub)[c] = atIneq(minUbPosition, getNumDimVars() + c);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1504:    }
        -: 1505:    // The lower bound leads to a ceildiv while the upper bound is a floordiv
        -: 1506:    // whenever the coefficient at pos != 1. ceildiv (val / d) = floordiv (val +
        -: 1507:    // d - 1 / d); hence, the addition of 'atIneq(minLbPosition, pos) - 1' to
        -: 1508:    // the constant term for the lower bound.
    #####: 1509:    (*lb)[getNumSymbolVars()] += atIneq(minLbPosition, pos) - 1;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1510:  }
    #####: 1511:  if (minLbPos)
branch  0 never executed
branch  1 never executed
    #####: 1512:    *minLbPos = minLbPosition;
    #####: 1513:  if (minUbPos)
branch  0 never executed
branch  1 never executed
    #####: 1514:    *minUbPos = minUbPosition;
    #####: 1515:  return minDiff;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1516:}
        -: 1517:
        -: 1518:template <bool isLower>
        -: 1519:Optional<MPInt>
    #####: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
    #####: 1521:  assert(pos < getNumVars() && "invalid position");
        -: 1522:  // Project to 'pos'.
    #####: 1523:  projectOut(0, pos);
    #####: 1524:  projectOut(1, getNumVars() - 1);
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
    #####: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
    #####: 1527:  if (eqRowIdx != -1)
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    #####: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
    #####: 1534:    if (atIneq(r, 0) != 0)
        -: 1535:      break;
        -: 1536:  }
    #####: 1537:  if (r == e)
        -: 1538:    // If it doesn't, there isn't a bound on it.
    #####: 1539:    return None;
        -: 1540:
    #####: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
    #####: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
        -: 1546:    if (isLower) {
    #####: 1547:      if (atIneq(r, 0) <= 0)
        -: 1548:        // Not a lower bound.
    #####: 1549:        continue;
    #####: 1550:    } else if (atIneq(r, 0) >= 0) {
        -: 1551:      // Not an upper bound.
    #####: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
    #####: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
    #####: 1556:      if (c != 0 && atIneq(r, c) != 0)
        -: 1557:        break;
    #####: 1558:    if (c < getNumCols() - 1)
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
    #####: 1562:    MPInt boundConst =
    #####: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
    #####: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
        -: 1565:    if (isLower) {
    #####: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
    #####: 1567:        minOrMaxConst = boundConst;
        -: 1568:    } else {
    #####: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
    #####: 1570:        minOrMaxConst = boundConst;
        -: 1571:    }
        -: 1572:  }
    #####: 1573:  return minOrMaxConst;
        -: 1574:}
------------------
_ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb0EEEN4llvm8OptionalINS0_5MPIntEEEj:
function _ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb0EEEN4llvm8OptionalINS0_5MPIntEEEj called 0 returned 0% blocks executed 0%
    #####: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
branch  0 never executed
branch  1 never executed
    #####: 1521:  assert(pos < getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1522:  // Project to 'pos'.
    #####: 1523:  projectOut(0, pos);
call    0 never executed
call    1 never executed
    #####: 1524:  projectOut(1, getNumVars() - 1);
call    0 never executed
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
    #####: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
call    0 never executed
    #####: 1527:  if (eqRowIdx != -1)
branch  0 never executed
branch  1 never executed
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    #####: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1534:    if (atIneq(r, 0) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1535:      break;
        -: 1536:  }
    #####: 1537:  if (r == e)
branch  0 never executed
branch  1 never executed
        -: 1538:    // If it doesn't, there isn't a bound on it.
    #####: 1539:    return None;
        -: 1540:
    #####: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
    #####: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1546:    if (isLower) {
        -: 1547:      if (atIneq(r, 0) <= 0)
        -: 1548:        // Not a lower bound.
    #####: 1549:        continue;
    #####: 1550:    } else if (atIneq(r, 0) >= 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1551:      // Not an upper bound.
    #####: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
    #####: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
branch  0 never executed
branch  1 never executed
    #####: 1556:      if (c != 0 && atIneq(r, c) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1557:        break;
    #####: 1558:    if (c < getNumCols() - 1)
branch  0 never executed
branch  1 never executed
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
    #####: 1562:    MPInt boundConst =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
    #####: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1565:    if (isLower) {
        -: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
        -: 1567:        minOrMaxConst = boundConst;
        -: 1568:    } else {
    #####: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1570:        minOrMaxConst = boundConst;
branch  0 never executed
branch  1 never executed
        -: 1571:    }
        -: 1572:  }
    #####: 1573:  return minOrMaxConst;
call    0 never executed
        -: 1574:}
------------------
_ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb1EEEN4llvm8OptionalINS0_5MPIntEEEj:
function _ZN4mlir10presburger15IntegerRelation32computeConstantLowerOrUpperBoundILb1EEEN4llvm8OptionalINS0_5MPIntEEEj called 0 returned 0% blocks executed 0%
    #####: 1520:IntegerRelation::computeConstantLowerOrUpperBound(unsigned pos) {
branch  0 never executed
branch  1 never executed
    #####: 1521:  assert(pos < getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1522:  // Project to 'pos'.
    #####: 1523:  projectOut(0, pos);
call    0 never executed
call    1 never executed
    #####: 1524:  projectOut(1, getNumVars() - 1);
call    0 never executed
        -: 1525:  // Check if there's an equality equating the '0'^th variable to a constant.
    #####: 1526:  int eqRowIdx = findEqualityToConstant(*this, 0, /*symbolic=*/false);
call    0 never executed
    #####: 1527:  if (eqRowIdx != -1)
branch  0 never executed
branch  1 never executed
        -: 1528:    // atEq(rowIdx, 0) is either -1 or 1.
    #####: 1529:    return -atEq(eqRowIdx, getNumCols() - 1) / atEq(eqRowIdx, 0);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -: 1530:
        -: 1531:  // Check if the variable appears at all in any of the inequalities.
        -: 1532:  unsigned r, e;
    #####: 1533:  for (r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1534:    if (atIneq(r, 0) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1535:      break;
        -: 1536:  }
    #####: 1537:  if (r == e)
branch  0 never executed
branch  1 never executed
        -: 1538:    // If it doesn't, there isn't a bound on it.
    #####: 1539:    return None;
        -: 1540:
    #####: 1541:  Optional<MPInt> minOrMaxConst;
        -: 1542:
        -: 1543:  // Take the max across all const lower bounds (or min across all constant
        -: 1544:  // upper bounds).
    #####: 1545:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1546:    if (isLower) {
    #####: 1547:      if (atIneq(r, 0) <= 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1548:        // Not a lower bound.
    #####: 1549:        continue;
        -: 1550:    } else if (atIneq(r, 0) >= 0) {
        -: 1551:      // Not an upper bound.
        -: 1552:      continue;
        -: 1553:    }
        -: 1554:    unsigned c, f;
    #####: 1555:    for (c = 0, f = getNumCols() - 1; c < f; c++)
branch  0 never executed
branch  1 never executed
    #####: 1556:      if (c != 0 && atIneq(r, c) != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1557:        break;
    #####: 1558:    if (c < getNumCols() - 1)
branch  0 never executed
branch  1 never executed
        -: 1559:      // Not a constant bound.
    #####: 1560:      continue;
        -: 1561:
    #####: 1562:    MPInt boundConst =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1563:        isLower ? ceilDiv(-atIneq(r, getNumCols() - 1), atIneq(r, 0))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1564:                : floorDiv(atIneq(r, getNumCols() - 1), -atIneq(r, 0));
        -: 1565:    if (isLower) {
    #####: 1566:      if (minOrMaxConst == None || boundConst > minOrMaxConst)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1567:        minOrMaxConst = boundConst;
branch  0 never executed
branch  1 never executed
        -: 1568:    } else {
        -: 1569:      if (minOrMaxConst == None || boundConst < minOrMaxConst)
        -: 1570:        minOrMaxConst = boundConst;
        -: 1571:    }
        -: 1572:  }
    #####: 1573:  return minOrMaxConst;
call    0 never executed
        -: 1574:}
------------------
        -: 1575:
function _ZNK4mlir10presburger15IntegerRelation16getConstantBoundENS1_9BoundTypeEj called 0 returned 0% blocks executed 0%
    #####: 1576:Optional<MPInt> IntegerRelation::getConstantBound(BoundType type,
        -: 1577:                                                  unsigned pos) const {
    #####: 1578:  if (type == BoundType::LB)
branch  0 never executed
branch  1 never executed
    #####: 1579:    return IntegerRelation(*this)
call    0 never executed
call    1 never executed
    #####: 1580:        .computeConstantLowerOrUpperBound</*isLower=*/true>(pos);
call    0 never executed
    #####: 1581:  if (type == BoundType::UB)
branch  0 never executed
branch  1 never executed
    #####: 1582:    return IntegerRelation(*this)
call    0 never executed
call    1 never executed
    #####: 1583:        .computeConstantLowerOrUpperBound</*isLower=*/false>(pos);
call    0 never executed
        -: 1584:
    #####: 1585:  assert(type == BoundType::EQ && "expected EQ");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1586:  Optional<MPInt> lb =
    #####: 1587:      IntegerRelation(*this).computeConstantLowerOrUpperBound</*isLower=*/true>(
call    0 never executed
    #####: 1588:          pos);
call    0 never executed
    #####: 1589:  Optional<MPInt> ub =
    #####: 1590:      IntegerRelation(*this)
call    0 never executed
    #####: 1591:          .computeConstantLowerOrUpperBound</*isLower=*/false>(pos);
call    0 never executed
call    1 never executed
    #####: 1592:  return (lb && ub && *lb == *ub) ? Optional<MPInt>(*ub) : None;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
        -: 1593:}
        -: 1594:
        -: 1595:// A simple (naive and conservative) check for hyper-rectangularity.
function _ZNK4mlir10presburger15IntegerRelation18isHyperRectangularEjj called 0 returned 0% blocks executed 0%
    #####: 1596:bool IntegerRelation::isHyperRectangular(unsigned pos, unsigned num) const {
    #####: 1597:  assert(pos < getNumCols() - 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1598:  // Check for two non-zero coefficients in the range [pos, pos + sum).
    #####: 1599:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1600:    unsigned sum = 0;
    #####: 1601:    for (unsigned c = pos; c < pos + num; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1602:      if (atIneq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1603:        sum++;
        -: 1604:    }
    #####: 1605:    if (sum > 1)
branch  0 never executed
branch  1 never executed
        -: 1606:      return false;
        -: 1607:  }
    #####: 1608:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 1609:    unsigned sum = 0;
    #####: 1610:    for (unsigned c = pos; c < pos + num; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1611:      if (atEq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1612:        sum++;
        -: 1613:    }
    #####: 1614:    if (sum > 1)
branch  0 never executed
branch  1 never executed
        -: 1615:      return false;
        -: 1616:  }
        -: 1617:  return true;
        -: 1618:}
        -: 1619:
        -: 1620:/// Removes duplicate constraints, trivially true constraints, and constraints
        -: 1621:/// that can be detected as redundant as a result of differing only in their
        -: 1622:/// constant term part. A constraint of the form <non-negative constant> >= 0 is
        -: 1623:/// considered trivially true.
        -: 1624://  Uses a DenseSet to hash and detect duplicates followed by a linear scan to
        -: 1625://  remove duplicates in place.
function _ZN4mlir10presburger15IntegerRelation23removeTrivialRedundancyEv called 0 returned 0% blocks executed 0%
    #####: 1626:void IntegerRelation::removeTrivialRedundancy() {
    #####: 1627:  gcdTightenInequalities();
call    0 never executed
    #####: 1628:  normalizeConstraintsByGCD();
call    0 never executed
        -: 1629:
        -: 1630:  // A map used to detect redundancy stemming from constraints that only differ
        -: 1631:  // in their constant term. The value stored is <row position, const term>
        -: 1632:  // for a given row.
    #####: 1633:  SmallDenseMap<ArrayRef<MPInt>, std::pair<unsigned, MPInt>>
call    0 never executed
    #####: 1634:      rowsWithoutConstTerm;
        -: 1635:  // To unique rows.
    #####: 1636:  SmallDenseSet<ArrayRef<MPInt>, 8> rowSet;
call    0 never executed
call    1 never executed
        -: 1637:
        -: 1638:  // Check if constraint is of the form <non-negative-constant> >= 0.
function _ZZN4mlir10presburger15IntegerRelation23removeTrivialRedundancyEvENKUljE_clEj.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1639:  auto isTriviallyValid = [&](unsigned r) -> bool {
    #####: 1640:    for (unsigned c = 0, e = getNumCols() - 1; c < e; c++) {
branch  0 never executed
branch  1 never executed
    #####: 1641:      if (atIneq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1642:        return false;
        -: 1643:    }
    #####: 1644:    return atIneq(r, getNumCols() - 1) >= 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1645:  };
        -: 1646:
        -: 1647:  // Detect and mark redundant constraints.
    #####: 1648:  SmallVector<bool, 256> redunIneq(getNumInequalities(), false);
call    0 never executed
call    1 never executed
    #####: 1649:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1650:    MPInt *rowStart = &inequalities(r, 0);
call    0 never executed
    #####: 1651:    auto row = ArrayRef<MPInt>(rowStart, getNumCols());
call    0 never executed
    #####: 1652:    if (isTriviallyValid(r) || !rowSet.insert(row).second) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1653:      redunIneq[r] = true;
branch  0 never executed
branch  1 never executed
    #####: 1654:      continue;
        -: 1655:    }
        -: 1656:
        -: 1657:    // Among constraints that only differ in the constant term part, mark
        -: 1658:    // everything other than the one with the smallest constant term redundant.
        -: 1659:    // (eg: among i - 16j - 5 >= 0, i - 16j - 1 >=0, i - 16j - 7 >= 0, the
        -: 1660:    // former two are redundant).
    #####: 1661:    MPInt constTerm = atIneq(r, getNumCols() - 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1662:    auto rowWithoutConstTerm = ArrayRef<MPInt>(rowStart, getNumCols() - 1);
call    0 never executed
    #####: 1663:    const auto &ret =
    #####: 1664:        rowsWithoutConstTerm.insert({rowWithoutConstTerm, {r, constTerm}});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1665:    if (!ret.second) {
branch  0 never executed
branch  1 never executed
        -: 1666:      // Check if the other constraint has a higher constant term.
    #####: 1667:      auto &val = ret.first->second;
call    0 never executed
    #####: 1668:      if (val.second > constTerm) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1669:        // The stored row is redundant. Mark it so, and update with this one.
    #####: 1670:        redunIneq[val.first] = true;
branch  0 never executed
branch  1 never executed
    #####: 1671:        val = {r, constTerm};
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1672:      } else {
        -: 1673:        // The one stored makes this one redundant.
    #####: 1674:        redunIneq[r] = true;
branch  0 never executed
branch  1 never executed
        -: 1675:      }
        -: 1676:    }
        -: 1677:  }
        -: 1678:
        -: 1679:  // Scan to get rid of all rows marked redundant, in-place.
    #####: 1680:  unsigned pos = 0;
    #####: 1681:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++)
branch  0 never executed
branch  1 never executed
    #####: 1682:    if (!redunIneq[r])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1683:      inequalities.copyRow(r, pos++);
call    0 never executed
        -: 1684:
    #####: 1685:  inequalities.resizeVertically(pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1686:
        -: 1687:  // TODO: consider doing this for equalities as well, but probably not worth
        -: 1688:  // the savings.
    #####: 1689:}
        -: 1690:
        -: 1691:#undef DEBUG_TYPE
        -: 1692:#define DEBUG_TYPE "fm"
        -: 1693:
        -: 1694:/// Eliminates variable at the specified position using Fourier-Motzkin
        -: 1695:/// variable elimination. This technique is exact for rational spaces but
        -: 1696:/// conservative (in "rare" cases) for integer spaces. The operation corresponds
        -: 1697:/// to a projection operation yielding the (convex) set of integer points
        -: 1698:/// contained in the rational shadow of the set. An emptiness test that relies
        -: 1699:/// on this method will guarantee emptiness, i.e., it disproves the existence of
        -: 1700:/// a solution if it says it's empty.
        -: 1701:/// If a non-null isResultIntegerExact is passed, it is set to true if the
        -: 1702:/// result is also integer exact. If it's set to false, the obtained solution
        -: 1703:/// *may* not be exact, i.e., it may contain integer points that do not have an
        -: 1704:/// integer pre-image in the original set.
        -: 1705:///
        -: 1706:/// Eg:
        -: 1707:/// j >= 0, j <= i + 1
        -: 1708:/// i >= 0, i <= N + 1
        -: 1709:/// Eliminating i yields,
        -: 1710:///   j >= 0, 0 <= N + 1, j - 1 <= N + 1
        -: 1711:///
        -: 1712:/// If darkShadow = true, this method computes the dark shadow on elimination;
        -: 1713:/// the dark shadow is a convex integer subset of the exact integer shadow. A
        -: 1714:/// non-empty dark shadow proves the existence of an integer solution. The
        -: 1715:/// elimination in such a case could however be an under-approximation, and thus
        -: 1716:/// should not be used for scanning sets or used by itself for dependence
        -: 1717:/// checking.
        -: 1718:///
        -: 1719:/// Eg: 2-d set, * represents grid points, 'o' represents a point in the set.
        -: 1720:///            ^
        -: 1721:///            |
        -: 1722:///            | * * * * o o
        -: 1723:///         i  | * * o o o o
        -: 1724:///            | o * * * * *
        -: 1725:///            --------------->
        -: 1726:///                 j ->
        -: 1727:///
        -: 1728:/// Eliminating i from this system (projecting on the j dimension):
        -: 1729:/// rational shadow / integer light shadow:  1 <= j <= 6
        -: 1730:/// dark shadow:                             3 <= j <= 6
        -: 1731:/// exact integer shadow:                    j = 1 \union  3 <= j <= 6
        -: 1732:/// holes/splinters:                         j = 2
        -: 1733:///
        -: 1734:/// darkShadow = false, isResultIntegerExact = nullptr are default values.
        -: 1735:// TODO: a slight modification to yield dark shadow version of FM (tightened),
        -: 1736:// which can prove the existence of a solution if there is one.
function _ZN4mlir10presburger15IntegerRelation23fourierMotzkinEliminateEjbPb called 0 returned 0% blocks executed 0%
    #####: 1737:void IntegerRelation::fourierMotzkinEliminate(unsigned pos, bool darkShadow,
        -: 1738:                                              bool *isResultIntegerExact) {
    #####: 1739:  LLVM_DEBUG(llvm::dbgs() << "FM input (eliminate pos " << pos << "):\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####: 1740:  LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1741:  assert(pos < getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1742:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1743:
        -: 1744:  // Check if this variable can be eliminated through a substitution.
    #####: 1745:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1746:    if (atEq(r, pos) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1747:      // Use Gaussian elimination here (since we have an equality).
    #####: 1748:      LogicalResult ret = gaussianEliminateVar(pos);
call    0 never executed
    #####: 1749:      (void)ret;
    #####: 1750:      assert(succeeded(ret) && "Gaussian elimination guaranteed to succeed");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1751:      LLVM_DEBUG(llvm::dbgs() << "FM output (through Gaussian elimination):\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####: 1752:      LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1753:      return;
        -: 1754:    }
        -: 1755:  }
        -: 1756:
        -: 1757:  // A fast linear time tightening.
    #####: 1758:  gcdTightenInequalities();
call    0 never executed
        -: 1759:
        -: 1760:  // Check if the variable appears at all in any of the inequalities.
    #####: 1761:  if (isColZero(pos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1762:    // If it doesn't appear, just remove the column and return.
        -: 1763:    // TODO: refactor removeColumns to use it from here.
    #####: 1764:    removeVar(pos);
call    0 never executed
    #####: 1765:    LLVM_DEBUG(llvm::dbgs() << "FM output:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####: 1766:    LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1767:    return;
        -: 1768:  }
        -: 1769:
        -: 1770:  // Positions of constraints that are lower bounds on the variable.
    #####: 1771:  SmallVector<unsigned, 4> lbIndices;
call    0 never executed
call    1 never executed
        -: 1772:  // Positions of constraints that are lower bounds on the variable.
    #####: 1773:  SmallVector<unsigned, 4> ubIndices;
call    0 never executed
        -: 1774:  // Positions of constraints that do not involve the variable.
    #####: 1775:  std::vector<unsigned> nbIndices;
call    0 never executed
call    1 never executed
    #####: 1776:  nbIndices.reserve(getNumInequalities());
call    0 never executed
        -: 1777:
        -: 1778:  // Gather all lower bounds and upper bounds of the variable. Since the
        -: 1779:  // canonical form c_1*x_1 + c_2*x_2 + ... + c_0 >= 0, a constraint is a lower
        -: 1780:  // bound for x_i if c_i >= 1, and an upper bound if c_i <= -1.
    #####: 1781:  for (unsigned r = 0, e = getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1782:    if (atIneq(r, pos) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1783:      // Var does not appear in bound.
    #####: 1784:      nbIndices.push_back(r);
call    0 never executed
    #####: 1785:    } else if (atIneq(r, pos) >= 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1786:      // Lower bound.
    #####: 1787:      lbIndices.push_back(r);
call    0 never executed
        -: 1788:    } else {
        -: 1789:      // Upper bound.
    #####: 1790:      ubIndices.push_back(r);
call    0 never executed
        -: 1791:    }
        -: 1792:  }
        -: 1793:
    #####: 1794:  PresburgerSpace newSpace = getSpace();
call    0 never executed
call    1 never executed
    #####: 1795:  VarKind idKindRemove = newSpace.getVarKindAt(pos);
call    0 never executed
    #####: 1796:  unsigned relativePos = pos - newSpace.getVarKindOffset(idKindRemove);
call    0 never executed
    #####: 1797:  newSpace.removeVarRange(idKindRemove, relativePos, relativePos + 1);
call    0 never executed
        -: 1798:
        -: 1799:  /// Create the new system which has one variable less.
    #####: 1800:  IntegerRelation newRel(lbIndices.size() * ubIndices.size() + nbIndices.size(),
call    0 never executed
    #####: 1801:                         getNumEqualities(), getNumCols() - 1, newSpace);
call    0 never executed
call    1 never executed
        -: 1802:
        -: 1803:  // This will be used to check if the elimination was integer exact.
    #####: 1804:  bool allLCMsAreOne = true;
        -: 1805:
        -: 1806:  // Let x be the variable we are eliminating.
        -: 1807:  // For each lower bound, lb <= c_l*x, and each upper bound c_u*x <= ub, (note
        -: 1808:  // that c_l, c_u >= 1) we have:
        -: 1809:  // lb*lcm(c_l, c_u)/c_l <= lcm(c_l, c_u)*x <= ub*lcm(c_l, c_u)/c_u
        -: 1810:  // We thus generate a constraint:
        -: 1811:  // lcm(c_l, c_u)/c_l*lb <= lcm(c_l, c_u)/c_u*ub.
        -: 1812:  // Note if c_l = c_u = 1, all integer points captured by the resulting
        -: 1813:  // constraint correspond to integer points in the original system (i.e., they
        -: 1814:  // have integer pre-images). Hence, if the lcm's are all 1, the elimination is
        -: 1815:  // integer exact.
    #####: 1816:  for (auto ubPos : ubIndices) {
branch  0 never executed
branch  1 never executed
    #####: 1817:    for (auto lbPos : lbIndices) {
branch  0 never executed
branch  1 never executed
    #####: 1818:      SmallVector<MPInt, 4> ineq;
branch  0 never executed
branch  1 never executed
    #####: 1819:      ineq.reserve(newRel.getNumCols());
branch  0 never executed
branch  1 never executed
    #####: 1820:      MPInt lbCoeff = atIneq(lbPos, pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1821:      // Note that in the comments above, ubCoeff is the negation of the
        -: 1822:      // coefficient in the canonical form as the view taken here is that of the
        -: 1823:      // term being moved to the other size of '>='.
    #####: 1824:      MPInt ubCoeff = -atIneq(ubPos, pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1825:      // TODO: refactor this loop to avoid all branches inside.
    #####: 1826:      for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 never executed
branch  1 never executed
    #####: 1827:        if (l == pos)
branch  0 never executed
branch  1 never executed
    #####: 1828:          continue;
    #####: 1829:        assert(lbCoeff >= 1 && ubCoeff >= 1 && "bounds wrongly identified");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####: 1830:        MPInt lcm = presburger::lcm(lbCoeff, ubCoeff);
branch  0 never executed
branch  1 never executed
    #####: 1831:        ineq.push_back(atIneq(ubPos, l) * (lcm / ubCoeff) +
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 1832:                       atIneq(lbPos, l) * (lcm / lbCoeff));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1833:        assert(lcm > 0 && "lcm should be positive!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1834:        if (lcm != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1835:          allLCMsAreOne = false;
        -: 1836:      }
    #####: 1837:      if (darkShadow) {
branch  0 never executed
branch  1 never executed
        -: 1838:        // The dark shadow is a convex subset of the exact integer shadow. If
        -: 1839:        // there is a point here, it proves the existence of a solution.
    #####: 1840:        ineq[ineq.size() - 1] += lbCoeff * ubCoeff - lbCoeff - ubCoeff + 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
        -: 1841:      }
        -: 1842:      // TODO: we need to have a way to add inequalities in-place in
        -: 1843:      // IntegerRelation instead of creating and copying over.
    #####: 1844:      newRel.addInequality(ineq);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1845:    }
        -: 1846:  }
        -: 1847:
    #####: 1848:  LLVM_DEBUG(llvm::dbgs() << "FM isResultIntegerExact: " << allLCMsAreOne
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -: 1849:                          << "\n");
    #####: 1850:  if (allLCMsAreOne && isResultIntegerExact)
branch  0 never executed
branch  1 never executed
    #####: 1851:    *isResultIntegerExact = true;
        -: 1852:
        -: 1853:  // Copy over the constraints not involving this variable.
    #####: 1854:  for (auto nbPos : nbIndices) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1855:    SmallVector<MPInt, 4> ineq;
branch  0 never executed
branch  1 never executed
    #####: 1856:    ineq.reserve(getNumCols() - 1);
branch  0 never executed
branch  1 never executed
    #####: 1857:    for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 never executed
branch  1 never executed
    #####: 1858:      if (l == pos)
branch  0 never executed
branch  1 never executed
    #####: 1859:        continue;
    #####: 1860:      ineq.push_back(atIneq(nbPos, l));
call    0 never executed
call    1 never executed
        -: 1861:    }
    #####: 1862:    newRel.addInequality(ineq);
call    0 never executed
call    1 never executed
        -: 1863:  }
        -: 1864:
    #####: 1865:  assert(newRel.getNumConstraints() ==
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1866:         lbIndices.size() * ubIndices.size() + nbIndices.size());
        -: 1867:
        -: 1868:  // Copy over the equalities.
    #####: 1869:  for (unsigned r = 0, e = getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####: 1870:    SmallVector<MPInt, 4> eq;
call    0 never executed
    #####: 1871:    eq.reserve(newRel.getNumCols());
call    0 never executed
    #####: 1872:    for (unsigned l = 0, e = getNumCols(); l < e; l++) {
branch  0 never executed
branch  1 never executed
    #####: 1873:      if (l == pos)
branch  0 never executed
branch  1 never executed
    #####: 1874:        continue;
    #####: 1875:      eq.push_back(atEq(r, l));
call    0 never executed
call    1 never executed
        -: 1876:    }
    #####: 1877:    newRel.addEquality(eq);
call    0 never executed
call    1 never executed
        -: 1878:  }
        -: 1879:
        -: 1880:  // GCD tightening and normalization allows detection of more trivially
        -: 1881:  // redundant constraints.
    #####: 1882:  newRel.gcdTightenInequalities();
call    0 never executed
    #####: 1883:  newRel.normalizeConstraintsByGCD();
call    0 never executed
    #####: 1884:  newRel.removeTrivialRedundancy();
call    0 never executed
    #####: 1885:  clearAndCopyFrom(newRel);
call    0 never executed
    #####: 1886:  LLVM_DEBUG(llvm::dbgs() << "FM output:\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####: 1887:  LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1888:}
        -: 1889:
        -: 1890:#undef DEBUG_TYPE
        -: 1891:#define DEBUG_TYPE "presburger"
        -: 1892:
function _ZN4mlir10presburger15IntegerRelation10projectOutEjj called 0 returned 0% blocks executed 0%
    #####: 1893:void IntegerRelation::projectOut(unsigned pos, unsigned num) {
    #####: 1894:  if (num == 0)
branch  0 never executed
branch  1 never executed
        -: 1895:    return;
        -: 1896:
        -: 1897:  // 'pos' can be at most getNumCols() - 2 if num > 0.
    #####: 1898:  assert((getNumCols() < 2 || pos <= getNumCols() - 2) && "invalid position");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1899:  assert(pos + num < getNumCols() && "invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1900:
        -: 1901:  // Eliminate as many variables as possible using Gaussian elimination.
        -: 1902:  unsigned currentPos = pos;
        -: 1903:  unsigned numToEliminate = num;
        -: 1904:  unsigned numGaussianEliminated = 0;
        -: 1905:
    #####: 1906:  while (currentPos < getNumVars()) {
branch  0 never executed
branch  1 never executed
    #####: 1907:    unsigned curNumEliminated =
    #####: 1908:        gaussianEliminateVars(currentPos, currentPos + numToEliminate);
call    0 never executed
    #####: 1909:    ++currentPos;
    #####: 1910:    numToEliminate -= curNumEliminated + 1;
    #####: 1911:    numGaussianEliminated += curNumEliminated;
        -: 1912:  }
        -: 1913:
        -: 1914:  // Eliminate the remaining using Fourier-Motzkin.
    #####: 1915:  for (unsigned i = 0; i < num - numGaussianEliminated; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1916:    unsigned numToEliminate = num - numGaussianEliminated - i;
    #####: 1917:    fourierMotzkinEliminate(
call    0 never executed
    #####: 1918:        getBestVarToEliminate(*this, pos, pos + numToEliminate));
call    0 never executed
        -: 1919:  }
        -: 1920:
        -: 1921:  // Fast/trivial simplifications.
    #####: 1922:  gcdTightenInequalities();
call    0 never executed
        -: 1923:  // Normalize constraints after tightening since the latter impacts this, but
        -: 1924:  // not the other way round.
    #####: 1925:  normalizeConstraintsByGCD();
call    0 never executed
        -: 1926:}
        -: 1927:
        -: 1928:namespace {
        -: 1929:
        -: 1930:enum BoundCmpResult { Greater, Less, Equal, Unknown };
        -: 1931:
        -: 1932:/// Compares two affine bounds whose coefficients are provided in 'first' and
        -: 1933:/// 'second'. The last coefficient is the constant term.
function _ZN12_GLOBAL__N_1L13compareBoundsEN4llvm8ArrayRefIN4mlir10presburger5MPIntEEES5_ called 0 returned 0% blocks executed 0%
    #####: 1934:static BoundCmpResult compareBounds(ArrayRef<MPInt> a, ArrayRef<MPInt> b) {
    #####: 1935:  assert(a.size() == b.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1936:
        -: 1937:  // For the bounds to be comparable, their corresponding variable
        -: 1938:  // coefficients should be equal; the constant terms are then compared to
        -: 1939:  // determine less/greater/equal.
        -: 1940:
    #####: 1941:  if (!std::equal(a.begin(), a.end() - 1, b.begin()))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1942:    return Unknown;
        -: 1943:
    #####: 1944:  if (a.back() == b.back())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1945:    return Equal;
        -: 1946:
    #####: 1947:  return a.back() < b.back() ? Less : Greater;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1948:}
        -: 1949:} // namespace
        -: 1950:
        -: 1951:// Returns constraints that are common to both A & B.
function _ZL20getCommonConstraintsRKN4mlir10presburger15IntegerRelationES3_RS1_ called 0 returned 0% blocks executed 0%
    #####: 1952:static void getCommonConstraints(const IntegerRelation &a,
        -: 1953:                                 const IntegerRelation &b, IntegerRelation &c) {
    #####: 1954:  c = IntegerRelation(a.getSpace());
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1955:  // a naive O(n^2) check should be enough here given the input sizes.
    #####: 1956:  for (unsigned r = 0, e = a.getNumInequalities(); r < e; ++r) {
branch  0 never executed
branch  1 never executed
    #####: 1957:    for (unsigned s = 0, f = b.getNumInequalities(); s < f; ++s) {
branch  0 never executed
branch  1 never executed
    #####: 1958:      if (a.getInequality(r) == b.getInequality(s)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1959:        c.addInequality(a.getInequality(r));
call    0 never executed
    #####: 1960:        break;
call    0 never executed
        -: 1961:      }
        -: 1962:    }
        -: 1963:  }
    #####: 1964:  for (unsigned r = 0, e = a.getNumEqualities(); r < e; ++r) {
branch  0 never executed
branch  1 never executed
    #####: 1965:    for (unsigned s = 0, f = b.getNumEqualities(); s < f; ++s) {
branch  0 never executed
branch  1 never executed
    #####: 1966:      if (a.getEquality(r) == b.getEquality(s)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1967:        c.addEquality(a.getEquality(r));
call    0 never executed
    #####: 1968:        break;
call    0 never executed
        -: 1969:      }
        -: 1970:    }
        -: 1971:  }
    #####: 1972:}
        -: 1973:
        -: 1974:// Computes the bounding box with respect to 'other' by finding the min of the
        -: 1975:// lower bounds and the max of the upper bounds along each of the dimensions.
        -: 1976:LogicalResult
function _ZN4mlir10presburger15IntegerRelation16unionBoundingBoxERKS1_ called 0 returned 0% blocks executed 0%
    #####: 1977:IntegerRelation::unionBoundingBox(const IntegerRelation &otherCst) {
    #####: 1978:  assert(space.isEqual(otherCst.getSpace()) && "Spaces should match.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1979:  assert(getNumLocalVars() == 0 && "local ids not supported yet here");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1980:
        -: 1981:  // Get the constraints common to both systems; these will be added as is to
        -: 1982:  // the union.
    #####: 1983:  IntegerRelation commonCst(PresburgerSpace::getRelationSpace());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1984:  getCommonConstraints(*this, otherCst, commonCst);
call    0 never executed
        -: 1985:
    #####: 1986:  std::vector<SmallVector<MPInt, 8>> boundingLbs;
call    0 never executed
call    1 never executed
    #####: 1987:  std::vector<SmallVector<MPInt, 8>> boundingUbs;
call    0 never executed
    #####: 1988:  boundingLbs.reserve(2 * getNumDimVars());
call    0 never executed
    #####: 1989:  boundingUbs.reserve(2 * getNumDimVars());
call    0 never executed
        -: 1990:
        -: 1991:  // To hold lower and upper bounds for each dimension.
    #####: 1992:  SmallVector<MPInt, 4> lb, otherLb, ub, otherUb;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1993:  // To compute min of lower bounds and max of upper bounds for each dimension.
    #####: 1994:  SmallVector<MPInt, 4> minLb(getNumSymbolVars() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1995:  SmallVector<MPInt, 4> maxUb(getNumSymbolVars() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1996:  // To compute final new lower and upper bounds for the union.
    #####: 1997:  SmallVector<MPInt, 8> newLb(getNumCols()), newUb(getNumCols());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1998:
    #####: 1999:  MPInt lbFloorDivisor, otherLbFloorDivisor;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2000:  for (unsigned d = 0, e = getNumDimVars(); d < e; ++d) {
branch  0 never executed
branch  1 never executed
    #####: 2001:    auto extent = getConstantBoundOnDimSize(d, &lb, &lbFloorDivisor, &ub);
call    0 never executed
    #####: 2002:    if (!extent.has_value())
branch  0 never executed
branch  1 never executed
        -: 2003:      // TODO: symbolic extents when necessary.
        -: 2004:      // TODO: handle union if a dimension is unbounded.
    #####: 2005:      return failure();
        -: 2006:
    #####: 2007:    auto otherExtent = otherCst.getConstantBoundOnDimSize(
    #####: 2008:        d, &otherLb, &otherLbFloorDivisor, &otherUb);
call    0 never executed
call    1 never executed
    #####: 2009:    if (!otherExtent.has_value() || lbFloorDivisor != otherLbFloorDivisor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2010:      // TODO: symbolic extents when necessary.
    #####: 2011:      return failure();
call    0 never executed
call    1 never executed
        -: 2012:
    #####: 2013:    assert(lbFloorDivisor > 0 && "divisor always expected to be positive");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2014:
    #####: 2015:    auto res = compareBounds(lb, otherLb);
call    0 never executed
        -: 2016:    // Identify min.
    #####: 2017:    if (res == BoundCmpResult::Less || res == BoundCmpResult::Equal) {
branch  0 never executed
branch  1 never executed
    #####: 2018:      minLb = lb;
call    0 never executed
        -: 2019:      // Since the divisor is for a floordiv, we need to convert to ceildiv,
        -: 2020:      // i.e., i >= expr floordiv div <=> i >= (expr - div + 1) ceildiv div <=>
        -: 2021:      // div * i >= expr - div + 1.
    #####: 2022:      minLb.back() -= lbFloorDivisor - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 2023:    } else if (res == BoundCmpResult::Greater) {
branch  0 never executed
branch  1 never executed
    #####: 2024:      minLb = otherLb;
call    0 never executed
    #####: 2025:      minLb.back() -= otherLbFloorDivisor - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2026:    } else {
        -: 2027:      // Uncomparable - check for constant lower/upper bounds.
    #####: 2028:      auto constLb = getConstantBound(BoundType::LB, d);
call    0 never executed
    #####: 2029:      auto constOtherLb = otherCst.getConstantBound(BoundType::LB, d);
call    0 never executed
call    1 never executed
    #####: 2030:      if (!constLb.has_value() || !constOtherLb.has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2031:        return failure();
call    0 never executed
call    1 never executed
    #####: 2032:      std::fill(minLb.begin(), minLb.end(), 0);
call    0 never executed
    #####: 2033:      minLb.back() = std::min(constLb.value(), constOtherLb.value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2034:    }
        -: 2035:
        -: 2036:    // Do the same for ub's but max of upper bounds. Identify max.
    #####: 2037:    auto uRes = compareBounds(ub, otherUb);
call    0 never executed
    #####: 2038:    if (uRes == BoundCmpResult::Greater || uRes == BoundCmpResult::Equal) {
branch  0 never executed
branch  1 never executed
    #####: 2039:      maxUb = ub;
call    0 never executed
    #####: 2040:    } else if (uRes == BoundCmpResult::Less) {
branch  0 never executed
branch  1 never executed
    #####: 2041:      maxUb = otherUb;
call    0 never executed
        -: 2042:    } else {
        -: 2043:      // Uncomparable - check for constant lower/upper bounds.
    #####: 2044:      auto constUb = getConstantBound(BoundType::UB, d);
call    0 never executed
    #####: 2045:      auto constOtherUb = otherCst.getConstantBound(BoundType::UB, d);
call    0 never executed
call    1 never executed
    #####: 2046:      if (!constUb.has_value() || !constOtherUb.has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2047:        return failure();
call    0 never executed
call    1 never executed
    #####: 2048:      std::fill(maxUb.begin(), maxUb.end(), 0);
call    0 never executed
    #####: 2049:      maxUb.back() = std::max(constUb.value(), constOtherUb.value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
        -: 2050:    }
        -: 2051:
    #####: 2052:    std::fill(newLb.begin(), newLb.end(), 0);
call    0 never executed
    #####: 2053:    std::fill(newUb.begin(), newUb.end(), 0);
call    0 never executed
        -: 2054:
        -: 2055:    // The divisor for lb, ub, otherLb, otherUb at this point is lbDivisor,
        -: 2056:    // and so it's the divisor for newLb and newUb as well.
    #####: 2057:    newLb[d] = lbFloorDivisor;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2058:    newUb[d] = -lbFloorDivisor;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 2059:    // Copy over the symbolic part + constant term.
    #####: 2060:    std::copy(minLb.begin(), minLb.end(), newLb.begin() + getNumDimVars());
call    0 never executed
    #####: 2061:    std::transform(newLb.begin() + getNumDimVars(), newLb.end(),
    #####: 2062:                   newLb.begin() + getNumDimVars(), std::negate<MPInt>());
call    0 never executed
    #####: 2063:    std::copy(maxUb.begin(), maxUb.end(), newUb.begin() + getNumDimVars());
call    0 never executed
        -: 2064:
    #####: 2065:    boundingLbs.push_back(newLb);
call    0 never executed
    #####: 2066:    boundingUbs.push_back(newUb);
call    0 never executed
call    1 never executed
        -: 2067:  }
        -: 2068:
        -: 2069:  // Clear all constraints and add the lower/upper bounds for the bounding box.
    #####: 2070:  clearConstraints();
call    0 never executed
    #####: 2071:  for (unsigned d = 0, e = getNumDimVars(); d < e; ++d) {
branch  0 never executed
branch  1 never executed
    #####: 2072:    addInequality(boundingLbs[d]);
call    0 never executed
    #####: 2073:    addInequality(boundingUbs[d]);
call    0 never executed
        -: 2074:  }
        -: 2075:
        -: 2076:  // Add the constraints that were common to both systems.
    #####: 2077:  append(commonCst);
call    0 never executed
    #####: 2078:  removeTrivialRedundancy();
call    0 never executed
        -: 2079:
        -: 2080:  // TODO: copy over pure symbolic constraints from this and 'other' over to the
        -: 2081:  // union (since the above are just the union along dimensions); we shouldn't
        -: 2082:  // be discarding any other constraints on the symbols.
        -: 2083:
    #####: 2084:  return success();
branch  0 never executed
branch  1 never executed
        -: 2085:}
        -: 2086:
function _ZNK4mlir10presburger15IntegerRelation9isColZeroEj called 0 returned 0% blocks executed 0%
    #####: 2087:bool IntegerRelation::isColZero(unsigned pos) const {
    #####: 2088:  unsigned rowPos;
    #####: 2089:  return !findConstraintWithNonZeroAt(pos, /*isEq=*/false, &rowPos) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2090:         !findConstraintWithNonZeroAt(pos, /*isEq=*/true, &rowPos);
call    0 never executed
        -: 2091:}
        -: 2092:
        -: 2093:/// Find positions of inequalities and equalities that do not have a coefficient
        -: 2094:/// for [pos, pos + num) variables.
function _ZL25getIndependentConstraintsRKN4mlir10presburger15IntegerRelationEjjRN4llvm15SmallVectorImplIjEES7_ called 0 returned 0% blocks executed 0%
    #####: 2095:static void getIndependentConstraints(const IntegerRelation &cst, unsigned pos,
        -: 2096:                                      unsigned num,
        -: 2097:                                      SmallVectorImpl<unsigned> &nbIneqIndices,
        -: 2098:                                      SmallVectorImpl<unsigned> &nbEqIndices) {
    #####: 2099:  assert(pos < cst.getNumVars() && "invalid start position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2100:  assert(pos + num <= cst.getNumVars() && "invalid limit");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2101:
    #####: 2102:  for (unsigned r = 0, e = cst.getNumInequalities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 2103:    // The bounds are to be independent of [offset, offset + num) columns.
        -: 2104:    unsigned c;
    #####: 2105:    for (c = pos; c < pos + num; ++c) {
branch  0 never executed
branch  1 never executed
    #####: 2106:      if (cst.atIneq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2107:        break;
        -: 2108:    }
    #####: 2109:    if (c == pos + num)
branch  0 never executed
branch  1 never executed
    #####: 2110:      nbIneqIndices.push_back(r);
call    0 never executed
        -: 2111:  }
        -: 2112:
    #####: 2113:  for (unsigned r = 0, e = cst.getNumEqualities(); r < e; r++) {
branch  0 never executed
branch  1 never executed
        -: 2114:    // The bounds are to be independent of [offset, offset + num) columns.
        -: 2115:    unsigned c;
    #####: 2116:    for (c = pos; c < pos + num; ++c) {
branch  0 never executed
branch  1 never executed
    #####: 2117:      if (cst.atEq(r, c) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 2118:        break;
        -: 2119:    }
    #####: 2120:    if (c == pos + num)
branch  0 never executed
branch  1 never executed
    #####: 2121:      nbEqIndices.push_back(r);
call    0 never executed
        -: 2122:  }
    #####: 2123:}
        -: 2124:
function _ZN4mlir10presburger15IntegerRelation28removeIndependentConstraintsEjj called 0 returned 0% blocks executed 0%
    #####: 2125:void IntegerRelation::removeIndependentConstraints(unsigned pos, unsigned num) {
    #####: 2126:  assert(pos + num <= getNumVars() && "invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2127:
        -: 2128:  // Remove constraints that are independent of these variables.
    #####: 2129:  SmallVector<unsigned, 4> nbIneqIndices, nbEqIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2130:  getIndependentConstraints(*this, /*pos=*/0, num, nbIneqIndices, nbEqIndices);
call    0 never executed
        -: 2131:
        -: 2132:  // Iterate in reverse so that indices don't have to be updated.
        -: 2133:  // TODO: This method can be made more efficient (because removal of each
        -: 2134:  // inequality leads to much shifting/copying in the underlying buffer).
    #####: 2135:  for (auto nbIndex : llvm::reverse(nbIneqIndices))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2136:    removeInequality(nbIndex);
call    0 never executed
    #####: 2137:  for (auto nbIndex : llvm::reverse(nbEqIndices))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2138:    removeEquality(nbIndex);
call    0 never executed
    #####: 2139:}
        -: 2140:
function _ZNK4mlir10presburger15IntegerRelation12getDomainSetEv called 0 returned 0% blocks executed 0%
    #####: 2141:IntegerPolyhedron IntegerRelation::getDomainSet() const {
    #####: 2142:  IntegerRelation copyRel = *this;
call    0 never executed
call    1 never executed
        -: 2143:
        -: 2144:  // Convert Range variables to Local variables.
    #####: 2145:  copyRel.convertVarKind(VarKind::Range, 0, getNumVarKind(VarKind::Range),
call    0 never executed
call    1 never executed
        -: 2146:                         VarKind::Local);
        -: 2147:
        -: 2148:  // Convert Domain variables to SetDim(Range) variables.
    #####: 2149:  copyRel.convertVarKind(VarKind::Domain, 0, getNumVarKind(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2150:                         VarKind::SetDim);
        -: 2151:
    #####: 2152:  return IntegerPolyhedron(std::move(copyRel));
call    0 never executed
        -: 2153:}
        -: 2154:
function _ZNK4mlir10presburger15IntegerRelation11getRangeSetEv called 0 returned 0% blocks executed 0%
    #####: 2155:IntegerPolyhedron IntegerRelation::getRangeSet() const {
    #####: 2156:  IntegerRelation copyRel = *this;
call    0 never executed
call    1 never executed
        -: 2157:
        -: 2158:  // Convert Domain variables to Local variables.
    #####: 2159:  copyRel.convertVarKind(VarKind::Domain, 0, getNumVarKind(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2160:                         VarKind::Local);
        -: 2161:
        -: 2162:  // We do not need to do anything to Range variables since they are already in
        -: 2163:  // SetDim position.
        -: 2164:
    #####: 2165:  return IntegerPolyhedron(std::move(copyRel));
call    0 never executed
        -: 2166:}
        -: 2167:
function _ZN4mlir10presburger15IntegerRelation15intersectDomainERKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####: 2168:void IntegerRelation::intersectDomain(const IntegerPolyhedron &poly) {
    #####: 2169:  assert(getDomainSet().getSpace().isCompatible(poly.getSpace()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2170:         "Domain set is not compatible with poly");
        -: 2171:
        -: 2172:  // Treating the poly as a relation, convert it from `0 -> R` to `R -> 0`.
    #####: 2173:  IntegerRelation rel = poly;
call    0 never executed
call    1 never executed
    #####: 2174:  rel.inverse();
call    0 never executed
        -: 2175:
        -: 2176:  // Append dummy range variables to make the spaces compatible.
    #####: 2177:  rel.appendVar(VarKind::Range, getNumRangeVars());
call    0 never executed
        -: 2178:
        -: 2179:  // Intersect in place.
    #####: 2180:  mergeLocalVars(rel);
call    0 never executed
    #####: 2181:  append(rel);
call    0 never executed
    #####: 2182:}
        -: 2183:
function _ZN4mlir10presburger15IntegerRelation14intersectRangeERKNS0_17IntegerPolyhedronE called 0 returned 0% blocks executed 0%
    #####: 2184:void IntegerRelation::intersectRange(const IntegerPolyhedron &poly) {
    #####: 2185:  assert(getRangeSet().getSpace().isCompatible(poly.getSpace()) &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2186:         "Range set is not compatible with poly");
        -: 2187:
    #####: 2188:  IntegerRelation rel = poly;
call    0 never executed
call    1 never executed
        -: 2189:
        -: 2190:  // Append dummy domain variables to make the spaces compatible.
    #####: 2191:  rel.appendVar(VarKind::Domain, getNumDomainVars());
call    0 never executed
        -: 2192:
    #####: 2193:  mergeLocalVars(rel);
call    0 never executed
    #####: 2194:  append(rel);
call    0 never executed
    #####: 2195:}
        -: 2196:
function _ZN4mlir10presburger15IntegerRelation7inverseEv called 0 returned 0% blocks executed 0%
    #####: 2197:void IntegerRelation::inverse() {
    #####: 2198:  unsigned numRangeVars = getNumVarKind(VarKind::Range);
call    0 never executed
    #####: 2199:  convertVarKind(VarKind::Domain, 0, getVarKindEnd(VarKind::Domain),
call    0 never executed
call    1 never executed
        -: 2200:                 VarKind::Range);
    #####: 2201:  convertVarKind(VarKind::Range, 0, numRangeVars, VarKind::Domain);
call    0 never executed
    #####: 2202:}
        -: 2203:
function _ZN4mlir10presburger15IntegerRelation7composeERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2204:void IntegerRelation::compose(const IntegerRelation &rel) {
    #####: 2205:  assert(getRangeSet().getSpace().isCompatible(rel.getDomainSet().getSpace()) &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 2206:         "Range of `this` should be compatible with Domain of `rel`");
        -: 2207:
    #####: 2208:  IntegerRelation copyRel = rel;
call    0 never executed
call    1 never executed
        -: 2209:
        -: 2210:  // Let relation `this` be R1: A -> B, and `rel` be R2: B -> C.
        -: 2211:  // We convert R1 to A -> (B X C), and R2 to B X C then intersect the range of
        -: 2212:  // R1 with R2. After this, we get R1: A -> C, by projecting out B.
        -: 2213:  // TODO: Using nested spaces here would help, since we could directly
        -: 2214:  // intersect the range with another relation.
    #####: 2215:  unsigned numBVars = getNumRangeVars();
call    0 never executed
        -: 2216:
        -: 2217:  // Convert R1 from A -> B to A -> (B X C).
    #####: 2218:  appendVar(VarKind::Range, copyRel.getNumRangeVars());
call    0 never executed
        -: 2219:
        -: 2220:  // Convert R2 to B X C.
    #####: 2221:  copyRel.convertVarKind(VarKind::Domain, 0, numBVars, VarKind::Range, 0);
call    0 never executed
        -: 2222:
        -: 2223:  // Intersect R2 to range of R1.
    #####: 2224:  intersectRange(IntegerPolyhedron(copyRel));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2225:
        -: 2226:  // Project out B in R1.
    #####: 2227:  convertVarKind(VarKind::Range, 0, numBVars, VarKind::Local);
call    0 never executed
    #####: 2228:}
        -: 2229:
function _ZN4mlir10presburger15IntegerRelation11applyDomainERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2230:void IntegerRelation::applyDomain(const IntegerRelation &rel) {
    #####: 2231:  inverse();
call    0 never executed
    #####: 2232:  compose(rel);
call    0 never executed
    #####: 2233:  inverse();
call    0 never executed
    #####: 2234:}
        -: 2235:
function _ZN4mlir10presburger15IntegerRelation10applyRangeERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2236:void IntegerRelation::applyRange(const IntegerRelation &rel) { compose(rel); }
call    0 never executed
        -: 2237:
function _ZNK4mlir10presburger15IntegerRelation10printSpaceERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 2238:void IntegerRelation::printSpace(raw_ostream &os) const {
    #####: 2239:  space.print(os);
call    0 never executed
    #####: 2240:  os << getNumConstraints() << " constraints\n";
call    0 never executed
call    1 never executed
    #####: 2241:}
        -: 2242:
function _ZNK4mlir10presburger15IntegerRelation5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 2243:void IntegerRelation::print(raw_ostream &os) const {
    #####: 2244:  assert(hasConsistentState());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2245:  printSpace(os);
call    0 never executed
    #####: 2246:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2247:    for (unsigned j = 0, f = getNumCols(); j < f; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 2248:      os << atEq(i, j) << " ";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2249:    }
    #####: 2250:    os << "= 0\n";
call    0 never executed
        -: 2251:  }
    #####: 2252:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 2253:    for (unsigned j = 0, f = getNumCols(); j < f; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 2254:      os << atIneq(i, j) << " ";
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2255:    }
    #####: 2256:    os << ">= 0\n";
call    0 never executed
        -: 2257:  }
    #####: 2258:  os << '\n';
branch  0 never executed
branch  1 never executed
    #####: 2259:}
        -: 2260:
function _ZNK4mlir10presburger15IntegerRelation4dumpEv called 0 returned 0% blocks executed 0%
    #####: 2261:void IntegerRelation::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 2262:
function _ZN4mlir10presburger17IntegerPolyhedron9insertVarENS0_7VarKindEjj called 0 returned 0% blocks executed 0%
    #####: 2263:unsigned IntegerPolyhedron::insertVar(VarKind kind, unsigned pos,
        -: 2264:                                      unsigned num) {
    #####: 2265:  assert((kind != VarKind::Domain || num == 0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2266:         "Domain has to be zero in a set");
    #####: 2267:  return IntegerRelation::insertVar(kind, pos, num);
call    0 never executed
        -: 2268:}
        -: 2269:IntegerPolyhedron
function _ZNK4mlir10presburger17IntegerPolyhedron9intersectERKS1_ called 0 returned 0% blocks executed 0%
    #####: 2270:IntegerPolyhedron::intersect(const IntegerPolyhedron &other) const {
    #####: 2271:  return IntegerPolyhedron(IntegerRelation::intersect(other));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 2272:}
        -: 2273:
function _ZNK4mlir10presburger17IntegerPolyhedron8subtractERKNS0_13PresburgerSetE called 0 returned 0% blocks executed 0%
    #####: 2274:PresburgerSet IntegerPolyhedron::subtract(const PresburgerSet &other) const {
    #####: 2275:  return PresburgerSet(IntegerRelation::subtract(other));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2276:}
