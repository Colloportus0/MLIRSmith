        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/include/mlir/IR/BuiltinAttributes.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:325580
        -:    1://===- BuiltinAttributes.h - MLIR Builtin Attribute Classes -----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef MLIR_IR_BUILTINATTRIBUTES_H
        -:   10:#define MLIR_IR_BUILTINATTRIBUTES_H
        -:   11:
        -:   12:#include "mlir/IR/BuiltinAttributeInterfaces.h"
        -:   13:#include "mlir/IR/SubElementInterfaces.h"
        -:   14:#include "llvm/ADT/APFloat.h"
        -:   15:#include "llvm/ADT/Sequence.h"
        -:   16:#include <complex>
        -:   17:
        -:   18:namespace mlir {
        -:   19:class AffineMap;
        -:   20:class AsmResourceBlob;
        -:   21:class BoolAttr;
        -:   22:class BuiltinDialect;
        -:   23:class DenseIntElementsAttr;
        -:   24:template <typename T>
        -:   25:struct DialectResourceBlobHandle;
        -:   26:class FlatSymbolRefAttr;
        -:   27:class FunctionType;
        -:   28:class IntegerSet;
        -:   29:class IntegerType;
        -:   30:class Location;
        -:   31:class Operation;
        -:   32:class RankedTensorType;
        -:   33:
        -:   34://===----------------------------------------------------------------------===//
        -:   35:// Elements Attributes
        -:   36://===----------------------------------------------------------------------===//
        -:   37:
        -:   38:namespace detail {
        -:   39:/// Pair of raw pointer and a boolean flag of whether the pointer holds a splat,
        -:   40:using DenseIterPtrAndSplat = std::pair<const char *, bool>;
        -:   41:
        -:   42:/// Impl iterator for indexed DenseElementsAttr iterators that records a data
        -:   43:/// pointer and data index that is adjusted for the case of a splat attribute.
        -:   44:template <typename ConcreteT, typename T, typename PointerT = T *,
        -:   45:          typename ReferenceT = T &>
    #####:   46:class DenseElementIndexedIteratorImpl
        -:   47:    : public llvm::indexed_accessor_iterator<ConcreteT, DenseIterPtrAndSplat, T,
        -:   48:                                             PointerT, ReferenceT> {
        -:   49:protected:
        -:   50:  DenseElementIndexedIteratorImpl(const char *data, bool isSplat,
        -:   51:                                  size_t dataIndex)
        -:   52:      : llvm::indexed_accessor_iterator<ConcreteT, DenseIterPtrAndSplat, T,
        -:   53:                                        PointerT, ReferenceT>({data, isSplat},
        -:   54:                                                              dataIndex) {}
        -:   55:
        -:   56:  /// Return the current index for this iterator, adjusted for the case of a
        -:   57:  /// splat.
        -:   58:  ptrdiff_t getDataIndex() const {
        -:   59:    bool isSplat = this->base.second;
        -:   60:    return isSplat ? 0 : this->index;
        -:   61:  }
        -:   62:
        -:   63:  /// Return the data base pointer.
        -:   64:  const char *getData() const { return this->base.first; }
        -:   65:};
        -:   66:
        -:   67:/// Type trait detector that checks if a given type T is a complex type.
        -:   68:template <typename T>
        -:   69:struct is_complex_t : public std::false_type {};
        -:   70:template <typename T>
        -:   71:struct is_complex_t<std::complex<T>> : public std::true_type {};
        -:   72:} // namespace detail
        -:   73:
        -:   74:/// An attribute that represents a reference to a dense vector or tensor
        -:   75:/// object.
        -:   76:class DenseElementsAttr : public Attribute {
        -:   77:public:
    #####:   78:  using Attribute::Attribute;
        -:   79:
        -:   80:  /// Allow implicit conversion to ElementsAttr.
        -:   81:  operator ElementsAttr() const {
        -:   82:    return *this ? cast<ElementsAttr>() : nullptr;
        -:   83:  }
        -:   84:
        -:   85:  /// Type trait used to check if the given type T is a potentially valid C++
        -:   86:  /// floating point type that can be used to access the underlying element
        -:   87:  /// types of a DenseElementsAttr.
        -:   88:  template <typename T>
        -:   89:  struct is_valid_cpp_fp_type {
        -:   90:    /// The type is a valid floating point type if it is a builtin floating
        -:   91:    /// point type, or is a potentially user defined floating point type. The
        -:   92:    /// latter allows for supporting users that have custom types defined for
        -:   93:    /// bfloat16/half/etc.
        -:   94:    static constexpr bool value = llvm::is_one_of<T, float, double>::value ||
        -:   95:                                  (std::numeric_limits<T>::is_specialized &&
        -:   96:                                   !std::numeric_limits<T>::is_integer);
        -:   97:  };
        -:   98:
        -:   99:  /// Method for support type inquiry through isa, cast and dyn_cast.
        -:  100:  static bool classof(Attribute attr);
        -:  101:
        -:  102:  /// Constructs a dense elements attribute from an array of element values.
        -:  103:  /// Each element attribute value is expected to be an element of 'type'.
        -:  104:  /// 'type' must be a vector or tensor with static shape. If the element of
        -:  105:  /// `type` is non-integer/index/float it is assumed to be a string type.
        -:  106:  static DenseElementsAttr get(ShapedType type, ArrayRef<Attribute> values);
        -:  107:
        -:  108:  /// Constructs a dense integer elements attribute from an array of integer
        -:  109:  /// or floating-point values. Each value is expected to be the same bitwidth
        -:  110:  /// of the element type of 'type'. 'type' must be a vector or tensor with
        -:  111:  /// static shape.
        -:  112:  template <typename T,
        -:  113:            typename = std::enable_if_t<std::numeric_limits<T>::is_integer ||
        -:  114:                                        is_valid_cpp_fp_type<T>::value>>
        -:  115:  static DenseElementsAttr get(const ShapedType &type, ArrayRef<T> values) {
        -:  116:    const char *data = reinterpret_cast<const char *>(values.data());
        -:  117:    return getRawIntOrFloat(
        -:  118:        type, ArrayRef<char>(data, values.size() * sizeof(T)), sizeof(T),
        -:  119:        std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed);
        -:  120:  }
        -:  121:
        -:  122:  /// Constructs a dense integer elements attribute from a single element.
        -:  123:  template <typename T,
        -:  124:            typename = std::enable_if_t<std::numeric_limits<T>::is_integer ||
        -:  125:                                        is_valid_cpp_fp_type<T>::value ||
        -:  126:                                        detail::is_complex_t<T>::value>>
        -:  127:  static DenseElementsAttr get(const ShapedType &type, T value) {
        -:  128:    return get(type, llvm::makeArrayRef(value));
        -:  129:  }
        -:  130:
        -:  131:  /// Constructs a dense complex elements attribute from an array of complex
        -:  132:  /// values. Each value is expected to be the same bitwidth of the element type
        -:  133:  /// of 'type'. 'type' must be a vector or tensor with static shape.
        -:  134:  template <
        -:  135:      typename T, typename ElementT = typename T::value_type,
        -:  136:      typename = std::enable_if_t<detail::is_complex_t<T>::value &&
        -:  137:                                  (std::numeric_limits<ElementT>::is_integer ||
        -:  138:                                   is_valid_cpp_fp_type<ElementT>::value)>>
        -:  139:  static DenseElementsAttr get(const ShapedType &type, ArrayRef<T> values) {
        -:  140:    const char *data = reinterpret_cast<const char *>(values.data());
        -:  141:    return getRawComplex(type, ArrayRef<char>(data, values.size() * sizeof(T)),
        -:  142:                         sizeof(T), std::numeric_limits<ElementT>::is_integer,
        -:  143:                         std::numeric_limits<ElementT>::is_signed);
        -:  144:  }
        -:  145:
        -:  146:  /// Overload of the above 'get' method that is specialized for boolean values.
        -:  147:  static DenseElementsAttr get(ShapedType type, ArrayRef<bool> values);
        -:  148:
        -:  149:  /// Overload of the above 'get' method that is specialized for StringRef
        -:  150:  /// values.
        -:  151:  static DenseElementsAttr get(ShapedType type, ArrayRef<StringRef> values);
        -:  152:
        -:  153:  /// Constructs a dense integer elements attribute from an array of APInt
        -:  154:  /// values. Each APInt value is expected to have the same bitwidth as the
        -:  155:  /// element type of 'type'. 'type' must be a vector or tensor with static
        -:  156:  /// shape.
        -:  157:  static DenseElementsAttr get(ShapedType type, ArrayRef<APInt> values);
        -:  158:
        -:  159:  /// Constructs a dense complex elements attribute from an array of APInt
        -:  160:  /// values. Each APInt value is expected to have the same bitwidth as the
        -:  161:  /// element type of 'type'. 'type' must be a vector or tensor with static
        -:  162:  /// shape.
        -:  163:  static DenseElementsAttr get(ShapedType type,
        -:  164:                               ArrayRef<std::complex<APInt>> values);
        -:  165:
        -:  166:  /// Constructs a dense float elements attribute from an array of APFloat
        -:  167:  /// values. Each APFloat value is expected to have the same bitwidth as the
        -:  168:  /// element type of 'type'. 'type' must be a vector or tensor with static
        -:  169:  /// shape.
        -:  170:  static DenseElementsAttr get(ShapedType type, ArrayRef<APFloat> values);
        -:  171:
        -:  172:  /// Constructs a dense complex elements attribute from an array of APFloat
        -:  173:  /// values. Each APFloat value is expected to have the same bitwidth as the
        -:  174:  /// element type of 'type'. 'type' must be a vector or tensor with static
        -:  175:  /// shape.
        -:  176:  static DenseElementsAttr get(ShapedType type,
        -:  177:                               ArrayRef<std::complex<APFloat>> values);
        -:  178:
        -:  179:  /// Construct a dense elements attribute for an initializer_list of values.
        -:  180:  /// Each value is expected to be the same bitwidth of the element type of
        -:  181:  /// 'type'. 'type' must be a vector or tensor with static shape.
        -:  182:  template <typename T>
        -:  183:  static DenseElementsAttr get(const ShapedType &type,
        -:  184:                               const std::initializer_list<T> &list) {
        -:  185:    return get(type, ArrayRef<T>(list));
        -:  186:  }
        -:  187:
        -:  188:  /// Construct a dense elements attribute from a raw buffer representing the
        -:  189:  /// data for this attribute. Users are encouraged to use one of the
        -:  190:  /// constructors above, which provide more safeties. However, this
        -:  191:  /// constructor is useful for tools which may want to interop and can
        -:  192:  /// follow the precise definition.
        -:  193:  ///
        -:  194:  /// The format of the raw buffer is a densely packed array of values that
        -:  195:  /// can be bitcast to the storage format of the element type specified.
        -:  196:  /// Types that are not byte aligned will be:
        -:  197:  ///   - For bitwidth > 1: Rounded up to the next byte.
        -:  198:  ///   - For bitwidth = 1: Packed into 8bit bytes with bits corresponding to
        -:  199:  ///     the linear order of the shape type from MSB to LSB, padded to on the
        -:  200:  ///     right.
        -:  201:  static DenseElementsAttr getFromRawBuffer(ShapedType type,
        -:  202:                                            ArrayRef<char> rawBuffer);
        -:  203:
        -:  204:  /// Returns true if the given buffer is a valid raw buffer for the given type.
        -:  205:  /// `detectedSplat` is set if the buffer is valid and represents a splat
        -:  206:  /// buffer. The definition may be expanded over time, but currently, a
        -:  207:  /// splat buffer is detected if:
        -:  208:  ///   - For >1bit: The buffer consists of a single element.
        -:  209:  ///   - For 1bit: The buffer consists of a single byte with value 0 or 255.
        -:  210:  ///
        -:  211:  /// User code should be prepared for additional, conformant patterns to be
        -:  212:  /// identified as splats in the future.
        -:  213:  static bool isValidRawBuffer(ShapedType type, ArrayRef<char> rawBuffer,
        -:  214:                               bool &detectedSplat);
        -:  215:
        -:  216:  //===--------------------------------------------------------------------===//
        -:  217:  // Iterators
        -:  218:  //===--------------------------------------------------------------------===//
        -:  219:
        -:  220:  /// The iterator range over the given iterator type T.
        -:  221:  template <typename IteratorT>
        -:  222:  using iterator_range_impl = detail::ElementsAttrRange<IteratorT>;
        -:  223:
        -:  224:  /// The iterator for the given element type T.
        -:  225:  template <typename T, typename AttrT = DenseElementsAttr>
        -:  226:  using iterator = decltype(std::declval<AttrT>().template value_begin<T>());
        -:  227:  /// The iterator range over the given element T.
        -:  228:  template <typename T, typename AttrT = DenseElementsAttr>
        -:  229:  using iterator_range =
        -:  230:      decltype(std::declval<AttrT>().template getValues<T>());
        -:  231:
        -:  232:  /// A utility iterator that allows walking over the internal Attribute values
        -:  233:  /// of a DenseElementsAttr.
        -:  234:  class AttributeElementIterator
        -:  235:      : public llvm::indexed_accessor_iterator<AttributeElementIterator,
        -:  236:                                               const void *, Attribute,
        -:  237:                                               Attribute, Attribute> {
        -:  238:  public:
        -:  239:    /// Accesses the Attribute value at this iterator position.
        -:  240:    Attribute operator*() const;
        -:  241:
        -:  242:  private:
        -:  243:    friend DenseElementsAttr;
        -:  244:
        -:  245:    /// Constructs a new iterator.
        -:  246:    AttributeElementIterator(DenseElementsAttr attr, size_t index);
        -:  247:  };
        -:  248:
        -:  249:  /// Iterator for walking raw element values of the specified type 'T', which
        -:  250:  /// may be any c++ data type matching the stored representation: int32_t,
        -:  251:  /// float, etc.
        -:  252:  template <typename T>
        -:  253:  class ElementIterator
        -:  254:      : public detail::DenseElementIndexedIteratorImpl<ElementIterator<T>,
        -:  255:                                                       const T> {
        -:  256:  public:
        -:  257:    /// Accesses the raw value at this iterator position.
        -:  258:    const T &operator*() const {
        -:  259:      return reinterpret_cast<const T *>(this->getData())[this->getDataIndex()];
        -:  260:    }
        -:  261:
        -:  262:  private:
        -:  263:    friend DenseElementsAttr;
        -:  264:
        -:  265:    /// Constructs a new iterator.
        -:  266:    ElementIterator(const char *data, bool isSplat, size_t dataIndex)
        -:  267:        : detail::DenseElementIndexedIteratorImpl<ElementIterator<T>, const T>(
        -:  268:              data, isSplat, dataIndex) {}
        -:  269:  };
        -:  270:
        -:  271:  /// A utility iterator that allows walking over the internal bool values.
        -:  272:  class BoolElementIterator
        -:  273:      : public detail::DenseElementIndexedIteratorImpl<BoolElementIterator,
        -:  274:                                                       bool, bool, bool> {
        -:  275:  public:
        -:  276:    /// Accesses the bool value at this iterator position.
        -:  277:    bool operator*() const;
        -:  278:
        -:  279:  private:
        -:  280:    friend DenseElementsAttr;
        -:  281:
        -:  282:    /// Constructs a new iterator.
        -:  283:    BoolElementIterator(DenseElementsAttr attr, size_t dataIndex);
        -:  284:  };
        -:  285:
        -:  286:  /// A utility iterator that allows walking over the internal raw APInt values.
    #####:  287:  class IntElementIterator
        -:  288:      : public detail::DenseElementIndexedIteratorImpl<IntElementIterator,
        -:  289:                                                       APInt, APInt, APInt> {
        -:  290:  public:
        -:  291:    /// Accesses the raw APInt value at this iterator position.
        -:  292:    APInt operator*() const;
        -:  293:
        -:  294:  private:
        -:  295:    friend DenseElementsAttr;
        -:  296:
        -:  297:    /// Constructs a new iterator.
        -:  298:    IntElementIterator(DenseElementsAttr attr, size_t dataIndex);
        -:  299:
        -:  300:    /// The bitwidth of the element type.
        -:  301:    size_t bitWidth;
        -:  302:  };
        -:  303:
        -:  304:  /// A utility iterator that allows walking over the internal raw complex APInt
        -:  305:  /// values.
        -:  306:  class ComplexIntElementIterator
        -:  307:      : public detail::DenseElementIndexedIteratorImpl<
        -:  308:            ComplexIntElementIterator, std::complex<APInt>, std::complex<APInt>,
        -:  309:            std::complex<APInt>> {
        -:  310:  public:
        -:  311:    /// Accesses the raw std::complex<APInt> value at this iterator position.
        -:  312:    std::complex<APInt> operator*() const;
        -:  313:
        -:  314:  private:
        -:  315:    friend DenseElementsAttr;
        -:  316:
        -:  317:    /// Constructs a new iterator.
        -:  318:    ComplexIntElementIterator(DenseElementsAttr attr, size_t dataIndex);
        -:  319:
        -:  320:    /// The bitwidth of the element type.
        -:  321:    size_t bitWidth;
        -:  322:  };
        -:  323:
        -:  324:  /// Iterator for walking over APFloat values.
        -:  325:  class FloatElementIterator final
        -:  326:      : public llvm::mapped_iterator_base<FloatElementIterator,
        -:  327:                                          IntElementIterator, APFloat> {
        -:  328:  public:
        -:  329:    /// Map the element to the iterator result type.
        -:  330:    APFloat mapElement(const APInt &value) const {
        -:  331:      return APFloat(*smt, value);
        -:  332:    }
        -:  333:
        -:  334:  private:
        -:  335:    friend DenseElementsAttr;
        -:  336:
        -:  337:    /// Initializes the float element iterator to the specified iterator.
        -:  338:    FloatElementIterator(const llvm::fltSemantics &smt, IntElementIterator it)
        -:  339:        : BaseT(it), smt(&smt) {}
        -:  340:
        -:  341:    /// The float semantics to use when constructing the APFloat.
        -:  342:    const llvm::fltSemantics *smt;
        -:  343:  };
        -:  344:
        -:  345:  /// Iterator for walking over complex APFloat values.
        -:  346:  class ComplexFloatElementIterator final
        -:  347:      : public llvm::mapped_iterator_base<ComplexFloatElementIterator,
        -:  348:                                          ComplexIntElementIterator,
        -:  349:                                          std::complex<APFloat>> {
        -:  350:  public:
        -:  351:    /// Map the element to the iterator result type.
        -:  352:    std::complex<APFloat> mapElement(const std::complex<APInt> &value) const {
        -:  353:      return {APFloat(*smt, value.real()), APFloat(*smt, value.imag())};
        -:  354:    }
        -:  355:
        -:  356:  private:
        -:  357:    friend DenseElementsAttr;
        -:  358:
        -:  359:    /// Initializes the float element iterator to the specified iterator.
        -:  360:    ComplexFloatElementIterator(const llvm::fltSemantics &smt,
        -:  361:                                ComplexIntElementIterator it)
        -:  362:        : BaseT(it), smt(&smt) {}
        -:  363:
        -:  364:    /// The float semantics to use when constructing the APFloat.
        -:  365:    const llvm::fltSemantics *smt;
        -:  366:  };
        -:  367:
        -:  368:  //===--------------------------------------------------------------------===//
        -:  369:  // Value Querying
        -:  370:  //===--------------------------------------------------------------------===//
        -:  371:
        -:  372:  /// Returns true if this attribute corresponds to a splat, i.e. if all element
        -:  373:  /// values are the same.
        -:  374:  bool isSplat() const;
        -:  375:
        -:  376:  /// Return the splat value for this attribute. This asserts that the attribute
        -:  377:  /// corresponds to a splat.
        -:  378:  template <typename T>
        -:  379:  std::enable_if_t<!std::is_base_of<Attribute, T>::value ||
        -:  380:                       std::is_same<Attribute, T>::value,
        -:  381:                   T>
        -:  382:  getSplatValue() const {
        -:  383:    assert(isSplat() && "expected the attribute to be a splat");
        -:  384:    return *value_begin<T>();
        -:  385:  }
        -:  386:  /// Return the splat value for derived attribute element types.
        -:  387:  template <typename T>
        -:  388:  std::enable_if_t<std::is_base_of<Attribute, T>::value &&
        -:  389:                       !std::is_same<Attribute, T>::value,
        -:  390:                   T>
        -:  391:  getSplatValue() const {
        -:  392:    return getSplatValue<Attribute>().template cast<T>();
        -:  393:  }
        -:  394:
        -:  395:  /// Try to get an iterator of the given type to the start of the held element
        -:  396:  /// values. Return failure if the type cannot be iterated.
        -:  397:  template <typename T>
        -:  398:  auto try_value_begin() const {
        -:  399:    auto range = tryGetValues<T>();
        -:  400:    using iterator = decltype(range->begin());
        -:  401:    return failed(range) ? FailureOr<iterator>(failure()) : range->begin();
        -:  402:  }
        -:  403:
        -:  404:  /// Try to get an iterator of the given type to the end of the held element
        -:  405:  /// values. Return failure if the type cannot be iterated.
        -:  406:  template <typename T>
        -:  407:  auto try_value_end() const {
        -:  408:    auto range = tryGetValues<T>();
        -:  409:    using iterator = decltype(range->begin());
        -:  410:    return failed(range) ? FailureOr<iterator>(failure()) : range->end();
        -:  411:  }
        -:  412:
        -:  413:  /// Return the held element values as a range of the given type.
        -:  414:  template <typename T>
        -:  415:  auto getValues() const {
        -:  416:    auto range = tryGetValues<T>();
        -:  417:    assert(succeeded(range) && "element type cannot be iterated");
        -:  418:    return std::move(*range);
        -:  419:  }
        -:  420:
        -:  421:  /// Get an iterator of the given type to the start of the held element values.
        -:  422:  template <typename T>
        -:  423:  auto value_begin() const {
        -:  424:    return getValues<T>().begin();
        -:  425:  }
        -:  426:
        -:  427:  /// Get an iterator of the given type to the end of the held element values.
        -:  428:  template <typename T>
        -:  429:  auto value_end() const {
        -:  430:    return getValues<T>().end();
        -:  431:  }
        -:  432:
        -:  433:  /// Try to get the held element values as a range of integer or floating-point
        -:  434:  /// values.
        -:  435:  template <typename T>
        -:  436:  using IntFloatValueTemplateCheckT =
        -:  437:      std::enable_if_t<(!std::is_same<T, bool>::value &&
        -:  438:                        std::numeric_limits<T>::is_integer) ||
        -:  439:                       is_valid_cpp_fp_type<T>::value>;
        -:  440:  template <typename T, typename = IntFloatValueTemplateCheckT<T>>
        -:  441:  FailureOr<iterator_range_impl<ElementIterator<T>>> tryGetValues() const {
        -:  442:    if (!isValidIntOrFloat(sizeof(T), std::numeric_limits<T>::is_integer,
        -:  443:                           std::numeric_limits<T>::is_signed))
        -:  444:      return failure();
        -:  445:    const char *rawData = getRawData().data();
        -:  446:    bool splat = isSplat();
        -:  447:    return iterator_range_impl<ElementIterator<T>>(
        -:  448:        getType(), ElementIterator<T>(rawData, splat, 0),
        -:  449:        ElementIterator<T>(rawData, splat, getNumElements()));
        -:  450:  }
        -:  451:
        -:  452:  /// Try to get the held element values as a range of std::complex.
        -:  453:  template <typename T, typename ElementT>
        -:  454:  using ComplexValueTemplateCheckT =
        -:  455:      std::enable_if_t<detail::is_complex_t<T>::value &&
        -:  456:                       (std::numeric_limits<ElementT>::is_integer ||
        -:  457:                        is_valid_cpp_fp_type<ElementT>::value)>;
        -:  458:  template <typename T, typename ElementT = typename T::value_type,
        -:  459:            typename = ComplexValueTemplateCheckT<T, ElementT>>
        -:  460:  FailureOr<iterator_range_impl<ElementIterator<T>>> tryGetValues() const {
        -:  461:    if (!isValidComplex(sizeof(T), std::numeric_limits<ElementT>::is_integer,
        -:  462:                        std::numeric_limits<ElementT>::is_signed))
        -:  463:      return failure();
        -:  464:    const char *rawData = getRawData().data();
        -:  465:    bool splat = isSplat();
        -:  466:    return iterator_range_impl<ElementIterator<T>>(
        -:  467:        getType(), ElementIterator<T>(rawData, splat, 0),
        -:  468:        ElementIterator<T>(rawData, splat, getNumElements()));
        -:  469:  }
        -:  470:
        -:  471:  /// Try to get the held element values as a range of StringRef.
        -:  472:  template <typename T>
        -:  473:  using StringRefValueTemplateCheckT =
        -:  474:      std::enable_if_t<std::is_same<T, StringRef>::value>;
        -:  475:  template <typename T, typename = StringRefValueTemplateCheckT<T>>
        -:  476:  FailureOr<iterator_range_impl<ElementIterator<StringRef>>>
        -:  477:  tryGetValues() const {
        -:  478:    auto stringRefs = getRawStringData();
        -:  479:    const char *ptr = reinterpret_cast<const char *>(stringRefs.data());
        -:  480:    bool splat = isSplat();
        -:  481:    return iterator_range_impl<ElementIterator<StringRef>>(
        -:  482:        getType(), ElementIterator<StringRef>(ptr, splat, 0),
        -:  483:        ElementIterator<StringRef>(ptr, splat, getNumElements()));
        -:  484:  }
        -:  485:
        -:  486:  /// Try to get the held element values as a range of Attributes.
        -:  487:  template <typename T>
        -:  488:  using AttributeValueTemplateCheckT =
        -:  489:      std::enable_if_t<std::is_same<T, Attribute>::value>;
        -:  490:  template <typename T, typename = AttributeValueTemplateCheckT<T>>
        -:  491:  FailureOr<iterator_range_impl<AttributeElementIterator>>
        -:  492:  tryGetValues() const {
        -:  493:    return iterator_range_impl<AttributeElementIterator>(
        -:  494:        getType(), AttributeElementIterator(*this, 0),
        -:  495:        AttributeElementIterator(*this, getNumElements()));
        -:  496:  }
        -:  497:
        -:  498:  /// Try to get the held element values a range of T, where T is a derived
        -:  499:  /// attribute type.
        -:  500:  template <typename T>
        -:  501:  using DerivedAttrValueTemplateCheckT =
        -:  502:      std::enable_if_t<std::is_base_of<Attribute, T>::value &&
        -:  503:                       !std::is_same<Attribute, T>::value>;
        -:  504:  template <typename T>
        -:  505:  struct DerivedAttributeElementIterator
        -:  506:      : public llvm::mapped_iterator_base<DerivedAttributeElementIterator<T>,
        -:  507:                                          AttributeElementIterator, T> {
        -:  508:    using llvm::mapped_iterator_base<DerivedAttributeElementIterator<T>,
        -:  509:                                     AttributeElementIterator,
        -:  510:                                     T>::mapped_iterator_base;
        -:  511:
        -:  512:    /// Map the element to the iterator result type.
        -:  513:    T mapElement(Attribute attr) const { return attr.cast<T>(); }
        -:  514:  };
        -:  515:  template <typename T, typename = DerivedAttrValueTemplateCheckT<T>>
        -:  516:  FailureOr<iterator_range_impl<DerivedAttributeElementIterator<T>>>
        -:  517:  tryGetValues() const {
        -:  518:    using DerivedIterT = DerivedAttributeElementIterator<T>;
        -:  519:    return iterator_range_impl<DerivedIterT>(
        -:  520:        getType(), DerivedIterT(value_begin<Attribute>()),
        -:  521:        DerivedIterT(value_end<Attribute>()));
        -:  522:  }
        -:  523:
        -:  524:  /// Try to get the held element values as a range of bool. The element type of
        -:  525:  /// this attribute must be of integer type of bitwidth 1.
        -:  526:  template <typename T>
        -:  527:  using BoolValueTemplateCheckT =
        -:  528:      std::enable_if_t<std::is_same<T, bool>::value>;
        -:  529:  template <typename T, typename = BoolValueTemplateCheckT<T>>
        -:  530:  FailureOr<iterator_range_impl<BoolElementIterator>> tryGetValues() const {
        -:  531:    if (!isValidBool())
        -:  532:      return failure();
        -:  533:    return iterator_range_impl<BoolElementIterator>(
        -:  534:        getType(), BoolElementIterator(*this, 0),
        -:  535:        BoolElementIterator(*this, getNumElements()));
        -:  536:  }
        -:  537:
        -:  538:  /// Try to get the held element values as a range of APInts. The element type
        -:  539:  /// of this attribute must be of integer type.
        -:  540:  template <typename T>
        -:  541:  using APIntValueTemplateCheckT =
        -:  542:      std::enable_if_t<std::is_same<T, APInt>::value>;
        -:  543:  template <typename T, typename = APIntValueTemplateCheckT<T>>
        -:  544:  FailureOr<iterator_range_impl<IntElementIterator>> tryGetValues() const {
        -:  545:    if (!getElementType().isIntOrIndex())
        -:  546:      return failure();
        -:  547:    return iterator_range_impl<IntElementIterator>(getType(), raw_int_begin(),
        -:  548:                                                   raw_int_end());
        -:  549:  }
        -:  550:
        -:  551:  /// Try to get the held element values as a range of complex APInts. The
        -:  552:  /// element type of this attribute must be a complex of integer type.
        -:  553:  template <typename T>
        -:  554:  using ComplexAPIntValueTemplateCheckT =
        -:  555:      std::enable_if_t<std::is_same<T, std::complex<APInt>>::value>;
        -:  556:  template <typename T, typename = ComplexAPIntValueTemplateCheckT<T>>
        -:  557:  FailureOr<iterator_range_impl<ComplexIntElementIterator>>
        -:  558:  tryGetValues() const {
        -:  559:    return tryGetComplexIntValues();
        -:  560:  }
        -:  561:
        -:  562:  /// Try to get the held element values as a range of APFloat. The element type
        -:  563:  /// of this attribute must be of float type.
        -:  564:  template <typename T>
        -:  565:  using APFloatValueTemplateCheckT =
        -:  566:      std::enable_if_t<std::is_same<T, APFloat>::value>;
        -:  567:  template <typename T, typename = APFloatValueTemplateCheckT<T>>
        -:  568:  FailureOr<iterator_range_impl<FloatElementIterator>> tryGetValues() const {
        -:  569:    return tryGetFloatValues();
        -:  570:  }
        -:  571:
        -:  572:  /// Try to get the held element values as a range of complex APFloat. The
        -:  573:  /// element type of this attribute must be a complex of float type.
        -:  574:  template <typename T>
        -:  575:  using ComplexAPFloatValueTemplateCheckT =
        -:  576:      std::enable_if_t<std::is_same<T, std::complex<APFloat>>::value>;
        -:  577:  template <typename T, typename = ComplexAPFloatValueTemplateCheckT<T>>
        -:  578:  FailureOr<iterator_range_impl<ComplexFloatElementIterator>>
        -:  579:  tryGetValues() const {
        -:  580:    return tryGetComplexFloatValues();
        -:  581:  }
        -:  582:
        -:  583:  /// Return the raw storage data held by this attribute. Users should generally
        -:  584:  /// not use this directly, as the internal storage format is not always in the
        -:  585:  /// form the user might expect.
        -:  586:  ArrayRef<char> getRawData() const;
        -:  587:
        -:  588:  /// Return the raw StringRef data held by this attribute.
        -:  589:  ArrayRef<StringRef> getRawStringData() const;
        -:  590:
        -:  591:  /// Return the type of this ElementsAttr, guaranteed to be a vector or tensor
        -:  592:  /// with static shape.
        -:  593:  ShapedType getType() const;
        -:  594:
        -:  595:  /// Return the element type of this DenseElementsAttr.
        -:  596:  Type getElementType() const;
        -:  597:
        -:  598:  /// Returns the number of elements held by this attribute.
        -:  599:  int64_t getNumElements() const;
        -:  600:
        -:  601:  /// Returns the number of elements held by this attribute.
        -:  602:  int64_t size() const { return getNumElements(); }
        -:  603:
        -:  604:  /// Returns if the number of elements held by this attribute is 0.
        -:  605:  bool empty() const { return size() == 0; }
        -:  606:
        -:  607:  //===--------------------------------------------------------------------===//
        -:  608:  // Mutation Utilities
        -:  609:  //===--------------------------------------------------------------------===//
        -:  610:
        -:  611:  /// Return a new DenseElementsAttr that has the same data as the current
        -:  612:  /// attribute, but has been reshaped to 'newType'. The new type must have the
        -:  613:  /// same total number of elements as well as element type.
        -:  614:  DenseElementsAttr reshape(ShapedType newType);
        -:  615:
        -:  616:  /// Return a new DenseElementsAttr that has the same data as the current
        -:  617:  /// attribute, but with a different shape for a splat type. The new type must
        -:  618:  /// have the same element type.
        -:  619:  DenseElementsAttr resizeSplat(ShapedType newType);
        -:  620:
        -:  621:  /// Return a new DenseElementsAttr that has the same data as the current
        -:  622:  /// attribute, but has bitcast elements to 'newElType'. The new type must have
        -:  623:  /// the same bitwidth as the current element type.
        -:  624:  DenseElementsAttr bitcast(Type newElType);
        -:  625:
        -:  626:  /// Generates a new DenseElementsAttr by mapping each int value to a new
        -:  627:  /// underlying APInt. The new values can represent either an integer or float.
        -:  628:  /// This underlying type must be an DenseIntElementsAttr.
        -:  629:  DenseElementsAttr mapValues(Type newElementType,
        -:  630:                              function_ref<APInt(const APInt &)> mapping) const;
        -:  631:
        -:  632:  /// Generates a new DenseElementsAttr by mapping each float value to a new
        -:  633:  /// underlying APInt. the new values can represent either an integer or float.
        -:  634:  /// This underlying type must be an DenseFPElementsAttr.
        -:  635:  DenseElementsAttr
        -:  636:  mapValues(Type newElementType,
        -:  637:            function_ref<APInt(const APFloat &)> mapping) const;
        -:  638:
        -:  639:protected:
        -:  640:  /// Iterators to various elements that require out-of-line definition. These
        -:  641:  /// are hidden from the user to encourage consistent use of the
        -:  642:  /// getValues/value_begin/value_end API.
    #####:  643:  IntElementIterator raw_int_begin() const {
    #####:  644:    return IntElementIterator(*this, 0);
        -:  645:  }
    #####:  646:  IntElementIterator raw_int_end() const {
    #####:  647:    return IntElementIterator(*this, getNumElements());
        -:  648:  }
        -:  649:  FailureOr<iterator_range_impl<ComplexIntElementIterator>>
        -:  650:  tryGetComplexIntValues() const;
        -:  651:  FailureOr<iterator_range_impl<FloatElementIterator>>
        -:  652:  tryGetFloatValues() const;
        -:  653:  FailureOr<iterator_range_impl<ComplexFloatElementIterator>>
        -:  654:  tryGetComplexFloatValues() const;
        -:  655:
        -:  656:  /// Overload of the raw 'get' method that asserts that the given type is of
        -:  657:  /// complex type. This method is used to verify type invariants that the
        -:  658:  /// templatized 'get' method cannot.
        -:  659:  static DenseElementsAttr getRawComplex(ShapedType type, ArrayRef<char> data,
        -:  660:                                         int64_t dataEltSize, bool isInt,
        -:  661:                                         bool isSigned);
        -:  662:
        -:  663:  /// Overload of the raw 'get' method that asserts that the given type is of
        -:  664:  /// integer or floating-point type. This method is used to verify type
        -:  665:  /// invariants that the templatized 'get' method cannot.
        -:  666:  static DenseElementsAttr getRawIntOrFloat(ShapedType type,
        -:  667:                                            ArrayRef<char> data,
        -:  668:                                            int64_t dataEltSize, bool isInt,
        -:  669:                                            bool isSigned);
        -:  670:
        -:  671:  /// Check the information for a C++ data type, check if this type is valid for
        -:  672:  /// the current attribute. This method is used to verify specific type
        -:  673:  /// invariants that the templatized 'getValues' method cannot.
        -:  674:  bool isValidBool() const { return getElementType().isInteger(1); }
        -:  675:  bool isValidIntOrFloat(int64_t dataEltSize, bool isInt, bool isSigned) const;
        -:  676:  bool isValidComplex(int64_t dataEltSize, bool isInt, bool isSigned) const;
        -:  677:};
        -:  678:
        -:  679:/// An attribute that represents a reference to a splat vector or tensor
        -:  680:/// constant, meaning all of the elements have the same value.
        -:  681:class SplatElementsAttr : public DenseElementsAttr {
        -:  682:public:
        -:  683:  using DenseElementsAttr::DenseElementsAttr;
        -:  684:
        -:  685:  /// Method for support type inquiry through isa, cast and dyn_cast.
        -:  686:  static bool classof(Attribute attr) {
        -:  687:    auto denseAttr = attr.dyn_cast<DenseElementsAttr>();
        -:  688:    return denseAttr && denseAttr.isSplat();
        -:  689:  }
        -:  690:};
        -:  691:
        -:  692://===----------------------------------------------------------------------===//
        -:  693:// DenseResourceElementsAttr
        -:  694://===----------------------------------------------------------------------===//
        -:  695:
        -:  696:using DenseResourceElementsHandle = DialectResourceBlobHandle<BuiltinDialect>;
        -:  697:
        -:  698:} // namespace mlir
        -:  699:
        -:  700://===----------------------------------------------------------------------===//
        -:  701:// Tablegen Attribute Declarations
        -:  702://===----------------------------------------------------------------------===//
        -:  703:
        -:  704:#define GET_ATTRDEF_CLASSES
        -:  705:#include "mlir/IR/BuiltinAttributes.h.inc"
        -:  706:
        -:  707://===----------------------------------------------------------------------===//
        -:  708:// C++ Attribute Declarations
        -:  709://===----------------------------------------------------------------------===//
        -:  710:
        -:  711:namespace mlir {
        -:  712://===----------------------------------------------------------------------===//
        -:  713:// DenseArrayAttr
        -:  714:
        -:  715:namespace detail {
        -:  716:/// Base class for DenseArrayAttr that is instantiated and specialized for each
        -:  717:/// supported element type below.
        -:  718:template <typename T>
        -:  719:class DenseArrayAttrImpl : public DenseArrayAttr {
        -:  720:public:
        -:  721:  using DenseArrayAttr::DenseArrayAttr;
        -:  722:
        -:  723:  /// Implicit conversion to ArrayRef<T>.
        -:  724:  operator ArrayRef<T>() const;
    #####:  725:  ArrayRef<T> asArrayRef() const { return ArrayRef<T>{*this}; }
call    0 never executed
call    1 never executed
        -:  726:
        -:  727:  /// Random access to elements.
        -:  728:  T operator[](std::size_t index) const { return asArrayRef()[index]; }
        -:  729:
        -:  730:  /// Builder from ArrayRef<T>.
        -:  731:  static DenseArrayAttrImpl get(MLIRContext *context, ArrayRef<T> content);
        -:  732:
        -:  733:  /// Print the short form `[42, 100, -1]` without any type prefix.
        -:  734:  void print(AsmPrinter &printer) const;
        -:  735:  void print(raw_ostream &os) const;
        -:  736:  /// Print the short form `42, 100, -1` without any braces or type prefix.
        -:  737:  void printWithoutBraces(raw_ostream &os) const;
        -:  738:
        -:  739:  /// Parse the short form `[42, 100, -1]` without any type prefix.
        -:  740:  static Attribute parse(AsmParser &parser, Type type);
        -:  741:
        -:  742:  /// Parse the short form `42, 100, -1` without any type prefix or braces.
        -:  743:  static Attribute parseWithoutBraces(AsmParser &parser, Type type);
        -:  744:
        -:  745:  /// Support for isa<>/cast<>.
        -:  746:  static bool classof(Attribute attr);
        -:  747:};
        -:  748:
        -:  749:extern template class DenseArrayAttrImpl<bool>;
        -:  750:extern template class DenseArrayAttrImpl<int8_t>;
        -:  751:extern template class DenseArrayAttrImpl<int16_t>;
        -:  752:extern template class DenseArrayAttrImpl<int32_t>;
        -:  753:extern template class DenseArrayAttrImpl<int64_t>;
        -:  754:extern template class DenseArrayAttrImpl<float>;
        -:  755:extern template class DenseArrayAttrImpl<double>;
        -:  756:} // namespace detail
        -:  757:
        -:  758:// Public name for all the supported DenseArrayAttr
        -:  759:using DenseBoolArrayAttr = detail::DenseArrayAttrImpl<bool>;
        -:  760:using DenseI8ArrayAttr = detail::DenseArrayAttrImpl<int8_t>;
        -:  761:using DenseI16ArrayAttr = detail::DenseArrayAttrImpl<int16_t>;
        -:  762:using DenseI32ArrayAttr = detail::DenseArrayAttrImpl<int32_t>;
        -:  763:using DenseI64ArrayAttr = detail::DenseArrayAttrImpl<int64_t>;
        -:  764:using DenseF32ArrayAttr = detail::DenseArrayAttrImpl<float>;
        -:  765:using DenseF64ArrayAttr = detail::DenseArrayAttrImpl<double>;
        -:  766:
        -:  767://===----------------------------------------------------------------------===//
        -:  768:// DenseResourceElementsAttr
        -:  769:
        -:  770:namespace detail {
        -:  771:/// Base class for DenseResourceElementsAttr that is instantiated and
        -:  772:/// specialized for each supported element type below.
        -:  773:template <typename T>
        -:  774:class DenseResourceElementsAttrBase : public DenseResourceElementsAttr {
        -:  775:public:
        -:  776:  using DenseResourceElementsAttr::DenseResourceElementsAttr;
        -:  777:
        -:  778:  /// A builder that inserts a new resource using the provided blob. The handle
        -:  779:  /// of the inserted blob is used when building the attribute. The provided
        -:  780:  /// `blobName` is used as a hint for the key of the new handle for the `blob`
        -:  781:  /// resource, but may be changed if necessary to ensure uniqueness during
        -:  782:  /// insertion.
        -:  783:  static DenseResourceElementsAttrBase<T>
        -:  784:  get(ShapedType type, StringRef blobName, AsmResourceBlob blob);
        -:  785:
        -:  786:  /// Return the data of this attribute as an ArrayRef<T> if it is present,
        -:  787:  /// returns None otherwise.
        -:  788:  Optional<ArrayRef<T>> tryGetAsArrayRef() const;
        -:  789:
        -:  790:  /// Support for isa<>/cast<>.
        -:  791:  static bool classof(Attribute attr);
        -:  792:};
        -:  793:
        -:  794:extern template class DenseResourceElementsAttrBase<bool>;
        -:  795:extern template class DenseResourceElementsAttrBase<int8_t>;
        -:  796:extern template class DenseResourceElementsAttrBase<int16_t>;
        -:  797:extern template class DenseResourceElementsAttrBase<int32_t>;
        -:  798:extern template class DenseResourceElementsAttrBase<int64_t>;
        -:  799:extern template class DenseResourceElementsAttrBase<uint8_t>;
        -:  800:extern template class DenseResourceElementsAttrBase<uint16_t>;
        -:  801:extern template class DenseResourceElementsAttrBase<uint32_t>;
        -:  802:extern template class DenseResourceElementsAttrBase<uint64_t>;
        -:  803:extern template class DenseResourceElementsAttrBase<float>;
        -:  804:extern template class DenseResourceElementsAttrBase<double>;
        -:  805:} // namespace detail
        -:  806:
        -:  807:// Public names for all the supported DenseResourceElementsAttr.
        -:  808:
        -:  809:using DenseBoolResourceElementsAttr =
        -:  810:    detail::DenseResourceElementsAttrBase<bool>;
        -:  811:using DenseI8ResourceElementsAttr =
        -:  812:    detail::DenseResourceElementsAttrBase<int8_t>;
        -:  813:using DenseI16ResourceElementsAttr =
        -:  814:    detail::DenseResourceElementsAttrBase<int16_t>;
        -:  815:using DenseI32ResourceElementsAttr =
        -:  816:    detail::DenseResourceElementsAttrBase<int32_t>;
        -:  817:using DenseI64ResourceElementsAttr =
        -:  818:    detail::DenseResourceElementsAttrBase<int64_t>;
        -:  819:using DenseUI8ResourceElementsAttr =
        -:  820:    detail::DenseResourceElementsAttrBase<uint8_t>;
        -:  821:using DenseUI16ResourceElementsAttr =
        -:  822:    detail::DenseResourceElementsAttrBase<uint16_t>;
        -:  823:using DenseUI32ResourceElementsAttr =
        -:  824:    detail::DenseResourceElementsAttrBase<uint32_t>;
        -:  825:using DenseUI64ResourceElementsAttr =
        -:  826:    detail::DenseResourceElementsAttrBase<uint64_t>;
        -:  827:using DenseF32ResourceElementsAttr =
        -:  828:    detail::DenseResourceElementsAttrBase<float>;
        -:  829:using DenseF64ResourceElementsAttr =
        -:  830:    detail::DenseResourceElementsAttrBase<double>;
        -:  831:
        -:  832://===----------------------------------------------------------------------===//
        -:  833:// BoolAttr
        -:  834://===----------------------------------------------------------------------===//
        -:  835:
        -:  836:/// Special case of IntegerAttr to represent boolean integers, i.e., signless i1
        -:  837:/// integers.
        -:  838:class BoolAttr : public Attribute {
        -:  839:public:
        -:  840:  using Attribute::Attribute;
        -:  841:  using ValueType = bool;
        -:  842:
        -:  843:  static BoolAttr get(MLIRContext *context, bool value);
        -:  844:
        -:  845:  /// Enable conversion to IntegerAttr. This uses conversion vs. inheritance to
        -:  846:  /// avoid bringing in all of IntegerAttrs methods.
        -:  847:  operator IntegerAttr() const { return IntegerAttr(impl); }
        -:  848:
        -:  849:  /// Return the boolean value of this attribute.
        -:  850:  bool getValue() const;
        -:  851:
        -:  852:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:  853:  static bool classof(Attribute attr);
        -:  854:};
        -:  855:
        -:  856://===----------------------------------------------------------------------===//
        -:  857:// FlatSymbolRefAttr
        -:  858://===----------------------------------------------------------------------===//
        -:  859:
        -:  860:/// A symbol reference with a reference path containing a single element. This
        -:  861:/// is used to refer to an operation within the current symbol table.
        -:  862:class FlatSymbolRefAttr : public SymbolRefAttr {
        -:  863:public:
    #####:  864:  using SymbolRefAttr::SymbolRefAttr;
        -:  865:  using ValueType = StringRef;
        -:  866:
        -:  867:  /// Construct a symbol reference for the given value name.
        -:  868:  static FlatSymbolRefAttr get(StringAttr value) {
        -:  869:    return SymbolRefAttr::get(value);
        -:  870:  }
        -:  871:  static FlatSymbolRefAttr get(MLIRContext *ctx, StringRef value) {
        -:  872:    return SymbolRefAttr::get(ctx, value);
        -:  873:  }
        -:  874:
        -:  875:  /// Convenience getter for building a SymbolRefAttr based on an operation
        -:  876:  /// that implements the SymbolTrait.
        -:  877:  static FlatSymbolRefAttr get(Operation *symbol) {
        -:  878:    return SymbolRefAttr::get(symbol);
        -:  879:  }
        -:  880:
        -:  881:  /// Returns the name of the held symbol reference as a StringAttr.
    #####:  882:  StringAttr getAttr() const { return getRootReference(); }
        -:  883:
        -:  884:  /// Returns the name of the held symbol reference.
function _ZNK4mlir17FlatSymbolRefAttr8getValueEv called 0 returned 0% blocks executed 0%
    #####:  885:  StringRef getValue() const { return getAttr().getValue(); }
call    0 never executed
call    1 never executed
        -:  886:
        -:  887:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
function _ZN4mlir17FlatSymbolRefAttr7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  888:  static bool classof(Attribute attr) {
    #####:  889:    SymbolRefAttr refAttr = attr.dyn_cast<SymbolRefAttr>();
call    0 never executed
    #####:  890:    return refAttr && refAttr.getNestedReferences().empty();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  891:  }
        -:  892:
        -:  893:private:
        -:  894:  using SymbolRefAttr::get;
        -:  895:  using SymbolRefAttr::getNestedReferences;
        -:  896:};
        -:  897:
        -:  898://===----------------------------------------------------------------------===//
        -:  899:// DenseFPElementsAttr
        -:  900://===----------------------------------------------------------------------===//
        -:  901:
        -:  902:/// An attribute that represents a reference to a dense float vector or tensor
        -:  903:/// object. Each element is stored as a double.
        -:  904:class DenseFPElementsAttr : public DenseIntOrFPElementsAttr {
        -:  905:public:
        -:  906:  using iterator = DenseElementsAttr::FloatElementIterator;
        -:  907:
        -:  908:  using DenseIntOrFPElementsAttr::DenseIntOrFPElementsAttr;
        -:  909:
        -:  910:  /// Get an instance of a DenseFPElementsAttr with the given arguments. This
        -:  911:  /// simply wraps the DenseElementsAttr::get calls.
        -:  912:  template <typename Arg>
        -:  913:  static DenseFPElementsAttr get(const ShapedType &type, Arg &&arg) {
        -:  914:    return DenseElementsAttr::get(type, llvm::makeArrayRef(arg))
        -:  915:        .template cast<DenseFPElementsAttr>();
        -:  916:  }
        -:  917:  template <typename T>
        -:  918:  static DenseFPElementsAttr get(const ShapedType &type,
        -:  919:                                 const std::initializer_list<T> &list) {
        -:  920:    return DenseElementsAttr::get(type, list)
        -:  921:        .template cast<DenseFPElementsAttr>();
        -:  922:  }
        -:  923:
        -:  924:  /// Generates a new DenseElementsAttr by mapping each value attribute, and
        -:  925:  /// constructing the DenseElementsAttr given the new element type.
        -:  926:  DenseElementsAttr
        -:  927:  mapValues(Type newElementType,
        -:  928:            function_ref<APInt(const APFloat &)> mapping) const;
        -:  929:
        -:  930:  /// Iterator access to the float element values.
        -:  931:  iterator begin() const { return tryGetFloatValues()->begin(); }
        -:  932:  iterator end() const { return tryGetFloatValues()->end(); }
        -:  933:
        -:  934:  /// Method for supporting type inquiry through isa, cast and dyn_cast.
        -:  935:  static bool classof(Attribute attr);
        -:  936:};
        -:  937:
        -:  938://===----------------------------------------------------------------------===//
        -:  939:// DenseIntElementsAttr
        -:  940://===----------------------------------------------------------------------===//
        -:  941:
        -:  942:/// An attribute that represents a reference to a dense integer vector or tensor
        -:  943:/// object.
        -:  944:class DenseIntElementsAttr : public DenseIntOrFPElementsAttr {
        -:  945:public:
        -:  946:  /// DenseIntElementsAttr iterates on APInt, so we can use the raw element
        -:  947:  /// iterator directly.
        -:  948:  using iterator = DenseElementsAttr::IntElementIterator;
        -:  949:
    #####:  950:  using DenseIntOrFPElementsAttr::DenseIntOrFPElementsAttr;
        -:  951:
        -:  952:  /// Get an instance of a DenseIntElementsAttr with the given arguments. This
        -:  953:  /// simply wraps the DenseElementsAttr::get calls.
        -:  954:  template <typename Arg>
        -:  955:  static DenseIntElementsAttr get(const ShapedType &type, Arg &&arg) {
        -:  956:    return DenseElementsAttr::get(type, llvm::makeArrayRef(arg))
        -:  957:        .template cast<DenseIntElementsAttr>();
        -:  958:  }
        -:  959:  template <typename T>
        -:  960:  static DenseIntElementsAttr get(const ShapedType &type,
        -:  961:                                  const std::initializer_list<T> &list) {
        -:  962:    return DenseElementsAttr::get(type, list)
        -:  963:        .template cast<DenseIntElementsAttr>();
        -:  964:  }
        -:  965:
        -:  966:  /// Generates a new DenseElementsAttr by mapping each value attribute, and
        -:  967:  /// constructing the DenseElementsAttr given the new element type.
        -:  968:  DenseElementsAttr mapValues(Type newElementType,
        -:  969:                              function_ref<APInt(const APInt &)> mapping) const;
        -:  970:
        -:  971:  /// Iterator access to the integer element values.
    #####:  972:  iterator begin() const { return raw_int_begin(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  973:  iterator end() const { return raw_int_end(); }
call    0 never executed
call    1 never executed
        -:  974:
        -:  975:  /// Method for supporting type inquiry through isa, cast and dyn_cast.
        -:  976:  static bool classof(Attribute attr);
        -:  977:};
        -:  978:
        -:  979://===----------------------------------------------------------------------===//
        -:  980:// SparseElementsAttr
        -:  981://===----------------------------------------------------------------------===//
        -:  982:
        -:  983:template <typename T>
        -:  984:auto SparseElementsAttr::try_value_begin_impl(OverloadToken<T>) const
        -:  985:    -> FailureOr<iterator<T>> {
        -:  986:  auto zeroValue = getZeroValue<T>();
        -:  987:  auto valueIt = getValues().try_value_begin<T>();
        -:  988:  if (failed(valueIt))
        -:  989:    return failure();
        -:  990:  const std::vector<ptrdiff_t> flatSparseIndices(getFlattenedSparseIndices());
        -:  991:  std::function<T(ptrdiff_t)> mapFn =
        -:  992:      [flatSparseIndices{flatSparseIndices}, valueIt{std::move(*valueIt)},
        -:  993:       zeroValue{std::move(zeroValue)}](ptrdiff_t index) {
        -:  994:        // Try to map the current index to one of the sparse indices.
        -:  995:        for (unsigned i = 0, e = flatSparseIndices.size(); i != e; ++i)
        -:  996:          if (flatSparseIndices[i] == index)
        -:  997:            return *std::next(valueIt, i);
        -:  998:        // Otherwise, return the zero value.
        -:  999:        return zeroValue;
        -: 1000:      };
        -: 1001:  return iterator<T>(llvm::seq<ptrdiff_t>(0, getNumElements()).begin(), mapFn);
        -: 1002:}
        -: 1003:
        -: 1004://===----------------------------------------------------------------------===//
        -: 1005:// StringAttr
        -: 1006://===----------------------------------------------------------------------===//
        -: 1007:
        -: 1008:/// Define comparisons for StringAttr against nullptr and itself to avoid the
        -: 1009:/// StringRef overloads from being chosen when not desirable.
        -: 1010:inline bool operator==(StringAttr lhs, std::nullptr_t) { return !lhs; }
        -: 1011:inline bool operator!=(StringAttr lhs, std::nullptr_t) {
        -: 1012:  return static_cast<bool>(lhs);
        -: 1013:}
        -: 1014:inline bool operator==(StringAttr lhs, StringAttr rhs) {
        -: 1015:  return (Attribute)lhs == (Attribute)rhs;
        -: 1016:}
        -: 1017:inline bool operator!=(StringAttr lhs, StringAttr rhs) { return !(lhs == rhs); }
        -: 1018:
        -: 1019:/// Allow direct comparison with StringRef.
        -: 1020:inline bool operator==(StringAttr lhs, StringRef rhs) {
        -: 1021:  return lhs.getValue() == rhs;
        -: 1022:}
        -: 1023:inline bool operator!=(StringAttr lhs, StringRef rhs) { return !(lhs == rhs); }
        -: 1024:inline bool operator==(StringRef lhs, StringAttr rhs) {
        -: 1025:  return rhs.getValue() == lhs;
        -: 1026:}
        -: 1027:inline bool operator!=(StringRef lhs, StringAttr rhs) { return !(lhs == rhs); }
        -: 1028:
        -: 1029:} // namespace mlir
        -: 1030:
        -: 1031://===----------------------------------------------------------------------===//
        -: 1032:// Attribute Utilities
        -: 1033://===----------------------------------------------------------------------===//
        -: 1034:
        -: 1035:namespace mlir {
        -: 1036:
        -: 1037:/// Given a list of strides (in which MemRefType::getDynamicStrideOrOffset()
        -: 1038:/// represents a dynamic value), return the single result AffineMap which
        -: 1039:/// represents the linearized strided layout map. Dimensions correspond to the
        -: 1040:/// offset followed by the strides in order. Symbols are inserted for each
        -: 1041:/// dynamic dimension in order. A stride is always positive.
        -: 1042:///
        -: 1043:/// Examples:
        -: 1044:/// =========
        -: 1045:///
        -: 1046:///   1. For offset: 0 strides: ?, ?, 1 return
        -: 1047:///         (i, j, k)[M, N]->(M * i + N * j + k)
        -: 1048:///
        -: 1049:///   2. For offset: 3 strides: 32, ?, 16 return
        -: 1050:///         (i, j, k)[M]->(3 + 32 * i + M * j + 16 * k)
        -: 1051:///
        -: 1052:///   3. For offset: ? strides: ?, ?, ? return
        -: 1053:///         (i, j, k)[off, M, N, P]->(off + M * i + N * j + P * k)
        -: 1054:AffineMap makeStridedLinearLayoutMap(ArrayRef<int64_t> strides, int64_t offset,
        -: 1055:                                     MLIRContext *context);
        -: 1056:
        -: 1057:} // namespace mlir
        -: 1058:
        -: 1059:namespace llvm {
        -: 1060:
        -: 1061:template <>
        -: 1062:struct DenseMapInfo<mlir::StringAttr> : public DenseMapInfo<mlir::Attribute> {
        -: 1063:  static mlir::StringAttr getEmptyKey() {
        -: 1064:    const void *pointer = llvm::DenseMapInfo<const void *>::getEmptyKey();
        -: 1065:    return mlir::StringAttr::getFromOpaquePointer(pointer);
        -: 1066:  }
        -: 1067:  static mlir::StringAttr getTombstoneKey() {
        -: 1068:    const void *pointer = llvm::DenseMapInfo<const void *>::getTombstoneKey();
        -: 1069:    return mlir::StringAttr::getFromOpaquePointer(pointer);
        -: 1070:  }
        -: 1071:};
        -: 1072:template <>
        -: 1073:struct PointerLikeTypeTraits<mlir::StringAttr>
        -: 1074:    : public PointerLikeTypeTraits<mlir::Attribute> {
        -: 1075:  static inline mlir::StringAttr getFromVoidPointer(void *p) {
        -: 1076:    return mlir::StringAttr::getFromOpaquePointer(p);
        -: 1077:  }
        -: 1078:};
        -: 1079:
        -: 1080:template <>
        -: 1081:struct PointerLikeTypeTraits<mlir::IntegerAttr>
        -: 1082:    : public PointerLikeTypeTraits<mlir::Attribute> {
    #####: 1083:  static inline mlir::IntegerAttr getFromVoidPointer(void *p) {
    #####: 1084:    return mlir::IntegerAttr::getFromOpaquePointer(p);
        -: 1085:  }
        -: 1086:};
        -: 1087:
        -: 1088:template <>
        -: 1089:struct PointerLikeTypeTraits<mlir::SymbolRefAttr>
        -: 1090:    : public PointerLikeTypeTraits<mlir::Attribute> {
        -: 1091:  static inline mlir::SymbolRefAttr getFromVoidPointer(void *ptr) {
        -: 1092:    return mlir::SymbolRefAttr::getFromOpaquePointer(ptr);
        -: 1093:  }
        -: 1094:};
        -: 1095:
        -: 1096:} // namespace llvm
        -: 1097:
        -: 1098:#endif // MLIR_IR_BUILTINATTRIBUTES_H
