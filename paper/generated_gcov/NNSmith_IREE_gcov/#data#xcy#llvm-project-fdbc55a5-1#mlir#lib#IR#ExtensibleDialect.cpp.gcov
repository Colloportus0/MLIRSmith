        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/ExtensibleDialect.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/ExtensibleDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/ExtensibleDialect.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- ExtensibleDialect.cpp - Extensible dialect ---------------*- C++ -*-===//
        -:    2://
        -:    3:// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/ExtensibleDialect.h"
        -:   10:#include "mlir/IR/AttributeSupport.h"
        -:   11:#include "mlir/IR/DialectImplementation.h"
        -:   12:#include "mlir/IR/OperationSupport.h"
        -:   13:#include "mlir/IR/StorageUniquerSupport.h"
        -:   14:#include "mlir/Support/LogicalResult.h"
        -:   15:
        -:   16:using namespace mlir;
        -:   17:
        -:   18://===----------------------------------------------------------------------===//
        -:   19:// Dynamic types and attributes shared functions
        -:   20://===----------------------------------------------------------------------===//
        -:   21:
        -:   22:/// Default parser for dynamic attribute or type parameters.
        -:   23:/// Parse in the format '(<>)?' or '<attr (,attr)*>'.
        -:   24:static LogicalResult
function _ZL16typeOrAttrParserRN4mlir9AsmParserERN4llvm15SmallVectorImplINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:   25:typeOrAttrParser(AsmParser &parser, SmallVectorImpl<Attribute> &parsedParams) {
        -:   26:  // No parameters
    #####:   27:  if (parser.parseOptionalLess() || !parser.parseOptionalGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   28:    return success();
        -:   29:
    #####:   30:  Attribute attr;
    #####:   31:  if (parser.parseAttribute(attr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   32:    return failure();
    #####:   33:  parsedParams.push_back(attr);
call    0 never executed
        -:   34:
    #####:   35:  while (parser.parseOptionalGreater()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   36:    Attribute attr;
    #####:   37:    if (parser.parseComma() || parser.parseAttribute(attr))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   38:      return failure();
    #####:   39:    parsedParams.push_back(attr);
call    0 never executed
        -:   40:  }
        -:   41:
    #####:   42:  return success();
        -:   43:}
        -:   44:
        -:   45:/// Default printer for dynamic attribute or type parameters.
        -:   46:/// Print in the format '(<>)?' or '<attr (,attr)*>'.
function _ZL17typeOrAttrPrinterRN4mlir10AsmPrinterEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:   47:static void typeOrAttrPrinter(AsmPrinter &printer, ArrayRef<Attribute> params) {
    #####:   48:  if (params.empty())
branch  0 never executed
branch  1 never executed
        -:   49:    return;
        -:   50:
    #####:   51:  printer << "<";
call    0 never executed
    #####:   52:  interleaveComma(params, printer.getStream());
call    0 never executed
call    1 never executed
    #####:   53:  printer << ">";
call    0 never executed
        -:   54:}
        -:   55:
        -:   56://===----------------------------------------------------------------------===//
        -:   57:// Dynamic type
        -:   58://===----------------------------------------------------------------------===//
        -:   59:
        -:   60:std::unique_ptr<DynamicTypeDefinition>
function _ZN4mlir21DynamicTypeDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEE called 10216 returned 100% blocks executed 100%
    10216:   61:DynamicTypeDefinition::get(StringRef name, ExtensibleDialect *dialect,
        -:   62:                           VerifierFn &&verifier) {
    20432:   63:  return DynamicTypeDefinition::get(name, dialect, std::move(verifier),
call    0 returned 100%
call    1 returned 100%
    10216:   64:                                    typeOrAttrParser, typeOrAttrPrinter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:   65:}
        -:   66:
        -:   67:std::unique_ptr<DynamicTypeDefinition>
function _ZN4mlir21DynamicTypeDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEEONS5_IKFNS_11ParseResultERNS_9AsmParserERNS1_15SmallVectorImplISC_EEEEEONS5_IKFvRNS_10AsmPrinterESD_EEE called 15324 returned 100% blocks executed 100%
    15324:   68:DynamicTypeDefinition::get(StringRef name, ExtensibleDialect *dialect,
        -:   69:                           VerifierFn &&verifier, ParserFn &&parser,
        -:   70:                           PrinterFn &&printer) {
    15324:   71:  return std::unique_ptr<DynamicTypeDefinition>(
    15324:   72:      new DynamicTypeDefinition(name, dialect, std::move(verifier),
call    0 returned 100%
    15324:   73:                                std::move(parser), std::move(printer)));
call    0 returned 100%
call    1 returned 100%
        -:   74:}
        -:   75:
function _ZN4mlir21DynamicTypeDefinitionC2EN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEEONS5_IKFNS_11ParseResultERNS_9AsmParserERNS1_15SmallVectorImplISC_EEEEEONS5_IKFvRNS_10AsmPrinterESD_EEE called 15324 returned 100% blocks executed 100%
    15324:   76:DynamicTypeDefinition::DynamicTypeDefinition(StringRef nameRef,
        -:   77:                                             ExtensibleDialect *dialect,
        -:   78:                                             VerifierFn &&verifier,
        -:   79:                                             ParserFn &&parser,
    15324:   80:                                             PrinterFn &&printer)
    15324:   81:    : name(nameRef), dialect(dialect), verifier(std::move(verifier)),
call    0 returned 100%
    15324:   82:      parser(std::move(parser)), printer(std::move(printer)),
call    0 returned 100%
call    1 returned 100%
    15324:   83:      ctx(dialect->getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:   84:
function _ZN4mlir21DynamicTypeDefinitionC2EPNS_17ExtensibleDialectEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   85:DynamicTypeDefinition::DynamicTypeDefinition(ExtensibleDialect *dialect,
    #####:   86:                                             StringRef nameRef)
    #####:   87:    : name(nameRef), dialect(dialect), ctx(dialect->getContext()) {}
call    0 never executed
        -:   88:
function _ZN4mlir21DynamicTypeDefinition21registerInTypeUniquerEv called 0 returned 0% blocks executed 0%
   15324*:   89:void DynamicTypeDefinition::registerInTypeUniquer() {
    #####:   90:  detail::TypeUniquer::registerType<DynamicType>(&getContext(), getTypeID());
call    0 never executed
    #####:   91:}
        -:   92:
        -:   93:namespace mlir {
        -:   94:namespace detail {
        -:   95:/// Storage of DynamicType.
        -:   96:/// Contains a pointer to the type definition and type parameters.
        -:   97:struct DynamicTypeStorage : public TypeStorage {
        -:   98:
        -:   99:  using KeyTy = std::pair<DynamicTypeDefinition *, ArrayRef<Attribute>>;
        -:  100:
    #####:  101:  explicit DynamicTypeStorage(DynamicTypeDefinition *typeDef,
        -:  102:                              ArrayRef<Attribute> params)
    #####:  103:      : typeDef(typeDef), params(params) {}
        -:  104:
function _ZNK4mlir6detail18DynamicTypeStorageeqERKSt4pairIPNS_21DynamicTypeDefinitionEN4llvm8ArrayRefINS_9AttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  105:  bool operator==(const KeyTy &key) const {
    #####:  106:    return typeDef == key.first && params == key.second;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  107:  }
        -:  108:
        -:  109:  static llvm::hash_code hashKey(const KeyTy &key) {
        -:  110:    return llvm::hash_value(key);
        -:  111:  }
        -:  112:
function _ZN4mlir6detail18DynamicTypeStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt4pairIPNS_21DynamicTypeDefinitionEN4llvm8ArrayRefINS_9AttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  113:  static DynamicTypeStorage *construct(TypeStorageAllocator &alloc,
        -:  114:                                       const KeyTy &key) {
    #####:  115:    return new (alloc.allocate<DynamicTypeStorage>())
    #####:  116:        DynamicTypeStorage(key.first, alloc.copyInto(key.second));
call    0 never executed
call    1 never executed
        -:  117:  }
        -:  118:
        -:  119:  /// Definition of the type.
        -:  120:  DynamicTypeDefinition *typeDef;
        -:  121:
        -:  122:  /// The type parameters.
        -:  123:  ArrayRef<Attribute> params;
        -:  124:};
        -:  125:} // namespace detail
        -:  126:} // namespace mlir
        -:  127:
function _ZN4mlir11DynamicType3getEPNS_21DynamicTypeDefinitionEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  128:DynamicType DynamicType::get(DynamicTypeDefinition *typeDef,
        -:  129:                             ArrayRef<Attribute> params) {
    #####:  130:  auto &ctx = typeDef->getContext();
call    0 never executed
    #####:  131:  auto emitError = detail::getDefaultDiagnosticEmitFn(&ctx);
call    0 never executed
    #####:  132:  assert(succeeded(typeDef->verify(emitError, params)));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  133:  return detail::TypeUniquer::getWithTypeID<DynamicType>(
    #####:  134:      &ctx, typeDef->getTypeID(), typeDef, params);
call    0 never executed
call    1 never executed
        -:  135:}
        -:  136:
        -:  137:DynamicType
function _ZN4mlir11DynamicType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEEPNS_21DynamicTypeDefinitionENS1_8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  138:DynamicType::getChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  139:                        DynamicTypeDefinition *typeDef,
        -:  140:                        ArrayRef<Attribute> params) {
    #####:  141:  if (failed(typeDef->verify(emitError, params)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  142:    return {};
    #####:  143:  auto &ctx = typeDef->getContext();
call    0 never executed
    #####:  144:  return detail::TypeUniquer::getWithTypeID<DynamicType>(
    #####:  145:      &ctx, typeDef->getTypeID(), typeDef, params);
call    0 never executed
        -:  146:}
        -:  147:
function _ZN4mlir11DynamicType10getTypeDefEv called 0 returned 0% blocks executed 0%
    #####:  148:DynamicTypeDefinition *DynamicType::getTypeDef() { return getImpl()->typeDef; }
        -:  149:
function _ZN4mlir11DynamicType9getParamsEv called 0 returned 0% blocks executed 0%
    #####:  150:ArrayRef<Attribute> DynamicType::getParams() { return getImpl()->params; }
call    0 never executed
        -:  151:
function _ZN4mlir11DynamicType7classofENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  152:bool DynamicType::classof(Type type) {
    #####:  153:  return type.hasTrait<TypeTrait::IsDynamicType>();
call    0 never executed
call    1 never executed
        -:  154:}
        -:  155:
function _ZN4mlir11DynamicType5parseERNS_9AsmParserEPNS_21DynamicTypeDefinitionERS0_ called 0 returned 0% blocks executed 0%
    #####:  156:ParseResult DynamicType::parse(AsmParser &parser,
        -:  157:                               DynamicTypeDefinition *typeDef,
        -:  158:                               DynamicType &parsedType) {
    #####:  159:  SmallVector<Attribute> params;
call    0 never executed
    #####:  160:  if (failed(typeDef->parser(parser, params)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  161:    return failure();
    #####:  162:  parsedType = parser.getChecked<DynamicType>(typeDef, params);
call    0 never executed
    #####:  163:  if (!parsedType)
branch  0 never executed
branch  1 never executed
    #####:  164:    return failure();
    #####:  165:  return success();
        -:  166:}
        -:  167:
function _ZN4mlir11DynamicType5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  168:void DynamicType::print(AsmPrinter &printer) {
    #####:  169:  printer << getTypeDef()->getName();
call    0 never executed
    #####:  170:  getTypeDef()->printer(printer, getParams());
call    0 never executed
    #####:  171:}
        -:  172:
        -:  173://===----------------------------------------------------------------------===//
        -:  174:// Dynamic attribute
        -:  175://===----------------------------------------------------------------------===//
        -:  176:
        -:  177:std::unique_ptr<DynamicAttrDefinition>
function _ZN4mlir21DynamicAttrDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEE called 10216 returned 100% blocks executed 100%
    10216:  178:DynamicAttrDefinition::get(StringRef name, ExtensibleDialect *dialect,
        -:  179:                           VerifierFn &&verifier) {
    20432:  180:  return DynamicAttrDefinition::get(name, dialect, std::move(verifier),
call    0 returned 100%
call    1 returned 100%
    10216:  181:                                    typeOrAttrParser, typeOrAttrPrinter);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  182:}
        -:  183:
        -:  184:std::unique_ptr<DynamicAttrDefinition>
function _ZN4mlir21DynamicAttrDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEEONS5_IKFNS_11ParseResultERNS_9AsmParserERNS1_15SmallVectorImplISC_EEEEEONS5_IKFvRNS_10AsmPrinterESD_EEE called 15324 returned 100% blocks executed 100%
    15324:  185:DynamicAttrDefinition::get(StringRef name, ExtensibleDialect *dialect,
        -:  186:                           VerifierFn &&verifier, ParserFn &&parser,
        -:  187:                           PrinterFn &&printer) {
    15324:  188:  return std::unique_ptr<DynamicAttrDefinition>(
    15324:  189:      new DynamicAttrDefinition(name, dialect, std::move(verifier),
call    0 returned 100%
    15324:  190:                                std::move(parser), std::move(printer)));
call    0 returned 100%
call    1 returned 100%
        -:  191:}
        -:  192:
function _ZN4mlir21DynamicAttrDefinitionC2EN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultENS1_12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefINS_9AttributeEEEEEEONS5_IKFNS_11ParseResultERNS_9AsmParserERNS1_15SmallVectorImplISC_EEEEEONS5_IKFvRNS_10AsmPrinterESD_EEE called 15324 returned 100% blocks executed 100%
    15324:  193:DynamicAttrDefinition::DynamicAttrDefinition(StringRef nameRef,
        -:  194:                                             ExtensibleDialect *dialect,
        -:  195:                                             VerifierFn &&verifier,
        -:  196:                                             ParserFn &&parser,
    15324:  197:                                             PrinterFn &&printer)
    15324:  198:    : name(nameRef), dialect(dialect), verifier(std::move(verifier)),
call    0 returned 100%
    15324:  199:      parser(std::move(parser)), printer(std::move(printer)),
call    0 returned 100%
call    1 returned 100%
    15324:  200:      ctx(dialect->getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  201:
function _ZN4mlir21DynamicAttrDefinitionC2EPNS_17ExtensibleDialectEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  202:DynamicAttrDefinition::DynamicAttrDefinition(ExtensibleDialect *dialect,
    #####:  203:                                             StringRef nameRef)
    #####:  204:    : name(nameRef), dialect(dialect), ctx(dialect->getContext()) {}
call    0 never executed
        -:  205:
function _ZN4mlir21DynamicAttrDefinition21registerInAttrUniquerEv called 0 returned 0% blocks executed 0%
   15324*:  206:void DynamicAttrDefinition::registerInAttrUniquer() {
    #####:  207:  detail::AttributeUniquer::registerAttribute<DynamicAttr>(&getContext(),
call    0 never executed
        -:  208:                                                           getTypeID());
    #####:  209:}
        -:  210:
        -:  211:namespace mlir {
        -:  212:namespace detail {
        -:  213:/// Storage of DynamicAttr.
        -:  214:/// Contains a pointer to the attribute definition and attribute parameters.
        -:  215:struct DynamicAttrStorage : public AttributeStorage {
        -:  216:  using KeyTy = std::pair<DynamicAttrDefinition *, ArrayRef<Attribute>>;
        -:  217:
    #####:  218:  explicit DynamicAttrStorage(DynamicAttrDefinition *attrDef,
        -:  219:                              ArrayRef<Attribute> params)
    #####:  220:      : attrDef(attrDef), params(params) {}
        -:  221:
function _ZNK4mlir6detail18DynamicAttrStorageeqERKSt4pairIPNS_21DynamicAttrDefinitionEN4llvm8ArrayRefINS_9AttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  222:  bool operator==(const KeyTy &key) const {
    #####:  223:    return attrDef == key.first && params == key.second;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  224:  }
        -:  225:
        -:  226:  static llvm::hash_code hashKey(const KeyTy &key) {
        -:  227:    return llvm::hash_value(key);
        -:  228:  }
        -:  229:
function _ZN4mlir6detail18DynamicAttrStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt4pairIPNS_21DynamicAttrDefinitionEN4llvm8ArrayRefINS_9AttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  230:  static DynamicAttrStorage *construct(AttributeStorageAllocator &alloc,
        -:  231:                                       const KeyTy &key) {
    #####:  232:    return new (alloc.allocate<DynamicAttrStorage>())
    #####:  233:        DynamicAttrStorage(key.first, alloc.copyInto(key.second));
call    0 never executed
call    1 never executed
        -:  234:  }
        -:  235:
        -:  236:  /// Definition of the type.
        -:  237:  DynamicAttrDefinition *attrDef;
        -:  238:
        -:  239:  /// The type parameters.
        -:  240:  ArrayRef<Attribute> params;
        -:  241:};
        -:  242:} // namespace detail
        -:  243:} // namespace mlir
        -:  244:
function _ZN4mlir11DynamicAttr3getEPNS_21DynamicAttrDefinitionEN4llvm8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  245:DynamicAttr DynamicAttr::get(DynamicAttrDefinition *attrDef,
        -:  246:                             ArrayRef<Attribute> params) {
    #####:  247:  auto &ctx = attrDef->getContext();
call    0 never executed
    #####:  248:  return detail::AttributeUniquer::getWithTypeID<DynamicAttr>(
    #####:  249:      &ctx, attrDef->getTypeID(), attrDef, params);
call    0 never executed
call    1 never executed
        -:  250:}
        -:  251:
        -:  252:DynamicAttr
function _ZN4mlir11DynamicAttr10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEEPNS_21DynamicAttrDefinitionENS1_8ArrayRefINS_9AttributeEEE called 0 returned 0% blocks executed 0%
    #####:  253:DynamicAttr::getChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  254:                        DynamicAttrDefinition *attrDef,
        -:  255:                        ArrayRef<Attribute> params) {
    #####:  256:  if (failed(attrDef->verify(emitError, params)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  257:    return {};
    #####:  258:  return get(attrDef, params);
call    0 never executed
        -:  259:}
        -:  260:
function _ZN4mlir11DynamicAttr10getAttrDefEv called 0 returned 0% blocks executed 0%
    #####:  261:DynamicAttrDefinition *DynamicAttr::getAttrDef() { return getImpl()->attrDef; }
        -:  262:
function _ZN4mlir11DynamicAttr9getParamsEv called 0 returned 0% blocks executed 0%
    #####:  263:ArrayRef<Attribute> DynamicAttr::getParams() { return getImpl()->params; }
call    0 never executed
        -:  264:
function _ZN4mlir11DynamicAttr7classofENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  265:bool DynamicAttr::classof(Attribute attr) {
    #####:  266:  return attr.hasTrait<AttributeTrait::IsDynamicAttr>();
call    0 never executed
call    1 never executed
        -:  267:}
        -:  268:
function _ZN4mlir11DynamicAttr5parseERNS_9AsmParserEPNS_21DynamicAttrDefinitionERS0_ called 0 returned 0% blocks executed 0%
    #####:  269:ParseResult DynamicAttr::parse(AsmParser &parser,
        -:  270:                               DynamicAttrDefinition *attrDef,
        -:  271:                               DynamicAttr &parsedAttr) {
    #####:  272:  SmallVector<Attribute> params;
call    0 never executed
    #####:  273:  if (failed(attrDef->parser(parser, params)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  274:    return failure();
    #####:  275:  parsedAttr = parser.getChecked<DynamicAttr>(attrDef, params);
call    0 never executed
    #####:  276:  if (!parsedAttr)
branch  0 never executed
branch  1 never executed
    #####:  277:    return failure();
    #####:  278:  return success();
        -:  279:}
        -:  280:
function _ZN4mlir11DynamicAttr5printERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  281:void DynamicAttr::print(AsmPrinter &printer) {
    #####:  282:  printer << getAttrDef()->getName();
call    0 never executed
    #####:  283:  getAttrDef()->printer(printer, getParams());
call    0 never executed
    #####:  284:}
        -:  285:
        -:  286://===----------------------------------------------------------------------===//
        -:  287:// Dynamic operation
        -:  288://===----------------------------------------------------------------------===//
        -:  289:
function _ZN4mlir19DynamicOpDefinitionC2EN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultEPNS_9OperationEEEESB_ONS5_IKFNS_11ParseResultERNS_11OpAsmParserERNS_14OperationStateEEEEONS5_IKFvS8_RNS_12OpAsmPrinterES2_EEEONS5_IKFS6_S8_NS1_8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEEEEEONS5_IKFvRNS_17RewritePatternSetEPNS_11MLIRContextEEEEONS5_IKFvRKNS_23RegisteredOperationNameERNS_13NamedAttrListEEEE called 15324 returned 100% blocks executed 100%
    15324:  290:DynamicOpDefinition::DynamicOpDefinition(
        -:  291:    StringRef name, ExtensibleDialect *dialect,
        -:  292:    OperationName::VerifyInvariantsFn &&verifyFn,
        -:  293:    OperationName::VerifyRegionInvariantsFn &&verifyRegionFn,
        -:  294:    OperationName::ParseAssemblyFn &&parseFn,
        -:  295:    OperationName::PrintAssemblyFn &&printFn,
        -:  296:    OperationName::FoldHookFn &&foldHookFn,
        -:  297:    OperationName::GetCanonicalizationPatternsFn
        -:  298:        &&getCanonicalizationPatternsFn,
    15324:  299:    OperationName::PopulateDefaultAttrsFn &&populateDefaultAttrsFn)
call    0 returned 100%
    15324:  300:    : typeID(dialect->allocateTypeID()),
    15324:  301:      name((dialect->getNamespace() + "." + name).str()), dialect(dialect),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    15324:  302:      verifyFn(std::move(verifyFn)), verifyRegionFn(std::move(verifyRegionFn)),
call    0 returned 100%
call    1 returned 100%
    15324:  303:      parseFn(std::move(parseFn)), printFn(std::move(printFn)),
call    0 returned 100%
call    1 returned 100%
    15324:  304:      foldHookFn(std::move(foldHookFn)),
call    0 returned 100%
    15324:  305:      getCanonicalizationPatternsFn(std::move(getCanonicalizationPatternsFn)),
call    0 returned 100%
    15324:  306:      populateDefaultAttrsFn(std::move(populateDefaultAttrsFn)) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
call    7 returned 100%
        -:  307:
function _ZN4mlir19DynamicOpDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultEPNS_9OperationEEEESB_ called 10216 returned 100% blocks executed 100%
    10216:  308:std::unique_ptr<DynamicOpDefinition> DynamicOpDefinition::get(
        -:  309:    StringRef name, ExtensibleDialect *dialect,
        -:  310:    OperationName::VerifyInvariantsFn &&verifyFn,
        -:  311:    OperationName::VerifyRegionInvariantsFn &&verifyRegionFn) {
function _ZZN4mlir19DynamicOpDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultEPNS_9OperationEEEESB_ENKUlRNS_11OpAsmParserERNS_14OperationStateEE_clESD_SF_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  312:  auto parseFn = [](OpAsmParser &parser, OperationState &result) {
    #####:  313:    return parser.emitError(
    #####:  314:        parser.getCurrentLocation(),
    #####:  315:        "dynamic operation do not define any parser function");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  316:  };
        -:  317:
   10216*:  318:  auto printFn = [](Operation *op, OpAsmPrinter &printer, StringRef) {
    #####:  319:    printer.printGenericOp(op);
call    0 never executed
        -:  320:  };
        -:  321:
    10216:  322:  return DynamicOpDefinition::get(name, dialect, std::move(verifyFn),
call    0 returned 100%
    10216:  323:                                  std::move(verifyRegionFn), std::move(parseFn),
call    0 returned 100%
call    1 returned 100%
    10216:  324:                                  std::move(printFn));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  325:}
        -:  326:
function _ZN4mlir19DynamicOpDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultEPNS_9OperationEEEESB_ONS5_IKFNS_11ParseResultERNS_11OpAsmParserERNS_14OperationStateEEEEONS5_IKFvS8_RNS_12OpAsmPrinterES2_EEE called 15324 returned 100% blocks executed 100%
    15324:  327:std::unique_ptr<DynamicOpDefinition> DynamicOpDefinition::get(
        -:  328:    StringRef name, ExtensibleDialect *dialect,
        -:  329:    OperationName::VerifyInvariantsFn &&verifyFn,
        -:  330:    OperationName::VerifyRegionInvariantsFn &&verifyRegionFn,
        -:  331:    OperationName::ParseAssemblyFn &&parseFn,
        -:  332:    OperationName::PrintAssemblyFn &&printFn) {
   15324*:  333:  auto foldHookFn = [](Operation *op, ArrayRef<Attribute> operands,
        -:  334:                       SmallVectorImpl<OpFoldResult> &results) {
    #####:  335:    return failure();
        -:  336:  };
        -:  337:
    15693:  338:  auto getCanonicalizationPatternsFn = [](RewritePatternSet &, MLIRContext *) {
        -:  339:  };
        -:  340:
   15324*:  341:  auto populateDefaultAttrsFn = [](const RegisteredOperationName &,
        -:  342:                                   NamedAttrList &) {};
        -:  343:
    15324:  344:  return DynamicOpDefinition::get(name, dialect, std::move(verifyFn),
call    0 returned 100%
    15324:  345:                                  std::move(verifyRegionFn), std::move(parseFn),
    15324:  346:                                  std::move(printFn), std::move(foldHookFn),
call    0 returned 100%
call    1 returned 100%
    15324:  347:                                  std::move(getCanonicalizationPatternsFn),
call    0 returned 100%
    15324:  348:                                  std::move(populateDefaultAttrsFn));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
        -:  349:}
        -:  350:
function _ZN4mlir19DynamicOpDefinition3getEN4llvm9StringRefEPNS_17ExtensibleDialectEONS1_15unique_functionIKFNS_13LogicalResultEPNS_9OperationEEEESB_ONS5_IKFNS_11ParseResultERNS_11OpAsmParserERNS_14OperationStateEEEEONS5_IKFvS8_RNS_12OpAsmPrinterES2_EEEONS5_IKFS6_S8_NS1_8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplINS_12OpFoldResultEEEEEEONS5_IKFvRNS_17RewritePatternSetEPNS_11MLIRContextEEEEONS5_IKFvRKNS_23RegisteredOperationNameERNS_13NamedAttrListEEEE called 15324 returned 100% blocks executed 100%
    15324:  351:std::unique_ptr<DynamicOpDefinition> DynamicOpDefinition::get(
        -:  352:    StringRef name, ExtensibleDialect *dialect,
        -:  353:    OperationName::VerifyInvariantsFn &&verifyFn,
        -:  354:    OperationName::VerifyInvariantsFn &&verifyRegionFn,
        -:  355:    OperationName::ParseAssemblyFn &&parseFn,
        -:  356:    OperationName::PrintAssemblyFn &&printFn,
        -:  357:    OperationName::FoldHookFn &&foldHookFn,
        -:  358:    OperationName::GetCanonicalizationPatternsFn
        -:  359:        &&getCanonicalizationPatternsFn,
        -:  360:    OperationName::PopulateDefaultAttrsFn &&populateDefaultAttrsFn) {
    15324:  361:  return std::unique_ptr<DynamicOpDefinition>(new DynamicOpDefinition(
    15324:  362:      name, dialect, std::move(verifyFn), std::move(verifyRegionFn),
    15324:  363:      std::move(parseFn), std::move(printFn), std::move(foldHookFn),
    15324:  364:      std::move(getCanonicalizationPatternsFn),
call    0 returned 100%
    15324:  365:      std::move(populateDefaultAttrsFn)));
call    0 returned 100%
call    1 returned 100%
        -:  366:}
        -:  367:
        -:  368://===----------------------------------------------------------------------===//
        -:  369:// Extensible dialect
        -:  370://===----------------------------------------------------------------------===//
        -:  371:
        -:  372:namespace {
        -:  373:/// Interface that can only be implemented by extensible dialects.
        -:  374:/// The interface is used to check if a dialect is extensible or not.
        -:  375:class IsExtensibleDialect : public DialectInterface::Base<IsExtensibleDialect> {
        -:  376:public:
        -:  377:  IsExtensibleDialect(Dialect *dialect) : Base(dialect) {}
        -:  378:
function _ZN12_GLOBAL__N_119IsExtensibleDialect13resolveTypeIDEv called 5108 returned 100% blocks executed 100%
     5108:  379:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IsExtensibleDialect)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
        -:  380:};
        -:  381:} // namespace
        -:  382:
function _ZN4mlir17ExtensibleDialectC2EN4llvm9StringRefEPNS_11MLIRContextENS_6TypeIDE called 5108 returned 100% blocks executed 100%
     5108:  383:ExtensibleDialect::ExtensibleDialect(StringRef name, MLIRContext *ctx,
     5108:  384:                                     TypeID typeID)
     5108:  385:    : Dialect(name, ctx, typeID) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     5108:  386:  addInterfaces<IsExtensibleDialect>();
call    0 returned 100%
     5108:  387:}
        -:  388:
function _ZN4mlir17ExtensibleDialect19registerDynamicTypeEOSt10unique_ptrINS_21DynamicTypeDefinitionESt14default_deleteIS2_EE called 15324 returned 100% blocks executed 82%
    15324:  389:void ExtensibleDialect::registerDynamicType(
        -:  390:    std::unique_ptr<DynamicTypeDefinition> &&type) {
    15324:  391:  DynamicTypeDefinition *typePtr = type.get();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  392:  TypeID typeID = type->getTypeID();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  393:  StringRef name = type->getName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  394:  ExtensibleDialect *dialect = type->getDialect();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  395:
   15324*:  396:  assert(dialect == this &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  397:         "trying to register a dynamic type in the wrong dialect");
        -:  398:
        -:  399:  // If a type with the same name is already defined, fail.
    15324:  400:  auto registered = dynTypes.try_emplace(typeID, std::move(type)).second;
call    0 returned 100%
    15324:  401:  (void)registered;
   15324*:  402:  assert(registered && "type TypeID was not unique");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  403:
    15324:  404:  registered = nameToDynTypes.insert({name, typePtr}).second;
call    0 returned 100%
    15324:  405:  (void)registered;
   15324*:  406:  assert(registered &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  407:         "Trying to create a new dynamic type with an existing name");
        -:  408:
    15324:  409:  auto abstractType =
call    0 returned 100%
    15324:  410:      AbstractType::get(*dialect, DynamicAttr::getInterfaceMap(),
call    0 returned 100%
    15324:  411:                        DynamicType::getHasTraitFn(), typeID);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  412:
        -:  413:  /// Add the type to the dialect and the type uniquer.
    15324:  414:  addType(typeID, std::move(abstractType));
call    0 returned 100%
    15324:  415:  typePtr->registerInTypeUniquer();
call    0 returned 100%
call    1 returned 100%
    15324:  416:}
        -:  417:
function _ZN4mlir17ExtensibleDialect19registerDynamicAttrEOSt10unique_ptrINS_21DynamicAttrDefinitionESt14default_deleteIS2_EE called 15324 returned 100% blocks executed 82%
    15324:  418:void ExtensibleDialect::registerDynamicAttr(
        -:  419:    std::unique_ptr<DynamicAttrDefinition> &&attr) {
    15324:  420:  auto *attrPtr = attr.get();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  421:  auto typeID = attr->getTypeID();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  422:  auto name = attr->getName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    15324:  423:  auto *dialect = attr->getDialect();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  424:
   15324*:  425:  assert(dialect == this &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  426:         "trying to register a dynamic attribute in the wrong dialect");
        -:  427:
        -:  428:  // If an attribute with the same name is already defined, fail.
    15324:  429:  auto registered = dynAttrs.try_emplace(typeID, std::move(attr)).second;
call    0 returned 100%
    15324:  430:  (void)registered;
   15324*:  431:  assert(registered && "attribute TypeID was not unique");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  432:
    15324:  433:  registered = nameToDynAttrs.insert({name, attrPtr}).second;
call    0 returned 100%
    15324:  434:  (void)registered;
   15324*:  435:  assert(registered &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  436:         "Trying to create a new dynamic attribute with an existing name");
        -:  437:
    15324:  438:  auto abstractAttr =
call    0 returned 100%
    15324:  439:      AbstractAttribute::get(*dialect, DynamicAttr::getInterfaceMap(),
call    0 returned 100%
    15324:  440:                             DynamicAttr::getHasTraitFn(), typeID);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  441:
        -:  442:  /// Add the type to the dialect and the type uniquer.
    15324:  443:  addAttribute(typeID, std::move(abstractAttr));
call    0 returned 100%
    15324:  444:  attrPtr->registerInAttrUniquer();
call    0 returned 100%
call    1 returned 100%
    15324:  445:}
        -:  446:
function _ZN4mlir17ExtensibleDialect17registerDynamicOpEOSt10unique_ptrINS_19DynamicOpDefinitionESt14default_deleteIS2_EE called 15324 returned 100% blocks executed 86%
    15324:  447:void ExtensibleDialect::registerDynamicOp(
        -:  448:    std::unique_ptr<DynamicOpDefinition> &&op) {
   15324*:  449:  assert(op->dialect == this &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  450:         "trying to register a dynamic op in the wrong dialect");
    15414:  451:  auto hasTraitFn = [](TypeID traitId) { return false; };
        -:  452:
    15324:  453:  RegisteredOperationName::insert(
call    0 returned 100%
call    1 returned 100%
    15324:  454:      op->name, *op->dialect, op->typeID, std::move(op->parseFn),
    15324:  455:      std::move(op->printFn), std::move(op->verifyFn),
    15324:  456:      std::move(op->verifyRegionFn), std::move(op->foldHookFn),
call    0 returned 100%
    15324:  457:      std::move(op->getCanonicalizationPatternsFn),
call    0 returned 100%
    15324:  458:      detail::InterfaceMap::get<>(), std::move(hasTraitFn), {},
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    15324:  459:      std::move(op->populateDefaultAttrsFn));
call    0 returned 100%
    15324:  460:}
        -:  461:
function _ZN4mlir17ExtensibleDialect7classofEPKNS_7DialectE called 0 returned 0% blocks executed 0%
    #####:  462:bool ExtensibleDialect::classof(const Dialect *dialect) {
    #####:  463:  return const_cast<Dialect *>(dialect)
    #####:  464:      ->getRegisteredInterface<IsExtensibleDialect>();
call    0 never executed
        -:  465:}
        -:  466:
function _ZNK4mlir17ExtensibleDialect24parseOptionalDynamicTypeEN4llvm9StringRefERNS_9AsmParserERNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  467:OptionalParseResult ExtensibleDialect::parseOptionalDynamicType(
        -:  468:    StringRef typeName, AsmParser &parser, Type &resultType) const {
    #####:  469:  DynamicTypeDefinition *typeDef = lookupTypeDefinition(typeName);
call    0 never executed
    #####:  470:  if (!typeDef)
branch  0 never executed
branch  1 never executed
    #####:  471:    return llvm::None;
        -:  472:
    #####:  473:  DynamicType dynType;
    #####:  474:  if (DynamicType::parse(parser, typeDef, dynType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  475:    return failure();
    #####:  476:  resultType = dynType;
    #####:  477:  return success();
        -:  478:}
        -:  479:
function _ZN4mlir17ExtensibleDialect18printIfDynamicTypeENS_4TypeERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  480:LogicalResult ExtensibleDialect::printIfDynamicType(Type type,
        -:  481:                                                    AsmPrinter &printer) {
    #####:  482:  if (auto dynType = type.dyn_cast<DynamicType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  483:    dynType.print(printer);
call    0 never executed
    #####:  484:    return success();
        -:  485:  }
    #####:  486:  return failure();
        -:  487:}
        -:  488:
function _ZNK4mlir17ExtensibleDialect24parseOptionalDynamicAttrEN4llvm9StringRefERNS_9AsmParserERNS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  489:OptionalParseResult ExtensibleDialect::parseOptionalDynamicAttr(
        -:  490:    StringRef attrName, AsmParser &parser, Attribute &resultAttr) const {
    #####:  491:  DynamicAttrDefinition *attrDef = lookupAttrDefinition(attrName);
call    0 never executed
    #####:  492:  if (!attrDef)
branch  0 never executed
branch  1 never executed
    #####:  493:    return llvm::None;
        -:  494:
    #####:  495:  DynamicAttr dynAttr;
    #####:  496:  if (DynamicAttr::parse(parser, attrDef, dynAttr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  497:    return failure();
    #####:  498:  resultAttr = dynAttr;
    #####:  499:  return success();
        -:  500:}
        -:  501:
function _ZN4mlir17ExtensibleDialect18printIfDynamicAttrENS_9AttributeERNS_10AsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  502:LogicalResult ExtensibleDialect::printIfDynamicAttr(Attribute attribute,
        -:  503:                                                    AsmPrinter &printer) {
    #####:  504:  if (auto dynAttr = attribute.dyn_cast<DynamicAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  505:    dynAttr.print(printer);
call    0 never executed
    #####:  506:    return success();
        -:  507:  }
    #####:  508:  return failure();
        -:  509:}
        -:  510:
        -:  511://===----------------------------------------------------------------------===//
        -:  512:// Dynamic dialect
        -:  513://===----------------------------------------------------------------------===//
        -:  514:
        -:  515:namespace {
        -:  516:/// Interface that can only be implemented by extensible dialects.
        -:  517:/// The interface is used to check if a dialect is extensible or not.
        -:  518:class IsDynamicDialect : public DialectInterface::Base<IsDynamicDialect> {
        -:  519:public:
        -:  520:  IsDynamicDialect(Dialect *dialect) : Base(dialect) {}
        -:  521:
function _ZN12_GLOBAL__N_116IsDynamicDialect13resolveTypeIDEv called 0 returned 0% blocks executed 0%
    #####:  522:  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(IsDynamicDialect)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  523:};
        -:  524:} // namespace
        -:  525:
function _ZN4mlir14DynamicDialectC2EN4llvm9StringRefEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  526:DynamicDialect::DynamicDialect(StringRef name, MLIRContext *ctx)
        -:  527:    : SelfOwningTypeID(),
    #####:  528:      ExtensibleDialect(name, ctx, SelfOwningTypeID::getTypeID()) {
call    0 never executed
    #####:  529:  addInterfaces<IsDynamicDialect>();
call    0 never executed
    #####:  530:}
        -:  531:
function _ZN4mlir14DynamicDialect7classofEPKNS_7DialectE called 0 returned 0% blocks executed 0%
    #####:  532:bool DynamicDialect::classof(const Dialect *dialect) {
    #####:  533:  return const_cast<Dialect *>(dialect)
    #####:  534:      ->getRegisteredInterface<IsDynamicDialect>();
call    0 never executed
        -:  535:}
        -:  536:
function _ZNK4mlir14DynamicDialect9parseTypeERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  537:Type DynamicDialect::parseType(DialectAsmParser &parser) const {
    #####:  538:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  539:  StringRef typeTag;
    #####:  540:  if (failed(parser.parseKeyword(&typeTag)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  541:    return Type();
        -:  542:
    #####:  543:  {
    #####:  544:    Type dynType;
    #####:  545:    auto parseResult = parseOptionalDynamicType(typeTag, parser, dynType);
call    0 never executed
    #####:  546:    if (parseResult.has_value()) {
branch  0 never executed
branch  1 never executed
    #####:  547:      if (succeeded(parseResult.value()))
branch  0 never executed
branch  1 never executed
    #####:  548:        return dynType;
    #####:  549:      return Type();
        -:  550:    }
        -:  551:  }
        -:  552:
    #####:  553:  parser.emitError(loc, "expected dynamic type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  554:  return Type();
        -:  555:}
        -:  556:
function _ZNK4mlir14DynamicDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  557:void DynamicDialect::printType(Type type, DialectAsmPrinter &printer) const {
    #####:  558:  auto wasDynamic = printIfDynamicType(type, printer);
call    0 never executed
    #####:  559:  (void)wasDynamic;
    #####:  560:  assert(succeeded(wasDynamic) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  561:         "non-dynamic type defined in dynamic dialect");
    #####:  562:}
        -:  563:
function _ZNK4mlir14DynamicDialect14parseAttributeERNS_16DialectAsmParserENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  564:Attribute DynamicDialect::parseAttribute(DialectAsmParser &parser,
        -:  565:                                         Type type) const {
    #####:  566:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  567:  StringRef typeTag;
    #####:  568:  if (failed(parser.parseKeyword(&typeTag)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  569:    return Attribute();
        -:  570:
    #####:  571:  {
    #####:  572:    Attribute dynAttr;
    #####:  573:    auto parseResult = parseOptionalDynamicAttr(typeTag, parser, dynAttr);
call    0 never executed
    #####:  574:    if (parseResult.has_value()) {
branch  0 never executed
branch  1 never executed
    #####:  575:      if (succeeded(parseResult.value()))
branch  0 never executed
branch  1 never executed
    #####:  576:        return dynAttr;
    #####:  577:      return Attribute();
        -:  578:    }
        -:  579:  }
        -:  580:
    #####:  581:  parser.emitError(loc, "expected dynamic attribute");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  582:  return Attribute();
        -:  583:}
function _ZNK4mlir14DynamicDialect14printAttributeENS_9AttributeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  584:void DynamicDialect::printAttribute(Attribute attr,
        -:  585:                                    DialectAsmPrinter &printer) const {
    #####:  586:  auto wasDynamic = printIfDynamicAttr(attr, printer);
call    0 never executed
    #####:  587:  (void)wasDynamic;
    #####:  588:  assert(succeeded(wasDynamic) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  589:         "non-dynamic attribute defined in dynamic dialect");
    #####:  590:}
