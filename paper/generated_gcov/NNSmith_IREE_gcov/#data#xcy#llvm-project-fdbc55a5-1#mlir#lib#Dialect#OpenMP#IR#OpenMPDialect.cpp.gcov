        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/OpenMP/IR/OpenMPDialect.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/OpenMP/CMakeFiles/obj.MLIROpenMPDialect.dir/IR/OpenMPDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/OpenMP/CMakeFiles/obj.MLIROpenMPDialect.dir/IR/OpenMPDialect.cpp.gcda
        -:    0:Runs:325549
        -:    1://===- OpenMPDialect.cpp - MLIR Dialect for OpenMP implementation ---------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the OpenMP dialect and its operations.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/OpenMP/OpenMPDialect.h"
        -:   14:#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
        -:   15:#include "mlir/IR/Attributes.h"
        -:   16:#include "mlir/IR/DialectImplementation.h"
        -:   17:#include "mlir/IR/OpImplementation.h"
        -:   18:#include "mlir/IR/OperationSupport.h"
        -:   19:
        -:   20:#include "llvm/ADT/BitVector.h"
        -:   21:#include "llvm/ADT/SmallString.h"
        -:   22:#include "llvm/ADT/StringExtras.h"
        -:   23:#include "llvm/ADT/StringRef.h"
        -:   24:#include "llvm/ADT/TypeSwitch.h"
        -:   25:#include <cstddef>
        -:   26:
        -:   27:#include "mlir/Dialect/OpenMP/OpenMPOpsDialect.cpp.inc"
        -:   28:#include "mlir/Dialect/OpenMP/OpenMPOpsEnums.cpp.inc"
        -:   29:#include "mlir/Dialect/OpenMP/OpenMPOpsInterfaces.cpp.inc"
        -:   30:#include "mlir/Dialect/OpenMP/OpenMPTypeInterfaces.cpp.inc"
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace mlir::omp;
        -:   34:
        -:   35:namespace {
        -:   36:/// Model for pointer-like types that already provide a `getElementType` method.
        -:   37:template <typename T>
     2090:   38:struct PointerLikeModel
call    0 returned 100%
call    1 returned 100%
        -:   39:    : public PointerLikeType::ExternalModel<PointerLikeModel<T>, T> {
        -:   40:  Type getElementType(Type pointer) const {
        -:   41:    return pointer.cast<T>().getElementType();
        -:   42:  }
        -:   43:};
        -:   44:} // namespace
        -:   45:
function _ZN4mlir3omp13OpenMPDialect10initializeEv called 1045 returned 100% blocks executed 100%
     1045:   46:void OpenMPDialect::initialize() {
     1045:   47:  addOperations<
        -:   48:#define GET_OP_LIST
        -:   49:#include "mlir/Dialect/OpenMP/OpenMPOps.cpp.inc"
     1045:   50:      >();
call    0 returned 100%
     1045:   51:  addAttributes<
        -:   52:#define GET_ATTRDEF_LIST
        -:   53:#include "mlir/Dialect/OpenMP/OpenMPOpsAttributes.cpp.inc"
     1045:   54:      >();
call    0 returned 100%
        -:   55:
     1045:   56:  LLVM::LLVMPointerType::attachInterface<
     1045:   57:      PointerLikeModel<LLVM::LLVMPointerType>>(*getContext());
call    0 returned 100%
     1045:   58:  MemRefType::attachInterface<PointerLikeModel<MemRefType>>(*getContext());
call    0 returned 100%
     1045:   59:}
        -:   60:
        -:   61://===----------------------------------------------------------------------===//
        -:   62:// Parser and printer for Allocate Clause
        -:   63://===----------------------------------------------------------------------===//
        -:   64:
        -:   65:/// Parse an allocate clause with allocators and a list of operands with types.
        -:   66:///
        -:   67:/// allocate-operand-list :: = allocate-operand |
        -:   68:///                            allocator-operand `,` allocate-operand-list
        -:   69:/// allocate-operand :: = ssa-id-and-type -> ssa-id-and-type
        -:   70:/// ssa-id-and-type ::= ssa-id `:` type
    #####:   71:static ParseResult parseAllocateAndAllocator(
        -:   72:    OpAsmParser &parser,
        -:   73:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &operandsAllocate,
        -:   74:    SmallVectorImpl<Type> &typesAllocate,
        -:   75:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &operandsAllocator,
        -:   76:    SmallVectorImpl<Type> &typesAllocator) {
        -:   77:
function _ZZL25parseAllocateAndAllocatorRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEES6_S9_ENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:   78:  return parser.parseCommaSeparatedList([&]() {
    #####:   79:    OpAsmParser::UnresolvedOperand operand;
call    0 never executed
    #####:   80:    Type type;
    #####:   81:    if (parser.parseOperand(operand) || parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   82:      return failure();
    #####:   83:    operandsAllocator.push_back(operand);
call    0 never executed
    #####:   84:    typesAllocator.push_back(type);
call    0 never executed
    #####:   85:    if (parser.parseArrow())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   86:      return failure();
    #####:   87:    if (parser.parseOperand(operand) || parser.parseColonType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   88:      return failure();
        -:   89:
    #####:   90:    operandsAllocate.push_back(operand);
call    0 never executed
    #####:   91:    typesAllocate.push_back(type);
call    0 never executed
    #####:   92:    return success();
    #####:   93:  });
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
        -:   94:}
        -:   95:
        -:   96:/// Print allocate clause
        -:   97:static void printAllocateAndAllocator(OpAsmPrinter &p, Operation *op,
        -:   98:                                      OperandRange varsAllocate,
        -:   99:                                      TypeRange typesAllocate,
        -:  100:                                      OperandRange varsAllocator,
        -:  101:                                      TypeRange typesAllocator) {
        -:  102:  for (unsigned i = 0; i < varsAllocate.size(); ++i) {
        -:  103:    std::string separator = i == varsAllocate.size() - 1 ? "" : ", ";
        -:  104:    p << varsAllocator[i] << " : " << typesAllocator[i] << " -> ";
        -:  105:    p << varsAllocate[i] << " : " << typesAllocate[i] << separator;
        -:  106:  }
        -:  107:}
        -:  108:
        -:  109://===----------------------------------------------------------------------===//
        -:  110:// Parser and printer for a clause attribute (StringEnumAttr)
        -:  111://===----------------------------------------------------------------------===//
        -:  112:
        -:  113:template <typename ClauseAttr>
    #####:  114:static ParseResult parseClauseAttr(AsmParser &parser, ClauseAttr &attr) {
        -:  115:  using ClauseT = decltype(std::declval<ClauseAttr>().getValue());
    #####:  116:  StringRef enumStr;
    #####:  117:  SMLoc loc = parser.getCurrentLocation();
    #####:  118:  if (parser.parseKeyword(&enumStr))
    #####:  119:    return failure();
    #####:  120:  if (Optional<ClauseT> enumValue = symbolizeEnum<ClauseT>(enumStr)) {
    #####:  121:    attr = ClauseAttr::get(parser.getContext(), *enumValue);
    #####:  122:    return success();
        -:  123:  }
    #####:  124:  return parser.emitError(loc, "invalid clause value: '") << enumStr << "'";
        -:  125:}
------------------
_Z15parseClauseAttrIN4mlir3omp19ClauseOrderKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_:
function _Z15parseClauseAttrIN4mlir3omp19ClauseOrderKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_ called 0 returned 0% blocks executed 0%
    #####:  114:static ParseResult parseClauseAttr(AsmParser &parser, ClauseAttr &attr) {
        -:  115:  using ClauseT = decltype(std::declval<ClauseAttr>().getValue());
    #####:  116:  StringRef enumStr;
    #####:  117:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  118:  if (parser.parseKeyword(&enumStr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return failure();
    #####:  120:  if (Optional<ClauseT> enumValue = symbolizeEnum<ClauseT>(enumStr)) {
branch  0 never executed
branch  1 never executed
    #####:  121:    attr = ClauseAttr::get(parser.getContext(), *enumValue);
call    0 never executed
call    1 never executed
    #####:  122:    return success();
        -:  123:  }
    #####:  124:  return parser.emitError(loc, "invalid clause value: '") << enumStr << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  125:}
------------------
_Z15parseClauseAttrIN4mlir3omp22ClauseProcBindKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_:
function _Z15parseClauseAttrIN4mlir3omp22ClauseProcBindKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_ called 0 returned 0% blocks executed 0%
    #####:  114:static ParseResult parseClauseAttr(AsmParser &parser, ClauseAttr &attr) {
        -:  115:  using ClauseT = decltype(std::declval<ClauseAttr>().getValue());
    #####:  116:  StringRef enumStr;
    #####:  117:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  118:  if (parser.parseKeyword(&enumStr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return failure();
    #####:  120:  if (Optional<ClauseT> enumValue = symbolizeEnum<ClauseT>(enumStr)) {
branch  0 never executed
branch  1 never executed
    #####:  121:    attr = ClauseAttr::get(parser.getContext(), *enumValue);
call    0 never executed
call    1 never executed
    #####:  122:    return success();
        -:  123:  }
    #####:  124:  return parser.emitError(loc, "invalid clause value: '") << enumStr << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  125:}
------------------
_Z15parseClauseAttrIN4mlir3omp35ClauseCancellationConstructTypeAttrEENS0_11ParseResultERNS0_9AsmParserERT_:
function _Z15parseClauseAttrIN4mlir3omp35ClauseCancellationConstructTypeAttrEENS0_11ParseResultERNS0_9AsmParserERT_ called 0 returned 0% blocks executed 0%
    #####:  114:static ParseResult parseClauseAttr(AsmParser &parser, ClauseAttr &attr) {
        -:  115:  using ClauseT = decltype(std::declval<ClauseAttr>().getValue());
    #####:  116:  StringRef enumStr;
    #####:  117:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  118:  if (parser.parseKeyword(&enumStr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return failure();
    #####:  120:  if (Optional<ClauseT> enumValue = symbolizeEnum<ClauseT>(enumStr)) {
branch  0 never executed
branch  1 never executed
    #####:  121:    attr = ClauseAttr::get(parser.getContext(), *enumValue);
call    0 never executed
call    1 never executed
    #####:  122:    return success();
        -:  123:  }
    #####:  124:  return parser.emitError(loc, "invalid clause value: '") << enumStr << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  125:}
------------------
_Z15parseClauseAttrIN4mlir3omp25ClauseMemoryOrderKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_:
function _Z15parseClauseAttrIN4mlir3omp25ClauseMemoryOrderKindAttrEENS0_11ParseResultERNS0_9AsmParserERT_ called 0 returned 0% blocks executed 0%
    #####:  114:static ParseResult parseClauseAttr(AsmParser &parser, ClauseAttr &attr) {
        -:  115:  using ClauseT = decltype(std::declval<ClauseAttr>().getValue());
    #####:  116:  StringRef enumStr;
    #####:  117:  SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  118:  if (parser.parseKeyword(&enumStr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return failure();
    #####:  120:  if (Optional<ClauseT> enumValue = symbolizeEnum<ClauseT>(enumStr)) {
branch  0 never executed
branch  1 never executed
    #####:  121:    attr = ClauseAttr::get(parser.getContext(), *enumValue);
call    0 never executed
call    1 never executed
    #####:  122:    return success();
        -:  123:  }
    #####:  124:  return parser.emitError(loc, "invalid clause value: '") << enumStr << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  125:}
------------------
        -:  126:
        -:  127:template <typename ClauseAttr>
        -:  128:void printClauseAttr(OpAsmPrinter &p, Operation *op, ClauseAttr attr) {
        -:  129:  p << stringifyEnum(attr.getValue());
        -:  130:}
        -:  131:
        -:  132://===----------------------------------------------------------------------===//
        -:  133:// Parser and printer for Linear Clause
        -:  134://===----------------------------------------------------------------------===//
        -:  135:
        -:  136:/// linear ::= `linear` `(` linear-list `)`
        -:  137:/// linear-list := linear-val | linear-val linear-list
        -:  138:/// linear-val := ssa-id-and-type `=` ssa-id-and-type
        -:  139:static ParseResult
    #####:  140:parseLinearClause(OpAsmParser &parser,
        -:  141:                  SmallVectorImpl<OpAsmParser::UnresolvedOperand> &vars,
        -:  142:                  SmallVectorImpl<Type> &types,
        -:  143:                  SmallVectorImpl<OpAsmParser::UnresolvedOperand> &stepVars) {
function _ZZL17parseLinearClauseRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEES6_ENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  144:  return parser.parseCommaSeparatedList([&]() {
    #####:  145:    OpAsmParser::UnresolvedOperand var;
call    0 never executed
    #####:  146:    Type type;
    #####:  147:    OpAsmParser::UnresolvedOperand stepVar;
    #####:  148:    if (parser.parseOperand(var) || parser.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  149:        parser.parseOperand(stepVar) || parser.parseColonType(type))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  150:      return failure();
        -:  151:
    #####:  152:    vars.push_back(var);
call    0 never executed
    #####:  153:    types.push_back(type);
call    0 never executed
    #####:  154:    stepVars.push_back(stepVar);
call    0 never executed
    #####:  155:    return success();
    #####:  156:  });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  157:}
        -:  158:
        -:  159:/// Print Linear Clause
        -:  160:static void printLinearClause(OpAsmPrinter &p, Operation *op,
        -:  161:                              ValueRange linearVars, TypeRange linearVarTypes,
        -:  162:                              ValueRange linearStepVars) {
        -:  163:  size_t linearVarsSize = linearVars.size();
        -:  164:  for (unsigned i = 0; i < linearVarsSize; ++i) {
        -:  165:    std::string separator = i == linearVarsSize - 1 ? "" : ", ";
        -:  166:    p << linearVars[i];
        -:  167:    if (linearStepVars.size() > i)
        -:  168:      p << " = " << linearStepVars[i];
        -:  169:    p << " : " << linearVars[i].getType() << separator;
        -:  170:  }
        -:  171:}
        -:  172:
        -:  173://===----------------------------------------------------------------------===//
        -:  174:// Parser, verifier and printer for Aligned Clause
        -:  175://===----------------------------------------------------------------------===//
function _ZL19verifyAlignedClausePN4mlir9OperationEN4llvm8OptionalINS_9ArrayAttrEEENS_12OperandRangeE called 0 returned 0% blocks executed 0%
    #####:  176:static LogicalResult verifyAlignedClause(Operation *op,
        -:  177:                                         Optional<ArrayAttr> alignmentValues,
        -:  178:                                         OperandRange alignedVariables) {
        -:  179:  // Check if number of alignment values equals to number of aligned variables
    #####:  180:  if (!alignedVariables.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  181:    if (!alignmentValues || alignmentValues->size() != alignedVariables.size())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  182:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  183:             << "expected as many alignment values as aligned variables";
call    0 never executed
        -:  184:  } else {
    #####:  185:    if (alignmentValues)
branch  0 never executed
branch  1 never executed
    #####:  186:      return op->emitOpError() << "unexpected alignment values attribute";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  187:    return success();
        -:  188:  }
        -:  189:
        -:  190:  // Check if each var is aligned only once - OpenMP 4.5 -> 2.8.1 section
    #####:  191:  DenseSet<Value> alignedItems;
call    0 never executed
    #####:  192:  for (auto it : alignedVariables)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  193:    if (!alignedItems.insert(it).second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:      return op->emitOpError() << "aligned variable used more than once";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  195:
    #####:  196:  if (!alignmentValues)
branch  0 never executed
branch  1 never executed
    #####:  197:    return success();
        -:  198:
        -:  199:  // Check if all alignment values are positive - OpenMP 4.5 -> 2.8.1 section
    #####:  200:  for (unsigned i = 0; i < (*alignmentValues).size(); ++i) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  201:    if (auto intAttr = (*alignmentValues)[i].dyn_cast<IntegerAttr>()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  202:      if (intAttr.getValue().sle(0))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  203:        return op->emitOpError() << "alignment should be greater than 0";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  204:    } else {
    #####:  205:      return op->emitOpError() << "expected integer alignment";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  206:    }
        -:  207:  }
        -:  208:
    #####:  209:  return success();
call    0 never executed
        -:  210:}
        -:  211:
        -:  212:/// aligned ::= `aligned` `(` aligned-list `)`
        -:  213:/// aligned-list := aligned-val | aligned-val aligned-list
        -:  214:/// aligned-val := ssa-id-and-type `->` alignment
function _ZL18parseAlignedClauseRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEERNS_9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####:  215:static ParseResult parseAlignedClause(
        -:  216:    OpAsmParser &parser,
        -:  217:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &alignedItems,
        -:  218:    SmallVectorImpl<Type> &types, ArrayAttr &alignmentValues) {
    #####:  219:  SmallVector<Attribute> alignmentVec;
call    0 never executed
function _ZZL18parseAlignedClauseRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEERNS_9ArrayAttrEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  220:  if (failed(parser.parseCommaSeparatedList([&]() {
branch  0 never executed
branch  1 never executed
    #####:  221:        if (parser.parseOperand(alignedItems.emplace_back()) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  222:            parser.parseColonType(types.emplace_back()) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  223:            parser.parseArrow() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  224:            parser.parseAttribute(alignmentVec.emplace_back())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  225:          return failure();
        -:  226:        }
    #####:  227:        return success();
    #####:  228:      })))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  229:    return failure();
    #####:  230:  SmallVector<Attribute> alignments(alignmentVec.begin(), alignmentVec.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  231:  alignmentValues = ArrayAttr::get(parser.getContext(), alignments);
call    0 never executed
call    1 never executed
    #####:  232:  return success();
branch  0 never executed
branch  1 never executed
        -:  233:}
        -:  234:
        -:  235:/// Print Aligned Clause
        -:  236:static void printAlignedClause(OpAsmPrinter &p, Operation *op,
        -:  237:                               ValueRange alignedVars,
        -:  238:                               TypeRange alignedVarTypes,
        -:  239:                               Optional<ArrayAttr> alignmentValues) {
        -:  240:  for (unsigned i = 0; i < alignedVars.size(); ++i) {
        -:  241:    if (i != 0)
        -:  242:      p << ", ";
        -:  243:    p << alignedVars[i] << " : " << alignedVars[i].getType();
        -:  244:    p << " -> " << (*alignmentValues)[i];
        -:  245:  }
        -:  246:}
        -:  247:
        -:  248://===----------------------------------------------------------------------===//
        -:  249:// Parser, printer and verifier for Schedule Clause
        -:  250://===----------------------------------------------------------------------===//
        -:  251:
        -:  252:static ParseResult
function _ZL23verifyScheduleModifiersRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS2_11SmallStringILj12EEEEE called 0 returned 0% blocks executed 0%
    #####:  253:verifyScheduleModifiers(OpAsmParser &parser,
        -:  254:                        SmallVectorImpl<SmallString<12>> &modifiers) {
    #####:  255:  if (modifiers.size() > 2)
branch  0 never executed
branch  1 never executed
    #####:  256:    return parser.emitError(parser.getNameLoc()) << " unexpected modifier(s)";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  257:  for (const auto &mod : modifiers) {
branch  0 never executed
branch  1 never executed
        -:  258:    // Translate the string. If it has no value, then it was not a valid
        -:  259:    // modifier!
    #####:  260:    auto symbol = symbolizeScheduleModifier(mod);
call    0 never executed
    #####:  261:    if (!symbol)
branch  0 never executed
branch  1 never executed
    #####:  262:      return parser.emitError(parser.getNameLoc())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  263:             << " unknown modifier type: " << mod;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  264:  }
        -:  265:
        -:  266:  // If we have one modifier that is "simd", then stick a "none" modiifer in
        -:  267:  // index 0.
    #####:  268:  if (modifiers.size() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  269:    if (symbolizeScheduleModifier(modifiers[0]) == ScheduleModifier::simd) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  270:      modifiers.push_back(modifiers[0]);
branch  0 never executed
branch  1 never executed
    #####:  271:      modifiers[0] = stringifyScheduleModifier(ScheduleModifier::none);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  272:    }
    #####:  273:  } else if (modifiers.size() == 2) {
branch  0 never executed
branch  1 never executed
        -:  274:    // If there are two modifier:
        -:  275:    // First modifier should not be simd, second one should be simd
    #####:  276:    if (symbolizeScheduleModifier(modifiers[0]) == ScheduleModifier::simd ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  277:        symbolizeScheduleModifier(modifiers[1]) != ScheduleModifier::simd)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  278:      return parser.emitError(parser.getNameLoc())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  279:             << " incorrect modifier order";
call    0 never executed
call    1 never executed
        -:  280:  }
    #####:  281:  return success();
        -:  282:}
        -:  283:
        -:  284:/// schedule ::= `schedule` `(` sched-list `)`
        -:  285:/// sched-list ::= sched-val | sched-val sched-list |
        -:  286:///                sched-val `,` sched-modifier
        -:  287:/// sched-val ::= sched-with-chunk | sched-wo-chunk
        -:  288:/// sched-with-chunk ::= sched-with-chunk-types (`=` ssa-id-and-type)?
        -:  289:/// sched-with-chunk-types ::= `static` | `dynamic` | `guided`
        -:  290:/// sched-wo-chunk ::=  `auto` | `runtime`
        -:  291:/// sched-modifier ::=  sched-mod-val | sched-mod-val `,` sched-mod-val
        -:  292:/// sched-mod-val ::=  `monotonic` | `nonmonotonic` | `simd` | `none`
function _ZL19parseScheduleClauseRN4mlir11OpAsmParserERNS_3omp22ClauseScheduleKindAttrERNS2_20ScheduleModifierAttrERNS_8UnitAttrERN4llvm8OptionalINS0_17UnresolvedOperandEEERNS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  293:static ParseResult parseScheduleClause(
        -:  294:    OpAsmParser &parser, ClauseScheduleKindAttr &scheduleAttr,
        -:  295:    ScheduleModifierAttr &scheduleModifier, UnitAttr &simdModifier,
        -:  296:    Optional<OpAsmParser::UnresolvedOperand> &chunkSize, Type &chunkType) {
    #####:  297:  StringRef keyword;
    #####:  298:  if (parser.parseKeyword(&keyword))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  299:    return failure();
    #####:  300:  llvm::Optional<mlir::omp::ClauseScheduleKind> schedule =
    #####:  301:      symbolizeClauseScheduleKind(keyword);
call    0 never executed
    #####:  302:  if (!schedule)
branch  0 never executed
branch  1 never executed
    #####:  303:    return parser.emitError(parser.getNameLoc()) << " expected schedule kind";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  304:
    #####:  305:  scheduleAttr = ClauseScheduleKindAttr::get(parser.getContext(), *schedule);
call    0 never executed
call    1 never executed
    #####:  306:  switch (*schedule) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  307:  case ClauseScheduleKind::Static:
    #####:  308:  case ClauseScheduleKind::Dynamic:
    #####:  309:  case ClauseScheduleKind::Guided:
    #####:  310:    if (succeeded(parser.parseOptionalEqual())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  311:      chunkSize = OpAsmParser::UnresolvedOperand{};
branch  0 never executed
branch  1 never executed
    #####:  312:      if (parser.parseOperand(*chunkSize) || parser.parseColonType(chunkType))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  313:        return failure();
        -:  314:    } else {
    #####:  315:      chunkSize = llvm::NoneType::None;
        -:  316:    }
        -:  317:    break;
    #####:  318:  case ClauseScheduleKind::Auto:
    #####:  319:  case ClauseScheduleKind::Runtime:
    #####:  320:    chunkSize = llvm::NoneType::None;
        -:  321:  }
        -:  322:
        -:  323:  // If there is a comma, we have one or more modifiers..
    #####:  324:  SmallVector<SmallString<12>> modifiers;
call    0 never executed
    #####:  325:  while (succeeded(parser.parseOptionalComma())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  326:    StringRef mod;
    #####:  327:    if (parser.parseKeyword(&mod))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  328:      return failure();
    #####:  329:    modifiers.push_back(mod);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  330:  }
        -:  331:
    #####:  332:  if (verifyScheduleModifiers(parser, modifiers))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  333:    return failure();
        -:  334:
    #####:  335:  if (!modifiers.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  336:    SMLoc loc = parser.getCurrentLocation();
call    0 never executed
    #####:  337:    if (Optional<ScheduleModifier> mod =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  338:            symbolizeScheduleModifier(modifiers[0])) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  339:      scheduleModifier = ScheduleModifierAttr::get(parser.getContext(), *mod);
call    0 never executed
call    1 never executed
        -:  340:    } else {
    #####:  341:      return parser.emitError(loc, "invalid schedule modifier");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  342:    }
        -:  343:    // Only SIMD attribute is allowed here!
    #####:  344:    if (modifiers.size() > 1) {
branch  0 never executed
branch  1 never executed
    #####:  345:      assert(symbolizeScheduleModifier(modifiers[1]) == ScheduleModifier::simd);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  346:      simdModifier = UnitAttr::get(parser.getBuilder().getContext());
call    0 never executed
call    1 never executed
        -:  347:    }
        -:  348:  }
        -:  349:
    #####:  350:  return success();
        -:  351:}
        -:  352:
        -:  353:/// Print schedule clause
        -:  354:static void printScheduleClause(OpAsmPrinter &p, Operation *op,
        -:  355:                                ClauseScheduleKindAttr schedAttr,
        -:  356:                                ScheduleModifierAttr modifier, UnitAttr simd,
        -:  357:                                Value scheduleChunkVar,
        -:  358:                                Type scheduleChunkType) {
        -:  359:  p << stringifyClauseScheduleKind(schedAttr.getValue());
        -:  360:  if (scheduleChunkVar)
        -:  361:    p << " = " << scheduleChunkVar << " : " << scheduleChunkVar.getType();
        -:  362:  if (modifier)
        -:  363:    p << ", " << stringifyScheduleModifier(modifier.getValue());
        -:  364:  if (simd)
        -:  365:    p << ", simd";
        -:  366:}
        -:  367:
        -:  368://===----------------------------------------------------------------------===//
        -:  369:// Parser, printer and verifier for ReductionVarList
        -:  370://===----------------------------------------------------------------------===//
        -:  371:
        -:  372:/// reduction-entry-list ::= reduction-entry
        -:  373:///                        | reduction-entry-list `,` reduction-entry
        -:  374:/// reduction-entry ::= symbol-ref `->` ssa-id `:` type
        -:  375:static ParseResult
function _ZL21parseReductionVarListRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEERNS_9ArrayAttrE called 0 returned 0% blocks executed 0%
    #####:  376:parseReductionVarList(OpAsmParser &parser,
        -:  377:                      SmallVectorImpl<OpAsmParser::UnresolvedOperand> &operands,
        -:  378:                      SmallVectorImpl<Type> &types,
        -:  379:                      ArrayAttr &redcuctionSymbols) {
    #####:  380:  SmallVector<SymbolRefAttr> reductionVec;
call    0 never executed
function _ZZL21parseReductionVarListRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEERNS_9ArrayAttrEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  381:  if (failed(parser.parseCommaSeparatedList([&]() {
branch  0 never executed
branch  1 never executed
    #####:  382:        if (parser.parseAttribute(reductionVec.emplace_back()) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  383:            parser.parseArrow() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  384:            parser.parseOperand(operands.emplace_back()) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  385:            parser.parseColonType(types.emplace_back()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  386:          return failure();
    #####:  387:        return success();
    #####:  388:      })))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  389:    return failure();
    #####:  390:  SmallVector<Attribute> reductions(reductionVec.begin(), reductionVec.end());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  391:  redcuctionSymbols = ArrayAttr::get(parser.getContext(), reductions);
call    0 never executed
call    1 never executed
    #####:  392:  return success();
branch  0 never executed
branch  1 never executed
        -:  393:}
        -:  394:
        -:  395:/// Print Reduction clause
        -:  396:static void printReductionVarList(OpAsmPrinter &p, Operation *op,
        -:  397:                                  OperandRange reductionVars,
        -:  398:                                  TypeRange reductionTypes,
        -:  399:                                  Optional<ArrayAttr> reductions) {
        -:  400:  for (unsigned i = 0, e = reductions->size(); i < e; ++i) {
        -:  401:    if (i != 0)
        -:  402:      p << ", ";
        -:  403:    p << (*reductions)[i] << " -> " << reductionVars[i] << " : "
        -:  404:      << reductionVars[i].getType();
        -:  405:  }
        -:  406:}
        -:  407:
        -:  408:/// Verifies Reduction Clause
function _ZL22verifyReductionVarListPN4mlir9OperationEN4llvm8OptionalINS_9ArrayAttrEEENS_12OperandRangeE called 0 returned 0% blocks executed 0%
    #####:  409:static LogicalResult verifyReductionVarList(Operation *op,
        -:  410:                                            Optional<ArrayAttr> reductions,
        -:  411:                                            OperandRange reductionVars) {
    #####:  412:  if (!reductionVars.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  413:    if (!reductions || reductions->size() != reductionVars.size())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  414:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  415:             << "expected as many reduction symbol references "
    #####:  416:                "as reduction variables";
call    0 never executed
        -:  417:  } else {
    #####:  418:    if (reductions)
branch  0 never executed
branch  1 never executed
    #####:  419:      return op->emitOpError() << "unexpected reduction symbol references";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  420:    return success();
        -:  421:  }
        -:  422:
        -:  423:  // TODO: The followings should be done in
        -:  424:  // SymbolUserOpInterface::verifySymbolUses.
    #####:  425:  DenseSet<Value> accumulators;
call    0 never executed
    #####:  426:  for (auto args : llvm::zip(reductionVars, *reductions)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  427:    Value accum = std::get<0>(args);
call    0 never executed
        -:  428:
    #####:  429:    if (!accumulators.insert(accum).second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  430:      return op->emitOpError() << "accumulator variable used more than once";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  431:
    #####:  432:    Type varType = accum.getType().cast<PointerLikeType>();
call    0 never executed
    #####:  433:    auto symbolRef = std::get<1>(args).cast<SymbolRefAttr>();
call    0 never executed
    #####:  434:    auto decl =
    #####:  435:        SymbolTable::lookupNearestSymbolFrom<ReductionDeclareOp>(op, symbolRef);
call    0 never executed
    #####:  436:    if (!decl)
branch  0 never executed
branch  1 never executed
    #####:  437:      return op->emitOpError() << "expected symbol reference " << symbolRef
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  438:                               << " to point to a reduction declaration";
call    0 never executed
        -:  439:
    #####:  440:    if (decl.getAccumulatorType() && decl.getAccumulatorType() != varType)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  441:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  442:             << "expected accumulator (" << varType
call    0 never executed
call    1 never executed
    #####:  443:             << ") to be the same type as reduction declaration ("
    #####:  444:             << decl.getAccumulatorType() << ")";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  445:  }
        -:  446:
    #####:  447:  return success();
call    0 never executed
        -:  448:}
        -:  449:
        -:  450://===----------------------------------------------------------------------===//
        -:  451:// Parser, printer and verifier for Synchronization Hint (2.17.12)
        -:  452://===----------------------------------------------------------------------===//
        -:  453:
        -:  454:/// Parses a Synchronization Hint clause. The value of hint is an integer
        -:  455:/// which is a combination of different hints from `omp_sync_hint_t`.
        -:  456:///
        -:  457:/// hint-clause = `hint` `(` hint-value `)`
function _ZL24parseSynchronizationHintRN4mlir11OpAsmParserERNS_11IntegerAttrE called 0 returned 0% blocks executed 0%
    #####:  458:static ParseResult parseSynchronizationHint(OpAsmParser &parser,
        -:  459:                                            IntegerAttr &hintAttr) {
    #####:  460:  StringRef hintKeyword;
    #####:  461:  int64_t hint = 0;
    #####:  462:  if (succeeded(parser.parseOptionalKeyword("none"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  463:    hintAttr = IntegerAttr::get(parser.getBuilder().getI64Type(), 0);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  464:    return success();
        -:  465:  }
function _ZZL24parseSynchronizationHintRN4mlir11OpAsmParserERNS_11IntegerAttrEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  466:  auto parseKeyword = [&]() -> ParseResult {
    #####:  467:    if (failed(parser.parseKeyword(&hintKeyword)))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  468:      return failure();
    #####:  469:    if (hintKeyword == "uncontended")
branch  0 never executed
branch  1 never executed
    #####:  470:      hint |= 1;
    #####:  471:    else if (hintKeyword == "contended")
branch  0 never executed
branch  1 never executed
    #####:  472:      hint |= 2;
    #####:  473:    else if (hintKeyword == "nonspeculative")
branch  0 never executed
branch  1 never executed
    #####:  474:      hint |= 4;
    #####:  475:    else if (hintKeyword == "speculative")
branch  0 never executed
branch  1 never executed
    #####:  476:      hint |= 8;
        -:  477:    else
    #####:  478:      return parser.emitError(parser.getCurrentLocation())
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  479:             << hintKeyword << " is not a valid hint";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  480:    return success();
    #####:  481:  };
    #####:  482:  if (parser.parseCommaSeparatedList(parseKeyword))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  483:    return failure();
    #####:  484:  hintAttr = IntegerAttr::get(parser.getBuilder().getI64Type(), hint);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  485:  return success();
        -:  486:}
        -:  487:
        -:  488:/// Prints a Synchronization Hint clause
        -:  489:static void printSynchronizationHint(OpAsmPrinter &p, Operation *op,
        -:  490:                                     IntegerAttr hintAttr) {
        -:  491:  int64_t hint = hintAttr.getInt();
        -:  492:
        -:  493:  if (hint == 0) {
        -:  494:    p << "none";
        -:  495:    return;
        -:  496:  }
        -:  497:
        -:  498:  // Helper function to get n-th bit from the right end of `value`
        -:  499:  auto bitn = [](int value, int n) -> bool { return value & (1 << n); };
        -:  500:
        -:  501:  bool uncontended = bitn(hint, 0);
        -:  502:  bool contended = bitn(hint, 1);
        -:  503:  bool nonspeculative = bitn(hint, 2);
        -:  504:  bool speculative = bitn(hint, 3);
        -:  505:
        -:  506:  SmallVector<StringRef> hints;
        -:  507:  if (uncontended)
        -:  508:    hints.push_back("uncontended");
        -:  509:  if (contended)
        -:  510:    hints.push_back("contended");
        -:  511:  if (nonspeculative)
        -:  512:    hints.push_back("nonspeculative");
        -:  513:  if (speculative)
        -:  514:    hints.push_back("speculative");
        -:  515:
        -:  516:  llvm::interleaveComma(hints, p);
        -:  517:}
        -:  518:
        -:  519:/// Verifies a synchronization hint clause
function _ZL25verifySynchronizationHintPN4mlir9OperationEm called 0 returned 0% blocks executed 0%
    #####:  520:static LogicalResult verifySynchronizationHint(Operation *op, uint64_t hint) {
        -:  521:
        -:  522:  // Helper function to get n-th bit from the right end of `value`
    #####:  523:  auto bitn = [](int value, int n) -> bool { return value & (1 << n); };
        -:  524:
    #####:  525:  bool uncontended = bitn(hint, 0);
    #####:  526:  bool contended = bitn(hint, 1);
    #####:  527:  bool nonspeculative = bitn(hint, 2);
    #####:  528:  bool speculative = bitn(hint, 3);
        -:  529:
    #####:  530:  if (uncontended && contended)
branch  0 never executed
branch  1 never executed
    #####:  531:    return op->emitOpError() << "the hints omp_sync_hint_uncontended and "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  532:                                "omp_sync_hint_contended cannot be combined";
call    0 never executed
    #####:  533:  if (nonspeculative && speculative)
branch  0 never executed
branch  1 never executed
    #####:  534:    return op->emitOpError() << "the hints omp_sync_hint_nonspeculative and "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  535:                                "omp_sync_hint_speculative cannot be combined.";
call    0 never executed
    #####:  536:  return success();
        -:  537:}
        -:  538:
        -:  539://===----------------------------------------------------------------------===//
        -:  540:// ParallelOp
        -:  541://===----------------------------------------------------------------------===//
        -:  542:
function _ZN4mlir3omp10ParallelOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  543:void ParallelOp::build(OpBuilder &builder, OperationState &state,
        -:  544:                       ArrayRef<NamedAttribute> attributes) {
    #####:  545:  ParallelOp::build(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  546:      builder, state, /*if_expr_var=*/nullptr, /*num_threads_var=*/nullptr,
        -:  547:      /*allocate_vars=*/ValueRange(), /*allocators_vars=*/ValueRange(),
        -:  548:      /*reduction_vars=*/ValueRange(), /*reductions=*/nullptr,
        -:  549:      /*proc_bind_val=*/nullptr);
    #####:  550:  state.addAttributes(attributes);
call    0 never executed
    #####:  551:}
        -:  552:
function _ZN4mlir3omp10ParallelOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  553:LogicalResult ParallelOp::verify() {
    #####:  554:  if (getAllocateVars().size() != getAllocatorsVars().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  555:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  556:        "expected equal sizes for allocate and allocator variables");
call    0 never executed
    #####:  557:  return verifyReductionVarList(*this, getReductions(), getReductionVars());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  558:}
        -:  559:
        -:  560://===----------------------------------------------------------------------===//
        -:  561:// Verifier for SectionsOp
        -:  562://===----------------------------------------------------------------------===//
        -:  563:
function _ZN4mlir3omp10SectionsOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  564:LogicalResult SectionsOp::verify() {
    #####:  565:  if (getAllocateVars().size() != getAllocatorsVars().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  566:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  567:        "expected equal sizes for allocate and allocator variables");
call    0 never executed
        -:  568:
    #####:  569:  return verifyReductionVarList(*this, getReductions(), getReductionVars());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  570:}
        -:  571:
function _ZN4mlir3omp10SectionsOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####:  572:LogicalResult SectionsOp::verifyRegions() {
    #####:  573:  for (auto &inst : *getRegion().begin()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  574:    if (!(isa<SectionOp>(inst) || isa<TerminatorOp>(inst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  575:      return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  576:             << "expected omp.section op or terminator op inside region";
call    0 never executed
        -:  577:    }
        -:  578:  }
        -:  579:
    #####:  580:  return success();
        -:  581:}
        -:  582:
function _ZN4mlir3omp8SingleOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  583:LogicalResult SingleOp::verify() {
        -:  584:  // Check for allocate clause restrictions
    #####:  585:  if (getAllocateVars().size() != getAllocatorsVars().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  586:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  587:        "expected equal sizes for allocate and allocator variables");
call    0 never executed
        -:  588:
    #####:  589:  return success();
        -:  590:}
        -:  591:
        -:  592://===----------------------------------------------------------------------===//
        -:  593:// WsLoopOp
        -:  594://===----------------------------------------------------------------------===//
        -:  595:
        -:  596:/// loop-control ::= `(` ssa-id-list `)` `:` type `=`  loop-bounds
        -:  597:/// loop-bounds := `(` ssa-id-list `)` to `(` ssa-id-list `)` inclusive? steps
        -:  598:/// steps := `step` `(`ssa-id-list`)`
        -:  599:ParseResult
function _Z16parseLoopControlRN4mlir11OpAsmParserERNS_6RegionERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEES8_S8_RNS5_INS_4TypeEEERNS_8UnitAttrE called 0 returned 0% blocks executed 0%
    #####:  600:parseLoopControl(OpAsmParser &parser, Region &region,
        -:  601:                 SmallVectorImpl<OpAsmParser::UnresolvedOperand> &lowerBound,
        -:  602:                 SmallVectorImpl<OpAsmParser::UnresolvedOperand> &upperBound,
        -:  603:                 SmallVectorImpl<OpAsmParser::UnresolvedOperand> &steps,
        -:  604:                 SmallVectorImpl<Type> &loopVarTypes, UnitAttr &inclusive) {
        -:  605:  // Parse an opening `(` followed by induction variables followed by `)`
    #####:  606:  SmallVector<OpAsmParser::Argument> ivs;
call    0 never executed
    #####:  607:  Type loopVarType;
    #####:  608:  if (parser.parseArgumentList(ivs, OpAsmParser::Delimiter::Paren) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  609:      parser.parseColonType(loopVarType) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  610:      // Parse loop bounds.
    #####:  611:      parser.parseEqual() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  612:      parser.parseOperandList(lowerBound, ivs.size(),
call    0 never executed
    #####:  613:                              OpAsmParser::Delimiter::Paren) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  614:      parser.parseKeyword("to") ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  615:      parser.parseOperandList(upperBound, ivs.size(),
call    0 never executed
    #####:  616:                              OpAsmParser::Delimiter::Paren))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  617:    return failure();
        -:  618:
    #####:  619:  if (succeeded(parser.parseOptionalKeyword("inclusive")))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  620:    inclusive = UnitAttr::get(parser.getBuilder().getContext());
call    0 never executed
call    1 never executed
        -:  621:
        -:  622:  // Parse step values.
    #####:  623:  if (parser.parseKeyword("step") ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  624:      parser.parseOperandList(steps, ivs.size(), OpAsmParser::Delimiter::Paren))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  625:    return failure();
        -:  626:
        -:  627:  // Now parse the body.
    #####:  628:  loopVarTypes = SmallVector<Type>(ivs.size(), loopVarType);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  629:  for (auto &iv : ivs)
branch  0 never executed
branch  1 never executed
    #####:  630:    iv.type = loopVarType;
    #####:  631:  return parser.parseRegion(region, ivs);
call    0 never executed
        -:  632:}
        -:  633:
function _Z16printLoopControlRN4mlir12OpAsmPrinterEPNS_9OperationERNS_6RegionENS_10ValueRangeES6_S6_NS_9TypeRangeENS_8UnitAttrE called 0 returned 0% blocks executed 0%
    #####:  634:void printLoopControl(OpAsmPrinter &p, Operation *op, Region &region,
        -:  635:                      ValueRange lowerBound, ValueRange upperBound,
        -:  636:                      ValueRange steps, TypeRange loopVarTypes,
        -:  637:                      UnitAttr inclusive) {
    #####:  638:  auto args = region.front().getArguments();
call    0 never executed
call    1 never executed
    #####:  639:  p << " (" << args << ") : " << args[0].getType() << " = (" << lowerBound
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  640:    << ") to (" << upperBound << ") ";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  641:  if (inclusive)
branch  0 never executed
branch  1 never executed
    #####:  642:    p << "inclusive ";
call    0 never executed
    #####:  643:  p << "step (" << steps << ") ";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  644:  p.printRegion(region, /*printEntryBlockArgs=*/false);
call    0 never executed
    #####:  645:}
        -:  646:
        -:  647://===----------------------------------------------------------------------===//
        -:  648:// Verifier for Simd construct [2.9.3.1]
        -:  649://===----------------------------------------------------------------------===//
        -:  650:
function _ZN4mlir3omp10SimdLoopOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  651:LogicalResult SimdLoopOp::verify() {
    #####:  652:  if (this->getLowerBound().empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  653:    return emitOpError() << "empty lowerbound for simd loop operation";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  654:  }
    #####:  655:  if (this->getSimdlen().has_value() && this->getSafelen().has_value() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  656:      this->getSimdlen().value() > this->getSafelen().value()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  657:    return emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  658:           << "simdlen clause and safelen clause are both present, but the "
    #####:  659:              "simdlen value is not less than or equal to safelen value";
call    0 never executed
        -:  660:  }
    #####:  661:  return verifyAlignedClause(*this, this->getAlignmentValues(),
call    0 never executed
    #####:  662:                             this->getAlignedVars());
call    0 never executed
call    1 never executed
        -:  663:}
        -:  664:
        -:  665://===----------------------------------------------------------------------===//
        -:  666:// ReductionOp
        -:  667://===----------------------------------------------------------------------===//
        -:  668:
function _ZL26parseAtomicReductionRegionRN4mlir11OpAsmParserERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  669:static ParseResult parseAtomicReductionRegion(OpAsmParser &parser,
        -:  670:                                              Region &region) {
    #####:  671:  if (parser.parseOptionalKeyword("atomic"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  672:    return success();
    #####:  673:  return parser.parseRegion(region);
call    0 never executed
        -:  674:}
        -:  675:
        -:  676:static void printAtomicReductionRegion(OpAsmPrinter &printer,
        -:  677:                                       ReductionDeclareOp op, Region &region) {
        -:  678:  if (region.empty())
        -:  679:    return;
        -:  680:  printer << "atomic ";
        -:  681:  printer.printRegion(region);
        -:  682:}
        -:  683:
function _ZN4mlir3omp18ReductionDeclareOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####:  684:LogicalResult ReductionDeclareOp::verifyRegions() {
    #####:  685:  if (getInitializerRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  686:    return emitOpError() << "expects non-empty initializer region";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  687:  Block &initializerEntryBlock = getInitializerRegion().front();
call    0 never executed
    #####:  688:  if (initializerEntryBlock.getNumArguments() != 1 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  689:      initializerEntryBlock.getArgument(0).getType() != getType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  690:    return emitOpError() << "expects initializer region with one argument "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  691:                            "of the reduction type";
call    0 never executed
        -:  692:  }
        -:  693:
    #####:  694:  for (YieldOp yieldOp : getInitializerRegion().getOps<YieldOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  695:    if (yieldOp.getResults().size() != 1 ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  696:        yieldOp.getResults().getTypes()[0] != getType())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  697:      return emitOpError() << "expects initializer region to yield a value "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  698:                              "of the reduction type";
call    0 never executed
        -:  699:  }
        -:  700:
    #####:  701:  if (getReductionRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  702:    return emitOpError() << "expects non-empty reduction region";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  703:  Block &reductionEntryBlock = getReductionRegion().front();
call    0 never executed
    #####:  704:  if (reductionEntryBlock.getNumArguments() != 2 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  705:      reductionEntryBlock.getArgumentTypes()[0] !=
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  706:          reductionEntryBlock.getArgumentTypes()[1] ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  707:      reductionEntryBlock.getArgumentTypes()[0] != getType())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  708:    return emitOpError() << "expects reduction region with two arguments of "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  709:                            "the reduction type";
call    0 never executed
    #####:  710:  for (YieldOp yieldOp : getReductionRegion().getOps<YieldOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  711:    if (yieldOp.getResults().size() != 1 ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  712:        yieldOp.getResults().getTypes()[0] != getType())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  713:      return emitOpError() << "expects reduction region to yield a value "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  714:                              "of the reduction type";
call    0 never executed
        -:  715:  }
        -:  716:
    #####:  717:  if (getAtomicReductionRegion().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  718:    return success();
        -:  719:
    #####:  720:  Block &atomicReductionEntryBlock = getAtomicReductionRegion().front();
call    0 never executed
    #####:  721:  if (atomicReductionEntryBlock.getNumArguments() != 2 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  722:      atomicReductionEntryBlock.getArgumentTypes()[0] !=
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  723:          atomicReductionEntryBlock.getArgumentTypes()[1])
call    0 never executed
    #####:  724:    return emitOpError() << "expects atomic reduction region with two "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  725:                            "arguments of the same type";
call    0 never executed
    #####:  726:  auto ptrType = atomicReductionEntryBlock.getArgumentTypes()[0]
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  727:                     .dyn_cast<PointerLikeType>();
    #####:  728:  if (!ptrType || ptrType.getElementType() != getType())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  729:    return emitOpError() << "expects atomic reduction region arguments to "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  730:                            "be accumulators containing the reduction type";
call    0 never executed
    #####:  731:  return success();
        -:  732:}
        -:  733:
function _ZN4mlir3omp11ReductionOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  734:LogicalResult ReductionOp::verify() {
    #####:  735:  auto *op = (*this)->getParentWithTrait<ReductionClauseInterface::Trait>();
call    0 never executed
    #####:  736:  if (!op)
branch  0 never executed
branch  1 never executed
    #####:  737:    return emitOpError() << "must be used within an operation supporting "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  738:                            "reduction clause interface";
call    0 never executed
    #####:  739:  while (op) {
branch  0 never executed
branch  1 never executed
    #####:  740:    for (const auto &var :
    #####:  741:         cast<ReductionClauseInterface>(op).getAllReductionVars())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  742:      if (var == getAccumulator())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  743:        return success();
branch  0 never executed
branch  1 never executed
    #####:  744:    op = op->getParentWithTrait<ReductionClauseInterface::Trait>();
call    0 never executed
        -:  745:  }
    #####:  746:  return emitOpError() << "the accumulator is not used by the parent";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  747:}
        -:  748:
        -:  749://===----------------------------------------------------------------------===//
        -:  750:// TaskOp
        -:  751://===----------------------------------------------------------------------===//
function _ZN4mlir3omp6TaskOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  752:LogicalResult TaskOp::verify() {
    #####:  753:  return verifyReductionVarList(*this, getInReductions(), getInReductionVars());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  754:}
        -:  755:
        -:  756://===----------------------------------------------------------------------===//
        -:  757:// TaskGroupOp
        -:  758://===----------------------------------------------------------------------===//
function _ZN4mlir3omp11TaskGroupOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  759:LogicalResult TaskGroupOp::verify() {
    #####:  760:  return verifyReductionVarList(*this, getTaskReductions(),
call    0 never executed
    #####:  761:                                getTaskReductionVars());
call    0 never executed
call    1 never executed
        -:  762:}
        -:  763:
        -:  764://===----------------------------------------------------------------------===//
        -:  765:// TaskLoopOp
        -:  766://===----------------------------------------------------------------------===//
function _ZN4mlir3omp10TaskLoopOp19getAllReductionVarsEv called 0 returned 0% blocks executed 0%
    #####:  767:SmallVector<Value> TaskLoopOp::getAllReductionVars() {
    #####:  768:  SmallVector<Value> allReductionNvars(getInReductionVars().begin(),
call    0 never executed
    #####:  769:                                       getInReductionVars().end());
call    0 never executed
call    1 never executed
    #####:  770:  allReductionNvars.insert(allReductionNvars.end(), getReductionVars().begin(),
call    0 never executed
call    1 never executed
    #####:  771:                           getReductionVars().end());
call    0 never executed
    #####:  772:  return allReductionNvars;
        -:  773:}
        -:  774:
function _ZN4mlir3omp10TaskLoopOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  775:LogicalResult TaskLoopOp::verify() {
    #####:  776:  if (getAllocateVars().size() != getAllocatorsVars().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  777:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  778:        "expected equal sizes for allocate and allocator variables");
call    0 never executed
    #####:  779:  if (failed(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  780:          verifyReductionVarList(*this, getReductions(), getReductionVars())) ||
branch  0 never executed
branch  1 never executed
    #####:  781:      failed(verifyReductionVarList(*this, getInReductions(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  782:                                    getInReductionVars())))
    #####:  783:    return failure();
        -:  784:
    #####:  785:  if (!getReductionVars().empty() && getNogroup())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  786:    return emitError("if a reduction clause is present on the taskloop "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  787:                     "directive, the nogroup clause must not be specified");
call    0 never executed
    #####:  788:  for (auto var : getReductionVars()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  789:    if (llvm::is_contained(getInReductionVars(), var))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  790:      return emitError("the same list item cannot appear in both a reduction "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  791:                       "and an in_reduction clause");
call    0 never executed
        -:  792:  }
        -:  793:
    #####:  794:  if (getGrainSize() && getNumTasks()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  795:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  796:        "the grainsize clause and num_tasks clause are mutually exclusive and "
    #####:  797:        "may not appear on the same taskloop directive");
call    0 never executed
        -:  798:  }
    #####:  799:  return success();
        -:  800:}
        -:  801:
        -:  802://===----------------------------------------------------------------------===//
        -:  803:// WsLoopOp
        -:  804://===----------------------------------------------------------------------===//
        -:  805:
function _ZN4mlir3omp8WsLoopOp5buildERNS_9OpBuilderERNS_14OperationStateENS_10ValueRangeES6_S6_N4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  806:void WsLoopOp::build(OpBuilder &builder, OperationState &state,
        -:  807:                     ValueRange lowerBound, ValueRange upperBound,
        -:  808:                     ValueRange step, ArrayRef<NamedAttribute> attributes) {
    #####:  809:  build(builder, state, lowerBound, upperBound, step,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  810:        /*linear_vars=*/ValueRange(),
        -:  811:        /*linear_step_vars=*/ValueRange(), /*reduction_vars=*/ValueRange(),
        -:  812:        /*reductions=*/nullptr, /*schedule_val=*/nullptr,
        -:  813:        /*schedule_chunk_var=*/nullptr, /*schedule_modifier=*/nullptr,
        -:  814:        /*simd_modifier=*/false, /*nowait=*/false, /*ordered_val=*/nullptr,
        -:  815:        /*order_val=*/nullptr, /*inclusive=*/false);
    #####:  816:  state.addAttributes(attributes);
call    0 never executed
    #####:  817:}
        -:  818:
function _ZN4mlir3omp8WsLoopOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  819:LogicalResult WsLoopOp::verify() {
    #####:  820:  return verifyReductionVarList(*this, getReductions(), getReductionVars());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  821:}
        -:  822:
        -:  823://===----------------------------------------------------------------------===//
        -:  824:// Verifier for critical construct (2.17.1)
        -:  825://===----------------------------------------------------------------------===//
        -:  826:
function _ZN4mlir3omp17CriticalDeclareOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  827:LogicalResult CriticalDeclareOp::verify() {
    #####:  828:  return verifySynchronizationHint(*this, getHintVal());
call    0 never executed
call    1 never executed
        -:  829:}
        -:  830:
function _ZN4mlir3omp10CriticalOp16verifySymbolUsesERNS_21SymbolTableCollectionE called 0 returned 0% blocks executed 0%
    #####:  831:LogicalResult CriticalOp::verifySymbolUses(SymbolTableCollection &symbolTable) {
    #####:  832:  if (getNameAttr()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  833:    SymbolRefAttr symbolRef = getNameAttr();
call    0 never executed
    #####:  834:    auto decl = symbolTable.lookupNearestSymbolFrom<CriticalDeclareOp>(
    #####:  835:        *this, symbolRef);
call    0 never executed
    #####:  836:    if (!decl) {
branch  0 never executed
branch  1 never executed
    #####:  837:      return emitOpError() << "expected symbol reference " << symbolRef
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  838:                           << " to point to a critical declaration";
call    0 never executed
        -:  839:    }
        -:  840:  }
        -:  841:
    #####:  842:  return success();
        -:  843:}
        -:  844:
        -:  845://===----------------------------------------------------------------------===//
        -:  846:// Verifier for ordered construct
        -:  847://===----------------------------------------------------------------------===//
        -:  848:
function _ZN4mlir3omp9OrderedOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  849:LogicalResult OrderedOp::verify() {
    #####:  850:  auto container = (*this)->getParentOfType<WsLoopOp>();
call    0 never executed
    #####:  851:  if (!container || !container.getOrderedValAttr() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  852:      container.getOrderedValAttr().getInt() == 0)
call    0 never executed
call    1 never executed
    #####:  853:    return emitOpError() << "ordered depend directive must be closely "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  854:                         << "nested inside a worksharing-loop with ordered "
call    0 never executed
    #####:  855:                         << "clause with parameter present";
call    0 never executed
        -:  856:
    #####:  857:  if (container.getOrderedValAttr().getInt() != (int64_t)*getNumLoopsVal())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  858:    return emitOpError() << "number of variables in depend clause does not "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  859:                         << "match number of iteration variables in the "
call    0 never executed
    #####:  860:                         << "doacross loop";
call    0 never executed
        -:  861:
    #####:  862:  return success();
        -:  863:}
        -:  864:
function _ZN4mlir3omp15OrderedRegionOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  865:LogicalResult OrderedRegionOp::verify() {
        -:  866:  // TODO: The code generation for ordered simd directive is not supported yet.
    #####:  867:  if (getSimd())
call    0 never executed
    #####:  868:    return failure();
        -:  869:
    #####:  870:  if (auto container = (*this)->getParentOfType<WsLoopOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  871:    if (!container.getOrderedValAttr() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  872:        container.getOrderedValAttr().getInt() != 0)
call    0 never executed
call    1 never executed
    #####:  873:      return emitOpError() << "ordered region must be closely nested inside "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  874:                           << "a worksharing-loop region with an ordered "
call    0 never executed
    #####:  875:                           << "clause without parameter present";
call    0 never executed
        -:  876:  }
        -:  877:
    #####:  878:  return success();
        -:  879:}
        -:  880:
        -:  881://===----------------------------------------------------------------------===//
        -:  882:// Verifier for AtomicReadOp
        -:  883://===----------------------------------------------------------------------===//
        -:  884:
function _ZN4mlir3omp12AtomicReadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  885:LogicalResult AtomicReadOp::verify() {
    #####:  886:  if (auto mo = getMemoryOrderVal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  887:    if (*mo == ClauseMemoryOrderKind::Acq_rel ||
branch  0 never executed
branch  1 never executed
    #####:  888:        *mo == ClauseMemoryOrderKind::Release) {
branch  0 never executed
branch  1 never executed
    #####:  889:      return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  890:          "memory-order must not be acq_rel or release for atomic reads");
call    0 never executed
        -:  891:    }
        -:  892:  }
    #####:  893:  if (getX() == getV())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  894:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  895:        "read and write must not be to the same location for atomic reads");
call    0 never executed
    #####:  896:  return verifySynchronizationHint(*this, getHintVal());
call    0 never executed
call    1 never executed
        -:  897:}
        -:  898:
        -:  899://===----------------------------------------------------------------------===//
        -:  900:// Verifier for AtomicWriteOp
        -:  901://===----------------------------------------------------------------------===//
        -:  902:
function _ZN4mlir3omp13AtomicWriteOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  903:LogicalResult AtomicWriteOp::verify() {
    #####:  904:  if (auto mo = getMemoryOrderVal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  905:    if (*mo == ClauseMemoryOrderKind::Acq_rel ||
branch  0 never executed
branch  1 never executed
    #####:  906:        *mo == ClauseMemoryOrderKind::Acquire) {
branch  0 never executed
branch  1 never executed
    #####:  907:      return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  908:          "memory-order must not be acq_rel or acquire for atomic writes");
call    0 never executed
        -:  909:    }
        -:  910:  }
    #####:  911:  if (getAddress().getType().cast<PointerLikeType>().getElementType() !=
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  912:      getValue().getType())
call    0 never executed
    #####:  913:    return emitError("address must dereference to value type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  914:  return verifySynchronizationHint(*this, getHintVal());
call    0 never executed
call    1 never executed
        -:  915:}
        -:  916:
        -:  917://===----------------------------------------------------------------------===//
        -:  918:// Verifier for AtomicUpdateOp
        -:  919://===----------------------------------------------------------------------===//
        -:  920:
function _ZN4mlir3omp14AtomicUpdateOp6isNoOpEv called 0 returned 0% blocks executed 0%
    #####:  921:bool AtomicUpdateOp::isNoOp() {
    #####:  922:  YieldOp yieldOp = dyn_cast<omp::YieldOp>(getFirstOp());
call    0 never executed
call    1 never executed
    #####:  923:  return (yieldOp &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  924:          yieldOp.getResults().front() == getRegion().front().getArgument(0));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  925:}
        -:  926:
function _ZN4mlir3omp14AtomicUpdateOp13getWriteOpValEv called 0 returned 0% blocks executed 0%
    #####:  927:Value AtomicUpdateOp::getWriteOpVal() {
    #####:  928:  YieldOp yieldOp = dyn_cast<omp::YieldOp>(getFirstOp());
call    0 never executed
call    1 never executed
    #####:  929:  if (yieldOp &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  930:      yieldOp.getResults().front() != getRegion().front().getArgument(0))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  931:    return yieldOp.getResults().front();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  932:  return nullptr;
        -:  933:}
        -:  934:
function _ZN4mlir3omp14AtomicUpdateOp12canonicalizeES1_RNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  935:LogicalResult AtomicUpdateOp::canonicalize(AtomicUpdateOp op,
        -:  936:                                           PatternRewriter &rewriter) {
    #####:  937:  if (op.isNoOp()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    rewriter.eraseOp(op);
call    0 never executed
    #####:  939:    return success();
        -:  940:  }
    #####:  941:  if (Value writeVal = op.getWriteOpVal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  942:    rewriter.replaceOpWithNewOp<AtomicWriteOp>(op, op.getX(), writeVal,
call    0 never executed
    #####:  943:                                               op.getHintValAttr(),
call    0 never executed
    #####:  944:                                               op.getMemoryOrderValAttr());
call    0 never executed
call    1 never executed
    #####:  945:    return success();
        -:  946:  }
    #####:  947:  return failure();
        -:  948:}
        -:  949:
function _ZN4mlir3omp14AtomicUpdateOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  950:LogicalResult AtomicUpdateOp::verify() {
    #####:  951:  if (auto mo = getMemoryOrderVal()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:    if (*mo == ClauseMemoryOrderKind::Acq_rel ||
branch  0 never executed
branch  1 never executed
    #####:  953:        *mo == ClauseMemoryOrderKind::Acquire) {
branch  0 never executed
branch  1 never executed
    #####:  954:      return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  955:          "memory-order must not be acq_rel or acquire for atomic updates");
call    0 never executed
        -:  956:    }
        -:  957:  }
        -:  958:
    #####:  959:  if (getRegion().getNumArguments() != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  960:    return emitError("the region must accept exactly one argument");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  961:
    #####:  962:  if (getX().getType().cast<PointerLikeType>().getElementType() !=
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  963:      getRegion().getArgument(0).getType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  964:    return emitError("the type of the operand must be a pointer type whose "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  965:                     "element type is the same as that of the region argument");
call    0 never executed
        -:  966:  }
        -:  967:
    #####:  968:  return verifySynchronizationHint(*this, getHintVal());
call    0 never executed
call    1 never executed
        -:  969:}
        -:  970:
function _ZN4mlir3omp14AtomicUpdateOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####:  971:LogicalResult AtomicUpdateOp::verifyRegions() {
        -:  972:
    #####:  973:  YieldOp yieldOp = *getRegion().getOps<YieldOp>().begin();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  974:
    #####:  975:  if (yieldOp.getResults().size() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  976:    return emitError("only updated value must be returned");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  977:  if (yieldOp.getResults().front().getType() !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  978:      getRegion().getArgument(0).getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  979:    return emitError("input and yielded value must have the same type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  980:  return success();
        -:  981:}
        -:  982:
        -:  983://===----------------------------------------------------------------------===//
        -:  984:// Verifier for AtomicCaptureOp
        -:  985://===----------------------------------------------------------------------===//
        -:  986:
function _ZN4mlir3omp15AtomicCaptureOp10getFirstOpEv called 0 returned 0% blocks executed 0%
    #####:  987:Operation *AtomicCaptureOp::getFirstOp() {
    #####:  988:  return &getRegion().front().getOperations().front();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  989:}
        -:  990:
function _ZN4mlir3omp15AtomicCaptureOp11getSecondOpEv called 0 returned 0% blocks executed 0%
    #####:  991:Operation *AtomicCaptureOp::getSecondOp() {
    #####:  992:  auto &ops = getRegion().front().getOperations();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  993:  return ops.getNextNode(ops.front());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  994:}
        -:  995:
function _ZN4mlir3omp15AtomicCaptureOp15getAtomicReadOpEv called 0 returned 0% blocks executed 0%
    #####:  996:AtomicReadOp AtomicCaptureOp::getAtomicReadOp() {
    #####:  997:  if (auto op = dyn_cast<AtomicReadOp>(getFirstOp()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  998:    return op;
    #####:  999:  return dyn_cast<AtomicReadOp>(getSecondOp());
call    0 never executed
call    1 never executed
        -: 1000:}
        -: 1001:
function _ZN4mlir3omp15AtomicCaptureOp16getAtomicWriteOpEv called 0 returned 0% blocks executed 0%
    #####: 1002:AtomicWriteOp AtomicCaptureOp::getAtomicWriteOp() {
    #####: 1003:  if (auto op = dyn_cast<AtomicWriteOp>(getFirstOp()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1004:    return op;
    #####: 1005:  return dyn_cast<AtomicWriteOp>(getSecondOp());
call    0 never executed
call    1 never executed
        -: 1006:}
        -: 1007:
function _ZN4mlir3omp15AtomicCaptureOp17getAtomicUpdateOpEv called 0 returned 0% blocks executed 0%
    #####: 1008:AtomicUpdateOp AtomicCaptureOp::getAtomicUpdateOp() {
    #####: 1009:  if (auto op = dyn_cast<AtomicUpdateOp>(getFirstOp()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1010:    return op;
    #####: 1011:  return dyn_cast<AtomicUpdateOp>(getSecondOp());
call    0 never executed
call    1 never executed
        -: 1012:}
        -: 1013:
function _ZN4mlir3omp15AtomicCaptureOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1014:LogicalResult AtomicCaptureOp::verify() {
    #####: 1015:  return verifySynchronizationHint(*this, getHintVal());
call    0 never executed
call    1 never executed
        -: 1016:}
        -: 1017:
function _ZN4mlir3omp15AtomicCaptureOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####: 1018:LogicalResult AtomicCaptureOp::verifyRegions() {
    #####: 1019:  Block::OpListType &ops = getRegion().front().getOperations();
call    0 never executed
call    1 never executed
    #####: 1020:  if (ops.size() != 3)
branch  0 never executed
branch  1 never executed
    #####: 1021:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1022:           << "expected three operations in omp.atomic.capture region (one "
    #####: 1023:              "terminator, and two atomic ops)";
call    0 never executed
    #####: 1024:  auto &firstOp = ops.front();
call    0 never executed
    #####: 1025:  auto &secondOp = *ops.getNextNode(firstOp);
branch  0 never executed
branch  1 never executed
    #####: 1026:  auto firstReadStmt = dyn_cast<AtomicReadOp>(firstOp);
call    0 never executed
    #####: 1027:  auto firstUpdateStmt = dyn_cast<AtomicUpdateOp>(firstOp);
call    0 never executed
    #####: 1028:  auto secondReadStmt = dyn_cast<AtomicReadOp>(secondOp);
call    0 never executed
    #####: 1029:  auto secondUpdateStmt = dyn_cast<AtomicUpdateOp>(secondOp);
call    0 never executed
    #####: 1030:  auto secondWriteStmt = dyn_cast<AtomicWriteOp>(secondOp);
call    0 never executed
        -: 1031:
    #####: 1032:  if (!((firstUpdateStmt && secondReadStmt) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1033:        (firstReadStmt && secondUpdateStmt) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1034:        (firstReadStmt && secondWriteStmt)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1035:    return ops.front().emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1036:           << "invalid sequence of operations in the capture region";
call    0 never executed
    #####: 1037:  if (firstUpdateStmt && secondReadStmt &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1038:      firstUpdateStmt.getX() != secondReadStmt.getX())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1039:    return firstUpdateStmt.emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1040:           << "updated variable in omp.atomic.update must be captured in "
    #####: 1041:              "second operation";
call    0 never executed
    #####: 1042:  if (firstReadStmt && secondUpdateStmt &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1043:      firstReadStmt.getX() != secondUpdateStmt.getX())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1044:    return firstReadStmt.emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1045:           << "captured variable in omp.atomic.read must be updated in second "
    #####: 1046:              "operation";
call    0 never executed
    #####: 1047:  if (firstReadStmt && secondWriteStmt &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1048:      firstReadStmt.getX() != secondWriteStmt.getAddress())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1049:    return firstReadStmt.emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1050:           << "captured variable in omp.atomic.read must be updated in "
    #####: 1051:              "second operation";
call    0 never executed
        -: 1052:
    #####: 1053:  if (getFirstOp()->getAttr("hint_val") || getSecondOp()->getAttr("hint_val"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1054:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1055:        "operations inside capture region must not have hint clause");
call    0 never executed
        -: 1056:
    #####: 1057:  if (getFirstOp()->getAttr("memory_order_val") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1058:      getSecondOp()->getAttr("memory_order_val"))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1059:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1060:        "operations inside capture region must not have memory_order clause");
call    0 never executed
    #####: 1061:  return success();
        -: 1062:}
        -: 1063:
        -: 1064://===----------------------------------------------------------------------===//
        -: 1065:// Verifier for CancelOp
        -: 1066://===----------------------------------------------------------------------===//
        -: 1067:
function _ZN4mlir3omp8CancelOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1068:LogicalResult CancelOp::verify() {
    #####: 1069:  ClauseCancellationConstructType cct = getCancellationConstructTypeVal();
call    0 never executed
    #####: 1070:  Operation *parentOp = (*this)->getParentOp();
branch  0 never executed
branch  1 never executed
        -: 1071:
    #####: 1072:  if (!parentOp) {
branch  0 never executed
branch  1 never executed
    #####: 1073:    return emitOpError() << "must be used within a region supporting "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1074:                            "cancel directive";
call    0 never executed
        -: 1075:  }
        -: 1076:
    #####: 1077:  if ((cct == ClauseCancellationConstructType::Parallel) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1078:      !isa<ParallelOp>(parentOp)) {
call    0 never executed
    #####: 1079:    return emitOpError() << "cancel parallel must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1080:                         << "inside a parallel region";
call    0 never executed
        -: 1081:  }
    #####: 1082:  if (cct == ClauseCancellationConstructType::Loop) {
branch  0 never executed
branch  1 never executed
    #####: 1083:    if (!isa<WsLoopOp>(parentOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1084:      return emitOpError() << "cancel loop must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1085:                           << "inside a worksharing-loop region";
call    0 never executed
        -: 1086:    }
    #####: 1087:    if (cast<WsLoopOp>(parentOp).getNowaitAttr()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1088:      return emitError() << "A worksharing construct that is canceled "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1089:                         << "must not have a nowait clause";
call    0 never executed
        -: 1090:    }
    #####: 1091:    if (cast<WsLoopOp>(parentOp).getOrderedValAttr()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1092:      return emitError() << "A worksharing construct that is canceled "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1093:                         << "must not have an ordered clause";
call    0 never executed
        -: 1094:    }
        -: 1095:
    #####: 1096:  } else if (cct == ClauseCancellationConstructType::Sections) {
branch  0 never executed
branch  1 never executed
    #####: 1097:    if (!(isa<SectionsOp>(parentOp) || isa<SectionOp>(parentOp))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1098:      return emitOpError() << "cancel sections must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1099:                           << "inside a sections region";
call    0 never executed
        -: 1100:    }
    #####: 1101:    if (isa_and_nonnull<SectionsOp>(parentOp->getParentOp()) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1102:        cast<SectionsOp>(parentOp->getParentOp()).getNowaitAttr()) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1103:      return emitError() << "A sections construct that is canceled "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1104:                         << "must not have a nowait clause";
call    0 never executed
        -: 1105:    }
        -: 1106:  }
        -: 1107:  // TODO : Add more when we support taskgroup.
    #####: 1108:  return success();
        -: 1109:}
        -: 1110://===----------------------------------------------------------------------===//
        -: 1111:// Verifier for CancelOp
        -: 1112://===----------------------------------------------------------------------===//
        -: 1113:
function _ZN4mlir3omp19CancellationPointOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1114:LogicalResult CancellationPointOp::verify() {
    #####: 1115:  ClauseCancellationConstructType cct = getCancellationConstructTypeVal();
call    0 never executed
    #####: 1116:  Operation *parentOp = (*this)->getParentOp();
branch  0 never executed
branch  1 never executed
        -: 1117:
    #####: 1118:  if (!parentOp) {
branch  0 never executed
branch  1 never executed
    #####: 1119:    return emitOpError() << "must be used within a region supporting "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1120:                            "cancellation point directive";
call    0 never executed
        -: 1121:  }
        -: 1122:
    #####: 1123:  if ((cct == ClauseCancellationConstructType::Parallel) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1124:      !(isa<ParallelOp>(parentOp))) {
call    0 never executed
    #####: 1125:    return emitOpError() << "cancellation point parallel must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1126:                         << "inside a parallel region";
call    0 never executed
        -: 1127:  }
    #####: 1128:  if ((cct == ClauseCancellationConstructType::Loop) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1129:      !isa<WsLoopOp>(parentOp)) {
call    0 never executed
    #####: 1130:    return emitOpError() << "cancellation point loop must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1131:                         << "inside a worksharing-loop region";
call    0 never executed
        -: 1132:  }
    #####: 1133:  if ((cct == ClauseCancellationConstructType::Sections) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1134:      !(isa<SectionsOp>(parentOp) || isa<SectionOp>(parentOp))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1135:    return emitOpError() << "cancellation point sections must appear "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1136:                         << "inside a sections region";
call    0 never executed
        -: 1137:  }
        -: 1138:  // TODO : Add more when we support taskgroup.
    #####: 1139:  return success();
        -: 1140:}
        -: 1141:
        -: 1142:#define GET_ATTRDEF_CLASSES
        -: 1143:#include "mlir/Dialect/OpenMP/OpenMPOpsAttributes.cpp.inc"
        -: 1144:
        -: 1145:#define GET_OP_CLASSES
        -: 1146:#include "mlir/Dialect/OpenMP/OpenMPOps.cpp.inc"
