        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Transforms/Utils/RegionUtils.cpp
        -:    0:Graph:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/RegionUtils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/RegionUtils.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- RegionUtils.cpp - Region-related transformation utilities ----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Transforms/RegionUtils.h"
        -:   10:#include "mlir/IR/Block.h"
        -:   11:#include "mlir/IR/Operation.h"
        -:   12:#include "mlir/IR/PatternMatch.h"
        -:   13:#include "mlir/IR/RegionGraphTraits.h"
        -:   14:#include "mlir/IR/Value.h"
        -:   15:#include "mlir/Interfaces/ControlFlowInterfaces.h"
        -:   16:#include "mlir/Interfaces/SideEffectInterfaces.h"
        -:   17:
        -:   18:#include "llvm/ADT/DepthFirstIterator.h"
        -:   19:#include "llvm/ADT/PostOrderIterator.h"
        -:   20:#include "llvm/ADT/SmallSet.h"
        -:   21:
        -:   22:using namespace mlir;
        -:   23:
function _ZN4mlir26replaceAllUsesInRegionWithENS_5ValueES0_RNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:   24:void mlir::replaceAllUsesInRegionWith(Value orig, Value replacement,
        -:   25:                                      Region &region) {
    #####:   26:  for (auto &use : llvm::make_early_inc_range(orig.getUses())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   27:    if (region.isAncestor(use.getOwner()->getParentRegion()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   28:      use.set(replacement);
branch  0 never executed
branch  1 never executed
        -:   29:  }
    #####:   30:}
        -:   31:
function _ZN4mlir27visitUsedValuesDefinedAboveERNS_6RegionES1_N4llvm12function_refIFvPNS_9OpOperandEEEE called 0 returned 0% blocks executed 0%
    #####:   32:void mlir::visitUsedValuesDefinedAbove(
        -:   33:    Region &region, Region &limit, function_ref<void(OpOperand *)> callback) {
    #####:   34:  assert(limit.isAncestor(&region) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   35:         "expected isolation limit to be an ancestor of the given region");
        -:   36:
        -:   37:  // Collect proper ancestors of `limit` upfront to avoid traversing the region
        -:   38:  // tree for every value.
    #####:   39:  SmallPtrSet<Region *, 4> properAncestors;
call    0 never executed
    #####:   40:  for (auto *reg = limit.getParentRegion(); reg != nullptr;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   41:       reg = reg->getParentRegion()) {
    #####:   42:    properAncestors.insert(reg);
call    0 never executed
call    1 never executed
        -:   43:  }
        -:   44:
function _ZZN4mlir27visitUsedValuesDefinedAboveERNS_6RegionES1_N4llvm12function_refIFvPNS_9OpOperandEEEEENKUlPNS_9OperationEE_clES9_ called 0 returned 0% blocks executed 0%
    #####:   45:  region.walk([callback, &properAncestors](Operation *op) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   46:    for (OpOperand &operand : op->getOpOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   47:      // Callback on values defined in a proper ancestor of region.
    #####:   48:      if (properAncestors.count(operand.get().getParentRegion()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   49:        callback(&operand);
call    0 never executed
    #####:   50:  });
    #####:   51:}
        -:   52:
function _ZN4mlir27visitUsedValuesDefinedAboveEN4llvm15MutableArrayRefINS_6RegionEEENS0_12function_refIFvPNS_9OpOperandEEEE called 0 returned 0% blocks executed 0%
    #####:   53:void mlir::visitUsedValuesDefinedAbove(
        -:   54:    MutableArrayRef<Region> regions, function_ref<void(OpOperand *)> callback) {
    #####:   55:  for (Region &region : regions)
branch  0 never executed
branch  1 never executed
    #####:   56:    visitUsedValuesDefinedAbove(region, region, callback);
call    0 never executed
    #####:   57:}
        -:   58:
function _ZN4mlir25getUsedValuesDefinedAboveERNS_6RegionES1_RN4llvm9SetVectorINS_5ValueESt6vectorIS4_SaIS4_EENS2_8DenseSetIS4_NS2_12DenseMapInfoIS4_vEEEEEE called 0 returned 0% blocks executed 0%
    #####:   59:void mlir::getUsedValuesDefinedAbove(Region &region, Region &limit,
        -:   60:                                     SetVector<Value> &values) {
    #####:   61:  visitUsedValuesDefinedAbove(region, limit, [&](OpOperand *operand) {
call    0 never executed
    #####:   62:    values.insert(operand->get());
call    0 never executed
        -:   63:  });
    #####:   64:}
        -:   65:
function _ZN4mlir25getUsedValuesDefinedAboveEN4llvm15MutableArrayRefINS_6RegionEEERNS0_9SetVectorINS_5ValueESt6vectorIS5_SaIS5_EENS0_8DenseSetIS5_NS0_12DenseMapInfoIS5_vEEEEEE called 0 returned 0% blocks executed 0%
    #####:   66:void mlir::getUsedValuesDefinedAbove(MutableArrayRef<Region> regions,
        -:   67:                                     SetVector<Value> &values) {
    #####:   68:  for (Region &region : regions)
branch  0 never executed
branch  1 never executed
    #####:   69:    getUsedValuesDefinedAbove(region, region, values);
call    0 never executed
    #####:   70:}
        -:   71:
        -:   72://===----------------------------------------------------------------------===//
        -:   73:// Unreachable Block Elimination
        -:   74://===----------------------------------------------------------------------===//
        -:   75:
        -:   76:/// Erase the unreachable blocks within the provided regions. Returns success
        -:   77:/// if any blocks were erased, failure otherwise.
        -:   78:// TODO: We could likely merge this with the DCE algorithm below.
function _ZN4mlir22eraseUnreachableBlocksERNS_12RewriterBaseEN4llvm15MutableArrayRefINS_6RegionEEE called 62264 returned 100% blocks executed 42%
    62264:   79:LogicalResult mlir::eraseUnreachableBlocks(RewriterBase &rewriter,
        -:   80:                                           MutableArrayRef<Region> regions) {
        -:   81:  // Set of blocks found to be reachable within a given region.
    62264:   82:  llvm::df_iterator_default_set<Block *, 16> reachable;
call    0 returned 100%
        -:   83:  // If any blocks were found to be dead.
    62271:   84:  bool erasedDeadBlocks = false;
        -:   85:
   124521:   86:  SmallVector<Region *, 1> worklist;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    62271:   87:  worklist.reserve(regions.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   124524:   88:  for (Region &region : regions)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    62268:   89:    worklist.push_back(&region);
call    0 returned 100%
   159232:   90:  while (!worklist.empty()) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
    96982:   91:    Region *region = worklist.pop_back_val();
call    0 returned 100%
    96976:   92:    if (region->empty())
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     6442:   93:      continue;
        -:   94:
        -:   95:    // If this is a single block region, just collect the nested regions.
   181068:   96:    if (std::next(region->begin()) == region->end()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   787062:   97:      for (Operation &op : region->front())
call    0 returned 100%
branch  1 taken 88% (fallthrough)
branch  2 taken 12%
call    3 returned 100%
   943414:   98:        for (Region &region : op.getRegions())
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
    34726:   99:          worklist.push_back(&region);
call    0 returned 100%
    90534:  100:      continue;
        -:  101:    }
        -:  102:
        -:  103:    // Mark all reachable blocks.
    #####:  104:    reachable.clear();
call    0 never executed
    #####:  105:    for (Block *block : depth_first_ext(&region->front(), reachable))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
    #####:  106:      (void)block /* Mark all reachable blocks */;
call    0 never executed
        -:  107:
        -:  108:    // Collect all of the dead blocks and push the live regions onto the
        -:  109:    // worklist.
    #####:  110:    for (Block &block : llvm::make_early_inc_range(*region)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  111:      if (!reachable.count(&block)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  112:        block.dropAllDefinedValueUses();
call    0 never executed
    #####:  113:        rewriter.eraseBlock(&block);
call    0 never executed
    #####:  114:        erasedDeadBlocks = true;
    #####:  115:        continue;
        -:  116:      }
        -:  117:
        -:  118:      // Walk any regions within this block.
    #####:  119:      for (Operation &op : block)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  120:        for (Region &region : op.getRegions())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  121:          worklist.push_back(&region);
call    0 never executed
        -:  122:    }
        -:  123:  }
        -:  124:
    62250:  125:  return success(erasedDeadBlocks);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  126:}
        -:  127:
        -:  128://===----------------------------------------------------------------------===//
        -:  129:// Dead Code Elimination
        -:  130://===----------------------------------------------------------------------===//
        -:  131:
        -:  132:namespace {
        -:  133:/// Data structure used to track which values have already been proved live.
        -:  134:///
        -:  135:/// Because Operation's can have multiple results, this data structure tracks
        -:  136:/// liveness for both Value's and Operation's to avoid having to look through
        -:  137:/// all Operation results when analyzing a use.
        -:  138:///
        -:  139:/// This data structure essentially tracks the dataflow lattice.
        -:  140:/// The set of values/ops proved live increases monotonically to a fixed-point.
        -:  141:class LiveMap {
        -:  142:public:
        -:  143:  /// Value methods.
function _ZN12_GLOBAL__N_17LiveMap13wasProvenLiveEN4mlir5ValueE called 0 returned 0% blocks executed 0%
    #####:  144:  bool wasProvenLive(Value value) {
        -:  145:    // TODO: For results that are removable, e.g. for region based control flow,
        -:  146:    // we could allow for these values to be tracked independently.
    #####:  147:    if (OpResult result = value.dyn_cast<OpResult>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  148:      return wasProvenLive(result.getOwner());
call    0 never executed
    #####:  149:    return wasProvenLive(value.cast<BlockArgument>());
call    0 never executed
        -:  150:  }
    #####:  151:  bool wasProvenLive(BlockArgument arg) { return liveValues.count(arg); }
call    0 never executed
call    1 never executed
call    2 never executed
function _ZN12_GLOBAL__N_17LiveMap13setProvedLiveEN4mlir5ValueE called 602002 returned 100% blocks executed 67%
   602002:  152:  void setProvedLive(Value value) {
        -:  153:    // TODO: For results that are removable, e.g. for region based control flow,
        -:  154:    // we could allow for these values to be tracked independently.
   602002:  155:    if (OpResult result = value.dyn_cast<OpResult>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   602002:  156:      return setProvedLive(result.getOwner());
call    0 returned 100%
    #####:  157:    setProvedLive(value.cast<BlockArgument>());
call    0 never executed
        -:  158:  }
    #####:  159:  void setProvedLive(BlockArgument arg) {
    #####:  160:    changed |= liveValues.insert(arg).second;
call    0 never executed
call    1 never executed
        -:  161:  }
        -:  162:
        -:  163:  /// Operation methods.
  602002*:  164:  bool wasProvenLive(Operation *op) { return liveOps.count(op); }
call    0 returned 100%
call    1 never executed
   602002:  165:  void setProvedLive(Operation *op) { changed |= liveOps.insert(op).second; }
call    0 returned 100%
        -:  166:
        -:  167:  /// Methods for tracking if we have reached a fixed-point.
   121734:  168:  void resetChanged() { changed = false; }
   121723:  169:  bool hasChanged() { return changed; }
        -:  170:
        -:  171:private:
        -:  172:  bool changed = false;
        -:  173:  DenseSet<Value> liveValues;
        -:  174:  DenseSet<Operation *> liveOps;
        -:  175:};
        -:  176:} // namespace
        -:  177:
function _ZL23isUseSpeciallyKnownDeadRN4mlir9OpOperandERN12_GLOBAL__N_17LiveMapE called 602002 returned 100% blocks executed 50%
   602002:  178:static bool isUseSpeciallyKnownDead(OpOperand &use, LiveMap &liveMap) {
   602002:  179:  Operation *owner = use.getOwner();
call    0 returned 100%
   602002:  180:  unsigned operandIndex = use.getOperandNumber();
call    0 returned 100%
        -:  181:  // This pass generally treats all uses of an op as live if the op itself is
        -:  182:  // considered live. However, for successor operands to terminators we need a
        -:  183:  // finer-grained notion where we deduce liveness for operands individually.
        -:  184:  // The reason for this is easiest to think about in terms of a classical phi
        -:  185:  // node based SSA IR, where each successor operand is really an operand to a
        -:  186:  // *separate* phi node, rather than all operands to the branch itself as with
        -:  187:  // the block argument representation that MLIR uses.
        -:  188:  //
        -:  189:  // And similarly, because each successor operand is really an operand to a phi
        -:  190:  // node, rather than to the terminator op itself, a terminator op can't e.g.
        -:  191:  // "print" the value of a successor operand.
   602002:  192:  if (owner->hasTrait<OpTrait::IsTerminator>()) {
call    0 returned 100%
branch  1 taken 23% (fallthrough)
branch  2 taken 77%
   138667:  193:    if (BranchOpInterface branchInterface = dyn_cast<BranchOpInterface>(owner))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  194:      if (auto arg = branchInterface.getSuccessorBlockArgument(operandIndex))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  195:        return !liveMap.wasProvenLive(*arg);
call    0 never executed
   138667:  196:    return false;
        -:  197:  }
        -:  198:  return false;
        -:  199:}
        -:  200:
function _ZL12processValueN4mlir5ValueERN12_GLOBAL__N_17LiveMapE called 602002 returned 100% blocks executed 100%
   602002:  201:static void processValue(Value value, LiveMap &liveMap) {
function _ZZL12processValueN4mlir5ValueERN12_GLOBAL__N_17LiveMapEENKUlRNS_9OpOperandEE_clES5_.isra.0 called 602002 returned 100% blocks executed 86%
   602002:  202:  bool provedLive = llvm::any_of(value.getUses(), [&](OpOperand &use) {
call    0 returned 100%
   602002:  203:    if (isUseSpeciallyKnownDead(use, liveMap))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  204:      return false;
  1204004:  205:    return liveMap.wasProvenLive(use.getOwner());
call    0 returned 100%
        -:  206:  });
   602002:  207:  if (provedLive)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   602002:  208:    liveMap.setProvedLive(value);
call    0 returned 100%
   602002:  209:}
        -:  210:
        -:  211:static void propagateLiveness(Region &region, LiveMap &liveMap);
        -:  212:
function _ZL27propagateTerminatorLivenessPN4mlir9OperationERN12_GLOBAL__N_17LiveMapE called 119440 returned 100% blocks executed 32%
   119440:  213:static void propagateTerminatorLiveness(Operation *op, LiveMap &liveMap) {
        -:  214:  // Terminators are always live.
   119440:  215:  liveMap.setProvedLive(op);
call    0 returned 100%
        -:  216:
        -:  217:  // Check to see if we can reason about the successor operands and mutate them.
   119440:  218:  BranchOpInterface branchInterface = dyn_cast<BranchOpInterface>(op);
call    0 returned 100%
   119440:  219:  if (!branchInterface) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  119440*:  220:    for (Block *successor : op->getSuccessors())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  221:      for (BlockArgument arg : successor->getArguments())
branch  0 never executed
branch  1 never executed
    #####:  222:        liveMap.setProvedLive(arg);
call    0 never executed
   119440:  223:    return;
        -:  224:  }
        -:  225:
        -:  226:  // If we can't reason about the operand to a successor, conservatively mark
        -:  227:  // it as live.
    #####:  228:  for (unsigned i = 0, e = op->getNumSuccessors(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  229:    SuccessorOperands successorOperands =
    #####:  230:        branchInterface.getSuccessorOperands(i);
call    0 never executed
    #####:  231:    for (unsigned opI = 0, opE = successorOperands.getProducedOperandCount();
    #####:  232:         opI != opE; ++opI)
branch  0 never executed
branch  1 never executed
    #####:  233:      liveMap.setProvedLive(op->getSuccessor(i)->getArgument(opI));
call    0 never executed
call    1 never executed
        -:  234:  }
        -:  235:}
        -:  236:
function _ZL17propagateLivenessPN4mlir9OperationERN12_GLOBAL__N_17LiveMapE called 1393056 returned 100% blocks executed 100%
  1393056:  237:static void propagateLiveness(Operation *op, LiveMap &liveMap) {
        -:  238:  // Recurse on any regions the op has.
  1886828:  239:  for (Region &region : op->getRegions())
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
    69452:  240:    propagateLiveness(region, liveMap);
call    0 returned 100%
        -:  241:
        -:  242:  // Process terminator operations.
  1393056:  243:  if (op->hasTrait<OpTrait::IsTerminator>())
call    0 returned 100%
branch  1 taken 9% (fallthrough)
branch  2 taken 91%
   119440:  244:    return propagateTerminatorLiveness(op, liveMap);
call    0 returned 100%
        -:  245:
        -:  246:  // Don't reprocess live operations.
  2547232:  247:  if (liveMap.wasProvenLive(op))
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  248:    return;
        -:  249:
        -:  250:  // Process the op itself.
   636808:  251:  if (!wouldOpBeTriviallyDead(op))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
    34806:  252:    return liveMap.setProvedLive(op);
call    0 returned 100%
        -:  253:
        -:  254:  // If the op isn't intrinsically alive, check it's results.
  1806006:  255:  for (Value value : op->getResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
   602002:  256:    processValue(value, liveMap);
call    0 returned 100%
        -:  257:}
        -:  258:
function _ZL17propagateLivenessRN4mlir6RegionERN12_GLOBAL__N_17LiveMapE called 191177 returned 100% blocks executed 77%
   191177:  259:static void propagateLiveness(Region &region, LiveMap &liveMap) {
   191177:  260:  if (region.empty())
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -:  261:    return;
        -:  262:
   543198:  263:  for (Block *block : llvm::post_order(&region.front())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
        -:  264:    // We process block arguments after the ops in the block, to promote
        -:  265:    // faster convergence to a fixed point (we try to visit uses before defs).
  1574122:  266:    for (Operation &op : llvm::reverse(block->getOperations()))
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
  1393056:  267:      propagateLiveness(&op, liveMap);
call    0 returned 100%
        -:  268:
        -:  269:    // We currently do not remove entry block arguments, so there is no need to
        -:  270:    // track their liveness.
        -:  271:    // TODO: We could track these and enable removing dead operands/arguments
        -:  272:    // from region control flow operations.
   181066:  273:    if (block->isEntryBlock())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   181066:  274:      continue;
        -:  275:
    #####:  276:    for (Value value : block->getArguments()) {
branch  0 never executed
branch  1 never executed
    #####:  277:      if (!liveMap.wasProvenLive(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  278:        processValue(value, liveMap);
call    0 never executed
        -:  279:    }
        -:  280:  }
        -:  281:}
        -:  282:
function _ZL32eraseTerminatorSuccessorOperandsPN4mlir9OperationERN12_GLOBAL__N_17LiveMapE called 0 returned 0% blocks executed 0%
    #####:  283:static void eraseTerminatorSuccessorOperands(Operation *terminator,
        -:  284:                                             LiveMap &liveMap) {
    #####:  285:  BranchOpInterface branchOp = dyn_cast<BranchOpInterface>(terminator);
call    0 never executed
    #####:  286:  if (!branchOp)
branch  0 never executed
branch  1 never executed
    #####:  287:    return;
        -:  288:
    #####:  289:  for (unsigned succI = 0, succE = terminator->getNumSuccessors();
    #####:  290:       succI < succE; succI++) {
branch  0 never executed
branch  1 never executed
        -:  291:    // Iterating successors in reverse is not strictly needed, since we
        -:  292:    // aren't erasing any successors. But it is slightly more efficient
        -:  293:    // since it will promote later operands of the terminator being erased
        -:  294:    // first, reducing the quadratic-ness.
    #####:  295:    unsigned succ = succE - succI - 1;
    #####:  296:    SuccessorOperands succOperands = branchOp.getSuccessorOperands(succ);
call    0 never executed
    #####:  297:    Block *successor = terminator->getSuccessor(succ);
call    0 never executed
        -:  298:
    #####:  299:    for (unsigned argI = 0, argE = succOperands.size(); argI < argE; ++argI) {
branch  0 never executed
branch  1 never executed
        -:  300:      // Iterating args in reverse is needed for correctness, to avoid
        -:  301:      // shifting later args when earlier args are erased.
    #####:  302:      unsigned arg = argE - argI - 1;
    #####:  303:      if (!liveMap.wasProvenLive(successor->getArgument(arg)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  304:        succOperands.erase(arg);
call    0 never executed
        -:  305:    }
        -:  306:  }
        -:  307:}
        -:  308:
function _ZL14deleteDeadnessRN4mlir12RewriterBaseEN4llvm15MutableArrayRefINS_6RegionEEERN12_GLOBAL__N_17LiveMapE called 758744 returned 100% blocks executed 78%
   758744:  309:static LogicalResult deleteDeadness(RewriterBase &rewriter,
        -:  310:                                    MutableArrayRef<Region> regions,
        -:  311:                                    LiveMap &liveMap) {
   758744:  312:  bool erasedAnything = false;
   855830:  313:  for (Region &region : regions) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
    97013:  314:    if (region.empty())
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
     6479:  315:      continue;
    90534:  316:    bool hasSingleBlock = llvm::hasSingleElement(region);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  317:
        -:  318:    // Delete every operation that is not live. Graph regions may have cycles
        -:  319:    // in the use-def graph, so we must explicitly dropAllUses() from each
        -:  320:    // operation as we erase it. Visiting the operations in post-order
        -:  321:    // guarantees that in SSA CFG regions value uses are removed before defs,
        -:  322:    // which makes dropAllUses() a no-op.
   181068:  323:    for (Block *block : llvm::post_order(&region.front())) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 50% (fallthrough)
branch  6 taken 50%
call    7 returned 100%
call    8 returned 100%
call    9 returned 100%
call   10 returned 100%
    90534:  324:      if (!hasSingleBlock)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  325:        eraseTerminatorSuccessorOperands(block->getTerminator(), liveMap);
call    0 never executed
call    1 never executed
   787062:  326:      for (Operation &childOp :
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   787062:  327:           llvm::make_early_inc_range(llvm::reverse(block->getOperations()))) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 88% (fallthrough)
branch  3 taken 12%
call    4 returned 100%
  1393056:  328:        if (!liveMap.wasProvenLive(&childOp)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  329:          erasedAnything = true;
    #####:  330:          childOp.dropAllUses();
call    0 never executed
    #####:  331:          rewriter.eraseOp(&childOp);
call    0 never executed
        -:  332:        } else {
   908688:  333:          erasedAnything |= succeeded(
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
call    2 returned 100%
        -:  334:              deleteDeadness(rewriter, childOp.getRegions(), liveMap));
        -:  335:        }
        -:  336:      }
        -:  337:    }
        -:  338:    // Delete block arguments.
        -:  339:    // The entry block has an unknown contract with their enclosing block, so
        -:  340:    // skip it.
  181141*:  341:    for (Block &block : llvm::drop_begin(region.getBlocks(), 1)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  342:      block.eraseArguments(
call    0 never executed
    #####:  343:          [&](BlockArgument arg) { return !liveMap.wasProvenLive(arg); });
call    0 never executed
        -:  344:    }
        -:  345:  }
   758817:  346:  return success(erasedAnything);
        -:  347:}
        -:  348:
        -:  349:// This function performs a simple dead code elimination algorithm over the
        -:  350:// given regions.
        -:  351://
        -:  352:// The overall goal is to prove that Values are dead, which allows deleting ops
        -:  353:// and block arguments.
        -:  354://
        -:  355:// This uses an optimistic algorithm that assumes everything is dead until
        -:  356:// proved otherwise, allowing it to delete recursively dead cycles.
        -:  357://
        -:  358:// This is a simple fixed-point dataflow analysis algorithm on a lattice
        -:  359:// {Dead,Alive}. Because liveness flows backward, we generally try to
        -:  360:// iterate everything backward to speed up convergence to the fixed-point. This
        -:  361:// allows for being able to delete recursively dead cycles of the use-def graph,
        -:  362:// including block arguments.
        -:  363://
        -:  364:// This function returns success if any operations or arguments were deleted,
        -:  365:// failure otherwise.
function _ZN4mlir12runRegionDCEERNS_12RewriterBaseEN4llvm15MutableArrayRefINS_6RegionEEE called 62243 returned 100% blocks executed 100%
    62243:  366:LogicalResult mlir::runRegionDCE(RewriterBase &rewriter,
        -:  367:                                 MutableArrayRef<Region> regions) {
   124539:  368:  LiveMap liveMap;
call    0 returned 100%
call    1 returned 100%
   121734:  369:  do {
   121734:  370:    liveMap.resetChanged();
        -:  371:
   243444:  372:    for (Region &region : regions)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   121721:  373:      propagateLiveness(region, liveMap);
call    0 returned 100%
   121723:  374:  } while (liveMap.hasChanged());
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  375:
    62243:  376:  return deleteDeadness(rewriter, regions, liveMap);
call    0 returned 100%
        -:  377:}
        -:  378:
        -:  379://===----------------------------------------------------------------------===//
        -:  380:// Block Merging
        -:  381://===----------------------------------------------------------------------===//
        -:  382:
        -:  383://===----------------------------------------------------------------------===//
        -:  384:// BlockEquivalenceData
        -:  385:
        -:  386:namespace {
        -:  387:/// This class contains the information for comparing the equivalencies of two
        -:  388:/// blocks. Blocks are considered equivalent if they contain the same operations
        -:  389:/// in the same order. The only allowed divergence is for operands that come
        -:  390:/// from sources outside of the parent block, i.e. the uses of values produced
        -:  391:/// within the block must be equivalent.
        -:  392:///   e.g.,
        -:  393:/// Equivalent:
        -:  394:///  ^bb1(%arg0: i32)
        -:  395:///    return %arg0, %foo : i32, i32
        -:  396:///  ^bb2(%arg1: i32)
        -:  397:///    return %arg1, %bar : i32, i32
        -:  398:/// Not Equivalent:
        -:  399:///  ^bb1(%arg0: i32)
        -:  400:///    return %foo, %arg0 : i32, i32
        -:  401:///  ^bb2(%arg1: i32)
        -:  402:///    return %arg1, %bar : i32, i32
    #####:  403:struct BlockEquivalenceData {
call    0 never executed
call    1 never executed
        -:  404:  BlockEquivalenceData(Block *block);
        -:  405:
        -:  406:  /// Return the order index for the given value that is within the block of
        -:  407:  /// this data.
        -:  408:  unsigned getOrderOf(Value value) const;
        -:  409:
        -:  410:  /// The block this data refers to.
        -:  411:  Block *block;
        -:  412:  /// A hash value for this block.
        -:  413:  llvm::hash_code hash;
        -:  414:  /// A map of result producing operations to their relative orders within this
        -:  415:  /// block. The order of an operation is the number of defined values that are
        -:  416:  /// produced within the block before this operation.
        -:  417:  DenseMap<Operation *, unsigned> opOrderIndex;
        -:  418:};
        -:  419:} // namespace
        -:  420:
function _ZN12_GLOBAL__N_120BlockEquivalenceDataC2EPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  421:BlockEquivalenceData::BlockEquivalenceData(Block *block)
    #####:  422:    : block(block), hash(0) {
call    0 never executed
    #####:  423:  unsigned orderIt = block->getNumArguments();
    #####:  424:  for (Operation &op : *block) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  425:    if (unsigned numResults = op.getNumResults()) {
branch  0 never executed
branch  1 never executed
    #####:  426:      opOrderIndex.try_emplace(&op, orderIt);
call    0 never executed
    #####:  427:      orderIt += numResults;
        -:  428:    }
    #####:  429:    auto opHash = OperationEquivalence::computeHash(
call    0 never executed
        -:  430:        &op, OperationEquivalence::ignoreHashValue,
        -:  431:        OperationEquivalence::ignoreHashValue,
    #####:  432:        OperationEquivalence::IgnoreLocations);
call    0 never executed
    #####:  433:    hash = llvm::hash_combine(hash, opHash);
call    0 never executed
        -:  434:  }
    #####:  435:}
        -:  436:
function _ZNK12_GLOBAL__N_120BlockEquivalenceData10getOrderOfEN4mlir5ValueE called 0 returned 0% blocks executed 0%
    #####:  437:unsigned BlockEquivalenceData::getOrderOf(Value value) const {
    #####:  438:  assert(value.getParentBlock() == block && "expected value of this block");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  439:
        -:  440:  // Arguments use the argument number as the order index.
    #####:  441:  if (BlockArgument arg = value.dyn_cast<BlockArgument>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  442:    return arg.getArgNumber();
        -:  443:
        -:  444:  // Otherwise, the result order is offset from the parent op's order.
    #####:  445:  OpResult result = value.cast<OpResult>();
call    0 never executed
    #####:  446:  auto opOrderIt = opOrderIndex.find(result.getDefiningOp());
call    0 never executed
call    1 never executed
    #####:  447:  assert(opOrderIt != opOrderIndex.end() && "expected op to have an order");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  448:  return opOrderIt->second + result.getResultNumber();
call    0 never executed
call    1 never executed
        -:  449:}
        -:  450:
        -:  451://===----------------------------------------------------------------------===//
        -:  452:// BlockMergeCluster
        -:  453:
        -:  454:namespace {
        -:  455:/// This class represents a cluster of blocks to be merged together.
        -:  456:class BlockMergeCluster {
        -:  457:public:
function _ZN12_GLOBAL__N_117BlockMergeClusterC2EONS_20BlockEquivalenceDataE called 0 returned 0% blocks executed 0%
    #####:  458:  BlockMergeCluster(BlockEquivalenceData &&leaderData)
    #####:  459:      : leaderData(std::move(leaderData)) {}
call    0 never executed
        -:  460:
        -:  461:  /// Attempt to add the given block to this cluster. Returns success if the
        -:  462:  /// block was merged, failure otherwise.
        -:  463:  LogicalResult addToCluster(BlockEquivalenceData &blockData);
        -:  464:
        -:  465:  /// Try to merge all of the blocks within this cluster into the leader block.
        -:  466:  LogicalResult merge(RewriterBase &rewriter);
        -:  467:
        -:  468:private:
        -:  469:  /// The equivalence data for the leader of the cluster.
        -:  470:  BlockEquivalenceData leaderData;
        -:  471:
        -:  472:  /// The set of blocks that can be merged into the leader.
        -:  473:  llvm::SmallSetVector<Block *, 1> blocksToMerge;
        -:  474:
        -:  475:  /// A set of operand+index pairs that correspond to operands that need to be
        -:  476:  /// replaced by arguments when the cluster gets merged.
        -:  477:  std::set<std::pair<int, int>> operandsToMerge;
        -:  478:};
        -:  479:} // namespace
        -:  480:
function _ZN12_GLOBAL__N_117BlockMergeCluster12addToClusterERNS_20BlockEquivalenceDataE called 0 returned 0% blocks executed 0%
    #####:  481:LogicalResult BlockMergeCluster::addToCluster(BlockEquivalenceData &blockData) {
    #####:  482:  if (leaderData.hash != blockData.hash)
branch  0 never executed
branch  1 never executed
    #####:  483:    return failure();
    #####:  484:  Block *leaderBlock = leaderData.block, *mergeBlock = blockData.block;
    #####:  485:  if (leaderBlock->getArgumentTypes() != mergeBlock->getArgumentTypes())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  486:    return failure();
        -:  487:
        -:  488:  // A set of operands that mismatch between the leader and the new block.
    #####:  489:  SmallVector<std::pair<int, int>, 8> mismatchedOperands;
    #####:  490:  auto lhsIt = leaderBlock->begin(), lhsE = leaderBlock->end();
    #####:  491:  auto rhsIt = blockData.block->begin(), rhsE = blockData.block->end();
    #####:  492:  for (int opI = 0; lhsIt != lhsE && rhsIt != rhsE; ++lhsIt, ++rhsIt, ++opI) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:    // Check that the operations are equivalent.
    #####:  494:    if (!OperationEquivalence::isEquivalentTo(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  495:            &*lhsIt, &*rhsIt, OperationEquivalence::ignoreValueEquivalence,
call    0 never executed
call    1 never executed
        -:  496:            OperationEquivalence::ignoreValueEquivalence,
        -:  497:            OperationEquivalence::Flags::IgnoreLocations))
    #####:  498:      return failure();
        -:  499:
        -:  500:    // Compare the operands of the two operations. If the operand is within
        -:  501:    // the block, it must refer to the same operation.
    #####:  502:    auto lhsOperands = lhsIt->getOperands(), rhsOperands = rhsIt->getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  503:    for (int operand : llvm::seq<int>(0, lhsIt->getNumOperands())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  504:      Value lhsOperand = lhsOperands[operand];
call    0 never executed
    #####:  505:      Value rhsOperand = rhsOperands[operand];
call    0 never executed
    #####:  506:      if (lhsOperand == rhsOperand)
branch  0 never executed
branch  1 never executed
    #####:  507:        continue;
        -:  508:      // Check that the types of the operands match.
    #####:  509:      if (lhsOperand.getType() != rhsOperand.getType())
branch  0 never executed
branch  1 never executed
    #####:  510:        return failure();
        -:  511:
        -:  512:      // Check that these uses are both external, or both internal.
    #####:  513:      bool lhsIsInBlock = lhsOperand.getParentBlock() == leaderBlock;
call    0 never executed
    #####:  514:      bool rhsIsInBlock = rhsOperand.getParentBlock() == mergeBlock;
call    0 never executed
    #####:  515:      if (lhsIsInBlock != rhsIsInBlock)
branch  0 never executed
branch  1 never executed
    #####:  516:        return failure();
        -:  517:      // Let the operands differ if they are defined in a different block. These
        -:  518:      // will become new arguments if the blocks get merged.
    #####:  519:      if (!lhsIsInBlock) {
branch  0 never executed
branch  1 never executed
        -:  520:
        -:  521:        // Check whether the operands aren't the result of an immediate
        -:  522:        // predecessors terminator. In that case we are not able to use it as a
        -:  523:        // successor operand when branching to the merged block as it does not
        -:  524:        // dominate its producing operation.
function _ZZN12_GLOBAL__N_117BlockMergeCluster12addToClusterERNS_20BlockEquivalenceDataEENKUlPN4mlir5BlockENS3_5ValueEE_clES5_S6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  525:        auto isValidSuccessorArg = [](Block *block, Value operand) {
    #####:  526:          if (operand.getDefiningOp() !=
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  527:              operand.getParentBlock()->getTerminator())
call    0 never executed
call    1 never executed
        -:  528:            return true;
    #####:  529:          return !llvm::is_contained(block->getPredecessors(),
call    0 never executed
    #####:  530:                                     operand.getParentBlock());
call    0 never executed
call    1 never executed
        -:  531:        };
        -:  532:
    #####:  533:        if (!isValidSuccessorArg(leaderBlock, lhsOperand) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  534:            !isValidSuccessorArg(mergeBlock, rhsOperand))
call    0 never executed
    #####:  535:          return failure();
        -:  536:
    #####:  537:        mismatchedOperands.emplace_back(opI, operand);
call    0 never executed
    #####:  538:        continue;
        -:  539:      }
        -:  540:
        -:  541:      // Otherwise, these operands must have the same logical order within the
        -:  542:      // parent block.
    #####:  543:      if (leaderData.getOrderOf(lhsOperand) != blockData.getOrderOf(rhsOperand))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  544:        return failure();
        -:  545:    }
        -:  546:
        -:  547:    // If the lhs or rhs has external uses, the blocks cannot be merged as the
        -:  548:    // merged version of this operation will not be either the lhs or rhs
        -:  549:    // alone (thus semantically incorrect), but some mix dependending on which
        -:  550:    // block preceeded this.
        -:  551:    // TODO allow merging of operations when one block does not dominate the
        -:  552:    // other
    #####:  553:    if (rhsIt->isUsedOutsideOfBlock(mergeBlock) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  554:        lhsIt->isUsedOutsideOfBlock(leaderBlock)) {
call    0 never executed
    #####:  555:      return failure();
        -:  556:    }
        -:  557:  }
        -:  558:  // Make sure that the block sizes are equivalent.
    #####:  559:  if (lhsIt != lhsE || rhsIt != rhsE)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:    return failure();
        -:  561:
        -:  562:  // If we get here, the blocks are equivalent and can be merged.
    #####:  563:  operandsToMerge.insert(mismatchedOperands.begin(), mismatchedOperands.end());
    #####:  564:  blocksToMerge.insert(blockData.block);
call    0 never executed
    #####:  565:  return success();
branch  0 never executed
branch  1 never executed
        -:  566:}
        -:  567:
        -:  568:/// Returns true if the predecessor terminators of the given block can not have
        -:  569:/// their operands updated.
function _ZL24ableToUpdatePredOperandsPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  570:static bool ableToUpdatePredOperands(Block *block) {
    #####:  571:  for (auto it = block->pred_begin(), e = block->pred_end(); it != e; ++it) {
branch  0 never executed
branch  1 never executed
    #####:  572:    if (!isa<BranchOpInterface>((*it)->getTerminator()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  573:      return false;
        -:  574:  }
    #####:  575:  return true;
        -:  576:}
        -:  577:
function _ZN12_GLOBAL__N_117BlockMergeCluster5mergeERN4mlir12RewriterBaseE called 0 returned 0% blocks executed 0%
    #####:  578:LogicalResult BlockMergeCluster::merge(RewriterBase &rewriter) {
        -:  579:  // Don't consider clusters that don't have blocks to merge.
    #####:  580:  if (blocksToMerge.empty())
branch  0 never executed
branch  1 never executed
    #####:  581:    return failure();
        -:  582:
    #####:  583:  Block *leaderBlock = leaderData.block;
    #####:  584:  if (!operandsToMerge.empty()) {
branch  0 never executed
branch  1 never executed
        -:  585:    // If the cluster has operands to merge, verify that the predecessor
        -:  586:    // terminators of each of the blocks can have their successor operands
        -:  587:    // updated.
        -:  588:    // TODO: We could try and sub-partition this cluster if only some blocks
        -:  589:    // cause the mismatch.
    #####:  590:    if (!ableToUpdatePredOperands(leaderBlock) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  591:        !llvm::all_of(blocksToMerge, ableToUpdatePredOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  592:      return failure();
        -:  593:
        -:  594:    // Collect the iterators for each of the blocks to merge. We will walk all
        -:  595:    // of the iterators at once to avoid operand index invalidation.
    #####:  596:    SmallVector<Block::iterator, 2> blockIterators;
branch  0 never executed
branch  1 never executed
    #####:  597:    blockIterators.reserve(blocksToMerge.size() + 1);
branch  0 never executed
branch  1 never executed
    #####:  598:    blockIterators.push_back(leaderBlock->begin());
call    0 never executed
    #####:  599:    for (Block *mergeBlock : blocksToMerge)
branch  0 never executed
branch  1 never executed
    #####:  600:      blockIterators.push_back(mergeBlock->begin());
call    0 never executed
        -:  601:
        -:  602:    // Update each of the predecessor terminators with the new arguments.
    #####:  603:    SmallVector<SmallVector<Value, 8>, 2> newArguments(
call    0 never executed
    #####:  604:        1 + blocksToMerge.size(),
    #####:  605:        SmallVector<Value, 8>(operandsToMerge.size()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  606:    unsigned curOpIndex = 0;
    #####:  607:    for (const auto &it : llvm::enumerate(operandsToMerge)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  608:      unsigned nextOpOffset = it.value().first - curOpIndex;
    #####:  609:      curOpIndex = it.value().first;
        -:  610:
        -:  611:      // Process the operand for each of the block iterators.
    #####:  612:      for (unsigned i = 0, e = blockIterators.size(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  613:        Block::iterator &blockIter = blockIterators[i];
branch  0 never executed
branch  1 never executed
    #####:  614:        std::advance(blockIter, nextOpOffset);
branch  0 never executed
branch  1 never executed
    #####:  615:        auto &operand = blockIter->getOpOperand(it.value().second);
call    0 never executed
call    1 never executed
    #####:  616:        newArguments[i][it.index()] = operand.get();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  617:
        -:  618:        // Update the operand and insert an argument if this is the leader.
    #####:  619:        if (i == 0) {
branch  0 never executed
branch  1 never executed
    #####:  620:          Value operandVal = operand.get();
call    0 never executed
    #####:  621:          operand.set(leaderBlock->addArgument(operandVal.getType(),
    #####:  622:                                               operandVal.getLoc()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  623:        }
        -:  624:      }
        -:  625:    }
        -:  626:    // Update the predecessors for each of the blocks.
function _ZZN12_GLOBAL__N_117BlockMergeCluster5mergeERN4mlir12RewriterBaseEENKUlPNS1_5BlockEjE_clES5_j.isra.0 called 0 returned 0% blocks executed 0%
    #####:  627:    auto updatePredecessors = [&](Block *block, unsigned clusterIndex) {
    #####:  628:      for (auto predIt = block->pred_begin(), predE = block->pred_end();
    #####:  629:           predIt != predE; ++predIt) {
branch  0 never executed
branch  1 never executed
    #####:  630:        auto branch = cast<BranchOpInterface>((*predIt)->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  631:        unsigned succIndex = predIt.getSuccessorIndex();
call    0 never executed
    #####:  632:        branch.getSuccessorOperands(succIndex).append(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  633:            newArguments[clusterIndex]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  634:      }
    #####:  635:    };
    #####:  636:    updatePredecessors(leaderBlock, /*clusterIndex=*/0);
call    0 never executed
    #####:  637:    for (unsigned i = 0, e = blocksToMerge.size(); i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  638:      updatePredecessors(blocksToMerge[i], /*clusterIndex=*/i + 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  639:  }
        -:  640:
        -:  641:  // Replace all uses of the merged blocks with the leader and erase them.
    #####:  642:  for (Block *block : blocksToMerge) {
branch  0 never executed
branch  1 never executed
    #####:  643:    block->replaceAllUsesWith(leaderBlock);
call    0 never executed
    #####:  644:    rewriter.eraseBlock(block);
call    0 never executed
        -:  645:  }
    #####:  646:  return success();
        -:  647:}
        -:  648:
        -:  649:/// Identify identical blocks within the given region and merge them, inserting
        -:  650:/// new block arguments as necessary. Returns success if any blocks were merged,
        -:  651:/// failure otherwise.
function _ZL20mergeIdenticalBlocksRN4mlir12RewriterBaseERNS_6RegionE called 96979 returned 100% blocks executed 10%
    96979:  652:static LogicalResult mergeIdenticalBlocks(RewriterBase &rewriter,
        -:  653:                                          Region &region) {
   96979*:  654:  if (region.empty() || llvm::hasSingleElement(region))
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
    96979:  655:    return failure();
        -:  656:
        -:  657:  // Identify sets of blocks, other than the entry block, that branch to the
        -:  658:  // same successors. We will use these groups to create clusters of equivalent
        -:  659:  // blocks.
    #####:  660:  DenseMap<SuccessorRange, SmallVector<Block *, 1>> matchingSuccessors;
call    0 never executed
call    1 never executed
    #####:  661:  for (Block &block : llvm::drop_begin(region, 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  662:    matchingSuccessors[block.getSuccessors()].push_back(&block);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  663:
    #####:  664:  bool mergedAnyBlocks = false;
    #####:  665:  for (ArrayRef<Block *> blocks : llvm::make_second_range(matchingSuccessors)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  666:    if (blocks.size() == 1)
branch  0 never executed
branch  1 never executed
    #####:  667:      continue;
        -:  668:
    #####:  669:    SmallVector<BlockMergeCluster, 1> clusters;
call    0 never executed
    #####:  670:    for (Block *block : blocks) {
branch  0 never executed
branch  1 never executed
    #####:  671:      BlockEquivalenceData data(block);
call    0 never executed
        -:  672:
        -:  673:      // Don't allow merging if this block has any regions.
        -:  674:      // TODO: Add support for regions if necessary.
function _ZZL20mergeIdenticalBlocksRN4mlir12RewriterBaseERNS_6RegionEENKUlRNS_9OperationEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  675:      bool hasNonEmptyRegion = llvm::any_of(*block, [](Operation &op) {
call    0 never executed
    #####:  676:        return llvm::any_of(op.getRegions(),
branch  0 never executed
branch  1 never executed
    #####:  677:                            [](Region &region) { return !region.empty(); });
        -:  678:      });
    #####:  679:      if (hasNonEmptyRegion)
branch  0 never executed
branch  1 never executed
    #####:  680:        continue;
call    0 never executed
        -:  681:
        -:  682:      // Try to add this block to an existing cluster.
    #####:  683:      bool addedToCluster = false;
    #####:  684:      for (auto &cluster : clusters)
branch  0 never executed
branch  1 never executed
    #####:  685:        if ((addedToCluster = succeeded(cluster.addToCluster(data))))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  686:          break;
    #####:  687:      if (!addedToCluster)
branch  0 never executed
branch  1 never executed
    #####:  688:        clusters.emplace_back(std::move(data));
call    0 never executed
        -:  689:    }
    #####:  690:    for (auto &cluster : clusters)
branch  0 never executed
branch  1 never executed
    #####:  691:      mergedAnyBlocks |= succeeded(cluster.merge(rewriter));
call    0 never executed
        -:  692:  }
        -:  693:
    #####:  694:  return success(mergedAnyBlocks);
call    0 never executed
        -:  695:}
        -:  696:
        -:  697:/// Identify identical blocks within the given regions and merge them, inserting
        -:  698:/// new block arguments as necessary.
function _ZL20mergeIdenticalBlocksRN4mlir12RewriterBaseEN4llvm15MutableArrayRefINS_6RegionEEE called 62261 returned 100% blocks executed 93%
    62261:  699:static LogicalResult mergeIdenticalBlocks(RewriterBase &rewriter,
        -:  700:                                          MutableArrayRef<Region> regions) {
    62261:  701:  llvm::SmallSetVector<Region *, 1> worklist;
call    0 returned 100%
   124533:  702:  for (auto &region : regions)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    62235:  703:    worklist.insert(&region);
call    0 returned 100%
        -:  704:  bool anyChanged = false;
   159268:  705:  while (!worklist.empty()) {
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
    97012:  706:    Region *region = worklist.pop_back_val();
call    0 returned 100%
    96992:  707:    if (succeeded(mergeIdenticalBlocks(rewriter, *region))) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  708:      worklist.insert(region);
    #####:  709:      anyChanged = true;
call    0 never executed
        -:  710:    }
        -:  711:
        -:  712:    // Add any nested regions to the worklist.
   187504:  713:    for (Block &block : *region)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
   787047:  714:      for (auto &op : block)
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
call    2 returned 100%
   943399:  715:        for (auto &nestedRegion : op.getRegions())
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
branch  2 taken 5% (fallthrough)
branch  3 taken 95%
    34726:  716:          worklist.insert(&nestedRegion);
call    0 returned 100%
        -:  717:  }
        -:  718:
    62256:  719:  return success(anyChanged);
call    0 returned 100%
        -:  720:}
        -:  721:
        -:  722://===----------------------------------------------------------------------===//
        -:  723:// Region Simplification
        -:  724://===----------------------------------------------------------------------===//
        -:  725:
        -:  726:/// Run a set of structural simplifications over the given regions. This
        -:  727:/// includes transformations like unreachable block elimination, dead argument
        -:  728:/// elimination, as well as some other DCE. This function returns success if any
        -:  729:/// of the regions were simplified, failure otherwise.
function _ZN4mlir15simplifyRegionsERNS_12RewriterBaseEN4llvm15MutableArrayRefINS_6RegionEEE called 62246 returned 100% blocks executed 100%
    62246:  730:LogicalResult mlir::simplifyRegions(RewriterBase &rewriter,
        -:  731:                                    MutableArrayRef<Region> regions) {
    62246:  732:  bool eliminatedBlocks = succeeded(eraseUnreachableBlocks(rewriter, regions));
call    0 returned 100%
    62252:  733:  bool eliminatedOpsOrArgs = succeeded(runRegionDCE(rewriter, regions));
call    0 returned 100%
    62268:  734:  bool mergedIdenticalBlocks =
    62268:  735:      succeeded(mergeIdenticalBlocks(rewriter, regions));
call    0 returned 100%
    62240:  736:  return success(eliminatedBlocks || eliminatedOpsOrArgs ||
branch  0 taken 100% (fallthrough)
branch  1 taken -0%
branch  2 taken 100% (fallthrough)
branch  3 taken -0%
    62240:  737:                 mergedIdenticalBlocks);
        -:  738:}
