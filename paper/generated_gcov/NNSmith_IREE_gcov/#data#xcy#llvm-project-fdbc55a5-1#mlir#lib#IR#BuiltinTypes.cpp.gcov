        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/BuiltinTypes.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/BuiltinTypes.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/BuiltinTypes.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- BuiltinTypes.cpp - MLIR Builtin Type Classes -----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/BuiltinTypes.h"
        -:   10:#include "TypeDetail.h"
        -:   11:#include "mlir/IR/AffineExpr.h"
        -:   12:#include "mlir/IR/AffineMap.h"
        -:   13:#include "mlir/IR/BuiltinAttributes.h"
        -:   14:#include "mlir/IR/BuiltinDialect.h"
        -:   15:#include "mlir/IR/Diagnostics.h"
        -:   16:#include "mlir/IR/Dialect.h"
        -:   17:#include "mlir/IR/FunctionInterfaces.h"
        -:   18:#include "mlir/IR/OpImplementation.h"
        -:   19:#include "mlir/IR/TensorEncoding.h"
        -:   20:#include "llvm/ADT/APFloat.h"
        -:   21:#include "llvm/ADT/BitVector.h"
        -:   22:#include "llvm/ADT/Sequence.h"
        -:   23:#include "llvm/ADT/Twine.h"
        -:   24:#include "llvm/ADT/TypeSwitch.h"
        -:   25:
        -:   26:using namespace mlir;
        -:   27:using namespace mlir::detail;
        -:   28:
        -:   29://===----------------------------------------------------------------------===//
        -:   30:/// Tablegen Type Definitions
        -:   31://===----------------------------------------------------------------------===//
        -:   32:
        -:   33:#define GET_TYPEDEF_CLASSES
        -:   34:#include "mlir/IR/BuiltinTypes.cpp.inc"
        -:   35:
        -:   36://===----------------------------------------------------------------------===//
        -:   37:// BuiltinDialect
        -:   38://===----------------------------------------------------------------------===//
        -:   39:
function _ZN4mlir14BuiltinDialect13registerTypesEv called 524218 returned 100% blocks executed 100%
   524218:   40:void BuiltinDialect::registerTypes() {
   524218:   41:  addTypes<
        -:   42:#define GET_TYPEDEF_LIST
        -:   43:#include "mlir/IR/BuiltinTypes.cpp.inc"
   524218:   44:      >();
call    0 returned 100%
   524218:   45:}
        -:   46:
        -:   47://===----------------------------------------------------------------------===//
        -:   48:/// ComplexType
        -:   49://===----------------------------------------------------------------------===//
        -:   50:
        -:   51:/// Verify the construction of an integer type.
function _ZN4mlir11ComplexType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:   52:LogicalResult ComplexType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:   53:                                  Type elementType) {
    #####:   54:  if (!elementType.isIntOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   55:    return emitError() << "invalid element type for complex";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   56:  return success();
        -:   57:}
        -:   58:
        -:   59://===----------------------------------------------------------------------===//
        -:   60:// Integer Type
        -:   61://===----------------------------------------------------------------------===//
        -:   62:
        -:   63:/// Verify the construction of an integer type.
function _ZN4mlir11IntegerType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEEjNS0_19SignednessSemanticsE called 6564 returned 100% blocks executed 30%
     6564:   64:LogicalResult IntegerType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:   65:                                  unsigned width,
        -:   66:                                  SignednessSemantics signedness) {
     6564:   67:  if (width > IntegerType::kMaxWidth) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   68:    return emitError() << "integer bitwidth is limited to "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   69:                       << IntegerType::kMaxWidth << " bits";
call    0 never executed
call    1 never executed
        -:   70:  }
     6564:   71:  return success();
        -:   72:}
        -:   73:
function _ZNK4mlir11IntegerType8getWidthEv called 30453169 returned 100% blocks executed 100%
    #####:   74:unsigned IntegerType::getWidth() const { return getImpl()->width; }
call    0 never executed
        -:   75:
function _ZNK4mlir11IntegerType13getSignednessEv called 30794782 returned 100% blocks executed 100%
30794782*:   76:IntegerType::SignednessSemantics IntegerType::getSignedness() const {
30794782*:   77:  return getImpl()->signedness;
        -:   78:}
        -:   79:
function _ZN4mlir11IntegerType20scaleElementBitwidthEj called 0 returned 0% blocks executed 0%
    #####:   80:IntegerType IntegerType::scaleElementBitwidth(unsigned scale) {
    #####:   81:  if (!scale)
branch  0 never executed
branch  1 never executed
    #####:   82:    return IntegerType();
    #####:   83:  return IntegerType::get(getContext(), scale * getWidth(), getSignedness());
call    0 never executed
call    1 never executed
        -:   84:}
        -:   85:
        -:   86://===----------------------------------------------------------------------===//
        -:   87:// Float Type
        -:   88://===----------------------------------------------------------------------===//
        -:   89:
function _ZN4mlir9FloatType8getWidthEv called 3687668 returned 100% blocks executed 50%
  3687668:   90:unsigned FloatType::getWidth() {
  3687668:   91:  if (isa<Float8E5M2Type>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   92:    return 8;
  3687668:   93:  if (isa<Float16Type, BFloat16Type>())
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
        -:   94:    return 16;
  3458997:   95:  if (isa<Float32Type>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   96:    return 32;
    #####:   97:  if (isa<Float64Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   98:    return 64;
    #####:   99:  if (isa<Float80Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  100:    return 80;
    #####:  101:  if (isa<Float128Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  102:    return 128;
    #####:  103:  llvm_unreachable("unexpected float type");
call    0 never executed
        -:  104:}
        -:  105:
        -:  106:/// Returns the floating semantics for the given type.
function _ZN4mlir9FloatType17getFloatSemanticsEv called 2489883 returned 100% blocks executed 48%
  2489883:  107:const llvm::fltSemantics &FloatType::getFloatSemantics() {
  2489883:  108:  if (isa<Float8E5M2Type>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  109:    return APFloat::Float8E5M2();
  2489883:  110:  if (isa<BFloat16Type>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  111:    return APFloat::BFloat();
  2489883:  112:  if (isa<Float16Type>())
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
   130626:  113:    return APFloat::IEEEhalf();
  2359257:  114:  if (isa<Float32Type>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2359257:  115:    return APFloat::IEEEsingle();
    #####:  116:  if (isa<Float64Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  117:    return APFloat::IEEEdouble();
    #####:  118:  if (isa<Float80Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  119:    return APFloat::x87DoubleExtended();
    #####:  120:  if (isa<Float128Type>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  121:    return APFloat::IEEEquad();
    #####:  122:  llvm_unreachable("non-floating point type used");
call    0 never executed
        -:  123:}
        -:  124:
function _ZN4mlir9FloatType20scaleElementBitwidthEj called 0 returned 0% blocks executed 0%
    #####:  125:FloatType FloatType::scaleElementBitwidth(unsigned scale) {
    #####:  126:  if (!scale)
branch  0 never executed
branch  1 never executed
    #####:  127:    return FloatType();
    #####:  128:  MLIRContext *ctx = getContext();
call    0 never executed
    #####:  129:  if (isF16() || isBF16()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  130:    if (scale == 2)
branch  0 never executed
branch  1 never executed
    #####:  131:      return FloatType::getF32(ctx);
call    0 never executed
    #####:  132:    if (scale == 4)
branch  0 never executed
branch  1 never executed
    #####:  133:      return FloatType::getF64(ctx);
call    0 never executed
        -:  134:  }
    #####:  135:  if (isF32())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  136:    if (scale == 2)
branch  0 never executed
branch  1 never executed
    #####:  137:      return FloatType::getF64(ctx);
call    0 never executed
    #####:  138:  return FloatType();
        -:  139:}
        -:  140:
function _ZN4mlir9FloatType18getFPMantissaWidthEv called 0 returned 0% blocks executed 0%
    #####:  141:unsigned FloatType::getFPMantissaWidth() {
    #####:  142:  return APFloat::semanticsPrecision(getFloatSemantics());
call    0 never executed
call    1 never executed
        -:  143:}
        -:  144:
        -:  145://===----------------------------------------------------------------------===//
        -:  146:// FunctionType
        -:  147://===----------------------------------------------------------------------===//
        -:  148:
function _ZNK4mlir12FunctionType12getNumInputsEv called 13878 returned 100% blocks executed 100%
   13878*:  149:unsigned FunctionType::getNumInputs() const { return getImpl()->numInputs; }
        -:  150:
function _ZNK4mlir12FunctionType9getInputsEv called 5615406 returned 100% blocks executed 100%
 5615410*:  151:ArrayRef<Type> FunctionType::getInputs() const {
       4*:  152:  return getImpl()->getInputs();
        -:  153:}
        -:  154:
function _ZNK4mlir12FunctionType13getNumResultsEv called 6965 returned 100% blocks executed 100%
     6965:  155:unsigned FunctionType::getNumResults() const { return getImpl()->numResults; }
        -:  156:
function _ZNK4mlir12FunctionType10getResultsEv called 5543125 returned 100% blocks executed 100%
 5543129*:  157:ArrayRef<Type> FunctionType::getResults() const {
 5543129*:  158:  return getImpl()->getResults();
        -:  159:}
        -:  160:
function _ZNK4mlir12FunctionType5cloneENS_9TypeRangeES1_ called 3639 returned 100% blocks executed 100%
     3639:  161:FunctionType FunctionType::clone(TypeRange inputs, TypeRange results) const {
     3639:  162:  return get(getContext(), inputs, results);
call    0 returned 100%
call    1 returned 100%
        -:  163:}
        -:  164:
        -:  165:/// Returns a new function type with the specified arguments and results
        -:  166:/// inserted.
function _ZN4mlir12FunctionType21getWithArgsAndResultsEN4llvm8ArrayRefIjEENS_9TypeRangeES3_S4_ called 0 returned 0% blocks executed 0%
    #####:  167:FunctionType FunctionType::getWithArgsAndResults(
        -:  168:    ArrayRef<unsigned> argIndices, TypeRange argTypes,
        -:  169:    ArrayRef<unsigned> resultIndices, TypeRange resultTypes) {
    #####:  170:  SmallVector<Type> argStorage, resultStorage;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  171:  TypeRange newArgTypes = function_interface_impl::insertTypesInto(
call    0 never executed
    #####:  172:      getInputs(), argIndices, argTypes, argStorage);
call    0 never executed
call    1 never executed
    #####:  173:  TypeRange newResultTypes = function_interface_impl::insertTypesInto(
call    0 never executed
    #####:  174:      getResults(), resultIndices, resultTypes, resultStorage);
call    0 never executed
call    1 never executed
    #####:  175:  return clone(newArgTypes, newResultTypes);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  176:}
        -:  177:
        -:  178:/// Returns a new function type without the specified arguments and results.
        -:  179:FunctionType
function _ZN4mlir12FunctionType24getWithoutArgsAndResultsERKN4llvm9BitVectorES4_ called 0 returned 0% blocks executed 0%
    #####:  180:FunctionType::getWithoutArgsAndResults(const BitVector &argIndices,
        -:  181:                                       const BitVector &resultIndices) {
    #####:  182:  SmallVector<Type> argStorage, resultStorage;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  183:  TypeRange newArgTypes = function_interface_impl::filterTypesOut(
call    0 never executed
    #####:  184:      getInputs(), argIndices, argStorage);
call    0 never executed
call    1 never executed
    #####:  185:  TypeRange newResultTypes = function_interface_impl::filterTypesOut(
call    0 never executed
    #####:  186:      getResults(), resultIndices, resultStorage);
call    0 never executed
call    1 never executed
    #####:  187:  return clone(newArgTypes, newResultTypes);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  188:}
        -:  189:
function _ZNK4mlir12FunctionType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 4 returned 100% blocks executed 100%
        4:  190:void FunctionType::walkImmediateSubElements(
        -:  191:    function_ref<void(Attribute)> walkAttrsFn,
        -:  192:    function_ref<void(Type)> walkTypesFn) const {
       18:  193:  for (Type type : llvm::concat<const Type>(getInputs(), getResults()))
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
call    2 returned 100%
       10:  194:    walkTypesFn(type);
call    0 returned 100%
call    1 returned 100%
        4:  195:}
        -:  196:
function _ZNK4mlir12FunctionType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  197:Type FunctionType::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  198:                                               ArrayRef<Type> replTypes) const {
    #####:  199:  unsigned numInputs = getNumInputs();
call    0 never executed
    #####:  200:  return get(getContext(), replTypes.take_front(numInputs),
    #####:  201:             replTypes.drop_front(numInputs));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  202:}
        -:  203:
        -:  204://===----------------------------------------------------------------------===//
        -:  205:// OpaqueType
        -:  206://===----------------------------------------------------------------------===//
        -:  207:
        -:  208:/// Verify the construction of an opaque type.
function _ZN4mlir10OpaqueType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_10StringAttrENS1_9StringRefE called 0 returned 0% blocks executed 0%
    #####:  209:LogicalResult OpaqueType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  210:                                 StringAttr dialect, StringRef typeData) {
    #####:  211:  if (!Dialect::isValidNamespace(dialect.strref()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  212:    return emitError() << "invalid dialect namespace '" << dialect << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  213:
        -:  214:  // Check that the dialect is actually registered.
    #####:  215:  MLIRContext *context = dialect.getContext();
call    0 never executed
    #####:  216:  if (!context->allowsUnregisteredDialects() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  217:      !context->getLoadedDialect(dialect.strref())) {
call    0 never executed
    #####:  218:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  219:           << "`!" << dialect << "<\"" << typeData << "\">"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  220:           << "` type created with unregistered dialect. If this is "
        -:  221:              "intended, please call allowUnregisteredDialects() on the "
        -:  222:              "MLIRContext, or use -allow-unregistered-dialect with "
    #####:  223:              "the MLIR opt tool used";
call    0 never executed
        -:  224:  }
        -:  225:
    #####:  226:  return success();
        -:  227:}
        -:  228:
        -:  229://===----------------------------------------------------------------------===//
        -:  230:// VectorType
        -:  231://===----------------------------------------------------------------------===//
        -:  232:
function _ZN4mlir10VectorType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeEj called 7 returned 100% blocks executed 29%
        7:  233:LogicalResult VectorType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  234:                                 ArrayRef<int64_t> shape, Type elementType,
        -:  235:                                 unsigned numScalableDims) {
        7:  236:  if (!isValidElementType(elementType))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  237:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  238:           << "vector elements must be int/index/float type but got "
call    0 never executed
    #####:  239:           << elementType;
call    0 never executed
        -:  240:
        7:  241:  if (any_of(shape, [](int64_t i) { return i <= 0; }))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  242:    return emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  243:           << "vector types must have positive constant sizes but got "
call    0 never executed
    #####:  244:           << shape;
call    0 never executed
        -:  245:
        7:  246:  return success();
        -:  247:}
        -:  248:
function _ZN4mlir10VectorType20scaleElementBitwidthEj called 0 returned 0% blocks executed 0%
    #####:  249:VectorType VectorType::scaleElementBitwidth(unsigned scale) {
    #####:  250:  if (!scale)
branch  0 never executed
branch  1 never executed
    #####:  251:    return VectorType();
    #####:  252:  if (auto et = getElementType().dyn_cast<IntegerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:    if (auto scaledEt = et.scaleElementBitwidth(scale))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  254:      return VectorType::get(getShape(), scaledEt, getNumScalableDims());
call    0 never executed
    #####:  255:  if (auto et = getElementType().dyn_cast<FloatType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  256:    if (auto scaledEt = et.scaleElementBitwidth(scale))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  257:      return VectorType::get(getShape(), scaledEt, getNumScalableDims());
call    0 never executed
    #####:  258:  return VectorType();
        -:  259:}
        -:  260:
function _ZNK4mlir10VectorType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
       3*:  261:void VectorType::walkImmediateSubElements(
        -:  262:    function_ref<void(Attribute)> walkAttrsFn,
        -:  263:    function_ref<void(Type)> walkTypesFn) const {
       3*:  264:  walkTypesFn(getElementType());
call    0 returned 100%
call    1 never executed
    #####:  265:}
        -:  266:
function _ZNK4mlir10VectorType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  267:Type VectorType::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  268:                                             ArrayRef<Type> replTypes) const {
    #####:  269:  return get(getShape(), replTypes.front(), getNumScalableDims());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  270:}
        -:  271:
function _ZNK4mlir10VectorType9cloneWithEN4llvm8OptionalINS1_8ArrayRefIlEEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  272:VectorType VectorType::cloneWith(Optional<ArrayRef<int64_t>> shape,
        -:  273:                                 Type elementType) const {
    #####:  274:  return VectorType::get(shape.value_or(getShape()), elementType,
branch  0 never executed
branch  1 never executed
    #####:  275:                         getNumScalableDims());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  276:}
        -:  277:
        -:  278://===----------------------------------------------------------------------===//
        -:  279:// TensorType
        -:  280://===----------------------------------------------------------------------===//
        -:  281:
function _ZNK4mlir10TensorType14getElementTypeEv called 13066 returned 100% blocks executed 80%
    13066:  282:Type TensorType::getElementType() const {
    13066:  283:  return llvm::TypeSwitch<TensorType, Type>(*this)
call    0 returned 100%
        -:  284:      .Case<RankedTensorType, UnrankedTensorType>(
    13066:  285:          [](auto type) { return type.getElementType(); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  286:}
        -:  287:
function _ZNK4mlir10TensorType7hasRankEv called 30228 returned 100% blocks executed 100%
10710463*:  288:bool TensorType::hasRank() const { return !isa<UnrankedTensorType>(); }
call    0 never executed
call    1 returned 100%
call    2 returned 100%
        -:  289:
function _ZNK4mlir10TensorType8getShapeEv called 19581 returned 100% blocks executed 100%
    19581:  290:ArrayRef<int64_t> TensorType::getShape() const {
    19581:  291:  return cast<RankedTensorType>().getShape();
call    0 returned 100%
        -:  292:}
        -:  293:
function _ZNK4mlir10TensorType9cloneWithEN4llvm8OptionalINS1_8ArrayRefIlEEEENS_4TypeE called 6175 returned 100% blocks executed 44%
     6175:  294:TensorType TensorType::cloneWith(Optional<ArrayRef<int64_t>> shape,
        -:  295:                                 Type elementType) const {
     6175:  296:  if (auto unrankedTy = dyn_cast<UnrankedTensorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  297:    if (shape)
branch  0 never executed
branch  1 never executed
    #####:  298:      return RankedTensorType::get(*shape, elementType);
call    0 never executed
    #####:  299:    return UnrankedTensorType::get(elementType);
call    0 never executed
        -:  300:  }
        -:  301:
     6175:  302:  auto rankedTy = cast<RankedTensorType>();
call    0 returned 100%
     6175:  303:  if (!shape)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  304:    return RankedTensorType::get(rankedTy.getShape(), elementType,
call    0 never executed
    #####:  305:                                 rankedTy.getEncoding());
call    0 never executed
     6175:  306:  return RankedTensorType::get(shape.value_or(rankedTy.getShape()), elementType,
call    0 returned 100%
    12350:  307:                               rankedTy.getEncoding());
call    0 returned 100%
        -:  308:}
        -:  309:
        -:  310:// Check if "elementType" can be an element type of a tensor.
        -:  311:static LogicalResult
function _ZL22checkTensorElementTypeN4llvm12function_refIFN4mlir18InFlightDiagnosticEvEEENS1_4TypeE called 11037894 returned 100% blocks executed 40%
 11037894:  312:checkTensorElementType(function_ref<InFlightDiagnostic()> emitError,
        -:  313:                       Type elementType) {
 11037894:  314:  if (!TensorType::isValidElementType(elementType))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  315:    return emitError() << "invalid tensor element type: " << elementType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
 11037894:  316:  return success();
        -:  317:}
        -:  318:
        -:  319:/// Return true if the specified element type is ok in a tensor.
function _ZN4mlir10TensorType18isValidElementTypeENS_4TypeE called 22032117 returned 100% blocks executed 43%
 22032117:  320:bool TensorType::isValidElementType(Type type) {
        -:  321:  // Note: Non standard/builtin types are allowed to exist within tensor
        -:  322:  // types. Dialects are expected to verify that tensor types have a valid
        -:  323:  // element type within that dialect.
 22032117:  324:  return type.isa<ComplexType, FloatType, IntegerType, OpaqueType, VectorType,
call    0 returned 100%
22032117*:  325:                  IndexType>() ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  326:         !llvm::isa<BuiltinDialect>(type.getDialect());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  327:}
        -:  328:
        -:  329://===----------------------------------------------------------------------===//
        -:  330:// RankedTensorType
        -:  331://===----------------------------------------------------------------------===//
        -:  332:
        -:  333:LogicalResult
function _ZN4mlir16RankedTensorType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeENS_9AttributeE called 11037894 returned 100% blocks executed 42%
 11037894:  334:RankedTensorType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  335:                         ArrayRef<int64_t> shape, Type elementType,
        -:  336:                         Attribute encoding) {
 52386368:  337:  for (int64_t s : shape)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
41348474*:  338:    if (s < 0 && !ShapedType::isDynamic(s))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  339:      return emitError() << "invalid tensor dimension size";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
 11037894:  340:  if (auto v = encoding.dyn_cast_or_null<VerifiableTensorEncoding>())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  341:    if (failed(v.verifyEncoding(shape, elementType, emitError)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  342:      return failure();
 11037894:  343:  return checkTensorElementType(emitError, elementType);
call    0 returned 100%
        -:  344:}
        -:  345:
function _ZNK4mlir16RankedTensorType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
  789222*:  346:void RankedTensorType::walkImmediateSubElements(
        -:  347:    function_ref<void(Attribute)> walkAttrsFn,
        -:  348:    function_ref<void(Type)> walkTypesFn) const {
  789222*:  349:  walkTypesFn(getElementType());
call    0 returned 100%
call    1 never executed
  789222*:  350:  if (Attribute encoding = getEncoding())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  351:    walkAttrsFn(encoding);
call    0 never executed
call    1 never executed
    #####:  352:}
        -:  353:
function _ZNK4mlir16RankedTensorType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  354:Type RankedTensorType::replaceImmediateSubElements(
        -:  355:    ArrayRef<Attribute> replAttrs, ArrayRef<Type> replTypes) const {
    #####:  356:  return get(getShape(), replTypes.front(),
call    0 never executed
    #####:  357:             replAttrs.empty() ? Attribute() : replAttrs.back());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  358:}
        -:  359:
        -:  360://===----------------------------------------------------------------------===//
        -:  361:// UnrankedTensorType
        -:  362://===----------------------------------------------------------------------===//
        -:  363:
        -:  364:LogicalResult
function _ZN4mlir18UnrankedTensorType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  365:UnrankedTensorType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  366:                           Type elementType) {
    #####:  367:  return checkTensorElementType(emitError, elementType);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  368:}
        -:  369:
function _ZNK4mlir18UnrankedTensorType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
    #####:  370:void UnrankedTensorType::walkImmediateSubElements(
        -:  371:    function_ref<void(Attribute)> walkAttrsFn,
        -:  372:    function_ref<void(Type)> walkTypesFn) const {
    #####:  373:  walkTypesFn(getElementType());
call    0 never executed
call    1 never executed
    #####:  374:}
        -:  375:
function _ZNK4mlir18UnrankedTensorType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  376:Type UnrankedTensorType::replaceImmediateSubElements(
        -:  377:    ArrayRef<Attribute> replAttrs, ArrayRef<Type> replTypes) const {
    #####:  378:  return get(replTypes.front());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  379:}
        -:  380:
        -:  381://===----------------------------------------------------------------------===//
        -:  382:// BaseMemRefType
        -:  383://===----------------------------------------------------------------------===//
        -:  384:
function _ZNK4mlir14BaseMemRefType14getElementTypeEv called 12 returned 100% blocks executed 80%
       12:  385:Type BaseMemRefType::getElementType() const {
       12:  386:  return llvm::TypeSwitch<BaseMemRefType, Type>(*this)
call    0 returned 100%
        -:  387:      .Case<MemRefType, UnrankedMemRefType>(
       12:  388:          [](auto type) { return type.getElementType(); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  389:}
        -:  390:
function _ZNK4mlir14BaseMemRefType7hasRankEv called 265 returned 100% blocks executed 100%
  178004*:  391:bool BaseMemRefType::hasRank() const { return !isa<UnrankedMemRefType>(); }
call    0 never executed
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 returned 100%
        -:  392:
function _ZNK4mlir14BaseMemRefType8getShapeEv called 12 returned 100% blocks executed 100%
       12:  393:ArrayRef<int64_t> BaseMemRefType::getShape() const {
       12:  394:  return cast<MemRefType>().getShape();
call    0 returned 100%
        -:  395:}
        -:  396:
function _ZNK4mlir14BaseMemRefType9cloneWithEN4llvm8OptionalINS1_8ArrayRefIlEEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  397:BaseMemRefType BaseMemRefType::cloneWith(Optional<ArrayRef<int64_t>> shape,
        -:  398:                                         Type elementType) const {
    #####:  399:  if (auto unrankedTy = dyn_cast<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  400:    if (!shape)
branch  0 never executed
branch  1 never executed
    #####:  401:      return UnrankedMemRefType::get(elementType, getMemorySpace());
call    0 never executed
call    1 never executed
    #####:  402:    MemRefType::Builder builder(*shape, elementType);
call    0 never executed
    #####:  403:    builder.setMemorySpace(getMemorySpace());
call    0 never executed
call    1 never executed
    #####:  404:    return builder;
call    0 never executed
        -:  405:  }
        -:  406:
    #####:  407:  MemRefType::Builder builder(cast<MemRefType>());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  408:  if (shape)
branch  0 never executed
branch  1 never executed
    #####:  409:    builder.setShape(*shape);
    #####:  410:  builder.setElementType(elementType);
call    0 never executed
    #####:  411:  return builder;
call    0 never executed
        -:  412:}
        -:  413:
function _ZNK4mlir14BaseMemRefType14getMemorySpaceEv called 104 returned 100% blocks executed 67%
      104:  414:Attribute BaseMemRefType::getMemorySpace() const {
      104:  415:  if (auto rankedMemRefTy = dyn_cast<MemRefType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      104:  416:    return rankedMemRefTy.getMemorySpace();
    #####:  417:  return cast<UnrankedMemRefType>().getMemorySpace();
call    0 never executed
        -:  418:}
        -:  419:
function _ZNK4mlir14BaseMemRefType19getMemorySpaceAsIntEv called 12 returned 100% blocks executed 67%
       12:  420:unsigned BaseMemRefType::getMemorySpaceAsInt() const {
       12:  421:  if (auto rankedMemRefTy = dyn_cast<MemRefType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       12:  422:    return rankedMemRefTy.getMemorySpaceAsInt();
    #####:  423:  return cast<UnrankedMemRefType>().getMemorySpaceAsInt();
call    0 never executed
        -:  424:}
        -:  425:
        -:  426://===----------------------------------------------------------------------===//
        -:  427:// MemRefType
        -:  428://===----------------------------------------------------------------------===//
        -:  429:
        -:  430:/// Given an `originalShape` and a `reducedShape` assumed to be a subset of
        -:  431:/// `originalShape` with some `1` entries erased, return the set of indices
        -:  432:/// that specifies which of the entries of `originalShape` are dropped to obtain
        -:  433:/// `reducedShape`. The returned mask can be applied as a projection to
        -:  434:/// `originalShape` to obtain the `reducedShape`. This mask is useful to track
        -:  435:/// which dimensions must be kept when e.g. compute MemRef strides under
        -:  436:/// rank-reducing operations. Return None if reducedShape cannot be obtained
        -:  437:/// by dropping only `1` entries in `originalShape`.
        -:  438:llvm::Optional<llvm::SmallDenseSet<unsigned>>
function _ZN4mlir24computeRankReductionMaskEN4llvm8ArrayRefIlEES2_ called 0 returned 0% blocks executed 0%
    #####:  439:mlir::computeRankReductionMask(ArrayRef<int64_t> originalShape,
        -:  440:                               ArrayRef<int64_t> reducedShape) {
    #####:  441:  size_t originalRank = originalShape.size(), reducedRank = reducedShape.size();
call    0 never executed
    #####:  442:  llvm::SmallDenseSet<unsigned> unusedDims;
call    0 never executed
    #####:  443:  unsigned reducedIdx = 0;
    #####:  444:  for (unsigned originalIdx = 0; originalIdx < originalRank; ++originalIdx) {
branch  0 never executed
branch  1 never executed
        -:  445:    // Greedily insert `originalIdx` if match.
    #####:  446:    if (reducedIdx < reducedRank &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  447:        originalShape[originalIdx] == reducedShape[reducedIdx]) {
branch  0 never executed
branch  1 never executed
    #####:  448:      reducedIdx++;
    #####:  449:      continue;
        -:  450:    }
        -:  451:
    #####:  452:    unusedDims.insert(originalIdx);
call    0 never executed
        -:  453:    // If no match on `originalIdx`, the `originalShape` at this dimension
        -:  454:    // must be 1, otherwise we bail.
    #####:  455:    if (originalShape[originalIdx] != 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  456:      return llvm::None;
        -:  457:  }
        -:  458:  // The whole reducedShape must be scanned, otherwise we bail.
    #####:  459:  if (reducedIdx != reducedRank)
branch  0 never executed
branch  1 never executed
    #####:  460:    return llvm::None;
    #####:  461:  return unusedDims;
call    0 never executed
call    1 never executed
        -:  462:}
        -:  463:
        -:  464:SliceVerificationResult
function _ZN4mlir17isRankReducedTypeENS_10ShapedTypeES0_ called 0 returned 0% blocks executed 0%
    #####:  465:mlir::isRankReducedType(ShapedType originalType,
        -:  466:                        ShapedType candidateReducedType) {
    #####:  467:  if (originalType == candidateReducedType)
branch  0 never executed
branch  1 never executed
        -:  468:    return SliceVerificationResult::Success;
        -:  469:
    #####:  470:  ShapedType originalShapedType = originalType.cast<ShapedType>();
call    0 never executed
    #####:  471:  ShapedType candidateReducedShapedType =
call    0 never executed
    #####:  472:      candidateReducedType.cast<ShapedType>();
        -:  473:
        -:  474:  // Rank and size logic is valid for all ShapedTypes.
    #####:  475:  ArrayRef<int64_t> originalShape = originalShapedType.getShape();
call    0 never executed
    #####:  476:  ArrayRef<int64_t> candidateReducedShape =
    #####:  477:      candidateReducedShapedType.getShape();
call    0 never executed
    #####:  478:  unsigned originalRank = originalShape.size(),
branch  0 never executed
branch  1 never executed
    #####:  479:           candidateReducedRank = candidateReducedShape.size();
    #####:  480:  if (candidateReducedRank > originalRank)
branch  0 never executed
branch  1 never executed
        -:  481:    return SliceVerificationResult::RankTooLarge;
        -:  482:
    #####:  483:  auto optionalUnusedDimsMask =
    #####:  484:      computeRankReductionMask(originalShape, candidateReducedShape);
call    0 never executed
        -:  485:
        -:  486:  // Sizes cannot be matched in case empty vector is returned.
    #####:  487:  if (!optionalUnusedDimsMask)
branch  0 never executed
branch  1 never executed
        -:  488:    return SliceVerificationResult::SizeMismatch;
        -:  489:
    #####:  490:  if (originalShapedType.getElementType() !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  491:      candidateReducedShapedType.getElementType())
    #####:  492:    return SliceVerificationResult::ElemTypeMismatch;
        -:  493:
        -:  494:  return SliceVerificationResult::Success;
        -:  495:}
        -:  496:
function _ZN4mlir6detail22isSupportedMemorySpaceENS_9AttributeE called 11899 returned 100% blocks executed 88%
    11899:  497:bool mlir::detail::isSupportedMemorySpace(Attribute memorySpace) {
        -:  498:  // Empty attribute is allowed as default memory space.
    11899:  499:  if (!memorySpace)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  500:    return true;
        -:  501:
        -:  502:  // Supported built-in attributes.
       12:  503:  if (memorySpace.isa<IntegerAttr, StringAttr, DictionaryAttr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  504:    return true;
        -:  505:
        -:  506:  // Allow custom dialect attributes.
       12:  507:  if (!isa<BuiltinDialect>(memorySpace.getDialect()))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       12:  508:    return true;
        -:  509:
        -:  510:  return false;
        -:  511:}
        -:  512:
function _ZN4mlir6detail22wrapIntegerMemorySpaceEjPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  513:Attribute mlir::detail::wrapIntegerMemorySpace(unsigned memorySpace,
        -:  514:                                               MLIRContext *ctx) {
    #####:  515:  if (memorySpace == 0)
branch  0 never executed
branch  1 never executed
    #####:  516:    return nullptr;
        -:  517:
    #####:  518:  return IntegerAttr::get(IntegerType::get(ctx, 64), memorySpace);
call    0 never executed
call    1 never executed
        -:  519:}
        -:  520:
function _ZN4mlir6detail22skipDefaultMemorySpaceENS_9AttributeE called 11899 returned 100% blocks executed 88%
    11899:  521:Attribute mlir::detail::skipDefaultMemorySpace(Attribute memorySpace) {
    11899:  522:  IntegerAttr intMemorySpace = memorySpace.dyn_cast_or_null<IntegerAttr>();
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
    17345:  523:  if (intMemorySpace && intMemorySpace.getValue() == 0)
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 46% (fallthrough)
branch  9 taken 54%
     5446:  524:    return nullptr;
        -:  525:
     6453:  526:  return memorySpace;
        -:  527:}
        -:  528:
function _ZN4mlir6detail19getMemorySpaceAsIntENS_9AttributeE called 117 returned 100% blocks executed 25%
      117:  529:unsigned mlir::detail::getMemorySpaceAsInt(Attribute memorySpace) {
      117:  530:  if (!memorySpace)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  531:    return 0;
        -:  532:
    #####:  533:  assert(memorySpace.isa<IntegerAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  534:         "Using `getMemorySpaceInteger` with non-Integer attribute");
        -:  535:
    #####:  536:  return static_cast<unsigned>(memorySpace.cast<IntegerAttr>().getInt());
call    0 never executed
call    1 never executed
        -:  537:}
        -:  538:
function _ZNK4mlir10MemRefType19getMemorySpaceAsIntEv called 105 returned 100% blocks executed 100%
      117:  539:unsigned MemRefType::getMemorySpaceAsInt() const {
      117:  540:  return detail::getMemorySpaceAsInt(getMemorySpace());
call    0 returned 100%
call    1 returned 100%
        -:  541:}
        -:  542:
function _ZN4mlir10MemRefType3getEN4llvm8ArrayRefIlEENS_4TypeENS_25MemRefLayoutAttrInterfaceENS_9AttributeE called 11899 returned 100% blocks executed 100%
    11899:  543:MemRefType MemRefType::get(ArrayRef<int64_t> shape, Type elementType,
        -:  544:                           MemRefLayoutAttrInterface layout,
        -:  545:                           Attribute memorySpace) {
        -:  546:  // Use default layout for empty attribute.
    11899:  547:  if (!layout)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
    11887:  548:    layout = AffineMapAttr::get(AffineMap::getMultiDimIdentityMap(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
    11887:  549:        shape.size(), elementType.getContext()));
call    0 returned 100%
        -:  550:
        -:  551:  // Drop default memory space value and replace it with empty attribute.
    11899:  552:  memorySpace = skipDefaultMemorySpace(memorySpace);
call    0 returned 100%
        -:  553:
    11899:  554:  return Base::get(elementType.getContext(), shape, elementType, layout,
    11899:  555:                   memorySpace);
call    0 returned 100%
call    1 returned 100%
        -:  556:}
        -:  557:
function _ZN4mlir10MemRefType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeENS_25MemRefLayoutAttrInterfaceENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  558:MemRefType MemRefType::getChecked(
        -:  559:    function_ref<InFlightDiagnostic()> emitErrorFn, ArrayRef<int64_t> shape,
        -:  560:    Type elementType, MemRefLayoutAttrInterface layout, Attribute memorySpace) {
        -:  561:
        -:  562:  // Use default layout for empty attribute.
    #####:  563:  if (!layout)
branch  0 never executed
branch  1 never executed
    #####:  564:    layout = AffineMapAttr::get(AffineMap::getMultiDimIdentityMap(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  565:        shape.size(), elementType.getContext()));
call    0 never executed
        -:  566:
        -:  567:  // Drop default memory space value and replace it with empty attribute.
    #####:  568:  memorySpace = skipDefaultMemorySpace(memorySpace);
call    0 never executed
        -:  569:
    #####:  570:  return Base::getChecked(emitErrorFn, elementType.getContext(), shape,
    #####:  571:                          elementType, layout, memorySpace);
call    0 never executed
call    1 never executed
        -:  572:}
        -:  573:
function _ZN4mlir10MemRefType3getEN4llvm8ArrayRefIlEENS_4TypeENS_9AffineMapENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  574:MemRefType MemRefType::get(ArrayRef<int64_t> shape, Type elementType,
        -:  575:                           AffineMap map, Attribute memorySpace) {
        -:  576:
        -:  577:  // Use default layout for empty map.
    #####:  578:  if (!map)
branch  0 never executed
branch  1 never executed
    #####:  579:    map = AffineMap::getMultiDimIdentityMap(shape.size(),
call    0 never executed
    #####:  580:                                            elementType.getContext());
call    0 never executed
call    1 never executed
        -:  581:
        -:  582:  // Wrap AffineMap into Attribute.
    #####:  583:  Attribute layout = AffineMapAttr::get(map);
call    0 never executed
        -:  584:
        -:  585:  // Drop default memory space value and replace it with empty attribute.
    #####:  586:  memorySpace = skipDefaultMemorySpace(memorySpace);
call    0 never executed
        -:  587:
    #####:  588:  return Base::get(elementType.getContext(), shape, elementType, layout,
    #####:  589:                   memorySpace);
call    0 never executed
call    1 never executed
        -:  590:}
        -:  591:
        -:  592:MemRefType
function _ZN4mlir10MemRefType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeENS_9AffineMapENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  593:MemRefType::getChecked(function_ref<InFlightDiagnostic()> emitErrorFn,
        -:  594:                       ArrayRef<int64_t> shape, Type elementType, AffineMap map,
        -:  595:                       Attribute memorySpace) {
        -:  596:
        -:  597:  // Use default layout for empty map.
    #####:  598:  if (!map)
branch  0 never executed
branch  1 never executed
    #####:  599:    map = AffineMap::getMultiDimIdentityMap(shape.size(),
call    0 never executed
    #####:  600:                                            elementType.getContext());
call    0 never executed
call    1 never executed
        -:  601:
        -:  602:  // Wrap AffineMap into Attribute.
    #####:  603:  Attribute layout = AffineMapAttr::get(map);
call    0 never executed
        -:  604:
        -:  605:  // Drop default memory space value and replace it with empty attribute.
    #####:  606:  memorySpace = skipDefaultMemorySpace(memorySpace);
call    0 never executed
        -:  607:
    #####:  608:  return Base::getChecked(emitErrorFn, elementType.getContext(), shape,
    #####:  609:                          elementType, layout, memorySpace);
call    0 never executed
call    1 never executed
        -:  610:}
        -:  611:
function _ZN4mlir10MemRefType3getEN4llvm8ArrayRefIlEENS_4TypeENS_9AffineMapEj called 0 returned 0% blocks executed 0%
    #####:  612:MemRefType MemRefType::get(ArrayRef<int64_t> shape, Type elementType,
        -:  613:                           AffineMap map, unsigned memorySpaceInd) {
        -:  614:
        -:  615:  // Use default layout for empty map.
    #####:  616:  if (!map)
branch  0 never executed
branch  1 never executed
    #####:  617:    map = AffineMap::getMultiDimIdentityMap(shape.size(),
call    0 never executed
    #####:  618:                                            elementType.getContext());
call    0 never executed
call    1 never executed
        -:  619:
        -:  620:  // Wrap AffineMap into Attribute.
    #####:  621:  Attribute layout = AffineMapAttr::get(map);
call    0 never executed
        -:  622:
        -:  623:  // Convert deprecated integer-like memory space to Attribute.
    #####:  624:  Attribute memorySpace =
    #####:  625:      wrapIntegerMemorySpace(memorySpaceInd, elementType.getContext());
call    0 never executed
call    1 never executed
        -:  626:
    #####:  627:  return Base::get(elementType.getContext(), shape, elementType, layout,
    #####:  628:                   memorySpace);
call    0 never executed
call    1 never executed
        -:  629:}
        -:  630:
        -:  631:MemRefType
function _ZN4mlir10MemRefType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeENS_9AffineMapEj called 0 returned 0% blocks executed 0%
    #####:  632:MemRefType::getChecked(function_ref<InFlightDiagnostic()> emitErrorFn,
        -:  633:                       ArrayRef<int64_t> shape, Type elementType, AffineMap map,
        -:  634:                       unsigned memorySpaceInd) {
        -:  635:
        -:  636:  // Use default layout for empty map.
    #####:  637:  if (!map)
branch  0 never executed
branch  1 never executed
    #####:  638:    map = AffineMap::getMultiDimIdentityMap(shape.size(),
call    0 never executed
    #####:  639:                                            elementType.getContext());
call    0 never executed
call    1 never executed
        -:  640:
        -:  641:  // Wrap AffineMap into Attribute.
    #####:  642:  Attribute layout = AffineMapAttr::get(map);
call    0 never executed
        -:  643:
        -:  644:  // Convert deprecated integer-like memory space to Attribute.
    #####:  645:  Attribute memorySpace =
    #####:  646:      wrapIntegerMemorySpace(memorySpaceInd, elementType.getContext());
call    0 never executed
call    1 never executed
        -:  647:
    #####:  648:  return Base::getChecked(emitErrorFn, elementType.getContext(), shape,
    #####:  649:                          elementType, layout, memorySpace);
call    0 never executed
call    1 never executed
        -:  650:}
        -:  651:
function _ZN4mlir10MemRefType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS1_8ArrayRefIlEENS_4TypeENS_25MemRefLayoutAttrInterfaceENS_9AttributeE called 11899 returned 100% blocks executed 42%
    11899:  652:LogicalResult MemRefType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  653:                                 ArrayRef<int64_t> shape, Type elementType,
        -:  654:                                 MemRefLayoutAttrInterface layout,
        -:  655:                                 Attribute memorySpace) {
    11899:  656:  if (!BaseMemRefType::isValidElementType(elementType))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  657:    return emitError() << "invalid memref element type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  658:
        -:  659:  // Negative sizes are not allowed except for `kDynamicSize`.
    55757:  660:  for (int64_t s : shape)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
   43858*:  661:    if (s < 0 && !ShapedType::isDynamic(s))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  662:      return emitError() << "invalid memref size";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  663:
   11899*:  664:  assert(layout && "missing layout specification");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    11899:  665:  if (failed(layout.verifyLayout(shape, emitError)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  666:    return failure();
        -:  667:
    11899:  668:  if (!isSupportedMemorySpace(memorySpace))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  669:    return emitError() << "unsupported memory space Attribute";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  670:
    11899:  671:  return success();
        -:  672:}
        -:  673:
function _ZNK4mlir10MemRefType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 2767 returned 100% blocks executed 71%
     2767:  674:void MemRefType::walkImmediateSubElements(
        -:  675:    function_ref<void(Attribute)> walkAttrsFn,
        -:  676:    function_ref<void(Type)> walkTypesFn) const {
     2767:  677:  walkTypesFn(getElementType());
call    0 returned 100%
     2767:  678:  if (!getLayout().isIdentity())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  679:    walkAttrsFn(getLayout());
call    0 never executed
     2767:  680:  walkAttrsFn(getMemorySpace());
call    0 returned 100%
     2767:  681:}
        -:  682:
function _ZNK4mlir10MemRefType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  683:Type MemRefType::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  684:                                             ArrayRef<Type> replTypes) const {
    #####:  685:  bool hasLayout = replAttrs.size() > 1;
branch  0 never executed
branch  1 never executed
    #####:  686:  return get(getShape(), replTypes[0],
call    0 never executed
    #####:  687:             hasLayout ? replAttrs[0].dyn_cast<MemRefLayoutAttrInterface>()
call    0 never executed
        -:  688:                       : MemRefLayoutAttrInterface(),
    #####:  689:             hasLayout ? replAttrs[1] : replAttrs[0]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
        -:  690:}
        -:  691:
        -:  692://===----------------------------------------------------------------------===//
        -:  693:// UnrankedMemRefType
        -:  694://===----------------------------------------------------------------------===//
        -:  695:
function _ZNK4mlir18UnrankedMemRefType19getMemorySpaceAsIntEv called 0 returned 0% blocks executed 0%
    #####:  696:unsigned UnrankedMemRefType::getMemorySpaceAsInt() const {
    #####:  697:  return detail::getMemorySpaceAsInt(getMemorySpace());
call    0 never executed
call    1 never executed
        -:  698:}
        -:  699:
        -:  700:LogicalResult
function _ZN4mlir18UnrankedMemRefType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  701:UnrankedMemRefType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  702:                           Type elementType, Attribute memorySpace) {
    #####:  703:  if (!BaseMemRefType::isValidElementType(elementType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  704:    return emitError() << "invalid memref element type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  705:
    #####:  706:  if (!isSupportedMemorySpace(memorySpace))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  707:    return emitError() << "unsupported memory space Attribute";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  708:
    #####:  709:  return success();
        -:  710:}
        -:  711:
        -:  712:// Fallback cases for terminal dim/sym/cst that are not part of a binary op (
        -:  713:// i.e. single term). Accumulate the AffineExpr into the existing one.
function _ZL22extractStridesFromTermN4mlir10AffineExprES0_N4llvm15MutableArrayRefIS0_EERS0_ called 253 returned 100% blocks executed 69%
      253:  714:static void extractStridesFromTerm(AffineExpr e,
        -:  715:                                   AffineExpr multiplicativeFactor,
        -:  716:                                   MutableArrayRef<AffineExpr> strides,
        -:  717:                                   AffineExpr &offset) {
      253:  718:  if (auto dim = e.dyn_cast<AffineDimExpr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      253:  719:    strides[dim.getPosition()] =
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      253:  720:        strides[dim.getPosition()] + multiplicativeFactor;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  721:  else
    #####:  722:    offset = offset + e * multiplicativeFactor;
call    0 never executed
call    1 never executed
      253:  723:}
        -:  724:
        -:  725:/// Takes a single AffineExpr `e` and populates the `strides` array with the
        -:  726:/// strides expressions for each dim position.
        -:  727:/// The convention is that the strides for dimensions d0, .. dn appear in
        -:  728:/// order to make indexing intuitive into the result.
function _ZL14extractStridesN4mlir10AffineExprES0_N4llvm15MutableArrayRefIS0_EERS0_ called 707 returned 100% blocks executed 68%
      707:  729:static LogicalResult extractStrides(AffineExpr e,
        -:  730:                                    AffineExpr multiplicativeFactor,
        -:  731:                                    MutableArrayRef<AffineExpr> strides,
        -:  732:                                    AffineExpr &offset) {
      707:  733:  auto bin = e.dyn_cast<AffineBinaryOpExpr>();
call    0 returned 100%
      707:  734:  if (!bin) {
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
      253:  735:    extractStridesFromTerm(e, multiplicativeFactor, strides, offset);
call    0 returned 100%
      253:  736:    return success();
        -:  737:  }
        -:  738:
      908:  739:  if (bin.getKind() == AffineExprKind::CeilDiv ||
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      908:  740:      bin.getKind() == AffineExprKind::FloorDiv ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
      454:  741:      bin.getKind() == AffineExprKind::Mod)
call    0 returned 100%
    #####:  742:    return failure();
        -:  743:
      454:  744:  if (bin.getKind() == AffineExprKind::Mul) {
call    0 returned 100%
branch  1 taken 34% (fallthrough)
branch  2 taken 66%
      153:  745:    auto dim = bin.getLHS().dyn_cast<AffineDimExpr>();
call    0 returned 100%
call    1 returned 100%
      153:  746:    if (dim) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      153:  747:      strides[dim.getPosition()] =
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      153:  748:          strides[dim.getPosition()] + bin.getRHS() * multiplicativeFactor;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 returned 100%
      153:  749:      return success();
        -:  750:    }
        -:  751:    // LHS and RHS may both contain complex expressions of dims. Try one path
        -:  752:    // and if it fails try the other. This is guaranteed to succeed because
        -:  753:    // only one path may have a `dim`, otherwise this is not an AffineExpr in
        -:  754:    // the first place.
    #####:  755:    if (bin.getLHS().isSymbolicOrConstant())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  756:      return extractStrides(bin.getRHS(), multiplicativeFactor * bin.getLHS(),
    #####:  757:                            strides, offset);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  758:    return extractStrides(bin.getLHS(), multiplicativeFactor * bin.getRHS(),
    #####:  759:                          strides, offset);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  760:  }
        -:  761:
      301:  762:  if (bin.getKind() == AffineExprKind::Add) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      301:  763:    auto res1 =
      301:  764:        extractStrides(bin.getLHS(), multiplicativeFactor, strides, offset);
call    0 returned 100%
call    1 returned 100%
      301:  765:    auto res2 =
      301:  766:        extractStrides(bin.getRHS(), multiplicativeFactor, strides, offset);
call    0 returned 100%
call    1 returned 100%
      301:  767:    return success(succeeded(res1) && succeeded(res2));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  768:  }
        -:  769:
    #####:  770:  llvm_unreachable("unexpected binary operation");
call    0 never executed
        -:  771:}
        -:  772:
        -:  773:/// A stride specification is a list of integer values that are either static
        -:  774:/// or dynamic (encoded with ShapedType::kDynamicStrideOrOffset). Strides encode
        -:  775:/// the distance in the number of elements between successive entries along a
        -:  776:/// particular dimension.
        -:  777:///
        -:  778:/// For example, `memref<42x16xf32, (64 * d0 + d1)>` specifies a view into a
        -:  779:/// non-contiguous memory region of `42` by `16` `f32` elements in which the
        -:  780:/// distance between two consecutive elements along the outer dimension is `1`
        -:  781:/// and the distance between two consecutive elements along the inner dimension
        -:  782:/// is `64`.
        -:  783:///
        -:  784:/// The convention is that the strides for dimensions d0, .. dn appear in
        -:  785:/// order to make indexing intuitive into the result.
function _ZL19getStridesAndOffsetN4mlir10MemRefTypeERN4llvm15SmallVectorImplINS_10AffineExprEEERS3_ called 105 returned 100% blocks executed 51%
      105:  786:static LogicalResult getStridesAndOffset(MemRefType t,
        -:  787:                                         SmallVectorImpl<AffineExpr> &strides,
        -:  788:                                         AffineExpr &offset) {
      105:  789:  AffineMap m = t.getLayout().getAffineMap();
call    0 returned 100%
        -:  790:
      105:  791:  if (m.getNumResults() != 1 && !m.isIdentity())
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  792:    return failure();
        -:  793:
      105:  794:  auto zero = getAffineConstantExpr(0, t.getContext());
call    0 returned 100%
call    1 returned 100%
      105:  795:  auto one = getAffineConstantExpr(1, t.getContext());
call    0 returned 100%
call    1 returned 100%
      105:  796:  offset = zero;
      105:  797:  strides.assign(t.getRank(), zero);
call    0 returned 100%
call    1 returned 100%
        -:  798:
        -:  799:  // Canonical case for empty map.
      105:  800:  if (m.isIdentity()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  801:    // 0-D corner case, offset is already 0.
      105:  802:    if (t.getRank() == 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  803:      return success();
      105:  804:    auto stridedExpr =
      105:  805:        makeCanonicalStridedLayoutExpr(t.getShape(), t.getContext());
call    0 returned 100%
call    1 returned 100%
      105:  806:    if (succeeded(extractStrides(stridedExpr, one, strides, offset)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      105:  807:      return success();
    #####:  808:    assert(false && "unexpected failure: extract strides in canonical layout");
call    0 never executed
        -:  809:  }
        -:  810:
        -:  811:  // Non-canonical case requires more work.
    #####:  812:  auto stridedExpr =
    #####:  813:      simplifyAffineExpr(m.getResult(0), m.getNumDims(), m.getNumSymbols());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  814:  if (failed(extractStrides(stridedExpr, one, strides, offset))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  815:    offset = AffineExpr();
    #####:  816:    strides.clear();
    #####:  817:    return failure();
        -:  818:  }
        -:  819:
        -:  820:  // Simplify results to allow folding to constants and simple checks.
    #####:  821:  unsigned numDims = m.getNumDims();
call    0 never executed
    #####:  822:  unsigned numSymbols = m.getNumSymbols();
call    0 never executed
    #####:  823:  offset = simplifyAffineExpr(offset, numDims, numSymbols);
call    0 never executed
    #####:  824:  for (auto &stride : strides)
branch  0 never executed
branch  1 never executed
    #####:  825:    stride = simplifyAffineExpr(stride, numDims, numSymbols);
call    0 never executed
        -:  826:
        -:  827:  // In practice, a strided memref must be internally non-aliasing. Test
        -:  828:  // against 0 as a proxy.
        -:  829:  // TODO: static cases can have more advanced checks.
        -:  830:  // TODO: dynamic cases would require a way to compare symbolic
        -:  831:  // expressions and would probably need an affine set context propagated
        -:  832:  // everywhere.
function _ZZL19getStridesAndOffsetN4mlir10MemRefTypeERN4llvm15SmallVectorImplINS_10AffineExprEEERS3_ENKUlS3_E_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  833:  if (llvm::any_of(strides, [](AffineExpr e) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  834:        return e == getAffineConstantExpr(0, e.getContext());
call    0 never executed
call    1 never executed
        -:  835:      })) {
    #####:  836:    offset = AffineExpr();
    #####:  837:    strides.clear();
    #####:  838:    return failure();
        -:  839:  }
        -:  840:
    #####:  841:  return success();
        -:  842:}
        -:  843:
function _ZN4mlir19getStridesAndOffsetENS_10MemRefTypeERN4llvm15SmallVectorImplIlEERl called 105 returned 100% blocks executed 74%
      105:  844:LogicalResult mlir::getStridesAndOffset(MemRefType t,
        -:  845:                                        SmallVectorImpl<int64_t> &strides,
        -:  846:                                        int64_t &offset) {
        -:  847:  // Happy path: the type uses the strided layout directly.
      105:  848:  if (auto strided = t.getLayout().dyn_cast<StridedLayoutAttr>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  849:    llvm::append_range(strides, strided.getStrides());
call    0 never executed
call    1 never executed
    #####:  850:    offset = strided.getOffset();
call    0 never executed
    #####:  851:    return success();
        -:  852:  }
        -:  853:
        -:  854:  // Otherwise, defer to the affine fallback as layouts are supposed to be
        -:  855:  // convertible to affine maps.
      105:  856:  AffineExpr offsetExpr;
      105:  857:  SmallVector<AffineExpr, 4> strideExprs;
call    0 returned 100%
      105:  858:  if (failed(::getStridesAndOffset(t, strideExprs, offsetExpr)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  859:    return failure();
      105:  860:  if (auto cst = offsetExpr.dyn_cast<AffineConstantExpr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      105:  861:    offset = cst.getValue();
call    0 returned 100%
        -:  862:  else
    #####:  863:    offset = ShapedType::kDynamicStrideOrOffset;
      511:  864:  for (auto e : strideExprs) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
      406:  865:    if (auto c = e.dyn_cast<AffineConstantExpr>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      406:  866:      strides.push_back(c.getValue());
call    0 returned 100%
call    1 returned 100%
        -:  867:    else
    #####:  868:      strides.push_back(ShapedType::kDynamicStrideOrOffset);
call    0 never executed
        -:  869:  }
      105:  870:  return success();
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
        -:  871:}
        -:  872:
function _ZNK4mlir18UnrankedMemRefType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
    #####:  873:void UnrankedMemRefType::walkImmediateSubElements(
        -:  874:    function_ref<void(Attribute)> walkAttrsFn,
        -:  875:    function_ref<void(Type)> walkTypesFn) const {
    #####:  876:  walkTypesFn(getElementType());
call    0 never executed
call    1 never executed
    #####:  877:  walkAttrsFn(getMemorySpace());
call    0 never executed
call    1 never executed
    #####:  878:}
        -:  879:
function _ZNK4mlir18UnrankedMemRefType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  880:Type UnrankedMemRefType::replaceImmediateSubElements(
        -:  881:    ArrayRef<Attribute> replAttrs, ArrayRef<Type> replTypes) const {
    #####:  882:  return get(replTypes.front(), replAttrs.front());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  883:}
        -:  884:
        -:  885://===----------------------------------------------------------------------===//
        -:  886:/// TupleType
        -:  887://===----------------------------------------------------------------------===//
        -:  888:
        -:  889:/// Return the elements types for this tuple.
function _ZNK4mlir9TupleType8getTypesEv called 0 returned 0% blocks executed 0%
    #####:  890:ArrayRef<Type> TupleType::getTypes() const { return getImpl()->getTypes(); }
        -:  891:
        -:  892:/// Accumulate the types contained in this tuple and tuples nested within it.
        -:  893:/// Note that this only flattens nested tuples, not any other container type,
        -:  894:/// e.g. a tuple<i32, tensor<i32>, tuple<f32, tuple<i64>>> is flattened to
        -:  895:/// (i32, tensor<i32>, f32, i64)
function _ZN4mlir9TupleType17getFlattenedTypesERN4llvm15SmallVectorImplINS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  896:void TupleType::getFlattenedTypes(SmallVectorImpl<Type> &types) {
    #####:  897:  for (Type type : getTypes()) {
branch  0 never executed
branch  1 never executed
    #####:  898:    if (auto nestedTuple = type.dyn_cast<TupleType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  899:      nestedTuple.getFlattenedTypes(types);
call    0 never executed
        -:  900:    else
    #####:  901:      types.push_back(type);
call    0 never executed
        -:  902:  }
    #####:  903:}
        -:  904:
        -:  905:/// Return the number of element types.
function _ZNK4mlir9TupleType4sizeEv called 0 returned 0% blocks executed 0%
    #####:  906:size_t TupleType::size() const { return getImpl()->size(); }
        -:  907:
function _ZNK4mlir9TupleType24walkImmediateSubElementsEN4llvm12function_refIFvNS_9AttributeEEEENS2_IFvNS_4TypeEEEE called 0 returned 0% blocks executed 0%
    #####:  908:void TupleType::walkImmediateSubElements(
        -:  909:    function_ref<void(Attribute)> walkAttrsFn,
        -:  910:    function_ref<void(Type)> walkTypesFn) const {
    #####:  911:  for (Type type : getTypes())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  912:    walkTypesFn(type);
call    0 never executed
call    1 never executed
    #####:  913:}
        -:  914:
function _ZNK4mlir9TupleType27replaceImmediateSubElementsEN4llvm8ArrayRefINS_9AttributeEEENS2_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  915:Type TupleType::replaceImmediateSubElements(ArrayRef<Attribute> replAttrs,
        -:  916:                                            ArrayRef<Type> replTypes) const {
    #####:  917:  return get(getContext(), replTypes);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  918:}
        -:  919:
        -:  920://===----------------------------------------------------------------------===//
        -:  921:// Type Utilities
        -:  922://===----------------------------------------------------------------------===//
        -:  923:
        -:  924:/// Return a version of `t` with identity layout if it can be determined
        -:  925:/// statically that the layout is the canonical contiguous strided layout.
        -:  926:/// Otherwise pass `t`'s layout into `simplifyAffineMap` and return a copy of
        -:  927:/// `t` with simplified layout.
        -:  928:/// If `t` has multiple layout maps or a multi-result layout, just return `t`.
function _ZN4mlir25canonicalizeStridedLayoutENS_10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####:  929:MemRefType mlir::canonicalizeStridedLayout(MemRefType t) {
    #####:  930:  AffineMap m = t.getLayout().getAffineMap();
call    0 never executed
        -:  931:
        -:  932:  // Already in canonical form.
    #####:  933:  if (m.isIdentity())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  934:    return t;
        -:  935:
        -:  936:  // Can't reduce to canonical identity form, return in canonical form.
    #####:  937:  if (m.getNumResults() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:    return t;
        -:  939:
        -:  940:  // Corner-case for 0-D affine maps.
    #####:  941:  if (m.getNumDims() == 0 && m.getNumSymbols() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  942:    if (auto cst = m.getResult(0).dyn_cast<AffineConstantExpr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  943:      if (cst.getValue() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  944:        return MemRefType::Builder(t).setLayout({});
call    0 never executed
call    1 never executed
    #####:  945:    return t;
        -:  946:  }
        -:  947:
        -:  948:  // 0-D corner case for empty shape that still have an affine map. Example:
        -:  949:  // `memref<f32, affine_map<()[s0] -> (s0)>>`. This is a 1 element memref whose
        -:  950:  // offset needs to remain, just return t.
    #####:  951:  if (t.getShape().empty())
branch  0 never executed
branch  1 never executed
    #####:  952:    return t;
        -:  953:
        -:  954:  // If the canonical strided layout for the sizes of `t` is equal to the
        -:  955:  // simplified layout of `t` we can just return an empty layout. Otherwise,
        -:  956:  // just simplify the existing layout.
    #####:  957:  AffineExpr expr =
    #####:  958:      makeCanonicalStridedLayoutExpr(t.getShape(), t.getContext());
call    0 never executed
call    1 never executed
    #####:  959:  auto simplifiedLayoutExpr =
    #####:  960:      simplifyAffineExpr(m.getResult(0), m.getNumDims(), m.getNumSymbols());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  961:  if (expr != simplifiedLayoutExpr)
branch  0 never executed
branch  1 never executed
    #####:  962:    return MemRefType::Builder(t).setLayout(AffineMapAttr::get(AffineMap::get(
call    0 never executed
    #####:  963:        m.getNumDims(), m.getNumSymbols(), simplifiedLayoutExpr)));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  964:  return MemRefType::Builder(t).setLayout({});
call    0 never executed
call    1 never executed
        -:  965:}
        -:  966:
function _ZN4mlir30makeCanonicalStridedLayoutExprEN4llvm8ArrayRefIlEENS1_INS_10AffineExprEEEPNS_11MLIRContextE called 105 returned 100% blocks executed 76%
      105:  967:AffineExpr mlir::makeCanonicalStridedLayoutExpr(ArrayRef<int64_t> sizes,
        -:  968:                                                ArrayRef<AffineExpr> exprs,
        -:  969:                                                MLIRContext *context) {
        -:  970:  // Size 0 corner case is useful for canonicalizations.
      105:  971:  if (sizes.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  972:    return getAffineConstantExpr(0, context);
call    0 never executed
        -:  973:
     105*:  974:  assert(!exprs.empty() && "expected exprs");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      105:  975:  auto maps = AffineMap::inferFromExprList(exprs);
call    0 returned 100%
     105*:  976:  assert(!maps.empty() && "Expected one non-empty map");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      105:  977:  unsigned numDims = maps[0].getNumDims(), nSymbols = maps[0].getNumSymbols();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  978:
      105:  979:  AffineExpr expr;
      105:  980:  bool dynamicPoisonBit = false;
      105:  981:  int64_t runningSize = 1;
      511:  982:  for (auto en : llvm::zip(llvm::reverse(exprs), llvm::reverse(sizes))) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
      406:  983:    int64_t size = std::get<1>(en);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      406:  984:    AffineExpr dimExpr = std::get<0>(en);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      406:  985:    AffineExpr stride = dynamicPoisonBit
    #####:  986:                            ? getAffineSymbolExpr(nSymbols++, context)
call    0 never executed
      406:  987:                            : getAffineConstantExpr(runningSize, context);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
      406:  988:    expr = expr ? expr + dimExpr * stride : dimExpr * stride;
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
      406:  989:    if (size > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      406:  990:      runningSize *= size;
     406*:  991:      assert(runningSize > 0 && "integer overflow in size computation");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  992:    } else {
        -:  993:      dynamicPoisonBit = true;
        -:  994:    }
        -:  995:  }
      105:  996:  return simplifyAffineExpr(expr, numDims, nSymbols);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  997:}
        -:  998:
function _ZN4mlir30makeCanonicalStridedLayoutExprEN4llvm8ArrayRefIlEEPNS_11MLIRContextE called 105 returned 100% blocks executed 94%
      105:  999:AffineExpr mlir::makeCanonicalStridedLayoutExpr(ArrayRef<int64_t> sizes,
        -: 1000:                                                MLIRContext *context) {
      105: 1001:  SmallVector<AffineExpr, 4> exprs;
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
      105: 1002:  exprs.reserve(sizes.size());
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
      917: 1003:  for (auto dim : llvm::seq<unsigned>(0, sizes.size()))
call    0 returned 100%
branch  1 taken 79% (fallthrough)
branch  2 taken 21%
call    3 returned 100%
      406: 1004:    exprs.push_back(getAffineDimExpr(dim, context));
call    0 returned 100%
call    1 returned 100%
      105: 1005:  return makeCanonicalStridedLayoutExpr(sizes, exprs, context);
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
        -: 1006:}
        -: 1007:
        -: 1008:/// Return true if the layout for `t` is compatible with strided semantics.
function _ZN4mlir9isStridedENS_10MemRefTypeE called 105 returned 100% blocks executed 100%
      105: 1009:bool mlir::isStrided(MemRefType t) {
      105: 1010:  int64_t offset;
      105: 1011:  SmallVector<int64_t, 4> strides;
call    0 returned 100%
      105: 1012:  auto res = getStridesAndOffset(t, strides, offset);
call    0 returned 100%
      105: 1013:  return succeeded(res);
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
        -: 1014:}
