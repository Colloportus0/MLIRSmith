        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/LLVMIR/IR/NVVMDialect.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRNVVMDialect.dir/IR/NVVMDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRNVVMDialect.dir/IR/NVVMDialect.cpp.gcda
        -:    0:Runs:325549
        -:    1://===- NVVMDialect.cpp - NVVM IR Ops and Dialect registration -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the types and operation details for the NVVM IR dialect in
        -:   10:// MLIR, and the LLVM IR dialect.  It also registers the dialect.
        -:   11://
        -:   12:// The NVVM dialect only contains GPU specific additions on top of the general
        -:   13:// LLVM dialect.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#include "mlir/Dialect/LLVMIR/NVVMDialect.h"
        -:   18:
        -:   19:#include "mlir/Dialect/Utils/StaticValueUtils.h"
        -:   20:#include "mlir/IR/Builders.h"
        -:   21:#include "mlir/IR/BuiltinAttributes.h"
        -:   22:#include "mlir/IR/BuiltinTypes.h"
        -:   23:#include "mlir/IR/DialectImplementation.h"
        -:   24:#include "mlir/IR/MLIRContext.h"
        -:   25:#include "mlir/IR/Operation.h"
        -:   26:#include "mlir/IR/OperationSupport.h"
        -:   27:#include "llvm/ADT/TypeSwitch.h"
        -:   28:#include "llvm/AsmParser/Parser.h"
        -:   29:#include "llvm/IR/Attributes.h"
        -:   30:#include "llvm/IR/Function.h"
        -:   31:#include "llvm/IR/Type.h"
        -:   32:#include "llvm/Support/Casting.h"
        -:   33:#include "llvm/Support/SourceMgr.h"
        -:   34:
        -:   35:using namespace mlir;
        -:   36:using namespace NVVM;
        -:   37:
        -:   38:#include "mlir/Dialect/LLVMIR/NVVMOpsDialect.cpp.inc"
        -:   39:#include "mlir/Dialect/LLVMIR/NVVMOpsEnums.cpp.inc"
        -:   40:
        -:   41://===----------------------------------------------------------------------===//
        -:   42:// Printing/parsing for NVVM ops
        -:   43://===----------------------------------------------------------------------===//
        -:   44:
function _ZL20printNVVMIntrinsicOpRN4mlir12OpAsmPrinterEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:   45:static void printNVVMIntrinsicOp(OpAsmPrinter &p, Operation *op) {
    #####:   46:  p << " " << op->getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   47:  if (op->getNumResults() > 0)
branch  0 never executed
branch  1 never executed
    #####:   48:    p << " : " << op->getResultTypes();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   49:}
        -:   50:
        -:   51:// <operation> ::= `llvm.nvvm.vote.ballot.sync %mask, %pred` : result_type
function _ZN4mlir4NVVM12VoteBallotOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:   52:ParseResult VoteBallotOp::parse(OpAsmParser &parser, OperationState &result) {
    #####:   53:  MLIRContext *context = parser.getContext();
call    0 never executed
    #####:   54:  auto int32Ty = IntegerType::get(context, 32);
call    0 never executed
    #####:   55:  auto int1Ty = IntegerType::get(context, 1);
call    0 never executed
        -:   56:
    #####:   57:  SmallVector<OpAsmParser::UnresolvedOperand, 8> ops;
call    0 never executed
    #####:   58:  Type type;
    #####:   59:  return failure(parser.parseOperandList(ops) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   60:                 parser.parseOptionalAttrDict(result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   61:                 parser.parseColonType(type) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   62:                 parser.addTypeToList(type, result.types) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   63:                 parser.resolveOperands(ops, {int32Ty, int1Ty},
branch  0 never executed
branch  1 never executed
    #####:   64:                                        parser.getNameLoc(), result.operands));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   65:}
        -:   66:
function _ZN4mlir4NVVM12VoteBallotOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:   67:void VoteBallotOp::print(OpAsmPrinter &p) { printNVVMIntrinsicOp(p, *this); }
call    0 never executed
call    1 never executed
        -:   68:
function _ZN4mlir4NVVM9CpAsyncOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:   69:LogicalResult CpAsyncOp::verify() {
    #####:   70:  if (getSize() != 4 && getSize() != 8 && getSize() != 16)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:   71:    return emitError("expected byte size to be either 4, 8 or 16.");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   72:  if (getBypassL1() && getSize() != 16)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   73:    return emitError("bypass l1 is only support for 16 bytes copy.");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   74:  return success();
        -:   75:}
        -:   76:
        -:   77:// Given the element type of an operand and whether or not it is an accumulator,
        -:   78:// this function returns the PTX type (`NVVM::MMATypes`) that corresponds to the
        -:   79:// operand's element type.
function _ZN4mlir4NVVM5MmaOp19inferOperandMMATypeENS_4TypeEb called 0 returned 0% blocks executed 0%
    #####:   80:Optional<mlir::NVVM::MMATypes> MmaOp::inferOperandMMAType(Type operandElType,
        -:   81:                                                          bool isAccumulator) {
    #####:   82:  auto half2Type =
    #####:   83:      LLVM::getFixedVectorType(Float16Type::get(operandElType.getContext()), 2);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   84:  if (operandElType.isF64())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   85:    return NVVM::MMATypes::f64;
    #####:   86:  if (operandElType.isF16() || operandElType == half2Type)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   87:    return NVVM::MMATypes::f16;
    #####:   88:  if (operandElType.isF32() && isAccumulator)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   89:    return NVVM::MMATypes::f32;
    #####:   90:  if (operandElType.isF32() && !isAccumulator)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:   91:    return NVVM::MMATypes::tf32;
    #####:   92:  if (operandElType.isa<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   93:    if (isAccumulator)
branch  0 never executed
branch  1 never executed
    #####:   94:      return NVVM::MMATypes::s32;
    #####:   95:    return llvm::None;
        -:   96:  }
        -:   97:
    #####:   98:  if (auto structType = operandElType.dyn_cast<LLVM::LLVMStructType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:    if (structType.getBody().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  100:      return llvm::None;
    #####:  101:    return inferOperandMMAType(structType.getBody()[0], isAccumulator);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  102:  }
        -:  103:
    #####:  104:  return llvm::None;
        -:  105:}
        -:  106:
    #####:  107:static bool isInt4PtxType(MMATypes type) {
    #####:  108:  return (type == MMATypes::u4 || type == MMATypes::s4);
        -:  109:}
        -:  110:
    #####:  111:static bool isInt8PtxType(MMATypes type) {
    #####:  112:  return (type == MMATypes::u8 || type == MMATypes::s8);
        -:  113:}
        -:  114:
    #####:  115:static bool isIntegerPtxType(MMATypes type) {
    #####:  116:  return isInt4PtxType(type) || isInt8PtxType(type) || type == MMATypes::b1 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  117:         type == MMATypes::s32;
        -:  118:}
        -:  119:
function _ZN4mlir4NVVM5MmaOp12accumPtxTypeEv called 0 returned 0% blocks executed 0%
    #####:  120:MMATypes MmaOp::accumPtxType() {
    #####:  121:  Optional<mlir::NVVM::MMATypes> val = inferOperandMMAType(
    #####:  122:      getODSOperands(2).getTypes().front(), /*isAccum=*/true);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  123:  assert(val.has_value() && "accumulator PTX type should always be inferrable");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  124:  return val.value();
        -:  125:}
        -:  126:
function _ZN4mlir4NVVM5MmaOp13resultPtxTypeEv called 0 returned 0% blocks executed 0%
    #####:  127:MMATypes MmaOp::resultPtxType() {
    #####:  128:  Optional<mlir::NVVM::MMATypes> val =
call    0 never executed
    #####:  129:      inferOperandMMAType(getResult().getType(), /*isAccum=*/true);
call    0 never executed
    #####:  130:  assert(val.has_value() && "result PTX type should always be inferrable");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  131:  return val.value();
        -:  132:}
        -:  133:
function _ZN4mlir4NVVM5MmaOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  134:void MmaOp::print(OpAsmPrinter &p) {
    #####:  135:  SmallVector<Type, 4> regTypes;
call    0 never executed
    #####:  136:  struct OperandFragment {
branch  0 never executed
branch  1 never executed
        -:  137:    StringRef operandName;
        -:  138:    StringRef ptxTypeAttr;
        -:  139:    SmallVector<Value, 4> regs;
    #####:  140:    explicit OperandFragment(StringRef name, StringRef ptxTypeName)
    #####:  141:        : operandName(name), ptxTypeAttr(ptxTypeName) {}
call    0 never executed
call    1 never executed
        -:  142:  };
        -:  143:
    #####:  144:  std::array<OperandFragment, 3> frags{
    #####:  145:      OperandFragment("A", getMultiplicandAPtxTypeAttrName()),
call    0 never executed
call    1 never executed
    #####:  146:      OperandFragment("B", getMultiplicandBPtxTypeAttrName()),
call    0 never executed
    #####:  147:      OperandFragment("C", "")};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  148:  SmallVector<StringRef, 4> ignoreAttrNames{
call    0 never executed
    #####:  149:      mlir::NVVM::MmaOp::getOperandSegmentSizeAttr()};
call    0 never executed
        -:  150:
    #####:  151:  for (unsigned fragIdx = 0; fragIdx < frags.size(); fragIdx++) {
branch  0 never executed
branch  1 never executed
    #####:  152:    auto &frag = frags[fragIdx];
call    0 never executed
    #####:  153:    auto varOperandSpec = getODSOperandIndexAndLength(fragIdx);
call    0 never executed
    #####:  154:    for (auto operandIdx = varOperandSpec.first;
    #####:  155:         operandIdx < varOperandSpec.first + varOperandSpec.second;
branch  0 never executed
branch  1 never executed
        -:  156:         operandIdx++) {
    #####:  157:      frag.regs.push_back(this->getOperand(operandIdx));
call    0 never executed
call    1 never executed
    #####:  158:      if (operandIdx == 0) {
branch  0 never executed
branch  1 never executed
    #####:  159:        regTypes.push_back(this->getOperand(operandIdx).getType());
call    0 never executed
call    1 never executed
        -:  160:      }
        -:  161:    }
    #####:  162:    Optional<MMATypes> inferredType =
    #####:  163:        inferOperandMMAType(regTypes.back(), /*isAccum=*/fragIdx >= 2);
call    0 never executed
call    1 never executed
    #####:  164:    if (inferredType)
branch  0 never executed
branch  1 never executed
    #####:  165:      ignoreAttrNames.push_back(frag.ptxTypeAttr);
call    0 never executed
        -:  166:  }
        -:  167:
function _ZZN4mlir4NVVM5MmaOp5printERNS_12OpAsmPrinterEENKUlRKZNS1_5printES3_E15OperandFragmentE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  168:  auto printMmaOperand = [&](const OperandFragment &frag) -> void {
    #####:  169:    p << " " << frag.operandName;
call    0 never executed
call    1 never executed
    #####:  170:    p << "[";
call    0 never executed
    #####:  171:    p.printOperands(frag.regs);
call    0 never executed
    #####:  172:    p << "] ";
call    0 never executed
    #####:  173:  };
        -:  174:
    #####:  175:  for (const auto &frag : frags) {
branch  0 never executed
branch  1 never executed
    #####:  176:    printMmaOperand(frag);
call    0 never executed
        -:  177:  }
        -:  178:
    #####:  179:  p.printOptionalAttrDict(this->getOperation()->getAttrs(), ignoreAttrNames);
call    0 never executed
call    1 never executed
        -:  180:
        -:  181:  // Print the types of the operands and result.
    #####:  182:  p << " : "
call    0 never executed
call    1 never executed
    #####:  183:    << "(";
    #####:  184:  llvm::interleaveComma(SmallVector<Type, 3>{frags[0].regs[0].getType(),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  185:                                             frags[1].regs[0].getType(),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  186:                                             frags[2].regs[0].getType()},
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  187:                        p);
    #####:  188:  p << ")";
call    0 never executed
    #####:  189:  p.printArrowTypeList(TypeRange{this->getRes().getType()});
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  190:}
        -:  191:
function _ZN4mlir4NVVM5MmaOp5buildERNS_9OpBuilderERNS_14OperationStateENS_4TypeENS_10ValueRangeES7_S7_N4llvm8ArrayRefIlEENS8_8OptionalINS0_7MMAB1OpEEENSB_INS0_14MMAIntOverflowEEENSB_ISt5arrayINS0_8MMATypesELm2EEEENSB_ISG_INS0_9MMALayoutELm2EEEE called 0 returned 0% blocks executed 0%
    #####:  192:void MmaOp::build(OpBuilder &builder, OperationState &result, Type resultType,
        -:  193:                  ValueRange operandA, ValueRange operandB, ValueRange operandC,
        -:  194:                  ArrayRef<int64_t> shape, Optional<MMAB1Op> b1Op,
        -:  195:                  Optional<MMAIntOverflow> intOverflow,
        -:  196:                  Optional<std::array<MMATypes, 2>> multiplicandPtxTypes,
        -:  197:                  Optional<std::array<MMALayout, 2>> multiplicandLayouts) {
        -:  198:
    #####:  199:  assert(shape.size() == 3 && "expected shape to have size 3 (m, n, k)");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  200:  MLIRContext *ctx = builder.getContext();
call    0 never executed
    #####:  201:  result.addAttribute(
call    0 never executed
    #####:  202:      "shape", builder.getAttr<MMAShapeAttr>(shape[0], shape[1], shape[2]));
call    0 never executed
call    1 never executed
        -:  203:
    #####:  204:  result.addOperands(operandA);
call    0 never executed
    #####:  205:  result.addOperands(operandB);
call    0 never executed
    #####:  206:  result.addOperands(operandC);
call    0 never executed
        -:  207:
    #####:  208:  if (multiplicandPtxTypes) {
branch  0 never executed
branch  1 never executed
    #####:  209:    result.addAttribute("multiplicandAPtxType",
call    0 never executed
call    1 never executed
    #####:  210:                        MMATypesAttr::get(ctx, (*multiplicandPtxTypes)[0]));
call    0 never executed
call    1 never executed
    #####:  211:    result.addAttribute("multiplicandBPtxType",
call    0 never executed
call    1 never executed
    #####:  212:                        MMATypesAttr::get(ctx, (*multiplicandPtxTypes)[1]));
call    0 never executed
call    1 never executed
        -:  213:  } else {
    #####:  214:    if (auto res = inferOperandMMAType(operandA[0].getType(), false))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  215:      result.addAttribute("multiplicandAPtxType", MMATypesAttr::get(ctx, *res));
call    0 never executed
call    1 never executed
    #####:  216:    if (auto res = inferOperandMMAType(operandB[0].getType(), false))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  217:      result.addAttribute("multiplicandBPtxType", MMATypesAttr::get(ctx, *res));
call    0 never executed
call    1 never executed
        -:  218:  }
        -:  219:
    #####:  220:  if (multiplicandLayouts) {
branch  0 never executed
branch  1 never executed
    #####:  221:    result.addAttribute("layoutA",
call    0 never executed
call    1 never executed
    #####:  222:                        MMALayoutAttr::get(ctx, (*multiplicandLayouts)[0]));
call    0 never executed
call    1 never executed
    #####:  223:    result.addAttribute("layoutB",
call    0 never executed
call    1 never executed
    #####:  224:                        MMALayoutAttr::get(ctx, (*multiplicandLayouts)[1]));
call    0 never executed
call    1 never executed
        -:  225:  } else {
    #####:  226:    result.addAttribute("layoutA", MMALayoutAttr::get(ctx, MMALayout::row));
call    0 never executed
call    1 never executed
    #####:  227:    result.addAttribute("layoutB", MMALayoutAttr::get(ctx, MMALayout::col));
call    0 never executed
call    1 never executed
        -:  228:  }
        -:  229:
    #####:  230:  if (intOverflow.has_value())
branch  0 never executed
branch  1 never executed
    #####:  231:    result.addAttribute("intOverflowBehavior",
call    0 never executed
call    1 never executed
    #####:  232:                        MMAIntOverflowAttr::get(ctx, *intOverflow));
call    0 never executed
call    1 never executed
    #####:  233:  if (b1Op.has_value())
branch  0 never executed
branch  1 never executed
    #####:  234:    result.addAttribute("b1Op", MMAB1OpAttr::get(ctx, *b1Op));
call    0 never executed
call    1 never executed
        -:  235:
    #####:  236:  result.addTypes(resultType);
call    0 never executed
    #####:  237:  result.addAttribute(
call    0 never executed
        -:  238:      MmaOp::getOperandSegmentSizeAttr(),
    #####:  239:      builder.getDenseI32ArrayAttr({static_cast<int32_t>(operandA.size()),
    #####:  240:                                    static_cast<int32_t>(operandB.size()),
call    0 never executed
    #####:  241:                                    static_cast<int32_t>(operandC.size())}));
call    0 never executed
    #####:  242:}
        -:  243:
        -:  244:// <operation> :=
        -:  245://   A `[` $operandA `]` B `[` $operandB `]` C `[` $operandC `]`
        -:  246://   attr-dict : (type($operandA[0]), type($operandB[0]), type($operandC[0]))
        -:  247://     `->` type($res)
function _ZN4mlir4NVVM5MmaOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  248:ParseResult MmaOp::parse(OpAsmParser &parser, OperationState &result) {
    #####:  249:  struct OperandFragment {
        -:  250:    Optional<MMATypes> elemtype;
        -:  251:    SmallVector<OpAsmParser::UnresolvedOperand, 4> regs;
        -:  252:    SmallVector<Type> regTypes;
        -:  253:  };
        -:  254:
    #####:  255:  Builder &builder = parser.getBuilder();
    #####:  256:  std::array<OperandFragment, 4> frags;
call    0 never executed
        -:  257:
    #####:  258:  NamedAttrList namedAttributes;
call    0 never executed
        -:  259:
        -:  260:  // A helper to parse the operand segments.
function _ZZN4mlir4NVVM5MmaOp5parseERNS_11OpAsmParserERNS_14OperationStateEENKUlN4llvm9StringRefERZNS1_5parseES3_S5_E15OperandFragmentE_clES7_S9_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  261:  auto parseMmaOperand = [&](StringRef operandName,
        -:  262:                             OperandFragment &frag) -> LogicalResult {
    #####:  263:    if (parser.parseKeyword(operandName).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  264:      return failure();
    #####:  265:    if (parser
    #####:  266:            .parseOperandList(frag.regs, OpAsmParser::Delimiter::OptionalSquare)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  267:            .failed())
branch  0 never executed
branch  1 never executed
    #####:  268:      return failure();
    #####:  269:    return success();
    #####:  270:  };
        -:  271:
        -:  272:  // Parse the operand segments.
    #####:  273:  if (parseMmaOperand("A", frags[0]).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  274:    return failure();
    #####:  275:  if (parseMmaOperand("B", frags[1]).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  276:    return failure();
    #####:  277:  if (parseMmaOperand("C", frags[2]).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  278:    return failure();
        -:  279:
    #####:  280:  if (parser.parseOptionalAttrDict(namedAttributes).failed())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  281:    return failure();
        -:  282:
        -:  283:  // Parse the type specification and resolve operands.
    #####:  284:  SmallVector<Type, 3> operandTypes;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  285:  if (failed(parser.parseColon()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  286:    return failure();
    #####:  287:  if (failed(parser.parseLParen()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  288:    return failure();
    #####:  289:  if (failed(parser.parseTypeList(operandTypes)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  290:    return failure();
    #####:  291:  if (failed(parser.parseRParen()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  292:    if (operandTypes.size() != 3)
branch  0 never executed
branch  1 never executed
    #####:  293:      return parser.emitError(
call    0 never executed
call    1 never executed
    #####:  294:          parser.getNameLoc(),
    #####:  295:          "expected one type for each operand segment but got " +
    #####:  296:              Twine(operandTypes.size()) + " types");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  297:  for (const auto &iter : llvm::enumerate(operandTypes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  298:    auto &frag = frags[iter.index()];
call    0 never executed
    #####:  299:    frag.regTypes.resize(frag.regs.size(), iter.value());
call    0 never executed
    #####:  300:    if (failed(parser.resolveOperands(frag.regs, frag.regTypes,
branch  0 never executed
branch  1 never executed
    #####:  301:                                      parser.getNameLoc(), result.operands)))
call    0 never executed
call    1 never executed
    #####:  302:      return failure();
    #####:  303:    frag.elemtype =
    #####:  304:        inferOperandMMAType(frag.regTypes[0], /*isAccum=*/iter.index() < 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  305:  }
        -:  306:
    #####:  307:  Type resultType;
    #####:  308:  if (parser.parseArrow() || parser.parseType(resultType))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  309:    return failure();
    #####:  310:  frags[3].elemtype = inferOperandMMAType(resultType, /*isAccum=*/true);
call    0 never executed
        -:  311:
    #####:  312:  std::array<StringRef, 2> names{"multiplicandAPtxType",
    #####:  313:                                 "multiplicandBPtxType"};
    #####:  314:  for (unsigned idx = 0; idx < names.size(); idx++) {
branch  0 never executed
branch  1 never executed
    #####:  315:    const auto &frag = frags[idx];
call    0 never executed
    #####:  316:    Optional<NamedAttribute> attr = namedAttributes.getNamed(names[idx]);
call    0 never executed
    #####:  317:    if (!frag.elemtype.has_value() && !attr.has_value()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  318:      return parser.emitError(
call    0 never executed
call    1 never executed
    #####:  319:          parser.getNameLoc(),
    #####:  320:          "attribute " + names[idx] +
call    0 never executed
call    1 never executed
    #####:  321:              " is not provided explicitly and cannot be inferred");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  322:    }
    #####:  323:    if (!attr.has_value())
branch  0 never executed
branch  1 never executed
    #####:  324:      result.addAttribute(
call    0 never executed
    #####:  325:          names[idx], MMATypesAttr::get(parser.getContext(), *frag.elemtype));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  326:  }
        -:  327:
    #####:  328:  result.addTypes(resultType);
call    0 never executed
    #####:  329:  if (!namedAttributes.empty())
branch  0 never executed
branch  1 never executed
    #####:  330:    result.addAttributes(namedAttributes);
call    0 never executed
call    1 never executed
    #####:  331:  result.addAttribute(MmaOp::getOperandSegmentSizeAttr(),
call    0 never executed
call    1 never executed
    #####:  332:                      builder.getDenseI32ArrayAttr({
    #####:  333:                          static_cast<int32_t>(frags[0].regs.size()),
call    0 never executed
    #####:  334:                          static_cast<int32_t>(frags[1].regs.size()),
    #####:  335:                          static_cast<int32_t>(frags[2].regs.size()),
    #####:  336:                      }));
call    0 never executed
    #####:  337:  return success();
        -:  338:}
        -:  339:
function _ZN4mlir4NVVM5MmaOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  340:LogicalResult MmaOp::verify() {
    #####:  341:  MLIRContext *context = getContext();
call    0 never executed
    #####:  342:  auto f16Ty = Float16Type::get(context);
call    0 never executed
    #####:  343:  auto i32Ty = IntegerType::get(context, 32);
call    0 never executed
    #####:  344:  auto f16x2Ty = LLVM::getFixedVectorType(f16Ty, 2);
call    0 never executed
    #####:  345:  auto f32Ty = Float32Type::get(context);
call    0 never executed
    #####:  346:  auto f16x2x4StructTy = LLVM::LLVMStructType::getLiteral(
    #####:  347:      context, {f16x2Ty, f16x2Ty, f16x2Ty, f16x2Ty});
call    0 never executed
        -:  348:
    #####:  349:  auto s32x4StructTy =
    #####:  350:      LLVM::LLVMStructType::getLiteral(context, {i32Ty, i32Ty, i32Ty, i32Ty});
call    0 never executed
    #####:  351:  auto f32x8StructTy =
call    0 never executed
    #####:  352:      LLVM::LLVMStructType::getLiteral(context, SmallVector<Type>(8, f32Ty));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  353:  auto f16x2x2StructTy =
    #####:  354:      LLVM::LLVMStructType::getLiteral(context, {f16x2Ty, f16x2Ty});
call    0 never executed
    #####:  355:  auto f32x4StructTy =
    #####:  356:      LLVM::LLVMStructType::getLiteral(context, {f32Ty, f32Ty, f32Ty, f32Ty});
call    0 never executed
    #####:  357:  auto s32x2StructTy =
    #####:  358:      LLVM::LLVMStructType::getLiteral(context, {i32Ty, i32Ty});
call    0 never executed
        -:  359:
    #####:  360:  std::array<int64_t, 3> mmaShape{getShapeAttr().getM(), getShapeAttr().getN(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  361:                                  getShapeAttr().getK()};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  362:
        -:  363:  // These variables define the set of allowed data types for matrices A, B, C,
        -:  364:  // and result.
    #####:  365:  using AllowedShapes = SmallVector<std::array<int64_t, 3>, 2>;
    #####:  366:  using AllowedTypes = SmallVector<SmallVector<Type, 4>, 2>;
    #####:  367:  AllowedShapes allowedShapes;
branch  0 never executed
branch  1 never executed
    #####:  368:  AllowedTypes expectedA;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  369:  AllowedTypes expectedB;
call    0 never executed
    #####:  370:  AllowedTypes expectedC;
    #####:  371:  SmallVector<Type> expectedResult;
call    0 never executed
        -:  372:
        -:  373:  // When M = 16, we just need to calculate the number of 8xk tiles, where
        -:  374:  // k is a factor that depends on the data type.
    #####:  375:  if (mmaShape[0] == 16) {
branch  0 never executed
branch  1 never executed
    #####:  376:    int64_t kFactor;
    #####:  377:    Type multiplicandFragType;
    #####:  378:    switch (*getMultiplicandAPtxType()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  379:    case MMATypes::tf32:
    #####:  380:      kFactor = 4;
    #####:  381:      multiplicandFragType = i32Ty;
    #####:  382:      expectedResult.push_back(LLVM::LLVMStructType::getLiteral(
call    0 never executed
    #####:  383:          context, {f32Ty, f32Ty, f32Ty, f32Ty}));
call    0 never executed
    #####:  384:      break;
    #####:  385:    case MMATypes::f16:
    #####:  386:    case MMATypes::bf16:
    #####:  387:      kFactor = 8;
    #####:  388:      multiplicandFragType = f16x2Ty;
    #####:  389:      expectedResult.push_back(f16x2x2StructTy);
call    0 never executed
    #####:  390:      expectedResult.push_back(f32x4StructTy);
    #####:  391:      break;
call    0 never executed
        -:  392:    case MMATypes::s4:
        -:  393:    case MMATypes::u4:
        -:  394:      kFactor = 32;
        -:  395:      break;
    #####:  396:    case MMATypes::b1:
    #####:  397:      kFactor = 128;
    #####:  398:      break;
    #####:  399:    case MMATypes::s8:
    #####:  400:    case MMATypes::u8:
    #####:  401:      kFactor = 16;
    #####:  402:      break;
    #####:  403:    default:
    #####:  404:      return emitError("invalid shape or multiplicand type: " +
call    0 never executed
    #####:  405:                       stringifyEnum(getMultiplicandAPtxType().value()));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
        -:  406:    }
        -:  407:
    #####:  408:    if (isIntegerPtxType(getMultiplicandAPtxType().value())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  409:      expectedResult.push_back(s32x4StructTy);
call    0 never executed
    #####:  410:      expectedC.emplace_back(4, i32Ty);
call    0 never executed
    #####:  411:      multiplicandFragType = i32Ty;
        -:  412:    } else {
    #####:  413:      expectedC.emplace_back(2, f16x2Ty);
call    0 never executed
    #####:  414:      expectedC.emplace_back(4, f32Ty);
call    0 never executed
        -:  415:    }
        -:  416:
    #####:  417:    int64_t unitA = (mmaShape[0] / 8) * (mmaShape[2] / kFactor);
call    0 never executed
    #####:  418:    int64_t unitB = (mmaShape[1] / 8) * (mmaShape[2] / kFactor);
    #####:  419:    expectedA.emplace_back(unitA, multiplicandFragType);
call    0 never executed
    #####:  420:    expectedB.emplace_back(unitB, multiplicandFragType);
call    0 never executed
    #####:  421:    allowedShapes.push_back({16, 8, kFactor});
call    0 never executed
    #####:  422:    allowedShapes.push_back({16, 8, kFactor * 2});
call    0 never executed
        -:  423:  }
        -:  424:
        -:  425:  // In the M=8 case, there is only 1 possible case per data type.
    #####:  426:  if (mmaShape[0] == 8) {
branch  0 never executed
branch  1 never executed
    #####:  427:    if (*getMultiplicandAPtxType() == MMATypes::f16) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  428:      expectedA.emplace_back(2, f16x2Ty);
call    0 never executed
    #####:  429:      expectedB.emplace_back(2, f16x2Ty);
call    0 never executed
    #####:  430:      expectedResult.push_back(f16x2x4StructTy);
call    0 never executed
    #####:  431:      expectedResult.push_back(f32x8StructTy);
call    0 never executed
    #####:  432:      expectedC.emplace_back(4, f16x2Ty);
call    0 never executed
    #####:  433:      expectedC.emplace_back(8, f32Ty);
call    0 never executed
    #####:  434:      allowedShapes.push_back({8, 8, 4});
call    0 never executed
        -:  435:    }
    #####:  436:    if (*getMultiplicandAPtxType() == MMATypes::f64) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  437:      Type f64Ty = Float64Type::get(context);
call    0 never executed
    #####:  438:      expectedA.emplace_back(1, f64Ty);
call    0 never executed
    #####:  439:      expectedB.emplace_back(1, f64Ty);
call    0 never executed
    #####:  440:      expectedC.emplace_back(2, f64Ty);
call    0 never executed
        -:  441:      // expectedC.emplace_back(1, LLVM::getFixedVectorType(f64Ty, 2));
    #####:  442:      expectedResult.emplace_back(LLVM::LLVMStructType::getLiteral(
call    0 never executed
    #####:  443:          context, SmallVector<Type>(2, f64Ty)));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  444:      allowedShapes.push_back({8, 8, 4});
call    0 never executed
        -:  445:    }
    #####:  446:    if (isIntegerPtxType(getMultiplicandAPtxType().value())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  447:      expectedA.push_back({i32Ty});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  448:      expectedB.push_back({i32Ty});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  449:      expectedC.push_back({i32Ty, i32Ty});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  450:      expectedResult.push_back(s32x2StructTy);
call    0 never executed
    #####:  451:      if (isInt4PtxType(getMultiplicandAPtxType().value()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  452:        allowedShapes.push_back({8, 8, 32});
call    0 never executed
    #####:  453:      if (isInt8PtxType(getMultiplicandAPtxType().value()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  454:        allowedShapes.push_back({8, 8, 16});
call    0 never executed
    #####:  455:      if (getMultiplicandAPtxType().value() == MMATypes::b1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  456:        allowedShapes.push_back({8, 8, 128});
call    0 never executed
        -:  457:    }
        -:  458:  }
        -:  459:
    #####:  460:  std::string errorMessage;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  461:  llvm::raw_string_ostream errorStream(errorMessage);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  462:
        -:  463:  // Check that we matched an existing shape/dtype combination.
    #####:  464:  if (expectedA.empty() || expectedB.empty() || expectedC.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  465:      !llvm::is_contained(allowedShapes, mmaShape)) {
branch  0 never executed
branch  1 never executed
    #####:  466:    errorStream << "unimplemented variant for MMA shape <";
call    0 never executed
    #####:  467:    llvm::interleaveComma(mmaShape, errorStream);
call    0 never executed
    #####:  468:    errorStream << ">";
call    0 never executed
    #####:  469:    return emitOpError(errorMessage);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  470:  }
        -:  471:
        -:  472:  // Verify the operand types for segments of A, B, and C operands.
    #####:  473:  std::array<StringRef, 3> operandNames{"A", "B", "C"};
call    0 never executed
    #####:  474:  for (const auto &iter : llvm::enumerate(
call    0 never executed
    #####:  475:           SmallVector<AllowedTypes, 3>{expectedA, expectedB, expectedC})) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
    #####:  476:    auto spec = this->getODSOperandIndexAndLength(iter.index());
call    0 never executed
    #####:  477:    SmallVector<Type, 4> operandTySeg(operand_type_begin() + spec.first,
call    0 never executed
    #####:  478:                                      operand_type_begin() + spec.first +
call    0 never executed
    #####:  479:                                          spec.second);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  480:    bool match = llvm::is_contained(iter.value(), operandTySeg);
call    0 never executed
        -:  481:
    #####:  482:    if (!match) {
branch  0 never executed
branch  1 never executed
    #####:  483:      errorStream << "Could not match types for the "
call    0 never executed
    #####:  484:                  << operandNames[iter.index()]
call    0 never executed
    #####:  485:                  << " operands; expected one of ";
call    0 never executed
    #####:  486:      for (const auto &x : iter.value()) {
branch  0 never executed
branch  1 never executed
    #####:  487:        errorStream << x.size() << "x" << x[0] << " ";
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  488:      }
    #####:  489:      errorStream << "but got ";
call    0 never executed
    #####:  490:      llvm::interleaveComma(operandTySeg, errorStream);
call    0 never executed
    #####:  491:      return emitOpError(errorStream.str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  492:    }
        -:  493:  }
        -:  494:
        -:  495:  // Check the result type
    #####:  496:  if (!llvm::any_of(expectedResult, [&](Type expectedResultType) {
branch  0 never executed
branch  1 never executed
        -:  497:        return expectedResultType == getResult().getType();
        -:  498:      })) {
    #####:  499:    errorStream
    #####:  500:        << "Could not match allowed types for the result; expected one of ";
call    0 never executed
    #####:  501:    llvm::interleaveComma(expectedResult, errorStream);
call    0 never executed
    #####:  502:    errorStream << " but got " << getResult().getType();
call    0 never executed
call    1 never executed
    #####:  503:    return emitOpError(errorStream.str());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  504:  }
        -:  505:
        -:  506:  // Ensure that binary MMA variants have a b1 MMA operation defined.
    #####:  507:  if (getMultiplicandAPtxType() == MMATypes::b1 && !getB1Op()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  508:    return emitOpError("op requires " + getB1OpAttrName().strref() +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  509:                       " attribute");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  510:  }
        -:  511:
        -:  512:  // Ensure int4/int8 MMA variants specify the accum overflow behavior
        -:  513:  // attribute.
    #####:  514:  if (isInt4PtxType(*getMultiplicandAPtxType()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  515:      isInt8PtxType(*getMultiplicandAPtxType())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  516:    if (!getIntOverflowBehavior())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  517:      return emitOpError("op requires " +
call    0 never executed
    #####:  518:                         getIntOverflowBehaviorAttrName().strref() +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  519:                         " attribute");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  520:  }
        -:  521:
    #####:  522:  return success();
call    0 never executed
        -:  523:}
        -:  524:
function _ZN4mlir4NVVM6ShflOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  525:LogicalResult ShflOp::verify() {
    #####:  526:  if (!(*this)->getAttrOfType<UnitAttr>("return_value_and_is_valid"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  527:    return success();
    #####:  528:  auto type = getType().dyn_cast<LLVM::LLVMStructType>();
call    0 never executed
    #####:  529:  auto elementType = (type && type.getBody().size() == 2)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  530:                         ? type.getBody()[1].dyn_cast<IntegerType>()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  531:                         : nullptr;
    #####:  532:  if (!elementType || elementType.getWidth() != 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  533:    return emitError("expected return type to be a two-element struct with "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  534:                     "i1 as the second element");
call    0 never executed
    #####:  535:  return success();
        -:  536:}
        -:  537:
function _ZN4mlir4NVVM12inferMMATypeENS0_8MMATypesENS0_7MMAFragEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  538:std::pair<mlir::Type, unsigned> NVVM::inferMMAType(NVVM::MMATypes type,
        -:  539:                                                   NVVM::MMAFrag frag,
        -:  540:                                                   MLIRContext *context) {
    #####:  541:  unsigned numberElements = 0;
    #####:  542:  Type elementType;
    #####:  543:  OpBuilder builder(context);
call    0 never executed
    #####:  544:  Type f16x2 = VectorType::get(2, builder.getF16Type());
call    0 never executed
call    1 never executed
    #####:  545:  if (type == NVVM::MMATypes::f16) {
branch  0 never executed
branch  1 never executed
    #####:  546:    elementType = f16x2;
    #####:  547:    if (frag == NVVM::MMAFrag::a || frag == NVVM::MMAFrag::b)
branch  0 never executed
branch  1 never executed
        -:  548:      numberElements = 8;
        -:  549:    else
        -:  550:      numberElements = 4;
    #####:  551:  } else if (type == NVVM::MMATypes::f32) {
branch  0 never executed
branch  1 never executed
    #####:  552:    elementType = builder.getF32Type();
call    0 never executed
    #####:  553:    numberElements = 8;
    #####:  554:  } else if (type == NVVM::MMATypes::tf32) {
branch  0 never executed
branch  1 never executed
    #####:  555:    elementType = builder.getI32Type();
call    0 never executed
    #####:  556:    numberElements = 4;
        -:  557:  }
    #####:  558:  assert(numberElements != 0 && elementType != nullptr);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  559:  return std::make_pair(elementType, numberElements);
        -:  560:}
        -:  561:
function _ZN4mlir4NVVM10WMMALoadOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  562:LogicalResult NVVM::WMMALoadOp::verify() {
    #####:  563:  unsigned addressSpace =
    #####:  564:      getPtr().getType().cast<LLVM::LLVMPointerType>().getAddressSpace();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  565:  if (addressSpace != 0 && addressSpace != 1 && addressSpace != 3)
branch  0 never executed
branch  1 never executed
    #####:  566:    return emitOpError("expected source pointer in memory "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  567:                       "space 0, 1, 3");
call    0 never executed
        -:  568:
    #####:  569:  if (NVVM::WMMALoadOp::getIntrinsicID(getM(), getN(), getK(), getLayout(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  570:                                       getEltype(), getFrag()) == 0)
    #####:  571:    return emitOpError() << "invalid attribute combination";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  572:  std::pair<Type, unsigned> typeInfo =
    #####:  573:      inferMMAType(getEltype(), getFrag(), getContext());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  574:  Type dstType = LLVM::LLVMStructType::getLiteral(
    #####:  575:      getContext(), SmallVector<Type, 8>(typeInfo.second, typeInfo.first));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  576:  if (getType() != dstType)
branch  0 never executed
branch  1 never executed
    #####:  577:    return emitOpError("expected destination type is a structure of ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  578:           << typeInfo.second << " elements of type " << typeInfo.first;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  579:  return success();
        -:  580:}
        -:  581:
function _ZN4mlir4NVVM11WMMAStoreOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  582:LogicalResult NVVM::WMMAStoreOp::verify() {
    #####:  583:  unsigned addressSpace =
    #####:  584:      getPtr().getType().cast<LLVM::LLVMPointerType>().getAddressSpace();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  585:  if (addressSpace != 0 && addressSpace != 1 && addressSpace != 3)
branch  0 never executed
branch  1 never executed
    #####:  586:    return emitOpError("expected operands to be a source pointer in memory "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  587:                       "space 0, 1, 3");
call    0 never executed
        -:  588:
    #####:  589:  if (NVVM::WMMAStoreOp::getIntrinsicID(getM(), getN(), getK(), getLayout(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
        -:  590:                                        getEltype()) == 0)
    #####:  591:    return emitOpError() << "invalid attribute combination";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  592:  std::pair<Type, unsigned> typeInfo =
    #####:  593:      inferMMAType(getEltype(), NVVM::MMAFrag::c, getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  594:  if (getArgs().size() != typeInfo.second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  595:    return emitOpError() << "expected " << typeInfo.second << " data operands";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  596:  if (llvm::any_of(getArgs(), [&typeInfo](Value operands) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  597:        return operands.getType() != typeInfo.first;
        -:  598:      }))
    #####:  599:    return emitOpError() << "expected data operands of type " << typeInfo.first;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  600:  return success();
        -:  601:}
        -:  602:
function _ZN4mlir4NVVM9WMMAMmaOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  603:LogicalResult NVVM::WMMAMmaOp::verify() {
    #####:  604:  if (NVVM::WMMAMmaOp::getIntrinsicID(getM(), getN(), getK(), getLayoutA(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -:  605:                                      getLayoutB(), getEltypeA(),
        -:  606:                                      getEltypeB()) == 0)
    #####:  607:    return emitOpError() << "invalid attribute combination";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  608:  std::pair<Type, unsigned> typeInfoA =
    #####:  609:      inferMMAType(getEltypeA(), NVVM::MMAFrag::a, getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  610:  std::pair<Type, unsigned> typeInfoB =
    #####:  611:      inferMMAType(getEltypeA(), NVVM::MMAFrag::b, getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  612:  std::pair<Type, unsigned> typeInfoC =
    #####:  613:      inferMMAType(getEltypeB(), NVVM::MMAFrag::c, getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  614:  SmallVector<Type, 32> arguments;
call    0 never executed
    #####:  615:  arguments.append(typeInfoA.second, typeInfoA.first);
call    0 never executed
    #####:  616:  arguments.append(typeInfoB.second, typeInfoB.first);
call    0 never executed
    #####:  617:  arguments.append(typeInfoC.second, typeInfoC.first);
call    0 never executed
    #####:  618:  unsigned numArgs = arguments.size();
call    0 never executed
    #####:  619:  if (getArgs().size() != numArgs)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  620:    return emitOpError() << "expected " << numArgs << " arguments";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  621:  for (unsigned i = 0; i < numArgs; i++) {
branch  0 never executed
branch  1 never executed
    #####:  622:    if (getArgs()[i].getType() != arguments[i])
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  623:      return emitOpError() << "expected argument " << i << " to be of type "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  624:                           << arguments[i];
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  625:  }
    #####:  626:  Type dstType = LLVM::LLVMStructType::getLiteral(
    #####:  627:      getContext(), SmallVector<Type, 8>(typeInfoC.second, typeInfoC.first));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  628:  if (getType() != dstType)
branch  0 never executed
branch  1 never executed
    #####:  629:    return emitOpError("expected destination type is a structure of ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  630:           << typeInfoC.second << " elements of type " << typeInfoC.first;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  631:  return success();
branch  0 never executed
branch  1 never executed
        -:  632:}
        -:  633:
function _ZN4mlir4NVVM10LdMatrixOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  634:LogicalResult NVVM::LdMatrixOp::verify() {
    #####:  635:  unsigned addressSpace =
    #####:  636:      getPtr().getType().cast<LLVM::LLVMPointerType>().getAddressSpace();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  637:  if (addressSpace != 3)
branch  0 never executed
branch  1 never executed
    #####:  638:    return emitOpError("expected source pointer in memory space 3");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  639:
    #####:  640:  if (getNum() != 1 && getNum() != 2 && getNum() != 4)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  641:    return emitOpError("expected num attribute to be 1, 2 or 4");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  642:
    #####:  643:  Type i32 = IntegerType::get(getContext(), 32);
call    0 never executed
call    1 never executed
    #####:  644:  if (getNum() == 1 && getType() != i32)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  645:    return emitOpError("expected destination type is i32");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  646:  if (getNum() == 2 || getNum() == 4) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  647:    Type dstType = LLVM::LLVMStructType::getLiteral(
    #####:  648:        getContext(), SmallVector<Type>(getNum(), i32));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  649:    if (getType() != dstType)
branch  0 never executed
branch  1 never executed
    #####:  650:      return emitOpError("expected destination type is a structure of ")
call    0 never executed
call    1 never executed
    #####:  651:             << getNum() << " elements of type i32";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  652:  }
    #####:  653:  return success();
        -:  654:}
        -:  655:
        -:  656://===----------------------------------------------------------------------===//
        -:  657:// NVVMDialect initialization, type parsing, and registration.
        -:  658://===----------------------------------------------------------------------===//
        -:  659:
        -:  660:// TODO: This should be the llvm.nvvm dialect once this is supported.
function _ZN4mlir4NVVM11NVVMDialect10initializeEv called 0 returned 0% blocks executed 0%
    3142*:  661:void NVVMDialect::initialize() {
    3142*:  662:  addOperations<
        -:  663:#define GET_OP_LIST
        -:  664:#include "mlir/Dialect/LLVMIR/NVVMOps.cpp.inc"
    3142*:  665:      >();
call    0 never executed
call    1 returned 100%
    3142*:  666:  addAttributes<
        -:  667:#define GET_ATTRDEF_LIST
        -:  668:#include "mlir/Dialect/LLVMIR/NVVMOpsAttributes.cpp.inc"
    3142*:  669:      >();
call    0 never executed
call    1 returned 100%
        -:  670:
        -:  671:  // Support unknown operations because not all NVVM operations are
        -:  672:  // registered.
    3142*:  673:  allowUnknownOperations();
    #####:  674:}
        -:  675:
function _ZN4mlir4NVVM11NVVMDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  676:LogicalResult NVVMDialect::verifyOperationAttribute(Operation *op,
        -:  677:                                                    NamedAttribute attr) {
    #####:  678:  StringAttr attrName = attr.getName();
call    0 never executed
        -:  679:  // Kernel function attribute should be attached to functions.
    #####:  680:  if (attrName == NVVMDialect::getKernelFuncAttrName()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  681:    if (!isa<LLVM::LLVMFuncOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  682:      return op->emitError() << "'" << NVVMDialect::getKernelFuncAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  683:                             << "' attribute attached to unexpected op";
call    0 never executed
        -:  684:    }
        -:  685:  }
        -:  686:  // If maxntid and reqntid exist, it must be an array with max 3 dim
    #####:  687:  if (attrName == NVVMDialect::getMaxntidAttrName() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  688:      attrName == NVVMDialect::getReqntidAttrName()) {
call    0 never executed
    #####:  689:    auto values = attr.getValue().dyn_cast<ArrayAttr>();
call    0 never executed
    #####:  690:    if (!values || values.empty() || values.size() > 3)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  691:      return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  692:             << "'" << attrName
call    0 never executed
call    1 never executed
    #####:  693:             << "' attribute must be integer array with maximum 3 index";
call    0 never executed
    #####:  694:    for (auto val : attr.getValue().cast<ArrayAttr>()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  695:      if (!val.dyn_cast<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  696:        return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  697:               << "'" << attrName
call    0 never executed
call    1 never executed
    #####:  698:               << "' attribute must be integer array with maximum 3 index";
call    0 never executed
        -:  699:    }
        -:  700:  }
        -:  701:  // If minctasm and maxnreg exist, it must be an array with max 3 dim
    #####:  702:  if (attrName == NVVMDialect::getMinctasmAttrName() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  703:      attrName == NVVMDialect::getMaxnregAttrName()) {
call    0 never executed
    #####:  704:    if (!attr.getValue().dyn_cast<IntegerAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  705:      return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  706:             << "'" << attrName << "' attribute must be integer constant";
call    0 never executed
call    1 never executed
call    2 never executed
        -:  707:  }
        -:  708:
    #####:  709:  return success();
        -:  710:}
        -:  711:
        -:  712:#define GET_OP_CLASSES
        -:  713:#include "mlir/Dialect/LLVMIR/NVVMOps.cpp.inc"
        -:  714:
        -:  715:#define GET_ATTRDEF_CLASSES
        -:  716:#include "mlir/Dialect/LLVMIR/NVVMOpsAttributes.cpp.inc"
