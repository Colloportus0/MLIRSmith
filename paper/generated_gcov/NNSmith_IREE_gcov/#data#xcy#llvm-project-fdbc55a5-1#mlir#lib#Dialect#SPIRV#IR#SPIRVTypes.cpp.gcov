        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/SPIRV/IR/SPIRVTypes.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVTypes.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVTypes.cpp.gcda
        -:    0:Runs:325553
        -:    1://===- SPIRVTypes.cpp - MLIR SPIR-V Types ---------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the types in the SPIR-V dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   14:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   15:#include "mlir/IR/Attributes.h"
        -:   16:#include "mlir/IR/BuiltinTypes.h"
        -:   17:#include "llvm/ADT/STLExtras.h"
        -:   18:#include "llvm/ADT/TypeSwitch.h"
        -:   19:
        -:   20:#include <iterator>
        -:   21:
        -:   22:using namespace mlir;
        -:   23:using namespace mlir::spirv;
        -:   24:
        -:   25://===----------------------------------------------------------------------===//
        -:   26:// ArrayType
        -:   27://===----------------------------------------------------------------------===//
        -:   28:
        -:   29:struct spirv::detail::ArrayTypeStorage : public TypeStorage {
        -:   30:  using KeyTy = std::tuple<Type, unsigned, unsigned>;
        -:   31:
    4450*:   32:  static ArrayTypeStorage *construct(TypeStorageAllocator &allocator,
        -:   33:                                     const KeyTy &key) {
    4450*:   34:    return new (allocator.allocate<ArrayTypeStorage>()) ArrayTypeStorage(key);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:   35:  }
        -:   36:
    2169*:   37:  bool operator==(const KeyTy &key) const {
    2169*:   38:    return key == KeyTy(elementType, elementCount, stride);
branch  0 never executed
branch  1 never executed
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
        -:   39:  }
        -:   40:
    4450*:   41:  ArrayTypeStorage(const KeyTy &key)
    4450*:   42:      : elementType(std::get<0>(key)), elementCount(std::get<1>(key)),
    4450*:   43:        stride(std::get<2>(key)) {}
branch  0 never executed
branch  1 never executed
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   44:
        -:   45:  Type elementType;
        -:   46:  unsigned elementCount;
        -:   47:  unsigned stride;
        -:   48:};
        -:   49:
function _ZN4mlir5spirv9ArrayType3getENS_4TypeEj called 6515 returned 100% blocks executed 80%
     6515:   50:ArrayType ArrayType::get(Type elementType, unsigned elementCount) {
    6515*:   51:  assert(elementCount && "ArrayType needs at least one element");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     6515:   52:  return Base::get(elementType.getContext(), elementType, elementCount,
     6515:   53:                   /*stride=*/0);
call    0 returned 100%
call    1 returned 100%
        -:   54:}
        -:   55:
function _ZN4mlir5spirv9ArrayType3getENS_4TypeEjj called 0 returned 0% blocks executed 0%
    #####:   56:ArrayType ArrayType::get(Type elementType, unsigned elementCount,
        -:   57:                         unsigned stride) {
    #####:   58:  assert(elementCount && "ArrayType needs at least one element");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   59:  return Base::get(elementType.getContext(), elementType, elementCount, stride);
call    0 never executed
call    1 never executed
        -:   60:}
        -:   61:
function _ZNK4mlir5spirv9ArrayType14getNumElementsEv called 2062 returned 100% blocks executed 100%
    #####:   62:unsigned ArrayType::getNumElements() const { return getImpl()->elementCount; }
        -:   63:
function _ZNK4mlir5spirv9ArrayType14getElementTypeEv called 2082 returned 100% blocks executed 100%
    3146*:   64:Type ArrayType::getElementType() const { return getImpl()->elementType; }
        -:   65:
function _ZNK4mlir5spirv9ArrayType14getArrayStrideEv called 2042 returned 100% blocks executed 100%
    #####:   66:unsigned ArrayType::getArrayStride() const { return getImpl()->stride; }
        -:   67:
function _ZN4mlir5spirv9ArrayType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 532 returned 100% blocks executed 100%
      532:   68:void ArrayType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -:   69:                              Optional<StorageClass> storage) {
      532:   70:  getElementType().cast<SPIRVType>().getExtensions(extensions, storage);
call    0 returned 100%
call    1 returned 100%
      532:   71:}
        -:   72:
function _ZN4mlir5spirv9ArrayType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 532 returned 100% blocks executed 100%
      532:   73:void ArrayType::getCapabilities(
        -:   74:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:   75:    Optional<StorageClass> storage) {
      532:   76:  getElementType().cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 returned 100%
call    1 returned 100%
      532:   77:}
        -:   78:
function _ZN4mlir5spirv9ArrayType14getSizeInBytesEv called 0 returned 0% blocks executed 0%
    #####:   79:Optional<int64_t> ArrayType::getSizeInBytes() {
    #####:   80:  auto elementType = getElementType().cast<SPIRVType>();
call    0 never executed
    #####:   81:  Optional<int64_t> size = elementType.getSizeInBytes();
call    0 never executed
    #####:   82:  if (!size)
branch  0 never executed
branch  1 never executed
    #####:   83:    return llvm::None;
    #####:   84:  return (*size + getArrayStride()) * getNumElements();
        -:   85:}
        -:   86:
        -:   87://===----------------------------------------------------------------------===//
        -:   88:// CompositeType
        -:   89://===----------------------------------------------------------------------===//
        -:   90:
function _ZN4mlir5spirv13CompositeType7classofENS_4TypeE called 1064 returned 100% blocks executed 83%
     1064:   91:bool CompositeType::classof(Type type) {
     1064:   92:  if (auto vectorType = type.dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   93:    return isValid(vectorType);
call    0 never executed
     1064:   94:  return type.isa<spirv::ArrayType, spirv::CooperativeMatrixNVType,
call    0 returned 100%
        -:   95:                  spirv::JointMatrixINTELType, spirv::MatrixType,
     1064:   96:                  spirv::RuntimeArrayType, spirv::StructType>();
call    0 returned 100%
        -:   97:}
        -:   98:
function _ZN4mlir5spirv13CompositeType7isValidENS_10VectorTypeE called 0 returned 0% blocks executed 0%
    #####:   99:bool CompositeType::isValid(VectorType type) {
    #####:  100:  switch (type.getNumElements()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  101:  case 2:
    #####:  102:  case 3:
    #####:  103:  case 4:
    #####:  104:  case 8:
    #####:  105:  case 16:
    #####:  106:    break;
        -:  107:  default:
        -:  108:    return false;
        -:  109:  }
    #####:  110:  return type.getRank() == 1 && type.getElementType().isa<ScalarType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  111:}
        -:  112:
function _ZNK4mlir5spirv13CompositeType14getElementTypeEj called 0 returned 0% blocks executed 0%
    #####:  113:Type CompositeType::getElementType(unsigned index) const {
    #####:  114:  return TypeSwitch<Type, Type>(*this)
call    0 never executed
        -:  115:      .Case<ArrayType, CooperativeMatrixNVType, JointMatrixINTELType,
        -:  116:            RuntimeArrayType, VectorType>(
    #####:  117:          [](auto type) { return type.getElementType(); })
    #####:  118:      .Case<MatrixType>([](MatrixType type) { return type.getColumnType(); })
call    0 never executed
        -:  119:      .Case<StructType>(
    #####:  120:          [index](StructType type) { return type.getElementType(index); })
call    0 never executed
call    1 never executed
        -:  121:      .Default(
function _ZZNK4mlir5spirv13CompositeType14getElementTypeEjENKUlNS_4TypeEE2_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  122:          [](Type) -> Type { llvm_unreachable("invalid composite type"); });
branch  0 never executed
branch  1 never executed
        -:  123:}
        -:  124:
function _ZNK4mlir5spirv13CompositeType14getNumElementsEv called 0 returned 0% blocks executed 0%
    #####:  125:unsigned CompositeType::getNumElements() const {
    #####:  126:  if (auto arrayType = dyn_cast<ArrayType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  127:    return arrayType.getNumElements();
    #####:  128:  if (auto matrixType = dyn_cast<MatrixType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  129:    return matrixType.getNumColumns();
    #####:  130:  if (auto structType = dyn_cast<StructType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:    return structType.getNumElements();
    #####:  132:  if (auto vectorType = dyn_cast<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  133:    return vectorType.getNumElements();
call    0 never executed
    #####:  134:  if (isa<CooperativeMatrixNVType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  135:    llvm_unreachable(
call    0 never executed
        -:  136:        "invalid to query number of elements of spirv::CooperativeMatrix type");
        -:  137:  }
    #####:  138:  if (isa<JointMatrixINTELType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  139:    llvm_unreachable(
call    0 never executed
        -:  140:        "invalid to query number of elements of spirv::JointMatrix type");
        -:  141:  }
    #####:  142:  if (isa<RuntimeArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  143:    llvm_unreachable(
call    0 never executed
        -:  144:        "invalid to query number of elements of spirv::RuntimeArray type");
        -:  145:  }
    #####:  146:  llvm_unreachable("invalid composite type");
call    0 never executed
        -:  147:}
        -:  148:
function _ZNK4mlir5spirv13CompositeType30hasCompileTimeKnownNumElementsEv called 0 returned 0% blocks executed 0%
    #####:  149:bool CompositeType::hasCompileTimeKnownNumElements() const {
    #####:  150:  return !isa<CooperativeMatrixNVType, JointMatrixINTELType,
    #####:  151:              RuntimeArrayType>();
call    0 never executed
        -:  152:}
        -:  153:
function _ZN4mlir5spirv13CompositeType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 532 returned 100% blocks executed 90%
      532:  154:void CompositeType::getExtensions(
        -:  155:    SPIRVType::ExtensionArrayRefVector &extensions,
        -:  156:    Optional<StorageClass> storage) {
      532:  157:  TypeSwitch<Type>(*this)
call    0 returned 100%
        -:  158:      .Case<ArrayType, CooperativeMatrixNVType, JointMatrixINTELType,
        -:  159:            MatrixType, RuntimeArrayType, StructType>(
    1064*:  160:          [&](auto type) { type.getExtensions(extensions, storage); })
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 returned 100%
function _ZZN4mlir5spirv13CompositeType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEEENKUlNS_10VectorTypeEE0_clESC_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  161:      .Case<VectorType>([&](VectorType type) {
    #####:  162:        return type.getElementType().cast<ScalarType>().getExtensions(
call    0 never executed
call    1 never executed
    #####:  163:            extensions, storage);
call    0 never executed
      532:  164:      })
call    0 returned 100%
function _ZZN4mlir5spirv13CompositeType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEEENKUlNS_4TypeEE1_clESC_.isra.0 called 0 returned 0% blocks executed 0%
     532*:  165:      .Default([](Type) { llvm_unreachable("invalid composite type"); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      532:  166:}
        -:  167:
function _ZN4mlir5spirv13CompositeType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 532 returned 100% blocks executed 90%
      532:  168:void CompositeType::getCapabilities(
        -:  169:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  170:    Optional<StorageClass> storage) {
      532:  171:  TypeSwitch<Type>(*this)
call    0 returned 100%
        -:  172:      .Case<ArrayType, CooperativeMatrixNVType, JointMatrixINTELType,
        -:  173:            MatrixType, RuntimeArrayType, StructType>(
    1064*:  174:          [&](auto type) { type.getCapabilities(capabilities, storage); })
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 returned 100%
call    6 returned 100%
function _ZZN4mlir5spirv13CompositeType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEEENKUlNS_10VectorTypeEE0_clESC_ called 0 returned 0% blocks executed 0%
    #####:  175:      .Case<VectorType>([&](VectorType type) {
    #####:  176:        auto vecSize = getNumElements();
call    0 never executed
    #####:  177:        if (vecSize == 8 || vecSize == 16) {
branch  0 never executed
branch  1 never executed
    #####:  178:          static const Capability caps[] = {Capability::Vector16};
    #####:  179:          ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####:  180:          capabilities.push_back(ref);
call    0 never executed
        -:  181:        }
    #####:  182:        return type.getElementType().cast<ScalarType>().getCapabilities(
call    0 never executed
call    1 never executed
    #####:  183:            capabilities, storage);
call    0 never executed
      532:  184:      })
call    0 returned 100%
function _ZZN4mlir5spirv13CompositeType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEEENKUlNS_4TypeEE1_clESC_.isra.0 called 0 returned 0% blocks executed 0%
     532*:  185:      .Default([](Type) { llvm_unreachable("invalid composite type"); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      532:  186:}
        -:  187:
function _ZN4mlir5spirv13CompositeType14getSizeInBytesEv called 0 returned 0% blocks executed 0%
    #####:  188:Optional<int64_t> CompositeType::getSizeInBytes() {
    #####:  189:  if (auto arrayType = dyn_cast<ArrayType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  190:    return arrayType.getSizeInBytes();
call    0 never executed
    #####:  191:  if (auto structType = dyn_cast<StructType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  192:    return structType.getSizeInBytes();
call    0 never executed
    #####:  193:  if (auto vectorType = dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  194:    Optional<int64_t> elementSize =
    #####:  195:        vectorType.getElementType().cast<ScalarType>().getSizeInBytes();
call    0 never executed
call    1 never executed
    #####:  196:    if (!elementSize)
branch  0 never executed
branch  1 never executed
    #####:  197:      return llvm::None;
    #####:  198:    return *elementSize * vectorType.getNumElements();
call    0 never executed
        -:  199:  }
    #####:  200:  return llvm::None;
        -:  201:}
        -:  202:
        -:  203://===----------------------------------------------------------------------===//
        -:  204:// CooperativeMatrixType
        -:  205://===----------------------------------------------------------------------===//
        -:  206:
        -:  207:struct spirv::detail::CooperativeMatrixTypeStorage : public TypeStorage {
        -:  208:  using KeyTy = std::tuple<Type, Scope, unsigned, unsigned>;
        -:  209:
        -:  210:  static CooperativeMatrixTypeStorage *
function _ZN4mlir5spirv6detail28CooperativeMatrixTypeStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt5tupleIJNS_4TypeENS0_5ScopeEjjEE called 0 returned 0% blocks executed 0%
    #####:  211:  construct(TypeStorageAllocator &allocator, const KeyTy &key) {
    #####:  212:    return new (allocator.allocate<CooperativeMatrixTypeStorage>())
call    0 never executed
    #####:  213:        CooperativeMatrixTypeStorage(key);
        -:  214:  }
        -:  215:
    #####:  216:  bool operator==(const KeyTy &key) const {
    #####:  217:    return key == KeyTy(elementType, scope, rows, columns);
branch  0 never executed
branch  1 never executed
        -:  218:  }
        -:  219:
    #####:  220:  CooperativeMatrixTypeStorage(const KeyTy &key)
    #####:  221:      : elementType(std::get<0>(key)), rows(std::get<2>(key)),
    #####:  222:        columns(std::get<3>(key)), scope(std::get<1>(key)) {}
        -:  223:
        -:  224:  Type elementType;
        -:  225:  unsigned rows;
        -:  226:  unsigned columns;
        -:  227:  Scope scope;
        -:  228:};
        -:  229:
function _ZN4mlir5spirv23CooperativeMatrixNVType3getENS_4TypeENS0_5ScopeEjj called 0 returned 0% blocks executed 0%
    #####:  230:CooperativeMatrixNVType CooperativeMatrixNVType::get(Type elementType,
        -:  231:                                                     Scope scope, unsigned rows,
        -:  232:                                                     unsigned columns) {
    #####:  233:  return Base::get(elementType.getContext(), elementType, scope, rows, columns);
call    0 never executed
call    1 never executed
        -:  234:}
        -:  235:
function _ZNK4mlir5spirv23CooperativeMatrixNVType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####:  236:Type CooperativeMatrixNVType::getElementType() const {
    #####:  237:  return getImpl()->elementType;
        -:  238:}
        -:  239:
function _ZNK4mlir5spirv23CooperativeMatrixNVType8getScopeEv called 0 returned 0% blocks executed 0%
    #####:  240:Scope CooperativeMatrixNVType::getScope() const { return getImpl()->scope; }
        -:  241:
function _ZNK4mlir5spirv23CooperativeMatrixNVType7getRowsEv called 0 returned 0% blocks executed 0%
    #####:  242:unsigned CooperativeMatrixNVType::getRows() const { return getImpl()->rows; }
        -:  243:
function _ZNK4mlir5spirv23CooperativeMatrixNVType10getColumnsEv called 0 returned 0% blocks executed 0%
    #####:  244:unsigned CooperativeMatrixNVType::getColumns() const {
    #####:  245:  return getImpl()->columns;
        -:  246:}
        -:  247:
function _ZN4mlir5spirv23CooperativeMatrixNVType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  248:void CooperativeMatrixNVType::getExtensions(
        -:  249:    SPIRVType::ExtensionArrayRefVector &extensions,
        -:  250:    Optional<StorageClass> storage) {
    #####:  251:  getElementType().cast<SPIRVType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####:  252:  static const Extension exts[] = {Extension::SPV_NV_cooperative_matrix};
    #####:  253:  ArrayRef<Extension> ref(exts, std::size(exts));
call    0 never executed
    #####:  254:  extensions.push_back(ref);
call    0 never executed
    #####:  255:}
        -:  256:
function _ZN4mlir5spirv23CooperativeMatrixNVType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  257:void CooperativeMatrixNVType::getCapabilities(
        -:  258:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  259:    Optional<StorageClass> storage) {
    #####:  260:  getElementType().cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####:  261:  static const Capability caps[] = {Capability::CooperativeMatrixNV};
    #####:  262:  ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####:  263:  capabilities.push_back(ref);
call    0 never executed
    #####:  264:}
        -:  265:
        -:  266://===----------------------------------------------------------------------===//
        -:  267:// JointMatrixType
        -:  268://===----------------------------------------------------------------------===//
        -:  269:
        -:  270:struct spirv::detail::JointMatrixTypeStorage : public TypeStorage {
        -:  271:  using KeyTy = std::tuple<Type, unsigned, unsigned, MatrixLayout, Scope>;
        -:  272:
function _ZN4mlir5spirv6detail22JointMatrixTypeStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt5tupleIJNS_4TypeEjjNS0_12MatrixLayoutENS0_5ScopeEEE called 0 returned 0% blocks executed 0%
    #####:  273:  static JointMatrixTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  274:                                           const KeyTy &key) {
    #####:  275:    return new (allocator.allocate<JointMatrixTypeStorage>())
call    0 never executed
    #####:  276:        JointMatrixTypeStorage(key);
        -:  277:  }
        -:  278:
    #####:  279:  bool operator==(const KeyTy &key) const {
    #####:  280:    return key == KeyTy(elementType, rows, columns, matrixLayout, scope);
branch  0 never executed
branch  1 never executed
        -:  281:  }
        -:  282:
    #####:  283:  JointMatrixTypeStorage(const KeyTy &key)
    #####:  284:      : elementType(std::get<0>(key)), rows(std::get<1>(key)),
    #####:  285:        columns(std::get<2>(key)), scope(std::get<4>(key)),
    #####:  286:        matrixLayout(std::get<3>(key)) {}
        -:  287:
        -:  288:  Type elementType;
        -:  289:  unsigned rows;
        -:  290:  unsigned columns;
        -:  291:  Scope scope;
        -:  292:  MatrixLayout matrixLayout;
        -:  293:};
        -:  294:
function _ZN4mlir5spirv20JointMatrixINTELType3getENS_4TypeENS0_5ScopeEjjNS0_12MatrixLayoutE called 0 returned 0% blocks executed 0%
    #####:  295:JointMatrixINTELType JointMatrixINTELType::get(Type elementType, Scope scope,
        -:  296:                                               unsigned rows, unsigned columns,
        -:  297:                                               MatrixLayout matrixLayout) {
    #####:  298:  return Base::get(elementType.getContext(), elementType, rows, columns,
    #####:  299:                   matrixLayout, scope);
call    0 never executed
call    1 never executed
        -:  300:}
        -:  301:
function _ZNK4mlir5spirv20JointMatrixINTELType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####:  302:Type JointMatrixINTELType::getElementType() const {
    #####:  303:  return getImpl()->elementType;
        -:  304:}
        -:  305:
function _ZNK4mlir5spirv20JointMatrixINTELType8getScopeEv called 0 returned 0% blocks executed 0%
    #####:  306:Scope JointMatrixINTELType::getScope() const { return getImpl()->scope; }
        -:  307:
function _ZNK4mlir5spirv20JointMatrixINTELType7getRowsEv called 0 returned 0% blocks executed 0%
    #####:  308:unsigned JointMatrixINTELType::getRows() const { return getImpl()->rows; }
        -:  309:
function _ZNK4mlir5spirv20JointMatrixINTELType10getColumnsEv called 0 returned 0% blocks executed 0%
    #####:  310:unsigned JointMatrixINTELType::getColumns() const { return getImpl()->columns; }
        -:  311:
function _ZNK4mlir5spirv20JointMatrixINTELType15getMatrixLayoutEv called 0 returned 0% blocks executed 0%
    #####:  312:MatrixLayout JointMatrixINTELType::getMatrixLayout() const {
    #####:  313:  return getImpl()->matrixLayout;
        -:  314:}
        -:  315:
function _ZN4mlir5spirv20JointMatrixINTELType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  316:void JointMatrixINTELType::getExtensions(
        -:  317:    SPIRVType::ExtensionArrayRefVector &extensions,
        -:  318:    Optional<StorageClass> storage) {
    #####:  319:  getElementType().cast<SPIRVType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####:  320:  static const Extension exts[] = {Extension::SPV_INTEL_joint_matrix};
    #####:  321:  ArrayRef<Extension> ref(exts, std::size(exts));
call    0 never executed
    #####:  322:  extensions.push_back(ref);
call    0 never executed
    #####:  323:}
        -:  324:
function _ZN4mlir5spirv20JointMatrixINTELType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  325:void JointMatrixINTELType::getCapabilities(
        -:  326:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  327:    Optional<StorageClass> storage) {
    #####:  328:  getElementType().cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####:  329:  static const Capability caps[] = {Capability::JointMatrixINTEL};
    #####:  330:  ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####:  331:  capabilities.push_back(ref);
call    0 never executed
    #####:  332:}
        -:  333:
        -:  334://===----------------------------------------------------------------------===//
        -:  335:// ImageType
        -:  336://===----------------------------------------------------------------------===//
        -:  337:
        -:  338:template <typename T>
        -:  339:static constexpr unsigned getNumBits() {
        -:  340:  return 0;
        -:  341:}
        -:  342:template <>
        -:  343:constexpr unsigned getNumBits<Dim>() {
        -:  344:  static_assert((1 << 3) > getMaxEnumValForDim(),
        -:  345:                "Not enough bits to encode Dim value");
        -:  346:  return 3;
        -:  347:}
        -:  348:template <>
        -:  349:constexpr unsigned getNumBits<ImageDepthInfo>() {
        -:  350:  static_assert((1 << 2) > getMaxEnumValForImageDepthInfo(),
        -:  351:                "Not enough bits to encode ImageDepthInfo value");
        -:  352:  return 2;
        -:  353:}
        -:  354:template <>
        -:  355:constexpr unsigned getNumBits<ImageArrayedInfo>() {
        -:  356:  static_assert((1 << 1) > getMaxEnumValForImageArrayedInfo(),
        -:  357:                "Not enough bits to encode ImageArrayedInfo value");
        -:  358:  return 1;
        -:  359:}
        -:  360:template <>
        -:  361:constexpr unsigned getNumBits<ImageSamplingInfo>() {
        -:  362:  static_assert((1 << 1) > getMaxEnumValForImageSamplingInfo(),
        -:  363:                "Not enough bits to encode ImageSamplingInfo value");
        -:  364:  return 1;
        -:  365:}
        -:  366:template <>
        -:  367:constexpr unsigned getNumBits<ImageSamplerUseInfo>() {
        -:  368:  static_assert((1 << 2) > getMaxEnumValForImageSamplerUseInfo(),
        -:  369:                "Not enough bits to encode ImageSamplerUseInfo value");
        -:  370:  return 2;
        -:  371:}
        -:  372:template <>
        -:  373:constexpr unsigned getNumBits<ImageFormat>() {
        -:  374:  static_assert((1 << 6) > getMaxEnumValForImageFormat(),
        -:  375:                "Not enough bits to encode ImageFormat value");
        -:  376:  return 6;
        -:  377:}
        -:  378:
        -:  379:struct spirv::detail::ImageTypeStorage : public TypeStorage {
        -:  380:public:
        -:  381:  using KeyTy = std::tuple<Type, Dim, ImageDepthInfo, ImageArrayedInfo,
        -:  382:                           ImageSamplingInfo, ImageSamplerUseInfo, ImageFormat>;
        -:  383:
function _ZN4mlir5spirv6detail16ImageTypeStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt5tupleIJNS_4TypeENS0_3DimENS0_14ImageDepthInfoENS0_16ImageArrayedInfoENS0_17ImageSamplingInfoENS0_19ImageSamplerUseInfoENS0_11ImageFormatEEE called 0 returned 0% blocks executed 0%
    #####:  384:  static ImageTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  385:                                     const KeyTy &key) {
    #####:  386:    return new (allocator.allocate<ImageTypeStorage>()) ImageTypeStorage(key);
call    0 never executed
        -:  387:  }
        -:  388:
function _ZNK4mlir5spirv6detail16ImageTypeStorageeqERKSt5tupleIJNS_4TypeENS0_3DimENS0_14ImageDepthInfoENS0_16ImageArrayedInfoENS0_17ImageSamplingInfoENS0_19ImageSamplerUseInfoENS0_11ImageFormatEEE called 0 returned 0% blocks executed 0%
    #####:  389:  bool operator==(const KeyTy &key) const {
    #####:  390:    return key == KeyTy(elementType, dim, depthInfo, arrayedInfo, samplingInfo,
    #####:  391:                        samplerUseInfo, format);
        -:  392:  }
        -:  393:
    #####:  394:  ImageTypeStorage(const KeyTy &key)
    #####:  395:      : elementType(std::get<0>(key)), dim(std::get<1>(key)),
    #####:  396:        depthInfo(std::get<2>(key)), arrayedInfo(std::get<3>(key)),
    #####:  397:        samplingInfo(std::get<4>(key)), samplerUseInfo(std::get<5>(key)),
    #####:  398:        format(std::get<6>(key)) {}
        -:  399:
        -:  400:  Type elementType;
        -:  401:  Dim dim : getNumBits<Dim>();
        -:  402:  ImageDepthInfo depthInfo : getNumBits<ImageDepthInfo>();
        -:  403:  ImageArrayedInfo arrayedInfo : getNumBits<ImageArrayedInfo>();
        -:  404:  ImageSamplingInfo samplingInfo : getNumBits<ImageSamplingInfo>();
        -:  405:  ImageSamplerUseInfo samplerUseInfo : getNumBits<ImageSamplerUseInfo>();
        -:  406:  ImageFormat format : getNumBits<ImageFormat>();
        -:  407:};
        -:  408:
        -:  409:ImageType
function _ZN4mlir5spirv9ImageType3getESt5tupleIJNS_4TypeENS0_3DimENS0_14ImageDepthInfoENS0_16ImageArrayedInfoENS0_17ImageSamplingInfoENS0_19ImageSamplerUseInfoENS0_11ImageFormatEEE called 0 returned 0% blocks executed 0%
    #####:  410:ImageType::get(std::tuple<Type, Dim, ImageDepthInfo, ImageArrayedInfo,
        -:  411:                          ImageSamplingInfo, ImageSamplerUseInfo, ImageFormat>
        -:  412:                   value) {
    #####:  413:  return Base::get(std::get<0>(value).getContext(), value);
call    0 never executed
call    1 never executed
        -:  414:}
        -:  415:
function _ZNK4mlir5spirv9ImageType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####:  416:Type ImageType::getElementType() const { return getImpl()->elementType; }
        -:  417:
function _ZNK4mlir5spirv9ImageType6getDimEv called 0 returned 0% blocks executed 0%
    #####:  418:Dim ImageType::getDim() const { return getImpl()->dim; }
        -:  419:
function _ZNK4mlir5spirv9ImageType12getDepthInfoEv called 0 returned 0% blocks executed 0%
    #####:  420:ImageDepthInfo ImageType::getDepthInfo() const { return getImpl()->depthInfo; }
        -:  421:
function _ZNK4mlir5spirv9ImageType14getArrayedInfoEv called 0 returned 0% blocks executed 0%
    #####:  422:ImageArrayedInfo ImageType::getArrayedInfo() const {
    #####:  423:  return getImpl()->arrayedInfo;
        -:  424:}
        -:  425:
function _ZNK4mlir5spirv9ImageType15getSamplingInfoEv called 0 returned 0% blocks executed 0%
    #####:  426:ImageSamplingInfo ImageType::getSamplingInfo() const {
    #####:  427:  return getImpl()->samplingInfo;
        -:  428:}
        -:  429:
function _ZNK4mlir5spirv9ImageType17getSamplerUseInfoEv called 0 returned 0% blocks executed 0%
    #####:  430:ImageSamplerUseInfo ImageType::getSamplerUseInfo() const {
    #####:  431:  return getImpl()->samplerUseInfo;
        -:  432:}
        -:  433:
function _ZNK4mlir5spirv9ImageType14getImageFormatEv called 0 returned 0% blocks executed 0%
    #####:  434:ImageFormat ImageType::getImageFormat() const { return getImpl()->format; }
        -:  435:
function _ZN4mlir5spirv9ImageType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  436:void ImageType::getExtensions(SPIRVType::ExtensionArrayRefVector &,
        -:  437:                              Optional<StorageClass>) {
        -:  438:  // Image types do not require extra extensions thus far.
    #####:  439:}
        -:  440:
function _ZN4mlir5spirv9ImageType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  441:void ImageType::getCapabilities(
        -:  442:    SPIRVType::CapabilityArrayRefVector &capabilities, Optional<StorageClass>) {
    #####:  443:  if (auto dimCaps = spirv::getCapabilities(getDim()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  444:    capabilities.push_back(*dimCaps);
call    0 never executed
        -:  445:
    #####:  446:  if (auto fmtCaps = spirv::getCapabilities(getImageFormat()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  447:    capabilities.push_back(*fmtCaps);
call    0 never executed
    #####:  448:}
        -:  449:
        -:  450://===----------------------------------------------------------------------===//
        -:  451:// PointerType
        -:  452://===----------------------------------------------------------------------===//
        -:  453:
        -:  454:struct spirv::detail::PointerTypeStorage : public TypeStorage {
        -:  455:  // (Type, StorageClass) as the key: Type stored in this struct, and
        -:  456:  // StorageClass stored as TypeStorage's subclass data.
        -:  457:  using KeyTy = std::pair<Type, StorageClass>;
        -:  458:
    #####:  459:  static PointerTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  460:                                       const KeyTy &key) {
    #####:  461:    return new (allocator.allocate<PointerTypeStorage>())
call    0 never executed
    #####:  462:        PointerTypeStorage(key);
branch  0 never executed
branch  1 never executed
        -:  463:  }
        -:  464:
    #####:  465:  bool operator==(const KeyTy &key) const {
    #####:  466:    return key == KeyTy(pointeeType, storageClass);
branch  0 never executed
branch  1 never executed
        -:  467:  }
        -:  468:
    #####:  469:  PointerTypeStorage(const KeyTy &key)
    #####:  470:      : pointeeType(key.first), storageClass(key.second) {}
branch  0 never executed
branch  1 never executed
        -:  471:
        -:  472:  Type pointeeType;
        -:  473:  StorageClass storageClass;
        -:  474:};
        -:  475:
function _ZN4mlir5spirv11PointerType3getENS_4TypeENS0_12StorageClassE called 0 returned 0% blocks executed 0%
    #####:  476:PointerType PointerType::get(Type pointeeType, StorageClass storageClass) {
    #####:  477:  return Base::get(pointeeType.getContext(), pointeeType, storageClass);
call    0 never executed
call    1 never executed
        -:  478:}
        -:  479:
function _ZNK4mlir5spirv11PointerType14getPointeeTypeEv called 0 returned 0% blocks executed 0%
    #####:  480:Type PointerType::getPointeeType() const { return getImpl()->pointeeType; }
        -:  481:
function _ZNK4mlir5spirv11PointerType15getStorageClassEv called 0 returned 0% blocks executed 0%
    #####:  482:StorageClass PointerType::getStorageClass() const {
    #####:  483:  return getImpl()->storageClass;
        -:  484:}
        -:  485:
function _ZN4mlir5spirv11PointerType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  486:void PointerType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -:  487:                                Optional<StorageClass> storage) {
        -:  488:  // Use this pointer type's storage class because this pointer indicates we are
        -:  489:  // using the pointee type in that specific storage class.
    #####:  490:  getPointeeType().cast<SPIRVType>().getExtensions(extensions,
call    0 never executed
call    1 never executed
    #####:  491:                                                   getStorageClass());
call    0 never executed
        -:  492:
    #####:  493:  if (auto scExts = spirv::getExtensions(getStorageClass()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  494:    extensions.push_back(*scExts);
call    0 never executed
    #####:  495:}
        -:  496:
function _ZN4mlir5spirv11PointerType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  497:void PointerType::getCapabilities(
        -:  498:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  499:    Optional<StorageClass> storage) {
        -:  500:  // Use this pointer type's storage class because this pointer indicates we are
        -:  501:  // using the pointee type in that specific storage class.
    #####:  502:  getPointeeType().cast<SPIRVType>().getCapabilities(capabilities,
call    0 never executed
call    1 never executed
    #####:  503:                                                     getStorageClass());
call    0 never executed
        -:  504:
    #####:  505:  if (auto scCaps = spirv::getCapabilities(getStorageClass()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:    capabilities.push_back(*scCaps);
call    0 never executed
    #####:  507:}
        -:  508:
        -:  509://===----------------------------------------------------------------------===//
        -:  510:// RuntimeArrayType
        -:  511://===----------------------------------------------------------------------===//
        -:  512:
        -:  513:struct spirv::detail::RuntimeArrayTypeStorage : public TypeStorage {
        -:  514:  using KeyTy = std::pair<Type, unsigned>;
        -:  515:
    #####:  516:  static RuntimeArrayTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  517:                                            const KeyTy &key) {
    #####:  518:    return new (allocator.allocate<RuntimeArrayTypeStorage>())
call    0 never executed
call    1 never executed
    #####:  519:        RuntimeArrayTypeStorage(key);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  520:  }
        -:  521:
    #####:  522:  bool operator==(const KeyTy &key) const {
    #####:  523:    return key == KeyTy(elementType, stride);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  524:  }
        -:  525:
    #####:  526:  RuntimeArrayTypeStorage(const KeyTy &key)
    #####:  527:      : elementType(key.first), stride(key.second) {}
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  528:
        -:  529:  Type elementType;
        -:  530:  unsigned stride;
        -:  531:};
        -:  532:
function _ZN4mlir5spirv16RuntimeArrayType3getENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  533:RuntimeArrayType RuntimeArrayType::get(Type elementType) {
    #####:  534:  return Base::get(elementType.getContext(), elementType, /*stride=*/0);
call    0 never executed
call    1 never executed
        -:  535:}
        -:  536:
function _ZN4mlir5spirv16RuntimeArrayType3getENS_4TypeEj called 0 returned 0% blocks executed 0%
    #####:  537:RuntimeArrayType RuntimeArrayType::get(Type elementType, unsigned stride) {
    #####:  538:  return Base::get(elementType.getContext(), elementType, stride);
call    0 never executed
call    1 never executed
        -:  539:}
        -:  540:
function _ZNK4mlir5spirv16RuntimeArrayType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####:  541:Type RuntimeArrayType::getElementType() const { return getImpl()->elementType; }
        -:  542:
function _ZNK4mlir5spirv16RuntimeArrayType14getArrayStrideEv called 0 returned 0% blocks executed 0%
    #####:  543:unsigned RuntimeArrayType::getArrayStride() const { return getImpl()->stride; }
        -:  544:
function _ZN4mlir5spirv16RuntimeArrayType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  545:void RuntimeArrayType::getExtensions(
        -:  546:    SPIRVType::ExtensionArrayRefVector &extensions,
        -:  547:    Optional<StorageClass> storage) {
    #####:  548:  getElementType().cast<SPIRVType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####:  549:}
        -:  550:
function _ZN4mlir5spirv16RuntimeArrayType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  551:void RuntimeArrayType::getCapabilities(
        -:  552:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  553:    Optional<StorageClass> storage) {
    #####:  554:  {
    #####:  555:    static const Capability caps[] = {Capability::Shader};
    #####:  556:    ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####:  557:    capabilities.push_back(ref);
call    0 never executed
        -:  558:  }
    #####:  559:  getElementType().cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####:  560:}
        -:  561:
        -:  562://===----------------------------------------------------------------------===//
        -:  563:// ScalarType
        -:  564://===----------------------------------------------------------------------===//
        -:  565:
function _ZN4mlir5spirv10ScalarType7classofENS_4TypeE called 36323 returned 100% blocks executed 100%
    36323:  566:bool ScalarType::classof(Type type) {
    36323:  567:  if (auto floatType = type.dyn_cast<FloatType>()) {
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23%
    56216:  568:    return isValid(floatType);
        -:  569:  }
     8215:  570:  if (auto intType = type.dyn_cast<IntegerType>()) {
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
      408:  571:    return isValid(intType);
call    0 returned 100%
        -:  572:  }
        -:  573:  return false;
        -:  574:}
        -:  575:
function _ZN4mlir5spirv10ScalarType7isValidENS_9FloatTypeE called 0 returned 0% blocks executed 0%
   28108*:  576:bool ScalarType::isValid(FloatType type) { return !type.isBF16(); }
call    0 never executed
call    1 returned 100%
        -:  577:
function _ZN4mlir5spirv10ScalarType7isValidENS_11IntegerTypeE called 408 returned 100% blocks executed 75%
      408:  578:bool ScalarType::isValid(IntegerType type) {
      408:  579:  switch (type.getWidth()) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
        -:  580:  case 1:
        -:  581:  case 8:
        -:  582:  case 16:
        -:  583:  case 32:
        -:  584:  case 64:
        -:  585:    return true;
    #####:  586:  default:
    #####:  587:    return false;
        -:  588:  }
        -:  589:}
        -:  590:
function _ZN4mlir5spirv10ScalarType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 7113 returned 100% blocks executed 18%
     7113:  591:void ScalarType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -:  592:                               Optional<StorageClass> storage) {
        -:  593:  // 8- or 16-bit integer/floating-point numbers will require extra extensions
        -:  594:  // to appear in interface storage classes. See SPV_KHR_16bit_storage and
        -:  595:  // SPV_KHR_8bit_storage for more details.
     7113:  596:  if (!storage)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  597:    return;
        -:  598:
    #####:  599:  switch (*storage) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  600:  case StorageClass::PushConstant:
    #####:  601:  case StorageClass::StorageBuffer:
    #####:  602:  case StorageClass::Uniform:
    #####:  603:    if (getIntOrFloatBitWidth() == 8) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  604:      static const Extension exts[] = {Extension::SPV_KHR_8bit_storage};
    #####:  605:      ArrayRef<Extension> ref(exts, std::size(exts));
call    0 never executed
    #####:  606:      extensions.push_back(ref);
call    0 never executed
        -:  607:    }
    #####:  608:    [[fallthrough]];
    #####:  609:  case StorageClass::Input:
    #####:  610:  case StorageClass::Output:
    #####:  611:    if (getIntOrFloatBitWidth() == 16) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  612:      static const Extension exts[] = {Extension::SPV_KHR_16bit_storage};
    #####:  613:      ArrayRef<Extension> ref(exts, std::size(exts));
call    0 never executed
    #####:  614:      extensions.push_back(ref);
call    0 never executed
        -:  615:    }
        -:  616:    break;
        -:  617:  default:
        -:  618:    break;
        -:  619:  }
        -:  620:}
        -:  621:
function _ZN4mlir5spirv10ScalarType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 7113 returned 100% blocks executed 34%
     7113:  622:void ScalarType::getCapabilities(
        -:  623:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  624:    Optional<StorageClass> storage) {
     7113:  625:  unsigned bitwidth = getIntOrFloatBitWidth();
call    0 returned 100%
        -:  626:
        -:  627:  // 8- or 16-bit integer/floating-point numbers will require extra capabilities
        -:  628:  // to appear in interface storage classes. See SPV_KHR_16bit_storage and
        -:  629:  // SPV_KHR_8bit_storage for more details.
        -:  630:
        -:  631:#define STORAGE_CASE(storage, cap8, cap16)                                     \
        -:  632:  case StorageClass::storage: {                                                \
        -:  633:    if (bitwidth == 8) {                                                       \
        -:  634:      static const Capability caps[] = {Capability::cap8};                     \
        -:  635:      ArrayRef<Capability> ref(caps, std::size(caps));                         \
        -:  636:      capabilities.push_back(ref);                                             \
        -:  637:      return;                                                                  \
        -:  638:    }                                                                          \
        -:  639:    if (bitwidth == 16) {                                                      \
        -:  640:      static const Capability caps[] = {Capability::cap16};                    \
        -:  641:      ArrayRef<Capability> ref(caps, std::size(caps));                         \
        -:  642:      capabilities.push_back(ref);                                             \
        -:  643:      return;                                                                  \
        -:  644:    }                                                                          \
        -:  645:    /* For 64-bit integers/floats, Int64/Float64 enables support for all */    \
        -:  646:    /* storage classes. Fall through to the next section. */                   \
        -:  647:  } break
        -:  648:
        -:  649:  // This part only handles the cases where special bitwidths appearing in
        -:  650:  // interface storage classes.
     7113:  651:  if (storage) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  652:    switch (*storage) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  653:      STORAGE_CASE(PushConstant, StoragePushConstant8, StoragePushConstant16);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  654:      STORAGE_CASE(StorageBuffer, StorageBuffer8BitAccess,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  655:                   StorageBuffer16BitAccess);
    #####:  656:      STORAGE_CASE(Uniform, UniformAndStorageBuffer8BitAccess,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  657:                   StorageUniform16);
    #####:  658:    case StorageClass::Input:
    #####:  659:    case StorageClass::Output: {
    #####:  660:      if (bitwidth == 16) {
branch  0 never executed
branch  1 never executed
    #####:  661:        static const Capability caps[] = {Capability::StorageInputOutput16};
    #####:  662:        ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####:  663:        capabilities.push_back(ref);
call    0 never executed
    #####:  664:        return;
        -:  665:      }
        -:  666:      break;
        -:  667:    }
        -:  668:    default:
        -:  669:      break;
        -:  670:    }
        -:  671:  }
        -:  672:#undef STORAGE_CASE
        -:  673:
        -:  674:  // For other non-interface storage classes, require a different set of
        -:  675:  // capabilities for special bitwidths.
        -:  676:
        -:  677:#define WIDTH_CASE(type, width)                                                \
        -:  678:  case width: {                                                                \
        -:  679:    static const Capability caps[] = {Capability::type##width};                \
        -:  680:    ArrayRef<Capability> ref(caps, std::size(caps));                           \
        -:  681:    capabilities.push_back(ref);                                               \
        -:  682:  } break
        -:  683:
     7113:  684:  if (auto intType = dyn_cast<IntegerType>()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
       89:  685:    switch (bitwidth) {
branch  0 taken 0%
branch  1 taken 4%
branch  2 taken 11%
branch  3 taken 0%
branch  4 taken 84%
    #####:  686:      WIDTH_CASE(Int, 8);
call    0 never executed
        4:  687:      WIDTH_CASE(Int, 16);
call    0 returned 100%
       10:  688:      WIDTH_CASE(Int, 64);
call    0 returned 100%
        -:  689:    case 1:
        -:  690:    case 32:
        -:  691:      break;
    #####:  692:    default:
    #####:  693:      llvm_unreachable("invalid bitwidth to getCapabilities");
call    0 never executed
        -:  694:    }
        -:  695:  } else {
    7024*:  696:    assert(isa<FloatType>());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
     7024:  697:    switch (bitwidth) {
branch  0 taken 47%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 53%
     3331:  698:      WIDTH_CASE(Float, 16);
call    0 returned 100%
    #####:  699:      WIDTH_CASE(Float, 64);
call    0 never executed
        -:  700:    case 32:
        -:  701:      break;
    #####:  702:    default:
    #####:  703:      llvm_unreachable("invalid bitwidth to getCapabilities");
call    0 never executed
        -:  704:    }
        -:  705:  }
        -:  706:
        -:  707:#undef WIDTH_CASE
        -:  708:}
        -:  709:
function _ZN4mlir5spirv10ScalarType14getSizeInBytesEv called 0 returned 0% blocks executed 0%
    #####:  710:Optional<int64_t> ScalarType::getSizeInBytes() {
    #####:  711:  auto bitWidth = getIntOrFloatBitWidth();
call    0 never executed
call    1 never executed
        -:  712:  // According to the SPIR-V spec:
        -:  713:  // "There is no physical size or bit pattern defined for values with boolean
        -:  714:  // type. If they are stored (in conjunction with OpVariable), they can only
        -:  715:  // be used with logical addressing operations, not physical, and only with
        -:  716:  // non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup,
        -:  717:  // Private, Function, Input, and Output."
    #####:  718:  if (bitWidth == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  719:    return llvm::None;
    #####:  720:  return bitWidth / 8;
        -:  721:}
        -:  722:
        -:  723://===----------------------------------------------------------------------===//
        -:  724:// SPIRVType
        -:  725://===----------------------------------------------------------------------===//
        -:  726:
function _ZN4mlir5spirv9SPIRVType7classofENS_4TypeE called 3026 returned 100% blocks executed 78%
     3026:  727:bool SPIRVType::classof(Type type) {
        -:  728:  // Allow SPIR-V dialect types
     3026:  729:  if (llvm::isa<SPIRVDialect>(type.getDialect()))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 47% (fallthrough)
branch  3 taken 53%
        -:  730:    return true;
     1430:  731:  if (type.isa<ScalarType>())
call    0 returned 100%
branch  1 taken 15% (fallthrough)
branch  2 taken 85%
        -:  732:    return true;
      210:  733:  if (auto vectorType = type.dyn_cast<VectorType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  734:    return CompositeType::isValid(vectorType);
call    0 never executed
        -:  735:  return false;
        -:  736:}
        -:  737:
function _ZN4mlir5spirv9SPIRVType16isScalarOrVectorEv called 0 returned 0% blocks executed 0%
    #####:  738:bool SPIRVType::isScalarOrVector() {
    #####:  739:  return isIntOrFloat() || isa<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  740:}
        -:  741:
function _ZN4mlir5spirv9SPIRVType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 1116 returned 100% blocks executed 33%
     1116:  742:void SPIRVType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -:  743:                              Optional<StorageClass> storage) {
     1116:  744:  if (auto scalarType = dyn_cast<ScalarType>()) {
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
      584:  745:    scalarType.getExtensions(extensions, storage);
call    0 returned 100%
      532:  746:  } else if (auto compositeType = dyn_cast<CompositeType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      532:  747:    compositeType.getExtensions(extensions, storage);
call    0 returned 100%
    #####:  748:  } else if (auto imageType = dyn_cast<ImageType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  749:    imageType.getExtensions(extensions, storage);
    #####:  750:  } else if (auto sampledImageType = dyn_cast<SampledImageType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  751:    sampledImageType.getExtensions(extensions, storage);
    #####:  752:  } else if (auto matrixType = dyn_cast<MatrixType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  753:    matrixType.getExtensions(extensions, storage);
call    0 never executed
    #####:  754:  } else if (auto ptrType = dyn_cast<PointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:    ptrType.getExtensions(extensions, storage);
call    0 never executed
        -:  756:  } else {
    #####:  757:    llvm_unreachable("invalid SPIR-V Type to getExtensions");
call    0 never executed
        -:  758:  }
     1116:  759:}
        -:  760:
function _ZN4mlir5spirv9SPIRVType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 1116 returned 100% blocks executed 32%
     1116:  761:void SPIRVType::getCapabilities(
        -:  762:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  763:    Optional<StorageClass> storage) {
     1116:  764:  if (auto scalarType = dyn_cast<ScalarType>()) {
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
      584:  765:    scalarType.getCapabilities(capabilities, storage);
call    0 returned 100%
      532:  766:  } else if (auto compositeType = dyn_cast<CompositeType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      532:  767:    compositeType.getCapabilities(capabilities, storage);
call    0 returned 100%
    #####:  768:  } else if (auto imageType = dyn_cast<ImageType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    imageType.getCapabilities(capabilities, storage);
call    0 never executed
    #####:  770:  } else if (auto sampledImageType = dyn_cast<SampledImageType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  771:    sampledImageType.getCapabilities(capabilities, storage);
call    0 never executed
    #####:  772:  } else if (auto matrixType = dyn_cast<MatrixType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  773:    matrixType.getCapabilities(capabilities, storage);
call    0 never executed
    #####:  774:  } else if (auto ptrType = dyn_cast<PointerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  775:    ptrType.getCapabilities(capabilities, storage);
call    0 never executed
        -:  776:  } else {
    #####:  777:    llvm_unreachable("invalid SPIR-V Type to getCapabilities");
call    0 never executed
        -:  778:  }
     1116:  779:}
        -:  780:
function _ZN4mlir5spirv9SPIRVType14getSizeInBytesEv called 0 returned 0% blocks executed 0%
    #####:  781:Optional<int64_t> SPIRVType::getSizeInBytes() {
    #####:  782:  if (auto scalarType = dyn_cast<ScalarType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  783:    return scalarType.getSizeInBytes();
call    0 never executed
    #####:  784:  if (auto compositeType = dyn_cast<CompositeType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  785:    return compositeType.getSizeInBytes();
call    0 never executed
    #####:  786:  return llvm::None;
        -:  787:}
        -:  788:
        -:  789://===----------------------------------------------------------------------===//
        -:  790:// SampledImageType
        -:  791://===----------------------------------------------------------------------===//
        -:  792:struct spirv::detail::SampledImageTypeStorage : public TypeStorage {
        -:  793:  using KeyTy = Type;
        -:  794:
    #####:  795:  SampledImageTypeStorage(const KeyTy &key) : imageType{key} {}
branch  0 never executed
branch  1 never executed
        -:  796:
    #####:  797:  bool operator==(const KeyTy &key) const { return key == KeyTy(imageType); }
        -:  798:
    #####:  799:  static SampledImageTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  800:                                            const KeyTy &key) {
    #####:  801:    return new (allocator.allocate<SampledImageTypeStorage>())
call    0 never executed
    #####:  802:        SampledImageTypeStorage(key);
branch  0 never executed
branch  1 never executed
        -:  803:  }
        -:  804:
        -:  805:  Type imageType;
        -:  806:};
        -:  807:
function _ZN4mlir5spirv16SampledImageType3getENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  808:SampledImageType SampledImageType::get(Type imageType) {
    #####:  809:  return Base::get(imageType.getContext(), imageType);
call    0 never executed
call    1 never executed
        -:  810:}
        -:  811:
        -:  812:SampledImageType
function _ZN4mlir5spirv16SampledImageType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  813:SampledImageType::getChecked(function_ref<InFlightDiagnostic()> emitError,
        -:  814:                             Type imageType) {
    #####:  815:  return Base::getChecked(emitError, imageType.getContext(), imageType);
call    0 never executed
call    1 never executed
        -:  816:}
        -:  817:
function _ZNK4mlir5spirv16SampledImageType12getImageTypeEv called 0 returned 0% blocks executed 0%
    #####:  818:Type SampledImageType::getImageType() const { return getImpl()->imageType; }
        -:  819:
        -:  820:LogicalResult
function _ZN4mlir5spirv16SampledImageType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  821:SampledImageType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:  822:                         Type imageType) {
    #####:  823:  if (!imageType.isa<ImageType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  824:    return emitError() << "expected image type";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  825:
    #####:  826:  return success();
        -:  827:}
        -:  828:
function _ZN4mlir5spirv16SampledImageType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  829:void SampledImageType::getExtensions(
        -:  830:    SPIRVType::ExtensionArrayRefVector &extensions,
        -:  831:    Optional<StorageClass> storage) {
    #####:  832:  getImageType().cast<ImageType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####:  833:}
        -:  834:
function _ZN4mlir5spirv16SampledImageType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  835:void SampledImageType::getCapabilities(
        -:  836:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -:  837:    Optional<StorageClass> storage) {
    #####:  838:  getImageType().cast<ImageType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####:  839:}
        -:  840:
        -:  841://===----------------------------------------------------------------------===//
        -:  842:// StructType
        -:  843://===----------------------------------------------------------------------===//
        -:  844:
        -:  845:/// Type storage for SPIR-V structure types:
        -:  846:///
        -:  847:/// Structures are uniqued using:
        -:  848:/// - for identified structs:
        -:  849:///   - a string identifier;
        -:  850:/// - for literal structs:
        -:  851:///   - a list of member types;
        -:  852:///   - a list of member offset info;
        -:  853:///   - a list of member decoration info.
        -:  854:///
        -:  855:/// Identified structures only have a mutable component consisting of:
        -:  856:/// - a list of member types;
        -:  857:/// - a list of member offset info;
        -:  858:/// - a list of member decoration info.
        -:  859:struct spirv::detail::StructTypeStorage : public TypeStorage {
        -:  860:  /// Construct a storage object for an identified struct type. A struct type
        -:  861:  /// associated with such storage must call StructType::trySetBody(...) later
        -:  862:  /// in order to mutate the storage object providing the actual content.
    #####:  863:  StructTypeStorage(StringRef identifier)
    #####:  864:      : memberTypesAndIsBodySet(nullptr, false), offsetInfo(nullptr),
        -:  865:        numMembers(0), numMemberDecorations(0), memberDecorationsInfo(nullptr),
    #####:  866:        identifier(identifier) {}
call    0 never executed
        -:  867:
        -:  868:  /// Construct a storage object for a literal struct type. A struct type
        -:  869:  /// associated with such storage is immutable.
    #####:  870:  StructTypeStorage(
        -:  871:      unsigned numMembers, Type const *memberTypes,
        -:  872:      StructType::OffsetInfo const *layoutInfo, unsigned numMemberDecorations,
        -:  873:      StructType::MemberDecorationInfo const *memberDecorationsInfo)
    #####:  874:      : memberTypesAndIsBodySet(memberTypes, false), offsetInfo(layoutInfo),
        -:  875:        numMembers(numMembers), numMemberDecorations(numMemberDecorations),
    #####:  876:        memberDecorationsInfo(memberDecorationsInfo) {}
call    0 never executed
        -:  877:
        -:  878:  /// A storage key is divided into 2 parts:
        -:  879:  /// - for identified structs:
        -:  880:  ///   - a StringRef representing the struct identifier;
        -:  881:  /// - for literal structs:
        -:  882:  ///   - an ArrayRef<Type> for member types;
        -:  883:  ///   - an ArrayRef<StructType::OffsetInfo> for member offset info;
        -:  884:  ///   - an ArrayRef<StructType::MemberDecorationInfo> for member decoration
        -:  885:  ///     info.
        -:  886:  ///
        -:  887:  /// An identified struct type is uniqued only by the first part (field 0)
        -:  888:  /// of the key.
        -:  889:  ///
        -:  890:  /// A literal struct type is uniqued only by the second part (fields 1, 2, and
        -:  891:  /// 3) of the key. The identifier field (field 0) must be empty.
        -:  892:  using KeyTy =
        -:  893:      std::tuple<StringRef, ArrayRef<Type>, ArrayRef<StructType::OffsetInfo>,
        -:  894:                 ArrayRef<StructType::MemberDecorationInfo>>;
        -:  895:
        -:  896:  /// For identified structs, return true if the given key contains the same
        -:  897:  /// identifier.
        -:  898:  ///
        -:  899:  /// For literal structs, return true if the given key contains a matching list
        -:  900:  /// of member types + offset info + decoration info.
function _ZNK4mlir5spirv6detail17StructTypeStorageeqERKSt5tupleIJN4llvm9StringRefENS4_8ArrayRefINS_4TypeEEENS6_IjEENS6_INS0_10StructType20MemberDecorationInfoEEEEE called 0 returned 0% blocks executed 0%
    #####:  901:  bool operator==(const KeyTy &key) const {
    #####:  902:    if (isIdentified()) {
        -:  903:      // Identified types are uniqued by their identifier.
    #####:  904:      return getIdentifier() == std::get<0>(key);
branch  0 never executed
branch  1 never executed
        -:  905:    }
        -:  906:
    #####:  907:    return key == KeyTy(StringRef(), getMemberTypes(), getOffsetInfo(),
    #####:  908:                        getMemberDecorationsInfo());
        -:  909:  }
        -:  910:
        -:  911:  /// If the given key contains a non-empty identifier, this method constructs
        -:  912:  /// an identified struct and leaves the rest of the struct type data to be set
        -:  913:  /// through a later call to StructType::trySetBody(...).
        -:  914:  ///
        -:  915:  /// If, on the other hand, the key contains an empty identifier, a literal
        -:  916:  /// struct is constructed using the other fields of the key.
function _ZN4mlir5spirv6detail17StructTypeStorage9constructERNS_14StorageUniquer16StorageAllocatorERKSt5tupleIJN4llvm9StringRefENS7_8ArrayRefINS_4TypeEEENS9_IjEENS9_INS0_10StructType20MemberDecorationInfoEEEEE called 0 returned 0% blocks executed 0%
    #####:  917:  static StructTypeStorage *construct(TypeStorageAllocator &allocator,
        -:  918:                                      const KeyTy &key) {
    #####:  919:    StringRef keyIdentifier = std::get<0>(key);
branch  0 never executed
branch  1 never executed
        -:  920:
    #####:  921:    if (!keyIdentifier.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  922:      StringRef identifier = allocator.copyInto(keyIdentifier);
call    0 never executed
        -:  923:
        -:  924:      // Identified StructType body/members will be set through trySetBody(...)
        -:  925:      // later.
    #####:  926:      return new (allocator.allocate<StructTypeStorage>())
    #####:  927:          StructTypeStorage(identifier);
call    0 never executed
call    1 never executed
        -:  928:    }
        -:  929:
    #####:  930:    ArrayRef<Type> keyTypes = std::get<1>(key);
branch  0 never executed
branch  1 never executed
        -:  931:
        -:  932:    // Copy the member type and layout information into the bump pointer
    #####:  933:    const Type *typesList = nullptr;
    #####:  934:    if (!keyTypes.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  935:      typesList = allocator.copyInto(keyTypes).data();
call    0 never executed
        -:  936:    }
        -:  937:
    #####:  938:    const StructType::OffsetInfo *offsetInfoList = nullptr;
    #####:  939:    if (!std::get<2>(key).empty()) {
branch  0 never executed
branch  1 never executed
    #####:  940:      ArrayRef<StructType::OffsetInfo> keyOffsetInfo = std::get<2>(key);
branch  0 never executed
branch  1 never executed
    #####:  941:      assert(keyOffsetInfo.size() == keyTypes.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  942:             "size of offset information must be same as the size of number of "
        -:  943:             "elements");
    #####:  944:      offsetInfoList = allocator.copyInto(keyOffsetInfo).data();
call    0 never executed
        -:  945:    }
        -:  946:
    #####:  947:    const StructType::MemberDecorationInfo *memberDecorationList = nullptr;
    #####:  948:    unsigned numMemberDecorations = 0;
    #####:  949:    if (!std::get<3>(key).empty()) {
branch  0 never executed
branch  1 never executed
    #####:  950:      auto keyMemberDecorations = std::get<3>(key);
call    0 never executed
    #####:  951:      numMemberDecorations = keyMemberDecorations.size();
call    0 never executed
    #####:  952:      memberDecorationList = allocator.copyInto(keyMemberDecorations).data();
call    0 never executed
        -:  953:    }
        -:  954:
    #####:  955:    return new (allocator.allocate<StructTypeStorage>())
    #####:  956:        StructTypeStorage(keyTypes.size(), typesList, offsetInfoList,
call    0 never executed
    #####:  957:                          numMemberDecorations, memberDecorationList);
call    0 never executed
call    1 never executed
        -:  958:  }
        -:  959:
    #####:  960:  ArrayRef<Type> getMemberTypes() const {
    #####:  961:    return ArrayRef<Type>(memberTypesAndIsBodySet.getPointer(), numMembers);
branch  0 never executed
branch  1 never executed
        -:  962:  }
        -:  963:
    #####:  964:  ArrayRef<StructType::OffsetInfo> getOffsetInfo() const {
    #####:  965:    if (offsetInfo) {
    #####:  966:      return ArrayRef<StructType::OffsetInfo>(offsetInfo, numMembers);
branch  0 never executed
branch  1 never executed
        -:  967:    }
    #####:  968:    return {};
call    0 never executed
        -:  969:  }
        -:  970:
    #####:  971:  ArrayRef<StructType::MemberDecorationInfo> getMemberDecorationsInfo() const {
    #####:  972:    if (memberDecorationsInfo) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  973:      return ArrayRef<StructType::MemberDecorationInfo>(memberDecorationsInfo,
        -:  974:                                                        numMemberDecorations);
        -:  975:    }
    #####:  976:    return {};
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  977:  }
        -:  978:
    #####:  979:  StringRef getIdentifier() const { return identifier; }
branch  0 never executed
branch  1 never executed
        -:  980:
    #####:  981:  bool isIdentified() const { return !identifier.empty(); }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  982:
        -:  983:  /// Sets the struct type content for identified structs. Calling this method
        -:  984:  /// is only valid for identified structs.
        -:  985:  ///
        -:  986:  /// Fails under the following conditions:
        -:  987:  /// - If called for a literal struct;
        -:  988:  /// - If called for an identified struct whose body was set before (through a
        -:  989:  /// call to this method) but with different contents from the passed
        -:  990:  /// arguments.
function _ZN4mlir5spirv6detail17StructTypeStorage6mutateERNS_14StorageUniquer16StorageAllocatorEN4llvm8ArrayRefINS_4TypeEEENS7_IjEENS7_INS0_10StructType20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####:  991:  LogicalResult mutate(
        -:  992:      TypeStorageAllocator &allocator, ArrayRef<Type> structMemberTypes,
        -:  993:      ArrayRef<StructType::OffsetInfo> structOffsetInfo,
        -:  994:      ArrayRef<StructType::MemberDecorationInfo> structMemberDecorationInfo) {
    #####:  995:    if (!isIdentified())
branch  0 never executed
branch  1 never executed
    #####:  996:      return failure();
        -:  997:
    #####:  998:    if (memberTypesAndIsBodySet.getInt() &&
branch  0 never executed
branch  1 never executed
    #####:  999:        (getMemberTypes() != structMemberTypes ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1000:         getOffsetInfo() != structOffsetInfo ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1001:         getMemberDecorationsInfo() != structMemberDecorationInfo))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1002:      return failure();
        -: 1003:
    #####: 1004:    memberTypesAndIsBodySet.setInt(true);
branch  0 never executed
branch  1 never executed
    #####: 1005:    numMembers = structMemberTypes.size();
branch  0 never executed
branch  1 never executed
        -: 1006:
        -: 1007:    // Copy the member type and layout information into the bump pointer.
    #####: 1008:    if (!structMemberTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 1009:      memberTypesAndIsBodySet.setPointer(
call    0 never executed
    #####: 1010:          allocator.copyInto(structMemberTypes).data());
call    0 never executed
        -: 1011:
    #####: 1012:    if (!structOffsetInfo.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1013:      assert(structOffsetInfo.size() == structMemberTypes.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1014:             "size of offset information must be same as the size of number of "
        -: 1015:             "elements");
    #####: 1016:      offsetInfo = allocator.copyInto(structOffsetInfo).data();
call    0 never executed
        -: 1017:    }
        -: 1018:
    #####: 1019:    if (!structMemberDecorationInfo.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1020:      numMemberDecorations = structMemberDecorationInfo.size();
call    0 never executed
    #####: 1021:      memberDecorationsInfo =
    #####: 1022:          allocator.copyInto(structMemberDecorationInfo).data();
call    0 never executed
        -: 1023:    }
        -: 1024:
    #####: 1025:    return success();
        -: 1026:  }
        -: 1027:
        -: 1028:  llvm::PointerIntPair<Type const *, 1, bool> memberTypesAndIsBodySet;
        -: 1029:  StructType::OffsetInfo const *offsetInfo;
        -: 1030:  unsigned numMembers;
        -: 1031:  unsigned numMemberDecorations;
        -: 1032:  StructType::MemberDecorationInfo const *memberDecorationsInfo;
        -: 1033:  StringRef identifier;
        -: 1034:};
        -: 1035:
        -: 1036:StructType
function _ZN4mlir5spirv10StructType3getEN4llvm8ArrayRefINS_4TypeEEENS3_IjEENS3_INS1_20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####: 1037:StructType::get(ArrayRef<Type> memberTypes,
        -: 1038:                ArrayRef<StructType::OffsetInfo> offsetInfo,
        -: 1039:                ArrayRef<StructType::MemberDecorationInfo> memberDecorations) {
    #####: 1040:  assert(!memberTypes.empty() && "Struct needs at least one member type");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1041:  // Sort the decorations.
    #####: 1042:  SmallVector<StructType::MemberDecorationInfo, 4> sortedDecorations(
    #####: 1043:      memberDecorations.begin(), memberDecorations.end());
call    0 never executed
    #####: 1044:  llvm::array_pod_sort(sortedDecorations.begin(), sortedDecorations.end());
branch  0 never executed
branch  1 never executed
    #####: 1045:  return Base::get(memberTypes.vec().front().getContext(),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1046:                   /*identifier=*/StringRef(), memberTypes, offsetInfo,
    #####: 1047:                   sortedDecorations);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 1048:}
        -: 1049:
function _ZN4mlir5spirv10StructType13getIdentifiedEPNS_11MLIRContextEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1050:StructType StructType::getIdentified(MLIRContext *context,
        -: 1051:                                     StringRef identifier) {
    #####: 1052:  assert(!identifier.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1053:         "StructType identifier must be non-empty string");
        -: 1054:
    #####: 1055:  return Base::get(context, identifier, ArrayRef<Type>(),
        -: 1056:                   ArrayRef<StructType::OffsetInfo>(),
    #####: 1057:                   ArrayRef<StructType::MemberDecorationInfo>());
call    0 never executed
        -: 1058:}
        -: 1059:
function _ZN4mlir5spirv10StructType8getEmptyEPNS_11MLIRContextEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1060:StructType StructType::getEmpty(MLIRContext *context, StringRef identifier) {
    #####: 1061:  StructType newStructType = Base::get(
        -: 1062:      context, identifier, ArrayRef<Type>(), ArrayRef<StructType::OffsetInfo>(),
    #####: 1063:      ArrayRef<StructType::MemberDecorationInfo>());
call    0 never executed
        -: 1064:  // Set an empty body in case this is a identified struct.
    #####: 1065:  if (newStructType.isIdentified() &&
branch  0 never executed
branch  1 never executed
    #####: 1066:      failed(newStructType.trySetBody(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1067:          ArrayRef<Type>(), ArrayRef<StructType::OffsetInfo>(),
        -: 1068:          ArrayRef<StructType::MemberDecorationInfo>())))
    #####: 1069:    return StructType();
        -: 1070:
    #####: 1071:  return newStructType;
        -: 1072:}
        -: 1073:
function _ZNK4mlir5spirv10StructType13getIdentifierEv called 0 returned 0% blocks executed 0%
    #####: 1074:StringRef StructType::getIdentifier() const { return getImpl()->identifier; }
        -: 1075:
function _ZNK4mlir5spirv10StructType12isIdentifiedEv called 0 returned 0% blocks executed 0%
    #####: 1076:bool StructType::isIdentified() const { return getImpl()->isIdentified(); }
branch  0 never executed
branch  1 never executed
        -: 1077:
function _ZNK4mlir5spirv10StructType14getNumElementsEv called 0 returned 0% blocks executed 0%
    #####: 1078:unsigned StructType::getNumElements() const { return getImpl()->numMembers; }
        -: 1079:
function _ZNK4mlir5spirv10StructType14getElementTypeEj called 0 returned 0% blocks executed 0%
    #####: 1080:Type StructType::getElementType(unsigned index) const {
    #####: 1081:  assert(getNumElements() > index && "member index out of range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1082:  return getImpl()->memberTypesAndIsBodySet.getPointer()[index];
        -: 1083:}
        -: 1084:
function _ZNK4mlir5spirv10StructType15getElementTypesEv called 0 returned 0% blocks executed 0%
    #####: 1085:StructType::ElementTypeRange StructType::getElementTypes() const {
    #####: 1086:  return ElementTypeRange(getImpl()->memberTypesAndIsBodySet.getPointer(),
    #####: 1087:                          getNumElements());
        -: 1088:}
        -: 1089:
function _ZNK4mlir5spirv10StructType9hasOffsetEv called 0 returned 0% blocks executed 0%
    #####: 1090:bool StructType::hasOffset() const { return getImpl()->offsetInfo; }
        -: 1091:
function _ZNK4mlir5spirv10StructType15getMemberOffsetEj called 0 returned 0% blocks executed 0%
    #####: 1092:uint64_t StructType::getMemberOffset(unsigned index) const {
    #####: 1093:  assert(getNumElements() > index && "member index out of range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1094:  return getImpl()->offsetInfo[index];
        -: 1095:}
        -: 1096:
function _ZNK4mlir5spirv10StructType20getMemberDecorationsERN4llvm15SmallVectorImplINS1_20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####: 1097:void StructType::getMemberDecorations(
        -: 1098:    SmallVectorImpl<StructType::MemberDecorationInfo> &memberDecorations)
        -: 1099:    const {
    #####: 1100:  memberDecorations.clear();
branch  0 never executed
branch  1 never executed
    #####: 1101:  auto implMemberDecorations = getImpl()->getMemberDecorationsInfo();
branch  0 never executed
branch  1 never executed
    #####: 1102:  memberDecorations.append(implMemberDecorations.begin(),
call    0 never executed
        -: 1103:                           implMemberDecorations.end());
    #####: 1104:}
        -: 1105:
function _ZNK4mlir5spirv10StructType20getMemberDecorationsEjRN4llvm15SmallVectorImplINS1_20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####: 1106:void StructType::getMemberDecorations(
        -: 1107:    unsigned index,
        -: 1108:    SmallVectorImpl<StructType::MemberDecorationInfo> &decorationsInfo) const {
    #####: 1109:  assert(getNumElements() > index && "member index out of range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1110:  auto memberDecorations = getImpl()->getMemberDecorationsInfo();
branch  0 never executed
branch  1 never executed
    #####: 1111:  decorationsInfo.clear();
    #####: 1112:  for (const auto &memberDecoration : memberDecorations) {
branch  0 never executed
branch  1 never executed
    #####: 1113:    if (memberDecoration.memberIndex == index) {
branch  0 never executed
branch  1 never executed
    #####: 1114:      decorationsInfo.push_back(memberDecoration);
call    0 never executed
        -: 1115:    }
    #####: 1116:    if (memberDecoration.memberIndex > index) {
branch  0 never executed
branch  1 never executed
        -: 1117:      // Early exit since the decorations are stored sorted.
    #####: 1118:      return;
        -: 1119:    }
        -: 1120:  }
        -: 1121:}
        -: 1122:
        -: 1123:LogicalResult
function _ZN4mlir5spirv10StructType10trySetBodyEN4llvm8ArrayRefINS_4TypeEEENS3_IjEENS3_INS1_20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####: 1124:StructType::trySetBody(ArrayRef<Type> memberTypes,
        -: 1125:                       ArrayRef<OffsetInfo> offsetInfo,
        -: 1126:                       ArrayRef<MemberDecorationInfo> memberDecorations) {
    #####: 1127:  return Base::mutate(memberTypes, offsetInfo, memberDecorations);
call    0 never executed
call    1 never executed
        -: 1128:}
        -: 1129:
function _ZN4mlir5spirv10StructType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####: 1130:void StructType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -: 1131:                               Optional<StorageClass> storage) {
    #####: 1132:  for (Type elementType : getElementTypes())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1133:    elementType.cast<SPIRVType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####: 1134:}
        -: 1135:
function _ZN4mlir5spirv10StructType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####: 1136:void StructType::getCapabilities(
        -: 1137:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -: 1138:    Optional<StorageClass> storage) {
    #####: 1139:  for (Type elementType : getElementTypes())
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1140:    elementType.cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####: 1141:}
        -: 1142:
function _ZN4mlir5spirv10hash_valueERKNS0_10StructType20MemberDecorationInfoE called 0 returned 0% blocks executed 0%
    #####: 1143:llvm::hash_code spirv::hash_value(
        -: 1144:    const StructType::MemberDecorationInfo &memberDecorationInfo) {
    #####: 1145:  return llvm::hash_combine(memberDecorationInfo.memberIndex,
    #####: 1146:                            memberDecorationInfo.decoration);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1147:}
        -: 1148:
        -: 1149://===----------------------------------------------------------------------===//
        -: 1150:// MatrixType
        -: 1151://===----------------------------------------------------------------------===//
        -: 1152:
        -: 1153:struct spirv::detail::MatrixTypeStorage : public TypeStorage {
    #####: 1154:  MatrixTypeStorage(Type columnType, uint32_t columnCount)
    #####: 1155:      : columnType(columnType), columnCount(columnCount) {}
branch  0 never executed
branch  1 never executed
        -: 1156:
        -: 1157:  using KeyTy = std::tuple<Type, uint32_t>;
        -: 1158:
    #####: 1159:  static MatrixTypeStorage *construct(TypeStorageAllocator &allocator,
        -: 1160:                                      const KeyTy &key) {
        -: 1161:
        -: 1162:    // Initialize the memory using placement new.
    #####: 1163:    return new (allocator.allocate<MatrixTypeStorage>())
call    0 never executed
    #####: 1164:        MatrixTypeStorage(std::get<0>(key), std::get<1>(key));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1165:  }
        -: 1166:
    #####: 1167:  bool operator==(const KeyTy &key) const {
    #####: 1168:    return key == KeyTy(columnType, columnCount);
branch  0 never executed
branch  1 never executed
        -: 1169:  }
        -: 1170:
        -: 1171:  Type columnType;
        -: 1172:  const uint32_t columnCount;
        -: 1173:};
        -: 1174:
function _ZN4mlir5spirv10MatrixType3getENS_4TypeEj called 0 returned 0% blocks executed 0%
    #####: 1175:MatrixType MatrixType::get(Type columnType, uint32_t columnCount) {
    #####: 1176:  return Base::get(columnType.getContext(), columnType, columnCount);
call    0 never executed
call    1 never executed
        -: 1177:}
        -: 1178:
function _ZN4mlir5spirv10MatrixType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeEj called 0 returned 0% blocks executed 0%
    #####: 1179:MatrixType MatrixType::getChecked(function_ref<InFlightDiagnostic()> emitError,
        -: 1180:                                  Type columnType, uint32_t columnCount) {
    #####: 1181:  return Base::getChecked(emitError, columnType.getContext(), columnType,
    #####: 1182:                          columnCount);
call    0 never executed
call    1 never executed
        -: 1183:}
        -: 1184:
function _ZN4mlir5spirv10MatrixType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS_4TypeEj called 0 returned 0% blocks executed 0%
    #####: 1185:LogicalResult MatrixType::verify(function_ref<InFlightDiagnostic()> emitError,
        -: 1186:                                 Type columnType, uint32_t columnCount) {
    #####: 1187:  if (columnCount < 2 || columnCount > 4)
branch  0 never executed
branch  1 never executed
    #####: 1188:    return emitError() << "matrix can have 2, 3, or 4 columns only";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1189:
    #####: 1190:  if (!isValidColumnType(columnType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1191:    return emitError() << "matrix columns must be vectors of floats";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1192:
        -: 1193:  /// The underlying vectors (columns) must be of size 2, 3, or 4
    #####: 1194:  ArrayRef<int64_t> columnShape = columnType.cast<VectorType>().getShape();
call    0 never executed
call    1 never executed
    #####: 1195:  if (columnShape.size() != 1)
branch  0 never executed
branch  1 never executed
    #####: 1196:    return emitError() << "matrix columns must be 1D vectors";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1197:
    #####: 1198:  if (columnShape[0] < 2 || columnShape[0] > 4)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1199:    return emitError() << "matrix columns must be of size 2, 3, or 4";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1200:
    #####: 1201:  return success();
        -: 1202:}
        -: 1203:
        -: 1204:/// Returns true if the matrix elements are vectors of float elements
function _ZN4mlir5spirv10MatrixType17isValidColumnTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 1205:bool MatrixType::isValidColumnType(Type columnType) {
    #####: 1206:  if (auto vectorType = columnType.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1207:    if (vectorType.getElementType().isa<FloatType>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1208:      return true;
        -: 1209:  }
    #####: 1210:  return false;
        -: 1211:}
        -: 1212:
function _ZNK4mlir5spirv10MatrixType13getColumnTypeEv called 0 returned 0% blocks executed 0%
    #####: 1213:Type MatrixType::getColumnType() const { return getImpl()->columnType; }
        -: 1214:
function _ZNK4mlir5spirv10MatrixType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####: 1215:Type MatrixType::getElementType() const {
    #####: 1216:  return getImpl()->columnType.cast<VectorType>().getElementType();
call    0 never executed
call    1 never executed
        -: 1217:}
        -: 1218:
function _ZNK4mlir5spirv10MatrixType13getNumColumnsEv called 0 returned 0% blocks executed 0%
    #####: 1219:unsigned MatrixType::getNumColumns() const { return getImpl()->columnCount; }
        -: 1220:
function _ZNK4mlir5spirv10MatrixType10getNumRowsEv called 0 returned 0% blocks executed 0%
    #####: 1221:unsigned MatrixType::getNumRows() const {
    #####: 1222:  return getImpl()->columnType.cast<VectorType>().getShape()[0];
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1223:}
        -: 1224:
function _ZNK4mlir5spirv10MatrixType14getNumElementsEv called 0 returned 0% blocks executed 0%
    #####: 1225:unsigned MatrixType::getNumElements() const {
    #####: 1226:  return (getImpl()->columnCount) * getNumRows();
call    0 never executed
        -: 1227:}
        -: 1228:
function _ZN4mlir5spirv10MatrixType13getExtensionsERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_9ExtensionEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####: 1229:void MatrixType::getExtensions(SPIRVType::ExtensionArrayRefVector &extensions,
        -: 1230:                               Optional<StorageClass> storage) {
    #####: 1231:  getColumnType().cast<SPIRVType>().getExtensions(extensions, storage);
call    0 never executed
call    1 never executed
    #####: 1232:}
        -: 1233:
function _ZN4mlir5spirv10MatrixType15getCapabilitiesERN4llvm15SmallVectorImplINS2_8ArrayRefINS0_10CapabilityEEEEENS2_8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####: 1234:void MatrixType::getCapabilities(
        -: 1235:    SPIRVType::CapabilityArrayRefVector &capabilities,
        -: 1236:    Optional<StorageClass> storage) {
    #####: 1237:  {
    #####: 1238:    static const Capability caps[] = {Capability::Matrix};
    #####: 1239:    ArrayRef<Capability> ref(caps, std::size(caps));
call    0 never executed
    #####: 1240:    capabilities.push_back(ref);
call    0 never executed
        -: 1241:  }
        -: 1242:  // Add any capabilities associated with the underlying vectors (i.e., columns)
    #####: 1243:  getColumnType().cast<SPIRVType>().getCapabilities(capabilities, storage);
call    0 never executed
call    1 never executed
    #####: 1244:}
        -: 1245:
        -: 1246://===----------------------------------------------------------------------===//
        -: 1247:// SPIR-V Dialect
        -: 1248://===----------------------------------------------------------------------===//
        -: 1249:
function _ZN4mlir5spirv12SPIRVDialect13registerTypesEv called 11762 returned 100% blocks executed 100%
    11762: 1250:void SPIRVDialect::registerTypes() {
    11762: 1251:  addTypes<ArrayType, CooperativeMatrixNVType, ImageType, JointMatrixINTELType,
        -: 1252:           MatrixType, PointerType, RuntimeArrayType, SampledImageType,
    11762: 1253:           StructType>();
call    0 returned 100%
    11762: 1254:}
