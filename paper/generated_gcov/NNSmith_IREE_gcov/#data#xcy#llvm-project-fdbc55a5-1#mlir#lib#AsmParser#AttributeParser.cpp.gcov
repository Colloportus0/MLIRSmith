        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/AsmParser/AttributeParser.cpp
        -:    0:Graph:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/AttributeParser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/AttributeParser.cpp.gcda
        -:    0:Runs:325595
        -:    1://===- AttributeParser.cpp - MLIR Attribute Parser Implementation ---------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the parser for the MLIR Types.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "Parser.h"
        -:   14:
        -:   15:#include "AsmParserImpl.h"
        -:   16:#include "mlir/AsmParser/AsmParserState.h"
        -:   17:#include "mlir/IR/AffineMap.h"
        -:   18:#include "mlir/IR/BuiltinAttributes.h"
        -:   19:#include "mlir/IR/BuiltinDialect.h"
        -:   20:#include "mlir/IR/BuiltinTypes.h"
        -:   21:#include "mlir/IR/DialectImplementation.h"
        -:   22:#include "mlir/IR/DialectResourceBlobManager.h"
        -:   23:#include "mlir/IR/IntegerSet.h"
        -:   24:#include "llvm/ADT/StringExtras.h"
        -:   25:#include "llvm/Support/Endian.h"
        -:   26:
        -:   27:using namespace mlir;
        -:   28:using namespace mlir::detail;
        -:   29:
        -:   30:/// Parse an arbitrary attribute.
        -:   31:///
        -:   32:///  attribute-value ::= `unit`
        -:   33:///                    | bool-literal
        -:   34:///                    | integer-literal (`:` (index-type | integer-type))?
        -:   35:///                    | float-literal (`:` float-type)?
        -:   36:///                    | string-literal (`:` type)?
        -:   37:///                    | type
        -:   38:///                    | `[` `:` (integer-type | float-type) tensor-literal `]`
        -:   39:///                    | `[` (attribute-value (`,` attribute-value)*)? `]`
        -:   40:///                    | `{` (attribute-entry (`,` attribute-entry)*)? `}`
        -:   41:///                    | symbol-ref-id (`::` symbol-ref-id)*
        -:   42:///                    | `dense` `<` tensor-literal `>` `:`
        -:   43:///                      (tensor-type | vector-type)
        -:   44:///                    | `sparse` `<` attribute-value `,` attribute-value `>`
        -:   45:///                      `:` (tensor-type | vector-type)
        -:   46:///                    | `strided` `<` `[` comma-separated-int-or-question `]`
        -:   47:///                      (`,` `offset` `:` integer-literal)? `>`
        -:   48:///                    | extended-attribute
        -:   49:///
function _ZN4mlir6detail6Parser14parseAttributeENS_4TypeE called 5804119 returned 100% blocks executed 17%
  5804119:   50:Attribute Parser::parseAttribute(Type type) {
  5804119:   51:  switch (getToken().getKind()) {
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 11%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 23%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 3%
branch 11 taken 42%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 20%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:   52:  // Parse an AffineMap or IntegerSet attribute.
    #####:   53:  case Token::kw_affine_map: {
    #####:   54:    consumeToken(Token::kw_affine_map);
call    0 never executed
        -:   55:
    #####:   56:    AffineMap map;
    #####:   57:    if (parseToken(Token::less, "expected '<' in affine map") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   58:        parseAffineMapReference(map) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   59:        parseToken(Token::greater, "expected '>' in affine map"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   60:      return Attribute();
    #####:   61:    return AffineMapAttr::get(map);
call    0 never executed
        -:   62:  }
    #####:   63:  case Token::kw_affine_set: {
    #####:   64:    consumeToken(Token::kw_affine_set);
call    0 never executed
        -:   65:
    #####:   66:    IntegerSet set;
    #####:   67:    if (parseToken(Token::less, "expected '<' in integer set") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   68:        parseIntegerSetReference(set) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   69:        parseToken(Token::greater, "expected '>' in integer set"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   70:      return Attribute();
    #####:   71:    return IntegerSetAttr::get(set);
call    0 never executed
        -:   72:  }
        -:   73:
        -:   74:  // Parse an array attribute.
   616887:   75:  case Token::l_square: {
   616887:   76:    consumeToken(Token::l_square);
call    0 returned 100%
  1233774:   77:    SmallVector<Attribute, 4> elements;
call    0 returned 100%
function _ZZN4mlir6detail6Parser14parseAttributeENS_4TypeEENKUlvE_clEv.isra.0 called 1802599 returned 100% blocks executed 83%
  2419486:   78:    auto parseElt = [&]() -> ParseResult {
  1802599:   79:      elements.push_back(parseAttribute());
call    0 returned 100%
call    1 returned 100%
  1802599:   80:      return elements.back() ? success() : failure();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   616887:   81:    };
        -:   82:
   616887:   83:    if (parseCommaSeparatedListUntil(Token::r_square, parseElt))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   84:      return nullptr;
   616887:   85:    return builder.getArrayAttr(elements);
call    0 returned 100%
        -:   86:  }
        -:   87:
        -:   88:  // Parse a boolean attribute.
    #####:   89:  case Token::kw_false:
    #####:   90:    consumeToken(Token::kw_false);
call    0 never executed
    #####:   91:    return builder.getBoolAttr(false);
call    0 never executed
    #####:   92:  case Token::kw_true:
    #####:   93:    consumeToken(Token::kw_true);
call    0 never executed
    #####:   94:    return builder.getBoolAttr(true);
call    0 never executed
        -:   95:
        -:   96:  // Parse a dense elements attribute.
  1361262:   97:  case Token::kw_dense:
  1361262:   98:    return parseDenseElementsAttr(type);
call    0 returned 100%
        -:   99:
        -:  100:  // Parse a dense resource elements attribute.
    #####:  101:  case Token::kw_dense_resource:
    #####:  102:    return parseDenseResourceElementsAttr(type);
call    0 never executed
        -:  103:
        -:  104:  // Parse a dense array attribute.
    #####:  105:  case Token::kw_array:
    #####:  106:    return parseDenseArrayAttr(type);
call    0 never executed
        -:  107:
        -:  108:  // Parse a dictionary attribute.
    #####:  109:  case Token::l_brace: {
    #####:  110:    NamedAttrList elements;
call    0 never executed
    #####:  111:    if (parseAttributeDict(elements))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  112:      return nullptr;
    #####:  113:    return elements.getDictionary(getContext());
call    0 never executed
        -:  114:  }
        -:  115:
        -:  116:  // Parse an extended attribute, i.e. alias or dialect attribute.
    #####:  117:  case Token::hash_identifier:
    #####:  118:    return parseExtendedAttr(type);
call    0 never executed
        -:  119:
        -:  120:  // Parse floating point and integer attributes.
   177448:  121:  case Token::floatliteral:
   177448:  122:    return parseFloatAttr(type, /*isNegative=*/false);
call    0 returned 100%
  2460839:  123:  case Token::integer:
  2460839:  124:    return parseDecOrHexAttr(type, /*isNegative=*/false);
call    0 returned 100%
    #####:  125:  case Token::minus: {
    #####:  126:    consumeToken(Token::minus);
call    0 never executed
    #####:  127:    if (getToken().is(Token::integer))
branch  0 never executed
branch  1 never executed
    #####:  128:      return parseDecOrHexAttr(type, /*isNegative=*/true);
call    0 never executed
    #####:  129:    if (getToken().is(Token::floatliteral))
branch  0 never executed
branch  1 never executed
    #####:  130:      return parseFloatAttr(type, /*isNegative=*/true);
call    0 never executed
        -:  131:
    #####:  132:    return (emitWrongTokenError(
        -:  133:                "expected constant integer or floating point value"),
    #####:  134:            nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  135:  }
        -:  136:
        -:  137:  // Parse a location attribute.
    #####:  138:  case Token::kw_loc: {
    #####:  139:    consumeToken(Token::kw_loc);
call    0 never executed
        -:  140:
    #####:  141:    LocationAttr locAttr;
    #####:  142:    if (parseToken(Token::l_paren, "expected '(' in inline location") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  143:        parseLocationInstance(locAttr) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  144:        parseToken(Token::r_paren, "expected ')' in inline location"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  145:      return Attribute();
    #####:  146:    return locAttr;
        -:  147:  }
        -:  148:
        -:  149:  // Parse a sparse elements attribute.
    #####:  150:  case Token::kw_sparse:
    #####:  151:    return parseSparseElementsAttr(type);
call    0 never executed
        -:  152:
        -:  153:  // Parse a strided layout attribute.
    #####:  154:  case Token::kw_strided:
    #####:  155:    return parseStridedLayoutAttr();
call    0 never executed
        -:  156:
        -:  157:  // Parse a string attribute.
  1187683:  158:  case Token::string: {
  2375366:  159:    auto val = getToken().getStringValue();
call    0 returned 100%
  1187683:  160:    consumeToken(Token::string);
call    0 returned 100%
        -:  161:    // Parse the optional trailing colon type if one wasn't explicitly provided.
 1187683*:  162:    if (!type && consumeIf(Token::colon) && !(type = parseType()))
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  163:      return Attribute();
        -:  164:
     3756:  165:    return type ? StringAttr::get(val, type)
call    0 returned 100%
call    1 returned 100%
  1191439:  166:                : StringAttr::get(getContext(), val);
branch  0 taken 1%
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
        -:  167:  }
        -:  168:
        -:  169:  // Parse a symbol reference attribute.
    #####:  170:  case Token::at_identifier: {
        -:  171:    // When populating the parser state, this is a list of locations for all of
        -:  172:    // the nested references.
    #####:  173:    SmallVector<SMRange> referenceLocations;
branch  0 never executed
branch  1 never executed
    #####:  174:    if (state.asmState)
branch  0 never executed
branch  1 never executed
    #####:  175:      referenceLocations.push_back(getToken().getLocRange());
call    0 never executed
call    1 never executed
        -:  176:
        -:  177:    // Parse the top-level reference.
    #####:  178:    std::string nameStr = getToken().getSymbolReference();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  179:    consumeToken(Token::at_identifier);
call    0 never executed
        -:  180:
        -:  181:    // Parse any nested references.
    #####:  182:    std::vector<FlatSymbolRefAttr> nestedRefs;
branch  0 never executed
branch  1 never executed
    #####:  183:    while (getToken().is(Token::colon)) {
branch  0 never executed
branch  1 never executed
        -:  184:      // Check for the '::' prefix.
    #####:  185:      const char *curPointer = getToken().getLoc().getPointer();
call    0 never executed
call    1 never executed
    #####:  186:      consumeToken(Token::colon);
call    0 never executed
    #####:  187:      if (!consumeIf(Token::colon)) {
branch  0 never executed
branch  1 never executed
    #####:  188:        if (getToken().isNot(Token::eof, Token::error)) {
branch  0 never executed
branch  1 never executed
    #####:  189:          state.lex.resetPointer(curPointer);
call    0 never executed
    #####:  190:          consumeToken();
call    0 never executed
        -:  191:        }
    #####:  192:        break;
        -:  193:      }
        -:  194:      // Parse the reference itself.
    #####:  195:      auto curLoc = getToken().getLoc();
call    0 never executed
    #####:  196:      if (getToken().isNot(Token::at_identifier)) {
branch  0 never executed
branch  1 never executed
    #####:  197:        emitError(curLoc, "expected nested symbol reference identifier");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  198:        return Attribute();
        -:  199:      }
        -:  200:
        -:  201:      // If we are populating the assembly state, add the location for this
        -:  202:      // reference.
    #####:  203:      if (state.asmState)
branch  0 never executed
branch  1 never executed
    #####:  204:        referenceLocations.push_back(getToken().getLocRange());
call    0 never executed
call    1 never executed
        -:  205:
    #####:  206:      std::string nameStr = getToken().getSymbolReference();
call    0 never executed
    #####:  207:      consumeToken(Token::at_identifier);
call    0 never executed
    #####:  208:      nestedRefs.push_back(SymbolRefAttr::get(getContext(), nameStr));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  209:    }
    #####:  210:    SymbolRefAttr symbolRefAttr =
call    0 never executed
    #####:  211:        SymbolRefAttr::get(getContext(), nameStr, nestedRefs);
call    0 never executed
        -:  212:
        -:  213:    // If we are populating the assembly state, record this symbol reference.
    #####:  214:    if (state.asmState)
branch  0 never executed
branch  1 never executed
    #####:  215:      state.asmState->addUses(symbolRefAttr, referenceLocations);
call    0 never executed
    #####:  216:    return symbolRefAttr;
        -:  217:  }
        -:  218:
        -:  219:  // Parse a 'unit' attribute.
    #####:  220:  case Token::kw_unit:
    #####:  221:    consumeToken(Token::kw_unit);
call    0 never executed
    #####:  222:    return builder.getUnitAttr();
call    0 never executed
        -:  223:
        -:  224:    // Handle completion of an attribute.
    #####:  225:  case Token::code_complete:
    #####:  226:    if (getToken().isCodeCompletionFor(Token::hash_identifier))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  227:      return parseExtendedAttr(type);
call    0 never executed
    #####:  228:    return codeCompleteAttribute();
call    0 never executed
        -:  229:
    #####:  230:  default:
        -:  231:    // Parse a type attribute. We parse `Optional` here to allow for providing a
        -:  232:    // better error message.
    #####:  233:    Type type;
    #####:  234:    OptionalParseResult result = parseOptionalType(type);
call    0 never executed
    #####:  235:    if (!result.has_value())
branch  0 never executed
branch  1 never executed
    #####:  236:      return emitWrongTokenError("expected attribute value"), Attribute();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  237:    return failed(*result) ? Attribute() : TypeAttr::get(type);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  238:  }
        -:  239:}
        -:  240:
        -:  241:/// Parse an optional attribute with the provided type.
function _ZN4mlir6detail6Parser22parseOptionalAttributeERNS_9AttributeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  242:OptionalParseResult Parser::parseOptionalAttribute(Attribute &attribute,
        -:  243:                                                   Type type) {
    #####:  244:  switch (getToken().getKind()) {
branch  0 never executed
branch  1 never executed
    #####:  245:  case Token::at_identifier:
    #####:  246:  case Token::floatliteral:
    #####:  247:  case Token::integer:
    #####:  248:  case Token::hash_identifier:
    #####:  249:  case Token::kw_affine_map:
    #####:  250:  case Token::kw_affine_set:
    #####:  251:  case Token::kw_dense:
    #####:  252:  case Token::kw_dense_resource:
    #####:  253:  case Token::kw_false:
    #####:  254:  case Token::kw_loc:
    #####:  255:  case Token::kw_sparse:
    #####:  256:  case Token::kw_true:
    #####:  257:  case Token::kw_unit:
    #####:  258:  case Token::l_brace:
    #####:  259:  case Token::l_square:
    #####:  260:  case Token::minus:
    #####:  261:  case Token::string:
    #####:  262:    attribute = parseAttribute(type);
call    0 never executed
    #####:  263:    return success(attribute != nullptr);
        -:  264:
    #####:  265:  default:
        -:  266:    // Parse an optional type attribute.
    #####:  267:    Type type;
    #####:  268:    OptionalParseResult result = parseOptionalType(type);
call    0 never executed
    #####:  269:    if (result.has_value() && succeeded(*result))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  270:      attribute = TypeAttr::get(type);
call    0 never executed
    #####:  271:    return result;
        -:  272:  }
        -:  273:}
function _ZN4mlir6detail6Parser22parseOptionalAttributeERNS_9ArrayAttrENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  274:OptionalParseResult Parser::parseOptionalAttribute(ArrayAttr &attribute,
        -:  275:                                                   Type type) {
    #####:  276:  return parseOptionalAttributeWithToken(Token::l_square, attribute, type);
call    0 never executed
        -:  277:}
function _ZN4mlir6detail6Parser22parseOptionalAttributeERNS_10StringAttrENS_4TypeE called 3756 returned 100% blocks executed 100%
     3756:  278:OptionalParseResult Parser::parseOptionalAttribute(StringAttr &attribute,
        -:  279:                                                   Type type) {
     3756:  280:  return parseOptionalAttributeWithToken(Token::string, attribute, type);
call    0 returned 100%
        -:  281:}
        -:  282:
        -:  283:/// Attribute dictionary.
        -:  284:///
        -:  285:///   attribute-dict ::= `{` `}`
        -:  286:///                    | `{` attribute-entry (`,` attribute-entry)* `}`
        -:  287:///   attribute-entry ::= (bare-id | string-literal) `=` attribute-value
        -:  288:///
function _ZN4mlir6detail6Parser18parseAttributeDictERNS_13NamedAttrListE called 3640990 returned 100% blocks executed 100%
  3640990:  289:ParseResult Parser::parseAttributeDict(NamedAttrList &attributes) {
  3640990:  290:  llvm::SmallDenseSet<StringAttr> seenKeys;
call    0 returned 100%
function _ZZN4mlir6detail6Parser18parseAttributeDictERNS_13NamedAttrListEENKUlvE_clEv called 3995886 returned 100% blocks executed 42%
  7636876:  291:  auto parseElt = [&]() -> ParseResult {
        -:  292:    // The name of an attribute can either be a bare identifier, or a string.
  3995886:  293:    Optional<StringAttr> nameId;
 3995886*:  294:    if (getToken().is(Token::string))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  295:      nameId = builder.getStringAttr(getToken().getStringValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
  4040248:  296:    else if (getToken().isAny(Token::bare_identifier, Token::inttype) ||
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    44362:  297:             getToken().isKeyword())
call    0 returned 100%
  7991772:  298:      nameId = builder.getStringAttr(getTokenSpelling());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  299:    else
    #####:  300:      return emitWrongTokenError("expected attribute name");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  301:
  3995886:  302:    if (nameId->size() == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  303:      return emitError("expected valid attribute name");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  304:
  3995886:  305:    if (!seenKeys.insert(*nameId).second)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  306:      return emitError("duplicate key '")
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  307:             << nameId->getValue() << "' in dictionary attribute";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
  3995886:  308:    consumeToken();
call    0 returned 100%
        -:  309:
        -:  310:    // Lazy load a dialect in the context if there is a possible namespace.
  3995886:  311:    auto splitName = nameId->strref().split('.');
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
  3995886:  312:    if (!splitName.second.empty())
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
  1139565:  313:      getContext()->getOrLoadDialect(splitName.first);
call    0 returned 100%
        -:  314:
        -:  315:    // Try to parse the '=' for the attribute value.
 3995886*:  316:    if (!consumeIf(Token::equal)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  317:      // If there is no '=', we treat this as a unit attribute.
    #####:  318:      attributes.push_back({*nameId, builder.getUnitAttr()});
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  319:      return success();
        -:  320:    }
        -:  321:
  3995886:  322:    auto attr = parseAttribute();
call    0 returned 100%
  3995886:  323:    if (!attr)
branch  0 taken 0%
branch  1 taken 100%
    #####:  324:      return failure();
  3995886:  325:    attributes.push_back({*nameId, attr});
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
  3995886:  326:    return success();
  3640990:  327:  };
        -:  328:
  3640990:  329:  return parseCommaSeparatedList(Delimiter::Braces, parseElt,
call    0 returned 100%
  3640990:  330:                                 " in attribute dictionary");
call    0 returned 100%
call    1 returned 100%
        -:  331:}
        -:  332:
        -:  333:/// Parse a float attribute.
function _ZN4mlir6detail6Parser14parseFloatAttrENS_4TypeEb called 177448 returned 100% blocks executed 54%
   177448:  334:Attribute Parser::parseFloatAttr(Type type, bool isNegative) {
   177448:  335:  auto val = getToken().getFloatingPointValue();
call    0 returned 100%
   177448:  336:  if (!val)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  337:    return (emitError("floating point value too large for attribute"), nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
   177448:  338:  consumeToken(Token::floatliteral);
call    0 returned 100%
   177448:  339:  if (!type) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  340:    // Default to F64 when no type is specified.
  177448*:  341:    if (!consumeIf(Token::colon))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  342:      type = builder.getF64Type();
call    0 never executed
   177448:  343:    else if (!(type = parseType()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  344:      return nullptr;
        -:  345:  }
   177448:  346:  if (!type.isa<FloatType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  347:    return (emitError("floating point value not valid for specified type"),
    #####:  348:            nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
  177448*:  349:  return FloatAttr::get(type, isNegative ? -*val : *val);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  350:}
        -:  351:
        -:  352:/// Construct an APint from a parsed value, a known attribute type and
        -:  353:/// sign.
function _ZL19buildAttributeAPIntN4mlir4TypeEbN4llvm9StringRefE called 2867177 returned 100% blocks executed 65%
  2867177:  354:static Optional<APInt> buildAttributeAPInt(Type type, bool isNegative,
        -:  355:                                           StringRef spelling) {
        -:  356:  // Parse the integer value into an APInt that is big enough to hold the value.
  2867177:  357:  APInt result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 2867177*:  358:  bool isHex = spelling.size() > 1 && spelling[1] == 'x';
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
  2867177:  359:  if (spelling.getAsInteger(isHex ? 0 : 10, result))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  360:    return llvm::None;
        -:  361:
        -:  362:  // Extend or truncate the bitwidth to the right size.
  2867177:  363:  unsigned width = type.isIndex() ? IndexType::kInternalStorageBitWidth
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2867177:  364:                                  : type.getIntOrFloatBitWidth();
call    0 returned 100%
        -:  365:
  2867177:  366:  if (width > result.getBitWidth()) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
  1713781:  367:    result = result.zext(width);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  1153396:  368:  } else if (width < result.getBitWidth()) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -:  369:    // The parser can return an unnecessarily wide result with leading zeros.
        -:  370:    // This isn't a problem, but truncating off bits is bad.
   754320:  371:    if (result.countLeadingZeros() < result.getBitWidth() - width)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  372:      return llvm::None;
        -:  373:
   754320:  374:    result = result.trunc(width);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  375:  }
        -:  376:
  2867177:  377:  if (width == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  378:    // 0 bit integers cannot be negative and manipulation of their sign bit will
        -:  379:    // assert, so short-cut validation here.
    #####:  380:    if (isNegative)
branch  0 never executed
branch  1 never executed
    #####:  381:      return llvm::None;
  2867177:  382:  } else if (isNegative) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  383:    // The value is negative, we have an overflow if the sign bit is not set
        -:  384:    // in the negated apInt.
     1648:  385:    result.negate();
call    0 returned 100%
     1648:  386:    if (!result.isSignBitSet())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  387:      return llvm::None;
 2865529*:  388:  } else if ((type.isSignedInteger() || type.isIndex()) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  389:             result.isSignBitSet()) {
branch  0 never executed
branch  1 never executed
        -:  390:    // The value is a positive signed integer or index,
        -:  391:    // we have an overflow if the sign bit is set.
    #####:  392:    return llvm::None;
        -:  393:  }
        -:  394:
  2867177:  395:  return result;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  396:}
        -:  397:
        -:  398:/// Parse a decimal or a hexadecimal literal, which can be either an integer
        -:  399:/// or a float attribute.
function _ZN4mlir6detail6Parser17parseDecOrHexAttrENS_4TypeEb called 2460839 returned 100% blocks executed 44%
  2460839:  400:Attribute Parser::parseDecOrHexAttr(Type type, bool isNegative) {
  2460839:  401:  Token tok = getToken();
call    0 returned 100%
  2460839:  402:  StringRef spelling = tok.getSpelling();
call    0 returned 100%
  2460839:  403:  SMLoc loc = tok.getLoc();
call    0 returned 100%
        -:  404:
  2460839:  405:  consumeToken(Token::integer);
call    0 returned 100%
  2460839:  406:  if (!type) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  407:    // Default to i64 if not type is specified.
  2458961:  408:    if (!consumeIf(Token::colon))
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
  1625151:  409:      type = builder.getIntegerType(64);
call    0 returned 100%
   833810:  410:    else if (!(type = parseType()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  411:      return nullptr;
        -:  412:  }
        -:  413:
  2460839:  414:  if (auto floatType = type.dyn_cast<FloatType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  415:    Optional<APFloat> result;
    #####:  416:    if (failed(parseFloatFromIntegerLiteral(result, tok, isNegative,
branch  0 never executed
branch  1 never executed
        -:  417:                                            floatType.getFloatSemantics(),
    #####:  418:                                            floatType.getWidth())))
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  419:      return Attribute();
    #####:  420:    return FloatAttr::get(floatType, *result);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  421:  }
        -:  422:
  2460839:  423:  if (!type.isa<IntegerType, IndexType>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  424:    return emitError(loc, "integer literal not valid for specified type"),
    #####:  425:           nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -:  426:
 2460839*:  427:  if (isNegative && type.isUnsignedInteger()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  428:    emitError(loc,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  429:              "negative integer literal not valid for unsigned integer type");
    #####:  430:    return nullptr;
        -:  431:  }
        -:  432:
  2460839:  433:  Optional<APInt> apInt = buildAttributeAPInt(type, isNegative, spelling);
call    0 returned 100%
  2460839:  434:  if (!apInt)
branch  0 taken 0%
branch  1 taken 100%
    #####:  435:    return emitError(loc, "integer constant out of range for attribute"),
    #####:  436:           nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
  2460839:  437:  return builder.getIntegerAttr(type, *apInt);
call    0 returned 100%
        -:  438:}
        -:  439:
        -:  440://===----------------------------------------------------------------------===//
        -:  441:// TensorLiteralParser
        -:  442://===----------------------------------------------------------------------===//
        -:  443:
        -:  444:/// Parse elements values stored within a hex string. On success, the values are
        -:  445:/// stored into 'result'.
function _ZL25parseElementAttrHexValuesRN4mlir6detail6ParserENS_5TokenERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 132563 returned 100% blocks executed 47%
   132563:  446:static ParseResult parseElementAttrHexValues(Parser &parser, Token tok,
        -:  447:                                             std::string &result) {
  132563*:  448:  if (Optional<std::string> value = tok.getHexStringValue()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   132563:  449:    result = std::move(*value);
call    0 returned 100%
   132563:  450:    return success();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  451:  }
    #####:  452:  return parser.emitError(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  453:      tok.getLoc(), "expected string containing hex digits starting with `0x`");
call    0 never executed
        -:  454:}
        -:  455:
        -:  456:namespace {
        -:  457:/// This class implements a parser for TensorLiterals. A tensor literal is
        -:  458:/// either a single element (e.g, 5) or a multi-dimensional list of elements
        -:  459:/// (e.g., [[5, 5]]).
        -:  460:class TensorLiteralParser {
        -:  461:public:
 1361262*:  462:  TensorLiteralParser(Parser &p) : p(p) {}
        -:  463:
        -:  464:  /// Parse the elements of a tensor literal. If 'allowHex' is true, the parser
        -:  465:  /// may also parse a tensor literal that is store as a hex string.
        -:  466:  ParseResult parse(bool allowHex);
        -:  467:
        -:  468:  /// Build a dense attribute instance with the parsed elements and the given
        -:  469:  /// shaped type.
        -:  470:  DenseElementsAttr getAttr(SMLoc loc, ShapedType type);
        -:  471:
    #####:  472:  ArrayRef<int64_t> getShape() const { return shape; }
call    0 never executed
call    1 never executed
        -:  473:
        -:  474:private:
        -:  475:  /// Get the parsed elements for an integer attribute.
        -:  476:  ParseResult getIntAttrElements(SMLoc loc, Type eltTy,
        -:  477:                                 std::vector<APInt> &intValues);
        -:  478:
        -:  479:  /// Get the parsed elements for a float attribute.
        -:  480:  ParseResult getFloatAttrElements(SMLoc loc, FloatType eltTy,
        -:  481:                                   std::vector<APFloat> &floatValues);
        -:  482:
        -:  483:  /// Build a Dense String attribute for the given type.
        -:  484:  DenseElementsAttr getStringAttr(SMLoc loc, ShapedType type, Type eltTy);
        -:  485:
        -:  486:  /// Build a Dense attribute with hex data for the given type.
        -:  487:  DenseElementsAttr getHexAttr(SMLoc loc, ShapedType type);
        -:  488:
        -:  489:  /// Parse a single element, returning failure if it isn't a valid element
        -:  490:  /// literal. For example:
        -:  491:  /// parseElement(1) -> Success, 1
        -:  492:  /// parseElement([1]) -> Failure
        -:  493:  ParseResult parseElement();
        -:  494:
        -:  495:  /// Parse a list of either lists or elements, returning the dimensions of the
        -:  496:  /// parsed sub-tensors in dims. For example:
        -:  497:  ///   parseList([1, 2, 3]) -> Success, [3]
        -:  498:  ///   parseList([[1, 2], [3, 4]]) -> Success, [2, 2]
        -:  499:  ///   parseList([[1, 2], 3]) -> Failure
        -:  500:  ///   parseList([[1, [2, 3]], [4, [5]]]) -> Failure
        -:  501:  ParseResult parseList(SmallVectorImpl<int64_t> &dims);
        -:  502:
        -:  503:  /// Parse a literal that was printed as a hex string.
        -:  504:  ParseResult parseHexElements();
        -:  505:
        -:  506:  Parser &p;
        -:  507:
        -:  508:  /// The shape inferred from the parsed elements.
        -:  509:  SmallVector<int64_t, 4> shape;
        -:  510:
        -:  511:  /// Storage used when parsing elements, this is a pair of <is_negated, token>.
        -:  512:  std::vector<std::pair<bool, Token>> storage;
        -:  513:
        -:  514:  /// Storage used when parsing elements that were stored as hex values.
        -:  515:  Optional<Token> hexStorage;
        -:  516:};
        -:  517:} // namespace
        -:  518:
        -:  519:/// Parse the elements of a tensor literal. If 'allowHex' is true, the parser
        -:  520:/// may also parse a tensor literal that is store as a hex string.
function _ZN12_GLOBAL__N_119TensorLiteralParser5parseEb called 1361262 returned 100% blocks executed 91%
  1361262:  521:ParseResult TensorLiteralParser::parse(bool allowHex) {
        -:  522:  // If hex is allowed, check for a string literal.
  1361262:  523:  if (allowHex && p.getToken().is(Token::string)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
   132563:  524:    hexStorage = p.getToken();
branch  0 taken 0%
branch  1 taken 100%
   132563:  525:    p.consumeToken(Token::string);
call    0 returned 100%
   132563:  526:    return success();
        -:  527:  }
        -:  528:  // Otherwise, parse a list or an individual element.
  1228699:  529:  if (p.getToken().is(Token::l_square))
branch  0 taken 20%
branch  1 taken 80%
   246085:  530:    return parseList(shape);
call    0 returned 100%
   982614:  531:  return parseElement();
call    0 returned 100%
        -:  532:}
        -:  533:
        -:  534:/// Build a dense attribute instance with the parsed elements and the given
        -:  535:/// shaped type.
function _ZN12_GLOBAL__N_119TensorLiteralParser7getAttrEN4llvm5SMLocEN4mlir10ShapedTypeE called 1361262 returned 100% blocks executed 51%
  1361262:  536:DenseElementsAttr TensorLiteralParser::getAttr(SMLoc loc, ShapedType type) {
  1361262:  537:  Type eltType = type.getElementType();
call    0 returned 100%
        -:  538:
        -:  539:  // Check to see if we parse the literal from a hex string.
   132563:  540:  if (hexStorage &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 1361262*:  541:      (eltType.isIntOrIndexOrFloat() || eltType.isa<ComplexType>()))
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
branch  3 never executed
branch  4 never executed
   132563:  542:    return getHexAttr(loc, type);
call    0 returned 100%
        -:  543:
        -:  544:  // Check that the parsed storage size has the same number of elements to the
        -:  545:  // type, or is a known splat.
  1228699:  546:  if (!shape.empty() && getShape() != type.getShape()) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####:  547:    p.emitError(loc) << "inferred shape of elements literal ([" << getShape()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  548:                     << "]) does not match type ([" << type.getShape() << "])";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  549:    return nullptr;
        -:  550:  }
        -:  551:
        -:  552:  // Handle the case where no elements were parsed.
 1228699*:  553:  if (!hexStorage && storage.empty() && type.getNumElements()) {
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  554:    p.emitError(loc) << "parsed zero elements, but type (" << type
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  555:                     << ") expected at least 1";
call    0 never executed
    #####:  556:    return nullptr;
        -:  557:  }
        -:  558:
        -:  559:  // Handle complex types in the specific element type cases below.
  1228699:  560:  bool isComplex = false;
  1228699:  561:  if (ComplexType complexTy = eltType.dyn_cast<ComplexType>()) {
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100%
    #####:  562:    eltType = complexTy.getElementType();
    #####:  563:    isComplex = true;
call    0 never executed
        -:  564:  }
        -:  565:
        -:  566:  // Handle integer and index types.
  1228699:  567:  if (eltType.isIntOrIndex()) {
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
   193730:  568:    std::vector<APInt> intValues;
call    0 returned 100%
call    1 returned 100%
    96865:  569:    if (failed(getIntAttrElements(loc, eltType, intValues)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  570:      return nullptr;
    96865:  571:    if (isComplex) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  572:      // If this is a complex, treat the parsed values as complex values.
    #####:  573:      auto complexData = llvm::makeArrayRef(
    #####:  574:          reinterpret_cast<std::complex<APInt> *>(intValues.data()),
call    0 never executed
    #####:  575:          intValues.size() / 2);
call    0 never executed
    #####:  576:      return DenseElementsAttr::get(type, complexData);
call    0 never executed
        -:  577:    }
    96865:  578:    return DenseElementsAttr::get(type, intValues);
call    0 returned 100%
        -:  579:  }
        -:  580:  // Handle floating point types.
  1131834:  581:  if (FloatType floatTy = eltType.dyn_cast<FloatType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  2263668:  582:    std::vector<APFloat> floatValues;
call    0 returned 100%
call    1 returned 100%
  1131834:  583:    if (failed(getFloatAttrElements(loc, floatTy, floatValues)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  584:      return nullptr;
  1131834:  585:    if (isComplex) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  586:      // If this is a complex, treat the parsed values as complex values.
    #####:  587:      auto complexData = llvm::makeArrayRef(
    #####:  588:          reinterpret_cast<std::complex<APFloat> *>(floatValues.data()),
call    0 never executed
    #####:  589:          floatValues.size() / 2);
call    0 never executed
    #####:  590:      return DenseElementsAttr::get(type, complexData);
call    0 never executed
        -:  591:    }
  1131834:  592:    return DenseElementsAttr::get(type, floatValues);
call    0 returned 100%
        -:  593:  }
        -:  594:
        -:  595:  // Other types are assumed to be string representations.
    #####:  596:  return getStringAttr(loc, type, type.getElementType());
call    0 never executed
call    1 never executed
        -:  597:}
        -:  598:
        -:  599:/// Build a Dense Integer attribute for the given type.
        -:  600:ParseResult
        -:  601:TensorLiteralParser::getIntAttrElements(SMLoc loc, Type eltTy,
        -:  602:                                        std::vector<APInt> &intValues) {
        -:  603:  intValues.reserve(storage.size());
        -:  604:  bool isUintType = eltTy.isUnsignedInteger();
        -:  605:  for (const auto &signAndToken : storage) {
        -:  606:    bool isNegative = signAndToken.first;
        -:  607:    const Token &token = signAndToken.second;
        -:  608:    auto tokenLoc = token.getLoc();
        -:  609:
        -:  610:    if (isNegative && isUintType) {
        -:  611:      return p.emitError(tokenLoc)
        -:  612:             << "expected unsigned integer elements, but parsed negative value";
        -:  613:    }
        -:  614:
        -:  615:    // Check to see if floating point values were parsed.
        -:  616:    if (token.is(Token::floatliteral)) {
        -:  617:      return p.emitError(tokenLoc)
        -:  618:             << "expected integer elements, but parsed floating-point";
        -:  619:    }
        -:  620:
        -:  621:    assert(token.isAny(Token::integer, Token::kw_true, Token::kw_false) &&
        -:  622:           "unexpected token type");
        -:  623:    if (token.isAny(Token::kw_true, Token::kw_false)) {
        -:  624:      if (!eltTy.isInteger(1)) {
        -:  625:        return p.emitError(tokenLoc)
        -:  626:               << "expected i1 type for 'true' or 'false' values";
        -:  627:      }
        -:  628:      APInt apInt(1, token.is(Token::kw_true), /*isSigned=*/false);
        -:  629:      intValues.push_back(apInt);
        -:  630:      continue;
        -:  631:    }
        -:  632:
        -:  633:    // Create APInt values for each element with the correct bitwidth.
        -:  634:    Optional<APInt> apInt =
        -:  635:        buildAttributeAPInt(eltTy, isNegative, token.getSpelling());
        -:  636:    if (!apInt)
        -:  637:      return p.emitError(tokenLoc, "integer constant out of range for type");
        -:  638:    intValues.push_back(*apInt);
        -:  639:  }
        -:  640:  return success();
        -:  641:}
        -:  642:
        -:  643:/// Build a Dense Float attribute for the given type.
        -:  644:ParseResult
        -:  645:TensorLiteralParser::getFloatAttrElements(SMLoc loc, FloatType eltTy,
        -:  646:                                          std::vector<APFloat> &floatValues) {
        -:  647:  floatValues.reserve(storage.size());
        -:  648:  for (const auto &signAndToken : storage) {
        -:  649:    bool isNegative = signAndToken.first;
        -:  650:    const Token &token = signAndToken.second;
        -:  651:
        -:  652:    // Handle hexadecimal float literals.
        -:  653:    if (token.is(Token::integer) && token.getSpelling().startswith("0x")) {
        -:  654:      Optional<APFloat> result;
        -:  655:      if (failed(p.parseFloatFromIntegerLiteral(result, token, isNegative,
        -:  656:                                                eltTy.getFloatSemantics(),
        -:  657:                                                eltTy.getWidth())))
        -:  658:        return failure();
        -:  659:
        -:  660:      floatValues.push_back(*result);
        -:  661:      continue;
        -:  662:    }
        -:  663:
        -:  664:    // Check to see if any decimal integers or booleans were parsed.
        -:  665:    if (!token.is(Token::floatliteral))
        -:  666:      return p.emitError()
        -:  667:             << "expected floating-point elements, but parsed integer";
        -:  668:
        -:  669:    // Build the float values from tokens.
        -:  670:    auto val = token.getFloatingPointValue();
        -:  671:    if (!val)
        -:  672:      return p.emitError("floating point value too large for attribute");
        -:  673:
        -:  674:    APFloat apVal(isNegative ? -*val : *val);
        -:  675:    if (!eltTy.isF64()) {
        -:  676:      bool unused;
        -:  677:      apVal.convert(eltTy.getFloatSemantics(), APFloat::rmNearestTiesToEven,
        -:  678:                    &unused);
        -:  679:    }
        -:  680:    floatValues.push_back(apVal);
        -:  681:  }
        -:  682:  return success();
        -:  683:}
        -:  684:
        -:  685:/// Build a Dense String attribute for the given type.
        -:  686:DenseElementsAttr TensorLiteralParser::getStringAttr(SMLoc loc, ShapedType type,
        -:  687:                                                     Type eltTy) {
        -:  688:  if (hexStorage.has_value()) {
        -:  689:    auto stringValue = hexStorage.value().getStringValue();
        -:  690:    return DenseStringElementsAttr::get(type, {stringValue});
        -:  691:  }
        -:  692:
        -:  693:  std::vector<std::string> stringValues;
        -:  694:  std::vector<StringRef> stringRefValues;
        -:  695:  stringValues.reserve(storage.size());
        -:  696:  stringRefValues.reserve(storage.size());
        -:  697:
        -:  698:  for (auto val : storage) {
        -:  699:    stringValues.push_back(val.second.getStringValue());
        -:  700:    stringRefValues.emplace_back(stringValues.back());
        -:  701:  }
        -:  702:
        -:  703:  return DenseStringElementsAttr::get(type, stringRefValues);
        -:  704:}
        -:  705:
        -:  706:/// Build a Dense attribute with hex data for the given type.
function _ZN12_GLOBAL__N_119TensorLiteralParser10getHexAttrEN4llvm5SMLocEN4mlir10ShapedTypeE called 132563 returned 100% blocks executed 47%
   132563:  707:DenseElementsAttr TensorLiteralParser::getHexAttr(SMLoc loc, ShapedType type) {
   132563:  708:  Type elementType = type.getElementType();
call    0 returned 100%
  132563*:  709:  if (!elementType.isIntOrIndexOrFloat() && !elementType.isa<ComplexType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 never executed
branch  4 never executed
    #####:  710:    p.emitError(loc)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  711:        << "expected floating-point, integer, or complex element type, got "
call    0 never executed
    #####:  712:        << elementType;
call    0 never executed
    #####:  713:    return nullptr;
        -:  714:  }
        -:  715:
   132563:  716:  std::string data;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   132563:  717:  if (parseElementAttrHexValues(p, *hexStorage, data))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  718:    return nullptr;
        -:  719:
   132563:  720:  ArrayRef<char> rawData(data.data(), data.size());
call    0 returned 100%
   132563:  721:  bool detectedSplat = false;
   132563:  722:  if (!DenseElementsAttr::isValidRawBuffer(type, rawData, detectedSplat)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  723:    p.emitError(loc) << "elements hex data size is invalid for provided type: "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  724:                     << type;
call    0 never executed
    #####:  725:    return nullptr;
        -:  726:  }
        -:  727:
   132563:  728:  if (llvm::support::endian::system_endianness() ==
        -:  729:      llvm::support::endianness::big) {
        -:  730:    // Convert endianess in big-endian(BE) machines. `rawData` is
        -:  731:    // little-endian(LE) because HEX in raw data of dense element attribute
        -:  732:    // is always LE format. It is converted into BE here to be used in BE
        -:  733:    // machines.
        -:  734:    SmallVector<char, 64> outDataVec(rawData.size());
        -:  735:    MutableArrayRef<char> convRawData(outDataVec);
        -:  736:    DenseIntOrFPElementsAttr::convertEndianOfArrayRefForBEmachine(
        -:  737:        rawData, convRawData, type);
        -:  738:    return DenseElementsAttr::getFromRawBuffer(type, convRawData);
        -:  739:  }
        -:  740:
   132563:  741:  return DenseElementsAttr::getFromRawBuffer(type, rawData);
call    0 returned 100%
        -:  742:}
        -:  743:
function _ZN12_GLOBAL__N_119TensorLiteralParser12parseElementEv called 1920484 returned 100% blocks executed 32%
  1920484:  744:ParseResult TensorLiteralParser::parseElement() {
  1920484:  745:  switch (p.getToken().getKind()) {
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
        -:  746:  // Parse a boolean element.
  1917781:  747:  case Token::kw_true:
  1917781:  748:  case Token::kw_false:
  1917781:  749:  case Token::floatliteral:
  1917781:  750:  case Token::integer:
  1917781:  751:    storage.emplace_back(/*isNegative=*/false, p.getToken());
call    0 returned 100%
  1917781:  752:    p.consumeToken();
  1917781:  753:    break;
call    0 returned 100%
        -:  754:
        -:  755:  // Parse a signed integer or a negative floating-point element.
     2703:  756:  case Token::minus:
     2703:  757:    p.consumeToken(Token::minus);
call    0 returned 100%
    2703*:  758:    if (!p.getToken().isAny(Token::floatliteral, Token::integer))
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
    #####:  759:      return p.emitError("expected integer or floating point literal");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
     2703:  760:    storage.emplace_back(/*isNegative=*/true, p.getToken());
call    0 returned 100%
     2703:  761:    p.consumeToken();
     2703:  762:    break;
call    0 returned 100%
        -:  763:
    #####:  764:  case Token::string:
    #####:  765:    storage.emplace_back(/*isNegative=*/false, p.getToken());
call    0 never executed
    #####:  766:    p.consumeToken();
    #####:  767:    break;
call    0 never executed
        -:  768:
        -:  769:  // Parse a complex element of the form '(' element ',' element ')'.
    #####:  770:  case Token::l_paren:
    #####:  771:    p.consumeToken(Token::l_paren);
call    0 never executed
    #####:  772:    if (parseElement() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  773:        p.parseToken(Token::comma, "expected ',' between complex elements") ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  774:        parseElement() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  775:        p.parseToken(Token::r_paren, "expected ')' after complex elements"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  776:      return failure();
        -:  777:    break;
        -:  778:
    #####:  779:  default:
    #####:  780:    return p.emitError("expected element literal of primitive type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  781:  }
        -:  782:
  1920484:  783:  return success();
        -:  784:}
        -:  785:
        -:  786:/// Parse a list of either lists or elements, returning the dimensions of the
        -:  787:/// parsed sub-tensors in dims. For example:
        -:  788:///   parseList([1, 2, 3]) -> Success, [3]
        -:  789:///   parseList([[1, 2], [3, 4]]) -> Success, [2, 2]
        -:  790:///   parseList([[1, 2], 3]) -> Failure
        -:  791:///   parseList([[1, [2, 3]], [4, [5]]]) -> Failure
function _ZN12_GLOBAL__N_119TensorLiteralParser9parseListERN4llvm15SmallVectorImplIlEE called 1292245 returned 100% blocks executed 78%
  1292245:  792:ParseResult TensorLiteralParser::parseList(SmallVectorImpl<int64_t> &dims) {
function _ZZN12_GLOBAL__N_119TensorLiteralParser9parseListERN4llvm15SmallVectorImplIlEEENKUlRKS3_S6_E_clES6_S6_.isra.0 called 691785 returned 100% blocks executed 38%
  1984030:  793:  auto checkDims = [&](const SmallVectorImpl<int64_t> &prevDims,
        -:  794:                       const SmallVectorImpl<int64_t> &newDims) -> ParseResult {
   691785:  795:    if (prevDims == newDims)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   691785:  796:      return success();
    #####:  797:    return p.emitError("tensor literal is invalid; ranks are not consistent "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  798:                       "between elements");
call    0 never executed
  1292245:  799:  };
        -:  800:
  1292245:  801:  bool first = true;
  1292245:  802:  SmallVector<int64_t, 4> newDims;
call    0 returned 100%
  1292245:  803:  unsigned size = 0;
function _ZZN12_GLOBAL__N_119TensorLiteralParser9parseListERN4llvm15SmallVectorImplIlEEENKUlvE0_clEv called 1984030 returned 100% blocks executed 79%
  3276275:  804:  auto parseOneElement = [&]() -> ParseResult {
  1984030:  805:    SmallVector<int64_t, 4> thisDims;
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
  1984030:  806:    if (p.getToken().getKind() == Token::l_square) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
  1046160:  807:      if (parseList(thisDims))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  808:        return failure();
   937870:  809:    } else if (parseElement()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  810:      return failure();
        -:  811:    }
  1984030:  812:    ++size;
  1984030:  813:    if (!first)
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
   691785:  814:      return checkDims(newDims, thisDims);
call    0 returned 100%
  1292245:  815:    newDims = thisDims;
call    0 returned 100%
  1292245:  816:    first = false;
  1292245:  817:    return success();
  1292245:  818:  };
  1292245:  819:  if (p.parseCommaSeparatedList(Parser::Delimiter::Square, parseOneElement))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  820:    return failure();
        -:  821:
        -:  822:  // Return the sublists' dimensions with 'size' prepended.
  1292245:  823:  dims.clear();
call    0 returned 100%
  1292245:  824:  dims.push_back(size);
call    0 returned 100%
  1292245:  825:  dims.append(newDims.begin(), newDims.end());
call    0 returned 100%
  1292245:  826:  return success();
        -:  827:}
        -:  828:
        -:  829://===----------------------------------------------------------------------===//
        -:  830:// DenseArrayAttr Parser
        -:  831://===----------------------------------------------------------------------===//
        -:  832:
        -:  833:namespace {
        -:  834:/// A generic dense array element parser. It parsers integer and floating point
        -:  835:/// elements.
    #####:  836:class DenseArrayElementParser {
branch  0 never executed
branch  1 never executed
        -:  837:public:
    #####:  838:  explicit DenseArrayElementParser(Type type) : type(type) {}
        -:  839:
        -:  840:  /// Parse an integer element.
        -:  841:  ParseResult parseIntegerElement(Parser &p);
        -:  842:
        -:  843:  /// Parse a floating point element.
        -:  844:  ParseResult parseFloatElement(Parser &p);
        -:  845:
        -:  846:  /// Convert the current contents to a dense array.
function _ZN12_GLOBAL__N_123DenseArrayElementParser7getAttrEv called 0 returned 0% blocks executed 0%
    #####:  847:  DenseArrayAttr getAttr() {
    #####:  848:    return DenseArrayAttr::get(RankedTensorType::get(size, type), rawData);
call    0 never executed
call    1 never executed
        -:  849:  }
        -:  850:
        -:  851:private:
        -:  852:  /// Append the raw data of an APInt to the result.
        -:  853:  void append(const APInt &data);
        -:  854:
        -:  855:  /// The array element type.
        -:  856:  Type type;
        -:  857:  /// The resultant byte array representing the contents of the array.
        -:  858:  std::vector<char> rawData;
        -:  859:  /// The number of elements in the array.
        -:  860:  int64_t size = 0;
        -:  861:};
        -:  862:} // namespace
        -:  863:
function _ZN12_GLOBAL__N_123DenseArrayElementParser6appendERKN4llvm5APIntE called 0 returned 0% blocks executed 0%
    #####:  864:void DenseArrayElementParser::append(const APInt &data) {
    #####:  865:  if (data.getBitWidth()) {
branch  0 never executed
branch  1 never executed
    #####:  866:    assert(data.getBitWidth() % 8 == 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  867:    unsigned byteSize = data.getBitWidth() / 8;
call    0 never executed
    #####:  868:    size_t offset = rawData.size();
call    0 never executed
    #####:  869:    rawData.insert(rawData.end(), byteSize, 0);
call    0 never executed
    #####:  870:    llvm::StoreIntToMemory(
    #####:  871:        data, reinterpret_cast<uint8_t *>(rawData.data() + offset), byteSize);
call    0 never executed
        -:  872:  }
    #####:  873:  ++size;
    #####:  874:}
        -:  875:
function _ZN12_GLOBAL__N_123DenseArrayElementParser19parseIntegerElementERN4mlir6detail6ParserE called 0 returned 0% blocks executed 0%
    #####:  876:ParseResult DenseArrayElementParser::parseIntegerElement(Parser &p) {
    #####:  877:  bool isNegative = p.consumeIf(Token::minus);
branch  0 never executed
branch  1 never executed
        -:  878:
        -:  879:  // Parse an integer literal as an APInt.
    #####:  880:  Optional<APInt> value;
    #####:  881:  StringRef spelling = p.getToken().getSpelling();
branch  0 never executed
branch  1 never executed
    #####:  882:  if (p.getToken().isAny(Token::kw_true, Token::kw_false)) {
branch  0 never executed
branch  1 never executed
    #####:  883:    if (!type.isInteger(1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  884:      return p.emitError("expected i1 type for 'true' or 'false' values");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  885:    value = APInt(/*numBits=*/8, p.getToken().is(Token::kw_true),
call    0 never executed
call    1 never executed
    #####:  886:                  !type.isUnsignedInteger());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  887:    p.consumeToken();
call    0 never executed
    #####:  888:  } else if (p.consumeIf(Token::integer)) {
branch  0 never executed
branch  1 never executed
    #####:  889:    value = buildAttributeAPInt(type, isNegative, spelling);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  890:    if (!value)
branch  0 never executed
branch  1 never executed
    #####:  891:      return p.emitError("integer constant out of range");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  892:  } else {
    #####:  893:    return p.emitError("expected integer literal");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  894:  }
    #####:  895:  append(*value);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:  return success();
        -:  897:}
        -:  898:
function _ZN12_GLOBAL__N_123DenseArrayElementParser17parseFloatElementERN4mlir6detail6ParserE called 0 returned 0% blocks executed 0%
    #####:  899:ParseResult DenseArrayElementParser::parseFloatElement(Parser &p) {
    #####:  900:  bool isNegative = p.consumeIf(Token::minus);
branch  0 never executed
branch  1 never executed
        -:  901:
    #####:  902:  Token token = p.getToken();
call    0 never executed
    #####:  903:  Optional<APFloat> result;
    #####:  904:  auto floatType = type.cast<FloatType>();
call    0 never executed
    #####:  905:  if (p.consumeIf(Token::integer)) {
branch  0 never executed
branch  1 never executed
        -:  906:    // Parse an integer literal as a float.
    #####:  907:    if (p.parseFloatFromIntegerLiteral(result, token, isNegative,
branch  0 never executed
branch  1 never executed
        -:  908:                                       floatType.getFloatSemantics(),
    #####:  909:                                       floatType.getWidth()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  910:      return failure();
    #####:  911:  } else if (p.consumeIf(Token::floatliteral)) {
branch  0 never executed
branch  1 never executed
        -:  912:    // Parse a floating point literal.
    #####:  913:    Optional<double> val = token.getFloatingPointValue();
call    0 never executed
    #####:  914:    if (!val)
branch  0 never executed
branch  1 never executed
    #####:  915:      return failure();
    #####:  916:    result = APFloat(isNegative ? -*val : *val);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  917:    if (!type.isF64()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  918:      bool unused;
    #####:  919:      result->convert(floatType.getFloatSemantics(),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  920:                      APFloat::rmNearestTiesToEven, &unused);
        -:  921:    }
        -:  922:  } else {
    #####:  923:    return p.emitError("expected integer or floating point literal");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  924:  }
        -:  925:
    #####:  926:  append(result->bitcastToAPInt());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  927:  return success();
        -:  928:}
        -:  929:
        -:  930:/// Parse a dense array attribute.
function _ZN4mlir6detail6Parser19parseDenseArrayAttrENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  931:Attribute Parser::parseDenseArrayAttr(Type attrType) {
    #####:  932:  consumeToken(Token::kw_array);
call    0 never executed
    #####:  933:  if (parseToken(Token::less, "expected '<' after 'array'"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  934:    return {};
        -:  935:
    #####:  936:  SMLoc typeLoc = getToken().getLoc();
call    0 never executed
    #####:  937:  Type eltType;
        -:  938:  // If an attribute type was provided, use its element type.
    #####:  939:  if (attrType) {
branch  0 never executed
branch  1 never executed
    #####:  940:    auto tensorType = attrType.dyn_cast<RankedTensorType>();
call    0 never executed
    #####:  941:    if (!tensorType) {
branch  0 never executed
branch  1 never executed
    #####:  942:      emitError(typeLoc, "dense array attribute expected ranked tensor type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  943:      return {};
        -:  944:    }
    #####:  945:    eltType = tensorType.getElementType();
call    0 never executed
        -:  946:
        -:  947:    // Otherwise, parse a type.
    #####:  948:  } else if (!(eltType = parseType())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  949:    return {};
        -:  950:  }
        -:  951:
        -:  952:  // Only bool or integer and floating point elements divisible by bytes are
        -:  953:  // supported.
    #####:  954:  if (!eltType.isIntOrIndexOrFloat()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  955:    emitError(typeLoc, "expected integer or float type, got: ") << eltType;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  956:    return {};
        -:  957:  }
    #####:  958:  if (!eltType.isInteger(1) && eltType.getIntOrFloatBitWidth() % 8 != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  959:    emitError(typeLoc, "element type bitwidth must be a multiple of 8");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  960:    return {};
        -:  961:  }
        -:  962:
        -:  963:  // If a type was provided, check that it matches the parsed type.
function _ZZN4mlir6detail6Parser19parseDenseArrayAttrENS_4TypeEENKUlNS_14DenseArrayAttrEE_clES3_ called 0 returned 0% blocks executed 0%
    #####:  964:  auto checkProvidedType = [&](DenseArrayAttr result) -> Attribute {
    #####:  965:    if (attrType && result.getType() != attrType) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  966:      emitError(typeLoc, "expected attribute type ")
call    0 never executed
call    1 never executed
    #####:  967:          << attrType << " does not match parsed type " << result.getType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  968:      return {};
        -:  969:    }
    #####:  970:    return result;
    #####:  971:  };
        -:  972:
        -:  973:  // Check for empty list.
    #####:  974:  if (consumeIf(Token::greater)) {
branch  0 never executed
branch  1 never executed
    #####:  975:    return checkProvidedType(
    #####:  976:        DenseArrayAttr::get(RankedTensorType::get(0, eltType), {}));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  977:  }
    #####:  978:  if (!attrType &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  979:      parseToken(Token::colon, "expected ':' after dense array type"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  980:    return {};
        -:  981:
    #####:  982:  DenseArrayElementParser eltParser(eltType);
call    0 never executed
    #####:  983:  if (eltType.isIntOrIndex()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  984:    if (parseCommaSeparatedList(
branch  0 never executed
branch  1 never executed
    #####:  985:            [&] { return eltParser.parseIntegerElement(*this); }))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  986:      return {};
        -:  987:  } else {
    #####:  988:    if (parseCommaSeparatedList(
branch  0 never executed
branch  1 never executed
    #####:  989:            [&] { return eltParser.parseFloatElement(*this); }))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  990:      return {};
        -:  991:  }
    #####:  992:  if (parseToken(Token::greater, "expected '>' to close an array attribute"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  993:    return {};
    #####:  994:  return checkProvidedType(eltParser.getAttr());
call    0 never executed
call    1 never executed
        -:  995:}
        -:  996:
        -:  997:/// Parse a dense elements attribute.
function _ZN4mlir6detail6Parser22parseDenseElementsAttrENS_4TypeE called 1361262 returned 100% blocks executed 80%
  1361262:  998:Attribute Parser::parseDenseElementsAttr(Type attrType) {
  1361262:  999:  auto attribLoc = getToken().getLoc();
call    0 returned 100%
  1361262: 1000:  consumeToken(Token::kw_dense);
call    0 returned 100%
  1361262: 1001:  if (parseToken(Token::less, "expected '<' after 'dense'"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1002:    return nullptr;
        -: 1003:
        -: 1004:  // Parse the literal data if necessary.
  2722524: 1005:  TensorLiteralParser literalParser(*this);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
 1361262*: 1006:  if (!consumeIf(Token::greater)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
 2722524*: 1007:    if (literalParser.parse(/*allowHex=*/true) ||
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
 1361262*: 1008:        parseToken(Token::greater, "expected '>'"))
branch  0 taken 100%
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
    #####: 1009:      return nullptr;
        -: 1010:  }
        -: 1011:
        -: 1012:  // If the type is specified `parseElementsLiteralType` will not parse a type.
        -: 1013:  // Use the attribute location as the location for error reporting in that
        -: 1014:  // case.
 1361262*: 1015:  auto loc = attrType ? attribLoc : getToken().getLoc();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  1361262: 1016:  auto type = parseElementsLiteralType(attrType);
call    0 returned 100%
  1361262: 1017:  if (!type)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1018:    return nullptr;
  1361262: 1019:  return literalParser.getAttr(loc, type);
call    0 returned 100%
        -: 1020:}
        -: 1021:
function _ZN4mlir6detail6Parser30parseDenseResourceElementsAttrENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 1022:Attribute Parser::parseDenseResourceElementsAttr(Type attrType) {
    #####: 1023:  auto loc = getToken().getLoc();
call    0 never executed
    #####: 1024:  consumeToken(Token::kw_dense_resource);
call    0 never executed
    #####: 1025:  if (parseToken(Token::less, "expected '<' after 'dense_resource'"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1026:    return nullptr;
        -: 1027:
        -: 1028:  // Parse the resource handle.
    #####: 1029:  FailureOr<AsmDialectResourceHandle> rawHandle =
    #####: 1030:      parseResourceHandle(getContext()->getLoadedDialect<BuiltinDialect>());
call    0 never executed
call    1 never executed
    #####: 1031:  if (failed(rawHandle) || parseToken(Token::greater, "expected '>'"))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1032:    return nullptr;
        -: 1033:
    #####: 1034:  auto *handle = dyn_cast<DenseResourceElementsHandle>(&*rawHandle);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1035:  if (!handle)
branch  0 never executed
branch  1 never executed
    #####: 1036:    return emitError(loc, "invalid `dense_resource` handle type"), nullptr;
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1037:
        -: 1038:  // Parse the type of the attribute if the user didn't provide one.
    #####: 1039:  SMLoc typeLoc = loc;
    #####: 1040:  if (!attrType) {
branch  0 never executed
branch  1 never executed
    #####: 1041:    typeLoc = getToken().getLoc();
call    0 never executed
    #####: 1042:    if (parseToken(Token::colon, "expected ':'") || !(attrType = parseType()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1043:      return nullptr;
        -: 1044:  }
        -: 1045:
    #####: 1046:  ShapedType shapedType = attrType.dyn_cast<ShapedType>();
call    0 never executed
    #####: 1047:  if (!shapedType) {
branch  0 never executed
branch  1 never executed
    #####: 1048:    emitError(typeLoc, "`dense_resource` expected a shaped type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1049:    return nullptr;
        -: 1050:  }
        -: 1051:
    #####: 1052:  return DenseResourceElementsAttr::get(shapedType, *handle);
call    0 never executed
        -: 1053:}
        -: 1054:
        -: 1055:/// Shaped type for elements attribute.
        -: 1056:///
        -: 1057:///   elements-literal-type ::= vector-type | ranked-tensor-type
        -: 1058:///
        -: 1059:/// This method also checks the type has static shape.
function _ZN4mlir6detail6Parser24parseElementsLiteralTypeENS_4TypeE called 1361262 returned 100% blocks executed 55%
  1361262: 1060:ShapedType Parser::parseElementsLiteralType(Type type) {
        -: 1061:  // If the user didn't provide a type, parse the colon type for the literal.
  1361262: 1062:  if (!type) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1361262: 1063:    if (parseToken(Token::colon, "expected ':'"))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1064:      return nullptr;
  1361262: 1065:    if (!(type = parseType()))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1066:      return nullptr;
        -: 1067:  }
        -: 1068:
  1361262: 1069:  auto sType = type.dyn_cast<ShapedType>();
call    0 returned 100%
  1361262: 1070:  if (!sType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1071:    emitError("elements literal must be a shaped type");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1072:    return nullptr;
        -: 1073:  }
        -: 1074:
  1361262: 1075:  if (!sType.hasStaticShape())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1076:    return (emitError("elements literal type must have static shape"), nullptr);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1077:
  1361262: 1078:  return sType;
        -: 1079:}
        -: 1080:
        -: 1081:/// Parse a sparse elements attribute.
function _ZN4mlir6detail6Parser23parseSparseElementsAttrENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 1082:Attribute Parser::parseSparseElementsAttr(Type attrType) {
    #####: 1083:  SMLoc loc = getToken().getLoc();
call    0 never executed
    #####: 1084:  consumeToken(Token::kw_sparse);
call    0 never executed
    #####: 1085:  if (parseToken(Token::less, "Expected '<' after 'sparse'"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1086:    return nullptr;
        -: 1087:
        -: 1088:  // Check for the case where all elements are sparse. The indices are
        -: 1089:  // represented by a 2-dimensional shape where the second dimension is the rank
        -: 1090:  // of the type.
    #####: 1091:  Type indiceEltType = builder.getIntegerType(64);
call    0 never executed
    #####: 1092:  if (consumeIf(Token::greater)) {
branch  0 never executed
branch  1 never executed
    #####: 1093:    ShapedType type = parseElementsLiteralType(attrType);
call    0 never executed
    #####: 1094:    if (!type)
branch  0 never executed
branch  1 never executed
    #####: 1095:      return nullptr;
        -: 1096:
        -: 1097:    // Construct the sparse elements attr using zero element indice/value
        -: 1098:    // attributes.
    #####: 1099:    ShapedType indicesType =
    #####: 1100:        RankedTensorType::get({0, type.getRank()}, indiceEltType);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1101:    ShapedType valuesType = RankedTensorType::get({0}, type.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1102:    return getChecked<SparseElementsAttr>(
    #####: 1103:        loc, type, DenseElementsAttr::get(indicesType, ArrayRef<Attribute>()),
call    0 never executed
    #####: 1104:        DenseElementsAttr::get(valuesType, ArrayRef<Attribute>()));
call    0 never executed
call    1 never executed
        -: 1105:  }
        -: 1106:
        -: 1107:  /// Parse the indices. We don't allow hex values here as we may need to use
        -: 1108:  /// the inferred shape.
    #####: 1109:  auto indicesLoc = getToken().getLoc();
call    0 never executed
    #####: 1110:  TensorLiteralParser indiceParser(*this);
call    0 never executed
call    1 never executed
    #####: 1111:  if (indiceParser.parse(/*allowHex=*/false))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1112:    return nullptr;
        -: 1113:
    #####: 1114:  if (parseToken(Token::comma, "expected ','"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1115:    return nullptr;
        -: 1116:
        -: 1117:  /// Parse the values.
    #####: 1118:  auto valuesLoc = getToken().getLoc();
call    0 never executed
    #####: 1119:  TensorLiteralParser valuesParser(*this);
call    0 never executed
call    1 never executed
    #####: 1120:  if (valuesParser.parse(/*allowHex=*/true))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1121:    return nullptr;
        -: 1122:
    #####: 1123:  if (parseToken(Token::greater, "expected '>'"))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1124:    return nullptr;
        -: 1125:
    #####: 1126:  auto type = parseElementsLiteralType(attrType);
call    0 never executed
    #####: 1127:  if (!type)
branch  0 never executed
branch  1 never executed
    #####: 1128:    return nullptr;
        -: 1129:
        -: 1130:  // If the indices are a splat, i.e. the literal parser parsed an element and
        -: 1131:  // not a list, we set the shape explicitly. The indices are represented by a
        -: 1132:  // 2-dimensional shape where the second dimension is the rank of the type.
        -: 1133:  // Given that the parsed indices is a splat, we know that we only have one
        -: 1134:  // indice and thus one for the first dimension.
    #####: 1135:  ShapedType indicesType;
call    0 never executed
    #####: 1136:  if (indiceParser.getShape().empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1137:    indicesType = RankedTensorType::get({1, type.getRank()}, indiceEltType);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1138:  } else {
        -: 1139:    // Otherwise, set the shape to the one parsed by the literal parser.
    #####: 1140:    indicesType = RankedTensorType::get(indiceParser.getShape(), indiceEltType);
call    0 never executed
call    1 never executed
        -: 1141:  }
    #####: 1142:  auto indices = indiceParser.getAttr(indicesLoc, indicesType);
call    0 never executed
        -: 1143:
        -: 1144:  // If the values are a splat, set the shape explicitly based on the number of
        -: 1145:  // indices. The number of indices is encoded in the first dimension of the
        -: 1146:  // indice shape type.
    #####: 1147:  auto valuesEltType = type.getElementType();
call    0 never executed
    #####: 1148:  ShapedType valuesType =
branch  0 never executed
branch  1 never executed
    #####: 1149:      valuesParser.getShape().empty()
branch  0 never executed
branch  1 never executed
    #####: 1150:          ? RankedTensorType::get({indicesType.getDimSize(0)}, valuesEltType)
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1151:          : RankedTensorType::get(valuesParser.getShape(), valuesEltType);
call    0 never executed
    #####: 1152:  auto values = valuesParser.getAttr(valuesLoc, valuesType);
call    0 never executed
        -: 1153:
        -: 1154:  // Build the sparse elements attribute by the indices and values.
    #####: 1155:  return getChecked<SparseElementsAttr>(loc, type, indices, values);
call    0 never executed
        -: 1156:}
        -: 1157:
function _ZN4mlir6detail6Parser22parseStridedLayoutAttrEv called 0 returned 0% blocks executed 0%
    #####: 1158:Attribute Parser::parseStridedLayoutAttr() {
        -: 1159:  // Callback for error emissing at the keyword token location.
    #####: 1160:  llvm::SMLoc loc = getToken().getLoc();
call    0 never executed
    #####: 1161:  auto errorEmitter = [&] { return emitError(loc); };
call    0 never executed
call    1 never executed
        -: 1162:
    #####: 1163:  consumeToken(Token::kw_strided);
call    0 never executed
    #####: 1164:  if (failed(parseToken(Token::less, "expected '<' after 'strided'")) ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1165:      failed(parseToken(Token::l_square, "expected '['")))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1166:    return nullptr;
        -: 1167:
        -: 1168:  // Parses either an integer token or a question mark token. Reports an error
        -: 1169:  // and returns None if the current token is neither. The integer token must
        -: 1170:  // fit into int64_t limits.
function _ZZN4mlir6detail6Parser22parseStridedLayoutAttrEvENKUlvE0_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1171:  auto parseStrideOrOffset = [&]() -> Optional<int64_t> {
    #####: 1172:    if (consumeIf(Token::question))
branch  0 never executed
branch  1 never executed
    #####: 1173:      return ShapedType::kDynamicStrideOrOffset;
        -: 1174:
    #####: 1175:    SMLoc loc = getToken().getLoc();
call    0 never executed
function _ZZZN4mlir6detail6Parser22parseStridedLayoutAttrEvENKUlvE0_clEvENKUlvE_clEv.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1176:    auto emitWrongTokenError = [&] {
    #####: 1177:      emitError(loc, "expected a 64-bit signed integer or '?'");
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1178:      return llvm::None;
    #####: 1179:    };
        -: 1180:
    #####: 1181:    bool negative = consumeIf(Token::minus);
branch  0 never executed
branch  1 never executed
        -: 1182:
    #####: 1183:    if (getToken().is(Token::integer)) {
branch  0 never executed
branch  1 never executed
    #####: 1184:      Optional<uint64_t> value = getToken().getUInt64IntegerValue();
call    0 never executed
    #####: 1185:      if (!value ||
branch  0 never executed
branch  1 never executed
    #####: 1186:          *value > static_cast<uint64_t>(std::numeric_limits<int64_t>::max()))
branch  0 never executed
branch  1 never executed
    #####: 1187:        return emitWrongTokenError();
call    0 never executed
    #####: 1188:      consumeToken();
call    0 never executed
    #####: 1189:      auto result = static_cast<int64_t>(*value);
branch  0 never executed
branch  1 never executed
    #####: 1190:      if (negative)
branch  0 never executed
branch  1 never executed
    #####: 1191:        result = -result;
        -: 1192:
    #####: 1193:      return result;
        -: 1194:    }
        -: 1195:
    #####: 1196:    return emitWrongTokenError();
call    0 never executed
    #####: 1197:  };
        -: 1198:
        -: 1199:  // Parse strides.
    #####: 1200:  SmallVector<int64_t> strides;
branch  0 never executed
branch  1 never executed
    #####: 1201:  if (!getToken().is(Token::r_square)) {
branch  0 never executed
branch  1 never executed
    #####: 1202:    do {
    #####: 1203:      Optional<int64_t> stride = parseStrideOrOffset();
call    0 never executed
    #####: 1204:      if (!stride)
branch  0 never executed
branch  1 never executed
    #####: 1205:        return nullptr;
    #####: 1206:      strides.push_back(*stride);
call    0 never executed
    #####: 1207:    } while (consumeIf(Token::comma));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1208:  }
        -: 1209:
    #####: 1210:  if (failed(parseToken(Token::r_square, "expected ']'")))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1211:    return nullptr;
        -: 1212:
        -: 1213:  // Fast path in absence of offset.
    #####: 1214:  if (consumeIf(Token::greater)) {
branch  0 never executed
branch  1 never executed
    #####: 1215:    if (failed(StridedLayoutAttr::verify(errorEmitter,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1216:                                         /*offset=*/0, strides)))
    #####: 1217:      return nullptr;
    #####: 1218:    return StridedLayoutAttr::get(getContext(), /*offset=*/0, strides);
call    0 never executed
        -: 1219:  }
        -: 1220:
    #####: 1221:  if (failed(parseToken(Token::comma, "expected ','")) ||
call    0 never executed
call    1 never executed
    #####: 1222:      failed(parseToken(Token::kw_offset, "expected 'offset' after comma")) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1223:      failed(parseToken(Token::colon, "expected ':' after 'offset'")))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1224:    return nullptr;
        -: 1225:
    #####: 1226:  Optional<int64_t> offset = parseStrideOrOffset();
call    0 never executed
    #####: 1227:  if (!offset || failed(parseToken(Token::greater, "expected '>'")))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1228:    return nullptr;
        -: 1229:
    #####: 1230:  if (failed(StridedLayoutAttr::verify(errorEmitter, *offset, strides)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1231:    return nullptr;
    #####: 1232:  return StridedLayoutAttr::get(getContext(), *offset, strides);
call    0 never executed
        -: 1233:  // return getChecked<StridedLayoutAttr>(loc,getContext(), *offset, strides);
        -: 1234:}
