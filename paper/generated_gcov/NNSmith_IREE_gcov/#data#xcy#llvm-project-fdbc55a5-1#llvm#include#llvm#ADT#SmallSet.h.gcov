        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/ADT/SmallSet.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Async/Transforms/CMakeFiles/obj.MLIRAsyncTransforms.dir/AsyncRuntimeRefCounting.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Async/Transforms/CMakeFiles/obj.MLIRAsyncTransforms.dir/AsyncRuntimeRefCounting.cpp.gcda
        -:    0:Runs:325545
        -:    1://===- llvm/ADT/SmallSet.h - 'Normally small' sets --------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:///
        -:    9:/// \file
        -:   10:/// This file defines the SmallSet class.
        -:   11:///
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_ADT_SMALLSET_H
        -:   15:#define LLVM_ADT_SMALLSET_H
        -:   16:
        -:   17:#include "llvm/ADT/None.h"
        -:   18:#include "llvm/ADT/SmallPtrSet.h"
        -:   19:#include "llvm/ADT/SmallVector.h"
        -:   20:#include "llvm/ADT/STLExtras.h"
        -:   21:#include "llvm/ADT/iterator.h"
        -:   22:#include "llvm/Support/Compiler.h"
        -:   23:#include "llvm/Support/type_traits.h"
        -:   24:#include <cstddef>
        -:   25:#include <functional>
        -:   26:#include <set>
        -:   27:#include <type_traits>
        -:   28:#include <utility>
        -:   29:
        -:   30:namespace llvm {
        -:   31:
        -:   32:/// SmallSetIterator - This class implements a const_iterator for SmallSet by
        -:   33:/// delegating to the underlying SmallVector or Set iterators.
        -:   34:template <typename T, unsigned N, typename C>
        -:   35:class SmallSetIterator
        -:   36:    : public iterator_facade_base<SmallSetIterator<T, N, C>,
        -:   37:                                  std::forward_iterator_tag, T> {
        -:   38:private:
        -:   39:  using SetIterTy = typename std::set<T, C>::const_iterator;
        -:   40:  using VecIterTy = typename SmallVector<T, N>::const_iterator;
        -:   41:  using SelfTy = SmallSetIterator<T, N, C>;
        -:   42:
        -:   43:  /// Iterators to the parts of the SmallSet containing the data. They are set
        -:   44:  /// depending on isSmall.
        -:   45:  union {
        -:   46:    SetIterTy SetIter;
        -:   47:    VecIterTy VecIter;
        -:   48:  };
        -:   49:
        -:   50:  bool isSmall;
        -:   51:
        -:   52:public:
        -:   53:  SmallSetIterator(SetIterTy SetIter) : SetIter(SetIter), isSmall(false) {}
        -:   54:
        -:   55:  SmallSetIterator(VecIterTy VecIter) : VecIter(VecIter), isSmall(true) {}
        -:   56:
        -:   57:  // Spell out destructor, copy/move constructor and assignment operators for
        -:   58:  // MSVC STL, where set<T>::const_iterator is not trivially copy constructible.
        -:   59:  ~SmallSetIterator() {
        -:   60:    if (isSmall)
        -:   61:      VecIter.~VecIterTy();
        -:   62:    else
        -:   63:      SetIter.~SetIterTy();
        -:   64:  }
        -:   65:
        -:   66:  SmallSetIterator(const SmallSetIterator &Other) : isSmall(Other.isSmall) {
        -:   67:    if (isSmall)
        -:   68:      VecIter = Other.VecIter;
        -:   69:    else
        -:   70:      // Use placement new, to make sure SetIter is properly constructed, even
        -:   71:      // if it is not trivially copy-able (e.g. in MSVC).
        -:   72:      new (&SetIter) SetIterTy(Other.SetIter);
        -:   73:  }
        -:   74:
        -:   75:  SmallSetIterator(SmallSetIterator &&Other) : isSmall(Other.isSmall) {
        -:   76:    if (isSmall)
        -:   77:      VecIter = std::move(Other.VecIter);
        -:   78:    else
        -:   79:      // Use placement new, to make sure SetIter is properly constructed, even
        -:   80:      // if it is not trivially copy-able (e.g. in MSVC).
        -:   81:      new (&SetIter) SetIterTy(std::move(Other.SetIter));
        -:   82:  }
        -:   83:
        -:   84:  SmallSetIterator& operator=(const SmallSetIterator& Other) {
        -:   85:    // Call destructor for SetIter, so it gets properly destroyed if it is
        -:   86:    // not trivially destructible in case we are setting VecIter.
        -:   87:    if (!isSmall)
        -:   88:      SetIter.~SetIterTy();
        -:   89:
        -:   90:    isSmall = Other.isSmall;
        -:   91:    if (isSmall)
        -:   92:      VecIter = Other.VecIter;
        -:   93:    else
        -:   94:      new (&SetIter) SetIterTy(Other.SetIter);
        -:   95:    return *this;
        -:   96:  }
        -:   97:
        -:   98:  SmallSetIterator& operator=(SmallSetIterator&& Other) {
        -:   99:    // Call destructor for SetIter, so it gets properly destroyed if it is
        -:  100:    // not trivially destructible in case we are setting VecIter.
        -:  101:    if (!isSmall)
        -:  102:      SetIter.~SetIterTy();
        -:  103:
        -:  104:    isSmall = Other.isSmall;
        -:  105:    if (isSmall)
        -:  106:      VecIter = std::move(Other.VecIter);
        -:  107:    else
        -:  108:      new (&SetIter) SetIterTy(std::move(Other.SetIter));
        -:  109:    return *this;
        -:  110:  }
        -:  111:
        -:  112:  bool operator==(const SmallSetIterator &RHS) const {
        -:  113:    if (isSmall != RHS.isSmall)
        -:  114:      return false;
        -:  115:    if (isSmall)
        -:  116:      return VecIter == RHS.VecIter;
        -:  117:    return SetIter == RHS.SetIter;
        -:  118:  }
        -:  119:
        -:  120:  SmallSetIterator &operator++() { // Preincrement
        -:  121:    if (isSmall)
        -:  122:      VecIter++;
        -:  123:    else
        -:  124:      SetIter++;
        -:  125:    return *this;
        -:  126:  }
        -:  127:
        -:  128:  const T &operator*() const { return isSmall ? *VecIter : *SetIter; }
        -:  129:};
        -:  130:
        -:  131:/// SmallSet - This maintains a set of unique values, optimizing for the case
        -:  132:/// when the set is small (less than N).  In this case, the set can be
        -:  133:/// maintained with no mallocs.  If the set gets large, we expand to using an
        -:  134:/// std::set to maintain reasonable lookup times.
        -:  135:template <typename T, unsigned N, typename C = std::less<T>>
        -:  136:class SmallSet {
        -:  137:  /// Use a SmallVector to hold the elements here (even though it will never
        -:  138:  /// reach its 'large' stage) to avoid calling the default ctors of elements
        -:  139:  /// we will never use.
        -:  140:  SmallVector<T, N> Vector;
        -:  141:  std::set<T, C> Set;
        -:  142:
        -:  143:  using VIterator = typename SmallVector<T, N>::const_iterator;
        -:  144:  using SIterator = typename std::set<T, C>::const_iterator;
        -:  145:  using mutable_iterator = typename SmallVector<T, N>::iterator;
        -:  146:
        -:  147:  // In small mode SmallPtrSet uses linear search for the elements, so it is
        -:  148:  // not a good idea to choose this value too high. You may consider using a
        -:  149:  // DenseSet<> instead if you expect many elements in the set.
        -:  150:  static_assert(N <= 32, "N should be small");
        -:  151:
        -:  152:public:
        -:  153:  using size_type = size_t;
        -:  154:  using const_iterator = SmallSetIterator<T, N, C>;
        -:  155:
        -:  156:  SmallSet() = default;
        -:  157:
        -:  158:  [[nodiscard]] bool empty() const { return Vector.empty() && Set.empty(); }
        -:  159:
        -:  160:  size_type size() const {
        -:  161:    return isSmall() ? Vector.size() : Set.size();
        -:  162:  }
        -:  163:
        -:  164:  /// count - Return 1 if the element is in the set, 0 otherwise.
        -:  165:  size_type count(const T &V) const {
        -:  166:    if (isSmall()) {
        -:  167:      // Since the collection is small, just do a linear search.
        -:  168:      return vfind(V) == Vector.end() ? 0 : 1;
        -:  169:    } else {
        -:  170:      return Set.count(V);
        -:  171:    }
        -:  172:  }
        -:  173:
        -:  174:  /// insert - Insert an element into the set if it isn't already there.
        -:  175:  /// Returns a pair. The first value of it is an iterator to the inserted
        -:  176:  /// element or the existing element in the set. The second value is true
        -:  177:  /// if the element is inserted (it was not in the set before).
        -:  178:  std::pair<const_iterator, bool> insert(const T &V) {
        -:  179:    if (!isSmall()) {
        -:  180:      auto [I, Inserted] = Set.insert(V);
        -:  181:      return std::make_pair(const_iterator(I), Inserted);
        -:  182:    }
        -:  183:
        -:  184:    VIterator I = vfind(V);
        -:  185:    if (I != Vector.end())    // Don't reinsert if it already exists.
        -:  186:      return std::make_pair(const_iterator(I), false);
        -:  187:    if (Vector.size() < N) {
        -:  188:      Vector.push_back(V);
        -:  189:      return std::make_pair(const_iterator(std::prev(Vector.end())), true);
        -:  190:    }
        -:  191:
        -:  192:    // Otherwise, grow from vector to set.
        -:  193:    while (!Vector.empty()) {
        -:  194:      Set.insert(Vector.back());
        -:  195:      Vector.pop_back();
        -:  196:    }
        -:  197:    return std::make_pair(const_iterator(Set.insert(V).first), true);
        -:  198:  }
        -:  199:
        -:  200:  template <typename IterT>
        -:  201:  void insert(IterT I, IterT E) {
        -:  202:    for (; I != E; ++I)
        -:  203:      insert(*I);
        -:  204:  }
        -:  205:
        -:  206:  bool erase(const T &V) {
        -:  207:    if (!isSmall())
        -:  208:      return Set.erase(V);
        -:  209:    for (mutable_iterator I = Vector.begin(), E = Vector.end(); I != E; ++I)
        -:  210:      if (*I == V) {
        -:  211:        Vector.erase(I);
        -:  212:        return true;
        -:  213:      }
        -:  214:    return false;
        -:  215:  }
        -:  216:
        -:  217:  void clear() {
        -:  218:    Vector.clear();
        -:  219:    Set.clear();
        -:  220:  }
        -:  221:
        -:  222:  const_iterator begin() const {
        -:  223:    if (isSmall())
        -:  224:      return {Vector.begin()};
        -:  225:    return {Set.begin()};
        -:  226:  }
        -:  227:
        -:  228:  const_iterator end() const {
        -:  229:    if (isSmall())
        -:  230:      return {Vector.end()};
        -:  231:    return {Set.end()};
        -:  232:  }
        -:  233:
        -:  234:  /// Check if the SmallSet contains the given element.
        -:  235:  bool contains(const T &V) const {
        -:  236:    if (isSmall())
        -:  237:      return vfind(V) != Vector.end();
        -:  238:    return Set.find(V) != Set.end();
        -:  239:  }
        -:  240:
        -:  241:private:
        -:  242:  bool isSmall() const { return Set.empty(); }
        -:  243:
        -:  244:  VIterator vfind(const T &V) const {
        -:  245:    for (VIterator I = Vector.begin(), E = Vector.end(); I != E; ++I)
        -:  246:      if (*I == V)
        -:  247:        return I;
        -:  248:    return Vector.end();
        -:  249:  }
        -:  250:};
        -:  251:
        -:  252:/// If this set is of pointer values, transparently switch over to using
        -:  253:/// SmallPtrSet for performance.
        -:  254:template <typename PointeeType, unsigned N>
    #####:  255:class SmallSet<PointeeType*, N> : public SmallPtrSet<PointeeType*, N> {};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  256:
        -:  257:/// Equality comparison for SmallSet.
        -:  258:///
        -:  259:/// Iterates over elements of LHS confirming that each element is also a member
        -:  260:/// of RHS, and that RHS contains no additional values.
        -:  261:/// Equivalent to N calls to RHS.count.
        -:  262:/// For small-set mode amortized complexity is O(N^2)
        -:  263:/// For large-set mode amortized complexity is linear, worst case is O(N^2) (if
        -:  264:/// every hash collides).
        -:  265:template <typename T, unsigned LN, unsigned RN, typename C>
        -:  266:bool operator==(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {
        -:  267:  if (LHS.size() != RHS.size())
        -:  268:    return false;
        -:  269:
        -:  270:  // All elements in LHS must also be in RHS
        -:  271:  return all_of(LHS, [&RHS](const T &E) { return RHS.count(E); });
        -:  272:}
        -:  273:
        -:  274:/// Inequality comparison for SmallSet.
        -:  275:///
        -:  276:/// Equivalent to !(LHS == RHS). See operator== for performance notes.
        -:  277:template <typename T, unsigned LN, unsigned RN, typename C>
        -:  278:bool operator!=(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {
        -:  279:  return !(LHS == RHS);
        -:  280:}
        -:  281:
        -:  282:} // end namespace llvm
        -:  283:
        -:  284:#endif // LLVM_ADT_SMALLSET_H
