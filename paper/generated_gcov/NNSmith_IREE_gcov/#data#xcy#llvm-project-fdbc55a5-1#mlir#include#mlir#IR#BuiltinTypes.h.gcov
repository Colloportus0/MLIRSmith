        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/include/mlir/IR/BuiltinTypes.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/CMakeFiles/obj.MLIRTargetLLVMIRExport.dir/ModuleTranslation.cpp.gcda
        -:    0:Runs:325581
        -:    1://===- BuiltinTypes.h - MLIR Builtin Type Classes ---------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#ifndef MLIR_IR_BUILTINTYPES_H
        -:   10:#define MLIR_IR_BUILTINTYPES_H
        -:   11:
        -:   12:#include "mlir/IR/BuiltinAttributeInterfaces.h"
        -:   13:#include "mlir/IR/BuiltinTypeInterfaces.h"
        -:   14:#include "mlir/IR/SubElementInterfaces.h"
        -:   15:
        -:   16:namespace llvm {
        -:   17:class BitVector;
        -:   18:struct fltSemantics;
        -:   19:} // namespace llvm
        -:   20:
        -:   21://===----------------------------------------------------------------------===//
        -:   22:// Tablegen Interface Declarations
        -:   23://===----------------------------------------------------------------------===//
        -:   24:
        -:   25:namespace mlir {
        -:   26:class AffineExpr;
        -:   27:class AffineMap;
        -:   28:class FloatType;
        -:   29:class IndexType;
        -:   30:class IntegerType;
        -:   31:class StringAttr;
        -:   32:class TypeRange;
        -:   33:
        -:   34://===----------------------------------------------------------------------===//
        -:   35:// FloatType
        -:   36://===----------------------------------------------------------------------===//
        -:   37:
        -:   38:class FloatType : public Type {
        -:   39:public:
    #####:   40:  using Type::Type;
        -:   41:
        -:   42:  // Convenience factories.
        -:   43:  static FloatType getBF16(MLIRContext *ctx);
        -:   44:  static FloatType getF16(MLIRContext *ctx);
        -:   45:  static FloatType getF32(MLIRContext *ctx);
        -:   46:  static FloatType getF64(MLIRContext *ctx);
        -:   47:  static FloatType getF80(MLIRContext *ctx);
        -:   48:  static FloatType getF128(MLIRContext *ctx);
        -:   49:  static FloatType getFloat8E5M2(MLIRContext *ctx);
        -:   50:
        -:   51:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:   52:  static bool classof(Type type);
        -:   53:
        -:   54:  /// Return the bitwidth of this float type.
        -:   55:  unsigned getWidth();
        -:   56:
        -:   57:  /// Return the width of the mantissa of this type.
        -:   58:  unsigned getFPMantissaWidth();
        -:   59:
        -:   60:  /// Get or create a new FloatType with bitwidth scaled by `scale`.
        -:   61:  /// Return null if the scaled element type cannot be represented.
        -:   62:  FloatType scaleElementBitwidth(unsigned scale);
        -:   63:
        -:   64:  /// Return the floating semantics of this float type.
        -:   65:  const llvm::fltSemantics &getFloatSemantics();
        -:   66:};
        -:   67:
        -:   68://===----------------------------------------------------------------------===//
        -:   69:// TensorType
        -:   70://===----------------------------------------------------------------------===//
        -:   71:
        -:   72:/// Tensor types represent multi-dimensional arrays, and have two variants:
        -:   73:/// RankedTensorType and UnrankedTensorType.
        -:   74:/// Note: This class attaches the ShapedType trait to act as a mixin to
        -:   75:///       provide many useful utility functions. This inheritance has no effect
        -:   76:///       on derived tensor types.
        -:   77:class TensorType : public Type, public ShapedType::Trait<TensorType> {
        -:   78:public:
        -:   79:  using Type::Type;
        -:   80:
        -:   81:  /// Returns the element type of this tensor type.
        -:   82:  Type getElementType() const;
        -:   83:
        -:   84:  /// Returns if this type is ranked, i.e. it has a known number of dimensions.
        -:   85:  bool hasRank() const;
        -:   86:
        -:   87:  /// Returns the shape of this tensor type.
        -:   88:  ArrayRef<int64_t> getShape() const;
        -:   89:
        -:   90:  /// Clone this type with the given shape and element type. If the
        -:   91:  /// provided shape is `None`, the current shape of the type is used.
        -:   92:  TensorType cloneWith(Optional<ArrayRef<int64_t>> shape,
        -:   93:                       Type elementType) const;
        -:   94:
        -:   95:  /// Return true if the specified element type is ok in a tensor.
        -:   96:  static bool isValidElementType(Type type);
        -:   97:
        -:   98:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:   99:  static bool classof(Type type);
        -:  100:
        -:  101:  /// Allow implicit conversion to ShapedType.
        -:  102:  operator ShapedType() const { return cast<ShapedType>(); }
        -:  103:};
        -:  104:
        -:  105://===----------------------------------------------------------------------===//
        -:  106:// BaseMemRefType
        -:  107://===----------------------------------------------------------------------===//
        -:  108:
        -:  109:/// This class provides a shared interface for ranked and unranked memref types.
        -:  110:/// Note: This class attaches the ShapedType trait to act as a mixin to
        -:  111:///       provide many useful utility functions. This inheritance has no effect
        -:  112:///       on derived memref types.
        -:  113:class BaseMemRefType : public Type, public ShapedType::Trait<BaseMemRefType> {
        -:  114:public:
        -:  115:  using Type::Type;
        -:  116:
        -:  117:  /// Returns the element type of this memref type.
        -:  118:  Type getElementType() const;
        -:  119:
        -:  120:  /// Returns if this type is ranked, i.e. it has a known number of dimensions.
        -:  121:  bool hasRank() const;
        -:  122:
        -:  123:  /// Returns the shape of this memref type.
        -:  124:  ArrayRef<int64_t> getShape() const;
        -:  125:
        -:  126:  /// Clone this type with the given shape and element type. If the
        -:  127:  /// provided shape is `None`, the current shape of the type is used.
        -:  128:  BaseMemRefType cloneWith(Optional<ArrayRef<int64_t>> shape,
        -:  129:                           Type elementType) const;
        -:  130:
        -:  131:  /// Return true if the specified element type is ok in a memref.
        -:  132:  static bool isValidElementType(Type type);
        -:  133:
        -:  134:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:  135:  static bool classof(Type type);
        -:  136:
        -:  137:  /// Returns the memory space in which data referred to by this memref resides.
        -:  138:  Attribute getMemorySpace() const;
        -:  139:
        -:  140:  /// [deprecated] Returns the memory space in old raw integer representation.
        -:  141:  /// New `Attribute getMemorySpace()` method should be used instead.
        -:  142:  unsigned getMemorySpaceAsInt() const;
        -:  143:
        -:  144:  /// Allow implicit conversion to ShapedType.
        -:  145:  operator ShapedType() const { return cast<ShapedType>(); }
        -:  146:};
        -:  147:
        -:  148:} // namespace mlir
        -:  149:
        -:  150://===----------------------------------------------------------------------===//
        -:  151:// Tablegen Type Declarations
        -:  152://===----------------------------------------------------------------------===//
        -:  153:
        -:  154:#define GET_TYPEDEF_CLASSES
        -:  155:#include "mlir/IR/BuiltinTypes.h.inc"
        -:  156:
        -:  157:namespace mlir {
        -:  158:
        -:  159://===----------------------------------------------------------------------===//
        -:  160:// MemRefType
        -:  161://===----------------------------------------------------------------------===//
        -:  162:
        -:  163:/// This is a builder type that keeps local references to arguments. Arguments
        -:  164:/// that are passed into the builder must outlive the builder.
        -:  165:class MemRefType::Builder {
        -:  166:public:
        -:  167:  // Build from another MemRefType.
        -:  168:  explicit Builder(MemRefType other)
        -:  169:      : shape(other.getShape()), elementType(other.getElementType()),
        -:  170:        layout(other.getLayout()), memorySpace(other.getMemorySpace()) {}
        -:  171:
        -:  172:  // Build from scratch.
        -:  173:  Builder(ArrayRef<int64_t> shape, Type elementType)
        -:  174:      : shape(shape), elementType(elementType) {}
        -:  175:
        -:  176:  Builder &setShape(ArrayRef<int64_t> newShape) {
        -:  177:    shape = newShape;
        -:  178:    return *this;
        -:  179:  }
        -:  180:
        -:  181:  Builder &setElementType(Type newElementType) {
        -:  182:    elementType = newElementType;
        -:  183:    return *this;
        -:  184:  }
        -:  185:
        -:  186:  Builder &setLayout(MemRefLayoutAttrInterface newLayout) {
        -:  187:    layout = newLayout;
        -:  188:    return *this;
        -:  189:  }
        -:  190:
        -:  191:  Builder &setMemorySpace(Attribute newMemorySpace) {
        -:  192:    memorySpace = newMemorySpace;
        -:  193:    return *this;
        -:  194:  }
        -:  195:
        -:  196:  operator MemRefType() {
        -:  197:    return MemRefType::get(shape, elementType, layout, memorySpace);
        -:  198:  }
        -:  199:
        -:  200:private:
        -:  201:  ArrayRef<int64_t> shape;
        -:  202:  Type elementType;
        -:  203:  MemRefLayoutAttrInterface layout;
        -:  204:  Attribute memorySpace;
        -:  205:};
        -:  206:
        -:  207://===----------------------------------------------------------------------===//
        -:  208:// RankedTensorType
        -:  209://===----------------------------------------------------------------------===//
        -:  210:
        -:  211:/// This is a builder type that keeps local references to arguments. Arguments
        -:  212:/// that are passed into the builder must outlive the builder.
        -:  213:class RankedTensorType::Builder {
        -:  214:public:
        -:  215:  /// Build from another RankedTensorType.
        -:  216:  explicit Builder(RankedTensorType other)
        -:  217:      : shape(other.getShape()), elementType(other.getElementType()),
        -:  218:        encoding(other.getEncoding()) {}
        -:  219:
        -:  220:  /// Build from scratch.
        -:  221:  Builder(ArrayRef<int64_t> shape, Type elementType, Attribute encoding)
        -:  222:      : shape(shape), elementType(elementType), encoding(encoding) {}
        -:  223:
        -:  224:  Builder &setShape(ArrayRef<int64_t> newShape) {
        -:  225:    shape = newShape;
        -:  226:    return *this;
        -:  227:  }
        -:  228:
        -:  229:  Builder &setElementType(Type newElementType) {
        -:  230:    elementType = newElementType;
        -:  231:    return *this;
        -:  232:  }
        -:  233:
        -:  234:  Builder &setEncoding(Attribute newEncoding) {
        -:  235:    encoding = newEncoding;
        -:  236:    return *this;
        -:  237:  }
        -:  238:
        -:  239:  /// Erase a dim from shape @pos.
        -:  240:  Builder &dropDim(unsigned pos) {
        -:  241:    assert(pos < shape.size() && "overflow");
        -:  242:    if (storage.empty())
        -:  243:      storage.append(shape.begin(), shape.end());
        -:  244:    storage.erase(storage.begin() + pos);
        -:  245:    shape = {storage.data(), storage.size()};
        -:  246:    return *this;
        -:  247:  }
        -:  248:
        -:  249:  /// Insert a val into shape @pos.
        -:  250:  Builder &insertDim(int64_t val, unsigned pos) {
        -:  251:    assert(pos <= shape.size() && "overflow");
        -:  252:    if (storage.empty())
        -:  253:      storage.append(shape.begin(), shape.end());
        -:  254:    storage.insert(storage.begin() + pos, val);
        -:  255:    shape = {storage.data(), storage.size()};
        -:  256:    return *this;
        -:  257:  }
        -:  258:
        -:  259:  operator RankedTensorType() {
        -:  260:    return RankedTensorType::get(shape, elementType, encoding);
        -:  261:  }
        -:  262:
        -:  263:private:
        -:  264:  ArrayRef<int64_t> shape;
        -:  265:  // Owning shape data for copy-on-write operations.
        -:  266:  SmallVector<int64_t> storage;
        -:  267:  Type elementType;
        -:  268:  Attribute encoding;
        -:  269:};
        -:  270:
        -:  271://===----------------------------------------------------------------------===//
        -:  272:// VectorType
        -:  273://===----------------------------------------------------------------------===//
        -:  274:
        -:  275:/// This is a builder type that keeps local references to arguments. Arguments
        -:  276:/// that are passed into the builder must outlive the builder.
        -:  277:class VectorType::Builder {
        -:  278:public:
        -:  279:  /// Build from another VectorType.
        -:  280:  explicit Builder(VectorType other)
        -:  281:      : shape(other.getShape()), elementType(other.getElementType()),
        -:  282:        numScalableDims(other.getNumScalableDims()) {}
        -:  283:
        -:  284:  /// Build from scratch.
        -:  285:  Builder(ArrayRef<int64_t> shape, Type elementType,
        -:  286:          unsigned numScalableDims = 0)
        -:  287:      : shape(shape), elementType(elementType),
        -:  288:        numScalableDims(numScalableDims) {}
        -:  289:
        -:  290:  Builder &setShape(ArrayRef<int64_t> newShape,
        -:  291:                    unsigned newNumScalableDims = 0) {
        -:  292:    numScalableDims = newNumScalableDims;
        -:  293:    shape = newShape;
        -:  294:    return *this;
        -:  295:  }
        -:  296:
        -:  297:  Builder &setElementType(Type newElementType) {
        -:  298:    elementType = newElementType;
        -:  299:    return *this;
        -:  300:  }
        -:  301:
        -:  302:  /// Erase a dim from shape @pos.
        -:  303:  Builder &dropDim(unsigned pos) {
        -:  304:    assert(pos < shape.size() && "overflow");
        -:  305:    if (pos >= shape.size() - numScalableDims)
        -:  306:      numScalableDims--;
        -:  307:    if (storage.empty())
        -:  308:      storage.append(shape.begin(), shape.end());
        -:  309:    storage.erase(storage.begin() + pos);
        -:  310:    shape = {storage.data(), storage.size()};
        -:  311:    return *this;
        -:  312:  }
        -:  313:
        -:  314:  /// In the particular case where the vector has a single dimension that we
        -:  315:  /// drop, return the scalar element type.
        -:  316:  // TODO: unify once we have a VectorType that supports 0-D.
        -:  317:  operator Type() {
        -:  318:    if (shape.empty())
        -:  319:      return elementType;
        -:  320:    return VectorType::get(shape, elementType, numScalableDims);
        -:  321:  }
        -:  322:
        -:  323:private:
        -:  324:  ArrayRef<int64_t> shape;
        -:  325:  // Owning shape data for copy-on-write operations.
        -:  326:  SmallVector<int64_t> storage;
        -:  327:  Type elementType;
        -:  328:  unsigned numScalableDims;
        -:  329:};
        -:  330:
        -:  331:/// Given an `originalShape` and a `reducedShape` assumed to be a subset of
        -:  332:/// `originalShape` with some `1` entries erased, return the set of indices
        -:  333:/// that specifies which of the entries of `originalShape` are dropped to obtain
        -:  334:/// `reducedShape`. The returned mask can be applied as a projection to
        -:  335:/// `originalShape` to obtain the `reducedShape`. This mask is useful to track
        -:  336:/// which dimensions must be kept when e.g. compute MemRef strides under
        -:  337:/// rank-reducing operations. Return None if reducedShape cannot be obtained
        -:  338:/// by dropping only `1` entries in `originalShape`.
        -:  339:llvm::Optional<llvm::SmallDenseSet<unsigned>>
        -:  340:computeRankReductionMask(ArrayRef<int64_t> originalShape,
        -:  341:                         ArrayRef<int64_t> reducedShape);
        -:  342:
        -:  343:/// Enum that captures information related to verifier error conditions on
        -:  344:/// slice insert/extract type of ops.
        -:  345:enum class SliceVerificationResult {
        -:  346:  Success,
        -:  347:  RankTooLarge,
        -:  348:  SizeMismatch,
        -:  349:  ElemTypeMismatch,
        -:  350:  // Error codes to ops with a memory space and a layout annotation.
        -:  351:  MemSpaceMismatch,
        -:  352:  LayoutMismatch
        -:  353:};
        -:  354:
        -:  355:/// Check if `originalType` can be rank reduced to `candidateReducedType` type
        -:  356:/// by dropping some dimensions with static size `1`.
        -:  357:/// Return `SliceVerificationResult::Success` on success or an appropriate error
        -:  358:/// code.
        -:  359:SliceVerificationResult isRankReducedType(ShapedType originalType,
        -:  360:                                          ShapedType candidateReducedType);
        -:  361:
        -:  362://===----------------------------------------------------------------------===//
        -:  363:// Deferred Method Definitions
        -:  364://===----------------------------------------------------------------------===//
        -:  365:
        -:  366:inline bool BaseMemRefType::classof(Type type) {
        -:  367:  return type.isa<MemRefType, UnrankedMemRefType>();
        -:  368:}
        -:  369:
        -:  370:inline bool BaseMemRefType::isValidElementType(Type type) {
        -:  371:  return type.isIntOrIndexOrFloat() ||
        -:  372:         type.isa<ComplexType, MemRefType, VectorType, UnrankedMemRefType>() ||
        -:  373:         type.isa<MemRefElementTypeInterface>();
        -:  374:}
        -:  375:
        -:  376:inline bool FloatType::classof(Type type) {
        -:  377:  return type.isa<Float8E5M2Type, BFloat16Type, Float16Type, Float32Type,
        -:  378:                  Float64Type, Float80Type, Float128Type>();
        -:  379:}
        -:  380:
        -:  381:inline FloatType FloatType::getFloat8E5M2(MLIRContext *ctx) {
        -:  382:  return Float8E5M2Type::get(ctx);
        -:  383:}
        -:  384:
        -:  385:inline FloatType FloatType::getBF16(MLIRContext *ctx) {
        -:  386:  return BFloat16Type::get(ctx);
        -:  387:}
        -:  388:
        -:  389:inline FloatType FloatType::getF16(MLIRContext *ctx) {
        -:  390:  return Float16Type::get(ctx);
        -:  391:}
        -:  392:
        -:  393:inline FloatType FloatType::getF32(MLIRContext *ctx) {
        -:  394:  return Float32Type::get(ctx);
        -:  395:}
        -:  396:
        -:  397:inline FloatType FloatType::getF64(MLIRContext *ctx) {
        -:  398:  return Float64Type::get(ctx);
        -:  399:}
        -:  400:
        -:  401:inline FloatType FloatType::getF80(MLIRContext *ctx) {
        -:  402:  return Float80Type::get(ctx);
        -:  403:}
        -:  404:
        -:  405:inline FloatType FloatType::getF128(MLIRContext *ctx) {
        -:  406:  return Float128Type::get(ctx);
        -:  407:}
        -:  408:
    #####:  409:inline bool TensorType::classof(Type type) {
    #####:  410:  return type.isa<RankedTensorType, UnrankedTensorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  411:}
        -:  412:
        -:  413://===----------------------------------------------------------------------===//
        -:  414:// Type Utilities
        -:  415://===----------------------------------------------------------------------===//
        -:  416:
        -:  417:/// Returns the strides of the MemRef if the layout map is in strided form.
        -:  418:/// MemRefs with a layout map in strided form include:
        -:  419:///   1. empty or identity layout map, in which case the stride information is
        -:  420:///      the canonical form computed from sizes;
        -:  421:///   2. a StridedLayoutAttr layout;
        -:  422:///   3. any other layout that be converted into a single affine map layout of
        -:  423:///      the form `K + k0 * d0 + ... kn * dn`, where K and ki's are constants or
        -:  424:///      symbols.
        -:  425:///
        -:  426:/// A stride specification is a list of integer values that are either static
        -:  427:/// or dynamic (encoded with ShapedType::kDynamicStrideOrOffset). Strides encode
        -:  428:/// the distance in the number of elements between successive entries along a
        -:  429:/// particular dimension.
        -:  430:LogicalResult getStridesAndOffset(MemRefType t,
        -:  431:                                  SmallVectorImpl<int64_t> &strides,
        -:  432:                                  int64_t &offset);
        -:  433:
        -:  434:/// Return a version of `t` with identity layout if it can be determined
        -:  435:/// statically that the layout is the canonical contiguous strided layout.
        -:  436:/// Otherwise pass `t`'s layout into `simplifyAffineMap` and return a copy of
        -:  437:/// `t` with simplified layout.
        -:  438:MemRefType canonicalizeStridedLayout(MemRefType t);
        -:  439:
        -:  440:/// Given MemRef `sizes` that are either static or dynamic, returns the
        -:  441:/// canonical "contiguous" strides AffineExpr. Strides are multiplicative and
        -:  442:/// once a dynamic dimension is encountered, all canonical strides become
        -:  443:/// dynamic and need to be encoded with a different symbol.
        -:  444:/// For canonical strides expressions, the offset is always 0 and and fastest
        -:  445:/// varying stride is always `1`.
        -:  446:///
        -:  447:/// Examples:
        -:  448:///   - memref<3x4x5xf32> has canonical stride expression
        -:  449:///         `20*exprs[0] + 5*exprs[1] + exprs[2]`.
        -:  450:///   - memref<3x?x5xf32> has canonical stride expression
        -:  451:///         `s0*exprs[0] + 5*exprs[1] + exprs[2]`.
        -:  452:///   - memref<3x4x?xf32> has canonical stride expression
        -:  453:///         `s1*exprs[0] + s0*exprs[1] + exprs[2]`.
        -:  454:AffineExpr makeCanonicalStridedLayoutExpr(ArrayRef<int64_t> sizes,
        -:  455:                                          ArrayRef<AffineExpr> exprs,
        -:  456:                                          MLIRContext *context);
        -:  457:
        -:  458:/// Return the result of makeCanonicalStrudedLayoutExpr for the common case
        -:  459:/// where `exprs` is {d0, d1, .., d_(sizes.size()-1)}
        -:  460:AffineExpr makeCanonicalStridedLayoutExpr(ArrayRef<int64_t> sizes,
        -:  461:                                          MLIRContext *context);
        -:  462:
        -:  463:/// Return true if the layout for `t` is compatible with strided semantics.
        -:  464:bool isStrided(MemRefType t);
        -:  465:
        -:  466:} // namespace mlir
        -:  467:
        -:  468:#endif // MLIR_IR_BUILTINTYPES_H
