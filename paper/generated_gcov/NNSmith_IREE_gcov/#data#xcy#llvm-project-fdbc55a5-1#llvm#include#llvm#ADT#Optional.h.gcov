        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/ADT/Optional.h
        -:    0:Graph:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- Optional.h - Simple variant for passing optional values --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:///
        -:    9:/// \file
        -:   10:///  This file provides Optional, a template class modeled in the spirit of
        -:   11:///  OCaml's 'opt' variant.  The idea is to strongly type whether or not
        -:   12:///  a value can be optional.
        -:   13:///
        -:   14://===----------------------------------------------------------------------===//
        -:   15:
        -:   16:#ifndef LLVM_ADT_OPTIONAL_H
        -:   17:#define LLVM_ADT_OPTIONAL_H
        -:   18:
        -:   19:#include "llvm/ADT/Hashing.h"
        -:   20:#include "llvm/ADT/None.h"
        -:   21:#include "llvm/ADT/STLForwardCompat.h"
        -:   22:#include "llvm/Support/Compiler.h"
        -:   23:#include "llvm/Support/type_traits.h"
        -:   24:#include <cassert>
        -:   25:#include <new>
        -:   26:#include <utility>
        -:   27:
        -:   28:namespace llvm {
        -:   29:
        -:   30:class raw_ostream;
        -:   31:
        -:   32:namespace optional_detail {
        -:   33:
        -:   34:/// Storage for any type.
        -:   35://
        -:   36:// The specialization condition intentionally uses
        -:   37:// llvm::is_trivially_{copy/move}_constructible instead of
        -:   38:// std::is_trivially_{copy/move}_constructible. GCC versions prior to 7.4 may
        -:   39:// instantiate the copy/move constructor of `T` when
        -:   40:// std::is_trivially_{copy/move}_constructible is instantiated.  This causes
        -:   41:// compilation to fail if we query the trivially copy/move constructible
        -:   42:// property of a class which is not copy/move constructible.
        -:   43://
        -:   44:// The current implementation of OptionalStorage insists that in order to use
        -:   45:// the trivial specialization, the value_type must be trivially copy
        -:   46:// constructible and trivially copy assignable due to =default implementations
        -:   47:// of the copy/move constructor/assignment.  It does not follow that this is
        -:   48:// necessarily the case std::is_trivially_copyable is true (hence the expanded
        -:   49:// specialization condition).
        -:   50://
        -:   51:// The move constructible / assignable conditions emulate the remaining behavior
        -:   52:// of std::is_trivially_copyable.
        -:   53:template <typename T,
        -:   54:          bool = (llvm::is_trivially_copy_constructible<T>::value &&
        -:   55:                  std::is_trivially_copy_assignable<T>::value &&
        -:   56:                  (llvm::is_trivially_move_constructible<T>::value ||
        -:   57:                   !std::is_move_constructible<T>::value) &&
        -:   58:                  (std::is_trivially_move_assignable<T>::value ||
        -:   59:                   !std::is_move_assignable<T>::value))>
        -:   60:class OptionalStorage {
        -:   61:  union {
        -:   62:    char empty;
        -:   63:    T val;
        -:   64:  };
        -:   65:  bool hasVal = false;
        -:   66:
        -:   67:public:
    #####:   68:  ~OptionalStorage() { reset(); }
        -:   69:
        -:   70:  constexpr OptionalStorage() noexcept : empty() {}
        -:   71:
        -:   72:  constexpr OptionalStorage(OptionalStorage const &other) : OptionalStorage() {
        -:   73:    if (other.has_value()) {
        -:   74:      emplace(other.val);
        -:   75:    }
        -:   76:  }
        -:   77:  constexpr OptionalStorage(OptionalStorage &&other) : OptionalStorage() {
        -:   78:    if (other.has_value()) {
        -:   79:      emplace(std::move(other.val));
        -:   80:    }
        -:   81:  }
        -:   82:
        -:   83:  template <class... Args>
        -:   84:  constexpr explicit OptionalStorage(std::in_place_t, Args &&...args)
        -:   85:      : val(std::forward<Args>(args)...), hasVal(true) {}
        -:   86:
    #####:   87:  void reset() noexcept {
    #####:   88:    if (hasVal) {
    #####:   89:      val.~T();
call    0 never executed
        -:   90:      hasVal = false;
        -:   91:    }
        -:   92:  }
        -:   93:
        -:   94:  constexpr bool has_value() const noexcept { return hasVal; }
        -:   95:  LLVM_DEPRECATED("Use has_value instead.", "has_value")
        -:   96:  constexpr bool hasValue() const noexcept {
        -:   97:    return hasVal;
        -:   98:  }
        -:   99:
        -:  100:  T &value() &noexcept {
        -:  101:    assert(hasVal);
        -:  102:    return val;
        -:  103:  }
        -:  104:  LLVM_DEPRECATED("Use value instead.", "value") T &getValue() &noexcept {
        -:  105:    assert(hasVal);
        -:  106:    return val;
        -:  107:  }
        -:  108:  constexpr T const &value() const &noexcept {
        -:  109:    assert(hasVal);
        -:  110:    return val;
        -:  111:  }
        -:  112:  LLVM_DEPRECATED("Use value instead.", "value")
        -:  113:  constexpr T const &getValue() const &noexcept {
        -:  114:    assert(hasVal);
        -:  115:    return val;
        -:  116:  }
        -:  117:  T &&value() &&noexcept {
        -:  118:    assert(hasVal);
        -:  119:    return std::move(val);
        -:  120:  }
        -:  121:  LLVM_DEPRECATED("Use value instead.", "value") T &&getValue() &&noexcept {
        -:  122:    assert(hasVal);
        -:  123:    return std::move(val);
        -:  124:  }
        -:  125:
        -:  126:  template <class... Args> void emplace(Args &&...args) {
        -:  127:    reset();
        -:  128:    ::new ((void *)std::addressof(val)) T(std::forward<Args>(args)...);
        -:  129:    hasVal = true;
        -:  130:  }
        -:  131:
        -:  132:  OptionalStorage &operator=(T const &y) {
        -:  133:    if (has_value()) {
        -:  134:      val = y;
        -:  135:    } else {
        -:  136:      ::new ((void *)std::addressof(val)) T(y);
        -:  137:      hasVal = true;
        -:  138:    }
        -:  139:    return *this;
        -:  140:  }
        -:  141:  OptionalStorage &operator=(T &&y) {
        -:  142:    if (has_value()) {
        -:  143:      val = std::move(y);
        -:  144:    } else {
        -:  145:      ::new ((void *)std::addressof(val)) T(std::move(y));
        -:  146:      hasVal = true;
        -:  147:    }
        -:  148:    return *this;
        -:  149:  }
        -:  150:
        -:  151:  OptionalStorage &operator=(OptionalStorage const &other) {
        -:  152:    if (other.has_value()) {
        -:  153:      if (has_value()) {
        -:  154:        val = other.val;
        -:  155:      } else {
        -:  156:        ::new ((void *)std::addressof(val)) T(other.val);
        -:  157:        hasVal = true;
        -:  158:      }
        -:  159:    } else {
        -:  160:      reset();
        -:  161:    }
        -:  162:    return *this;
        -:  163:  }
        -:  164:
        -:  165:  OptionalStorage &operator=(OptionalStorage &&other) {
        -:  166:    if (other.has_value()) {
        -:  167:      if (has_value()) {
        -:  168:        val = std::move(other.val);
        -:  169:      } else {
        -:  170:        ::new ((void *)std::addressof(val)) T(std::move(other.val));
        -:  171:        hasVal = true;
        -:  172:      }
        -:  173:    } else {
        -:  174:      reset();
        -:  175:    }
        -:  176:    return *this;
        -:  177:  }
        -:  178:};
        -:  179:
        -:  180:template <typename T> class OptionalStorage<T, true> {
        -:  181:  union {
        -:  182:    char empty;
        -:  183:    T val;
        -:  184:  };
        -:  185:  bool hasVal = false;
        -:  186:
        -:  187:public:
        -:  188:  ~OptionalStorage() = default;
        -:  189:
        -:  190:  constexpr OptionalStorage() noexcept : empty{} {}
        -:  191:
        -:  192:  constexpr OptionalStorage(OptionalStorage const &other) = default;
        -:  193:  constexpr OptionalStorage(OptionalStorage &&other) = default;
        -:  194:
        -:  195:  OptionalStorage &operator=(OptionalStorage const &other) = default;
        -:  196:  OptionalStorage &operator=(OptionalStorage &&other) = default;
        -:  197:
        -:  198:  template <class... Args>
        -:  199:  constexpr explicit OptionalStorage(std::in_place_t, Args &&...args)
        -:  200:      : val(std::forward<Args>(args)...), hasVal(true) {}
        -:  201:
        -:  202:  void reset() noexcept {
        -:  203:    if (hasVal) {
        -:  204:      val.~T();
        -:  205:      hasVal = false;
        -:  206:    }
        -:  207:  }
        -:  208:
        -:  209:  constexpr bool has_value() const noexcept { return hasVal; }
        -:  210:  LLVM_DEPRECATED("Use has_value instead.", "has_value")
        -:  211:  constexpr bool hasValue() const noexcept {
        -:  212:    return hasVal;
        -:  213:  }
        -:  214:
        -:  215:  T &value() &noexcept {
        -:  216:    assert(hasVal);
        -:  217:    return val;
        -:  218:  }
        -:  219:  LLVM_DEPRECATED("Use value instead.", "value") T &getValue() &noexcept {
        -:  220:    assert(hasVal);
        -:  221:    return val;
        -:  222:  }
        -:  223:  constexpr T const &value() const &noexcept {
        -:  224:    assert(hasVal);
        -:  225:    return val;
        -:  226:  }
        -:  227:  LLVM_DEPRECATED("Use value instead.", "value")
        -:  228:  constexpr T const &getValue() const &noexcept {
        -:  229:    assert(hasVal);
        -:  230:    return val;
        -:  231:  }
        -:  232:  T &&value() &&noexcept {
        -:  233:    assert(hasVal);
        -:  234:    return std::move(val);
        -:  235:  }
        -:  236:  LLVM_DEPRECATED("Use value instead.", "value") T &&getValue() &&noexcept {
        -:  237:    assert(hasVal);
        -:  238:    return std::move(val);
        -:  239:  }
        -:  240:
        -:  241:  template <class... Args> void emplace(Args &&...args) {
        -:  242:    reset();
        -:  243:    ::new ((void *)std::addressof(val)) T(std::forward<Args>(args)...);
        -:  244:    hasVal = true;
        -:  245:  }
        -:  246:
        -:  247:  OptionalStorage &operator=(T const &y) {
        -:  248:    if (has_value()) {
        -:  249:      val = y;
        -:  250:    } else {
        -:  251:      ::new ((void *)std::addressof(val)) T(y);
        -:  252:      hasVal = true;
        -:  253:    }
        -:  254:    return *this;
        -:  255:  }
        -:  256:  OptionalStorage &operator=(T &&y) {
        -:  257:    if (has_value()) {
        -:  258:      val = std::move(y);
        -:  259:    } else {
        -:  260:      ::new ((void *)std::addressof(val)) T(std::move(y));
        -:  261:      hasVal = true;
        -:  262:    }
        -:  263:    return *this;
        -:  264:  }
        -:  265:};
        -:  266:
        -:  267:} // namespace optional_detail
        -:  268:
    #####:  269:template <typename T> class Optional {
branch  0 never executed
branch  1 never executed
        -:  270:  optional_detail::OptionalStorage<T> Storage;
        -:  271:
        -:  272:public:
        -:  273:  using value_type = T;
        -:  274:
        -:  275:  constexpr Optional() = default;
        -:  276:  constexpr Optional(NoneType) {}
        -:  277:
        -:  278:  constexpr Optional(const T &y) : Storage(std::in_place, y) {}
        -:  279:  constexpr Optional(const Optional &O) = default;
        -:  280:
        -:  281:  constexpr Optional(T &&y) : Storage(std::in_place, std::move(y)) {}
        -:  282:  constexpr Optional(Optional &&O) = default;
        -:  283:
        -:  284:  template <typename... ArgTypes>
        -:  285:  constexpr Optional(std::in_place_t, ArgTypes &&...Args)
        -:  286:      : Storage(std::in_place, std::forward<ArgTypes>(Args)...) {}
        -:  287:
        -:  288:  Optional &operator=(T &&y) {
        -:  289:    Storage = std::move(y);
        -:  290:    return *this;
        -:  291:  }
        -:  292:  Optional &operator=(Optional &&O) = default;
        -:  293:
        -:  294:  /// Create a new object by constructing it in place with the given arguments.
        -:  295:  template <typename... ArgTypes> void emplace(ArgTypes &&... Args) {
        -:  296:    Storage.emplace(std::forward<ArgTypes>(Args)...);
        -:  297:  }
        -:  298:
        -:  299:  static constexpr Optional create(const T *y) {
        -:  300:    return y ? Optional(*y) : Optional();
        -:  301:  }
        -:  302:
        -:  303:  Optional &operator=(const T &y) {
        -:  304:    Storage = y;
        -:  305:    return *this;
        -:  306:  }
        -:  307:  Optional &operator=(const Optional &O) = default;
        -:  308:
        -:  309:  void reset() { Storage.reset(); }
        -:  310:
        -:  311:  constexpr const T *getPointer() const { return &Storage.value(); }
        -:  312:  T *getPointer() { return &Storage.value(); }
        -:  313:  constexpr const T &value() const & { return Storage.value(); }
        -:  314:  LLVM_DEPRECATED("Use value instead.", "value")
        -:  315:  constexpr const T &getValue() const & {
        -:  316:    return Storage.value();
        -:  317:  }
        -:  318:  T &value() & { return Storage.value(); }
        -:  319:  LLVM_DEPRECATED("Use value instead.", "value") T &getValue() & {
        -:  320:    return Storage.value();
        -:  321:  }
        -:  322:
        -:  323:  constexpr explicit operator bool() const { return has_value(); }
        -:  324:  constexpr bool has_value() const { return Storage.has_value(); }
        -:  325:  LLVM_DEPRECATED("Use has_value instead.", "has_value")
        -:  326:  constexpr bool hasValue() const {
        -:  327:    return Storage.has_value();
        -:  328:  }
        -:  329:  constexpr const T *operator->() const { return getPointer(); }
        -:  330:  T *operator->() { return getPointer(); }
        -:  331:  constexpr const T &operator*() const & { return value(); }
        -:  332:  T &operator*() & { return value(); }
        -:  333:
        -:  334:  template <typename U> constexpr T value_or(U &&alt) const & {
        -:  335:    return has_value() ? value() : std::forward<U>(alt);
        -:  336:  }
        -:  337:  template <typename U>
        -:  338:  LLVM_DEPRECATED("Use value_or instead.", "value_or")
        -:  339:  constexpr T getValueOr(U &&alt) const & {
        -:  340:    return has_value() ? value() : std::forward<U>(alt);
        -:  341:  }
        -:  342:
        -:  343:  /// Apply a function to the value if present; otherwise return None.
        -:  344:  template <class Function>
        -:  345:  auto transform(const Function &F) const & -> Optional<decltype(F(value()))> {
        -:  346:    if (*this)
        -:  347:      return F(value());
        -:  348:    return None;
        -:  349:  }
        -:  350:  template <class Function>
        -:  351:  LLVM_DEPRECATED("Use transform instead.", "transform")
        -:  352:  auto map(const Function &F) const & -> Optional<decltype(F(value()))> {
        -:  353:    if (*this)
        -:  354:      return F(value());
        -:  355:    return None;
        -:  356:  }
        -:  357:
        -:  358:  T &&value() && { return std::move(Storage.value()); }
        -:  359:  LLVM_DEPRECATED("Use value instead.", "value") T &&getValue() && {
        -:  360:    return std::move(Storage.value());
        -:  361:  }
        -:  362:  T &&operator*() && { return std::move(Storage.value()); }
        -:  363:
        -:  364:  template <typename U> T value_or(U &&alt) && {
        -:  365:    return has_value() ? std::move(value()) : std::forward<U>(alt);
        -:  366:  }
        -:  367:  template <typename U>
        -:  368:  LLVM_DEPRECATED("Use value_or instead.", "value_or")
        -:  369:  T getValueOr(U &&alt) && {
        -:  370:    return has_value() ? std::move(value()) : std::forward<U>(alt);
        -:  371:  }
        -:  372:
        -:  373:  /// Apply a function to the value if present; otherwise return None.
        -:  374:  template <class Function>
        -:  375:  auto transform(
        -:  376:      const Function &F) && -> Optional<decltype(F(std::move(*this).value()))> {
        -:  377:    if (*this)
        -:  378:      return F(std::move(*this).value());
        -:  379:    return None;
        -:  380:  }
        -:  381:  template <class Function>
        -:  382:  LLVM_DEPRECATED("Use transform instead.", "transform")
        -:  383:  auto map(const Function &F)
        -:  384:      && -> Optional<decltype(F(std::move(*this).value()))> {
        -:  385:    if (*this)
        -:  386:      return F(std::move(*this).value());
        -:  387:    return None;
        -:  388:  }
        -:  389:};
        -:  390:
        -:  391:template<typename T>
        -:  392:Optional(const T&) -> Optional<T>;
        -:  393:
        -:  394:template <class T> llvm::hash_code hash_value(const Optional<T> &O) {
        -:  395:  return O ? hash_combine(true, *O) : hash_value(false);
        -:  396:}
        -:  397:
        -:  398:template <typename T, typename U>
        -:  399:constexpr bool operator==(const Optional<T> &X, const Optional<U> &Y) {
        -:  400:  if (X && Y)
        -:  401:    return *X == *Y;
        -:  402:  return X.has_value() == Y.has_value();
        -:  403:}
        -:  404:
        -:  405:template <typename T, typename U>
        -:  406:constexpr bool operator!=(const Optional<T> &X, const Optional<U> &Y) {
        -:  407:  return !(X == Y);
        -:  408:}
        -:  409:
        -:  410:template <typename T, typename U>
        -:  411:constexpr bool operator<(const Optional<T> &X, const Optional<U> &Y) {
        -:  412:  if (X && Y)
        -:  413:    return *X < *Y;
        -:  414:  return X.has_value() < Y.has_value();
        -:  415:}
        -:  416:
        -:  417:template <typename T, typename U>
        -:  418:constexpr bool operator<=(const Optional<T> &X, const Optional<U> &Y) {
        -:  419:  return !(Y < X);
        -:  420:}
        -:  421:
        -:  422:template <typename T, typename U>
        -:  423:constexpr bool operator>(const Optional<T> &X, const Optional<U> &Y) {
        -:  424:  return Y < X;
        -:  425:}
        -:  426:
        -:  427:template <typename T, typename U>
        -:  428:constexpr bool operator>=(const Optional<T> &X, const Optional<U> &Y) {
        -:  429:  return !(X < Y);
        -:  430:}
        -:  431:
        -:  432:template <typename T>
        -:  433:constexpr bool operator==(const Optional<T> &X, NoneType) {
        -:  434:  return !X;
        -:  435:}
        -:  436:
        -:  437:template <typename T>
        -:  438:constexpr bool operator==(NoneType, const Optional<T> &X) {
        -:  439:  return X == None;
        -:  440:}
        -:  441:
        -:  442:template <typename T>
        -:  443:constexpr bool operator!=(const Optional<T> &X, NoneType) {
        -:  444:  return !(X == None);
        -:  445:}
        -:  446:
        -:  447:template <typename T>
        -:  448:constexpr bool operator!=(NoneType, const Optional<T> &X) {
        -:  449:  return X != None;
        -:  450:}
        -:  451:
        -:  452:template <typename T> constexpr bool operator<(const Optional<T> &, NoneType) {
        -:  453:  return false;
        -:  454:}
        -:  455:
        -:  456:template <typename T> constexpr bool operator<(NoneType, const Optional<T> &X) {
        -:  457:  return X.has_value();
        -:  458:}
        -:  459:
        -:  460:template <typename T>
        -:  461:constexpr bool operator<=(const Optional<T> &X, NoneType) {
        -:  462:  return !(None < X);
        -:  463:}
        -:  464:
        -:  465:template <typename T>
        -:  466:constexpr bool operator<=(NoneType, const Optional<T> &X) {
        -:  467:  return !(X < None);
        -:  468:}
        -:  469:
        -:  470:template <typename T> constexpr bool operator>(const Optional<T> &X, NoneType) {
        -:  471:  return None < X;
        -:  472:}
        -:  473:
        -:  474:template <typename T> constexpr bool operator>(NoneType, const Optional<T> &X) {
        -:  475:  return X < None;
        -:  476:}
        -:  477:
        -:  478:template <typename T>
        -:  479:constexpr bool operator>=(const Optional<T> &X, NoneType) {
        -:  480:  return None <= X;
        -:  481:}
        -:  482:
        -:  483:template <typename T>
        -:  484:constexpr bool operator>=(NoneType, const Optional<T> &X) {
        -:  485:  return X <= None;
        -:  486:}
        -:  487:
        -:  488:template <typename T>
        -:  489:constexpr bool operator==(const Optional<T> &X, const T &Y) {
        -:  490:  return X && *X == Y;
        -:  491:}
        -:  492:
        -:  493:template <typename T>
        -:  494:constexpr bool operator==(const T &X, const Optional<T> &Y) {
        -:  495:  return Y && X == *Y;
        -:  496:}
        -:  497:
        -:  498:template <typename T>
        -:  499:constexpr bool operator!=(const Optional<T> &X, const T &Y) {
        -:  500:  return !(X == Y);
        -:  501:}
        -:  502:
        -:  503:template <typename T>
        -:  504:constexpr bool operator!=(const T &X, const Optional<T> &Y) {
        -:  505:  return !(X == Y);
        -:  506:}
        -:  507:
        -:  508:template <typename T>
        -:  509:constexpr bool operator<(const Optional<T> &X, const T &Y) {
        -:  510:  return !X || *X < Y;
        -:  511:}
        -:  512:
        -:  513:template <typename T>
        -:  514:constexpr bool operator<(const T &X, const Optional<T> &Y) {
        -:  515:  return Y && X < *Y;
        -:  516:}
        -:  517:
        -:  518:template <typename T>
        -:  519:constexpr bool operator<=(const Optional<T> &X, const T &Y) {
        -:  520:  return !(Y < X);
        -:  521:}
        -:  522:
        -:  523:template <typename T>
        -:  524:constexpr bool operator<=(const T &X, const Optional<T> &Y) {
        -:  525:  return !(Y < X);
        -:  526:}
        -:  527:
        -:  528:template <typename T>
        -:  529:constexpr bool operator>(const Optional<T> &X, const T &Y) {
        -:  530:  return Y < X;
        -:  531:}
        -:  532:
        -:  533:template <typename T>
        -:  534:constexpr bool operator>(const T &X, const Optional<T> &Y) {
        -:  535:  return Y < X;
        -:  536:}
        -:  537:
        -:  538:template <typename T>
        -:  539:constexpr bool operator>=(const Optional<T> &X, const T &Y) {
        -:  540:  return !(X < Y);
        -:  541:}
        -:  542:
        -:  543:template <typename T>
        -:  544:constexpr bool operator>=(const T &X, const Optional<T> &Y) {
        -:  545:  return !(X < Y);
        -:  546:}
        -:  547:
        -:  548:raw_ostream &operator<<(raw_ostream &OS, NoneType);
        -:  549:
        -:  550:template <typename T, typename = decltype(std::declval<raw_ostream &>()
        -:  551:                                          << std::declval<const T &>())>
        -:  552:raw_ostream &operator<<(raw_ostream &OS, const Optional<T> &O) {
        -:  553:  if (O)
        -:  554:    OS << *O;
        -:  555:  else
        -:  556:    OS << None;
        -:  557:  return OS;
        -:  558:}
        -:  559:
        -:  560:} // end namespace llvm
        -:  561:
        -:  562:#endif // LLVM_ADT_OPTIONAL_H
