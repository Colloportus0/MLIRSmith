        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/include/mlir/Conversion/LLVMCommon/TypeConverter.h
        -:    0:Graph:../tools/mlir/lib/Conversion/GPUToROCDL/CMakeFiles/obj.MLIRGPUToROCDLTransforms.dir/LowerGpuOpsToROCDLOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/GPUToROCDL/CMakeFiles/obj.MLIRGPUToROCDLTransforms.dir/LowerGpuOpsToROCDLOps.cpp.gcda
        -:    0:Runs:325556
        -:    1://===- TypeConverter.h - Convert builtin to LLVM dialect types --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Provides a type converter configuration for converting most builtin types to
        -:   10:// LLVM dialect types.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef MLIR_CONVERSION_LLVMCOMMON_TYPECONVERTER_H
        -:   15:#define MLIR_CONVERSION_LLVMCOMMON_TYPECONVERTER_H
        -:   16:
        -:   17:#include "mlir/Conversion/LLVMCommon/LoweringOptions.h"
        -:   18:#include "mlir/Transforms/DialectConversion.h"
        -:   19:
        -:   20:namespace mlir {
        -:   21:
        -:   22:class DataLayoutAnalysis;
        -:   23:class LowerToLLVMOptions;
        -:   24:
        -:   25:namespace LLVM {
        -:   26:class LLVMDialect;
        -:   27:} // namespace LLVM
        -:   28:
        -:   29:/// Conversion from types to the LLVM IR dialect.
    #####:   30:class LLVMTypeConverter : public TypeConverter {
call    0 never executed
call    1 never executed
call    2 never executed
        -:   31:  /// Give structFuncArgTypeConverter access to memref-specific functions.
        -:   32:  friend LogicalResult
        -:   33:  structFuncArgTypeConverter(LLVMTypeConverter &converter, Type type,
        -:   34:                             SmallVectorImpl<Type> &result);
        -:   35:
        -:   36:public:
        -:   37:  using TypeConverter::convertType;
        -:   38:
        -:   39:  /// Create an LLVMTypeConverter using the default LowerToLLVMOptions.
        -:   40:  /// Optionally takes a data layout analysis to use in conversions.
        -:   41:  LLVMTypeConverter(MLIRContext *ctx,
        -:   42:                    const DataLayoutAnalysis *analysis = nullptr);
        -:   43:
        -:   44:  /// Create an LLVMTypeConverter using custom LowerToLLVMOptions. Optionally
        -:   45:  /// takes a data layout analysis to use in conversions.
        -:   46:  LLVMTypeConverter(MLIRContext *ctx, const LowerToLLVMOptions &options,
        -:   47:                    const DataLayoutAnalysis *analysis = nullptr);
        -:   48:
        -:   49:  /// Convert a function type.  The arguments and results are converted one by
        -:   50:  /// one and results are packed into a wrapped LLVM IR structure type. `result`
        -:   51:  /// is populated with argument mapping.
        -:   52:  Type convertFunctionSignature(FunctionType funcTy, bool isVariadic,
        -:   53:                                SignatureConversion &result);
        -:   54:
        -:   55:  /// Convert a non-empty list of types to be returned from a function into a
        -:   56:  /// supported LLVM IR type.  In particular, if more than one value is
        -:   57:  /// returned, create an LLVM IR structure type with elements that correspond
        -:   58:  /// to each of the MLIR types converted with `convertType`.
        -:   59:  Type packFunctionResults(TypeRange types);
        -:   60:
        -:   61:  /// Convert a type in the context of the default or bare pointer calling
        -:   62:  /// convention. Calling convention sensitive types, such as MemRefType and
        -:   63:  /// UnrankedMemRefType, are converted following the specific rules for the
        -:   64:  /// calling convention. Calling convention independent types are converted
        -:   65:  /// following the default LLVM type conversions.
        -:   66:  Type convertCallingConventionType(Type type);
        -:   67:
        -:   68:  /// Promote the bare pointers in 'values' that resulted from memrefs to
        -:   69:  /// descriptors. 'stdTypes' holds the types of 'values' before the conversion
        -:   70:  /// to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type).
        -:   71:  void promoteBarePtrsToDescriptors(ConversionPatternRewriter &rewriter,
        -:   72:                                    Location loc, ArrayRef<Type> stdTypes,
        -:   73:                                    SmallVectorImpl<Value> &values);
        -:   74:
        -:   75:  /// Returns the MLIR context.
        -:   76:  MLIRContext &getContext();
        -:   77:
        -:   78:  /// Returns the LLVM dialect.
        -:   79:  LLVM::LLVMDialect *getDialect() { return llvmDialect; }
        -:   80:
        -:   81:  const LowerToLLVMOptions &getOptions() const { return options; }
        -:   82:
        -:   83:  /// Set the lowering options to `newOptions`. Note: using this after some
        -:   84:  /// some conversions have been performed can lead to inconsistencies in the
        -:   85:  /// IR.
        -:   86:  void dangerousSetOptions(LowerToLLVMOptions newOptions) {
        -:   87:    options = std::move(newOptions);
        -:   88:  }
        -:   89:
        -:   90:  /// Promote the LLVM representation of all operands including promoting MemRef
        -:   91:  /// descriptors to stack and use pointers to struct to avoid the complexity
        -:   92:  /// of the platform-specific C/C++ ABI lowering related to struct argument
        -:   93:  /// passing.
        -:   94:  SmallVector<Value, 4> promoteOperands(Location loc, ValueRange opOperands,
        -:   95:                                        ValueRange operands,
        -:   96:                                        OpBuilder &builder);
        -:   97:
        -:   98:  /// Promote the LLVM struct representation of one MemRef descriptor to stack
        -:   99:  /// and use pointer to struct to avoid the complexity of the platform-specific
        -:  100:  /// C/C++ ABI lowering related to struct argument passing.
        -:  101:  Value promoteOneMemRefDescriptor(Location loc, Value operand,
        -:  102:                                   OpBuilder &builder);
        -:  103:
        -:  104:  /// Converts the function type to a C-compatible format, in particular using
        -:  105:  /// pointers to memref descriptors for arguments. Also converts the return
        -:  106:  /// type to a pointer argument if it is a struct. Returns true if this
        -:  107:  /// was the case.
        -:  108:  std::pair<Type, bool> convertFunctionTypeCWrapper(FunctionType type);
        -:  109:
        -:  110:  /// Returns the data layout to use during and after conversion.
        -:  111:  const llvm::DataLayout &getDataLayout() { return options.dataLayout; }
        -:  112:
        -:  113:  /// Returns the data layout analysis to query during conversion.
        -:  114:  const DataLayoutAnalysis *getDataLayoutAnalysis() const {
        -:  115:    return dataLayoutAnalysis;
        -:  116:  }
        -:  117:
        -:  118:  /// Gets the LLVM representation of the index type. The returned type is an
        -:  119:  /// integer type with the size configured for this type converter.
        -:  120:  Type getIndexType();
        -:  121:
        -:  122:  /// Gets the bitwidth of the index type when converted to LLVM.
    #####:  123:  unsigned getIndexTypeBitwidth() { return options.getIndexBitwidth(); }
        -:  124:
        -:  125:  /// Gets the pointer bitwidth.
        -:  126:  unsigned getPointerBitwidth(unsigned addressSpace = 0);
        -:  127:
        -:  128:  /// Returns the size of the memref descriptor object in bytes.
        -:  129:  unsigned getMemRefDescriptorSize(MemRefType type, const DataLayout &layout);
        -:  130:
        -:  131:  /// Returns the size of the unranked memref descriptor object in bytes.
        -:  132:  unsigned getUnrankedMemRefDescriptorSize(UnrankedMemRefType type,
        -:  133:                                           const DataLayout &layout);
        -:  134:
        -:  135:  /// Check if a memref type can be converted to a bare pointer.
        -:  136:  static bool canConvertToBarePtr(BaseMemRefType type);
        -:  137:
        -:  138:protected:
        -:  139:  /// Pointer to the LLVM dialect.
        -:  140:  LLVM::LLVMDialect *llvmDialect;
        -:  141:
        -:  142:private:
        -:  143:  /// Convert a function type.  The arguments and results are converted one by
        -:  144:  /// one.  Additionally, if the function returns more than one value, pack the
        -:  145:  /// results into an LLVM IR structure type so that the converted function type
        -:  146:  /// returns at most one result.
        -:  147:  Type convertFunctionType(FunctionType type);
        -:  148:
        -:  149:  /// Convert the index type.  Uses llvmModule data layout to create an integer
        -:  150:  /// of the pointer bitwidth.
        -:  151:  Type convertIndexType(IndexType type);
        -:  152:
        -:  153:  /// Convert an integer type `i*` to `!llvm<"i*">`.
        -:  154:  Type convertIntegerType(IntegerType type);
        -:  155:
        -:  156:  /// Convert a floating point type: `f16` to `f16`, `f32` to
        -:  157:  /// `f32` and `f64` to `f64`.  `bf16` is not supported
        -:  158:  /// by LLVM.
        -:  159:  Type convertFloatType(FloatType type);
        -:  160:
        -:  161:  /// Convert complex number type: `complex<f16>` to `!llvm<"{ half, half }">`,
        -:  162:  /// `complex<f32>` to `!llvm<"{ float, float }">`, and `complex<f64>` to
        -:  163:  /// `!llvm<"{ double, double }">`. `complex<bf16>` is not supported.
        -:  164:  Type convertComplexType(ComplexType type);
        -:  165:
        -:  166:  /// Convert a memref type into an LLVM type that captures the relevant data.
        -:  167:  Type convertMemRefType(MemRefType type);
        -:  168:
        -:  169:  /// Convert a memref type into a list of LLVM IR types that will form the
        -:  170:  /// memref descriptor. If `unpackAggregates` is true the `sizes` and `strides`
        -:  171:  /// arrays in the descriptors are unpacked to individual index-typed elements,
        -:  172:  /// else they are are kept as rank-sized arrays of index type. In particular,
        -:  173:  /// the list will contain:
        -:  174:  /// - two pointers to the memref element type, followed by
        -:  175:  /// - an index-typed offset, followed by
        -:  176:  /// - (if unpackAggregates = true)
        -:  177:  ///    - one index-typed size per dimension of the memref, followed by
        -:  178:  ///    - one index-typed stride per dimension of the memref.
        -:  179:  /// - (if unpackArrregates = false)
        -:  180:  ///   - one rank-sized array of index-type for the size of each dimension
        -:  181:  ///   - one rank-sized array of index-type for the stride of each dimension
        -:  182:  ///
        -:  183:  /// For example, memref<?x?xf32> is converted to the following list:
        -:  184:  /// - `!llvm<"float*">` (allocated pointer),
        -:  185:  /// - `!llvm<"float*">` (aligned pointer),
        -:  186:  /// - `i64` (offset),
        -:  187:  /// - `i64`, `i64` (sizes),
        -:  188:  /// - `i64`, `i64` (strides).
        -:  189:  /// These types can be recomposed to a memref descriptor struct.
        -:  190:  SmallVector<Type, 5> getMemRefDescriptorFields(MemRefType type,
        -:  191:                                                 bool unpackAggregates);
        -:  192:
        -:  193:  /// Convert an unranked memref type into a list of non-aggregate LLVM IR types
        -:  194:  /// that will form the unranked memref descriptor. In particular, this list
        -:  195:  /// contains:
        -:  196:  /// - an integer rank, followed by
        -:  197:  /// - a pointer to the memref descriptor struct.
        -:  198:  /// For example, memref<*xf32> is converted to the following list:
        -:  199:  /// i64 (rank)
        -:  200:  /// !llvm<"i8*"> (type-erased pointer).
        -:  201:  /// These types can be recomposed to a unranked memref descriptor struct.
        -:  202:  SmallVector<Type, 2> getUnrankedMemRefDescriptorFields();
        -:  203:
        -:  204:  /// Convert an unranked memref type to an LLVM type that captures the
        -:  205:  /// runtime rank and a pointer to the static ranked memref desc
        -:  206:  Type convertUnrankedMemRefType(UnrankedMemRefType type);
        -:  207:
        -:  208:  /// Convert a memref type to a bare pointer to the memref element type.
        -:  209:  Type convertMemRefToBarePtr(BaseMemRefType type);
        -:  210:
        -:  211:  /// Convert a 1D vector type into an LLVM vector type.
        -:  212:  Type convertVectorType(VectorType type);
        -:  213:
        -:  214:  /// Options for customizing the llvm lowering.
        -:  215:  LowerToLLVMOptions options;
        -:  216:
        -:  217:  /// Data layout analysis mapping scopes to layouts active in them.
        -:  218:  const DataLayoutAnalysis *dataLayoutAnalysis;
        -:  219:};
        -:  220:
        -:  221:/// Callback to convert function argument types. It converts a MemRef function
        -:  222:/// argument to a list of non-aggregate types containing descriptor
        -:  223:/// information, and an UnrankedmemRef function argument to a list containing
        -:  224:/// the rank and a pointer to a descriptor struct.
        -:  225:LogicalResult structFuncArgTypeConverter(LLVMTypeConverter &converter,
        -:  226:                                         Type type,
        -:  227:                                         SmallVectorImpl<Type> &result);
        -:  228:
        -:  229:/// Callback to convert function argument types. It converts MemRef function
        -:  230:/// arguments to bare pointers to the MemRef element type.
        -:  231:LogicalResult barePtrFuncArgTypeConverter(LLVMTypeConverter &converter,
        -:  232:                                          Type type,
        -:  233:                                          SmallVectorImpl<Type> &result);
        -:  234:
        -:  235:} // namespace mlir
        -:  236:
        -:  237:#endif // MLIR_CONVERSION_LLVMCOMMON_TYPECONVERTER_H
