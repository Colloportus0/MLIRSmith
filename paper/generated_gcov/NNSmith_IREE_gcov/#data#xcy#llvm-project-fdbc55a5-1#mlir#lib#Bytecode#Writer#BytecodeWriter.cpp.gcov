        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Bytecode/Writer/BytecodeWriter.cpp
        -:    0:Graph:../tools/mlir/lib/Bytecode/Writer/CMakeFiles/obj.MLIRBytecodeWriter.dir/BytecodeWriter.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Bytecode/Writer/CMakeFiles/obj.MLIRBytecodeWriter.dir/BytecodeWriter.cpp.gcda
        -:    0:Runs:325597
        -:    1://===- BytecodeWriter.cpp - MLIR Bytecode Writer --------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Bytecode/BytecodeWriter.h"
        -:   10:#include "../Encoding.h"
        -:   11:#include "IRNumbering.h"
        -:   12:#include "mlir/Bytecode/BytecodeImplementation.h"
        -:   13:#include "mlir/IR/BuiltinDialect.h"
        -:   14:#include "mlir/IR/OpImplementation.h"
        -:   15:#include "llvm/ADT/CachedHashString.h"
        -:   16:#include "llvm/ADT/MapVector.h"
        -:   17:#include "llvm/ADT/SmallString.h"
        -:   18:#include "llvm/Support/Debug.h"
        -:   19:#include <random>
        -:   20:
        -:   21:#define DEBUG_TYPE "mlir-bytecode-writer"
        -:   22:
        -:   23:using namespace mlir;
        -:   24:using namespace mlir::bytecode::detail;
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// BytecodeWriterConfig
        -:   28://===----------------------------------------------------------------------===//
        -:   29:
        -:   30:struct BytecodeWriterConfig::Impl {
     804*:   31:  Impl(StringRef producer) : producer(producer) {}
call    0 returned 100%
        -:   32:
        -:   33:  /// The producer of the bytecode.
        -:   34:  StringRef producer;
        -:   35:
        -:   36:  /// A collection of non-dialect resource printers.
        -:   37:  SmallVector<std::unique_ptr<AsmResourcePrinter>> externalResourcePrinters;
        -:   38:};
        -:   39:
function _ZN4mlir20BytecodeWriterConfigC2EN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   40:BytecodeWriterConfig::BytecodeWriterConfig(StringRef producer)
call    0 never executed
     804*:   41:    : impl(std::make_unique<Impl>(producer)) {}
function _ZN4mlir20BytecodeWriterConfigC2ERNS_22FallbackAsmResourceMapEN4llvm9StringRefE called 804 returned 100% blocks executed 100%
      804:   42:BytecodeWriterConfig::BytecodeWriterConfig(FallbackAsmResourceMap &map,
      804:   43:                                           StringRef producer)
call    0 returned 100%
      804:   44:    : BytecodeWriterConfig(producer) {
      804:   45:  attachFallbackResourcePrinter(map);
call    0 returned 100%
      804:   46:}
        -:   47:BytecodeWriterConfig::~BytecodeWriterConfig() = default;
        -:   48:
function _ZN4mlir20BytecodeWriterConfig21attachResourcePrinterESt10unique_ptrINS_18AsmResourcePrinterESt14default_deleteIS2_EE called 0 returned 0% blocks executed 0%
    #####:   49:void BytecodeWriterConfig::attachResourcePrinter(
        -:   50:    std::unique_ptr<AsmResourcePrinter> printer) {
    #####:   51:  impl->externalResourcePrinters.emplace_back(std::move(printer));
call    0 never executed
call    1 never executed
    #####:   52:}
        -:   53:
        -:   54://===----------------------------------------------------------------------===//
        -:   55:// EncodingEmitter
        -:   56://===----------------------------------------------------------------------===//
        -:   57:
        -:   58:namespace {
        -:   59:/// This class functions as the underlying encoding emitter for the bytecode
        -:   60:/// writer. This class is a bit different compared to other types of encoders;
        -:   61:/// it does not use a single buffer, but instead may contain several buffers
        -:   62:/// (some owned by the writer, and some not) that get concatted during the final
        -:   63:/// emission.
        -:   64:class EncodingEmitter {
        -:   65:public:
     4824:   66:  EncodingEmitter() = default;
        -:   67:  EncodingEmitter(const EncodingEmitter &) = delete;
        -:   68:  EncodingEmitter &operator=(const EncodingEmitter &) = delete;
        -:   69:
        -:   70:  /// Write the current contents to the provided stream.
        -:   71:  void writeTo(raw_ostream &os) const;
        -:   72:
        -:   73:  /// Return the current size of the encoded buffer.
   75827*:   74:  size_t size() const { return prevResultSize + currentResult.size(); }
        -:   75:
        -:   76:  //===--------------------------------------------------------------------===//
        -:   77:  // Emission
        -:   78:  //===--------------------------------------------------------------------===//
        -:   79:
        -:   80:  /// Backpatch a byte in the result buffer at the given offset.
function _ZN12_GLOBAL__N_115EncodingEmitter9patchByteEmh called 10688 returned 100% blocks executed 75%
    10688:   81:  void patchByte(uint64_t offset, uint8_t value) {
   10688*:   82:    assert(offset < size() && offset >= prevResultSize &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:   83:           "cannot patch previously emitted data");
    10688:   84:    currentResult[offset - prevResultSize] = value;
    10688:   85:  }
        -:   86:
        -:   87:  /// Emit the provided blob of data, which is owned by the caller and is
        -:   88:  /// guaranteed to not die before the end of the bytecode process.
function _ZN12_GLOBAL__N_115EncodingEmitter13emitOwnedBlobEN4llvm8ArrayRefIhEE called 2335 returned 100% blocks executed 100%
     2335:   89:  void emitOwnedBlob(ArrayRef<uint8_t> data) {
        -:   90:    // Push the current buffer before adding the provided data.
     2335:   91:    appendResult(std::move(currentResult));
call    0 returned 100%
     4670:   92:    appendOwnedResult(data);
     2335:   93:  }
        -:   94:
        -:   95:  /// Emit the provided blob of data that has the given alignment, which is
        -:   96:  /// owned by the caller and is guaranteed to not die before the end of the
        -:   97:  /// bytecode process. The alignment value is also encoded, making it available
        -:   98:  /// on load.
function _ZN12_GLOBAL__N_115EncodingEmitter25emitOwnedBlobAndAlignmentEN4llvm8ArrayRefIhEEj called 0 returned 0% blocks executed 0%
    #####:   99:  void emitOwnedBlobAndAlignment(ArrayRef<uint8_t> data, uint32_t alignment) {
    #####:  100:    emitVarInt(alignment);
call    0 never executed
    #####:  101:    emitVarInt(data.size());
call    0 never executed
        -:  102:
    #####:  103:    alignTo(alignment);
call    0 never executed
    #####:  104:    emitOwnedBlob(data);
call    0 never executed
    #####:  105:  }
    #####:  106:  void emitOwnedBlobAndAlignment(ArrayRef<char> data, uint32_t alignment) {
    #####:  107:    ArrayRef<uint8_t> castedData(reinterpret_cast<const uint8_t *>(data.data()),
    #####:  108:                                 data.size());
    #####:  109:    emitOwnedBlobAndAlignment(castedData, alignment);
call    0 never executed
        -:  110:  }
        -:  111:
        -:  112:  /// Align the emitter to the given alignment.
function _ZN12_GLOBAL__N_115EncodingEmitter7alignToEj called 0 returned 0% blocks executed 0%
    #####:  113:  void alignTo(unsigned alignment) {
    #####:  114:    if (alignment < 2)
branch  0 never executed
branch  1 never executed
        -:  115:      return;
    #####:  116:    assert(llvm::isPowerOf2_32(alignment) && "expected valid alignment");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  117:
        -:  118:    // Check to see if we need to emit any padding bytes to meet the desired
        -:  119:    // alignment.
    #####:  120:    size_t curOffset = size();
    #####:  121:    size_t paddingSize = llvm::alignTo(curOffset, alignment) - curOffset;
    #####:  122:    while (paddingSize--)
    #####:  123:      emitByte(bytecode::kAlignmentByte);
branch  0 never executed
branch  1 never executed
        -:  124:
        -:  125:    // Keep track of the maximum required alignment.
    #####:  126:    requiredAlignment = std::max(requiredAlignment, alignment);
branch  0 never executed
branch  1 never executed
        -:  127:  }
        -:  128:
        -:  129:  //===--------------------------------------------------------------------===//
        -:  130:  // Integer Emission
        -:  131:
        -:  132:  /// Emit a single byte.
        -:  133:  template <typename T>
  381619*:  134:  void emitByte(T byte) {
    #####:  135:    currentResult.push_back(static_cast<uint8_t>(byte));
call    0 never executed
      54*:  136:  }
        -:  137:
        -:  138:  /// Emit a range of bytes.
   26250*:  139:  void emitBytes(ArrayRef<uint8_t> bytes) {
   26250*:  140:    llvm::append_range(currentResult, bytes);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
call    3 returned 100%
call    4 returned 100%
        -:  141:  }
        -:  142:
        -:  143:  /// Emit a variable length integer. The first encoded byte contains a prefix
        -:  144:  /// in the low bits indicating the encoded length of the value. This length
        -:  145:  /// prefix is a bit sequence of '0's followed by a '1'. The number of '0' bits
        -:  146:  /// indicate the number of _additional_ bytes (not including the prefix byte).
        -:  147:  /// All remaining bits in the first byte, along with all of the bits in
        -:  148:  /// additional bytes, provide the value of the integer encoded in
        -:  149:  /// little-endian order.
function _ZN12_GLOBAL__N_115EncodingEmitter10emitVarIntEm called 347077 returned 100% blocks executed 100%
   348101:  150:  void emitVarInt(uint64_t value) {
        -:  151:    // In the most common case, the value can be represented in a single byte.
        -:  152:    // Given how hot this case is, explicitly handle that here.
   347077:  153:    if ((value >> 7) == 0)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   343171:  154:      return emitByte((value << 1) | 0x1);
call    0 returned 100%
     3906:  155:    emitMultiByteVarInt(value);
call    0 returned 100%
        -:  156:  }
        -:  157:
        -:  158:  /// Emit a signed variable length integer. Signed varints are encoded using
        -:  159:  /// a varint with zigzag encoding, meaning that we use the low bit of the
        -:  160:  /// value to indicate the sign of the value. This allows for more efficient
        -:  161:  /// encoding of negative values by limiting the number of active bits
   16675*:  162:  void emitSignedVarInt(uint64_t value) {
   16675*:  163:    emitVarInt((value << 1) ^ (uint64_t)((int64_t)value >> 63));
        -:  164:  }
        -:  165:
        -:  166:  /// Emit a variable length integer whose low bit is used to encode the
        -:  167:  /// provided flag, i.e. encoded as: (value << 1) | (flag ? 1 : 0).
    52303:  168:  void emitVarIntWithFlag(uint64_t value, bool flag) {
    51499:  169:    emitVarInt((value << 1) | (flag ? 1 : 0));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  170:  }
        -:  171:
        -:  172:  //===--------------------------------------------------------------------===//
        -:  173:  // String Emission
        -:  174:
        -:  175:  /// Emit the given string as a nul terminated string.
function _ZN12_GLOBAL__N_115EncodingEmitter23emitNulTerminatedStringEN4llvm9StringRefE called 21054 returned 100% blocks executed 100%
    21054:  176:  void emitNulTerminatedString(StringRef str) {
    42108:  177:    emitString(str);
    42108:  178:    emitByte(0);
    21054:  179:  }
        -:  180:
        -:  181:  /// Emit the given string without a nul terminator.
    21858:  182:  void emitString(StringRef str) {
    21858:  183:    emitBytes({reinterpret_cast<const uint8_t *>(str.data()), str.size()});
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  184:  }
        -:  185:
        -:  186:  //===--------------------------------------------------------------------===//
        -:  187:  // Section Emission
        -:  188:
        -:  189:  /// Emit a nested section of the given code, whose contents are encoded in the
        -:  190:  /// provided emitter.
function _ZN12_GLOBAL__N_115EncodingEmitter11emitSectionEN4mlir8bytecode7Section2IDEOS0_ called 5628 returned 100% blocks executed 61%
     5628:  191:  void emitSection(bytecode::Section::ID code, EncodingEmitter &&emitter) {
        -:  192:    // Emit the section code and length. The high bit of the code is used to
        -:  193:    // indicate whether the section alignment is present, so save an offset to
        -:  194:    // it.
     5628:  195:    uint64_t codeOffset = currentResult.size();
call    0 returned 100%
     5628:  196:    emitByte(code);
call    0 returned 100%
     5628:  197:    emitVarInt(emitter.size());
call    0 returned 100%
        -:  198:
        -:  199:    // Integrate the alignment of the section into this emitter if necessary.
     5628:  200:    unsigned emitterAlign = emitter.requiredAlignment;
     5628:  201:    if (emitterAlign > 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  202:      if (size() & (emitterAlign - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  203:        emitVarInt(emitterAlign);
call    0 never executed
    #####:  204:        alignTo(emitterAlign);
call    0 never executed
        -:  205:
        -:  206:        // Indicate that we needed to align the section, the high bit of the
        -:  207:        // code field is used for this.
    #####:  208:        currentResult[codeOffset] |= 0b10000000;
        -:  209:      } else {
        -:  210:        // Otherwise, if we happen to be at a compatible offset, we just
        -:  211:        // remember that we need this alignment.
    #####:  212:        requiredAlignment = std::max(requiredAlignment, emitterAlign);
branch  0 never executed
branch  1 never executed
        -:  213:      }
        -:  214:    }
        -:  215:
        -:  216:    // Push our current buffer and then merge the provided section body into
        -:  217:    // ours.
     5628:  218:    appendResult(std::move(currentResult));
call    0 returned 100%
     7963:  219:    for (std::vector<uint8_t> &result : emitter.prevResultStorage)
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
call    2 returned 100%
     2335:  220:      prevResultStorage.push_back(std::move(result));
call    0 returned 100%
     5628:  221:    llvm::append_range(prevResultList, emitter.prevResultList);
call    0 returned 100%
     5628:  222:    prevResultSize += emitter.prevResultSize;
     5628:  223:    appendResult(std::move(emitter.currentResult));
call    0 returned 100%
     5628:  224:  }
        -:  225:
        -:  226:private:
        -:  227:  /// Emit the given value using a variable width encoding. This method is a
        -:  228:  /// fallback when the number of bytes needed to encode the value is greater
        -:  229:  /// than 1. We mark it noinline here so that the single byte hot path isn't
        -:  230:  /// pessimized.
        -:  231:  LLVM_ATTRIBUTE_NOINLINE void emitMultiByteVarInt(uint64_t value);
        -:  232:
        -:  233:  /// Append a new result buffer to the current contents.
function _ZN12_GLOBAL__N_115EncodingEmitter12appendResultEOSt6vectorIhSaIhEE called 13591 returned 100% blocks executed 100%
    13591:  234:  void appendResult(std::vector<uint8_t> &&result) {
    13591:  235:    if (result.empty())
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  236:      return;
    12787:  237:    prevResultStorage.emplace_back(std::move(result));
call    0 returned 100%
    25574:  238:    appendOwnedResult(prevResultStorage.back());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  239:  }
    15122:  240:  void appendOwnedResult(ArrayRef<uint8_t> result) {
    15122:  241:    if (result.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  242:      return;
    15122:  243:    prevResultSize += result.size();
call    0 returned 100%
call    1 returned 100%
    15122:  244:    prevResultList.emplace_back(result);
call    0 returned 100%
call    1 returned 100%
        -:  245:  }
        -:  246:
        -:  247:  /// The result of the emitter currently being built. We refrain from building
        -:  248:  /// a single buffer to simplify emitting sections, large data, and more. The
        -:  249:  /// result is thus represented using multiple distinct buffers, some of which
        -:  250:  /// we own (via prevResultStorage), and some of which are just pointers into
        -:  251:  /// externally owned buffers.
        -:  252:  std::vector<uint8_t> currentResult;
        -:  253:  std::vector<ArrayRef<uint8_t>> prevResultList;
        -:  254:  std::vector<std::vector<uint8_t>> prevResultStorage;
        -:  255:
        -:  256:  /// An up-to-date total size of all of the buffers within `prevResultList`.
        -:  257:  /// This enables O(1) size checks of the current encoding.
        -:  258:  size_t prevResultSize = 0;
        -:  259:
        -:  260:  /// The highest required alignment for the start of this section.
        -:  261:  unsigned requiredAlignment = 1;
        -:  262:};
        -:  263:
        -:  264:/// A simple raw_ostream wrapper around a EncodingEmitter. This removes the need
        -:  265:/// to go through an intermediate buffer when interacting with code that wants a
        -:  266:/// raw_ostream.
       54:  267:class RawEmitterOstream : public raw_ostream {
        -:  268:public:
       54:  269:  explicit RawEmitterOstream(EncodingEmitter &emitter) : emitter(emitter) {
       54:  270:    SetUnbuffered();
call    0 returned 100%
call    1 returned 100%
        -:  271:  }
        -:  272:
        -:  273:private:
function _ZN12_GLOBAL__N_117RawEmitterOstream10write_implEPKcm called 486 returned 100% blocks executed 100%
      486:  274:  void write_impl(const char *ptr, size_t size) override {
      486:  275:    emitter.emitBytes({reinterpret_cast<const uint8_t *>(ptr), size});
call    0 returned 100%
      486:  276:  }
function _ZNK12_GLOBAL__N_117RawEmitterOstream11current_posEv called 0 returned 0% blocks executed 0%
    #####:  277:  uint64_t current_pos() const override { return emitter.size(); }
        -:  278:
        -:  279:  /// The section being emitted to.
        -:  280:  EncodingEmitter &emitter;
        -:  281:};
        -:  282:} // namespace
        -:  283:
function _ZNK12_GLOBAL__N_115EncodingEmitter7writeToERN4llvm11raw_ostreamE called 804 returned 100% blocks executed 100%
      804:  284:void EncodingEmitter::writeTo(raw_ostream &os) const {
    15926:  285:  for (auto &prevResult : prevResultList)
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
    15122:  286:    os.write((const char *)prevResult.data(), prevResult.size());
call    0 returned 100%
      804:  287:  os.write((const char *)currentResult.data(), currentResult.size());
call    0 returned 100%
      804:  288:}
        -:  289:
function _ZN12_GLOBAL__N_115EncodingEmitter19emitMultiByteVarIntEm called 3906 returned 100% blocks executed 60%
     3906:  290:void EncodingEmitter::emitMultiByteVarInt(uint64_t value) {
        -:  291:  // Compute the number of bytes needed to encode the value. Each byte can hold
        -:  292:  // up to 7-bits of data. We only check up to the number of bits we can encode
        -:  293:  // in the first byte (8).
     3906:  294:  uint64_t it = value >> 7;
    3906*:  295:  for (size_t numBytes = 2; numBytes < 9; ++numBytes) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3906:  296:    if (LLVM_LIKELY(it >>= 7) == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3906:  297:      uint64_t encodedValue = (value << 1) | 0x1;
     3906:  298:      encodedValue <<= (numBytes - 1);
     3906:  299:      emitBytes({reinterpret_cast<uint8_t *>(&encodedValue), numBytes});
call    0 returned 100%
     3906:  300:      return;
        -:  301:    }
        -:  302:  }
        -:  303:
        -:  304:  // If the value is too large to encode in a single byte, emit a special all
        -:  305:  // zero marker byte and splat the value directly.
    #####:  306:  emitByte(0);
call    0 never executed
    #####:  307:  emitBytes({reinterpret_cast<uint8_t *>(&value), sizeof(value)});
call    0 never executed
        -:  308:}
        -:  309:
        -:  310://===----------------------------------------------------------------------===//
        -:  311:// StringSectionBuilder
        -:  312://===----------------------------------------------------------------------===//
        -:  313:
        -:  314:namespace {
        -:  315:/// This class is used to simplify the process of emitting the string section.
     2412:  316:class StringSectionBuilder {
        -:  317:public:
        -:  318:  /// Add the given string to the string section, and return the index of the
        -:  319:  /// string within the section.
function _ZN12_GLOBAL__N_120StringSectionBuilder6insertEN4llvm9StringRefE called 21067 returned 100% blocks executed 100%
    21067:  320:  size_t insert(StringRef str) {
    21067:  321:    auto it = strings.insert({llvm::CachedHashStringRef(str), strings.size()});
call    0 returned 100%
call    1 returned 100%
    21067:  322:    return it.first->second;
        -:  323:  }
        -:  324:
        -:  325:  /// Write the current set of strings to the given emitter.
function _ZN12_GLOBAL__N_120StringSectionBuilder5writeERNS_15EncodingEmitterE called 804 returned 100% blocks executed 100%
      804:  326:  void write(EncodingEmitter &emitter) {
      804:  327:    emitter.emitVarInt(strings.size());
call    0 returned 100%
        -:  328:
        -:  329:    // Emit the sizes in reverse order, so that we don't need to backpatch an
        -:  330:    // offset to the string data or have a separate section.
    21054:  331:    for (const auto &it : llvm::reverse(strings))
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
    20250:  332:      emitter.emitVarInt(it.first.size() + 1);
call    0 returned 100%
        -:  333:    // Emit the string data itself.
    21054:  334:    for (const auto &it : strings)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
    20250:  335:      emitter.emitNulTerminatedString(it.first.val());
call    0 returned 100%
      804:  336:  }
        -:  337:
        -:  338:private:
        -:  339:  /// A set of strings referenced within the bytecode. The value of the map is
        -:  340:  /// unused.
        -:  341:  llvm::MapVector<llvm::CachedHashStringRef, size_t> strings;
        -:  342:};
        -:  343:} // namespace
        -:  344:
        -:  345://===----------------------------------------------------------------------===//
        -:  346:// Bytecode Writer
        -:  347://===----------------------------------------------------------------------===//
        -:  348:
        -:  349:namespace {
      804:  350:class BytecodeWriter {
call    0 returned 100%
        -:  351:public:
function _ZN12_GLOBAL__N_114BytecodeWriterC2EPN4mlir9OperationE called 804 returned 100% blocks executed 100%
      804:  352:  BytecodeWriter(Operation *op) : numberingState(op) {}
call    0 returned 100%
call    1 returned 100%
        -:  353:
        -:  354:  /// Write the bytecode for the given root operation.
        -:  355:  void write(Operation *rootOp, raw_ostream &os,
        -:  356:             const BytecodeWriterConfig::Impl &config);
        -:  357:
        -:  358:private:
        -:  359:  //===--------------------------------------------------------------------===//
        -:  360:  // Dialects
        -:  361:
        -:  362:  void writeDialectSection(EncodingEmitter &emitter);
        -:  363:
        -:  364:  //===--------------------------------------------------------------------===//
        -:  365:  // Attributes and Types
        -:  366:
        -:  367:  void writeAttrTypeSection(EncodingEmitter &emitter);
        -:  368:
        -:  369:  //===--------------------------------------------------------------------===//
        -:  370:  // Operations
        -:  371:
        -:  372:  void writeBlock(EncodingEmitter &emitter, Block *block);
        -:  373:  void writeOp(EncodingEmitter &emitter, Operation *op);
        -:  374:  void writeRegion(EncodingEmitter &emitter, Region *region);
        -:  375:  void writeIRSection(EncodingEmitter &emitter, Operation *op);
        -:  376:
        -:  377:  //===--------------------------------------------------------------------===//
        -:  378:  // Resources
        -:  379:
        -:  380:  void writeResourceSection(Operation *op, EncodingEmitter &emitter,
        -:  381:                            const BytecodeWriterConfig::Impl &config);
        -:  382:
        -:  383:  //===--------------------------------------------------------------------===//
        -:  384:  // Strings
        -:  385:
        -:  386:  void writeStringSection(EncodingEmitter &emitter);
        -:  387:
        -:  388:  //===--------------------------------------------------------------------===//
        -:  389:  // Fields
        -:  390:
        -:  391:  /// The builder used for the string section.
        -:  392:  StringSectionBuilder stringSection;
        -:  393:
        -:  394:  /// The IR numbering state generated for the root operation.
        -:  395:  IRNumberingState numberingState;
        -:  396:};
        -:  397:} // namespace
        -:  398:
function _ZN12_GLOBAL__N_114BytecodeWriter5writeEPN4mlir9OperationERN4llvm11raw_ostreamERKNS1_20BytecodeWriterConfig4ImplE called 804 returned 100% blocks executed 100%
      804:  399:void BytecodeWriter::write(Operation *rootOp, raw_ostream &os,
        -:  400:                           const BytecodeWriterConfig::Impl &config) {
     1608:  401:  EncodingEmitter emitter;
call    0 returned 100%
call    1 returned 100%
        -:  402:
        -:  403:  // Emit the bytecode file header. This is how we identify the output as a
        -:  404:  // bytecode file.
      804:  405:  emitter.emitString("ML\xefR");
call    0 returned 100%
        -:  406:
        -:  407:  // Emit the bytecode version.
      804:  408:  emitter.emitVarInt(bytecode::kVersion);
call    0 returned 100%
        -:  409:
        -:  410:  // Emit the producer.
      804:  411:  emitter.emitNulTerminatedString(config.producer);
call    0 returned 100%
        -:  412:
        -:  413:  // Emit the dialect section.
      804:  414:  writeDialectSection(emitter);
call    0 returned 100%
        -:  415:
        -:  416:  // Emit the attributes and types section.
      804:  417:  writeAttrTypeSection(emitter);
call    0 returned 100%
        -:  418:
        -:  419:  // Emit the IR section.
      804:  420:  writeIRSection(emitter, rootOp);
call    0 returned 100%
        -:  421:
        -:  422:  // Emit the resources section.
      804:  423:  writeResourceSection(rootOp, emitter, config);
call    0 returned 100%
        -:  424:
        -:  425:  // Emit the string section.
      804:  426:  writeStringSection(emitter);
call    0 returned 100%
        -:  427:
        -:  428:  // Write the generated bytecode to the provided output stream.
      804:  429:  emitter.writeTo(os);
call    0 returned 100%
      804:  430:}
        -:  431:
        -:  432://===----------------------------------------------------------------------===//
        -:  433:// Dialects
        -:  434:
        -:  435:/// Write the given entries in contiguous groups with the same parent dialect.
        -:  436:/// Each dialect sub-group is encoded with the parent dialect and number of
        -:  437:/// elements, followed by the encoding for the entries. The given callback is
        -:  438:/// invoked to encode each individual entry.
        -:  439:template <typename EntriesT, typename EntryCallbackT>
     2412:  440:static void writeDialectGrouping(EncodingEmitter &emitter, EntriesT &&entries,
        -:  441:                                 EntryCallbackT &&callback) {
     6493:  442:  for (auto it = entries.begin(), e = entries.end(); it != e;) {
     4081:  443:    auto groupStart = it++;
        -:  444:
        -:  445:    // Find the end of the group that shares the same parent dialect.
     4081:  446:    DialectNumbering *currentDialect = groupStart->dialect;
     4081:  447:    it = std::find_if(it, e, [&](const auto &entry) {
        -:  448:      return entry.dialect != currentDialect;
        -:  449:    });
        -:  450:
        -:  451:    // Emit the dialect and number of elements.
     4081:  452:    emitter.emitVarInt(currentDialect->number);
     4081:  453:    emitter.emitVarInt(std::distance(groupStart, it));
        -:  454:
        -:  455:    // Emit the entries within the group.
    59046:  456:    for (auto &entry : llvm::make_range(groupStart, it))
    54965:  457:      callback(entry);
        -:  458:  }
     2412:  459:}
------------------
_Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail13TypeNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNSH_15EncodingEmitterEEUlRT_E_EvSK_OSL_OT0_:
function _Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail13TypeNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNSH_15EncodingEmitterEEUlRT_E_EvSK_OSL_OT0_ called 804 returned 100% blocks executed 100%
      804:  440:static void writeDialectGrouping(EncodingEmitter &emitter, EntriesT &&entries,
        -:  441:                                 EntryCallbackT &&callback) {
     1629:  442:  for (auto it = entries.begin(), e = entries.end(); it != e;) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
      825:  443:    auto groupStart = it++;
call    0 returned 100%
        -:  444:
        -:  445:    // Find the end of the group that shares the same parent dialect.
      825:  446:    DialectNumbering *currentDialect = groupStart->dialect;
call    0 returned 100%
      825:  447:    it = std::find_if(it, e, [&](const auto &entry) {
call    0 returned 100%
        -:  448:      return entry.dialect != currentDialect;
        -:  449:    });
        -:  450:
        -:  451:    // Emit the dialect and number of elements.
      825:  452:    emitter.emitVarInt(currentDialect->number);
call    0 returned 100%
call    1 returned 100%
      825:  453:    emitter.emitVarInt(std::distance(groupStart, it));
call    0 returned 100%
        -:  454:
        -:  455:    // Emit the entries within the group.
     8139:  456:    for (auto &entry : llvm::make_range(groupStart, it))
call    0 returned 100%
branch  1 taken 90% (fallthrough)
branch  2 taken 10%
     7314:  457:      callback(entry);
call    0 returned 100%
        -:  458:  }
      804:  459:}
------------------
_Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail18AttributeNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNSH_15EncodingEmitterEEUlRT_E_EvSK_OSL_OT0_:
function _Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail18AttributeNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNSH_15EncodingEmitterEEUlRT_E_EvSK_OSL_OT0_ called 804 returned 100% blocks executed 100%
      804:  440:static void writeDialectGrouping(EncodingEmitter &emitter, EntriesT &&entries,
        -:  441:                                 EntryCallbackT &&callback) {
     1611:  442:  for (auto it = entries.begin(), e = entries.end(); it != e;) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      807:  443:    auto groupStart = it++;
call    0 returned 100%
        -:  444:
        -:  445:    // Find the end of the group that shares the same parent dialect.
      807:  446:    DialectNumbering *currentDialect = groupStart->dialect;
call    0 returned 100%
      807:  447:    it = std::find_if(it, e, [&](const auto &entry) {
call    0 returned 100%
        -:  448:      return entry.dialect != currentDialect;
        -:  449:    });
        -:  450:
        -:  451:    // Emit the dialect and number of elements.
      807:  452:    emitter.emitVarInt(currentDialect->number);
call    0 returned 100%
call    1 returned 100%
      807:  453:    emitter.emitVarInt(std::distance(groupStart, it));
call    0 returned 100%
        -:  454:
        -:  455:    // Emit the entries within the group.
    41512:  456:    for (auto &entry : llvm::make_range(groupStart, it))
call    0 returned 100%
branch  1 taken 98% (fallthrough)
branch  2 taken 2%
    40705:  457:      callback(entry);
call    0 returned 100%
        -:  458:  }
      804:  459:}
------------------
_Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail15OpNameNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter19writeDialectSectionERNSH_15EncodingEmitterEEUlRS8_E_EvSK_OT_OT0_:
function _Z20writeDialectGroupingIN4llvm14iterator_rangeINS0_16pointee_iteratorIN9__gnu_cxx17__normal_iteratorIPPN4mlir8bytecode6detail15OpNameNumberingESt6vectorIS9_SaIS9_EEEES8_EEEERZN12_GLOBAL__N_114BytecodeWriter19writeDialectSectionERNSH_15EncodingEmitterEEUlRS8_E_EvSK_OT_OT0_ called 804 returned 100% blocks executed 100%
      804:  440:static void writeDialectGrouping(EncodingEmitter &emitter, EntriesT &&entries,
        -:  441:                                 EntryCallbackT &&callback) {
     3253:  442:  for (auto it = entries.begin(), e = entries.end(); it != e;) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     2449:  443:    auto groupStart = it++;
call    0 returned 100%
        -:  444:
        -:  445:    // Find the end of the group that shares the same parent dialect.
     2449:  446:    DialectNumbering *currentDialect = groupStart->dialect;
call    0 returned 100%
     2449:  447:    it = std::find_if(it, e, [&](const auto &entry) {
call    0 returned 100%
        -:  448:      return entry.dialect != currentDialect;
        -:  449:    });
        -:  450:
        -:  451:    // Emit the dialect and number of elements.
     2449:  452:    emitter.emitVarInt(currentDialect->number);
call    0 returned 100%
call    1 returned 100%
     2449:  453:    emitter.emitVarInt(std::distance(groupStart, it));
call    0 returned 100%
        -:  454:
        -:  455:    // Emit the entries within the group.
     9395:  456:    for (auto &entry : llvm::make_range(groupStart, it))
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
     6946:  457:      callback(entry);
call    0 returned 100%
        -:  458:  }
      804:  459:}
------------------
        -:  460:
function _ZN12_GLOBAL__N_114BytecodeWriter19writeDialectSectionERNS_15EncodingEmitterE called 804 returned 100% blocks executed 100%
      804:  461:void BytecodeWriter::writeDialectSection(EncodingEmitter &emitter) {
     1608:  462:  EncodingEmitter dialectEmitter;
call    0 returned 100%
call    1 returned 100%
        -:  463:
        -:  464:  // Emit the referenced dialects.
      804:  465:  auto dialects = numberingState.getDialects();
call    0 returned 100%
      804:  466:  dialectEmitter.emitVarInt(llvm::size(dialects));
call    0 returned 100%
     3273:  467:  for (DialectNumbering &dialect : dialects)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     2469:  468:    dialectEmitter.emitVarInt(stringSection.insert(dialect.name));
call    0 returned 100%
call    1 returned 100%
        -:  469:
        -:  470:  // Emit the referenced operation names grouped by dialect.
function _ZZN12_GLOBAL__N_114BytecodeWriter19writeDialectSectionERNS_15EncodingEmitterEENKUlRN4mlir8bytecode6detail15OpNameNumberingEE_clES7_.isra.0 called 6946 returned 100% blocks executed 100%
     6946:  471:  auto emitOpName = [&](OpNameNumbering &name) {
     6946:  472:    dialectEmitter.emitVarInt(stringSection.insert(name.name.stripDialect()));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     7750:  473:  };
      804:  474:  writeDialectGrouping(dialectEmitter, numberingState.getOpNames(), emitOpName);
call    0 returned 100%
        -:  475:
      804:  476:  emitter.emitSection(bytecode::Section::kDialect, std::move(dialectEmitter));
call    0 returned 100%
      804:  477:}
        -:  478:
        -:  479://===----------------------------------------------------------------------===//
        -:  480:// Attributes and Types
        -:  481:
        -:  482:namespace {
    47977:  483:class DialectWriter : public DialectBytecodeWriter {
        -:  484:public:
    47977:  485:  DialectWriter(EncodingEmitter &emitter, IRNumberingState &numberingState,
        -:  486:                StringSectionBuilder &stringSection)
    47977:  487:      : emitter(emitter), numberingState(numberingState),
    47977:  488:        stringSection(stringSection) {}
        -:  489:
        -:  490:  //===--------------------------------------------------------------------===//
        -:  491:  // IR
        -:  492:  //===--------------------------------------------------------------------===//
        -:  493:
function _ZN12_GLOBAL__N_113DialectWriter14writeAttributeEN4mlir9AttributeE called 44149 returned 100% blocks executed 100%
    44149:  494:  void writeAttribute(Attribute attr) override {
    44149:  495:    emitter.emitVarInt(numberingState.getNumber(attr));
call    0 returned 100%
call    1 returned 100%
    44149:  496:  }
function _ZN12_GLOBAL__N_113DialectWriter9writeTypeEN4mlir4TypeE called 12867 returned 100% blocks executed 100%
    12867:  497:  void writeType(Type type) override {
    12867:  498:    emitter.emitVarInt(numberingState.getNumber(type));
call    0 returned 100%
call    1 returned 100%
    12867:  499:  }
        -:  500:
function _ZN12_GLOBAL__N_113DialectWriter19writeResourceHandleERKN4mlir24AsmDialectResourceHandleE called 0 returned 0% blocks executed 0%
    #####:  501:  void writeResourceHandle(const AsmDialectResourceHandle &resource) override {
    #####:  502:    emitter.emitVarInt(numberingState.getNumber(resource));
call    0 never executed
call    1 never executed
    #####:  503:  }
        -:  504:
        -:  505:  //===--------------------------------------------------------------------===//
        -:  506:  // Primitives
        -:  507:  //===--------------------------------------------------------------------===//
        -:  508:
function _ZN12_GLOBAL__N_113DialectWriter11writeVarIntEm called 90945 returned 100% blocks executed 100%
    90945:  509:  void writeVarInt(uint64_t value) override { emitter.emitVarInt(value); }
call    0 returned 100%
        -:  510:
function _ZN12_GLOBAL__N_113DialectWriter17writeSignedVarIntEl called 14803 returned 100% blocks executed 100%
    14803:  511:  void writeSignedVarInt(int64_t value) override {
    14803:  512:    emitter.emitSignedVarInt(value);
call    0 returned 100%
    14803:  513:  }
        -:  514:
function _ZN12_GLOBAL__N_113DialectWriter24writeAPIntWithKnownWidthERKN4llvm5APIntE called 1872 returned 100% blocks executed 32%
     1872:  515:  void writeAPIntWithKnownWidth(const APInt &value) override {
     1872:  516:    size_t bitWidth = value.getBitWidth();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  517:
        -:  518:    // If the value is a single byte, just emit it directly without going
        -:  519:    // through a varint.
     1872:  520:    if (bitWidth <= 8)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  521:      return emitter.emitByte(value.getLimitedValue());
call    0 never executed
call    1 never executed
        -:  522:
        -:  523:    // If the value fits within a single varint, emit it directly.
     1872:  524:    if (bitWidth <= 64)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1872:  525:      return emitter.emitSignedVarInt(value.getLimitedValue());
call    0 returned 100%
call    1 returned 100%
        -:  526:
        -:  527:    // Otherwise, we need to encode a variable number of active words. We use
        -:  528:    // active words instead of the number of total words under the observation
        -:  529:    // that smaller values will be more common.
    #####:  530:    unsigned numActiveWords = value.getActiveWords();
branch  0 never executed
branch  1 never executed
    #####:  531:    emitter.emitVarInt(numActiveWords);
call    0 never executed
        -:  532:
    #####:  533:    const uint64_t *rawValueData = value.getRawData();
branch  0 never executed
branch  1 never executed
    #####:  534:    for (unsigned i = 0; i < numActiveWords; ++i)
branch  0 never executed
branch  1 never executed
    #####:  535:      emitter.emitSignedVarInt(rawValueData[i]);
call    0 never executed
        -:  536:  }
        -:  537:
function _ZN12_GLOBAL__N_113DialectWriter30writeAPFloatWithKnownSemanticsERKN4llvm7APFloatE called 0 returned 0% blocks executed 0%
    #####:  538:  void writeAPFloatWithKnownSemantics(const APFloat &value) override {
    #####:  539:    writeAPIntWithKnownWidth(value.bitcastToAPInt());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  540:  }
        -:  541:
function _ZN12_GLOBAL__N_113DialectWriter16writeOwnedStringEN4llvm9StringRefE called 11652 returned 100% blocks executed 100%
    11652:  542:  void writeOwnedString(StringRef str) override {
    11652:  543:    emitter.emitVarInt(stringSection.insert(str));
call    0 returned 100%
call    1 returned 100%
    11652:  544:  }
        -:  545:
function _ZN12_GLOBAL__N_113DialectWriter14writeOwnedBlobEN4llvm8ArrayRefIcEE called 2335 returned 100% blocks executed 100%
     2335:  546:  void writeOwnedBlob(ArrayRef<char> blob) override {
     2335:  547:    emitter.emitVarInt(blob.size());
call    0 returned 100%
     2335:  548:    emitter.emitOwnedBlob(ArrayRef<uint8_t>(
call    0 returned 100%
     2335:  549:        reinterpret_cast<const uint8_t *>(blob.data()), blob.size()));
call    0 returned 100%
     2335:  550:  }
        -:  551:
        -:  552:private:
        -:  553:  EncodingEmitter &emitter;
        -:  554:  IRNumberingState &numberingState;
        -:  555:  StringSectionBuilder &stringSection;
        -:  556:};
        -:  557:} // namespace
        -:  558:
function _ZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNS_15EncodingEmitterE called 804 returned 100% blocks executed 100%
      804:  559:void BytecodeWriter::writeAttrTypeSection(EncodingEmitter &emitter) {
     1608:  560:  EncodingEmitter attrTypeEmitter;
call    0 returned 100%
call    1 returned 100%
      804:  561:  EncodingEmitter offsetEmitter;
call    0 returned 100%
      804:  562:  offsetEmitter.emitVarInt(llvm::size(numberingState.getAttributes()));
call    0 returned 100%
      804:  563:  offsetEmitter.emitVarInt(llvm::size(numberingState.getTypes()));
call    0 returned 100%
        -:  564:
        -:  565:  // A functor used to emit an attribute or type entry.
      804:  566:  uint64_t prevOffset = 0;
    48823:  567:  auto emitAttrOrType = [&](auto &entry) {
    48019:  568:    auto entryValue = entry.getValue();
        -:  569:
        -:  570:    // First, try to emit this entry using the dialect bytecode interface.
    48019:  571:    bool hasCustomEncoding = false;
    48019:  572:    if (const BytecodeDialectInterface *interface = entry.dialect->interface) {
        -:  573:      // The writer used when emitting using a custom bytecode encoding.
       54:  574:      DialectWriter dialectWriter(attrTypeEmitter, numberingState,
    47977:  575:                                  stringSection);
        -:  576:
        -:  577:      if constexpr (std::is_same_v<std::decay_t<decltype(entryValue)>, Type>) {
        -:  578:        // TODO: We don't currently support custom encoded mutable types.
     7275:  579:        hasCustomEncoding =
     7275:  580:            !entryValue.template hasTrait<TypeTrait::IsMutable>() &&
     7275:  581:            succeeded(interface->writeType(entryValue, dialectWriter));
        -:  582:      } else {
        -:  583:        // TODO: We don't currently support custom encoded mutable attributes.
    40702:  584:        hasCustomEncoding =
    40702:  585:            !entryValue.template hasTrait<AttributeTrait::IsMutable>() &&
    40702:  586:            succeeded(interface->writeAttribute(entryValue, dialectWriter));
        -:  587:      }
        -:  588:    }
        -:  589:
        -:  590:    // If the entry was not emitted using the dialect interface, emit it using
        -:  591:    // the textual format.
    47977:  592:    if (!hasCustomEncoding) {
       54:  593:      RawEmitterOstream(attrTypeEmitter) << entryValue;
    48019:  594:      attrTypeEmitter.emitByte(0);
        -:  595:    }
        -:  596:
        -:  597:    // Record the offset of this entry.
    48019:  598:    uint64_t curOffset = attrTypeEmitter.size();
    48019:  599:    offsetEmitter.emitVarIntWithFlag(curOffset - prevOffset, hasCustomEncoding);
    48019:  600:    prevOffset = curOffset;
    48823:  601:  };
------------------
_ZZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNS_15EncodingEmitterEENKUlRT_E_clIN4mlir8bytecode6detail13TypeNumberingEEEDaS4_:
function _ZZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNS_15EncodingEmitterEENKUlRT_E_clIN4mlir8bytecode6detail13TypeNumberingEEEDaS4_ called 7314 returned 100% blocks executed 94%
     7314:  567:  auto emitAttrOrType = [&](auto &entry) {
call    0 returned 100%
     7314:  568:    auto entryValue = entry.getValue();
        -:  569:
        -:  570:    // First, try to emit this entry using the dialect bytecode interface.
     7314:  571:    bool hasCustomEncoding = false;
     7314:  572:    if (const BytecodeDialectInterface *interface = entry.dialect->interface) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  573:      // The writer used when emitting using a custom bytecode encoding.
       39:  574:      DialectWriter dialectWriter(attrTypeEmitter, numberingState,
call    0 returned 100%
     7275:  575:                                  stringSection);
call    0 returned 100%
        -:  576:
        -:  577:      if constexpr (std::is_same_v<std::decay_t<decltype(entryValue)>, Type>) {
        -:  578:        // TODO: We don't currently support custom encoded mutable types.
     7275:  579:        hasCustomEncoding =
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     7275:  580:            !entryValue.template hasTrait<TypeTrait::IsMutable>() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     7275:  581:            succeeded(interface->writeType(entryValue, dialectWriter));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  582:      } else {
        -:  583:        // TODO: We don't currently support custom encoded mutable attributes.
        -:  584:        hasCustomEncoding =
        -:  585:            !entryValue.template hasTrait<AttributeTrait::IsMutable>() &&
        -:  586:            succeeded(interface->writeAttribute(entryValue, dialectWriter));
        -:  587:      }
        -:  588:    }
        -:  589:
        -:  590:    // If the entry was not emitted using the dialect interface, emit it using
        -:  591:    // the textual format.
     7275:  592:    if (!hasCustomEncoding) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       39:  593:      RawEmitterOstream(attrTypeEmitter) << entryValue;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     7314:  594:      attrTypeEmitter.emitByte(0);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  595:    }
        -:  596:
        -:  597:    // Record the offset of this entry.
     7314:  598:    uint64_t curOffset = attrTypeEmitter.size();
     7314:  599:    offsetEmitter.emitVarIntWithFlag(curOffset - prevOffset, hasCustomEncoding);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     7314:  600:    prevOffset = curOffset;
     7314:  601:  };
------------------
_ZZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNS_15EncodingEmitterEENKUlRT_E_clIN4mlir8bytecode6detail18AttributeNumberingEEEDaS4_:
function _ZZN12_GLOBAL__N_114BytecodeWriter20writeAttrTypeSectionERNS_15EncodingEmitterEENKUlRT_E_clIN4mlir8bytecode6detail18AttributeNumberingEEEDaS4_ called 40705 returned 100% blocks executed 100%
    40705:  567:  auto emitAttrOrType = [&](auto &entry) {
call    0 returned 100%
    40705:  568:    auto entryValue = entry.getValue();
        -:  569:
        -:  570:    // First, try to emit this entry using the dialect bytecode interface.
    40705:  571:    bool hasCustomEncoding = false;
    40705:  572:    if (const BytecodeDialectInterface *interface = entry.dialect->interface) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  573:      // The writer used when emitting using a custom bytecode encoding.
       15:  574:      DialectWriter dialectWriter(attrTypeEmitter, numberingState,
call    0 returned 100%
    40702:  575:                                  stringSection);
call    0 returned 100%
        -:  576:
        -:  577:      if constexpr (std::is_same_v<std::decay_t<decltype(entryValue)>, Type>) {
        -:  578:        // TODO: We don't currently support custom encoded mutable types.
        -:  579:        hasCustomEncoding =
        -:  580:            !entryValue.template hasTrait<TypeTrait::IsMutable>() &&
        -:  581:            succeeded(interface->writeType(entryValue, dialectWriter));
        -:  582:      } else {
        -:  583:        // TODO: We don't currently support custom encoded mutable attributes.
    40702:  584:        hasCustomEncoding =
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    40702:  585:            !entryValue.template hasTrait<AttributeTrait::IsMutable>() &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    40702:  586:            succeeded(interface->writeAttribute(entryValue, dialectWriter));
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  587:      }
        -:  588:    }
        -:  589:
        -:  590:    // If the entry was not emitted using the dialect interface, emit it using
        -:  591:    // the textual format.
    40702:  592:    if (!hasCustomEncoding) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       15:  593:      RawEmitterOstream(attrTypeEmitter) << entryValue;
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    40705:  594:      attrTypeEmitter.emitByte(0);
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  595:    }
        -:  596:
        -:  597:    // Record the offset of this entry.
    40705:  598:    uint64_t curOffset = attrTypeEmitter.size();
    40705:  599:    offsetEmitter.emitVarIntWithFlag(curOffset - prevOffset, hasCustomEncoding);
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    40705:  600:    prevOffset = curOffset;
    40705:  601:  };
------------------
        -:  602:
        -:  603:  // Emit the attribute and type entries for each dialect.
      804:  604:  writeDialectGrouping(offsetEmitter, numberingState.getAttributes(),
call    0 returned 100%
        -:  605:                       emitAttrOrType);
      804:  606:  writeDialectGrouping(offsetEmitter, numberingState.getTypes(),
call    0 returned 100%
        -:  607:                       emitAttrOrType);
        -:  608:
        -:  609:  // Emit the sections to the stream.
      804:  610:  emitter.emitSection(bytecode::Section::kAttrTypeOffset,
call    0 returned 100%
      804:  611:                      std::move(offsetEmitter));
call    0 returned 100%
      804:  612:  emitter.emitSection(bytecode::Section::kAttrType, std::move(attrTypeEmitter));
call    0 returned 100%
      804:  613:}
        -:  614:
        -:  615://===----------------------------------------------------------------------===//
        -:  616:// Operations
        -:  617:
function _ZN12_GLOBAL__N_114BytecodeWriter10writeBlockERNS_15EncodingEmitterEPN4mlir5BlockE called 1630 returned 100% blocks executed 100%
     1630:  618:void BytecodeWriter::writeBlock(EncodingEmitter &emitter, Block *block) {
     1630:  619:  ArrayRef<BlockArgument> args = block->getArguments();
call    0 returned 100%
     1630:  620:  bool hasArgs = !args.empty();
call    0 returned 100%
        -:  621:
        -:  622:  // Emit the number of operations in this block, and if it has arguments. We
        -:  623:  // use the low bit of the operation count to indicate if the block has
        -:  624:  // arguments.
     1630:  625:  unsigned numOps = numberingState.getOperationCount(block);
call    0 returned 100%
     1630:  626:  emitter.emitVarIntWithFlag(numOps, hasArgs);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  627:
        -:  628:  // Emit the arguments of the block.
     1630:  629:  if (hasArgs) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      815:  630:    emitter.emitVarInt(args.size());
call    0 returned 100%
     2440:  631:    for (BlockArgument arg : args) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
     1625:  632:      emitter.emitVarInt(numberingState.getNumber(arg.getType()));
call    0 returned 100%
call    1 returned 100%
     1625:  633:      emitter.emitVarInt(numberingState.getNumber(arg.getLoc()));
call    0 returned 100%
call    1 returned 100%
        -:  634:    }
        -:  635:  }
        -:  636:
        -:  637:  // Emit the operations within the block.
    11514:  638:  for (Operation &op : *block)
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
call    2 returned 100%
     9884:  639:    writeOp(emitter, &op);
call    0 returned 100%
     1630:  640:}
        -:  641:
function _ZN12_GLOBAL__N_114BytecodeWriter7writeOpERNS_15EncodingEmitterEPN4mlir9OperationE called 10688 returned 100% blocks executed 84%
    10688:  642:void BytecodeWriter::writeOp(EncodingEmitter &emitter, Operation *op) {
    10688:  643:  emitter.emitVarInt(numberingState.getNumber(op->getName()));
call    0 returned 100%
call    1 returned 100%
        -:  644:
        -:  645:  // Emit a mask for the operation components. We need to fill this in later
        -:  646:  // (when we actually know what needs to be emitted), so emit a placeholder for
        -:  647:  // now.
    10688:  648:  uint64_t maskOffset = emitter.size();
call    0 returned 100%
    10688:  649:  uint8_t opEncodingMask = 0;
    10688:  650:  emitter.emitByte(0);
call    0 returned 100%
        -:  651:
        -:  652:  // Emit the location for this operation.
    10688:  653:  emitter.emitVarInt(numberingState.getNumber(op->getLoc()));
call    0 returned 100%
call    1 returned 100%
        -:  654:
        -:  655:  // Emit the attributes of this operation.
    10688:  656:  DictionaryAttr attrs = op->getAttrDictionary();
call    0 returned 100%
    10688:  657:  if (!attrs.empty()) {
call    0 returned 100%
branch  1 taken 59% (fallthrough)
branch  2 taken 41%
     6347:  658:    opEncodingMask |= bytecode::OpEncodingMask::kHasAttrs;
     6347:  659:    emitter.emitVarInt(numberingState.getNumber(op->getAttrDictionary()));
call    0 returned 100%
call    1 returned 100%
        -:  660:  }
        -:  661:
        -:  662:  // Emit the result types of the operation.
    10688:  663:  if (unsigned numResults = op->getNumResults()) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     8023:  664:    opEncodingMask |= bytecode::OpEncodingMask::kHasResults;
     8023:  665:    emitter.emitVarInt(numResults);
call    0 returned 100%
    40115:  666:    for (Type type : op->getResultTypes())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
     8023:  667:      emitter.emitVarInt(numberingState.getNumber(type));
call    0 returned 100%
call    1 returned 100%
        -:  668:  }
        -:  669:
        -:  670:  // Emit the operands of the operation.
    17126:  671:  if (unsigned numOperands = op->getNumOperands()) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     6438:  672:    opEncodingMask |= bytecode::OpEncodingMask::kHasOperands;
     6438:  673:    emitter.emitVarInt(numOperands);
call    0 returned 100%
    17582:  674:    for (Value operand : op->getOperands())
call    0 returned 100%
branch  1 taken 63% (fallthrough)
branch  2 taken 37%
call    3 returned 100%
    11144:  675:      emitter.emitVarInt(numberingState.getNumber(operand));
call    0 returned 100%
call    1 returned 100%
        -:  676:  }
        -:  677:
        -:  678:  // Emit the successors of the operation.
    10688:  679:  if (unsigned numSuccessors = op->getNumSuccessors()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  680:    opEncodingMask |= bytecode::OpEncodingMask::kHasSuccessors;
    #####:  681:    emitter.emitVarInt(numSuccessors);
call    0 never executed
    #####:  682:    for (Block *successor : op->getSuccessors())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  683:      emitter.emitVarInt(numberingState.getNumber(successor));
call    0 never executed
call    1 never executed
        -:  684:  }
        -:  685:
        -:  686:  // Check for regions.
    10688:  687:  unsigned numRegions = op->getNumRegions();
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
    10688:  688:  if (numRegions)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
     1850:  689:    opEncodingMask |= bytecode::OpEncodingMask::kHasInlineRegions;
        -:  690:
        -:  691:  // Update the mask for the operation.
    10688:  692:  emitter.patchByte(maskOffset, opEncodingMask);
call    0 returned 100%
        -:  693:
        -:  694:  // With the mask emitted, we can now emit the regions of the operation. We do
        -:  695:  // this after mask emission to avoid offset complications that may arise by
        -:  696:  // emitting the regions first (e.g. if the regions are huge, backpatching the
        -:  697:  // op encoding mask is more annoying).
    10688:  698:  if (numRegions) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
     1850:  699:    bool isIsolatedFromAbove = op->hasTrait<OpTrait::IsIsolatedFromAbove>();
call    0 returned 100%
     1850:  700:    emitter.emitVarIntWithFlag(numRegions, isIsolatedFromAbove);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  701:
     5550:  702:    for (Region &region : op->getRegions())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
     1850:  703:      writeRegion(emitter, &region);
call    0 returned 100%
        -:  704:  }
    10688:  705:}
        -:  706:
function _ZN12_GLOBAL__N_114BytecodeWriter11writeRegionERNS_15EncodingEmitterEPN4mlir6RegionE called 1850 returned 100% blocks executed 93%
     1850:  707:void BytecodeWriter::writeRegion(EncodingEmitter &emitter, Region *region) {
        -:  708:  // If the region is empty, we only need to emit the number of blocks (which is
        -:  709:  // zero).
     1850:  710:  if (region->empty())
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
      220:  711:    return emitter.emitVarInt(/*numBlocks*/ 0);
call    0 returned 100%
        -:  712:
        -:  713:  // Emit the number of blocks and values within the region.
     1630:  714:  unsigned numBlocks, numValues;
     1630:  715:  std::tie(numBlocks, numValues) = numberingState.getBlockValueCount(region);
call    0 returned 100%
call    1 returned 100%
     1630:  716:  emitter.emitVarInt(numBlocks);
call    0 returned 100%
     1630:  717:  emitter.emitVarInt(numValues);
call    0 returned 100%
        -:  718:
        -:  719:  // Emit the blocks within the region.
     3260:  720:  for (Block &block : *region)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     1630:  721:    writeBlock(emitter, &block);
call    0 returned 100%
        -:  722:}
        -:  723:
function _ZN12_GLOBAL__N_114BytecodeWriter14writeIRSectionERNS_15EncodingEmitterEPN4mlir9OperationE called 804 returned 100% blocks executed 100%
      804:  724:void BytecodeWriter::writeIRSection(EncodingEmitter &emitter, Operation *op) {
     1608:  725:  EncodingEmitter irEmitter;
call    0 returned 100%
call    1 returned 100%
        -:  726:
        -:  727:  // Write the IR section the same way as a block with no arguments. Note that
        -:  728:  // the low-bit of the operation count for a block is used to indicate if the
        -:  729:  // block has arguments, which in this case is always false.
      804:  730:  irEmitter.emitVarIntWithFlag(/*numOps*/ 1, /*hasArgs*/ false);
call    0 returned 100%
        -:  731:
        -:  732:  // Emit the operations.
      804:  733:  writeOp(irEmitter, op);
call    0 returned 100%
        -:  734:
      804:  735:  emitter.emitSection(bytecode::Section::kIR, std::move(irEmitter));
call    0 returned 100%
      804:  736:}
        -:  737:
        -:  738://===----------------------------------------------------------------------===//
        -:  739:// Resources
        -:  740:
        -:  741:namespace {
        -:  742:/// This class represents a resource builder implementation for the MLIR
        -:  743:/// bytecode format.
        -:  744:class ResourceBuilder : public AsmResourceBuilder {
        -:  745:public:
        -:  746:  using PostProcessFn = function_ref<void(StringRef, AsmResourceEntryKind)>;
        -:  747:
      804:  748:  ResourceBuilder(EncodingEmitter &emitter, StringSectionBuilder &stringSection,
        -:  749:                  PostProcessFn postProcessFn)
      804:  750:      : emitter(emitter), stringSection(stringSection),
      804:  751:        postProcessFn(postProcessFn) {}
call    0 returned 100%
    1608*:  752:  ~ResourceBuilder() override = default;
------------------
_ZN12_GLOBAL__N_115ResourceBuilderD0Ev:
function _ZN12_GLOBAL__N_115ResourceBuilderD0Ev called 0 returned 0% blocks executed 0%
    #####:  752:  ~ResourceBuilder() override = default;
call    0 never executed
call    1 never executed
------------------
_ZN12_GLOBAL__N_115ResourceBuilderD2Ev:
function _ZN12_GLOBAL__N_115ResourceBuilderD2Ev called 0 returned 0% blocks executed 0%
    #####:  752:  ~ResourceBuilder() override = default;
call    0 never executed
------------------
        -:  753:
function _ZN12_GLOBAL__N_115ResourceBuilder9buildBlobEN4llvm9StringRefENS1_8ArrayRefIcEEj called 0 returned 0% blocks executed 0%
    #####:  754:  void buildBlob(StringRef key, ArrayRef<char> data,
        -:  755:                 uint32_t dataAlignment) final {
    #####:  756:    emitter.emitOwnedBlobAndAlignment(data, dataAlignment);
call    0 never executed
    #####:  757:    postProcessFn(key, AsmResourceEntryKind::Blob);
call    0 never executed
    #####:  758:  }
function _ZN12_GLOBAL__N_115ResourceBuilder9buildBoolEN4llvm9StringRefEb called 0 returned 0% blocks executed 0%
    #####:  759:  void buildBool(StringRef key, bool data) final {
    #####:  760:    emitter.emitByte(data);
call    0 never executed
    #####:  761:    postProcessFn(key, AsmResourceEntryKind::Bool);
call    0 never executed
    #####:  762:  }
function _ZN12_GLOBAL__N_115ResourceBuilder11buildStringEN4llvm9StringRefES2_ called 0 returned 0% blocks executed 0%
    #####:  763:  void buildString(StringRef key, StringRef data) final {
    #####:  764:    emitter.emitVarInt(stringSection.insert(data));
call    0 never executed
call    1 never executed
    #####:  765:    postProcessFn(key, AsmResourceEntryKind::String);
call    0 never executed
    #####:  766:  }
        -:  767:
        -:  768:private:
        -:  769:  EncodingEmitter &emitter;
        -:  770:  StringSectionBuilder &stringSection;
        -:  771:  PostProcessFn postProcessFn;
        -:  772:};
        -:  773:} // namespace
        -:  774:
function _ZN12_GLOBAL__N_114BytecodeWriter20writeResourceSectionEPN4mlir9OperationERNS_15EncodingEmitterERKNS1_20BytecodeWriterConfig4ImplE called 804 returned 100% blocks executed 59%
      804:  775:void BytecodeWriter::writeResourceSection(
        -:  776:    Operation *op, EncodingEmitter &emitter,
        -:  777:    const BytecodeWriterConfig::Impl &config) {
     1608:  778:  EncodingEmitter resourceEmitter;
call    0 returned 100%
call    1 returned 100%
     1608:  779:  EncodingEmitter resourceOffsetEmitter;
      804:  780:  uint64_t prevOffset = 0;
      804:  781:  SmallVector<std::tuple<StringRef, AsmResourceEntryKind, uint64_t>>
call    0 returned 100%
      804:  782:      curResourceEntries;
call    0 returned 100%
        -:  783:
        -:  784:  // Functor used to process the offset for a resource of `kind` defined by
        -:  785:  // 'key'.
function _ZZN12_GLOBAL__N_114BytecodeWriter20writeResourceSectionEPN4mlir9OperationERNS_15EncodingEmitterERKNS1_20BytecodeWriterConfig4ImplEENKUlN4llvm9StringRefENS1_20AsmResourceEntryKindEE_clESB_SC_ called 0 returned 0% blocks executed 0%
     804*:  786:  auto appendResourceOffset = [&](StringRef key, AsmResourceEntryKind kind) {
    #####:  787:    uint64_t curOffset = resourceEmitter.size();
call    0 never executed
    #####:  788:    curResourceEntries.emplace_back(key, kind, curOffset - prevOffset);
call    0 never executed
    #####:  789:    prevOffset = curOffset;
     804*:  790:  };
        -:  791:
        -:  792:  // Functor used to emit a resource group defined by 'key'.
function _ZZN12_GLOBAL__N_114BytecodeWriter20writeResourceSectionEPN4mlir9OperationERNS_15EncodingEmitterERKNS1_20BytecodeWriterConfig4ImplEENKUlmE0_clEm called 0 returned 0% blocks executed 0%
     804*:  793:  auto emitResourceGroup = [&](uint64_t key) {
    #####:  794:    resourceOffsetEmitter.emitVarInt(key);
call    0 never executed
    #####:  795:    resourceOffsetEmitter.emitVarInt(curResourceEntries.size());
call    0 never executed
    #####:  796:    for (auto [key, kind, size] : curResourceEntries) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  797:      resourceOffsetEmitter.emitVarInt(stringSection.insert(key));
call    0 never executed
call    1 never executed
    #####:  798:      resourceOffsetEmitter.emitVarInt(size);
call    0 never executed
    #####:  799:      resourceOffsetEmitter.emitByte(kind);
call    0 never executed
        -:  800:    }
     804*:  801:  };
        -:  802:
        -:  803:  // Builder used to emit resources.
      804:  804:  ResourceBuilder entryBuilder(resourceEmitter, stringSection,
     1608:  805:                               appendResourceOffset);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  806:
        -:  807:  // Emit the external resource entries.
      804:  808:  resourceOffsetEmitter.emitVarInt(config.externalResourcePrinters.size());
call    0 returned 100%
     804*:  809:  for (const auto &printer : config.externalResourcePrinters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  810:    curResourceEntries.clear();
call    0 never executed
    #####:  811:    printer->buildResources(op, entryBuilder);
call    0 never executed
    #####:  812:    emitResourceGroup(stringSection.insert(printer->getName()));
call    0 never executed
call    1 never executed
        -:  813:  }
        -:  814:
        -:  815:  // Emit the dialect resource entries.
     3273:  816:  for (DialectNumbering &dialect : numberingState.getDialects()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
     2469:  817:    if (!dialect.asmInterface)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
     1654:  818:      continue;
      815:  819:    curResourceEntries.clear();
call    0 returned 100%
      815:  820:    dialect.asmInterface->buildResources(op, dialect.resources, entryBuilder);
call    0 returned 100%
        -:  821:
        -:  822:    // Emit the declaration resources for this dialect, these didn't get emitted
        -:  823:    // by the interface. These resources don't have data attached, so just use a
        -:  824:    // "blob" kind as a placeholder.
     815*:  825:    for (const auto &resource : dialect.resourceMap)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  826:      if (resource.second->isDeclaration)
branch  0 never executed
branch  1 never executed
    #####:  827:        appendResourceOffset(resource.first, AsmResourceEntryKind::Blob);
call    0 never executed
        -:  828:
        -:  829:    // Emit the resource group for this dialect.
      815:  830:    if (!curResourceEntries.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  831:      emitResourceGroup(dialect.number);
call    0 never executed
        -:  832:  }
        -:  833:
        -:  834:  // If we didn't emit any resource groups, elide the resource sections.
      804:  835:  if (resourceOffsetEmitter.size() == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  836:    return;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  837:
      804:  838:  emitter.emitSection(bytecode::Section::kResourceOffset,
call    0 returned 100%
      804:  839:                      std::move(resourceOffsetEmitter));
call    0 returned 100%
      804:  840:  emitter.emitSection(bytecode::Section::kResource, std::move(resourceEmitter));
call    0 returned 100%
call    1 returned 100%
        -:  841:}
        -:  842:
        -:  843://===----------------------------------------------------------------------===//
        -:  844:// Strings
        -:  845:
function _ZN12_GLOBAL__N_114BytecodeWriter18writeStringSectionERNS_15EncodingEmitterE called 804 returned 100% blocks executed 100%
      804:  846:void BytecodeWriter::writeStringSection(EncodingEmitter &emitter) {
     1608:  847:  EncodingEmitter stringEmitter;
call    0 returned 100%
call    1 returned 100%
      804:  848:  stringSection.write(stringEmitter);
call    0 returned 100%
      804:  849:  emitter.emitSection(bytecode::Section::kString, std::move(stringEmitter));
call    0 returned 100%
      804:  850:}
        -:  851:
        -:  852://===----------------------------------------------------------------------===//
        -:  853:// Entry Points
        -:  854://===----------------------------------------------------------------------===//
        -:  855:
function _ZN4mlir19writeBytecodeToFileEPNS_9OperationERN4llvm11raw_ostreamERKNS_20BytecodeWriterConfigE called 804 returned 100% blocks executed 100%
      804:  856:void mlir::writeBytecodeToFile(Operation *op, raw_ostream &os,
        -:  857:                               const BytecodeWriterConfig &config) {
      804:  858:  BytecodeWriter writer(op);
call    0 returned 100%
      804:  859:  writer.write(op, os, config.getImpl());
call    0 returned 100%
call    1 returned 100%
      804:  860:}
