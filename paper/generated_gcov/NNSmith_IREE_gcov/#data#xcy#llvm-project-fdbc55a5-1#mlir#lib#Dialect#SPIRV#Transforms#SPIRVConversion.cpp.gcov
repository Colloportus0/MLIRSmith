        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/SPIRV/Transforms/SPIRVConversion.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVConversion.dir/SPIRVConversion.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/Transforms/CMakeFiles/obj.MLIRSPIRVConversion.dir/SPIRVConversion.cpp.gcda
        -:    0:Runs:325587
        -:    1://===- SPIRVConversion.cpp - SPIR-V Conversion Utilities ------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements utilities used to lower to SPIR-V dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
        -:   14:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   15:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVEnums.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   18:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   19:#include "mlir/Transforms/DialectConversion.h"
        -:   20:#include "llvm/ADT/Sequence.h"
        -:   21:#include "llvm/ADT/StringExtras.h"
        -:   22:#include "llvm/Support/Debug.h"
        -:   23:
        -:   24:#include <functional>
        -:   25:
        -:   26:#define DEBUG_TYPE "mlir-spirv-conversion"
        -:   27:
        -:   28:using namespace mlir;
        -:   29:
        -:   30://===----------------------------------------------------------------------===//
        -:   31:// Utility functions
        -:   32://===----------------------------------------------------------------------===//
        -:   33:
        -:   34:/// Checks that `candidates` extension requirements are possible to be satisfied
        -:   35:/// with the given `targetEnv`.
        -:   36:///
        -:   37:///  `candidates` is a vector of vector for extension requirements following
        -:   38:/// ((Extension::A OR Extension::B) AND (Extension::C OR Extension::D))
        -:   39:/// convention.
        -:   40:template <typename LabelT>
    4874*:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
    4874*:   44:  for (const auto &ors : candidates) {
    #####:   45:    if (targetEnv.allows(ors))
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
    4874*:   57:    return failure();
        -:   58:  }
    4874*:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE called 1690 returned 100% blocks executed 14%
     1690:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
    1690*:   44:  for (const auto &ors : candidates) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
     1690:   57:    return failure();
        -:   58:  }
     1690:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_9ExtensionEEEEE called 0 returned 0% blocks executed 0%
    #####:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
    #####:   44:  for (const auto &ors : candidates) {
branch  0 never executed
branch  1 never executed
    #####:   45:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
    #####:   57:    return failure();
        -:   58:  }
    #####:   59:  return success();
        -:   60:}
------------------
_Z26checkExtensionRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_9ExtensionEEEEE:
function _Z26checkExtensionRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_9ExtensionEEEEE called 3184 returned 100% blocks executed 14%
     3184:   41:static LogicalResult checkExtensionRequirements(
        -:   42:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   43:    const spirv::SPIRVType::ExtensionArrayRefVector &candidates) {
    3184*:   44:  for (const auto &ors : candidates) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   45:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   46:      continue;
        -:   47:
    #####:   48:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   49:      SmallVector<StringRef> extStrings;
        -:   50:      for (spirv::Extension ext : ors)
        -:   51:        extStrings.push_back(spirv::stringifyExtension(ext));
        -:   52:
        -:   53:      llvm::dbgs() << label << " illegal: requires at least one extension in ["
        -:   54:                   << llvm::join(extStrings, ", ")
        -:   55:                   << "] but none allowed in target environment\n";
        -:   56:    });
     3184:   57:    return failure();
        -:   58:  }
     3184:   59:  return success();
        -:   60:}
------------------
        -:   61:
        -:   62:/// Checks that `candidates`capability requirements are possible to be satisfied
        -:   63:/// with the given `isAllowedFn`.
        -:   64:///
        -:   65:///  `candidates` is a vector of vector for capability requirements following
        -:   66:/// ((Capability::A OR Capability::B) AND (Capability::C OR Capability::D))
        -:   67:/// convention.
        -:   68:template <typename LabelT>
    8219*:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    8219*:   72:  for (const auto &ors : candidates) {
    3345*:   73:    if (targetEnv.allows(ors))
        -:   74:      continue;
        -:   75:
    3345*:   76:    LLVM_DEBUG({
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
    8219*:   85:    return failure();
        -:   86:  }
    8219*:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir13OperationNameEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE called 1690 returned 100% blocks executed 14%
     1690:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    1690*:   72:  for (const auto &ors : candidates) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   73:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   74:      continue;
        -:   75:
    #####:   76:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
     1690:   85:    return failure();
        -:   86:  }
     1690:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir10VectorTypeEENS0_13LogicalResultET_RKNS0_5spirv9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS4_10CapabilityEEEEE called 0 returned 0% blocks executed 0%
    #####:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    #####:   72:  for (const auto &ors : candidates) {
branch  0 never executed
branch  1 never executed
    #####:   73:    if (targetEnv.allows(ors))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   74:      continue;
        -:   75:
    #####:   76:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
    #####:   85:    return failure();
        -:   86:  }
    #####:   87:  return success();
        -:   88:}
------------------
_Z27checkCapabilityRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_10CapabilityEEEEE:
function _Z27checkCapabilityRequirementsIN4mlir5spirv10ScalarTypeEENS0_13LogicalResultET_RKNS1_9TargetEnvERKN4llvm15SmallVectorImplINS8_8ArrayRefINS1_10CapabilityEEEEE called 6529 returned 100% blocks executed 29%
     6529:   69:static LogicalResult checkCapabilityRequirements(
        -:   70:    LabelT label, const spirv::TargetEnv &targetEnv,
        -:   71:    const spirv::SPIRVType::CapabilityArrayRefVector &candidates) {
    6529*:   72:  for (const auto &ors : candidates) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    3345*:   73:    if (targetEnv.allows(ors))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   74:      continue;
        -:   75:
    3345*:   76:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
        -:   77:      SmallVector<StringRef> capStrings;
        -:   78:      for (spirv::Capability cap : ors)
        -:   79:        capStrings.push_back(spirv::stringifyCapability(cap));
        -:   80:
        -:   81:      llvm::dbgs() << label << " illegal: requires at least one capability in ["
        -:   82:                   << llvm::join(capStrings, ", ")
        -:   83:                   << "] but none allowed in target environment\n";
        -:   84:    });
     6529:   85:    return failure();
        -:   86:  }
     6529:   87:  return success();
        -:   88:}
------------------
        -:   89:
        -:   90:/// Returns true if the given `storageClass` needs explicit layout when used in
        -:   91:/// Shader environments.
    #####:   92:static bool needsExplicitLayout(spirv::StorageClass storageClass) {
    #####:   93:  switch (storageClass) {
        -:   94:  case spirv::StorageClass::PhysicalStorageBuffer:
        -:   95:  case spirv::StorageClass::PushConstant:
        -:   96:  case spirv::StorageClass::StorageBuffer:
        -:   97:  case spirv::StorageClass::Uniform:
        -:   98:    return true;
    #####:   99:  default:
    #####:  100:    return false;
        -:  101:  }
        -:  102:}
        -:  103:
        -:  104:/// Wraps the given `elementType` in a struct and gets the pointer to the
        -:  105:/// struct. This is used to satisfy Vulkan interface requirements.
        -:  106:static spirv::PointerType
function _ZL25wrapInStructAndGetPointerN4mlir4TypeENS_5spirv12StorageClassE called 0 returned 0% blocks executed 0%
    #####:  107:wrapInStructAndGetPointer(Type elementType, spirv::StorageClass storageClass) {
    #####:  108:  auto structType = needsExplicitLayout(storageClass)
branch  0 never executed
branch  1 never executed
    #####:  109:                        ? spirv::StructType::get(elementType, /*offsetInfo=*/0)
call    0 never executed
    #####:  110:                        : spirv::StructType::get(elementType);
call    0 never executed
    #####:  111:  return spirv::PointerType::get(structType, storageClass);
call    0 never executed
        -:  112:}
        -:  113:
        -:  114://===----------------------------------------------------------------------===//
        -:  115:// Type Conversion
        -:  116://===----------------------------------------------------------------------===//
        -:  117:
function _ZNK4mlir18SPIRVTypeConverter12getIndexTypeEv called 36 returned 100% blocks executed 100%
       36:  118:Type SPIRVTypeConverter::getIndexType() const {
       36:  119:  return IntegerType::get(getContext(), options.use64bitIndex ? 64 : 32);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:}
        -:  121:
function _ZNK4mlir18SPIRVTypeConverter10getContextEv called 0 returned 0% blocks executed 0%
      36*:  122:MLIRContext *SPIRVTypeConverter::getContext() const {
      36*:  123:  return targetEnv.getAttr().getContext();
call    0 never executed
call    1 returned 100%
call    2 returned 100%
        -:  124:}
        -:  125:
function _ZN4mlir18SPIRVTypeConverter6allowsENS_5spirv10CapabilityE called 0 returned 0% blocks executed 0%
    #####:  126:bool SPIRVTypeConverter::allows(spirv::Capability capability) {
    #####:  127:  return targetEnv.allows(capability);
call    0 never executed
        -:  128:}
        -:  129:
        -:  130:// TODO: This is a utility function that should probably be exposed by the
        -:  131:// SPIR-V dialect. Keeping it local till the use case arises.
function _ZL15getTypeNumBytesRKN4mlir22SPIRVConversionOptionsENS_4TypeE called 26114 returned 100% blocks executed 40%
    26114:  132:static Optional<int64_t> getTypeNumBytes(const SPIRVConversionOptions &options,
        -:  133:                                         Type type) {
    26114:  134:  if (type.isa<spirv::ScalarType>()) {
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
    19581:  135:    auto bitWidth = type.getIntOrFloatBitWidth();
call    0 returned 100%
        -:  136:    // According to the SPIR-V spec:
        -:  137:    // "There is no physical size or bit pattern defined for values with boolean
        -:  138:    // type. If they are stored (in conjunction with OpVariable), they can only
        -:  139:    // be used with logical addressing operations, not physical, and only with
        -:  140:    // non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup,
        -:  141:    // Private, Function, Input, and Output."
    19581:  142:    if (bitWidth == 1)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       36:  143:      return llvm::None;
    19545:  144:    return bitWidth / 8;
        -:  145:  }
        -:  146:
     6533:  147:  if (auto vecType = type.dyn_cast<VectorType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  148:    auto elementSize = getTypeNumBytes(options, vecType.getElementType());
call    0 never executed
call    1 never executed
    #####:  149:    if (!elementSize)
branch  0 never executed
branch  1 never executed
    #####:  150:      return llvm::None;
    #####:  151:    return vecType.getNumElements() * *elementSize;
call    0 never executed
        -:  152:  }
        -:  153:
     6533:  154:  if (auto memRefType = type.dyn_cast<MemRefType>()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  155:    // TODO: Layout should also be controlled by the ABI attributes. For now
        -:  156:    // using the layout from MemRef.
    #####:  157:    int64_t offset;
    #####:  158:    SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  159:    if (!memRefType.hasStaticShape() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:        failed(getStridesAndOffset(memRefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  161:      return llvm::None;
        -:  162:
        -:  163:    // To get the size of the memref object in memory, the total size is the
        -:  164:    // max(stride * dimension-size) computed for all dimensions times the size
        -:  165:    // of the element.
    #####:  166:    auto elementSize = getTypeNumBytes(options, memRefType.getElementType());
call    0 never executed
call    1 never executed
    #####:  167:    if (!elementSize)
branch  0 never executed
branch  1 never executed
    #####:  168:      return llvm::None;
        -:  169:
    #####:  170:    if (memRefType.getRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  171:      return elementSize;
        -:  172:
    #####:  173:    auto dims = memRefType.getShape();
call    0 never executed
    #####:  174:    if (llvm::is_contained(dims, ShapedType::kDynamicSize) ||
branch  0 never executed
branch  1 never executed
    #####:  175:        offset == MemRefType::getDynamicStrideOrOffset() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  176:        llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()))
branch  0 never executed
branch  1 never executed
    #####:  177:      return llvm::None;
        -:  178:
    #####:  179:    int64_t memrefSize = -1;
    #####:  180:    for (const auto &shape : enumerate(dims))
branch  0 never executed
branch  1 never executed
    #####:  181:      memrefSize = std::max(memrefSize, shape.value() * strides[shape.index()]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  182:
    #####:  183:    return (offset + memrefSize) * *elementSize;
        -:  184:  }
        -:  185:
     6533:  186:  if (auto tensorType = type.dyn_cast<TensorType>()) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     6533:  187:    if (!tensorType.hasStaticShape())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  188:      return llvm::None;
        -:  189:
     6533:  190:    auto elementSize = getTypeNumBytes(options, tensorType.getElementType());
call    0 returned 100%
call    1 returned 100%
     6533:  191:    if (!elementSize)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
       18:  192:      return llvm::None;
        -:  193:
     6515:  194:    int64_t size = *elementSize;
call    0 returned 100%
    29891:  195:    for (auto shape : tensorType.getShape())
call    0 returned 100%
branch  1 taken 78% (fallthrough)
branch  2 taken 22%
    23376:  196:      size *= shape;
        -:  197:
     6515:  198:    return size;
        -:  199:  }
        -:  200:
        -:  201:  // TODO: Add size computation for other types.
    #####:  202:  return llvm::None;
        -:  203:}
        -:  204:
        -:  205:/// Converts a scalar `type` to a suitable type under the given `targetEnv`.
        -:  206:static Type convertScalarType(const spirv::TargetEnv &targetEnv,
        -:  207:                              const SPIRVConversionOptions &options,
        -:  208:                              spirv::ScalarType type,
        -:  209:                              Optional<spirv::StorageClass> storageClass = {}) {
        -:  210:  // Get extension and capability requirements for the given type.
        -:  211:  SmallVector<ArrayRef<spirv::Extension>, 1> extensions;
        -:  212:  SmallVector<ArrayRef<spirv::Capability>, 2> capabilities;
        -:  213:  type.getExtensions(extensions, storageClass);
        -:  214:  type.getCapabilities(capabilities, storageClass);
        -:  215:
        -:  216:  // If all requirements are met, then we can accept this type as-is.
        -:  217:  if (succeeded(checkCapabilityRequirements(type, targetEnv, capabilities)) &&
        -:  218:      succeeded(checkExtensionRequirements(type, targetEnv, extensions)))
        -:  219:    return type;
        -:  220:
        -:  221:  // Otherwise we need to adjust the type, which really means adjusting the
        -:  222:  // bitwidth given this is a scalar type.
        -:  223:
        -:  224:  if (!options.emulateNon32BitScalarTypes)
        -:  225:    return nullptr;
        -:  226:
        -:  227:  if (auto floatType = type.dyn_cast<FloatType>()) {
        -:  228:    LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
        -:  229:    return Builder(targetEnv.getContext()).getF32Type();
        -:  230:  }
        -:  231:
        -:  232:  auto intType = type.cast<IntegerType>();
        -:  233:  LLVM_DEBUG(llvm::dbgs() << type << " converted to 32-bit for SPIR-V\n");
        -:  234:  return IntegerType::get(targetEnv.getContext(), /*width=*/32,
        -:  235:                          intType.getSignedness());
        -:  236:}
        -:  237:
        -:  238:/// Converts a vector `type` to a suitable type under the given `targetEnv`.
function _ZL17convertVectorTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10VectorTypeEN4llvm8OptionalINS0_12StorageClassEEE called 0 returned 0% blocks executed 0%
    #####:  239:static Type convertVectorType(const spirv::TargetEnv &targetEnv,
        -:  240:                              const SPIRVConversionOptions &options,
        -:  241:                              VectorType type,
        -:  242:                              Optional<spirv::StorageClass> storageClass = {}) {
    #####:  243:  auto scalarType = type.getElementType().cast<spirv::ScalarType>();
call    0 never executed
call    1 never executed
    #####:  244:  if (type.getRank() <= 1 && type.getNumElements() == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  245:    return convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 never executed
        -:  246:
    #####:  247:  if (!spirv::CompositeType::isValid(type)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  248:    // TODO: Vector types with more than four elements can be translated into
        -:  249:    // array types.
    #####:  250:    LLVM_DEBUG(llvm::dbgs() << type << " illegal: > 4-element unimplemented\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  251:    return nullptr;
        -:  252:  }
        -:  253:
        -:  254:  // Get extension and capability requirements for the given type.
    #####:  255:  SmallVector<ArrayRef<spirv::Extension>, 1> extensions;
call    0 never executed
    #####:  256:  SmallVector<ArrayRef<spirv::Capability>, 2> capabilities;
branch  0 never executed
branch  1 never executed
    #####:  257:  type.cast<spirv::CompositeType>().getExtensions(extensions, storageClass);
call    0 never executed
call    1 never executed
    #####:  258:  type.cast<spirv::CompositeType>().getCapabilities(capabilities, storageClass);
call    0 never executed
call    1 never executed
        -:  259:
        -:  260:  // If all requirements are met, then we can accept this type as-is.
    #####:  261:  if (succeeded(checkCapabilityRequirements(type, targetEnv, capabilities)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  262:      succeeded(checkExtensionRequirements(type, targetEnv, extensions)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  263:    return type;
        -:  264:
    #####:  265:  auto elementType =
    #####:  266:      convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 never executed
    #####:  267:  if (elementType)
branch  0 never executed
branch  1 never executed
    #####:  268:    return VectorType::get(type.getShape(), elementType);
call    0 never executed
call    1 never executed
    #####:  269:  return nullptr;
        -:  270:}
        -:  271:
        -:  272:/// Converts a tensor `type` to a suitable type under the given `targetEnv`.
        -:  273:///
        -:  274:/// Note that this is mainly for lowering constant tensors. In SPIR-V one can
        -:  275:/// create composite constants with OpConstantComposite to embed relative large
        -:  276:/// constant values and use OpCompositeExtract and OpCompositeInsert to
        -:  277:/// manipulate, like what we do for vectors.
function _ZL17convertTensorTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10TensorTypeE called 6533 returned 100% blocks executed 40%
     6533:  278:static Type convertTensorType(const spirv::TargetEnv &targetEnv,
        -:  279:                              const SPIRVConversionOptions &options,
        -:  280:                              TensorType type) {
        -:  281:  // TODO: Handle dynamic shapes.
     6533:  282:  if (!type.hasStaticShape()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  283:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  284:               << type << " illegal: dynamic shape unimplemented\n");
    #####:  285:    return nullptr;
        -:  286:  }
        -:  287:
     6533:  288:  auto scalarType = type.getElementType().dyn_cast<spirv::ScalarType>();
call    0 returned 100%
call    1 returned 100%
     6533:  289:  if (!scalarType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  290:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  291:               << type << " illegal: cannot convert non-scalar element type\n");
    #####:  292:    return nullptr;
        -:  293:  }
        -:  294:
     6533:  295:  Optional<int64_t> scalarSize = getTypeNumBytes(options, scalarType);
call    0 returned 100%
     6533:  296:  Optional<int64_t> tensorSize = getTypeNumBytes(options, type);
call    0 returned 100%
     6533:  297:  if (!scalarSize || !tensorSize) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      18*:  298:    LLVM_DEBUG(llvm::dbgs()
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  299:               << type << " illegal: cannot deduce element count\n");
       18:  300:    return nullptr;
        -:  301:  }
        -:  302:
     6515:  303:  auto arrayElemCount = *tensorSize / *scalarSize;
call    0 returned 100%
     6515:  304:  auto arrayElemType = convertScalarType(targetEnv, options, scalarType);
call    0 returned 100%
     6515:  305:  if (!arrayElemType)
branch  0 taken 0%
branch  1 taken 100%
    #####:  306:    return nullptr;
     6515:  307:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 returned 100%
     6515:  308:  if (!arrayElemSize) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  309:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  310:               << type << " illegal: cannot deduce converted element size\n");
    #####:  311:    return nullptr;
        -:  312:  }
        -:  313:
     6515:  314:  return spirv::ArrayType::get(arrayElemType, arrayElemCount);
call    0 returned 100%
        -:  315:}
        -:  316:
function _ZL21convertBoolMemrefTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10MemRefTypeENS0_12StorageClassE called 0 returned 0% blocks executed 0%
    #####:  317:static Type convertBoolMemrefType(const spirv::TargetEnv &targetEnv,
        -:  318:                                  const SPIRVConversionOptions &options,
        -:  319:                                  MemRefType type,
        -:  320:                                  spirv::StorageClass storageClass) {
    #####:  321:  unsigned numBoolBits = options.boolNumBits;
    #####:  322:  if (numBoolBits != 8) {
branch  0 never executed
branch  1 never executed
    #####:  323:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  324:               << "using non-8-bit storage for bool types unimplemented");
    #####:  325:    return nullptr;
        -:  326:  }
    #####:  327:  auto elementType = IntegerType::get(type.getContext(), numBoolBits)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  328:                         .dyn_cast<spirv::ScalarType>();
    #####:  329:  if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  330:    return nullptr;
    #####:  331:  Type arrayElemType =
call    0 never executed
    #####:  332:      convertScalarType(targetEnv, options, elementType, storageClass);
call    0 never executed
    #####:  333:  if (!arrayElemType)
branch  0 never executed
branch  1 never executed
    #####:  334:    return nullptr;
    #####:  335:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 never executed
    #####:  336:  if (!arrayElemSize) {
branch  0 never executed
branch  1 never executed
    #####:  337:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  338:               << type << " illegal: cannot deduce converted element size\n");
    #####:  339:    return nullptr;
        -:  340:  }
        -:  341:
        -:  342:
    #####:  343:  if (!type.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  344:    // For OpenCL Kernel, dynamic shaped memrefs convert into a pointer pointing
        -:  345:    // to the element.
    #####:  346:    if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:      return spirv::PointerType::get(arrayElemType, storageClass);
call    0 never executed
    #####:  348:    int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  349:    auto arrayType = spirv::RuntimeArrayType::get(arrayElemType, stride);
call    0 never executed
        -:  350:    // For Vulkan we need extra wrapping struct and array to satisfy interface
        -:  351:    // needs.
    #####:  352:    return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  353:  }
        -:  354:
    #####:  355:  int64_t memrefSize = (type.getNumElements() * numBoolBits + 7) / 8;
call    0 never executed
    #####:  356:  auto arrayElemCount = llvm::divideCeil(memrefSize, *arrayElemSize);
call    0 never executed
    #####:  357:  int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  358:  auto arrayType = spirv::ArrayType::get(arrayElemType, arrayElemCount, stride);
call    0 never executed
    #####:  359:  if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  360:    return spirv::PointerType::get(arrayType, storageClass);
call    0 never executed
    #####:  361:  return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  362:}
        -:  363:
function _ZL17convertMemrefTypeRKN4mlir5spirv9TargetEnvERKNS_22SPIRVConversionOptionsENS_10MemRefTypeE called 11 returned 100% blocks executed 8%
       11:  364:static Type convertMemrefType(const spirv::TargetEnv &targetEnv,
        -:  365:                              const SPIRVConversionOptions &options,
        -:  366:                              MemRefType type) {
       11:  367:  auto attr = type.getMemorySpace().dyn_cast_or_null<spirv::StorageClassAttr>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       11:  368:  if (!attr) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      11*:  369:    LLVM_DEBUG(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  370:        llvm::dbgs()
        -:  371:        << type
        -:  372:        << " illegal: expected memory space to be a SPIR-V storage class "
        -:  373:           "attribute; please use MemorySpaceToStorageClassConverter to map "
        -:  374:           "numeric memory spaces beforehand\n");
       11:  375:    return nullptr;
        -:  376:  }
    #####:  377:  spirv::StorageClass storageClass = attr.getValue();
call    0 never executed
        -:  378:
    #####:  379:  if (type.getElementType().isa<IntegerType>() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  380:      type.getElementTypeBitWidth() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  381:    return convertBoolMemrefType(targetEnv, options, type, storageClass);
call    0 never executed
        -:  382:  }
        -:  383:
    #####:  384:  Type arrayElemType;
    #####:  385:  Type elementType = type.getElementType();
call    0 never executed
    #####:  386:  if (auto vecType = elementType.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:    arrayElemType =
call    0 never executed
    #####:  388:        convertVectorType(targetEnv, options, vecType, storageClass);
call    0 never executed
    #####:  389:  } else if (auto scalarType = elementType.dyn_cast<spirv::ScalarType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  390:    arrayElemType =
call    0 never executed
    #####:  391:        convertScalarType(targetEnv, options, scalarType, storageClass);
call    0 never executed
        -:  392:  } else {
    #####:  393:    LLVM_DEBUG(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  394:        llvm::dbgs()
        -:  395:        << type
        -:  396:        << " unhandled: can only convert scalar or vector element type\n");
    #####:  397:    return nullptr;
        -:  398:  }
    #####:  399:  if (!arrayElemType)
branch  0 never executed
branch  1 never executed
    #####:  400:    return nullptr;
        -:  401:
    #####:  402:  Optional<int64_t> arrayElemSize = getTypeNumBytes(options, arrayElemType);
call    0 never executed
    #####:  403:  if (!arrayElemSize) {
branch  0 never executed
branch  1 never executed
    #####:  404:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  405:               << type << " illegal: cannot deduce converted element size\n");
    #####:  406:    return nullptr;
        -:  407:  }
        -:  408:
        -:  409:
    #####:  410:  if (!type.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  411:    // For OpenCL Kernel, dynamic shaped memrefs convert into a pointer pointing
        -:  412:    // to the element.
    #####:  413:    if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  414:      return spirv::PointerType::get(arrayElemType, storageClass);
call    0 never executed
    #####:  415:    int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  416:    auto arrayType = spirv::RuntimeArrayType::get(arrayElemType, stride);
call    0 never executed
        -:  417:    // For Vulkan we need extra wrapping struct and array to satisfy interface
        -:  418:    // needs.
    #####:  419:    return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  420:  }
        -:  421:
    #####:  422:  Optional<int64_t> memrefSize = getTypeNumBytes(options, type);
call    0 never executed
    #####:  423:  if (!memrefSize) {
branch  0 never executed
branch  1 never executed
    #####:  424:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  425:               << type << " illegal: cannot deduce element count\n");
    #####:  426:    return nullptr;
        -:  427:  }
        -:  428:
    #####:  429:  auto arrayElemCount = llvm::divideCeil(*memrefSize, *arrayElemSize);
call    0 never executed
    #####:  430:  int64_t stride = needsExplicitLayout(storageClass) ? *arrayElemSize : 0;
branch  0 never executed
branch  1 never executed
    #####:  431:  auto arrayType = spirv::ArrayType::get(arrayElemType, arrayElemCount, stride);
call    0 never executed
    #####:  432:  if (targetEnv.allows(spirv::Capability::Kernel))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  433:    return spirv::PointerType::get(arrayType, storageClass);
call    0 never executed
    #####:  434:  return wrapInStructAndGetPointer(arrayType, storageClass);
call    0 never executed
        -:  435:}
        -:  436:
function _ZN4mlir18SPIRVTypeConverterC2ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsE called 7045 returned 100% blocks executed 100%
     7045:  437:SPIRVTypeConverter::SPIRVTypeConverter(spirv::TargetEnvAttr targetAttr,
     7045:  438:                                       const SPIRVConversionOptions &options)
     7045:  439:    : targetEnv(targetAttr), options(options) {
call    0 returned 100%
call    1 returned 100%
        -:  440:  // Add conversions. The order matters here: later ones will be tried earlier.
        -:  441:
        -:  442:  // Allow all SPIR-V dialect specific types. This assumes all builtin types
        -:  443:  // adopted in the SPIR-V dialect (i.e., IntegerType, FloatType, VectorType)
        -:  444:  // were tried before.
        -:  445:  //
        -:  446:  // TODO: this assumes that the SPIR-V types are valid to use in
        -:  447:  // the given target environment, which should be the case if the whole
        -:  448:  // pipeline is driven by the same target environment. Still, we probably still
        -:  449:  // want to validate and convert to be safe.
    7045*:  450:  addConversion([](spirv::SPIRVType type) { return type; });
call    0 never executed
call    1 returned 100%
        -:  451:
     7081:  452:  addConversion([this](IndexType /*indexType*/) { return getIndexType(); });
call    0 returned 100%
call    1 returned 100%
        -:  453:
function _ZZN4mlir18SPIRVTypeConverterC4ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsEENKUlNS_11IntegerTypeEE1_clES6_.isra.0 called 10 returned 100% blocks executed 86%
     7065:  454:  addConversion([this](IntegerType intType) -> Optional<Type> {
call    0 returned 100%
call    1 returned 100%
       10:  455:    if (auto scalarType = intType.dyn_cast<spirv::ScalarType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       10:  456:      return convertScalarType(this->targetEnv, this->options, scalarType);
call    0 returned 100%
    #####:  457:    return Type();
        -:  458:  });
        -:  459:
function _ZZN4mlir18SPIRVTypeConverterC4ENS_5spirv13TargetEnvAttrERKNS_22SPIRVConversionOptionsEENKUlNS_9FloatTypeEE2_clES6_.isra.0 called 4 returned 100% blocks executed 86%
     7053:  460:  addConversion([this](FloatType floatType) -> Optional<Type> {
call    0 returned 100%
call    1 returned 100%
        4:  461:    if (auto scalarType = floatType.dyn_cast<spirv::ScalarType>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        4:  462:      return convertScalarType(this->targetEnv, this->options, scalarType);
call    0 returned 100%
    #####:  463:    return Type();
        -:  464:  });
        -:  465:
    7045*:  466:  addConversion([this](VectorType vectorType) {
call    0 returned 100%
    #####:  467:    return convertVectorType(this->targetEnv, this->options, vectorType);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  468:  });
        -:  469:
     7045:  470:  addConversion([this](TensorType tensorType) {
call    0 returned 100%
     6533:  471:    return convertTensorType(this->targetEnv, this->options, tensorType);
call    0 returned 100%
        -:  472:  });
        -:  473:
     7045:  474:  addConversion([this](MemRefType memRefType) {
call    0 returned 100%
       11:  475:    return convertMemrefType(this->targetEnv, this->options, memRefType);
call    0 returned 100%
        -:  476:  });
     7045:  477:}
        -:  478:
        -:  479://===----------------------------------------------------------------------===//
        -:  480:// func::FuncOp Conversion Patterns
        -:  481://===----------------------------------------------------------------------===//
        -:  482:
        -:  483:namespace {
        -:  484:/// A pattern for rewriting function signature to convert arguments of functions
        -:  485:/// to be of valid SPIR-V types.
        -:  486:class FuncOpConversion final : public OpConversionPattern<func::FuncOp> {
        -:  487:public:
        -:  488:  using OpConversionPattern<func::FuncOp>::OpConversionPattern;
        -:  489:
        -:  490:  LogicalResult
        -:  491:  matchAndRewrite(func::FuncOp funcOp, OpAdaptor adaptor,
        -:  492:                  ConversionPatternRewriter &rewriter) const override;
        -:  493:};
        -:  494:} // namespace
        -:  495:
        -:  496:LogicalResult
function _ZNK12_GLOBAL__N_116FuncOpConversion15matchAndRewriteEN4mlir4func6FuncOpENS2_13FuncOpAdaptorERNS1_25ConversionPatternRewriterE called 2837 returned 100% blocks executed 96%
     2837:  497:FuncOpConversion::matchAndRewrite(func::FuncOp funcOp, OpAdaptor adaptor,
        -:  498:                                  ConversionPatternRewriter &rewriter) const {
     2837:  499:  auto fnType = funcOp.getFunctionType();
call    0 returned 100%
     2837:  500:  if (fnType.getNumResults() > 1)
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
     2089:  501:    return failure();
        -:  502:
      748:  503:  TypeConverter::SignatureConversion signatureConverter(fnType.getNumInputs());
call    0 returned 100%
call    1 returned 100%
     1807:  504:  for (const auto &argType : enumerate(fnType.getInputs())) {
call    0 returned 100%
branch  1 taken 69% (fallthrough)
branch  2 taken 31%
     1240:  505:    auto convertedType = getTypeConverter()->convertType(argType.value());
call    0 returned 100%
     1240:  506:    if (!convertedType)
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
      181:  507:      return failure();
     1059:  508:    signatureConverter.addInputs(argType.index(), convertedType);
call    0 returned 100%
call    1 returned 100%
        -:  509:  }
        -:  510:
      567:  511:  Type resultType;
      567:  512:  if (fnType.getNumResults() == 1) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      567:  513:    resultType = getTypeConverter()->convertType(fnType.getResult(0));
call    0 returned 100%
call    1 returned 100%
      567:  514:    if (!resultType)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
       45:  515:      return failure();
        -:  516:  }
        -:  517:
        -:  518:  // Create the converted spirv.func op.
      522:  519:  auto newFuncOp = rewriter.create<spirv::FuncOp>(
      522:  520:      funcOp.getLoc(), funcOp.getName(),
call    0 returned 100%
      522:  521:      rewriter.getFunctionType(signatureConverter.getConvertedTypes(),
        -:  522:                               resultType ? TypeRange(resultType)
    1566*:  523:                                          : TypeRange()));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  524:
        -:  525:  // Copy over all attributes other than the function name and type.
     2604:  526:  for (const auto &namedAttr : funcOp->getAttrs()) {
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
     4164:  527:    if (namedAttr.getName() != FunctionOpInterface::getTypeAttrName() &&
call    0 returned 100%
branch  1 taken 75% (fallthrough)
branch  2 taken 25%
     3120:  528:        namedAttr.getName() != SymbolTable::getSymbolAttrName())
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
     1038:  529:      newFuncOp->setAttr(namedAttr.getName(), namedAttr.getValue());
call    0 returned 100%
call    1 returned 100%
        -:  530:  }
        -:  531:
      522:  532:  rewriter.inlineRegionBefore(funcOp.getBody(), newFuncOp.getBody(),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  533:                              newFuncOp.end());
      522:  534:  if (failed(rewriter.convertRegionTypes(
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      522:  535:          &newFuncOp.getBody(), *getTypeConverter(), &signatureConverter)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  536:    return failure();
      522:  537:  rewriter.eraseOp(funcOp);
call    0 returned 100%
      748:  538:  return success();
call    0 returned 100%
        -:  539:}
        -:  540:
function _ZN4mlir34populateBuiltinFuncToSPIRVPatternsERNS_18SPIRVTypeConverterERNS_17RewritePatternSetE called 2618 returned 100% blocks executed 100%
     2618:  541:void mlir::populateBuiltinFuncToSPIRVPatterns(SPIRVTypeConverter &typeConverter,
        -:  542:                                              RewritePatternSet &patterns) {
     2618:  543:  patterns.add<FuncOpConversion>(typeConverter, patterns.getContext());
call    0 returned 100%
     2618:  544:}
        -:  545:
        -:  546://===----------------------------------------------------------------------===//
        -:  547:// Builtin Variables
        -:  548://===----------------------------------------------------------------------===//
        -:  549:
function _ZL18getBuiltinVariableRN4mlir5BlockENS_5spirv7BuiltInE called 0 returned 0% blocks executed 0%
    #####:  550:static spirv::GlobalVariableOp getBuiltinVariable(Block &body,
        -:  551:                                                  spirv::BuiltIn builtin) {
        -:  552:  // Look through all global variables in the given `body` block and check if
        -:  553:  // there is a spirv.GlobalVariable that has the same `builtin` attribute.
    #####:  554:  for (auto varOp : body.getOps<spirv::GlobalVariableOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  555:    if (auto builtinAttr = varOp->getAttrOfType<StringAttr>(
branch  0 never executed
branch  1 never executed
    #####:  556:            spirv::SPIRVDialect::getAttributeName(
call    0 never executed
call    1 never executed
    #####:  557:                spirv::Decoration::BuiltIn))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  558:      auto varBuiltIn = spirv::symbolizeBuiltIn(builtinAttr.getValue());
call    0 never executed
call    1 never executed
    #####:  559:      if (varBuiltIn && *varBuiltIn == builtin) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:        return varOp;
        -:  561:      }
        -:  562:    }
        -:  563:  }
    #####:  564:  return nullptr;
        -:  565:}
        -:  566:
        -:  567:/// Gets name of global variable for a builtin.
function _ZL17getBuiltinVarNameN4mlir5spirv7BuiltInE called 0 returned 0% blocks executed 0%
    #####:  568:static std::string getBuiltinVarName(spirv::BuiltIn builtin) {
    #####:  569:  return std::string("__builtin_var_") + stringifyBuiltIn(builtin).str() + "__";
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -:  570:}
        -:  571:
        -:  572:/// Gets or inserts a global variable for a builtin within `body` block.
        -:  573:static spirv::GlobalVariableOp
function _ZL26getOrInsertBuiltinVariableRN4mlir5BlockENS_8LocationENS_5spirv7BuiltInENS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  574:getOrInsertBuiltinVariable(Block &body, Location loc, spirv::BuiltIn builtin,
        -:  575:                           Type integerType, OpBuilder &builder) {
    #####:  576:  if (auto varOp = getBuiltinVariable(body, builtin))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  577:    return varOp;
        -:  578:
    #####:  579:  OpBuilder::InsertionGuard guard(builder);
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  580:  builder.setInsertionPointToStart(&body);
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  581:
    #####:  582:  spirv::GlobalVariableOp newVarOp;
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  583:  switch (builtin) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####:  584:  case spirv::BuiltIn::NumWorkgroups:
    #####:  585:  case spirv::BuiltIn::WorkgroupSize:
    #####:  586:  case spirv::BuiltIn::WorkgroupId:
    #####:  587:  case spirv::BuiltIn::LocalInvocationId:
    #####:  588:  case spirv::BuiltIn::GlobalInvocationId: {
    #####:  589:    auto ptrType = spirv::PointerType::get(VectorType::get({3}, integerType),
call    0 never executed
    #####:  590:                                           spirv::StorageClass::Input);
call    0 never executed
    #####:  591:    std::string name = getBuiltinVarName(builtin);
call    0 never executed
    #####:  592:    newVarOp =
    #####:  593:        builder.create<spirv::GlobalVariableOp>(loc, ptrType, name, builtin);
call    0 never executed
    #####:  594:    break;
branch  0 never executed
branch  1 never executed
        -:  595:  }
    #####:  596:  case spirv::BuiltIn::SubgroupId:
    #####:  597:  case spirv::BuiltIn::NumSubgroups:
    #####:  598:  case spirv::BuiltIn::SubgroupSize: {
    #####:  599:    auto ptrType =
    #####:  600:        spirv::PointerType::get(integerType, spirv::StorageClass::Input);
call    0 never executed
    #####:  601:    std::string name = getBuiltinVarName(builtin);
call    0 never executed
    #####:  602:    newVarOp =
    #####:  603:        builder.create<spirv::GlobalVariableOp>(loc, ptrType, name, builtin);
call    0 never executed
    #####:  604:    break;
branch  0 never executed
branch  1 never executed
        -:  605:  }
    #####:  606:  default:
    #####:  607:    emitError(loc, "unimplemented builtin variable generation for ")
call    0 never executed
call    1 never executed
    #####:  608:        << stringifyBuiltIn(builtin);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  609:  }
    #####:  610:  return newVarOp;
branch  0 never executed
branch  1 never executed
        -:  611:}
        -:  612:
function _ZN4mlir5spirv23getBuiltinVariableValueEPNS_9OperationENS0_7BuiltInENS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  613:Value mlir::spirv::getBuiltinVariableValue(Operation *op,
        -:  614:                                           spirv::BuiltIn builtin,
        -:  615:                                           Type integerType,
        -:  616:                                           OpBuilder &builder) {
    #####:  617:  Operation *parent = SymbolTable::getNearestSymbolTable(op->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  618:  if (!parent) {
branch  0 never executed
branch  1 never executed
    #####:  619:    op->emitError("expected operation to be within a module-like op");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  620:    return nullptr;
        -:  621:  }
        -:  622:
    #####:  623:  spirv::GlobalVariableOp varOp =
    #####:  624:      getOrInsertBuiltinVariable(*parent->getRegion(0).begin(), op->getLoc(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  625:                                 builtin, integerType, builder);
call    0 never executed
call    1 never executed
    #####:  626:  Value ptr = builder.create<spirv::AddressOfOp>(op->getLoc(), varOp);
call    0 never executed
call    1 never executed
    #####:  627:  return builder.create<spirv::LoadOp>(op->getLoc(), ptr);
call    0 never executed
        -:  628:}
        -:  629:
        -:  630://===----------------------------------------------------------------------===//
        -:  631:// Push constant storage
        -:  632://===----------------------------------------------------------------------===//
        -:  633:
        -:  634:/// Returns the pointer type for the push constant storage containing
        -:  635:/// `elementCount` 32-bit integer values.
        -:  636:static spirv::PointerType getPushConstantStorageType(unsigned elementCount,
        -:  637:                                                     Builder &builder,
        -:  638:                                                     Type indexType) {
        -:  639:  auto arrayType = spirv::ArrayType::get(indexType, elementCount,
        -:  640:                                         /*stride=*/4);
        -:  641:  auto structType = spirv::StructType::get({arrayType}, /*offsetInfo=*/0);
        -:  642:  return spirv::PointerType::get(structType, spirv::StorageClass::PushConstant);
        -:  643:}
        -:  644:
        -:  645:/// Returns the push constant varible containing `elementCount` 32-bit integer
        -:  646:/// values in `body`. Returns null op if such an op does not exit.
function _ZL23getPushConstantVariableRN4mlir5BlockEj called 0 returned 0% blocks executed 0%
    #####:  647:static spirv::GlobalVariableOp getPushConstantVariable(Block &body,
        -:  648:                                                       unsigned elementCount) {
    #####:  649:  for (auto varOp : body.getOps<spirv::GlobalVariableOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  650:    auto ptrType = varOp.getType().dyn_cast<spirv::PointerType>();
call    0 never executed
call    1 never executed
    #####:  651:    if (!ptrType)
branch  0 never executed
branch  1 never executed
    #####:  652:      continue;
        -:  653:
        -:  654:    // Note that Vulkan requires "There must be no more than one push constant
        -:  655:    // block statically used per shader entry point." So we should always reuse
        -:  656:    // the existing one.
    #####:  657:    if (ptrType.getStorageClass() == spirv::StorageClass::PushConstant) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  658:      auto numElements = ptrType.getPointeeType()
call    0 never executed
call    1 never executed
    #####:  659:                             .cast<spirv::StructType>()
    #####:  660:                             .getElementType(0)
call    0 never executed
call    1 never executed
    #####:  661:                             .cast<spirv::ArrayType>()
    #####:  662:                             .getNumElements();
call    0 never executed
    #####:  663:      if (numElements == elementCount)
branch  0 never executed
branch  1 never executed
    #####:  664:        return varOp;
        -:  665:    }
        -:  666:  }
    #####:  667:  return nullptr;
        -:  668:}
        -:  669:
        -:  670:/// Gets or inserts a global variable for push constant storage containing
        -:  671:/// `elementCount` 32-bit integer values in `block`.
        -:  672:static spirv::GlobalVariableOp
function _ZL31getOrInsertPushConstantVariableN4mlir8LocationERNS_5BlockEjRNS_9OpBuilderENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  673:getOrInsertPushConstantVariable(Location loc, Block &block,
        -:  674:                                unsigned elementCount, OpBuilder &b,
        -:  675:                                Type indexType) {
    #####:  676:  if (auto varOp = getPushConstantVariable(block, elementCount))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  677:    return varOp;
        -:  678:
    #####:  679:  auto builder = OpBuilder::atBlockBegin(&block, b.getListener());
call    0 never executed
    #####:  680:  auto type = getPushConstantStorageType(elementCount, builder, indexType);
call    0 never executed
    #####:  681:  const char *name = "__push_constant_var__";
    #####:  682:  return builder.create<spirv::GlobalVariableOp>(loc, type, name,
    #####:  683:                                                 /*initializer=*/nullptr);
call    0 never executed
        -:  684:}
        -:  685:
function _ZN4mlir5spirv20getPushConstantValueEPNS_9OperationEjjNS_4TypeERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  686:Value spirv::getPushConstantValue(Operation *op, unsigned elementCount,
        -:  687:                                  unsigned offset, Type integerType,
        -:  688:                                  OpBuilder &builder) {
    #####:  689:  Location loc = op->getLoc();
branch  0 never executed
branch  1 never executed
    #####:  690:  Operation *parent = SymbolTable::getNearestSymbolTable(op->getParentOp());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  691:  if (!parent) {
branch  0 never executed
branch  1 never executed
    #####:  692:    op->emitError("expected operation to be within a module-like op");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  693:    return nullptr;
        -:  694:  }
        -:  695:
    #####:  696:  spirv::GlobalVariableOp varOp = getOrInsertPushConstantVariable(
    #####:  697:      loc, parent->getRegion(0).front(), elementCount, builder, integerType);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  698:
    #####:  699:  Value zeroOp = spirv::ConstantOp::getZero(integerType, loc, builder);
call    0 never executed
call    1 never executed
    #####:  700:  Value offsetOp = builder.create<spirv::ConstantOp>(
    #####:  701:      loc, integerType, builder.getI32IntegerAttr(offset));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  702:  auto addrOp = builder.create<spirv::AddressOfOp>(loc, varOp);
call    0 never executed
    #####:  703:  auto acOp = builder.create<spirv::AccessChainOp>(
    #####:  704:      loc, addrOp, llvm::makeArrayRef({zeroOp, offsetOp}));
call    0 never executed
    #####:  705:  return builder.create<spirv::LoadOp>(loc, acOp);
call    0 never executed
        -:  706:}
        -:  707:
        -:  708://===----------------------------------------------------------------------===//
        -:  709:// Index calculation
        -:  710://===----------------------------------------------------------------------===//
        -:  711:
function _ZN4mlir5spirv14linearizeIndexENS_10ValueRangeEN4llvm8ArrayRefIlEElNS_4TypeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  712:Value mlir::spirv::linearizeIndex(ValueRange indices, ArrayRef<int64_t> strides,
        -:  713:                                  int64_t offset, Type integerType,
        -:  714:                                  Location loc, OpBuilder &builder) {
    #####:  715:  assert(indices.size() == strides.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  716:         "must provide indices for all dimensions");
        -:  717:
        -:  718:  // TODO: Consider moving to use affine.apply and patterns converting
        -:  719:  // affine.apply to standard ops. This needs converting to SPIR-V passes to be
        -:  720:  // broken down into progressive small steps so we can have intermediate steps
        -:  721:  // using other dialects. At the moment SPIR-V is the final sink.
        -:  722:
    #####:  723:  Value linearizedIndex = builder.create<spirv::ConstantOp>(
    #####:  724:      loc, integerType, IntegerAttr::get(integerType, offset));
call    0 never executed
call    1 never executed
    #####:  725:  for (const auto &index : llvm::enumerate(indices)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  726:    Value strideVal = builder.create<spirv::ConstantOp>(
        -:  727:        loc, integerType,
    #####:  728:        IntegerAttr::get(integerType, strides[index.index()]));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  729:    Value update = builder.create<spirv::IMulOp>(loc, strideVal, index.value());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  730:    linearizedIndex =
    #####:  731:        builder.create<spirv::IAddOp>(loc, linearizedIndex, update);
call    0 never executed
        -:  732:  }
    #####:  733:  return linearizedIndex;
        -:  734:}
        -:  735:
function _ZN4mlir5spirv19getVulkanElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  736:Value mlir::spirv::getVulkanElementPtr(SPIRVTypeConverter &typeConverter,
        -:  737:                                       MemRefType baseType, Value basePtr,
        -:  738:                                       ValueRange indices, Location loc,
        -:  739:                                       OpBuilder &builder) {
        -:  740:  // Get base and offset of the MemRefType and verify they are static.
        -:  741:
    #####:  742:  int64_t offset;
    #####:  743:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  744:  if (failed(getStridesAndOffset(baseType, strides, offset)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  745:      llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  746:      offset == MemRefType::getDynamicStrideOrOffset()) {
branch  0 never executed
branch  1 never executed
    #####:  747:    return nullptr;
        -:  748:  }
        -:  749:
    #####:  750:  auto indexType = typeConverter.getIndexType();
call    0 never executed
        -:  751:
    #####:  752:  SmallVector<Value, 2> linearizedIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  753:  auto zero = spirv::ConstantOp::getZero(indexType, loc, builder);
call    0 never executed
        -:  754:
        -:  755:  // Add a '0' at the start to index into the struct.
    #####:  756:  linearizedIndices.push_back(zero);
call    0 never executed
        -:  757:
    #####:  758:  if (baseType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  759:    linearizedIndices.push_back(zero);
call    0 never executed
        -:  760:  } else {
    #####:  761:    linearizedIndices.push_back(
call    0 never executed
call    1 never executed
        -:  762:        linearizeIndex(indices, strides, offset, indexType, loc, builder));
        -:  763:  }
    #####:  764:  return builder.create<spirv::AccessChainOp>(loc, basePtr, linearizedIndices);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  765:}
        -:  766:
function _ZN4mlir5spirv19getOpenCLElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  767:Value mlir::spirv::getOpenCLElementPtr(SPIRVTypeConverter &typeConverter,
        -:  768:                                       MemRefType baseType, Value basePtr,
        -:  769:                                       ValueRange indices, Location loc,
        -:  770:                                       OpBuilder &builder) {
        -:  771:  // Get base and offset of the MemRefType and verify they are static.
        -:  772:
    #####:  773:  int64_t offset;
    #####:  774:  SmallVector<int64_t, 4> strides;
call    0 never executed
    #####:  775:  if (failed(getStridesAndOffset(baseType, strides, offset)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  776:      llvm::is_contained(strides, MemRefType::getDynamicStrideOrOffset()) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  777:      offset == MemRefType::getDynamicStrideOrOffset()) {
branch  0 never executed
branch  1 never executed
    #####:  778:    return nullptr;
        -:  779:  }
        -:  780:
    #####:  781:  auto indexType = typeConverter.getIndexType();
call    0 never executed
        -:  782:
    #####:  783:  SmallVector<Value, 2> linearizedIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  784:  Value linearIndex;
    #####:  785:  if (baseType.getRank() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  786:    linearIndex = spirv::ConstantOp::getZero(indexType, loc, builder);
call    0 never executed
        -:  787:  } else {
    #####:  788:    linearIndex =
    #####:  789:        linearizeIndex(indices, strides, offset, indexType, loc, builder);
call    0 never executed
        -:  790:  }
    #####:  791:  Type pointeeType =
    #####:  792:      basePtr.getType().cast<spirv::PointerType>().getPointeeType();
call    0 never executed
call    1 never executed
    #####:  793:  if (pointeeType.isa<spirv::ArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  794:    linearizedIndices.push_back(linearIndex);
call    0 never executed
    #####:  795:    return builder.create<spirv::AccessChainOp>(loc, basePtr,
    #####:  796:                                                linearizedIndices);
call    0 never executed
        -:  797:  }
    #####:  798:  return builder.create<spirv::PtrAccessChainOp>(loc, basePtr, linearIndex,
    #####:  799:                                                 linearizedIndices);
call    0 never executed
        -:  800:}
        -:  801:
function _ZN4mlir5spirv13getElementPtrERNS_18SPIRVTypeConverterENS_10MemRefTypeENS_5ValueENS_10ValueRangeENS_8LocationERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  802:Value mlir::spirv::getElementPtr(SPIRVTypeConverter &typeConverter,
        -:  803:                                 MemRefType baseType, Value basePtr,
        -:  804:                                 ValueRange indices, Location loc,
        -:  805:                                 OpBuilder &builder) {
        -:  806:
    #####:  807:  if (typeConverter.allows(spirv::Capability::Kernel)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  808:    return getOpenCLElementPtr(typeConverter, baseType, basePtr, indices, loc,
    #####:  809:                               builder);
call    0 never executed
        -:  810:  }
        -:  811:
    #####:  812:  return getVulkanElementPtr(typeConverter, baseType, basePtr, indices, loc,
    #####:  813:                             builder);
call    0 never executed
        -:  814:}
        -:  815:
        -:  816://===----------------------------------------------------------------------===//
        -:  817:// SPIR-V ConversionTarget
        -:  818://===----------------------------------------------------------------------===//
        -:  819:
        -:  820:std::unique_ptr<SPIRVConversionTarget>
function _ZN4mlir21SPIRVConversionTarget3getENS_5spirv13TargetEnvAttrE called 7045 returned 100% blocks executed 100%
     7045:  821:SPIRVConversionTarget::get(spirv::TargetEnvAttr targetAttr) {
     7045:  822:  std::unique_ptr<SPIRVConversionTarget> target(
        -:  823:      // std::make_unique does not work here because the constructor is private.
     7045:  824:      new SPIRVConversionTarget(targetAttr));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     7045:  825:  SPIRVConversionTarget *targetPtr = target.get();
call    0 returned 100%
     7045:  826:  target->addDynamicallyLegalDialect<spirv::SPIRVDialect>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  827:      // We need to capture the raw pointer here because it is stable:
        -:  828:      // target will be destroyed once this function is returned.
     1106:  829:      [targetPtr](Operation *op) { return targetPtr->isLegalOp(op); });
call    0 returned 100%
     7045:  830:  return target;
        -:  831:}
        -:  832:
function _ZN4mlir21SPIRVConversionTargetC2ENS_5spirv13TargetEnvAttrE called 7045 returned 100% blocks executed 100%
     7045:  833:SPIRVConversionTarget::SPIRVConversionTarget(spirv::TargetEnvAttr targetAttr)
     7045:  834:    : ConversionTarget(*targetAttr.getContext()), targetEnv(targetAttr) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  835:
function _ZN4mlir21SPIRVConversionTarget9isLegalOpEPNS_9OperationE called 1106 returned 100% blocks executed 64%
     1106:  836:bool SPIRVConversionTarget::isLegalOp(Operation *op) {
        -:  837:  // Make sure this op is available at the given version. Ops not implementing
        -:  838:  // QueryMinVersionInterface/QueryMaxVersionInterface are available to all
        -:  839:  // SPIR-V versions.
     1106:  840:  if (auto minVersionIfx = dyn_cast<spirv::QueryMinVersionInterface>(op)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1106:  841:    Optional<spirv::Version> minVersion = minVersionIfx.getMinVersion();
call    0 returned 100%
     1106:  842:    if (minVersion && *minVersion > this->targetEnv.getVersion()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  843:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  844:                 << op->getName() << " illegal: requiring min version "
        -:  845:                 << spirv::stringifyVersion(*minVersion) << "\n");
    #####:  846:      return false;
        -:  847:    }
        -:  848:  }
     1106:  849:  if (auto maxVersionIfx = dyn_cast<spirv::QueryMaxVersionInterface>(op)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1106:  850:    Optional<spirv::Version> maxVersion = maxVersionIfx.getMaxVersion();
call    0 returned 100%
     1106:  851:    if (maxVersion && *maxVersion < this->targetEnv.getVersion()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
    #####:  852:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  853:                 << op->getName() << " illegal: requiring max version "
        -:  854:                 << spirv::stringifyVersion(*maxVersion) << "\n");
    #####:  855:      return false;
        -:  856:    }
        -:  857:  }
        -:  858:
        -:  859:  // Make sure this op's required extensions are allowed to use. Ops not
        -:  860:  // implementing QueryExtensionInterface do not require extensions to be
        -:  861:  // available.
     1106:  862:  if (auto extensions = dyn_cast<spirv::QueryExtensionInterface>(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1106:  863:    if (failed(checkExtensionRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2212:  864:                                          extensions.getExtensions())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  865:      return false;
        -:  866:
        -:  867:  // Make sure this op's required extensions are allowed to use. Ops not
        -:  868:  // implementing QueryCapabilityInterface do not require capabilities to be
        -:  869:  // available.
     1106:  870:  if (auto capabilities = dyn_cast<spirv::QueryCapabilityInterface>(op))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1106:  871:    if (failed(checkCapabilityRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2212:  872:                                           capabilities.getCapabilities())))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  873:      return false;
        -:  874:
     1106:  875:  SmallVector<Type, 4> valueTypes;
call    0 returned 100%
     1106:  876:  valueTypes.append(op->operand_type_begin(), op->operand_type_end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1106:  877:  valueTypes.append(op->result_type_begin(), op->result_type_end());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  878:
        -:  879:  // Ensure that all types have been converted to SPIRV types.
     1106:  880:  if (llvm::any_of(valueTypes,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  881:                   [](Type t) { return !t.isa<spirv::SPIRVType>(); }))
        -:  882:    return false;
        -:  883:
        -:  884:  // Special treatment for global variables, whose type requirements are
        -:  885:  // conveyed by type attributes.
     1106:  886:  if (auto globalVar = dyn_cast<spirv::GlobalVariableOp>(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  887:    valueTypes.push_back(globalVar.getType());
call    0 never executed
call    1 never executed
        -:  888:
        -:  889:  // Make sure the op's operands/results use types that are allowed by the
        -:  890:  // target environment.
     2212:  891:  SmallVector<ArrayRef<spirv::Extension>, 4> typeExtensions;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1106:  892:  SmallVector<ArrayRef<spirv::Capability>, 8> typeCapabilities;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     1690:  893:  for (Type valueType : valueTypes) {
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
      584:  894:    typeExtensions.clear();
call    0 returned 100%
      584:  895:    valueType.cast<spirv::SPIRVType>().getExtensions(typeExtensions);
call    0 returned 100%
call    1 returned 100%
      584:  896:    if (failed(checkExtensionRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  897:                                          typeExtensions)))
    #####:  898:      return false;
        -:  899:
      584:  900:    typeCapabilities.clear();
call    0 returned 100%
      584:  901:    valueType.cast<spirv::SPIRVType>().getCapabilities(typeCapabilities);
call    0 returned 100%
call    1 returned 100%
      584:  902:    if (failed(checkCapabilityRequirements(op->getName(), this->targetEnv,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  903:                                           typeCapabilities)))
        -:  904:      return false;
        -:  905:  }
        -:  906:
     1106:  907:  return true;
        -:  908:}
