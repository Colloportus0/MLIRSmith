        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/llvm/include/llvm/ADT/STLExtras.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:325580
        -:    1://===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:///
        -:    9:/// \file
        -:   10:/// This file contains some templates that are useful if you are working with
        -:   11:/// the STL at all.
        -:   12:///
        -:   13:/// No library is required when using these functions.
        -:   14:///
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_ADT_STLEXTRAS_H
        -:   18:#define LLVM_ADT_STLEXTRAS_H
        -:   19:
        -:   20:#include "llvm/ADT/ArrayRef.h"
        -:   21:#include "llvm/ADT/Optional.h"
        -:   22:#include "llvm/ADT/STLForwardCompat.h"
        -:   23:#include "llvm/ADT/STLFunctionalExtras.h"
        -:   24:#include "llvm/ADT/identity.h"
        -:   25:#include "llvm/ADT/iterator.h"
        -:   26:#include "llvm/ADT/iterator_range.h"
        -:   27:#include "llvm/Config/abi-breaking.h"
        -:   28:#include "llvm/Support/ErrorHandling.h"
        -:   29:#include <algorithm>
        -:   30:#include <cassert>
        -:   31:#include <cstddef>
        -:   32:#include <cstdint>
        -:   33:#include <cstdlib>
        -:   34:#include <functional>
        -:   35:#include <initializer_list>
        -:   36:#include <iterator>
        -:   37:#include <limits>
        -:   38:#include <memory>
        -:   39:#include <optional>
        -:   40:#include <tuple>
        -:   41:#include <type_traits>
        -:   42:#include <utility>
        -:   43:
        -:   44:#ifdef EXPENSIVE_CHECKS
        -:   45:#include <random> // for std::mt19937
        -:   46:#endif
        -:   47:
        -:   48:namespace llvm {
        -:   49:
        -:   50:// Only used by compiler if both template types are the same.  Useful when
        -:   51:// using SFINAE to test for the existence of member functions.
        -:   52:template <typename T, T> struct SameType;
        -:   53:
        -:   54:namespace detail {
        -:   55:
        -:   56:template <typename RangeT>
        -:   57:using IterOfRange = decltype(std::begin(std::declval<RangeT &>()));
        -:   58:
        -:   59:template <typename RangeT>
        -:   60:using ValueOfRange =
        -:   61:    std::remove_reference_t<decltype(*std::begin(std::declval<RangeT &>()))>;
        -:   62:
        -:   63:} // end namespace detail
        -:   64:
        -:   65://===----------------------------------------------------------------------===//
        -:   66://     Extra additions to <type_traits>
        -:   67://===----------------------------------------------------------------------===//
        -:   68:
        -:   69:template <typename T> struct make_const_ptr {
        -:   70:  using type = std::add_pointer_t<std::add_const_t<T>>;
        -:   71:};
        -:   72:
        -:   73:template <typename T> struct make_const_ref {
        -:   74:  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;
        -:   75:};
        -:   76:
        -:   77:namespace detail {
        -:   78:template <class, template <class...> class Op, class... Args> struct detector {
        -:   79:  using value_t = std::false_type;
        -:   80:};
        -:   81:template <template <class...> class Op, class... Args>
        -:   82:struct detector<std::void_t<Op<Args...>>, Op, Args...> {
        -:   83:  using value_t = std::true_type;
        -:   84:};
        -:   85:} // end namespace detail
        -:   86:
        -:   87:/// Detects if a given trait holds for some set of arguments 'Args'.
        -:   88:/// For example, the given trait could be used to detect if a given type
        -:   89:/// has a copy assignment operator:
        -:   90:///   template<class T>
        -:   91:///   using has_copy_assign_t = decltype(std::declval<T&>()
        -:   92:///                                                 = std::declval<const T&>());
        -:   93:///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;
        -:   94:template <template <class...> class Op, class... Args>
        -:   95:using is_detected = typename detail::detector<void, Op, Args...>::value_t;
        -:   96:
        -:   97:/// This class provides various trait information about a callable object.
        -:   98:///   * To access the number of arguments: Traits::num_args
        -:   99:///   * To access the type of an argument: Traits::arg_t<Index>
        -:  100:///   * To access the type of the result:  Traits::result_t
        -:  101:template <typename T, bool isClass = std::is_class<T>::value>
        -:  102:struct function_traits : public function_traits<decltype(&T::operator())> {};
        -:  103:
        -:  104:/// Overload for class function types.
        -:  105:template <typename ClassType, typename ReturnType, typename... Args>
        -:  106:struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {
        -:  107:  /// The number of arguments to this function.
        -:  108:  enum { num_args = sizeof...(Args) };
        -:  109:
        -:  110:  /// The result type of this function.
        -:  111:  using result_t = ReturnType;
        -:  112:
        -:  113:  /// The type of an argument to this function.
        -:  114:  template <size_t Index>
        -:  115:  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;
        -:  116:};
        -:  117:/// Overload for class function types.
        -:  118:template <typename ClassType, typename ReturnType, typename... Args>
        -:  119:struct function_traits<ReturnType (ClassType::*)(Args...), false>
        -:  120:    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};
        -:  121:/// Overload for non-class function types.
        -:  122:template <typename ReturnType, typename... Args>
        -:  123:struct function_traits<ReturnType (*)(Args...), false> {
        -:  124:  /// The number of arguments to this function.
        -:  125:  enum { num_args = sizeof...(Args) };
        -:  126:
        -:  127:  /// The result type of this function.
        -:  128:  using result_t = ReturnType;
        -:  129:
        -:  130:  /// The type of an argument to this function.
        -:  131:  template <size_t i>
        -:  132:  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;
        -:  133:};
        -:  134:template <typename ReturnType, typename... Args>
        -:  135:struct function_traits<ReturnType (*const)(Args...), false>
        -:  136:    : public function_traits<ReturnType (*)(Args...)> {};
        -:  137:/// Overload for non-class function type references.
        -:  138:template <typename ReturnType, typename... Args>
        -:  139:struct function_traits<ReturnType (&)(Args...), false>
        -:  140:    : public function_traits<ReturnType (*)(Args...)> {};
        -:  141:
        -:  142:/// traits class for checking whether type T is one of any of the given
        -:  143:/// types in the variadic list.
        -:  144:template <typename T, typename... Ts>
        -:  145:using is_one_of = std::disjunction<std::is_same<T, Ts>...>;
        -:  146:
        -:  147:/// traits class for checking whether type T is a base class for all
        -:  148:///  the given types in the variadic list.
        -:  149:template <typename T, typename... Ts>
        -:  150:using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;
        -:  151:
        -:  152:namespace detail {
        -:  153:template <typename T, typename... Us> struct TypesAreDistinct;
        -:  154:template <typename T, typename... Us>
        -:  155:struct TypesAreDistinct
        -:  156:    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&
        -:  157:                                       TypesAreDistinct<Us...>::value> {};
        -:  158:template <typename T> struct TypesAreDistinct<T> : std::true_type {};
        -:  159:} // namespace detail
        -:  160:
        -:  161:/// Determine if all types in Ts are distinct.
        -:  162:///
        -:  163:/// Useful to statically assert when Ts is intended to describe a non-multi set
        -:  164:/// of types.
        -:  165:///
        -:  166:/// Expensive (currently quadratic in sizeof(Ts...)), and so should only be
        -:  167:/// asserted once per instantiation of a type which requires it.
        -:  168:template <typename... Ts> struct TypesAreDistinct;
        -:  169:template <> struct TypesAreDistinct<> : std::true_type {};
        -:  170:template <typename... Ts>
        -:  171:struct TypesAreDistinct
        -:  172:    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};
        -:  173:
        -:  174:/// Find the first index where a type appears in a list of types.
        -:  175:///
        -:  176:/// FirstIndexOfType<T, Us...>::value is the first index of T in Us.
        -:  177:///
        -:  178:/// Typically only meaningful when it is otherwise statically known that the
        -:  179:/// type pack has no duplicate types. This should be guaranteed explicitly with
        -:  180:/// static_assert(TypesAreDistinct<Us...>::value).
        -:  181:///
        -:  182:/// It is a compile-time error to instantiate when T is not present in Us, i.e.
        -:  183:/// if is_one_of<T, Us...>::value is false.
        -:  184:template <typename T, typename... Us> struct FirstIndexOfType;
        -:  185:template <typename T, typename U, typename... Us>
        -:  186:struct FirstIndexOfType<T, U, Us...>
        -:  187:    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};
        -:  188:template <typename T, typename... Us>
        -:  189:struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};
        -:  190:
        -:  191:/// Find the type at a given index in a list of types.
        -:  192:///
        -:  193:/// TypeAtIndex<I, Ts...> is the type at index I in Ts.
        -:  194:template <size_t I, typename... Ts>
        -:  195:using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;
        -:  196:
        -:  197:/// Helper which adds two underlying types of enumeration type.
        -:  198:/// Implicit conversion to a common type is accepted.
        -:  199:template <typename EnumTy1, typename EnumTy2,
        -:  200:          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,
        -:  201:                                          std::underlying_type_t<EnumTy1>>,
        -:  202:          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,
        -:  203:                                          std::underlying_type_t<EnumTy2>>>
        -:  204:constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {
        -:  205:  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);
        -:  206:}
        -:  207:
        -:  208://===----------------------------------------------------------------------===//
        -:  209://     Extra additions to <iterator>
        -:  210://===----------------------------------------------------------------------===//
        -:  211:
        -:  212:namespace callable_detail {
        -:  213:
        -:  214:/// Templated storage wrapper for a callable.
        -:  215:///
        -:  216:/// This class is consistently default constructible, copy / move
        -:  217:/// constructible / assignable.
        -:  218:///
        -:  219:/// Supported callable types:
        -:  220:///  - Function pointer
        -:  221:///  - Function reference
        -:  222:///  - Lambda
        -:  223:///  - Function object
        -:  224:template <typename T,
        -:  225:          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>>
        -:  226:class Callable {
        -:  227:  using value_type = std::remove_reference_t<T>;
        -:  228:  using reference = value_type &;
        -:  229:  using const_reference = value_type const &;
        -:  230:
        -:  231:  std::optional<value_type> Obj;
        -:  232:
        -:  233:  static_assert(!std::is_pointer_v<value_type>,
        -:  234:                "Pointers to non-functions are not callable.");
        -:  235:
        -:  236:public:
        -:  237:  Callable() = default;
        -:  238:  Callable(T const &O) : Obj(std::in_place, O) {}
        -:  239:
        -:  240:  Callable(Callable const &Other) = default;
        -:  241:  Callable(Callable &&Other) = default;
        -:  242:
        -:  243:  Callable &operator=(Callable const &Other) {
        -:  244:    Obj = std::nullopt;
        -:  245:    if (Other.Obj)
        -:  246:      Obj.emplace(*Other.Obj);
        -:  247:    return *this;
        -:  248:  }
        -:  249:
        -:  250:  Callable &operator=(Callable &&Other) {
        -:  251:    Obj = std::nullopt;
        -:  252:    if (Other.Obj)
        -:  253:      Obj.emplace(std::move(*Other.Obj));
        -:  254:    return *this;
        -:  255:  }
        -:  256:
        -:  257:  template <typename... Pn,
        -:  258:            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
        -:  259:  decltype(auto) operator()(Pn &&...Params) {
        -:  260:    return (*Obj)(std::forward<Pn>(Params)...);
        -:  261:  }
        -:  262:
        -:  263:  template <typename... Pn,
        -:  264:            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0>
        -:  265:  decltype(auto) operator()(Pn &&...Params) const {
        -:  266:    return (*Obj)(std::forward<Pn>(Params)...);
        -:  267:  }
        -:  268:
        -:  269:  bool valid() const { return Obj != std::nullopt; }
        -:  270:  bool reset() { return Obj = std::nullopt; }
        -:  271:
        -:  272:  operator reference() { return *Obj; }
        -:  273:  operator const_reference() const { return *Obj; }
        -:  274:};
        -:  275:
        -:  276:// Function specialization.  No need to waste extra space wrapping with a
        -:  277:// std::optional.
        -:  278:template <typename T> class Callable<T, true> {
        -:  279:  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;
        -:  280:
        -:  281:  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;
        -:  282:  using CastT = std::conditional_t<IsPtr, T, T &>;
        -:  283:
        -:  284:private:
        -:  285:  StorageT Func = nullptr;
        -:  286:
        -:  287:private:
    #####:  288:  template <typename In> static constexpr auto convertIn(In &&I) {
        -:  289:    if constexpr (IsPtr) {
        -:  290:      // Pointer... just echo it back.
        -:  291:      return I;
        -:  292:    } else {
        -:  293:      // Must be a function reference.  Return its address.
        -:  294:      return &I;
        -:  295:    }
        -:  296:  }
        -:  297:
        -:  298:public:
        -:  299:  Callable() = default;
        -:  300:
        -:  301:  // Construct from a function pointer or reference.
        -:  302:  //
        -:  303:  // Disable this constructor for references to 'Callable' so we don't violate
        -:  304:  // the rule of 0.
        -:  305:  template < // clang-format off
        -:  306:    typename FnPtrOrRef,
        -:  307:    std::enable_if_t<
        -:  308:      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int
        -:  309:    > = 0
        -:  310:  > // clang-format on
    #####:  311:  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}
call    0 never executed
        -:  312:
        -:  313:  template <typename... Pn,
        -:  314:            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
        -:  315:  decltype(auto) operator()(Pn &&...Params) const {
        -:  316:    return Func(std::forward<Pn>(Params)...);
        -:  317:  }
        -:  318:
        -:  319:  bool valid() const { return Func != nullptr; }
        -:  320:  void reset() { Func = nullptr; }
        -:  321:
        -:  322:  operator T const &() const {
        -:  323:    if constexpr (IsPtr) {
        -:  324:      // T is a pointer... just echo it back.
        -:  325:      return Func;
        -:  326:    } else {
        -:  327:      static_assert(std::is_reference_v<T>,
        -:  328:                    "Expected a reference to a function.");
        -:  329:      // T is a function reference... dereference the stored pointer.
        -:  330:      return *Func;
        -:  331:    }
        -:  332:  }
        -:  333:};
        -:  334:
        -:  335:} // namespace callable_detail
        -:  336:
        -:  337:namespace adl_detail {
        -:  338:
        -:  339:using std::begin;
        -:  340:
        -:  341:template <typename ContainerTy>
    #####:  342:decltype(auto) adl_begin(ContainerTy &&container) {
    #####:  343:  return begin(std::forward<ContainerTy>(container));
        -:  344:}
        -:  345:
        -:  346:using std::end;
        -:  347:
        -:  348:template <typename ContainerTy>
    #####:  349:decltype(auto) adl_end(ContainerTy &&container) {
    #####:  350:  return end(std::forward<ContainerTy>(container));
        -:  351:}
        -:  352:
        -:  353:using std::swap;
        -:  354:
        -:  355:template <typename T>
        -:  356:void adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),
        -:  357:                                                       std::declval<T>()))) {
        -:  358:  swap(std::forward<T>(lhs), std::forward<T>(rhs));
        -:  359:}
        -:  360:
        -:  361:} // end namespace adl_detail
        -:  362:
        -:  363:template <typename ContainerTy>
    #####:  364:decltype(auto) adl_begin(ContainerTy &&container) {
    #####:  365:  return adl_detail::adl_begin(std::forward<ContainerTy>(container));
        -:  366:}
        -:  367:
        -:  368:template <typename ContainerTy>
    #####:  369:decltype(auto) adl_end(ContainerTy &&container) {
    #####:  370:  return adl_detail::adl_end(std::forward<ContainerTy>(container));
        -:  371:}
        -:  372:
        -:  373:template <typename T>
        -:  374:void adl_swap(T &&lhs, T &&rhs) noexcept(
        -:  375:    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {
        -:  376:  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));
        -:  377:}
        -:  378:
        -:  379:/// Test whether \p RangeOrContainer is empty. Similar to C++17 std::empty.
        -:  380:template <typename T>
        -:  381:LLVM_DEPRECATED("Use x.empty() instead", "empty")
        -:  382:constexpr bool empty(const T &RangeOrContainer) {
        -:  383:  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);
        -:  384:}
        -:  385:
        -:  386:/// Returns true if the given container only contains a single element.
        -:  387:template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {
        -:  388:  auto B = std::begin(C), E = std::end(C);
        -:  389:  return B != E && std::next(B) == E;
        -:  390:}
        -:  391:
        -:  392:/// Return a range covering \p RangeOrContainer with the first N elements
        -:  393:/// excluded.
        -:  394:template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {
        -:  395:  return make_range(std::next(adl_begin(RangeOrContainer), N),
        -:  396:                    adl_end(RangeOrContainer));
        -:  397:}
        -:  398:
        -:  399:/// Return a range covering \p RangeOrContainer with the last N elements
        -:  400:/// excluded.
        -:  401:template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {
        -:  402:  return make_range(adl_begin(RangeOrContainer),
        -:  403:                    std::prev(adl_end(RangeOrContainer), N));
        -:  404:}
        -:  405:
        -:  406:// mapped_iterator - This is a simple iterator adapter that causes a function to
        -:  407:// be applied whenever operator* is invoked on the iterator.
        -:  408:
        -:  409:template <typename ItTy, typename FuncTy,
        -:  410:          typename ReferenceTy =
        -:  411:              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>
        -:  412:class mapped_iterator
        -:  413:    : public iterator_adaptor_base<
        -:  414:          mapped_iterator<ItTy, FuncTy>, ItTy,
        -:  415:          typename std::iterator_traits<ItTy>::iterator_category,
        -:  416:          std::remove_reference_t<ReferenceTy>,
        -:  417:          typename std::iterator_traits<ItTy>::difference_type,
        -:  418:          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
        -:  419:public:
        -:  420:  mapped_iterator() = default;
    #####:  421:  mapped_iterator(ItTy U, FuncTy F)
    #####:  422:    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}
call    0 never executed
        -:  423:
        -:  424:  ItTy getCurrent() { return this->I; }
        -:  425:
        -:  426:  const FuncTy &getFunction() const { return F; }
        -:  427:
        -:  428:  ReferenceTy operator*() const { return F(*this->I); }
        -:  429:
        -:  430:private:
        -:  431:  callable_detail::Callable<FuncTy> F{};
        -:  432:};
        -:  433:
        -:  434:// map_iterator - Provide a convenient way to create mapped_iterators, just like
        -:  435:// make_pair is useful for creating pairs...
        -:  436:template <class ItTy, class FuncTy>
        -:  437:inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {
        -:  438:  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));
        -:  439:}
        -:  440:
        -:  441:template <class ContainerTy, class FuncTy>
        -:  442:auto map_range(ContainerTy &&C, FuncTy F) {
        -:  443:  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));
        -:  444:}
        -:  445:
        -:  446:/// A base type of mapped iterator, that is useful for building derived
        -:  447:/// iterators that do not need/want to store the map function (as in
        -:  448:/// mapped_iterator). These iterators must simply provide a `mapElement` method
        -:  449:/// that defines how to map a value of the iterator to the provided reference
        -:  450:/// type.
        -:  451:template <typename DerivedT, typename ItTy, typename ReferenceTy>
        -:  452:class mapped_iterator_base
        -:  453:    : public iterator_adaptor_base<
        -:  454:          DerivedT, ItTy,
        -:  455:          typename std::iterator_traits<ItTy>::iterator_category,
        -:  456:          std::remove_reference_t<ReferenceTy>,
        -:  457:          typename std::iterator_traits<ItTy>::difference_type,
        -:  458:          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
        -:  459:public:
        -:  460:  using BaseT = mapped_iterator_base;
        -:  461:
        -:  462:  mapped_iterator_base(ItTy U)
        -:  463:      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}
        -:  464:
        -:  465:  ItTy getCurrent() { return this->I; }
        -:  466:
    #####:  467:  ReferenceTy operator*() const {
    #####:  468:    return static_cast<const DerivedT &>(*this).mapElement(*this->I);
        -:  469:  }
        -:  470:};
        -:  471:
        -:  472:/// Helper to determine if type T has a member called rbegin().
        -:  473:template <typename Ty> class has_rbegin_impl {
        -:  474:  using yes = char[1];
        -:  475:  using no = char[2];
        -:  476:
        -:  477:  template <typename Inner>
        -:  478:  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);
        -:  479:
        -:  480:  template <typename>
        -:  481:  static no& test(...);
        -:  482:
        -:  483:public:
        -:  484:  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);
        -:  485:};
        -:  486:
        -:  487:/// Metafunction to determine if T& or T has a member called rbegin().
        -:  488:template <typename Ty>
        -:  489:struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};
        -:  490:
        -:  491:// Returns an iterator_range over the given container which iterates in reverse.
        -:  492:template <typename ContainerTy> auto reverse(ContainerTy &&C) {
        -:  493:  if constexpr (has_rbegin<ContainerTy>::value)
        -:  494:    return make_range(C.rbegin(), C.rend());
        -:  495:  else
        -:  496:    return make_range(std::make_reverse_iterator(std::end(C)),
        -:  497:                      std::make_reverse_iterator(std::begin(C)));
        -:  498:}
        -:  499:
        -:  500:/// An iterator adaptor that filters the elements of given inner iterators.
        -:  501:///
        -:  502:/// The predicate parameter should be a callable object that accepts the wrapped
        -:  503:/// iterator's reference type and returns a bool. When incrementing or
        -:  504:/// decrementing the iterator, it will call the predicate on each element and
        -:  505:/// skip any where it returns false.
        -:  506:///
        -:  507:/// \code
        -:  508:///   int A[] = { 1, 2, 3, 4 };
        -:  509:///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });
        -:  510:///   // R contains { 1, 3 }.
        -:  511:/// \endcode
        -:  512:///
        -:  513:/// Note: filter_iterator_base implements support for forward iteration.
        -:  514:/// filter_iterator_impl exists to provide support for bidirectional iteration,
        -:  515:/// conditional on whether the wrapped iterator supports it.
        -:  516:template <typename WrappedIteratorT, typename PredicateT, typename IterTag>
        -:  517:class filter_iterator_base
        -:  518:    : public iterator_adaptor_base<
        -:  519:          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,
        -:  520:          WrappedIteratorT,
        -:  521:          std::common_type_t<IterTag,
        -:  522:                             typename std::iterator_traits<
        -:  523:                                 WrappedIteratorT>::iterator_category>> {
        -:  524:  using BaseT = typename filter_iterator_base::iterator_adaptor_base;
        -:  525:
        -:  526:protected:
        -:  527:  WrappedIteratorT End;
        -:  528:  PredicateT Pred;
        -:  529:
        -:  530:  void findNextValid() {
        -:  531:    while (this->I != End && !Pred(*this->I))
        -:  532:      BaseT::operator++();
        -:  533:  }
        -:  534:
        -:  535:  // Construct the iterator. The begin iterator needs to know where the end
        -:  536:  // is, so that it can properly stop when it gets there. The end iterator only
        -:  537:  // needs the predicate to support bidirectional iteration.
        -:  538:  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  539:                       PredicateT Pred)
        -:  540:      : BaseT(Begin), End(End), Pred(Pred) {
        -:  541:    findNextValid();
        -:  542:  }
        -:  543:
        -:  544:public:
        -:  545:  using BaseT::operator++;
        -:  546:
        -:  547:  filter_iterator_base &operator++() {
        -:  548:    BaseT::operator++();
        -:  549:    findNextValid();
        -:  550:    return *this;
        -:  551:  }
        -:  552:
        -:  553:  decltype(auto) operator*() const {
        -:  554:    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");
        -:  555:    return BaseT::operator*();
        -:  556:  }
        -:  557:
        -:  558:  decltype(auto) operator->() const {
        -:  559:    assert(BaseT::wrapped() != End && "Cannot dereference end iterator!");
        -:  560:    return BaseT::operator->();
        -:  561:  }
        -:  562:};
        -:  563:
        -:  564:/// Specialization of filter_iterator_base for forward iteration only.
        -:  565:template <typename WrappedIteratorT, typename PredicateT,
        -:  566:          typename IterTag = std::forward_iterator_tag>
        -:  567:class filter_iterator_impl
        -:  568:    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {
        -:  569:public:
        -:  570:  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  571:                       PredicateT Pred)
        -:  572:      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}
        -:  573:};
        -:  574:
        -:  575:/// Specialization of filter_iterator_base for bidirectional iteration.
        -:  576:template <typename WrappedIteratorT, typename PredicateT>
        -:  577:class filter_iterator_impl<WrappedIteratorT, PredicateT,
        -:  578:                           std::bidirectional_iterator_tag>
        -:  579:    : public filter_iterator_base<WrappedIteratorT, PredicateT,
        -:  580:                                  std::bidirectional_iterator_tag> {
        -:  581:  using BaseT = typename filter_iterator_impl::filter_iterator_base;
        -:  582:
        -:  583:  void findPrevValid() {
        -:  584:    while (!this->Pred(*this->I))
        -:  585:      BaseT::operator--();
        -:  586:  }
        -:  587:
        -:  588:public:
        -:  589:  using BaseT::operator--;
        -:  590:
        -:  591:  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
        -:  592:                       PredicateT Pred)
        -:  593:      : BaseT(Begin, End, Pred) {}
        -:  594:
        -:  595:  filter_iterator_impl &operator--() {
        -:  596:    BaseT::operator--();
        -:  597:    findPrevValid();
        -:  598:    return *this;
        -:  599:  }
        -:  600:};
        -:  601:
        -:  602:namespace detail {
        -:  603:
        -:  604:template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {
        -:  605:  using type = std::forward_iterator_tag;
        -:  606:};
        -:  607:
        -:  608:template <> struct fwd_or_bidi_tag_impl<true> {
        -:  609:  using type = std::bidirectional_iterator_tag;
        -:  610:};
        -:  611:
        -:  612:/// Helper which sets its type member to forward_iterator_tag if the category
        -:  613:/// of \p IterT does not derive from bidirectional_iterator_tag, and to
        -:  614:/// bidirectional_iterator_tag otherwise.
        -:  615:template <typename IterT> struct fwd_or_bidi_tag {
        -:  616:  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<
        -:  617:      std::bidirectional_iterator_tag,
        -:  618:      typename std::iterator_traits<IterT>::iterator_category>::value>::type;
        -:  619:};
        -:  620:
        -:  621:} // namespace detail
        -:  622:
        -:  623:/// Defines filter_iterator to a suitable specialization of
        -:  624:/// filter_iterator_impl, based on the underlying iterator's category.
        -:  625:template <typename WrappedIteratorT, typename PredicateT>
        -:  626:using filter_iterator = filter_iterator_impl<
        -:  627:    WrappedIteratorT, PredicateT,
        -:  628:    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;
        -:  629:
        -:  630:/// Convenience function that takes a range of elements and a predicate,
        -:  631:/// and return a new filter_iterator range.
        -:  632:///
        -:  633:/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the
        -:  634:/// lifetime of that temporary is not kept by the returned range object, and the
        -:  635:/// temporary is going to be dropped on the floor after the make_iterator_range
        -:  636:/// full expression that contains this function call.
        -:  637:template <typename RangeT, typename PredicateT>
        -:  638:iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>
        -:  639:make_filter_range(RangeT &&Range, PredicateT Pred) {
        -:  640:  using FilterIteratorT =
        -:  641:      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;
        -:  642:  return make_range(
        -:  643:      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),
        -:  644:                      std::end(std::forward<RangeT>(Range)), Pred),
        -:  645:      FilterIteratorT(std::end(std::forward<RangeT>(Range)),
        -:  646:                      std::end(std::forward<RangeT>(Range)), Pred));
        -:  647:}
        -:  648:
        -:  649:/// A pseudo-iterator adaptor that is designed to implement "early increment"
        -:  650:/// style loops.
        -:  651:///
        -:  652:/// This is *not a normal iterator* and should almost never be used directly. It
        -:  653:/// is intended primarily to be used with range based for loops and some range
        -:  654:/// algorithms.
        -:  655:///
        -:  656:/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but
        -:  657:/// somewhere between them. The constraints of these iterators are:
        -:  658:///
        -:  659:/// - On construction or after being incremented, it is comparable and
        -:  660:///   dereferencable. It is *not* incrementable.
        -:  661:/// - After being dereferenced, it is neither comparable nor dereferencable, it
        -:  662:///   is only incrementable.
        -:  663:///
        -:  664:/// This means you can only dereference the iterator once, and you can only
        -:  665:/// increment it once between dereferences.
        -:  666:template <typename WrappedIteratorT>
        -:  667:class early_inc_iterator_impl
        -:  668:    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,
        -:  669:                                   WrappedIteratorT, std::input_iterator_tag> {
        -:  670:  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;
        -:  671:
        -:  672:  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;
        -:  673:
        -:  674:protected:
        -:  675:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  676:  bool IsEarlyIncremented = false;
        -:  677:#endif
        -:  678:
        -:  679:public:
        -:  680:  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}
        -:  681:
        -:  682:  using BaseT::operator*;
        -:  683:  decltype(*std::declval<WrappedIteratorT>()) operator*() {
        -:  684:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  685:    assert(!IsEarlyIncremented && "Cannot dereference twice!");
        -:  686:    IsEarlyIncremented = true;
        -:  687:#endif
        -:  688:    return *(this->I)++;
        -:  689:  }
        -:  690:
        -:  691:  using BaseT::operator++;
        -:  692:  early_inc_iterator_impl &operator++() {
        -:  693:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  694:    assert(IsEarlyIncremented && "Cannot increment before dereferencing!");
        -:  695:    IsEarlyIncremented = false;
        -:  696:#endif
        -:  697:    return *this;
        -:  698:  }
        -:  699:
        -:  700:  friend bool operator==(const early_inc_iterator_impl &LHS,
        -:  701:                         const early_inc_iterator_impl &RHS) {
        -:  702:#if LLVM_ENABLE_ABI_BREAKING_CHECKS
        -:  703:    assert(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!");
        -:  704:#endif
        -:  705:    return (const BaseT &)LHS == (const BaseT &)RHS;
        -:  706:  }
        -:  707:};
        -:  708:
        -:  709:/// Make a range that does early increment to allow mutation of the underlying
        -:  710:/// range without disrupting iteration.
        -:  711:///
        -:  712:/// The underlying iterator will be incremented immediately after it is
        -:  713:/// dereferenced, allowing deletion of the current node or insertion of nodes to
        -:  714:/// not disrupt iteration provided they do not invalidate the *next* iterator --
        -:  715:/// the current iterator can be invalidated.
        -:  716:///
        -:  717:/// This requires a very exact pattern of use that is only really suitable to
        -:  718:/// range based for loops and other range algorithms that explicitly guarantee
        -:  719:/// to dereference exactly once each element, and to increment exactly once each
        -:  720:/// element.
        -:  721:template <typename RangeT>
        -:  722:iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>
        -:  723:make_early_inc_range(RangeT &&Range) {
        -:  724:  using EarlyIncIteratorT =
        -:  725:      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;
        -:  726:  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),
        -:  727:                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));
        -:  728:}
        -:  729:
        -:  730:// forward declarations required by zip_shortest/zip_first/zip_longest
        -:  731:template <typename R, typename UnaryPredicate>
        -:  732:bool all_of(R &&range, UnaryPredicate P);
        -:  733:template <typename R, typename UnaryPredicate>
        -:  734:bool any_of(R &&range, UnaryPredicate P);
        -:  735:
        -:  736:namespace detail {
        -:  737:
        -:  738:using std::declval;
        -:  739:
        -:  740:// We have to alias this since inlining the actual type at the usage site
        -:  741:// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.
        -:  742:template<typename... Iters> struct ZipTupleType {
        -:  743:  using type = std::tuple<decltype(*declval<Iters>())...>;
        -:  744:};
        -:  745:
        -:  746:template <typename ZipType, typename... Iters>
        -:  747:using zip_traits = iterator_facade_base<
        -:  748:    ZipType,
        -:  749:    std::common_type_t<
        -:  750:        std::bidirectional_iterator_tag,
        -:  751:        typename std::iterator_traits<Iters>::iterator_category...>,
        -:  752:    // ^ TODO: Implement random access methods.
        -:  753:    typename ZipTupleType<Iters...>::type,
        -:  754:    typename std::iterator_traits<
        -:  755:        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,
        -:  756:    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all
        -:  757:    // inner iterators have the same difference_type. It would fail if, for
        -:  758:    // instance, the second field's difference_type were non-numeric while the
        -:  759:    // first is.
        -:  760:    typename ZipTupleType<Iters...>::type *,
        -:  761:    typename ZipTupleType<Iters...>::type>;
        -:  762:
        -:  763:template <typename ZipType, typename... Iters>
        -:  764:struct zip_common : public zip_traits<ZipType, Iters...> {
        -:  765:  using Base = zip_traits<ZipType, Iters...>;
        -:  766:  using value_type = typename Base::value_type;
        -:  767:
        -:  768:  std::tuple<Iters...> iterators;
        -:  769:
        -:  770:protected:
        -:  771:  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
        -:  772:    return value_type(*std::get<Ns>(iterators)...);
        -:  773:  }
        -:  774:
        -:  775:  template <size_t... Ns>
    #####:  776:  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
    #####:  777:    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);
        -:  778:  }
        -:  779:
        -:  780:  template <size_t... Ns>
        -:  781:  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {
        -:  782:    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);
        -:  783:  }
        -:  784:
        -:  785:  template <size_t... Ns>
        -:  786:  bool test_all_equals(const zip_common &other,
        -:  787:            std::index_sequence<Ns...>) const {
        -:  788:    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) ==
        -:  789:                                              std::get<Ns>(other.iterators)...},
        -:  790:                  identity<bool>{});
        -:  791:  }
        -:  792:
        -:  793:public:
    #####:  794:  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}
call    0 never executed
        -:  795:
    #####:  796:  value_type operator*() const {
    #####:  797:    return deref(std::index_sequence_for<Iters...>{});
call    0 never executed
        -:  798:  }
        -:  799:
    #####:  800:  ZipType &operator++() {
    #####:  801:    iterators = tup_inc(std::index_sequence_for<Iters...>{});
    #####:  802:    return *reinterpret_cast<ZipType *>(this);
        -:  803:  }
        -:  804:
        -:  805:  ZipType &operator--() {
        -:  806:    static_assert(Base::IsBidirectional,
        -:  807:                  "All inner iterators must be at least bidirectional.");
        -:  808:    iterators = tup_dec(std::index_sequence_for<Iters...>{});
        -:  809:    return *reinterpret_cast<ZipType *>(this);
        -:  810:  }
        -:  811:
        -:  812:  /// Return true if all the iterator are matching `other`'s iterators.
        -:  813:  bool all_equals(zip_common &other) {
        -:  814:    return test_all_equals(other, std::index_sequence_for<Iters...>{});
        -:  815:  }
        -:  816:};
        -:  817:
        -:  818:template <typename... Iters>
        -:  819:struct zip_first : public zip_common<zip_first<Iters...>, Iters...> {
        -:  820:  using Base = zip_common<zip_first<Iters...>, Iters...>;
        -:  821:
        -:  822:  bool operator==(const zip_first<Iters...> &other) const {
        -:  823:    return std::get<0>(this->iterators) == std::get<0>(other.iterators);
        -:  824:  }
        -:  825:
        -:  826:  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}
        -:  827:};
        -:  828:
        -:  829:template <typename... Iters>
        -:  830:class zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {
        -:  831:  template <size_t... Ns>
function _ZNK4llvm6detail12zip_shortestIJN4mlir17DenseElementsAttr18IntElementIteratorENS0_27indexed_accessor_range_baseINS2_14SuccessorRangeEPNS2_12BlockOperandEPNS2_5BlockESA_SA_E8iteratorEEE4testIJLm0ELm1EEEEbRKSD_St16integer_sequenceImJXspT_EEE called 0 returned 0% blocks executed 0%
    #####:  832:  bool test(const zip_shortest<Iters...> &other,
        -:  833:            std::index_sequence<Ns...>) const {
    #####:  834:    return all_of(llvm::ArrayRef<bool>({std::get<Ns>(this->iterators) !=
branch  0 never executed
branch  1 never executed
    #####:  835:                                        std::get<Ns>(other.iterators)...}),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  836:                  identity<bool>{});
        -:  837:  }
        -:  838:
        -:  839:public:
        -:  840:  using Base = zip_common<zip_shortest<Iters...>, Iters...>;
        -:  841:
    #####:  842:  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}
        -:  843:
    #####:  844:  bool operator==(const zip_shortest<Iters...> &other) const {
    #####:  845:    return !test(other, std::index_sequence_for<Iters...>{});
branch  0 never executed
branch  1 never executed
        -:  846:  }
        -:  847:};
        -:  848:
        -:  849:template <template <typename...> class ItType, typename... Args> class zippy {
        -:  850:public:
        -:  851:  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;
        -:  852:  using iterator_category = typename iterator::iterator_category;
        -:  853:  using value_type = typename iterator::value_type;
        -:  854:  using difference_type = typename iterator::difference_type;
        -:  855:  using pointer = typename iterator::pointer;
        -:  856:  using reference = typename iterator::reference;
        -:  857:
        -:  858:private:
        -:  859:  std::tuple<Args...> ts;
        -:  860:
        -:  861:  template <size_t... Ns>
    #####:  862:  iterator begin_impl(std::index_sequence<Ns...>) const {
    #####:  863:    return iterator(std::begin(std::get<Ns>(ts))...);
call    0 never executed
        -:  864:  }
        -:  865:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -:  866:    return iterator(std::end(std::get<Ns>(ts))...);
        -:  867:  }
        -:  868:
        -:  869:public:
    #####:  870:  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}
        -:  871:
    #####:  872:  iterator begin() const {
    #####:  873:    return begin_impl(std::index_sequence_for<Args...>{});
call    0 never executed
call    1 never executed
        -:  874:  }
    #####:  875:  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
call    0 never executed
        -:  876:};
        -:  877:
        -:  878:} // end namespace detail
        -:  879:
        -:  880:/// zip iterator for two or more iteratable types.
        -:  881:template <typename T, typename U, typename... Args>
    #####:  882:detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,
call    0 never executed
        -:  883:                                                       Args &&... args) {
        -:  884:  return detail::zippy<detail::zip_shortest, T, U, Args...>(
    #####:  885:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
call    0 never executed
        -:  886:}
        -:  887:
        -:  888:/// zip iterator that, for the sake of efficiency, assumes the first iteratee to
        -:  889:/// be the shortest.
        -:  890:template <typename T, typename U, typename... Args>
        -:  891:detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,
        -:  892:                                                          Args &&... args) {
        -:  893:  return detail::zippy<detail::zip_first, T, U, Args...>(
        -:  894:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
        -:  895:}
        -:  896:
        -:  897:namespace detail {
        -:  898:template <typename Iter>
        -:  899:Iter next_or_end(const Iter &I, const Iter &End) {
        -:  900:  if (I == End)
        -:  901:    return End;
        -:  902:  return std::next(I);
        -:  903:}
        -:  904:
        -:  905:template <typename Iter>
        -:  906:auto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<
        -:  907:    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {
        -:  908:  if (I == End)
        -:  909:    return None;
        -:  910:  return *I;
        -:  911:}
        -:  912:
        -:  913:template <typename Iter> struct ZipLongestItemType {
        -:  914:  using type = llvm::Optional<std::remove_const_t<
        -:  915:      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;
        -:  916:};
        -:  917:
        -:  918:template <typename... Iters> struct ZipLongestTupleType {
        -:  919:  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;
        -:  920:};
        -:  921:
        -:  922:template <typename... Iters>
        -:  923:class zip_longest_iterator
        -:  924:    : public iterator_facade_base<
        -:  925:          zip_longest_iterator<Iters...>,
        -:  926:          std::common_type_t<
        -:  927:              std::forward_iterator_tag,
        -:  928:              typename std::iterator_traits<Iters>::iterator_category...>,
        -:  929:          typename ZipLongestTupleType<Iters...>::type,
        -:  930:          typename std::iterator_traits<
        -:  931:              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,
        -:  932:          typename ZipLongestTupleType<Iters...>::type *,
        -:  933:          typename ZipLongestTupleType<Iters...>::type> {
        -:  934:public:
        -:  935:  using value_type = typename ZipLongestTupleType<Iters...>::type;
        -:  936:
        -:  937:private:
        -:  938:  std::tuple<Iters...> iterators;
        -:  939:  std::tuple<Iters...> end_iterators;
        -:  940:
        -:  941:  template <size_t... Ns>
        -:  942:  bool test(const zip_longest_iterator<Iters...> &other,
        -:  943:            std::index_sequence<Ns...>) const {
        -:  944:    return llvm::any_of(
        -:  945:        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=
        -:  946:                                    std::get<Ns>(other.iterators)...},
        -:  947:        identity<bool>{});
        -:  948:  }
        -:  949:
        -:  950:  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
        -:  951:    return value_type(
        -:  952:        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
        -:  953:  }
        -:  954:
        -:  955:  template <size_t... Ns>
        -:  956:  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
        -:  957:    return std::tuple<Iters...>(
        -:  958:        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
        -:  959:  }
        -:  960:
        -:  961:public:
        -:  962:  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)
        -:  963:      : iterators(std::forward<Iters>(ts.first)...),
        -:  964:        end_iterators(std::forward<Iters>(ts.second)...) {}
        -:  965:
        -:  966:  value_type operator*() const {
        -:  967:    return deref(std::index_sequence_for<Iters...>{});
        -:  968:  }
        -:  969:
        -:  970:  zip_longest_iterator<Iters...> &operator++() {
        -:  971:    iterators = tup_inc(std::index_sequence_for<Iters...>{});
        -:  972:    return *this;
        -:  973:  }
        -:  974:
        -:  975:  bool operator==(const zip_longest_iterator<Iters...> &other) const {
        -:  976:    return !test(other, std::index_sequence_for<Iters...>{});
        -:  977:  }
        -:  978:};
        -:  979:
        -:  980:template <typename... Args> class zip_longest_range {
        -:  981:public:
        -:  982:  using iterator =
        -:  983:      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;
        -:  984:  using iterator_category = typename iterator::iterator_category;
        -:  985:  using value_type = typename iterator::value_type;
        -:  986:  using difference_type = typename iterator::difference_type;
        -:  987:  using pointer = typename iterator::pointer;
        -:  988:  using reference = typename iterator::reference;
        -:  989:
        -:  990:private:
        -:  991:  std::tuple<Args...> ts;
        -:  992:
        -:  993:  template <size_t... Ns>
        -:  994:  iterator begin_impl(std::index_sequence<Ns...>) const {
        -:  995:    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),
        -:  996:                                   adl_end(std::get<Ns>(ts)))...);
        -:  997:  }
        -:  998:
        -:  999:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -: 1000:    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),
        -: 1001:                                   adl_end(std::get<Ns>(ts)))...);
        -: 1002:  }
        -: 1003:
        -: 1004:public:
        -: 1005:  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}
        -: 1006:
        -: 1007:  iterator begin() const {
        -: 1008:    return begin_impl(std::index_sequence_for<Args...>{});
        -: 1009:  }
        -: 1010:  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
        -: 1011:};
        -: 1012:} // namespace detail
        -: 1013:
        -: 1014:/// Iterate over two or more iterators at the same time. Iteration continues
        -: 1015:/// until all iterators reach the end. The llvm::Optional only contains a value
        -: 1016:/// if the iterator has not reached the end.
        -: 1017:template <typename T, typename U, typename... Args>
        -: 1018:detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,
        -: 1019:                                                     Args &&... args) {
        -: 1020:  return detail::zip_longest_range<T, U, Args...>(
        -: 1021:      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
        -: 1022:}
        -: 1023:
        -: 1024:/// Iterator wrapper that concatenates sequences together.
        -: 1025:///
        -: 1026:/// This can concatenate different iterators, even with different types, into
        -: 1027:/// a single iterator provided the value types of all the concatenated
        -: 1028:/// iterators expose `reference` and `pointer` types that can be converted to
        -: 1029:/// `ValueT &` and `ValueT *` respectively. It doesn't support more
        -: 1030:/// interesting/customized pointer or reference types.
        -: 1031:///
        -: 1032:/// Currently this only supports forward or higher iterator categories as
        -: 1033:/// inputs and always exposes a forward iterator interface.
        -: 1034:template <typename ValueT, typename... IterTs>
        -: 1035:class concat_iterator
        -: 1036:    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,
        -: 1037:                                  std::forward_iterator_tag, ValueT> {
        -: 1038:  using BaseT = typename concat_iterator::iterator_facade_base;
        -: 1039:
        -: 1040:  /// We store both the current and end iterators for each concatenated
        -: 1041:  /// sequence in a tuple of pairs.
        -: 1042:  ///
        -: 1043:  /// Note that something like iterator_range seems nice at first here, but the
        -: 1044:  /// range properties are of little benefit and end up getting in the way
        -: 1045:  /// because we need to do mutation on the current iterators.
        -: 1046:  std::tuple<IterTs...> Begins;
        -: 1047:  std::tuple<IterTs...> Ends;
        -: 1048:
        -: 1049:  /// Attempts to increment a specific iterator.
        -: 1050:  ///
        -: 1051:  /// Returns true if it was able to increment the iterator. Returns false if
        -: 1052:  /// the iterator is already at the end iterator.
        -: 1053:  template <size_t Index> bool incrementHelper() {
        -: 1054:    auto &Begin = std::get<Index>(Begins);
        -: 1055:    auto &End = std::get<Index>(Ends);
        -: 1056:    if (Begin == End)
        -: 1057:      return false;
        -: 1058:
        -: 1059:    ++Begin;
        -: 1060:    return true;
        -: 1061:  }
        -: 1062:
        -: 1063:  /// Increments the first non-end iterator.
        -: 1064:  ///
        -: 1065:  /// It is an error to call this with all iterators at the end.
        -: 1066:  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {
        -: 1067:    // Build a sequence of functions to increment each iterator if possible.
        -: 1068:    bool (concat_iterator::*IncrementHelperFns[])() = {
        -: 1069:        &concat_iterator::incrementHelper<Ns>...};
        -: 1070:
        -: 1071:    // Loop over them, and stop as soon as we succeed at incrementing one.
        -: 1072:    for (auto &IncrementHelperFn : IncrementHelperFns)
        -: 1073:      if ((this->*IncrementHelperFn)())
        -: 1074:        return;
        -: 1075:
        -: 1076:    llvm_unreachable("Attempted to increment an end concat iterator!");
        -: 1077:  }
        -: 1078:
        -: 1079:  /// Returns null if the specified iterator is at the end. Otherwise,
        -: 1080:  /// dereferences the iterator and returns the address of the resulting
        -: 1081:  /// reference.
        -: 1082:  template <size_t Index> ValueT *getHelper() const {
        -: 1083:    auto &Begin = std::get<Index>(Begins);
        -: 1084:    auto &End = std::get<Index>(Ends);
        -: 1085:    if (Begin == End)
        -: 1086:      return nullptr;
        -: 1087:
        -: 1088:    return &*Begin;
        -: 1089:  }
        -: 1090:
        -: 1091:  /// Finds the first non-end iterator, dereferences, and returns the resulting
        -: 1092:  /// reference.
        -: 1093:  ///
        -: 1094:  /// It is an error to call this with all iterators at the end.
        -: 1095:  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {
        -: 1096:    // Build a sequence of functions to get from iterator if possible.
        -: 1097:    ValueT *(concat_iterator::*GetHelperFns[])() const = {
        -: 1098:        &concat_iterator::getHelper<Ns>...};
        -: 1099:
        -: 1100:    // Loop over them, and return the first result we find.
        -: 1101:    for (auto &GetHelperFn : GetHelperFns)
        -: 1102:      if (ValueT *P = (this->*GetHelperFn)())
        -: 1103:        return *P;
        -: 1104:
        -: 1105:    llvm_unreachable("Attempted to get a pointer from an end concat iterator!");
        -: 1106:  }
        -: 1107:
        -: 1108:public:
        -: 1109:  /// Constructs an iterator from a sequence of ranges.
        -: 1110:  ///
        -: 1111:  /// We need the full range to know how to switch between each of the
        -: 1112:  /// iterators.
        -: 1113:  template <typename... RangeTs>
        -: 1114:  explicit concat_iterator(RangeTs &&... Ranges)
        -: 1115:      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}
        -: 1116:
        -: 1117:  using BaseT::operator++;
        -: 1118:
        -: 1119:  concat_iterator &operator++() {
        -: 1120:    increment(std::index_sequence_for<IterTs...>());
        -: 1121:    return *this;
        -: 1122:  }
        -: 1123:
        -: 1124:  ValueT &operator*() const {
        -: 1125:    return get(std::index_sequence_for<IterTs...>());
        -: 1126:  }
        -: 1127:
        -: 1128:  bool operator==(const concat_iterator &RHS) const {
        -: 1129:    return Begins == RHS.Begins && Ends == RHS.Ends;
        -: 1130:  }
        -: 1131:};
        -: 1132:
        -: 1133:namespace detail {
        -: 1134:
        -: 1135:/// Helper to store a sequence of ranges being concatenated and access them.
        -: 1136:///
        -: 1137:/// This is designed to facilitate providing actual storage when temporaries
        -: 1138:/// are passed into the constructor such that we can use it as part of range
        -: 1139:/// based for loops.
        -: 1140:template <typename ValueT, typename... RangeTs> class concat_range {
        -: 1141:public:
        -: 1142:  using iterator =
        -: 1143:      concat_iterator<ValueT,
        -: 1144:                      decltype(std::begin(std::declval<RangeTs &>()))...>;
        -: 1145:
        -: 1146:private:
        -: 1147:  std::tuple<RangeTs...> Ranges;
        -: 1148:
        -: 1149:  template <size_t... Ns>
        -: 1150:  iterator begin_impl(std::index_sequence<Ns...>) {
        -: 1151:    return iterator(std::get<Ns>(Ranges)...);
        -: 1152:  }
        -: 1153:  template <size_t... Ns>
        -: 1154:  iterator begin_impl(std::index_sequence<Ns...>) const {
        -: 1155:    return iterator(std::get<Ns>(Ranges)...);
        -: 1156:  }
        -: 1157:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
        -: 1158:    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
        -: 1159:                               std::end(std::get<Ns>(Ranges)))...);
        -: 1160:  }
        -: 1161:  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
        -: 1162:    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
        -: 1163:                               std::end(std::get<Ns>(Ranges)))...);
        -: 1164:  }
        -: 1165:
        -: 1166:public:
        -: 1167:  concat_range(RangeTs &&... Ranges)
        -: 1168:      : Ranges(std::forward<RangeTs>(Ranges)...) {}
        -: 1169:
        -: 1170:  iterator begin() {
        -: 1171:    return begin_impl(std::index_sequence_for<RangeTs...>{});
        -: 1172:  }
        -: 1173:  iterator begin() const {
        -: 1174:    return begin_impl(std::index_sequence_for<RangeTs...>{});
        -: 1175:  }
        -: 1176:  iterator end() {
        -: 1177:    return end_impl(std::index_sequence_for<RangeTs...>{});
        -: 1178:  }
        -: 1179:  iterator end() const {
        -: 1180:    return end_impl(std::index_sequence_for<RangeTs...>{});
        -: 1181:  }
        -: 1182:};
        -: 1183:
        -: 1184:} // end namespace detail
        -: 1185:
        -: 1186:/// Concatenated range across two or more ranges.
        -: 1187:///
        -: 1188:/// The desired value type must be explicitly specified.
        -: 1189:template <typename ValueT, typename... RangeTs>
        -: 1190:detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {
        -: 1191:  static_assert(sizeof...(RangeTs) > 1,
        -: 1192:                "Need more than one range to concatenate!");
        -: 1193:  return detail::concat_range<ValueT, RangeTs...>(
        -: 1194:      std::forward<RangeTs>(Ranges)...);
        -: 1195:}
        -: 1196:
        -: 1197:/// A utility class used to implement an iterator that contains some base object
        -: 1198:/// and an index. The iterator moves the index but keeps the base constant.
        -: 1199:template <typename DerivedT, typename BaseT, typename T,
        -: 1200:          typename PointerT = T *, typename ReferenceT = T &>
    #####: 1201:class indexed_accessor_iterator
        -: 1202:    : public llvm::iterator_facade_base<DerivedT,
        -: 1203:                                        std::random_access_iterator_tag, T,
        -: 1204:                                        std::ptrdiff_t, PointerT, ReferenceT> {
        -: 1205:public:
    #####: 1206:  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {
    #####: 1207:    assert(base == rhs.base && "incompatible iterators");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
    #####: 1208:    return index - rhs.index;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1209:  }
    #####: 1210:  bool operator==(const indexed_accessor_iterator &rhs) const {
    #####: 1211:    return base == rhs.base && index == rhs.index;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -: 1212:  }
        -: 1213:  bool operator<(const indexed_accessor_iterator &rhs) const {
        -: 1214:    assert(base == rhs.base && "incompatible iterators");
        -: 1215:    return index < rhs.index;
        -: 1216:  }
        -: 1217:
    #####: 1218:  DerivedT &operator+=(ptrdiff_t offset) {
    #####: 1219:    this->index += offset;
call    0 never executed
        -: 1220:    return static_cast<DerivedT &>(*this);
        -: 1221:  }
        -: 1222:  DerivedT &operator-=(ptrdiff_t offset) {
        -: 1223:    this->index -= offset;
        -: 1224:    return static_cast<DerivedT &>(*this);
        -: 1225:  }
        -: 1226:
        -: 1227:  /// Returns the current index of the iterator.
    #####: 1228:  ptrdiff_t getIndex() const { return index; }
        -: 1229:
        -: 1230:  /// Returns the current base of the iterator.
    #####: 1231:  const BaseT &getBase() const { return base; }
        -: 1232:
        -: 1233:protected:
    #####: 1234:  indexed_accessor_iterator(BaseT base, ptrdiff_t index)
        -: 1235:      : base(base), index(index) {}
        -: 1236:  BaseT base;
        -: 1237:  ptrdiff_t index;
        -: 1238:};
        -: 1239:
        -: 1240:namespace detail {
        -: 1241:/// The class represents the base of a range of indexed_accessor_iterators. It
        -: 1242:/// provides support for many different range functionalities, e.g.
        -: 1243:/// drop_front/slice/etc.. Derived range classes must implement the following
        -: 1244:/// static methods:
        -: 1245:///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)
        -: 1246:///     - Dereference an iterator pointing to the base object at the given
        -: 1247:///       index.
        -: 1248:///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)
        -: 1249:///     - Return a new base that is offset from the provide base by 'index'
        -: 1250:///       elements.
        -: 1251:template <typename DerivedT, typename BaseT, typename T,
        -: 1252:          typename PointerT = T *, typename ReferenceT = T &>
        -: 1253:class indexed_accessor_range_base {
        -: 1254:public:
        -: 1255:  using RangeBaseT = indexed_accessor_range_base;
        -: 1256:
        -: 1257:  /// An iterator element of this range.
        -: 1258:  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,
        -: 1259:                                                    PointerT, ReferenceT> {
        -: 1260:  public:
        -: 1261:    // Index into this iterator, invoking a static method on the derived type.
    #####: 1262:    ReferenceT operator*() const {
    #####: 1263:      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());
call    0 never executed
        -: 1264:    }
        -: 1265:
        -: 1266:  private:
    #####: 1267:    iterator(BaseT owner, ptrdiff_t curIndex)
    #####: 1268:        : iterator::indexed_accessor_iterator(owner, curIndex) {}
        -: 1269:
        -: 1270:    /// Allow access to the constructor.
        -: 1271:    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
        -: 1272:                                       ReferenceT>;
        -: 1273:  };
        -: 1274:
        -: 1275:  indexed_accessor_range_base(iterator begin, iterator end)
        -: 1276:      : base(offset_base(begin.getBase(), begin.getIndex())),
        -: 1277:        count(end.getIndex() - begin.getIndex()) {}
        -: 1278:  indexed_accessor_range_base(const iterator_range<iterator> &range)
        -: 1279:      : indexed_accessor_range_base(range.begin(), range.end()) {}
    #####: 1280:  indexed_accessor_range_base(BaseT base, ptrdiff_t count)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
call   134 never executed
        -: 1281:      : base(base), count(count) {}
        -: 1282:
    #####: 1283:  iterator begin() const { return iterator(base, 0); }
call    0 never executed
        -: 1284:  iterator end() const { return iterator(base, count); }
    #####: 1285:  ReferenceT operator[](size_t Index) const {
    #####: 1286:    assert(Index < size() && "invalid index for value range");
    #####: 1287:    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));
        -: 1288:  }
    #####: 1289:  ReferenceT front() const {
    #####: 1290:    assert(!empty() && "expected non-empty range");
call    0 never executed
call    1 never executed
    #####: 1291:    return (*this)[0];
call    0 never executed
call    1 never executed
        -: 1292:  }
        -: 1293:  ReferenceT back() const {
        -: 1294:    assert(!empty() && "expected non-empty range");
        -: 1295:    return (*this)[size() - 1];
        -: 1296:  }
        -: 1297:
        -: 1298:  /// Compare this range with another.
        -: 1299:  template <typename OtherT>
        -: 1300:  friend bool operator==(const indexed_accessor_range_base &lhs,
        -: 1301:                         const OtherT &rhs) {
        -: 1302:    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
        -: 1303:  }
        -: 1304:  template <typename OtherT>
        -: 1305:  friend bool operator!=(const indexed_accessor_range_base &lhs,
        -: 1306:                         const OtherT &rhs) {
        -: 1307:    return !(lhs == rhs);
        -: 1308:  }
        -: 1309:
        -: 1310:  /// Return the size of this range.
    #####: 1311:  size_t size() const { return count; }
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1312:
        -: 1313:  /// Return if the range is empty.
    #####: 1314:  bool empty() const { return size() == 0; }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1315:
        -: 1316:  /// Drop the first N elements, and keep M elements.
        -: 1317:  DerivedT slice(size_t n, size_t m) const {
        -: 1318:    assert(n + m <= size() && "invalid size specifiers");
        -: 1319:    return DerivedT(offset_base(base, n), m);
        -: 1320:  }
        -: 1321:
        -: 1322:  /// Drop the first n elements.
        -: 1323:  DerivedT drop_front(size_t n = 1) const {
        -: 1324:    assert(size() >= n && "Dropping more elements than exist");
        -: 1325:    return slice(n, size() - n);
        -: 1326:  }
        -: 1327:  /// Drop the last n elements.
        -: 1328:  DerivedT drop_back(size_t n = 1) const {
        -: 1329:    assert(size() >= n && "Dropping more elements than exist");
        -: 1330:    return DerivedT(base, size() - n);
        -: 1331:  }
        -: 1332:
        -: 1333:  /// Take the first n elements.
        -: 1334:  DerivedT take_front(size_t n = 1) const {
        -: 1335:    return n < size() ? drop_back(size() - n)
        -: 1336:                      : static_cast<const DerivedT &>(*this);
        -: 1337:  }
        -: 1338:
        -: 1339:  /// Take the last n elements.
        -: 1340:  DerivedT take_back(size_t n = 1) const {
        -: 1341:    return n < size() ? drop_front(size() - n)
        -: 1342:                      : static_cast<const DerivedT &>(*this);
        -: 1343:  }
        -: 1344:
        -: 1345:  /// Allow conversion to any type accepting an iterator_range.
        -: 1346:  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<
        -: 1347:                                 RangeT, iterator_range<iterator>>::value>>
        -: 1348:  operator RangeT() const {
        -: 1349:    return RangeT(iterator_range<iterator>(*this));
        -: 1350:  }
        -: 1351:
        -: 1352:  /// Returns the base of this range.
        -: 1353:  const BaseT &getBase() const { return base; }
        -: 1354:
        -: 1355:private:
        -: 1356:  /// Offset the given base by the given amount.
        -: 1357:  static BaseT offset_base(const BaseT &base, size_t n) {
        -: 1358:    return n == 0 ? base : DerivedT::offset_base(base, n);
        -: 1359:  }
        -: 1360:
        -: 1361:protected:
        -: 1362:  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;
        -: 1363:  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;
        -: 1364:  indexed_accessor_range_base &
        -: 1365:  operator=(const indexed_accessor_range_base &) = default;
        -: 1366:
        -: 1367:  /// The base that owns the provided range of values.
        -: 1368:  BaseT base;
        -: 1369:  /// The size from the owning range.
        -: 1370:  ptrdiff_t count;
        -: 1371:};
        -: 1372:} // end namespace detail
        -: 1373:
        -: 1374:/// This class provides an implementation of a range of
        -: 1375:/// indexed_accessor_iterators where the base is not indexable. Ranges with
        -: 1376:/// bases that are offsetable should derive from indexed_accessor_range_base
        -: 1377:/// instead. Derived range classes are expected to implement the following
        -: 1378:/// static method:
        -: 1379:///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)
        -: 1380:///     - Dereference an iterator pointing to a parent base at the given index.
        -: 1381:template <typename DerivedT, typename BaseT, typename T,
        -: 1382:          typename PointerT = T *, typename ReferenceT = T &>
        -: 1383:class indexed_accessor_range
        -: 1384:    : public detail::indexed_accessor_range_base<
        -: 1385:          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {
        -: 1386:public:
        -: 1387:  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)
        -: 1388:      : detail::indexed_accessor_range_base<
        -: 1389:            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(
        -: 1390:            std::make_pair(base, startIndex), count) {}
        -: 1391:  using detail::indexed_accessor_range_base<
        -: 1392:      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,
        -: 1393:      ReferenceT>::indexed_accessor_range_base;
        -: 1394:
        -: 1395:  /// Returns the current base of the range.
        -: 1396:  const BaseT &getBase() const { return this->base.first; }
        -: 1397:
        -: 1398:  /// Returns the current start index of the range.
        -: 1399:  ptrdiff_t getStartIndex() const { return this->base.second; }
        -: 1400:
        -: 1401:  /// See `detail::indexed_accessor_range_base` for details.
        -: 1402:  static std::pair<BaseT, ptrdiff_t>
        -: 1403:  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {
        -: 1404:    // We encode the internal base as a pair of the derived base and a start
        -: 1405:    // index into the derived base.
        -: 1406:    return std::make_pair(base.first, base.second + index);
        -: 1407:  }
        -: 1408:  /// See `detail::indexed_accessor_range_base` for details.
        -: 1409:  static ReferenceT
        -: 1410:  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,
        -: 1411:                       ptrdiff_t index) {
        -: 1412:    return DerivedT::dereference(base.first, base.second + index);
        -: 1413:  }
        -: 1414:};
        -: 1415:
        -: 1416:namespace detail {
        -: 1417:/// Return a reference to the first or second member of a reference. Otherwise,
        -: 1418:/// return a copy of the member of a temporary.
        -: 1419:///
        -: 1420:/// When passing a range whose iterators return values instead of references,
        -: 1421:/// the reference must be dropped from `decltype((elt.first))`, which will
        -: 1422:/// always be a reference, to avoid returning a reference to a temporary.
        -: 1423:template <typename EltTy, typename FirstTy> class first_or_second_type {
        -: 1424:public:
        -: 1425:  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,
        -: 1426:                                  std::remove_reference_t<FirstTy>>;
        -: 1427:};
        -: 1428:} // end namespace detail
        -: 1429:
        -: 1430:/// Given a container of pairs, return a range over the first elements.
        -: 1431:template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {
        -: 1432:  using EltTy = decltype((*std::begin(c)));
        -: 1433:  return llvm::map_range(std::forward<ContainerTy>(c),
        -: 1434:                         [](EltTy elt) -> typename detail::first_or_second_type<
        -: 1435:                                           EltTy, decltype((elt.first))>::type {
        -: 1436:                           return elt.first;
        -: 1437:                         });
        -: 1438:}
        -: 1439:
        -: 1440:/// Given a container of pairs, return a range over the second elements.
        -: 1441:template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {
        -: 1442:  using EltTy = decltype((*std::begin(c)));
        -: 1443:  return llvm::map_range(
        -: 1444:      std::forward<ContainerTy>(c),
        -: 1445:      [](EltTy elt) ->
        -: 1446:      typename detail::first_or_second_type<EltTy,
        -: 1447:                                            decltype((elt.second))>::type {
        -: 1448:        return elt.second;
        -: 1449:      });
        -: 1450:}
        -: 1451:
        -: 1452://===----------------------------------------------------------------------===//
        -: 1453://     Extra additions to <utility>
        -: 1454://===----------------------------------------------------------------------===//
        -: 1455:
        -: 1456:/// Function object to check whether the first component of a std::pair
        -: 1457:/// compares less than the first component of another std::pair.
        -: 1458:struct less_first {
        -: 1459:  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
        -: 1460:    return std::less<>()(lhs.first, rhs.first);
        -: 1461:  }
        -: 1462:};
        -: 1463:
        -: 1464:/// Function object to check whether the second component of a std::pair
        -: 1465:/// compares less than the second component of another std::pair.
        -: 1466:struct less_second {
        -: 1467:  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
        -: 1468:    return std::less<>()(lhs.second, rhs.second);
        -: 1469:  }
        -: 1470:};
        -: 1471:
        -: 1472:/// \brief Function object to apply a binary function to the first component of
        -: 1473:/// a std::pair.
        -: 1474:template<typename FuncTy>
        -: 1475:struct on_first {
        -: 1476:  FuncTy func;
        -: 1477:
        -: 1478:  template <typename T>
        -: 1479:  decltype(auto) operator()(const T &lhs, const T &rhs) const {
        -: 1480:    return func(lhs.first, rhs.first);
        -: 1481:  }
        -: 1482:};
        -: 1483:
        -: 1484:/// Utility type to build an inheritance chain that makes it easy to rank
        -: 1485:/// overload candidates.
        -: 1486:template <int N> struct rank : rank<N - 1> {};
        -: 1487:template <> struct rank<0> {};
        -: 1488:
        -: 1489:/// traits class for checking whether type T is one of any of the given
        -: 1490:/// types in the variadic list.
        -: 1491:template <typename T, typename... Ts>
        -: 1492:using is_one_of = std::disjunction<std::is_same<T, Ts>...>;
        -: 1493:
        -: 1494:/// traits class for checking whether type T is a base class for all
        -: 1495:///  the given types in the variadic list.
        -: 1496:template <typename T, typename... Ts>
        -: 1497:using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;
        -: 1498:
        -: 1499:namespace detail {
        -: 1500:template <typename... Ts> struct Visitor;
        -: 1501:
        -: 1502:template <typename HeadT, typename... TailTs>
        -: 1503:struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {
        -: 1504:  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)
        -: 1505:      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),
        -: 1506:        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}
        -: 1507:  using remove_cvref_t<HeadT>::operator();
        -: 1508:  using Visitor<TailTs...>::operator();
        -: 1509:};
        -: 1510:
        -: 1511:template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {
        -: 1512:  explicit constexpr Visitor(HeadT &&Head)
        -: 1513:      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}
        -: 1514:  using remove_cvref_t<HeadT>::operator();
        -: 1515:};
        -: 1516:} // namespace detail
        -: 1517:
        -: 1518:/// Returns an opaquely-typed Callable object whose operator() overload set is
        -: 1519:/// the sum of the operator() overload sets of each CallableT in CallableTs.
        -: 1520:///
        -: 1521:/// The type of the returned object derives from each CallableT in CallableTs.
        -: 1522:/// The returned object is constructed by invoking the appropriate copy or move
        -: 1523:/// constructor of each CallableT, as selected by overload resolution on the
        -: 1524:/// corresponding argument to makeVisitor.
        -: 1525:///
        -: 1526:/// Example:
        -: 1527:///
        -: 1528:/// \code
        -: 1529:/// auto visitor = makeVisitor([](auto) { return "unhandled type"; },
        -: 1530:///                            [](int i) { return "int"; },
        -: 1531:///                            [](std::string s) { return "str"; });
        -: 1532:/// auto a = visitor(42);    // `a` is now "int".
        -: 1533:/// auto b = visitor("foo"); // `b` is now "str".
        -: 1534:/// auto c = visitor(3.14f); // `c` is now "unhandled type".
        -: 1535:/// \endcode
        -: 1536:///
        -: 1537:/// Example of making a visitor with a lambda which captures a move-only type:
        -: 1538:///
        -: 1539:/// \code
        -: 1540:/// std::unique_ptr<FooHandler> FH = /* ... */;
        -: 1541:/// auto visitor = makeVisitor(
        -: 1542:///     [FH{std::move(FH)}](Foo F) { return FH->handle(F); },
        -: 1543:///     [](int i) { return i; },
        -: 1544:///     [](std::string s) { return atoi(s); });
        -: 1545:/// \endcode
        -: 1546:template <typename... CallableTs>
        -: 1547:constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {
        -: 1548:  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);
        -: 1549:}
        -: 1550:
        -: 1551://===----------------------------------------------------------------------===//
        -: 1552://     Extra additions to <algorithm>
        -: 1553://===----------------------------------------------------------------------===//
        -: 1554:
        -: 1555:// We have a copy here so that LLVM behaves the same when using different
        -: 1556:// standard libraries.
        -: 1557:template <class Iterator, class RNG>
        -: 1558:void shuffle(Iterator first, Iterator last, RNG &&g) {
        -: 1559:  // It would be better to use a std::uniform_int_distribution,
        -: 1560:  // but that would be stdlib dependent.
        -: 1561:  typedef
        -: 1562:      typename std::iterator_traits<Iterator>::difference_type difference_type;
        -: 1563:  for (auto size = last - first; size > 1; ++first, (void)--size) {
        -: 1564:    difference_type offset = g() % size;
        -: 1565:    // Avoid self-assignment due to incorrect assertions in libstdc++
        -: 1566:    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).
        -: 1567:    if (offset != difference_type(0))
        -: 1568:      std::iter_swap(first, first + offset);
        -: 1569:  }
        -: 1570:}
        -: 1571:
        -: 1572:/// Adapt std::less<T> for array_pod_sort.
        -: 1573:template<typename T>
        -: 1574:inline int array_pod_sort_comparator(const void *P1, const void *P2) {
        -: 1575:  if (std::less<T>()(*reinterpret_cast<const T*>(P1),
        -: 1576:                     *reinterpret_cast<const T*>(P2)))
        -: 1577:    return -1;
        -: 1578:  if (std::less<T>()(*reinterpret_cast<const T*>(P2),
        -: 1579:                     *reinterpret_cast<const T*>(P1)))
        -: 1580:    return 1;
        -: 1581:  return 0;
        -: 1582:}
        -: 1583:
        -: 1584:/// get_array_pod_sort_comparator - This is an internal helper function used to
        -: 1585:/// get type deduction of T right.
        -: 1586:template<typename T>
        -: 1587:inline int (*get_array_pod_sort_comparator(const T &))
        -: 1588:             (const void*, const void*) {
        -: 1589:  return array_pod_sort_comparator<T>;
        -: 1590:}
        -: 1591:
        -: 1592:#ifdef EXPENSIVE_CHECKS
        -: 1593:namespace detail {
        -: 1594:
        -: 1595:inline unsigned presortShuffleEntropy() {
        -: 1596:  static unsigned Result(std::random_device{}());
        -: 1597:  return Result;
        -: 1598:}
        -: 1599:
        -: 1600:template <class IteratorTy>
        -: 1601:inline void presortShuffle(IteratorTy Start, IteratorTy End) {
        -: 1602:  std::mt19937 Generator(presortShuffleEntropy());
        -: 1603:  llvm::shuffle(Start, End, Generator);
        -: 1604:}
        -: 1605:
        -: 1606:} // end namespace detail
        -: 1607:#endif
        -: 1608:
        -: 1609:/// array_pod_sort - This sorts an array with the specified start and end
        -: 1610:/// extent.  This is just like std::sort, except that it calls qsort instead of
        -: 1611:/// using an inlined template.  qsort is slightly slower than std::sort, but
        -: 1612:/// most sorts are not performance critical in LLVM and std::sort has to be
        -: 1613:/// template instantiated for each type, leading to significant measured code
        -: 1614:/// bloat.  This function should generally be used instead of std::sort where
        -: 1615:/// possible.
        -: 1616:///
        -: 1617:/// This function assumes that you have simple POD-like types that can be
        -: 1618:/// compared with std::less and can be moved with memcpy.  If this isn't true,
        -: 1619:/// you should use std::sort.
        -: 1620:///
        -: 1621:/// NOTE: If qsort_r were portable, we could allow a custom comparator and
        -: 1622:/// default to std::less.
        -: 1623:template<class IteratorTy>
        -: 1624:inline void array_pod_sort(IteratorTy Start, IteratorTy End) {
        -: 1625:  // Don't inefficiently call qsort with one element or trigger undefined
        -: 1626:  // behavior with an empty sequence.
        -: 1627:  auto NElts = End - Start;
        -: 1628:  if (NElts <= 1) return;
        -: 1629:#ifdef EXPENSIVE_CHECKS
        -: 1630:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1631:#endif
        -: 1632:  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));
        -: 1633:}
        -: 1634:
        -: 1635:template <class IteratorTy>
        -: 1636:inline void array_pod_sort(
        -: 1637:    IteratorTy Start, IteratorTy End,
        -: 1638:    int (*Compare)(
        -: 1639:        const typename std::iterator_traits<IteratorTy>::value_type *,
        -: 1640:        const typename std::iterator_traits<IteratorTy>::value_type *)) {
        -: 1641:  // Don't inefficiently call qsort with one element or trigger undefined
        -: 1642:  // behavior with an empty sequence.
        -: 1643:  auto NElts = End - Start;
        -: 1644:  if (NElts <= 1) return;
        -: 1645:#ifdef EXPENSIVE_CHECKS
        -: 1646:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1647:#endif
        -: 1648:  qsort(&*Start, NElts, sizeof(*Start),
        -: 1649:        reinterpret_cast<int (*)(const void *, const void *)>(Compare));
        -: 1650:}
        -: 1651:
        -: 1652:namespace detail {
        -: 1653:template <typename T>
        -: 1654:// We can use qsort if the iterator type is a pointer and the underlying value
        -: 1655:// is trivially copyable.
        -: 1656:using sort_trivially_copyable = std::conjunction<
        -: 1657:    std::is_pointer<T>,
        -: 1658:    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;
        -: 1659:} // namespace detail
        -: 1660:
        -: 1661:// Provide wrappers to std::sort which shuffle the elements before sorting
        -: 1662:// to help uncover non-deterministic behavior (PR35135).
        -: 1663:template <typename IteratorTy>
        -: 1664:inline void sort(IteratorTy Start, IteratorTy End) {
        -: 1665:  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {
        -: 1666:    // Forward trivially copyable types to array_pod_sort. This avoids a large
        -: 1667:    // amount of code bloat for a minor performance hit.
        -: 1668:    array_pod_sort(Start, End);
        -: 1669:  } else {
        -: 1670:#ifdef EXPENSIVE_CHECKS
        -: 1671:    detail::presortShuffle<IteratorTy>(Start, End);
        -: 1672:#endif
        -: 1673:    std::sort(Start, End);
        -: 1674:  }
        -: 1675:}
        -: 1676:
        -: 1677:template <typename Container> inline void sort(Container &&C) {
        -: 1678:  llvm::sort(adl_begin(C), adl_end(C));
        -: 1679:}
        -: 1680:
        -: 1681:template <typename IteratorTy, typename Compare>
        -: 1682:inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {
        -: 1683:#ifdef EXPENSIVE_CHECKS
        -: 1684:  detail::presortShuffle<IteratorTy>(Start, End);
        -: 1685:#endif
        -: 1686:  std::sort(Start, End, Comp);
        -: 1687:}
        -: 1688:
        -: 1689:template <typename Container, typename Compare>
        -: 1690:inline void sort(Container &&C, Compare Comp) {
        -: 1691:  llvm::sort(adl_begin(C), adl_end(C), Comp);
        -: 1692:}
        -: 1693:
        -: 1694:/// Get the size of a range. This is a wrapper function around std::distance
        -: 1695:/// which is only enabled when the operation is O(1).
        -: 1696:template <typename R>
    #####: 1697:auto size(R &&Range,
        -: 1698:          std::enable_if_t<
        -: 1699:              std::is_base_of<std::random_access_iterator_tag,
        -: 1700:                              typename std::iterator_traits<decltype(
        -: 1701:                                  Range.begin())>::iterator_category>::value,
        -: 1702:              void> * = nullptr) {
    #####: 1703:  return std::distance(Range.begin(), Range.end());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1704:}
        -: 1705:
        -: 1706:/// Provide wrappers to std::for_each which take ranges instead of having to
        -: 1707:/// pass begin/end explicitly.
        -: 1708:template <typename R, typename UnaryFunction>
        -: 1709:UnaryFunction for_each(R &&Range, UnaryFunction F) {
        -: 1710:  return std::for_each(adl_begin(Range), adl_end(Range), F);
        -: 1711:}
        -: 1712:
        -: 1713:/// Provide wrappers to std::all_of which take ranges instead of having to pass
        -: 1714:/// begin/end explicitly.
        -: 1715:template <typename R, typename UnaryPredicate>
    #####: 1716:bool all_of(R &&Range, UnaryPredicate P) {
    #####: 1717:  return std::all_of(adl_begin(Range), adl_end(Range), P);
        -: 1718:}
        -: 1719:
        -: 1720:/// Provide wrappers to std::any_of which take ranges instead of having to pass
        -: 1721:/// begin/end explicitly.
        -: 1722:template <typename R, typename UnaryPredicate>
        -: 1723:bool any_of(R &&Range, UnaryPredicate P) {
        -: 1724:  return std::any_of(adl_begin(Range), adl_end(Range), P);
        -: 1725:}
        -: 1726:
        -: 1727:/// Provide wrappers to std::none_of which take ranges instead of having to pass
        -: 1728:/// begin/end explicitly.
        -: 1729:template <typename R, typename UnaryPredicate>
        -: 1730:bool none_of(R &&Range, UnaryPredicate P) {
        -: 1731:  return std::none_of(adl_begin(Range), adl_end(Range), P);
        -: 1732:}
        -: 1733:
        -: 1734:/// Provide wrappers to std::find which take ranges instead of having to pass
        -: 1735:/// begin/end explicitly.
        -: 1736:template <typename R, typename T> auto find(R &&Range, const T &Val) {
        -: 1737:  return std::find(adl_begin(Range), adl_end(Range), Val);
        -: 1738:}
        -: 1739:
        -: 1740:/// Provide wrappers to std::find_if which take ranges instead of having to pass
        -: 1741:/// begin/end explicitly.
        -: 1742:template <typename R, typename UnaryPredicate>
        -: 1743:auto find_if(R &&Range, UnaryPredicate P) {
        -: 1744:  return std::find_if(adl_begin(Range), adl_end(Range), P);
        -: 1745:}
        -: 1746:
        -: 1747:template <typename R, typename UnaryPredicate>
        -: 1748:auto find_if_not(R &&Range, UnaryPredicate P) {
        -: 1749:  return std::find_if_not(adl_begin(Range), adl_end(Range), P);
        -: 1750:}
        -: 1751:
        -: 1752:/// Provide wrappers to std::remove_if which take ranges instead of having to
        -: 1753:/// pass begin/end explicitly.
        -: 1754:template <typename R, typename UnaryPredicate>
        -: 1755:auto remove_if(R &&Range, UnaryPredicate P) {
        -: 1756:  return std::remove_if(adl_begin(Range), adl_end(Range), P);
        -: 1757:}
        -: 1758:
        -: 1759:/// Provide wrappers to std::copy_if which take ranges instead of having to
        -: 1760:/// pass begin/end explicitly.
        -: 1761:template <typename R, typename OutputIt, typename UnaryPredicate>
        -: 1762:OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {
        -: 1763:  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);
        -: 1764:}
        -: 1765:
        -: 1766:/// Return the single value in \p Range that satisfies
        -: 1767:/// \p P(<member of \p Range> *, AllowRepeats)->T * returning nullptr
        -: 1768:/// when no values or multiple values were found.
        -: 1769:/// When \p AllowRepeats is true, multiple values that compare equal
        -: 1770:/// are allowed.
        -: 1771:template <typename T, typename R, typename Predicate>
        -: 1772:T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {
        -: 1773:  T *RC = nullptr;
        -: 1774:  for (auto *A : Range) {
        -: 1775:    if (T *PRC = P(A, AllowRepeats)) {
        -: 1776:      if (RC) {
        -: 1777:        if (!AllowRepeats || PRC != RC)
        -: 1778:          return nullptr;
        -: 1779:      } else
        -: 1780:        RC = PRC;
        -: 1781:    }
        -: 1782:  }
        -: 1783:  return RC;
        -: 1784:}
        -: 1785:
        -: 1786:/// Return a pair consisting of the single value in \p Range that satisfies
        -: 1787:/// \p P(<member of \p Range> *, AllowRepeats)->std::pair<T*, bool> returning
        -: 1788:/// nullptr when no values or multiple values were found, and a bool indicating
        -: 1789:/// whether multiple values were found to cause the nullptr.
        -: 1790:/// When \p AllowRepeats is true, multiple values that compare equal are
        -: 1791:/// allowed.  The predicate \p P returns a pair<T *, bool> where T is the
        -: 1792:/// singleton while the bool indicates whether multiples have already been
        -: 1793:/// found.  It is expected that first will be nullptr when second is true.
        -: 1794:/// This allows using find_singleton_nested within the predicate \P.
        -: 1795:template <typename T, typename R, typename Predicate>
        -: 1796:std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,
        -: 1797:                                           bool AllowRepeats = false) {
        -: 1798:  T *RC = nullptr;
        -: 1799:  for (auto *A : Range) {
        -: 1800:    std::pair<T *, bool> PRC = P(A, AllowRepeats);
        -: 1801:    if (PRC.second) {
        -: 1802:      assert(PRC.first == nullptr &&
        -: 1803:             "Inconsistent return values in find_singleton_nested.");
        -: 1804:      return PRC;
        -: 1805:    }
        -: 1806:    if (PRC.first) {
        -: 1807:      if (RC) {
        -: 1808:        if (!AllowRepeats || PRC.first != RC)
        -: 1809:          return {nullptr, true};
        -: 1810:      } else
        -: 1811:        RC = PRC.first;
        -: 1812:    }
        -: 1813:  }
        -: 1814:  return {RC, false};
        -: 1815:}
        -: 1816:
        -: 1817:template <typename R, typename OutputIt>
        -: 1818:OutputIt copy(R &&Range, OutputIt Out) {
        -: 1819:  return std::copy(adl_begin(Range), adl_end(Range), Out);
        -: 1820:}
        -: 1821:
        -: 1822:/// Provide wrappers to std::replace_copy_if which take ranges instead of having
        -: 1823:/// to pass begin/end explicitly.
        -: 1824:template <typename R, typename OutputIt, typename UnaryPredicate, typename T>
        -: 1825:OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,
        -: 1826:                         const T &NewValue) {
        -: 1827:  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,
        -: 1828:                              NewValue);
        -: 1829:}
        -: 1830:
        -: 1831:/// Provide wrappers to std::replace_copy which take ranges instead of having to
        -: 1832:/// pass begin/end explicitly.
        -: 1833:template <typename R, typename OutputIt, typename T>
        -: 1834:OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,
        -: 1835:                      const T &NewValue) {
        -: 1836:  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,
        -: 1837:                           NewValue);
        -: 1838:}
        -: 1839:
        -: 1840:/// Provide wrappers to std::move which take ranges instead of having to
        -: 1841:/// pass begin/end explicitly.
        -: 1842:template <typename R, typename OutputIt>
        -: 1843:OutputIt move(R &&Range, OutputIt Out) {
        -: 1844:  return std::move(adl_begin(Range), adl_end(Range), Out);
        -: 1845:}
        -: 1846:
        -: 1847:/// Wrapper function around std::find to detect if an element exists
        -: 1848:/// in a container.
        -: 1849:template <typename R, typename E>
        -: 1850:bool is_contained(R &&Range, const E &Element) {
        -: 1851:  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);
        -: 1852:}
        -: 1853:
        -: 1854:template <typename T>
        -: 1855:constexpr bool is_contained(std::initializer_list<T> Set, T Value) {
        -: 1856:  // TODO: Use std::find when we switch to C++20.
        -: 1857:  for (T V : Set)
        -: 1858:    if (V == Value)
        -: 1859:      return true;
        -: 1860:  return false;
        -: 1861:}
        -: 1862:
        -: 1863:/// Wrapper function around std::is_sorted to check if elements in a range \p R
        -: 1864:/// are sorted with respect to a comparator \p C.
        -: 1865:template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {
        -: 1866:  return std::is_sorted(adl_begin(Range), adl_end(Range), C);
        -: 1867:}
        -: 1868:
        -: 1869:/// Wrapper function around std::is_sorted to check if elements in a range \p R
        -: 1870:/// are sorted in non-descending order.
        -: 1871:template <typename R> bool is_sorted(R &&Range) {
        -: 1872:  return std::is_sorted(adl_begin(Range), adl_end(Range));
        -: 1873:}
        -: 1874:
        -: 1875:/// Wrapper function around std::count to count the number of times an element
        -: 1876:/// \p Element occurs in the given range \p Range.
        -: 1877:template <typename R, typename E> auto count(R &&Range, const E &Element) {
        -: 1878:  return std::count(adl_begin(Range), adl_end(Range), Element);
        -: 1879:}
        -: 1880:
        -: 1881:/// Wrapper function around std::count_if to count the number of times an
        -: 1882:/// element satisfying a given predicate occurs in a range.
        -: 1883:template <typename R, typename UnaryPredicate>
        -: 1884:auto count_if(R &&Range, UnaryPredicate P) {
        -: 1885:  return std::count_if(adl_begin(Range), adl_end(Range), P);
        -: 1886:}
        -: 1887:
        -: 1888:/// Wrapper function around std::transform to apply a function to a range and
        -: 1889:/// store the result elsewhere.
        -: 1890:template <typename R, typename OutputIt, typename UnaryFunction>
        -: 1891:OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {
        -: 1892:  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);
        -: 1893:}
        -: 1894:
        -: 1895:/// Provide wrappers to std::partition which take ranges instead of having to
        -: 1896:/// pass begin/end explicitly.
        -: 1897:template <typename R, typename UnaryPredicate>
        -: 1898:auto partition(R &&Range, UnaryPredicate P) {
        -: 1899:  return std::partition(adl_begin(Range), adl_end(Range), P);
        -: 1900:}
        -: 1901:
        -: 1902:/// Provide wrappers to std::lower_bound which take ranges instead of having to
        -: 1903:/// pass begin/end explicitly.
        -: 1904:template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {
        -: 1905:  return std::lower_bound(adl_begin(Range), adl_end(Range),
        -: 1906:                          std::forward<T>(Value));
        -: 1907:}
        -: 1908:
        -: 1909:template <typename R, typename T, typename Compare>
    #####: 1910:auto lower_bound(R &&Range, T &&Value, Compare C) {
    #####: 1911:  return std::lower_bound(adl_begin(Range), adl_end(Range),
branch  0 never executed
branch  1 never executed
    #####: 1912:                          std::forward<T>(Value), C);
        -: 1913:}
        -: 1914:
        -: 1915:/// Provide wrappers to std::upper_bound which take ranges instead of having to
        -: 1916:/// pass begin/end explicitly.
        -: 1917:template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {
        -: 1918:  return std::upper_bound(adl_begin(Range), adl_end(Range),
        -: 1919:                          std::forward<T>(Value));
        -: 1920:}
        -: 1921:
        -: 1922:template <typename R, typename T, typename Compare>
        -: 1923:auto upper_bound(R &&Range, T &&Value, Compare C) {
        -: 1924:  return std::upper_bound(adl_begin(Range), adl_end(Range),
        -: 1925:                          std::forward<T>(Value), C);
        -: 1926:}
        -: 1927:
        -: 1928:template <typename R>
        -: 1929:void stable_sort(R &&Range) {
        -: 1930:  std::stable_sort(adl_begin(Range), adl_end(Range));
        -: 1931:}
        -: 1932:
        -: 1933:template <typename R, typename Compare>
        -: 1934:void stable_sort(R &&Range, Compare C) {
        -: 1935:  std::stable_sort(adl_begin(Range), adl_end(Range), C);
        -: 1936:}
        -: 1937:
        -: 1938:/// Binary search for the first iterator in a range where a predicate is false.
        -: 1939:/// Requires that C is always true below some limit, and always false above it.
        -: 1940:template <typename R, typename Predicate,
        -: 1941:          typename Val = decltype(*adl_begin(std::declval<R>()))>
        -: 1942:auto partition_point(R &&Range, Predicate P) {
        -: 1943:  return std::partition_point(adl_begin(Range), adl_end(Range), P);
        -: 1944:}
        -: 1945:
        -: 1946:template<typename Range, typename Predicate>
        -: 1947:auto unique(Range &&R, Predicate P) {
        -: 1948:  return std::unique(adl_begin(R), adl_end(R), P);
        -: 1949:}
        -: 1950:
        -: 1951:/// Wrapper function around std::equal to detect if pair-wise elements between
        -: 1952:/// two ranges are the same.
        -: 1953:template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {
        -: 1954:  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),
        -: 1955:                    adl_end(RRange));
        -: 1956:}
        -: 1957:
        -: 1958:/// Returns true if all elements in Range are equal or when the Range is empty.
        -: 1959:template <typename R> bool all_equal(R &&Range) {
        -: 1960:  auto Begin = adl_begin(Range);
        -: 1961:  auto End = adl_end(Range);
        -: 1962:  return Begin == End || std::equal(Begin + 1, End, Begin);
        -: 1963:}
        -: 1964:
        -: 1965:/// Returns true if all Values in the initializer lists are equal or the list
        -: 1966:// is empty.
        -: 1967:template <typename T> bool all_equal(std::initializer_list<T> Values) {
        -: 1968:  return all_equal<std::initializer_list<T>>(std::move(Values));
        -: 1969:}
        -: 1970:
        -: 1971:/// Provide a container algorithm similar to C++ Library Fundamentals v2's
        -: 1972:/// `erase_if` which is equivalent to:
        -: 1973:///
        -: 1974:///   C.erase(remove_if(C, pred), C.end());
        -: 1975:///
        -: 1976:/// This version works for any container with an erase method call accepting
        -: 1977:/// two iterators.
        -: 1978:template <typename Container, typename UnaryPredicate>
        -: 1979:void erase_if(Container &C, UnaryPredicate P) {
        -: 1980:  C.erase(remove_if(C, P), C.end());
        -: 1981:}
        -: 1982:
        -: 1983:/// Wrapper function to remove a value from a container:
        -: 1984:///
        -: 1985:/// C.erase(remove(C.begin(), C.end(), V), C.end());
        -: 1986:template <typename Container, typename ValueType>
        -: 1987:void erase_value(Container &C, ValueType V) {
        -: 1988:  C.erase(std::remove(C.begin(), C.end(), V), C.end());
        -: 1989:}
        -: 1990:
        -: 1991:/// Wrapper function to append a range to a container.
        -: 1992:///
        -: 1993:/// C.insert(C.end(), R.begin(), R.end());
        -: 1994:template <typename Container, typename Range>
    #####: 1995:inline void append_range(Container &C, Range &&R) {
    #####: 1996:  C.insert(C.end(), R.begin(), R.end());
    #####: 1997:}
------------------
_ZN4llvm12append_rangeINS_11SmallVectorIN4mlir4TypeELj8EEENS2_14ValueTypeRangeINS2_12OperandRangeEEEEEvRT_OT0_:
function _ZN4llvm12append_rangeINS_11SmallVectorIN4mlir4TypeELj8EEENS2_14ValueTypeRangeINS2_12OperandRangeEEEEEvRT_OT0_ called 0 returned 0% blocks executed 0%
    #####: 1995:inline void append_range(Container &C, Range &&R) {
    #####: 1996:  C.insert(C.end(), R.begin(), R.end());
call    0 never executed
    #####: 1997:}
------------------
_ZN4llvm12append_rangeINS_11SmallVectorIjLj12EEERNS_8ArrayRefIlEEEEvRT_OT0_:
function _ZN4llvm12append_rangeINS_11SmallVectorIjLj12EEERNS_8ArrayRefIlEEEEvRT_OT0_ called 0 returned 0% blocks executed 0%
    #####: 1995:inline void append_range(Container &C, Range &&R) {
    #####: 1996:  C.insert(C.end(), R.begin(), R.end());
call    0 never executed
    #####: 1997:}
------------------
        -: 1998:
        -: 1999:/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with
        -: 2000:/// the range [ValIt, ValEnd) (which is not from the same container).
        -: 2001:template<typename Container, typename RandomAccessIterator>
        -: 2002:void replace(Container &Cont, typename Container::iterator ContIt,
        -: 2003:             typename Container::iterator ContEnd, RandomAccessIterator ValIt,
        -: 2004:             RandomAccessIterator ValEnd) {
        -: 2005:  while (true) {
        -: 2006:    if (ValIt == ValEnd) {
        -: 2007:      Cont.erase(ContIt, ContEnd);
        -: 2008:      return;
        -: 2009:    } else if (ContIt == ContEnd) {
        -: 2010:      Cont.insert(ContIt, ValIt, ValEnd);
        -: 2011:      return;
        -: 2012:    }
        -: 2013:    *ContIt++ = *ValIt++;
        -: 2014:  }
        -: 2015:}
        -: 2016:
        -: 2017:/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with
        -: 2018:/// the range R.
        -: 2019:template<typename Container, typename Range = std::initializer_list<
        -: 2020:                                 typename Container::value_type>>
        -: 2021:void replace(Container &Cont, typename Container::iterator ContIt,
        -: 2022:             typename Container::iterator ContEnd, Range R) {
        -: 2023:  replace(Cont, ContIt, ContEnd, R.begin(), R.end());
        -: 2024:}
        -: 2025:
        -: 2026:/// An STL-style algorithm similar to std::for_each that applies a second
        -: 2027:/// functor between every pair of elements.
        -: 2028:///
        -: 2029:/// This provides the control flow logic to, for example, print a
        -: 2030:/// comma-separated list:
        -: 2031:/// \code
        -: 2032:///   interleave(names.begin(), names.end(),
        -: 2033:///              [&](StringRef name) { os << name; },
        -: 2034:///              [&] { os << ", "; });
        -: 2035:/// \endcode
        -: 2036:template <typename ForwardIterator, typename UnaryFunctor,
        -: 2037:          typename NullaryFunctor,
        -: 2038:          typename = std::enable_if_t<
        -: 2039:              !std::is_constructible<StringRef, UnaryFunctor>::value &&
        -: 2040:              !std::is_constructible<StringRef, NullaryFunctor>::value>>
        -: 2041:inline void interleave(ForwardIterator begin, ForwardIterator end,
        -: 2042:                       UnaryFunctor each_fn, NullaryFunctor between_fn) {
        -: 2043:  if (begin == end)
        -: 2044:    return;
        -: 2045:  each_fn(*begin);
        -: 2046:  ++begin;
        -: 2047:  for (; begin != end; ++begin) {
        -: 2048:    between_fn();
        -: 2049:    each_fn(*begin);
        -: 2050:  }
        -: 2051:}
        -: 2052:
        -: 2053:template <typename Container, typename UnaryFunctor, typename NullaryFunctor,
        -: 2054:          typename = std::enable_if_t<
        -: 2055:              !std::is_constructible<StringRef, UnaryFunctor>::value &&
        -: 2056:              !std::is_constructible<StringRef, NullaryFunctor>::value>>
        -: 2057:inline void interleave(const Container &c, UnaryFunctor each_fn,
        -: 2058:                       NullaryFunctor between_fn) {
        -: 2059:  interleave(c.begin(), c.end(), each_fn, between_fn);
        -: 2060:}
        -: 2061:
        -: 2062:/// Overload of interleave for the common case of string separator.
        -: 2063:template <typename Container, typename UnaryFunctor, typename StreamT,
        -: 2064:          typename T = detail::ValueOfRange<Container>>
        -: 2065:inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,
        -: 2066:                       const StringRef &separator) {
        -: 2067:  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });
        -: 2068:}
        -: 2069:template <typename Container, typename StreamT,
        -: 2070:          typename T = detail::ValueOfRange<Container>>
        -: 2071:inline void interleave(const Container &c, StreamT &os,
        -: 2072:                       const StringRef &separator) {
        -: 2073:  interleave(
        -: 2074:      c, os, [&](const T &a) { os << a; }, separator);
        -: 2075:}
        -: 2076:
        -: 2077:template <typename Container, typename UnaryFunctor, typename StreamT,
        -: 2078:          typename T = detail::ValueOfRange<Container>>
        -: 2079:inline void interleaveComma(const Container &c, StreamT &os,
        -: 2080:                            UnaryFunctor each_fn) {
        -: 2081:  interleave(c, os, each_fn, ", ");
        -: 2082:}
        -: 2083:template <typename Container, typename StreamT,
        -: 2084:          typename T = detail::ValueOfRange<Container>>
        -: 2085:inline void interleaveComma(const Container &c, StreamT &os) {
        -: 2086:  interleaveComma(c, os, [&](const T &a) { os << a; });
        -: 2087:}
        -: 2088:
        -: 2089://===----------------------------------------------------------------------===//
        -: 2090://     Extra additions to <memory>
        -: 2091://===----------------------------------------------------------------------===//
        -: 2092:
        -: 2093:struct FreeDeleter {
        -: 2094:  void operator()(void* v) {
        -: 2095:    ::free(v);
        -: 2096:  }
        -: 2097:};
        -: 2098:
        -: 2099:template<typename First, typename Second>
        -: 2100:struct pair_hash {
        -: 2101:  size_t operator()(const std::pair<First, Second> &P) const {
        -: 2102:    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);
        -: 2103:  }
        -: 2104:};
        -: 2105:
        -: 2106:/// Binary functor that adapts to any other binary functor after dereferencing
        -: 2107:/// operands.
        -: 2108:template <typename T> struct deref {
        -: 2109:  T func;
        -: 2110:
        -: 2111:  // Could be further improved to cope with non-derivable functors and
        -: 2112:  // non-binary functors (should be a variadic template member function
        -: 2113:  // operator()).
        -: 2114:  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {
        -: 2115:    assert(lhs);
        -: 2116:    assert(rhs);
        -: 2117:    return func(*lhs, *rhs);
        -: 2118:  }
        -: 2119:};
        -: 2120:
        -: 2121:namespace detail {
        -: 2122:
        -: 2123:template <typename R> class enumerator_iter;
        -: 2124:
        -: 2125:template <typename R> struct result_pair {
        -: 2126:  using value_reference =
        -: 2127:      typename std::iterator_traits<IterOfRange<R>>::reference;
        -: 2128:
        -: 2129:  friend class enumerator_iter<R>;
        -: 2130:
        -: 2131:  result_pair() = default;
    #####: 2132:  result_pair(std::size_t Index, IterOfRange<R> Iter)
    #####: 2133:      : Index(Index), Iter(Iter) {}
        -: 2134:
        -: 2135:  result_pair(const result_pair<R> &Other)
        -: 2136:      : Index(Other.Index), Iter(Other.Iter) {}
        -: 2137:  result_pair &operator=(const result_pair &Other) {
        -: 2138:    Index = Other.Index;
        -: 2139:    Iter = Other.Iter;
        -: 2140:    return *this;
        -: 2141:  }
        -: 2142:
    #####: 2143:  std::size_t index() const { return Index; }
call    0 never executed
    #####: 2144:  value_reference value() const { return *Iter; }
branch  0 never executed
branch  1 never executed
        -: 2145:
        -: 2146:private:
        -: 2147:  std::size_t Index = std::numeric_limits<std::size_t>::max();
        -: 2148:  IterOfRange<R> Iter;
        -: 2149:};
        -: 2150:
        -: 2151:template <std::size_t i, typename R>
        -: 2152:decltype(auto) get(const result_pair<R> &Pair) {
        -: 2153:  static_assert(i < 2);
        -: 2154:  if constexpr (i == 0) {
        -: 2155:    return Pair.index();
        -: 2156:  } else {
        -: 2157:    return Pair.value();
        -: 2158:  }
        -: 2159:}
        -: 2160:
        -: 2161:template <typename R>
        -: 2162:class enumerator_iter
        -: 2163:    : public iterator_facade_base<enumerator_iter<R>, std::forward_iterator_tag,
        -: 2164:                                  const result_pair<R>> {
        -: 2165:  using result_type = result_pair<R>;
        -: 2166:
        -: 2167:public:
    #####: 2168:  explicit enumerator_iter(IterOfRange<R> EndIter)
    #####: 2169:      : Result(std::numeric_limits<size_t>::max(), EndIter) {}
        -: 2170:
    #####: 2171:  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)
    #####: 2172:      : Result(Index, Iter) {}
        -: 2173:
    #####: 2174:  const result_type &operator*() const { return Result; }
branch  0 never executed
branch  1 never executed
        -: 2175:
function _ZN4llvm6detail15enumerator_iterIRN4mlir9ArrayAttrEEppEv called 0 returned 0% blocks executed 0%
    #####: 2176:  enumerator_iter &operator++() {
    #####: 2177:    assert(Result.Index != std::numeric_limits<size_t>::max());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2178:    ++Result.Iter;
    #####: 2179:    ++Result.Index;
    #####: 2180:    return *this;
        -: 2181:  }
        -: 2182:
    #####: 2183:  bool operator==(const enumerator_iter &RHS) const {
branch  0 never executed
branch  1 never executed
        -: 2184:    // Don't compare indices here, only iterators.  It's possible for an end
        -: 2185:    // iterator to have different indices depending on whether it was created
        -: 2186:    // by calling std::end() versus incrementing a valid iterator.
        -: 2187:    return Result.Iter == RHS.Result.Iter;
        -: 2188:  }
        -: 2189:
        -: 2190:  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}
        -: 2191:  enumerator_iter &operator=(const enumerator_iter &Other) {
        -: 2192:    Result = Other.Result;
        -: 2193:    return *this;
        -: 2194:  }
        -: 2195:
        -: 2196:private:
        -: 2197:  result_type Result;
        -: 2198:};
        -: 2199:
        -: 2200:template <typename R> class enumerator {
        -: 2201:public:
    #####: 2202:  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}
        -: 2203:
    #####: 2204:  enumerator_iter<R> begin() {
    #####: 2205:    return enumerator_iter<R>(0, std::begin(TheRange));
call    0 never executed
        -: 2206:  }
        -: 2207:  enumerator_iter<R> begin() const {
        -: 2208:    return enumerator_iter<R>(0, std::begin(TheRange));
        -: 2209:  }
        -: 2210:
    #####: 2211:  enumerator_iter<R> end() {
    #####: 2212:    return enumerator_iter<R>(std::end(TheRange));
call    0 never executed
        -: 2213:  }
        -: 2214:  enumerator_iter<R> end() const {
        -: 2215:    return enumerator_iter<R>(std::end(TheRange));
        -: 2216:  }
        -: 2217:
        -: 2218:private:
        -: 2219:  R TheRange;
        -: 2220:};
        -: 2221:
        -: 2222:} // end namespace detail
        -: 2223:
        -: 2224:/// Given an input range, returns a new range whose values are are pair (A,B)
        -: 2225:/// such that A is the 0-based index of the item in the sequence, and B is
        -: 2226:/// the value from the original sequence.  Example:
        -: 2227:///
        -: 2228:/// std::vector<char> Items = {'A', 'B', 'C', 'D'};
        -: 2229:/// for (auto X : enumerate(Items)) {
        -: 2230:///   printf("Item %d - %c\n", X.index(), X.value());
        -: 2231:/// }
        -: 2232:///
        -: 2233:/// or using structured bindings:
        -: 2234:///
        -: 2235:/// for (auto [Index, Value] : enumerate(Items)) {
        -: 2236:///   printf("Item %d - %c\n", Index, Value);
        -: 2237:/// }
        -: 2238:///
        -: 2239:/// Output:
        -: 2240:///   Item 0 - A
        -: 2241:///   Item 1 - B
        -: 2242:///   Item 2 - C
        -: 2243:///   Item 3 - D
        -: 2244:///
    #####: 2245:template <typename R> detail::enumerator<R> enumerate(R &&TheRange) {
call    0 never executed
    #####: 2246:  return detail::enumerator<R>(std::forward<R>(TheRange));
call    0 never executed
        -: 2247:}
        -: 2248:
        -: 2249:namespace detail {
        -: 2250:
        -: 2251:template <typename Predicate, typename... Args>
        -: 2252:bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {
        -: 2253:  auto z = zip(args...);
        -: 2254:  auto it = z.begin();
        -: 2255:  auto end = z.end();
        -: 2256:  while (it != end) {
        -: 2257:    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))
        -: 2258:      return false;
        -: 2259:    ++it;
        -: 2260:  }
        -: 2261:  return it.all_equals(end);
        -: 2262:}
        -: 2263:
        -: 2264:// Just an adaptor to switch the order of argument and have the predicate before
        -: 2265:// the zipped inputs.
        -: 2266:template <typename... ArgsThenPredicate, size_t... InputIndexes>
        -: 2267:bool all_of_zip_predicate_last(
        -: 2268:    std::tuple<ArgsThenPredicate...> argsThenPredicate,
        -: 2269:    std::index_sequence<InputIndexes...>) {
        -: 2270:  auto constexpr OutputIndex =
        -: 2271:      std::tuple_size<decltype(argsThenPredicate)>::value - 1;
        -: 2272:  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),
        -: 2273:                             std::get<InputIndexes>(argsThenPredicate)...);
        -: 2274:}
        -: 2275:
        -: 2276:} // end namespace detail
        -: 2277:
        -: 2278:/// Compare two zipped ranges using the provided predicate (as last argument).
        -: 2279:/// Return true if all elements satisfy the predicate and false otherwise.
        -: 2280://  Return false if the zipped iterator aren't all at end (size mismatch).
        -: 2281:template <typename... ArgsAndPredicate>
        -: 2282:bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {
        -: 2283:  return detail::all_of_zip_predicate_last(
        -: 2284:      std::forward_as_tuple(argsAndPredicate...),
        -: 2285:      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});
        -: 2286:}
        -: 2287:
        -: 2288:/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)
        -: 2289:/// time. Not meant for use with random-access iterators.
        -: 2290:/// Can optionally take a predicate to filter lazily some items.
        -: 2291:template <typename IterTy,
        -: 2292:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2293:bool hasNItems(
        -: 2294:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2295:    Pred &&ShouldBeCounted =
        -: 2296:        [](const decltype(*std::declval<IterTy>()) &) { return true; },
        -: 2297:    std::enable_if_t<
        -: 2298:        !std::is_base_of<std::random_access_iterator_tag,
        -: 2299:                         typename std::iterator_traits<std::remove_reference_t<
        -: 2300:                             decltype(Begin)>>::iterator_category>::value,
        -: 2301:        void> * = nullptr) {
        -: 2302:  for (; N; ++Begin) {
        -: 2303:    if (Begin == End)
        -: 2304:      return false; // Too few.
        -: 2305:    N -= ShouldBeCounted(*Begin);
        -: 2306:  }
        -: 2307:  for (; Begin != End; ++Begin)
        -: 2308:    if (ShouldBeCounted(*Begin))
        -: 2309:      return false; // Too many.
        -: 2310:  return true;
        -: 2311:}
        -: 2312:
        -: 2313:/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)
        -: 2314:/// time. Not meant for use with random-access iterators.
        -: 2315:/// Can optionally take a predicate to lazily filter some items.
        -: 2316:template <typename IterTy,
        -: 2317:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2318:bool hasNItemsOrMore(
        -: 2319:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2320:    Pred &&ShouldBeCounted =
        -: 2321:        [](const decltype(*std::declval<IterTy>()) &) { return true; },
        -: 2322:    std::enable_if_t<
        -: 2323:        !std::is_base_of<std::random_access_iterator_tag,
        -: 2324:                         typename std::iterator_traits<std::remove_reference_t<
        -: 2325:                             decltype(Begin)>>::iterator_category>::value,
        -: 2326:        void> * = nullptr) {
        -: 2327:  for (; N; ++Begin) {
        -: 2328:    if (Begin == End)
        -: 2329:      return false; // Too few.
        -: 2330:    N -= ShouldBeCounted(*Begin);
        -: 2331:  }
        -: 2332:  return true;
        -: 2333:}
        -: 2334:
        -: 2335:/// Returns true if the sequence [Begin, End) has N or less items. Can
        -: 2336:/// optionally take a predicate to lazily filter some items.
        -: 2337:template <typename IterTy,
        -: 2338:          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
        -: 2339:bool hasNItemsOrLess(
        -: 2340:    IterTy &&Begin, IterTy &&End, unsigned N,
        -: 2341:    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {
        -: 2342:      return true;
        -: 2343:    }) {
        -: 2344:  assert(N != std::numeric_limits<unsigned>::max());
        -: 2345:  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);
        -: 2346:}
        -: 2347:
        -: 2348:/// Returns true if the given container has exactly N items
        -: 2349:template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {
        -: 2350:  return hasNItems(std::begin(C), std::end(C), N);
        -: 2351:}
        -: 2352:
        -: 2353:/// Returns true if the given container has N or more items
        -: 2354:template <typename ContainerTy>
        -: 2355:bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {
        -: 2356:  return hasNItemsOrMore(std::begin(C), std::end(C), N);
        -: 2357:}
        -: 2358:
        -: 2359:/// Returns true if the given container has N or less items
        -: 2360:template <typename ContainerTy>
        -: 2361:bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {
        -: 2362:  return hasNItemsOrLess(std::begin(C), std::end(C), N);
        -: 2363:}
        -: 2364:
        -: 2365:/// Returns a raw pointer that represents the same address as the argument.
        -: 2366:///
        -: 2367:/// This implementation can be removed once we move to C++20 where it's defined
        -: 2368:/// as std::to_address().
        -: 2369:///
        -: 2370:/// The std::pointer_traits<>::to_address(p) variations of these overloads has
        -: 2371:/// not been implemented.
        -: 2372:template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }
        -: 2373:template <class T> constexpr T *to_address(T *P) { return P; }
        -: 2374:
        -: 2375:} // end namespace llvm
        -: 2376:
        -: 2377:namespace std {
        -: 2378:template <typename R>
        -: 2379:struct tuple_size<llvm::detail::result_pair<R>>
        -: 2380:    : std::integral_constant<std::size_t, 2> {};
        -: 2381:
        -: 2382:template <std::size_t i, typename R>
        -: 2383:struct tuple_element<i, llvm::detail::result_pair<R>>
        -: 2384:    : std::conditional<i == 0, std::size_t,
        -: 2385:                       typename llvm::detail::result_pair<R>::value_reference> {
        -: 2386:};
        -: 2387:
        -: 2388:} // namespace std
        -: 2389:
        -: 2390:#endif // LLVM_ADT_STLEXTRAS_H
