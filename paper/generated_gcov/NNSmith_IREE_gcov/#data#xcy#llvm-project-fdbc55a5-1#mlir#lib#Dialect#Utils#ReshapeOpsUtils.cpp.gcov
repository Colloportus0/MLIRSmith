        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Utils/ReshapeOpsUtils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Utils/CMakeFiles/obj.MLIRDialectUtils.dir/ReshapeOpsUtils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Utils/CMakeFiles/obj.MLIRDialectUtils.dir/ReshapeOpsUtils.cpp.gcda
        -:    0:Runs:325595
        -:    1://===- ReshapeOpsUtils.cpp - Utilities used by structured ops -------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Utils/ReshapeOpsUtils.h"
        -:   10:
        -:   11:#include "mlir/IR/AffineMap.h"
        -:   12:#include "mlir/IR/Builders.h"
        -:   13:
        -:   14:#include <numeric>
        -:   15:
        -:   16:using namespace mlir;
        -:   17:
        -:   18:Optional<SmallVector<ReassociationIndices>>
function _ZN4mlir33getReassociationIndicesForReshapeENS_10ShapedTypeES0_ called 0 returned 0% blocks executed 0%
    #####:   19:mlir::getReassociationIndicesForReshape(ShapedType sourceType,
        -:   20:                                        ShapedType targetType) {
    #####:   21:  if (sourceType.getRank() > targetType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   22:    return getReassociationIndicesForCollapse(sourceType.getShape(),
    #####:   23:                                              targetType.getShape());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   24:  if (sourceType.getRank() < targetType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   25:    return getReassociationIndicesForCollapse(targetType.getShape(),
    #####:   26:                                              sourceType.getShape());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   27:  return llvm::None;
        -:   28:}
        -:   29:
        -:   30:Optional<SmallVector<ReassociationIndices>>
function _ZN4mlir34getReassociationIndicesForCollapseEN4llvm8ArrayRefIlEES2_ called 0 returned 0% blocks executed 0%
    #####:   31:mlir::getReassociationIndicesForCollapse(ArrayRef<int64_t> sourceShape,
        -:   32:                                         ArrayRef<int64_t> targetShape) {
    #####:   33:  if (sourceShape.size() <= targetShape.size())
branch  0 never executed
branch  1 never executed
    #####:   34:    return llvm::None;
    #####:   35:  unsigned sourceDim = 0;
    #####:   36:  SmallVector<ReassociationIndices> reassociationMap;
branch  0 never executed
branch  1 never executed
    #####:   37:  reassociationMap.reserve(targetShape.size());
branch  0 never executed
branch  1 never executed
        -:   38:
    #####:   39:  ReassociationIndices currIndices;
call    0 never executed
    #####:   40:  int64_t prodOfCollapsedDims = 1;
    #####:   41:  while (sourceDim < sourceShape.size()) {
branch  0 never executed
branch  1 never executed
    #####:   42:    unsigned targetDim = reassociationMap.size();
branch  0 never executed
branch  1 never executed
        -:   43:    // If we have mapped all the target dimensions stop and handle the remaining
        -:   44:    // tail of size-1 dimensions explictly.
    #####:   45:    if (targetDim == targetShape.size())
branch  0 never executed
branch  1 never executed
        -:   46:      break;
        -:   47:
    #####:   48:    int64_t currTargetShape = targetShape[targetDim];
branch  0 never executed
branch  1 never executed
    #####:   49:    while (sourceShape[sourceDim] != ShapedType::kDynamicSize &&
branch  0 never executed
branch  1 never executed
    #####:   50:           prodOfCollapsedDims * sourceShape[sourceDim] < currTargetShape &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   51:           sourceDim < sourceShape.size()) {
call    0 never executed
    #####:   52:      prodOfCollapsedDims *= sourceShape[sourceDim];
call    0 never executed
    #####:   53:      currIndices.push_back(sourceDim++);
call    0 never executed
        -:   54:    }
        -:   55:
        -:   56:    // If the current expanded dimension is dynamic, then the collapsed
        -:   57:    // dimensions should also be dynamic and product of all previous unprocessed
        -:   58:    // dimensions of the expanded shape should be 1.
    #####:   59:    if (sourceShape[sourceDim] == ShapedType::kDynamicSize &&
branch  0 never executed
branch  1 never executed
    #####:   60:        (currTargetShape != ShapedType::kDynamicSize ||
    #####:   61:         prodOfCollapsedDims != 1))
branch  0 never executed
branch  1 never executed
    #####:   62:      return llvm::None;
        -:   63:
        -:   64:    // If the collapsed dim is dynamic, the current expanded dim should also
        -:   65:    // be dynamic.
    #####:   66:    if (currTargetShape == ShapedType::kDynamicSize &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   67:        sourceShape[sourceDim] != ShapedType::kDynamicSize)
branch  0 never executed
branch  1 never executed
    #####:   68:      return llvm::None;
        -:   69:
        -:   70:    // For static shapes, if the product of dimensions of the expanded shape
        -:   71:    // should match the collapsed dimension shape.
    #####:   72:    if (prodOfCollapsedDims * sourceShape[sourceDim] != currTargetShape)
branch  0 never executed
branch  1 never executed
    #####:   73:      return llvm::None;
        -:   74:
    #####:   75:    currIndices.push_back(sourceDim++);
call    0 never executed
    #####:   76:    reassociationMap.emplace_back(ReassociationIndices{});
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    std::swap(reassociationMap.back(), currIndices);
call    0 never executed
call    1 never executed
    #####:   78:    prodOfCollapsedDims = 1;
call    0 never executed
        -:   79:  }
        -:   80:  // All the dimensions in the target must have been processed.
    #####:   81:  if (reassociationMap.size() != targetShape.size())
branch  0 never executed
branch  1 never executed
    #####:   82:    return llvm::None;
        -:   83:  // Process any remaining entries in the source shape. They all need to be
        -:   84:  // 1 or dynamic.
    #####:   85:  for (; sourceDim < sourceShape.size(); sourceDim++) {
branch  0 never executed
branch  1 never executed
    #####:   86:    if (sourceShape[sourceDim] != ShapedType::kDynamicSize &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   87:        sourceShape[sourceDim] != 1)
branch  0 never executed
branch  1 never executed
    #####:   88:      return llvm::None;
        -:   89:    // The map is empty when the target type is a scalar.
    #####:   90:    if (!reassociationMap.empty())
branch  0 never executed
branch  1 never executed
    #####:   91:      reassociationMap.back().push_back(sourceDim);
call    0 never executed
call    1 never executed
        -:   92:  }
    #####:   93:  return reassociationMap;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   94:}
        -:   95:
function _ZN4mlir27composeReassociationIndicesEN4llvm8ArrayRefINS0_11SmallVectorIlLj2EEEEES4_PNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:   96:Optional<SmallVector<ReassociationIndices>> mlir::composeReassociationIndices(
        -:   97:    ArrayRef<ReassociationIndices> producerReassociations,
        -:   98:    ArrayRef<ReassociationIndices> consumerReassociations,
        -:   99:    MLIRContext *context) {
    #####:  100:  SmallVector<ReassociationIndices> composedIndices;
branch  0 never executed
branch  1 never executed
        -:  101:  // Make the producer the larger sized vector. If they are of same size, the
        -:  102:  // resulting reshape is not a supported reshape op.
    #####:  103:  if (producerReassociations.size() == consumerReassociations.size())
branch  0 never executed
branch  1 never executed
    #####:  104:    return llvm::None;
    #####:  105:  if (producerReassociations.size() < consumerReassociations.size())
branch  0 never executed
branch  1 never executed
    #####:  106:    std::swap(producerReassociations, consumerReassociations);
        -:  107:
        -:  108:  // Handle the corner case of the result being a rank 0 shaped type. Return an
        -:  109:  // empty reassociation.
    #####:  110:  if (consumerReassociations.empty())
branch  0 never executed
branch  1 never executed
    #####:  111:    return composedIndices;
        -:  112:
    #####:  113:  size_t consumerDims = std::accumulate(
        -:  114:      consumerReassociations.begin(), consumerReassociations.end(), 0,
    #####:  115:      [](size_t all, ReassociationIndicesRef indices) {
    #####:  116:        return all + indices.size();
    #####:  117:      });
    #####:  118:  if (producerReassociations.size() != consumerDims)
branch  0 never executed
branch  1 never executed
    #####:  119:    return llvm::None;
        -:  120:
    #####:  121:  for (ReassociationIndicesRef consumerIndices : consumerReassociations) {
branch  0 never executed
branch  1 never executed
    #####:  122:    ReassociationIndices reassociations;
    #####:  123:    for (int64_t consumerIndex : consumerIndices) {
branch  0 never executed
branch  1 never executed
    #####:  124:      llvm::append_range(reassociations, producerReassociations[consumerIndex]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  125:    }
    #####:  126:    composedIndices.push_back(std::move(reassociations));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  127:  }
    #####:  128:  return composedIndices;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  129:}
        -:  130:
        -:  131:SmallVector<SmallVector<AffineExpr, 2>, 2>
function _ZN4mlir34convertReassociationIndicesToExprsEPNS_11MLIRContextEN4llvm8ArrayRefINS2_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  132:mlir::convertReassociationIndicesToExprs(
        -:  133:    MLIRContext *context, ArrayRef<ReassociationIndices> reassociationIndices) {
    #####:  134:  SmallVector<SmallVector<AffineExpr, 2>, 2> reassociationMaps;
    #####:  135:  for (const auto &indices : reassociationIndices) {
branch  0 never executed
branch  1 never executed
    #####:  136:    SmallVector<AffineExpr, 2> reassociationMap;
branch  0 never executed
branch  1 never executed
    #####:  137:    reassociationMap.reserve(indices.size());
branch  0 never executed
branch  1 never executed
    #####:  138:    for (int64_t index : indices)
branch  0 never executed
branch  1 never executed
    #####:  139:      reassociationMap.push_back(mlir::getAffineDimExpr(index, context));
call    0 never executed
call    1 never executed
    #####:  140:    reassociationMaps.push_back(std::move(reassociationMap));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  141:  }
    #####:  142:  return reassociationMaps;
        -:  143:}
        -:  144:
        -:  145:template <typename AffineExprTy>
    #####:  146:unsigned getMaxPosOfType(ArrayRef<ReassociationExprs> exprArrays) {
    #####:  147:  unsigned pos = 0;
    #####:  148:  for (const auto &exprs : exprArrays) {
    #####:  149:    for (auto expr : exprs) {
    #####:  150:      expr.walk([&pos](AffineExpr e) {
    #####:  151:        if (auto d = e.dyn_cast<AffineExprTy>())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  152:          pos = std::max(pos, d.getPosition());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  153:      });
        -:  154:    }
        -:  155:  }
    #####:  156:  return pos;
        -:  157:}
------------------
_Z15getMaxPosOfTypeIN4mlir16AffineSymbolExprEEjN4llvm8ArrayRefINS2_11SmallVectorINS0_10AffineExprELj2EEEEE:
function _Z15getMaxPosOfTypeIN4mlir16AffineSymbolExprEEjN4llvm8ArrayRefINS2_11SmallVectorINS0_10AffineExprELj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  146:unsigned getMaxPosOfType(ArrayRef<ReassociationExprs> exprArrays) {
    #####:  147:  unsigned pos = 0;
    #####:  148:  for (const auto &exprs : exprArrays) {
branch  0 never executed
branch  1 never executed
    #####:  149:    for (auto expr : exprs) {
branch  0 never executed
branch  1 never executed
    #####:  150:      expr.walk([&pos](AffineExpr e) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  151:        if (auto d = e.dyn_cast<AffineExprTy>())
        -:  152:          pos = std::max(pos, d.getPosition());
        -:  153:      });
        -:  154:    }
        -:  155:  }
    #####:  156:  return pos;
        -:  157:}
------------------
_Z15getMaxPosOfTypeIN4mlir13AffineDimExprEEjN4llvm8ArrayRefINS2_11SmallVectorINS0_10AffineExprELj2EEEEE:
function _Z15getMaxPosOfTypeIN4mlir13AffineDimExprEEjN4llvm8ArrayRefINS2_11SmallVectorINS0_10AffineExprELj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  146:unsigned getMaxPosOfType(ArrayRef<ReassociationExprs> exprArrays) {
    #####:  147:  unsigned pos = 0;
    #####:  148:  for (const auto &exprs : exprArrays) {
branch  0 never executed
branch  1 never executed
    #####:  149:    for (auto expr : exprs) {
branch  0 never executed
branch  1 never executed
    #####:  150:      expr.walk([&pos](AffineExpr e) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  151:        if (auto d = e.dyn_cast<AffineExprTy>())
        -:  152:          pos = std::max(pos, d.getPosition());
        -:  153:      });
        -:  154:    }
        -:  155:  }
    #####:  156:  return pos;
        -:  157:}
------------------
        -:  158:
function _ZN4mlir32getReassociationIndicesAttributeERNS_9OpBuilderEN4llvm8ArrayRefINS2_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  159:ArrayAttr mlir::getReassociationIndicesAttribute(
        -:  160:    OpBuilder &b, ArrayRef<ReassociationIndices> reassociation) {
    #####:  161:  SmallVector<Attribute, 4> reassociationAttr =
    #####:  162:      llvm::to_vector<4>(llvm::map_range(
    #####:  163:          reassociation, [&](const ReassociationIndices &indices) -> Attribute {
    #####:  164:            return b.getI64ArrayAttr(indices).cast<Attribute>();
call    0 never executed
    #####:  165:          }));
call    0 never executed
    #####:  166:  return b.getArrayAttr(reassociationAttr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  167:}
        -:  168:
function _ZN4mlir33convertReassociationMapsToIndicesERNS_9OpBuilderEN4llvm8ArrayRefINS2_11SmallVectorINS_10AffineExprELj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  169:SmallVector<ReassociationIndices, 2> mlir::convertReassociationMapsToIndices(
        -:  170:    OpBuilder &b, ArrayRef<ReassociationExprs> reassociationExprs) {
    #####:  171:  SmallVector<ReassociationIndices, 2> reassociationIndices;
    #####:  172:  for (const auto &exprs : reassociationExprs) {
branch  0 never executed
branch  1 never executed
    #####:  173:    ReassociationIndices indices;
branch  0 never executed
branch  1 never executed
    #####:  174:    indices.reserve(exprs.size());
branch  0 never executed
branch  1 never executed
    #####:  175:    for (const auto &expr : exprs)
branch  0 never executed
branch  1 never executed
    #####:  176:      indices.push_back(expr.cast<AffineDimExpr>().getPosition());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  177:    reassociationIndices.push_back(indices);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  178:  }
    #####:  179:  return reassociationIndices;
        -:  180:}
        -:  181:
        -:  182:SmallVector<AffineMap, 4>
function _ZN4mlir23getSymbolLessAffineMapsEN4llvm8ArrayRefINS0_11SmallVectorINS_10AffineExprELj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  183:mlir::getSymbolLessAffineMaps(ArrayRef<ReassociationExprs> reassociation) {
    #####:  184:  unsigned maxDim = getMaxPosOfType<AffineDimExpr>(reassociation);
call    0 never executed
    #####:  185:  assert(getMaxPosOfType<AffineSymbolExpr>(reassociation) == 0 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  186:         "Expected symbol-less expressions");
    #####:  187:  SmallVector<AffineMap, 4> maps;
branch  0 never executed
branch  1 never executed
    #####:  188:  maps.reserve(reassociation.size());
branch  0 never executed
branch  1 never executed
    #####:  189:  for (const auto &exprs : reassociation) {
branch  0 never executed
branch  1 never executed
    #####:  190:    assert(!exprs.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  191:    maps.push_back(AffineMap::get(maxDim + 1, 0, exprs, exprs[0].getContext()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  192:  }
    #####:  193:  return maps;
        -:  194:}
        -:  195:
function _ZN4mlir20isReassociationValidEN4llvm8ArrayRefINS_9AffineMapEEEPi called 0 returned 0% blocks executed 0%
    #####:  196:bool mlir::isReassociationValid(ArrayRef<AffineMap> reassociation,
        -:  197:                                int *invalidIndex) {
    #####:  198:  if (reassociation.empty())
branch  0 never executed
branch  1 never executed
        -:  199:    return true;
    #####:  200:  unsigned nDims = reassociation[0].getNumDims();
call    0 never executed
    #####:  201:  unsigned nextExpectedDim = 0;
    #####:  202:  for (const auto &it : llvm::enumerate(reassociation)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  203:    auto m = it.value();
call    0 never executed
    #####:  204:    if (m.getNumDims() != nDims || m.getNumSymbols() != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  205:      if (invalidIndex)
branch  0 never executed
branch  1 never executed
    #####:  206:        *invalidIndex = it.index();
    #####:  207:      return false;
        -:  208:    }
    #####:  209:    for (auto e : m.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  210:      auto d = e.dyn_cast<AffineDimExpr>();
call    0 never executed
    #####:  211:      if (!d || d.getPosition() != nextExpectedDim++) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  212:        if (invalidIndex)
branch  0 never executed
branch  1 never executed
    #####:  213:          *invalidIndex = it.index();
    #####:  214:        return false;
        -:  215:      }
        -:  216:    }
        -:  217:  }
    #####:  218:  if (nextExpectedDim != nDims) {
branch  0 never executed
branch  1 never executed
    #####:  219:    if (invalidIndex)
branch  0 never executed
branch  1 never executed
    #####:  220:      *invalidIndex = reassociation.size() - 1;
    #####:  221:    return false;
        -:  222:  }
        -:  223:  return true;
        -:  224:}
        -:  225:
function _ZN4mlir30reshapeLikeShapesAreCompatibleEN4llvm12function_refIFNS_13LogicalResultERKNS0_5TwineEEEENS0_8ArrayRefIlEES9_NS8_INS0_11SmallVectorIlLj2EEEEEb called 0 returned 0% blocks executed 0%
    #####:  226:LogicalResult mlir::reshapeLikeShapesAreCompatible(
        -:  227:    function_ref<LogicalResult(const Twine &)> emitError,
        -:  228:    ArrayRef<int64_t> collapsedShape, ArrayRef<int64_t> expandedShape,
        -:  229:    ArrayRef<ReassociationIndices> reassociationMaps, bool isExpandingReshape) {
    #####:  230:  unsigned expandedDimStart = 0;
    #####:  231:  for (const auto &map : llvm::enumerate(reassociationMaps)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  232:    Optional<int64_t> dynamicShape;
    #####:  233:    int64_t linearizedStaticShape = 1;
    #####:  234:    for (const auto &dim : llvm::enumerate(
    #####:  235:             expandedShape.slice(expandedDimStart, map.value().size()))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  236:      if (ShapedType::isDynamic(dim.value())) {
branch  0 never executed
branch  1 never executed
    #####:  237:        if (isExpandingReshape && dynamicShape) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  238:          return emitError("invalid to have a single dimension (" +
    #####:  239:                           Twine(map.index()) +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  240:                           ") expanded into multiple dynamic dims (" +
call    0 never executed
call    1 never executed
    #####:  241:                           Twine(expandedDimStart + dynamicShape.value()) +
call    0 never executed
call    1 never executed
    #####:  242:                           "," + Twine(expandedDimStart + dim.index()) + ")");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  243:        }
    #####:  244:        dynamicShape = dim.index();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  245:      } else {
    #####:  246:        linearizedStaticShape *= dim.value();
        -:  247:      }
        -:  248:    }
    #####:  249:    if (dynamicShape) {
branch  0 never executed
branch  1 never executed
    #####:  250:      if (!ShapedType::isDynamic(collapsedShape[map.index()])) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  251:        return emitError(
    #####:  252:            "expected dimension " + Twine(map.index()) +
call    0 never executed
call    1 never executed
call    2 never executed
        -:  253:            " of collapsed type to be dynamic since one or more of the "
    #####:  254:            "corresponding dimensions in the expanded type is dynamic");
call    0 never executed
call    1 never executed
        -:  255:      }
        -:  256:    } else {
    #####:  257:      if (collapsedShape[map.index()] != linearizedStaticShape) {
branch  0 never executed
branch  1 never executed
    #####:  258:        return emitError("expected dimension " + Twine(map.index()) +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  259:                         " of collapsed type to be static value of " +
call    0 never executed
    #####:  260:                         Twine(linearizedStaticShape));
call    0 never executed
call    1 never executed
        -:  261:      }
        -:  262:    }
    #####:  263:    expandedDimStart += map.value().size();
call    0 never executed
        -:  264:  }
    #####:  265:  return success();
        -:  266:}
        -:  267:
function _ZN4mlir20hasNonIdentityLayoutENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  268:bool mlir::hasNonIdentityLayout(Type type) {
    #####:  269:  if (auto memrefType = type.dyn_cast<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  270:    return !memrefType.getLayout().isIdentity();
call    0 never executed
call    1 never executed
    #####:  271:  return false;
        -:  272:}
        -:  273:
        -:  274:llvm::SmallBitVector
function _ZN4mlir19getSlicedDimensionsEN4llvm8ArrayRefINS_12OpFoldResultEEENS1_INS_5RangeEEE called 0 returned 0% blocks executed 0%
    #####:  275:mlir::getSlicedDimensions(ArrayRef<OpFoldResult> sliceInputShape,
        -:  276:                          ArrayRef<Range> sliceParams) {
    #####:  277:  assert(sliceParams.size() == sliceInputShape.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  278:         "only supports non rank-reducing case");
    #####:  279:  llvm::SmallBitVector mask(sliceInputShape.size());
call    0 never executed
    #####:  280:  unsigned idx = 0;
    #####:  281:  for (const auto &[offset, size, stride] : sliceParams) {
branch  0 never executed
branch  1 never executed
    #####:  282:    Optional<int64_t> offsetConst = getConstantIntValue(offset);
call    0 never executed
    #####:  283:    Optional<int64_t> strideConst = getConstantIntValue(stride);
call    0 never executed
    #####:  284:    mask[idx] = !isEqualConstantIntOrValue(size, sliceInputShape[idx]) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  285:                (!strideConst || *strideConst != 1) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  286:                (!offsetConst || *offsetConst != 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  287:    idx++;
        -:  288:  }
    #####:  289:  return mask;
        -:  290:}
        -:  291:
function _ZN4mlir23getLinearizedDimensionsEN4llvm8ArrayRefINS0_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  292:llvm::SmallBitVector mlir::getLinearizedDimensions(
        -:  293:    ArrayRef<ReassociationIndices> reassociationIndices) {
    #####:  294:  llvm::SmallBitVector result(reassociationIndices.size());
call    0 never executed
    #####:  295:  for (const auto &it : llvm::enumerate(reassociationIndices))
branch  0 never executed
branch  1 never executed
    #####:  296:    result[it.index()] = it.value().size() > 1;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  297:  return result;
        -:  298:}
        -:  299:
function _ZN4mlir23SliceFromCollapseHelper21getExtractSliceParamsEPNS_11MLIRContextEN4llvm8ArrayRefINS_10ValueRangeEEE called 0 returned 0% blocks executed 0%
    #####:  300:SmallVector<Range> SliceFromCollapseHelper::getExtractSliceParams(
        -:  301:    MLIRContext *ctx, ArrayRef<ValueRange> multiIndices) {
    #####:  302:  unsigned loopIdx = 0;
    #####:  303:  auto oneAttr = IntegerAttr::get(IndexType::get(ctx), 1);
call    0 never executed
call    1 never executed
    #####:  304:  auto zeroAttr = IntegerAttr::get(IndexType::get(ctx), 0);
call    0 never executed
call    1 never executed
    #####:  305:  SmallVector<Range> offsetsSizesAndStrides;
branch  0 never executed
branch  1 never executed
    #####:  306:  offsetsSizesAndStrides.reserve(collapseShapeInputShape.size());
branch  0 never executed
branch  1 never executed
    #####:  307:  for (const auto &it : llvm::enumerate(reassociationIndices)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  308:    // Case 1: Linearized dimensions that have also been sliced. These
        -:  309:    // are size of 1 because we are iterating over these dimensions. The
        -:  310:    // offsets are exactly the de-linearized multi-indices.
    #####:  311:    if (slicedDimensions[it.index()] && linearizedDimensions[it.index()]) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  312:      llvm::append_range(
call    0 never executed
        -:  313:          offsetsSizesAndStrides,
function _ZZN4mlir23SliceFromCollapseHelper21getExtractSliceParamsEPNS_11MLIRContextEN4llvm8ArrayRefINS_10ValueRangeEEEENKUlNS_5ValueEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  314:          llvm::map_range(multiIndices[loopIdx++], [&](Value v) -> Range {
    #####:  315:            return Range{getAsOpFoldResult(v), oneAttr, oneAttr};
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  316:          }));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  317:      continue;
        -:  318:    }
        -:  319:
        -:  320:    // Case 2: One or possibly multiple combined input dimensions, but we
        -:  321:    // have proven that these are not sliced. In this case we just take
        -:  322:    // the full extent of each dimension in the reassociation list.
    #####:  323:    if (linearizedDimensions[it.index()]) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  324:      llvm::append_range(
        -:  325:          offsetsSizesAndStrides,
function _ZZN4mlir23SliceFromCollapseHelper21getExtractSliceParamsEPNS_11MLIRContextEN4llvm8ArrayRefINS_10ValueRangeEEEENKUllE0_clEl called 0 returned 0% blocks executed 0%
    #####:  326:          llvm::map_range(it.value(), [&](int64_t idx) -> Range {
call    0 never executed
    #####:  327:            return {zeroAttr, collapseShapeInputShape[idx], oneAttr};
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  328:          }));
call    0 never executed
    #####:  329:      continue;
        -:  330:    }
        -:  331:
        -:  332:    // Case 3: A single index, but it may be sliced.
    #####:  333:    offsetsSizesAndStrides.push_back(sliceParams[it.index()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  334:  }
    #####:  335:  return offsetsSizesAndStrides;
        -:  336:}
        -:  337:
        -:  338:SmallVector<Range>
function _ZN4mlir23SliceFromCollapseHelper20getInsertSliceParamsEPNS_11MLIRContextENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  339:SliceFromCollapseHelper::getInsertSliceParams(MLIRContext *ctx,
        -:  340:                                              ValueRange tileIndices) {
    #####:  341:  auto one = IntegerAttr::get(IndexType::get(ctx), 1);
call    0 never executed
call    1 never executed
    #####:  342:  auto zero = IntegerAttr::get(IndexType::get(ctx), 0);
call    0 never executed
call    1 never executed
    #####:  343:  SmallVector<Range> insertParams;
branch  0 never executed
branch  1 never executed
    #####:  344:  insertParams.reserve(linearizedDimensions.size());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  345:  unsigned loopIdx = 0;
    #####:  346:  for (unsigned i = 0; i < linearizedDimensions.size(); i++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  347:    if (linearizedDimensions[i] && slicedDimensions[i]) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  348:      insertParams.push_back(Range{tileIndices[loopIdx++], one, one});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  349:      continue;
        -:  350:    }
    #####:  351:    insertParams.push_back(Range{zero, sliceParams[i].size, one});
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  352:  }
    #####:  353:  return insertParams;
        -:  354:}
        -:  355:
        -:  356:/// Returns the index of the only non-unit dimension among `indices` of `shape`,
        -:  357:/// if such a dimension exists and `indices` has more than one element.
        -:  358:/// Otherwise, return none.
function _ZL19getUniqueNonUnitDimN4llvm8ArrayRefIlEES1_ called 0 returned 0% blocks executed 0%
    #####:  359:static Optional<int64_t> getUniqueNonUnitDim(ArrayRef<int64_t> indices,
        -:  360:                                             ArrayRef<int64_t> shape) {
        -:  361:  // Return false if more than one of the dimensions in this group are not 1.
    #####:  362:  Optional<int64_t> dimIndex = None;
    #####:  363:  if (indices.size() < 2)
branch  0 never executed
branch  1 never executed
    #####:  364:    return None;
    #####:  365:  for (int64_t idx : indices) {
branch  0 never executed
branch  1 never executed
    #####:  366:    if (shape[idx] != 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  367:      if (dimIndex != None)
branch  0 never executed
branch  1 never executed
    #####:  368:        return None;
    #####:  369:      dimIndex = idx;
        -:  370:    }
        -:  371:  }
    #####:  372:  return dimIndex;
        -:  373:}
        -:  374:
        -:  375:// For each segment in the reassociation indices, check whether we can
        -:  376:// simplify that segment with a rank-reducing extract slice. We can do this if
        -:  377:// all but (exactly) one of the corresponding source dims is 1.
function _ZL31getCollapseShapeTrivialSegmentsN4mlir16RankedTensorTypeEN4llvm8ArrayRefINS1_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  378:static SmallVector<Optional<int64_t>> getCollapseShapeTrivialSegments(
        -:  379:    RankedTensorType sourceType,
        -:  380:    ArrayRef<ReassociationIndices> reassociationIndices) {
    #####:  381:  SmallVector<Optional<int64_t>> trivialSegments;
    #####:  382:  for (const auto &indices : reassociationIndices)
branch  0 never executed
branch  1 never executed
    #####:  383:    trivialSegments.push_back(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  384:        getUniqueNonUnitDim(indices, sourceType.getShape()));
    #####:  385:  return trivialSegments;
        -:  386:}
        -:  387:
        -:  388:/// Returns true if any of the segments of the reassociation indices for a
        -:  389:/// collapsing reshape can be simplified using a rank-reducing slice.
        -:  390:static FailureOr<SmallVector<Optional<int64_t>>>
function _ZL47canCollapseShapeBeSimplifiedByRankReducingSliceN4mlir16RankedTensorTypeEN4llvm8ArrayRefINS1_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  391:canCollapseShapeBeSimplifiedByRankReducingSlice(
        -:  392:    RankedTensorType sourceType,
        -:  393:    ArrayRef<ReassociationIndices> reassociationIndices) {
    #####:  394:  SmallVector<Optional<int64_t>> trivialSegments =
    #####:  395:      getCollapseShapeTrivialSegments(sourceType, reassociationIndices);
call    0 never executed
    #####:  396:  if (!llvm::any_of(trivialSegments, [](const Optional<int64_t> &idx) {
branch  0 never executed
branch  1 never executed
        -:  397:        return idx.has_value();
        -:  398:      }))
    #####:  399:    return failure();
    #####:  400:  return trivialSegments;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  401:}
        -:  402:
        -:  403:FailureOr<CollapseShapeRankReducingSliceSimplificationInfo>
function _ZN4mlir49getSimplifyCollapseShapeWithRankReducingSliceInfoENS_16RankedTensorTypeEN4llvm8ArrayRefINS1_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####:  404:mlir::getSimplifyCollapseShapeWithRankReducingSliceInfo(
        -:  405:    RankedTensorType sourceType,
        -:  406:    ArrayRef<ReassociationIndices> reassociationIndices) {
    #####:  407:  FailureOr<SmallVector<Optional<int64_t>>> trivialSegments =
        -:  408:      canCollapseShapeBeSimplifiedByRankReducingSlice(sourceType,
    #####:  409:                                                      reassociationIndices);
call    0 never executed
    #####:  410:  if (failed(trivialSegments))
branch  0 never executed
branch  1 never executed
    #####:  411:    return failure();
        -:  412:
        -:  413:  // Create the expected result shape of the rank-reducing slice.
    #####:  414:  SmallVector<int64_t> sliceShape;
branch  0 never executed
branch  1 never executed
    #####:  415:  for (const auto &[nonUnitDim, indices] :
    #####:  416:       llvm::zip(*trivialSegments, reassociationIndices)) {
branch  0 never executed
branch  1 never executed
    #####:  417:    if (nonUnitDim) {
branch  0 never executed
branch  1 never executed
    #####:  418:      sliceShape.push_back(sourceType.getDimSize(nonUnitDim.value()));
call    0 never executed
call    1 never executed
    #####:  419:      continue;
        -:  420:    }
    #####:  421:    llvm::append_range(sliceShape, llvm::map_range(indices, [&](int64_t idx) {
    #####:  422:                         return sourceType.getDimSize(idx);
call    0 never executed
call    1 never executed
    #####:  423:                       }));
call    0 never executed
        -:  424:  }
    #####:  425:  auto sliceType =
    #####:  426:      RankedTensorType::get(sliceShape, sourceType.getElementType());
call    0 never executed
call    1 never executed
        -:  427:
        -:  428:  // If the rank-reducing slice simplified every segment, then we are done.
    #####:  429:  if (sliceShape.size() == reassociationIndices.size())
branch  0 never executed
branch  1 never executed
    #####:  430:    return CollapseShapeRankReducingSliceSimplificationInfo{sliceType, None};
        -:  431:
        -:  432:  // Otherwise, we need to create a new collapse_shape op for the segments that
        -:  433:  // weren't covered by the slice. By design, the new reassociation indices has
        -:  434:  // the same number of groups as the old reassociation indices.
    #####:  435:  SmallVector<ReassociationIndices> newReassociationIndices;
    #####:  436:  SmallVector<int64_t, 2> reassociation;
call    0 never executed
    #####:  437:  int64_t groupIdx = 0;
    #####:  438:  for (int64_t dimIdx = 0; dimIdx < sliceType.getRank(); dimIdx++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  439:    reassociation.push_back(dimIdx);
call    0 never executed
    #####:  440:    if ((*trivialSegments)[groupIdx] ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  441:        reassociation.size() == reassociationIndices[groupIdx].size()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  442:      newReassociationIndices.push_back(reassociation);
call    0 never executed
    #####:  443:      reassociation.clear();
    #####:  444:      groupIdx++;
        -:  445:    }
        -:  446:  }
        -:  447:
    #####:  448:  return CollapseShapeRankReducingSliceSimplificationInfo{
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  449:      sliceType, newReassociationIndices};
branch  0 never executed
branch  1 never executed
        -:  450:}
