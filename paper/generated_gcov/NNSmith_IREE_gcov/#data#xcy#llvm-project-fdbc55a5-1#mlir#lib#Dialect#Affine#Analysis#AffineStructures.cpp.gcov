        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/Affine/Analysis/AffineStructures.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/AffineStructures.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Analysis/CMakeFiles/obj.MLIRAffineAnalysis.dir/AffineStructures.cpp.gcda
        -:    0:Runs:325563
        -:    1://===- AffineStructures.cpp - MLIR Affine Structures Class-----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Structures for affine/polyhedral analysis of affine dialect ops.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Affine/Analysis/AffineStructures.h"
        -:   14:#include "mlir/Analysis/Presburger/LinearTransform.h"
        -:   15:#include "mlir/Analysis/Presburger/Simplex.h"
        -:   16:#include "mlir/Analysis/Presburger/Utils.h"
        -:   17:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   18:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   19:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   20:#include "mlir/IR/AffineExprVisitor.h"
        -:   21:#include "mlir/IR/IntegerSet.h"
        -:   22:#include "mlir/Support/LLVM.h"
        -:   23:#include "mlir/Support/MathExtras.h"
        -:   24:#include "llvm/ADT/STLExtras.h"
        -:   25:#include "llvm/ADT/SmallPtrSet.h"
        -:   26:#include "llvm/ADT/SmallVector.h"
        -:   27:#include "llvm/Support/Debug.h"
        -:   28:#include "llvm/Support/raw_ostream.h"
        -:   29:
        -:   30:#define DEBUG_TYPE "affine-structures"
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace presburger;
        -:   34:
        -:   35:namespace {
        -:   36:
        -:   37:// See comments for SimpleAffineExprFlattener.
        -:   38:// An AffineExprFlattener extends a SimpleAffineExprFlattener by recording
        -:   39:// constraint information associated with mod's, floordiv's, and ceildiv's
        -:   40:// in FlatAffineValueConstraints 'localVarCst'.
    #####:   41:struct AffineExprFlattener : public SimpleAffineExprFlattener {
call    0 never executed
        -:   42:public:
        -:   43:  // Constraints connecting newly introduced local variables (for mod's and
        -:   44:  // div's) to existing (dimensional and symbolic) ones. These are always
        -:   45:  // inequalities.
        -:   46:  IntegerPolyhedron localVarCst;
        -:   47:
function _ZN12_GLOBAL__N_119AffineExprFlattenerC2Ejj called 0 returned 0% blocks executed 0%
    #####:   48:  AffineExprFlattener(unsigned nDims, unsigned nSymbols)
    #####:   49:      : SimpleAffineExprFlattener(nDims, nSymbols),
    #####:   50:        localVarCst(PresburgerSpace::getSetSpace(nDims, nSymbols)) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   51:
        -:   52:private:
        -:   53:  // Add a local variable (needed to flatten a mod, floordiv, ceildiv expr).
        -:   54:  // The local variable added is always a floordiv of a pure add/mul affine
        -:   55:  // function of other variables, coefficients of which are specified in
        -:   56:  // `dividend' and with respect to the positive constant `divisor'. localExpr
        -:   57:  // is the simplified tree expression (AffineExpr) corresponding to the
        -:   58:  // quantifier.
function _ZN12_GLOBAL__N_119AffineExprFlattener18addLocalFloorDivIdEN4llvm8ArrayRefIlEElN4mlir10AffineExprE called 0 returned 0% blocks executed 0%
    #####:   59:  void addLocalFloorDivId(ArrayRef<int64_t> dividend, int64_t divisor,
        -:   60:                          AffineExpr localExpr) override {
    #####:   61:    SimpleAffineExprFlattener::addLocalFloorDivId(dividend, divisor, localExpr);
call    0 never executed
        -:   62:    // Update localVarCst.
    #####:   63:    localVarCst.addLocalFloorDiv(dividend, divisor);
call    0 never executed
    #####:   64:  }
        -:   65:};
        -:   66:
        -:   67:} // namespace
        -:   68:
        -:   69:// Flattens the expressions in map. Returns failure if 'expr' was unable to be
        -:   70:// flattened (i.e., semi-affine expressions not handled yet).
        -:   71:static LogicalResult
function _ZL23getFlattenedAffineExprsN4llvm8ArrayRefIN4mlir10AffineExprEEEjjPSt6vectorINS_11SmallVectorIlLj8EEESaIS6_EEPNS1_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:   72:getFlattenedAffineExprs(ArrayRef<AffineExpr> exprs, unsigned numDims,
        -:   73:                        unsigned numSymbols,
        -:   74:                        std::vector<SmallVector<int64_t, 8>> *flattenedExprs,
        -:   75:                        FlatAffineValueConstraints *localVarCst) {
    #####:   76:  if (exprs.empty()) {
branch  0 never executed
branch  1 never executed
    #####:   77:    localVarCst->reset(numDims, numSymbols);
    #####:   78:    return success();
        -:   79:  }
        -:   80:
    #####:   81:  AffineExprFlattener flattener(numDims, numSymbols);
call    0 never executed
        -:   82:  // Use the same flattener to simplify each expression successively. This way
        -:   83:  // local variables / expressions are shared.
    #####:   84:  for (auto expr : exprs) {
branch  0 never executed
branch  1 never executed
    #####:   85:    if (!expr.isPureAffine())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   86:      return failure();
        -:   87:
    #####:   88:    flattener.walkPostOrder(expr);
call    0 never executed
        -:   89:  }
        -:   90:
    #####:   91:  assert(flattener.operandExprStack.size() == exprs.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   92:  flattenedExprs->clear();
call    0 never executed
    #####:   93:  flattenedExprs->assign(flattener.operandExprStack.begin(),
call    0 never executed
        -:   94:                         flattener.operandExprStack.end());
        -:   95:
    #####:   96:  if (localVarCst)
branch  0 never executed
branch  1 never executed
    #####:   97:    localVarCst->clearAndCopyFrom(flattener.localVarCst);
call    0 never executed
        -:   98:
    #####:   99:  return success();
call    0 never executed
        -:  100:}
        -:  101:
        -:  102:// Flattens 'expr' into 'flattenedExpr'. Returns failure if 'expr' was unable to
        -:  103:// be flattened (semi-affine expressions not handled yet).
        -:  104:LogicalResult
function _ZN4mlir22getFlattenedAffineExprENS_10AffineExprEjjPN4llvm15SmallVectorImplIlEEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  105:mlir::getFlattenedAffineExpr(AffineExpr expr, unsigned numDims,
        -:  106:                             unsigned numSymbols,
        -:  107:                             SmallVectorImpl<int64_t> *flattenedExpr,
        -:  108:                             FlatAffineValueConstraints *localVarCst) {
    #####:  109:  std::vector<SmallVector<int64_t, 8>> flattenedExprs;
call    0 never executed
    #####:  110:  LogicalResult ret = ::getFlattenedAffineExprs({expr}, numDims, numSymbols,
    #####:  111:                                                &flattenedExprs, localVarCst);
call    0 never executed
    #####:  112:  *flattenedExpr = flattenedExprs[0];
call    0 never executed
    #####:  113:  return ret;
call    0 never executed
        -:  114:}
        -:  115:
        -:  116:/// Flattens the expressions in map. Returns failure if 'expr' was unable to be
        -:  117:/// flattened (i.e., semi-affine expressions not handled yet).
function _ZN4mlir23getFlattenedAffineExprsENS_9AffineMapEPSt6vectorIN4llvm11SmallVectorIlLj8EEESaIS4_EEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  118:LogicalResult mlir::getFlattenedAffineExprs(
        -:  119:    AffineMap map, std::vector<SmallVector<int64_t, 8>> *flattenedExprs,
        -:  120:    FlatAffineValueConstraints *localVarCst) {
    #####:  121:  if (map.getNumResults() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  122:    localVarCst->reset(map.getNumDims(), map.getNumSymbols());
call    0 never executed
call    1 never executed
    #####:  123:    return success();
        -:  124:  }
    #####:  125:  return ::getFlattenedAffineExprs(map.getResults(), map.getNumDims(),
        -:  126:                                   map.getNumSymbols(), flattenedExprs,
    #####:  127:                                   localVarCst);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  128:}
        -:  129:
function _ZN4mlir23getFlattenedAffineExprsENS_10IntegerSetEPSt6vectorIN4llvm11SmallVectorIlLj8EEESaIS4_EEPNS_26FlatAffineValueConstraintsE called 0 returned 0% blocks executed 0%
    #####:  130:LogicalResult mlir::getFlattenedAffineExprs(
        -:  131:    IntegerSet set, std::vector<SmallVector<int64_t, 8>> *flattenedExprs,
        -:  132:    FlatAffineValueConstraints *localVarCst) {
    #####:  133:  if (set.getNumConstraints() == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  134:    localVarCst->reset(set.getNumDims(), set.getNumSymbols());
call    0 never executed
call    1 never executed
    #####:  135:    return success();
        -:  136:  }
    #####:  137:  return ::getFlattenedAffineExprs(set.getConstraints(), set.getNumDims(),
        -:  138:                                   set.getNumSymbols(), flattenedExprs,
    #####:  139:                                   localVarCst);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  140:}
        -:  141:
        -:  142://===----------------------------------------------------------------------===//
        -:  143:// FlatAffineConstraints / FlatAffineValueConstraints.
        -:  144://===----------------------------------------------------------------------===//
        -:  145:
        -:  146:std::unique_ptr<FlatAffineValueConstraints>
function _ZNK4mlir26FlatAffineValueConstraints5cloneEv called 0 returned 0% blocks executed 0%
    #####:  147:FlatAffineValueConstraints::clone() const {
    #####:  148:  return std::make_unique<FlatAffineValueConstraints>(*this);
call    0 never executed
        -:  149:}
        -:  150:
        -:  151:// Construct from an IntegerSet.
function _ZN4mlir26FlatAffineValueConstraintsC2ENS_10IntegerSetE called 0 returned 0% blocks executed 0%
    #####:  152:FlatAffineValueConstraints::FlatAffineValueConstraints(IntegerSet set)
        -:  153:    : IntegerPolyhedron(set.getNumInequalities(), set.getNumEqualities(),
    #####:  154:                        set.getNumDims() + set.getNumSymbols() + 1,
call    0 never executed
call    1 never executed
    #####:  155:                        PresburgerSpace::getSetSpace(set.getNumDims(),
call    0 never executed
call    1 never executed
        -:  156:                                                     set.getNumSymbols(),
    #####:  157:                                                     /*numLocals=*/0)) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  158:
        -:  159:  // Resize values.
    #####:  160:  values.resize(getNumDimAndSymbolVars(), None);
call    0 never executed
        -:  161:
        -:  162:  // Flatten expressions and add them to the constraint system.
    #####:  163:  std::vector<SmallVector<int64_t, 8>> flatExprs;
call    0 never executed
call    1 never executed
    #####:  164:  FlatAffineValueConstraints localVarCst;
call    0 never executed
call    1 never executed
    #####:  165:  if (failed(getFlattenedAffineExprs(set, &flatExprs, &localVarCst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  166:    assert(false && "flattening unimplemented for semi-affine integer sets");
call    0 never executed
        -:  167:    return;
        -:  168:  }
    #####:  169:  assert(flatExprs.size() == set.getNumConstraints());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  170:  insertVar(VarKind::Local, getNumVarKind(VarKind::Local),
call    0 never executed
        -:  171:            /*num=*/localVarCst.getNumLocalVars());
        -:  172:
    #####:  173:  for (unsigned i = 0, e = flatExprs.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  174:    const auto &flatExpr = flatExprs[i];
branch  0 never executed
branch  1 never executed
    #####:  175:    assert(flatExpr.size() == getNumCols());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  176:    if (set.getEqFlags()[i]) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  177:      addEquality(flatExpr);
call    0 never executed
        -:  178:    } else {
    #####:  179:      addInequality(flatExpr);
call    0 never executed
        -:  180:    }
        -:  181:  }
        -:  182:  // Add the other constraints involving local vars from flattening.
    #####:  183:  append(localVarCst);
call    0 never executed
        -:  184:}
        -:  185:
        -:  186:// Construct a hyperrectangular constraint set from ValueRanges that represent
        -:  187:// induction variables, lower and upper bounds. `ivs`, `lbs` and `ubs` are
        -:  188:// expected to match one to one. The order of variables and constraints is:
        -:  189://
        -:  190:// ivs | lbs | ubs | eq/ineq
        -:  191:// ----+-----+-----+---------
        -:  192://   1   -1     0      >= 0
        -:  193:// ----+-----+-----+---------
        -:  194://  -1    0     1      >= 0
        -:  195://
        -:  196:// All dimensions as set as VarKind::SetDim.
        -:  197:FlatAffineValueConstraints
function _ZN4mlir26FlatAffineValueConstraints19getHyperrectangularENS_10ValueRangeES1_S1_ called 0 returned 0% blocks executed 0%
    #####:  198:FlatAffineValueConstraints::getHyperrectangular(ValueRange ivs, ValueRange lbs,
        -:  199:                                                ValueRange ubs) {
    #####:  200:  FlatAffineValueConstraints res;
call    0 never executed
    #####:  201:  unsigned nIvs = ivs.size();
branch  0 never executed
branch  1 never executed
    #####:  202:  assert(nIvs == lbs.size() && "expected as many lower bounds as ivs");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  203:  assert(nIvs == ubs.size() && "expected as many upper bounds as ivs");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  204:
    #####:  205:  if (nIvs == 0)
branch  0 never executed
branch  1 never executed
        -:  206:    return res;
        -:  207:
    #####:  208:  res.appendDimVar(ivs);
    #####:  209:  unsigned lbsStart = res.appendDimVar(lbs);
    #####:  210:  unsigned ubsStart = res.appendDimVar(ubs);
        -:  211:
    #####:  212:  MLIRContext *ctx = ivs.front().getContext();
call    0 never executed
call    1 never executed
    #####:  213:  for (int ivIdx = 0, e = nIvs; ivIdx < e; ++ivIdx) {
branch  0 never executed
branch  1 never executed
        -:  214:    // iv - lb >= 0
    #####:  215:    AffineMap lb = AffineMap::get(/*dimCount=*/3 * nIvs, /*symbolCount=*/0,
    #####:  216:                                  getAffineDimExpr(lbsStart + ivIdx, ctx));
call    0 never executed
call    1 never executed
    #####:  217:    if (failed(res.addBound(BoundType::LB, ivIdx, lb)))
branch  0 never executed
branch  1 never executed
    #####:  218:      llvm_unreachable("Unexpected FlatAffineValueConstraints creation error");
call    0 never executed
        -:  219:    // -iv + ub >= 0
    #####:  220:    AffineMap ub = AffineMap::get(/*dimCount=*/3 * nIvs, /*symbolCount=*/0,
    #####:  221:                                  getAffineDimExpr(ubsStart + ivIdx, ctx));
call    0 never executed
call    1 never executed
    #####:  222:    if (failed(res.addBound(BoundType::UB, ivIdx, ub)))
branch  0 never executed
branch  1 never executed
    #####:  223:      llvm_unreachable("Unexpected FlatAffineValueConstraints creation error");
call    0 never executed
        -:  224:  }
        -:  225:  return res;
        -:  226:}
        -:  227:
function _ZN4mlir26FlatAffineValueConstraints5resetEjjjjjj called 0 returned 0% blocks executed 0%
    #####:  228:void FlatAffineValueConstraints::reset(unsigned numReservedInequalities,
        -:  229:                                       unsigned numReservedEqualities,
        -:  230:                                       unsigned newNumReservedCols,
        -:  231:                                       unsigned newNumDims,
        -:  232:                                       unsigned newNumSymbols,
        -:  233:                                       unsigned newNumLocals) {
    #####:  234:  assert(newNumReservedCols >= newNumDims + newNumSymbols + newNumLocals + 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  235:         "minimum 1 column");
    #####:  236:  *this = FlatAffineValueConstraints(numReservedInequalities,
call    0 never executed
call    1 never executed
        -:  237:                                     numReservedEqualities, newNumReservedCols,
    #####:  238:                                     newNumDims, newNumSymbols, newNumLocals);
call    0 never executed
    #####:  239:}
        -:  240:
function _ZN4mlir26FlatAffineValueConstraints5resetEjjj called 0 returned 0% blocks executed 0%
    #####:  241:void FlatAffineValueConstraints::reset(unsigned newNumDims,
        -:  242:                                       unsigned newNumSymbols,
        -:  243:                                       unsigned newNumLocals) {
    #####:  244:  reset(/*numReservedInequalities=*/0, /*numReservedEqualities=*/0,
    #####:  245:        /*numReservedCols=*/newNumDims + newNumSymbols + newNumLocals + 1,
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  246:        newNumDims, newNumSymbols, newNumLocals);
    #####:  247:}
        -:  248:
function _ZN4mlir26FlatAffineValueConstraints5resetEjjjjjjN4llvm8ArrayRefINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  249:void FlatAffineValueConstraints::reset(
        -:  250:    unsigned numReservedInequalities, unsigned numReservedEqualities,
        -:  251:    unsigned newNumReservedCols, unsigned newNumDims, unsigned newNumSymbols,
        -:  252:    unsigned newNumLocals, ArrayRef<Value> valArgs) {
    #####:  253:  assert(newNumReservedCols >= newNumDims + newNumSymbols + newNumLocals + 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  254:         "minimum 1 column");
    #####:  255:  SmallVector<Optional<Value>, 8> newVals;
branch  0 never executed
branch  1 never executed
    #####:  256:  if (!valArgs.empty())
branch  0 never executed
branch  1 never executed
    #####:  257:    newVals.assign(valArgs.begin(), valArgs.end());
call    0 never executed
        -:  258:
    #####:  259:  *this = FlatAffineValueConstraints(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  260:      numReservedInequalities, numReservedEqualities, newNumReservedCols,
    #####:  261:      newNumDims, newNumSymbols, newNumLocals, newVals);
call    0 never executed
    #####:  262:}
        -:  263:
function _ZN4mlir26FlatAffineValueConstraints5resetEjjjN4llvm8ArrayRefINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  264:void FlatAffineValueConstraints::reset(unsigned newNumDims,
        -:  265:                                       unsigned newNumSymbols,
        -:  266:                                       unsigned newNumLocals,
        -:  267:                                       ArrayRef<Value> valArgs) {
    #####:  268:  reset(0, 0, newNumDims + newNumSymbols + newNumLocals + 1, newNumDims,
call    0 never executed
        -:  269:        newNumSymbols, newNumLocals, valArgs);
    #####:  270:}
        -:  271:
function _ZN4mlir26FlatAffineValueConstraints12appendDimVarENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  272:unsigned FlatAffineValueConstraints::appendDimVar(ValueRange vals) {
    #####:  273:  unsigned pos = getNumDimVars();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  274:  return insertVar(VarKind::SetDim, pos, vals);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  275:}
        -:  276:
function _ZN4mlir26FlatAffineValueConstraints15appendSymbolVarENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  277:unsigned FlatAffineValueConstraints::appendSymbolVar(ValueRange vals) {
    #####:  278:  unsigned pos = getNumSymbolVars();
call    0 never executed
    #####:  279:  return insertVar(VarKind::Symbol, pos, vals);
call    0 never executed
call    1 never executed
        -:  280:}
        -:  281:
function _ZN4mlir26FlatAffineValueConstraints12insertDimVarEjNS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  282:unsigned FlatAffineValueConstraints::insertDimVar(unsigned pos,
        -:  283:                                                  ValueRange vals) {
    #####:  284:  return insertVar(VarKind::SetDim, pos, vals);
call    0 never executed
        -:  285:}
        -:  286:
function _ZN4mlir26FlatAffineValueConstraints15insertSymbolVarEjNS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  287:unsigned FlatAffineValueConstraints::insertSymbolVar(unsigned pos,
        -:  288:                                                     ValueRange vals) {
    #####:  289:  return insertVar(VarKind::Symbol, pos, vals);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  290:}
        -:  291:
function _ZN4mlir26FlatAffineValueConstraints9insertVarENS_10presburger7VarKindEjj called 0 returned 0% blocks executed 0%
    #####:  292:unsigned FlatAffineValueConstraints::insertVar(VarKind kind, unsigned pos,
        -:  293:                                               unsigned num) {
    #####:  294:  unsigned absolutePos = IntegerPolyhedron::insertVar(kind, pos, num);
call    0 never executed
call    1 never executed
        -:  295:
    #####:  296:  if (kind != VarKind::Local) {
branch  0 never executed
branch  1 never executed
    #####:  297:    values.insert(values.begin() + absolutePos, num, None);
call    0 never executed
    #####:  298:    assert(values.size() == getNumDimAndSymbolVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  299:  }
        -:  300:
    #####:  301:  return absolutePos;
        -:  302:}
        -:  303:
function _ZN4mlir26FlatAffineValueConstraints9insertVarENS_10presburger7VarKindEjNS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  304:unsigned FlatAffineValueConstraints::insertVar(VarKind kind, unsigned pos,
        -:  305:                                               ValueRange vals) {
    #####:  306:  assert(!vals.empty() && "expected ValueRange with Values.");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  307:  assert(kind != VarKind::Local &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  308:         "values cannot be attached to local variables.");
    #####:  309:  unsigned num = vals.size();
call    0 never executed
    #####:  310:  unsigned absolutePos = IntegerPolyhedron::insertVar(kind, pos, num);
        -:  311:
        -:  312:  // If a Value is provided, insert it; otherwise use None.
    #####:  313:  for (unsigned i = 0; i < num; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  314:    values.insert(values.begin() + absolutePos + i,
    #####:  315:                  vals[i] ? Optional<Value>(vals[i]) : None);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  316:
    #####:  317:  assert(values.size() == getNumDimAndSymbolVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  318:  return absolutePos;
        -:  319:}
        -:  320:
function _ZNK4mlir26FlatAffineValueConstraints9hasValuesEv called 0 returned 0% blocks executed 0%
    #####:  321:bool FlatAffineValueConstraints::hasValues() const {
    #####:  322:  return llvm::any_of(
    #####:  323:      values, [](const Optional<Value> &var) { return var.has_value(); });
        -:  324:}
        -:  325:
        -:  326:/// Checks if two constraint systems are in the same space, i.e., if they are
        -:  327:/// associated with the same set of variables, appearing in the same order.
function _ZL14areVarsAlignedRKN4mlir26FlatAffineValueConstraintsES2_ called 0 returned 0% blocks executed 0%
    #####:  328:static bool areVarsAligned(const FlatAffineValueConstraints &a,
        -:  329:                           const FlatAffineValueConstraints &b) {
    #####:  330:  return a.getNumDimVars() == b.getNumDimVars() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  331:         a.getNumSymbolVars() == b.getNumSymbolVars() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  332:         a.getNumVars() == b.getNumVars() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  333:         a.getMaybeValues().equals(b.getMaybeValues());
call    0 never executed
        -:  334:}
        -:  335:
        -:  336:/// Calls areVarsAligned to check if two constraint systems have the same set
        -:  337:/// of variables in the same order.
function _ZN4mlir26FlatAffineValueConstraints23areVarsAlignedWithOtherERKS0_ called 0 returned 0% blocks executed 0%
    #####:  338:bool FlatAffineValueConstraints::areVarsAlignedWithOther(
        -:  339:    const FlatAffineValueConstraints &other) {
    #####:  340:  return areVarsAligned(*this, other);
call    0 never executed
        -:  341:}
        -:  342:
        -:  343:/// Checks if the SSA values associated with `cst`'s variables in range
        -:  344:/// [start, end) are unique.
function _ZL13areVarsUniqueRKN4mlir26FlatAffineValueConstraintsEjj called 0 returned 0% blocks executed 0%
    #####:  345:static bool LLVM_ATTRIBUTE_UNUSED areVarsUnique(
        -:  346:    const FlatAffineValueConstraints &cst, unsigned start, unsigned end) {
        -:  347:
    #####:  348:  assert(start <= cst.getNumDimAndSymbolVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  349:         "Start position out of bounds");
    #####:  350:  assert(end <= cst.getNumDimAndSymbolVars() && "End position out of bounds");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  351:
    #####:  352:  if (start >= end)
branch  0 never executed
branch  1 never executed
        -:  353:    return true;
        -:  354:
    #####:  355:  SmallPtrSet<Value, 8> uniqueVars;
call    0 never executed
    #####:  356:  ArrayRef<Optional<Value>> maybeValues =
call    0 never executed
    #####:  357:      cst.getMaybeValues().slice(start, end - start);
call    0 never executed
    #####:  358:  for (Optional<Value> val : maybeValues) {
branch  0 never executed
branch  1 never executed
    #####:  359:    if (val && !uniqueVars.insert(*val).second)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  360:      return false;
        -:  361:  }
    #####:  362:  return true;
        -:  363:}
        -:  364:
        -:  365:/// Checks if the SSA values associated with `cst`'s variables are unique.
        -:  366:static bool LLVM_ATTRIBUTE_UNUSED
    #####:  367:areVarsUnique(const FlatAffineValueConstraints &cst) {
    #####:  368:  return areVarsUnique(cst, 0, cst.getNumDimAndSymbolVars());
        -:  369:}
        -:  370:
        -:  371:/// Checks if the SSA values associated with `cst`'s variables of kind `kind`
        -:  372:/// are unique.
        -:  373:static bool LLVM_ATTRIBUTE_UNUSED
function _ZL13areVarsUniqueRKN4mlir26FlatAffineValueConstraintsENS_10presburger7VarKindE called 0 returned 0% blocks executed 0%
    #####:  374:areVarsUnique(const FlatAffineValueConstraints &cst, VarKind kind) {
        -:  375:
    #####:  376:  if (kind == VarKind::SetDim)
branch  0 never executed
branch  1 never executed
    #####:  377:    return areVarsUnique(cst, 0, cst.getNumDimVars());
call    0 never executed
    #####:  378:  if (kind == VarKind::Symbol)
branch  0 never executed
branch  1 never executed
    #####:  379:    return areVarsUnique(cst, cst.getNumDimVars(),
call    0 never executed
    #####:  380:                         cst.getNumDimAndSymbolVars());
    #####:  381:  llvm_unreachable("Unexpected VarKind");
call    0 never executed
        -:  382:}
        -:  383:
        -:  384:/// Merge and align the variables of A and B starting at 'offset', so that
        -:  385:/// both constraint systems get the union of the contained variables that is
        -:  386:/// dimension-wise and symbol-wise unique; both constraint systems are updated
        -:  387:/// so that they have the union of all variables, with A's original
        -:  388:/// variables appearing first followed by any of B's variables that didn't
        -:  389:/// appear in A. Local variables in B that have the same division
        -:  390:/// representation as local variables in A are merged into one.
        -:  391://  E.g.: Input: A has ((%i, %j) [%M, %N]) and B has (%k, %j) [%P, %N, %M])
        -:  392://        Output: both A, B have (%i, %j, %k) [%M, %N, %P]
function _ZL17mergeAndAlignVarsjPN4mlir26FlatAffineValueConstraintsES1_ called 0 returned 0% blocks executed 0%
    #####:  393:static void mergeAndAlignVars(unsigned offset, FlatAffineValueConstraints *a,
        -:  394:                              FlatAffineValueConstraints *b) {
    #####:  395:  assert(offset <= a->getNumDimVars() && offset <= b->getNumDimVars());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  396:  // A merge/align isn't meaningful if a cst's vars aren't distinct.
    #####:  397:  assert(areVarsUnique(*a) && "A's values aren't unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  398:  assert(areVarsUnique(*b) && "B's values aren't unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  399:
    #####:  400:  assert(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  401:      llvm::all_of(llvm::drop_begin(a->getMaybeValues(), offset),
        -:  402:                   [](const Optional<Value> &var) { return var.has_value(); }));
        -:  403:
    #####:  404:  assert(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  405:      llvm::all_of(llvm::drop_begin(b->getMaybeValues(), offset),
        -:  406:                   [](const Optional<Value> &var) { return var.has_value(); }));
        -:  407:
    #####:  408:  SmallVector<Value, 4> aDimValues;
call    0 never executed
    #####:  409:  a->getValues(offset, a->getNumDimVars(), &aDimValues);
call    0 never executed
        -:  410:
    #####:  411:  {
        -:  412:    // Merge dims from A into B.
    #####:  413:    unsigned d = offset;
    #####:  414:    for (auto aDimValue : aDimValues) {
branch  0 never executed
branch  1 never executed
    #####:  415:      unsigned loc;
    #####:  416:      if (b->findVar(aDimValue, &loc)) {
    #####:  417:        assert(loc >= offset && "A's dim appears in B's aligned range");
call    0 never executed
    #####:  418:        assert(loc < b->getNumDimVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  419:               "A's dim appears in B's non-dim position");
    #####:  420:        b->swapVar(d, loc);
call    0 never executed
        -:  421:      } else {
    #####:  422:        b->insertDimVar(d, aDimValue);
call    0 never executed
call    1 never executed
        -:  423:      }
    #####:  424:      d++;
        -:  425:    }
        -:  426:    // Dimensions that are in B, but not in A, are added at the end.
    #####:  427:    for (unsigned t = a->getNumDimVars(), e = b->getNumDimVars(); t < e; t++) {
branch  0 never executed
branch  1 never executed
    #####:  428:      a->appendDimVar(b->getValue(t));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  429:    }
    #####:  430:    assert(a->getNumDimVars() == b->getNumDimVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  431:           "expected same number of dims");
        -:  432:  }
        -:  433:
        -:  434:  // Merge and align symbols of A and B
    #####:  435:  a->mergeSymbolVars(*b);
call    0 never executed
        -:  436:  // Merge and align locals of A and B
    #####:  437:  a->mergeLocalVars(*b);
call    0 never executed
        -:  438:
    #####:  439:  assert(areVarsAligned(*a, *b) && "IDs expected to be aligned");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  440:}
        -:  441:
        -:  442:// Call 'mergeAndAlignVars' to align constraint systems of 'this' and 'other'.
function _ZN4mlir26FlatAffineValueConstraints26mergeAndAlignVarsWithOtherEjPS0_ called 0 returned 0% blocks executed 0%
    #####:  443:void FlatAffineValueConstraints::mergeAndAlignVarsWithOther(
        -:  444:    unsigned offset, FlatAffineValueConstraints *other) {
    #####:  445:  mergeAndAlignVars(offset, this, other);
call    0 never executed
    #####:  446:}
        -:  447:
        -:  448:LogicalResult
function _ZN4mlir26FlatAffineValueConstraints10composeMapEPKNS_14AffineValueMapE called 0 returned 0% blocks executed 0%
    #####:  449:FlatAffineValueConstraints::composeMap(const AffineValueMap *vMap) {
    #####:  450:  return composeMatchingMap(
    #####:  451:      computeAlignedMap(vMap->getAffineMap(), vMap->getOperands()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  452:}
        -:  453:
        -:  454:// Similar to `composeMap` except that no Values need be associated with the
        -:  455:// constraint system nor are they looked at -- the dimensions and symbols of
        -:  456:// `other` are expected to correspond 1:1 to `this` system.
function _ZN4mlir26FlatAffineValueConstraints18composeMatchingMapENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  457:LogicalResult FlatAffineValueConstraints::composeMatchingMap(AffineMap other) {
    #####:  458:  assert(other.getNumDims() == getNumDimVars() && "dim mismatch");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  459:  assert(other.getNumSymbols() == getNumSymbolVars() && "symbol mismatch");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  460:
    #####:  461:  std::vector<SmallVector<int64_t, 8>> flatExprs;
call    0 never executed
    #####:  462:  if (failed(flattenAlignedMapAndMergeLocals(other, &flatExprs)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  463:    return failure();
    #####:  464:  assert(flatExprs.size() == other.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  465:
        -:  466:  // Add dimensions corresponding to the map's results.
    #####:  467:  insertDimVar(/*pos=*/0, /*num=*/other.getNumResults());
call    0 never executed
call    1 never executed
        -:  468:
        -:  469:  // We add one equality for each result connecting the result dim of the map to
        -:  470:  // the other variables.
        -:  471:  // E.g.: if the expression is 16*i0 + i1, and this is the r^th
        -:  472:  // iteration/result of the value map, we are adding the equality:
        -:  473:  // d_r - 16*i0 - i1 = 0. Similarly, when flattening (i0 + 1, i0 + 8*i2), we
        -:  474:  // add two equalities: d_0 - i0 - 1 == 0, d1 - i0 - 8*i2 == 0.
    #####:  475:  for (unsigned r = 0, e = flatExprs.size(); r < e; r++) {
branch  0 never executed
branch  1 never executed
    #####:  476:    const auto &flatExpr = flatExprs[r];
call    0 never executed
    #####:  477:    assert(flatExpr.size() >= other.getNumInputs() + 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  478:
    #####:  479:    SmallVector<int64_t, 8> eqToAdd(getNumCols(), 0);
call    0 never executed
        -:  480:    // Set the coefficient for this result to one.
    #####:  481:    eqToAdd[r] = 1;
branch  0 never executed
branch  1 never executed
        -:  482:
        -:  483:    // Dims and symbols.
    #####:  484:    for (unsigned i = 0, f = other.getNumInputs(); i < f; i++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  485:      // Negate `eq[r]` since the newly added dimension will be set to this one.
    #####:  486:      eqToAdd[e + i] = -flatExpr[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  487:    }
        -:  488:    // Local columns of `eq` are at the beginning.
    #####:  489:    unsigned j = getNumDimVars() + getNumSymbolVars();
call    0 never executed
    #####:  490:    unsigned end = flatExpr.size() - 1;
call    0 never executed
    #####:  491:    for (unsigned i = other.getNumInputs(); i < end; i++, j++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  492:      eqToAdd[j] = -flatExpr[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:    }
        -:  494:
        -:  495:    // Constant term.
    #####:  496:    eqToAdd[getNumCols() - 1] = -flatExpr[flatExpr.size() - 1];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  497:
        -:  498:    // Add the equality connecting the result of the map to this constraint set.
    #####:  499:    addEquality(eqToAdd);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  500:  }
        -:  501:
    #####:  502:  return success();
call    0 never executed
        -:  503:}
        -:  504:
        -:  505:// Turn a symbol into a dimension.
function _ZL17turnSymbolIntoDimPN4mlir26FlatAffineValueConstraintsENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  506:static void turnSymbolIntoDim(FlatAffineValueConstraints *cst, Value value) {
    #####:  507:  unsigned pos;
    #####:  508:  if (cst->findVar(value, &pos) && pos >= cst->getNumDimVars() &&
branch  0 never executed
branch  1 never executed
    #####:  509:      pos < cst->getNumDimAndSymbolVars()) {
branch  0 never executed
branch  1 never executed
    #####:  510:    cst->swapVar(pos, cst->getNumDimVars());
call    0 never executed
    #####:  511:    cst->setDimSymbolSeparation(cst->getNumSymbolVars() - 1);
call    0 never executed
        -:  512:  }
    #####:  513:}
        -:  514:
        -:  515:/// Merge and align symbols of `this` and `other` such that both get union of
        -:  516:/// of symbols that are unique. Symbols in `this` and `other` should be
        -:  517:/// unique. Symbols with Value as `None` are considered to be inequal to all
        -:  518:/// other symbols.
function _ZN4mlir26FlatAffineValueConstraints15mergeSymbolVarsERS0_ called 0 returned 0% blocks executed 0%
    #####:  519:void FlatAffineValueConstraints::mergeSymbolVars(
        -:  520:    FlatAffineValueConstraints &other) {
        -:  521:
    #####:  522:  assert(areVarsUnique(*this, VarKind::Symbol) && "Symbol vars are not unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  523:  assert(areVarsUnique(other, VarKind::Symbol) && "Symbol vars are not unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  524:
    #####:  525:  SmallVector<Value, 4> aSymValues;
call    0 never executed
    #####:  526:  getValues(getNumDimVars(), getNumDimAndSymbolVars(), &aSymValues);
call    0 never executed
        -:  527:
        -:  528:  // Merge symbols: merge symbols into `other` first from `this`.
    #####:  529:  unsigned s = other.getNumDimVars();
    #####:  530:  for (Value aSymValue : aSymValues) {
branch  0 never executed
branch  1 never executed
    #####:  531:    unsigned loc;
        -:  532:    // If the var is a symbol in `other`, then align it, otherwise assume that
        -:  533:    // it is a new symbol
    #####:  534:    if (other.findVar(aSymValue, &loc) && loc >= other.getNumDimVars() &&
branch  0 never executed
branch  1 never executed
    #####:  535:        loc < other.getNumDimAndSymbolVars())
branch  0 never executed
branch  1 never executed
    #####:  536:      other.swapVar(s, loc);
call    0 never executed
        -:  537:    else
    #####:  538:      other.insertSymbolVar(s - other.getNumDimVars(), aSymValue);
call    0 never executed
call    1 never executed
    #####:  539:    s++;
        -:  540:  }
        -:  541:
        -:  542:  // Symbols that are in other, but not in this, are added at the end.
    #####:  543:  for (unsigned t = other.getNumDimVars() + getNumSymbolVars(),
    #####:  544:                e = other.getNumDimAndSymbolVars();
    #####:  545:       t < e; t++)
branch  0 never executed
branch  1 never executed
    #####:  546:    insertSymbolVar(getNumSymbolVars(), other.getValue(t));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  547:
    #####:  548:  assert(getNumSymbolVars() == other.getNumSymbolVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  549:         "expected same number of symbols");
    #####:  550:  assert(areVarsUnique(*this, VarKind::Symbol) && "Symbol vars are not unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  551:  assert(areVarsUnique(other, VarKind::Symbol) && "Symbol vars are not unique");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  552:}
        -:  553:
        -:  554:// Changes all symbol variables which are loop IVs to dim variables.
function _ZN4mlir26FlatAffineValueConstraints26convertLoopIVSymbolsToDimsEv called 0 returned 0% blocks executed 0%
    #####:  555:void FlatAffineValueConstraints::convertLoopIVSymbolsToDims() {
        -:  556:  // Gather all symbols which are loop IVs.
    #####:  557:  SmallVector<Value, 4> loopIVs;
    #####:  558:  for (unsigned i = getNumDimVars(), e = getNumDimAndSymbolVars(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####:  559:    if (hasValue(i) && getForInductionVarOwner(getValue(i)))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  560:      loopIVs.push_back(getValue(i));
call    0 never executed
call    1 never executed
        -:  561:  }
        -:  562:  // Turn each symbol in 'loopIVs' into a dim variable.
    #####:  563:  for (auto iv : loopIVs) {
branch  0 never executed
branch  1 never executed
    #####:  564:    turnSymbolIntoDim(this, iv);
call    0 never executed
        -:  565:  }
    #####:  566:}
        -:  567:
function _ZN4mlir26FlatAffineValueConstraints31addInductionVarOrTerminalSymbolENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  568:void FlatAffineValueConstraints::addInductionVarOrTerminalSymbol(Value val) {
    #####:  569:  if (containsVar(val))
        -:  570:    return;
        -:  571:
        -:  572:  // Caller is expected to fully compose map/operands if necessary.
    #####:  573:  assert((isTopLevelValue(val) || isForInductionVar(val)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  574:         "non-terminal symbol / loop IV expected");
        -:  575:  // Outer loop IVs could be used in forOp's bounds.
    #####:  576:  if (auto loop = getForInductionVarOwner(val)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  577:    appendDimVar(val);
call    0 never executed
call    1 never executed
    #####:  578:    if (failed(this->addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  579:      LLVM_DEBUG(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  580:          loop.emitWarning("failed to add domain info to constraint system"));
    #####:  581:    return;
        -:  582:  }
        -:  583:  // Add top level symbol.
    #####:  584:  appendSymbolVar(val);
call    0 never executed
call    1 never executed
        -:  585:  // Check if the symbol is a constant.
    #####:  586:  if (auto constOp = val.getDefiningOp<arith::ConstantIndexOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  587:    addBound(BoundType::EQ, val, constOp.value());
call    0 never executed
call    1 never executed
        -:  588:}
        -:  589:
        -:  590:LogicalResult
function _ZN4mlir26FlatAffineValueConstraints20addAffineForOpDomainENS_11AffineForOpE called 0 returned 0% blocks executed 0%
    #####:  591:FlatAffineValueConstraints::addAffineForOpDomain(AffineForOp forOp) {
    #####:  592:  unsigned pos;
        -:  593:  // Pre-condition for this method.
    #####:  594:  if (!findVar(forOp.getInductionVar(), &pos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  595:    assert(false && "Value not found");
call    0 never executed
        -:  596:    return failure();
        -:  597:  }
        -:  598:
    #####:  599:  int64_t step = forOp.getStep();
call    0 never executed
    #####:  600:  if (step != 1) {
branch  0 never executed
branch  1 never executed
    #####:  601:    if (!forOp.hasConstantLowerBound())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  602:      LLVM_DEBUG(forOp.emitWarning("domain conservatively approximated"));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  603:    else {
        -:  604:      // Add constraints for the stride.
        -:  605:      // (iv - lb) % step = 0 can be written as:
        -:  606:      // (iv - lb) - step * q = 0 where q = (iv - lb) / step.
        -:  607:      // Add local variable 'q' and add the above equality.
        -:  608:      // The first constraint is q = (iv - lb) floordiv step
    #####:  609:      SmallVector<int64_t, 8> dividend(getNumCols(), 0);
call    0 never executed
    #####:  610:      int64_t lb = forOp.getConstantLowerBound();
call    0 never executed
    #####:  611:      dividend[pos] = 1;
branch  0 never executed
branch  1 never executed
    #####:  612:      dividend.back() -= lb;
call    0 never executed
    #####:  613:      addLocalFloorDiv(dividend, step);
call    0 never executed
        -:  614:      // Second constraint: (iv - lb) - step * q = 0.
    #####:  615:      SmallVector<int64_t, 8> eq(getNumCols(), 0);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  616:      eq[pos] = 1;
branch  0 never executed
branch  1 never executed
    #####:  617:      eq.back() -= lb;
call    0 never executed
        -:  618:      // For the local var just added above.
    #####:  619:      eq[getNumCols() - 2] = -step;
branch  0 never executed
branch  1 never executed
    #####:  620:      addEquality(eq);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  621:    }
        -:  622:  }
        -:  623:
    #####:  624:  if (forOp.hasConstantLowerBound()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  625:    addBound(BoundType::LB, pos, forOp.getConstantLowerBound());
call    0 never executed
call    1 never executed
        -:  626:  } else {
        -:  627:    // Non-constant lower bound case.
    #####:  628:    if (failed(addBound(BoundType::LB, pos, forOp.getLowerBoundMap(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  629:                        forOp.getLowerBoundOperands())))
    #####:  630:      return failure();
        -:  631:  }
        -:  632:
    #####:  633:  if (forOp.hasConstantUpperBound()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  634:    addBound(BoundType::UB, pos, forOp.getConstantUpperBound() - 1);
call    0 never executed
call    1 never executed
    #####:  635:    return success();
        -:  636:  }
        -:  637:  // Non-constant upper bound case.
    #####:  638:  return addBound(BoundType::UB, pos, forOp.getUpperBoundMap(),
    #####:  639:                  forOp.getUpperBoundOperands());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  640:}
        -:  641:
        -:  642:LogicalResult
function _ZN4mlir26FlatAffineValueConstraints22addDomainFromSliceMapsEN4llvm8ArrayRefINS_9AffineMapEEES4_NS2_INS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  643:FlatAffineValueConstraints::addDomainFromSliceMaps(ArrayRef<AffineMap> lbMaps,
        -:  644:                                                   ArrayRef<AffineMap> ubMaps,
        -:  645:                                                   ArrayRef<Value> operands) {
    #####:  646:  assert(lbMaps.size() == ubMaps.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  647:  assert(lbMaps.size() <= getNumDimVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  648:
    #####:  649:  for (unsigned i = 0, e = lbMaps.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  650:    AffineMap lbMap = lbMaps[i];
branch  0 never executed
branch  1 never executed
    #####:  651:    AffineMap ubMap = ubMaps[i];
branch  0 never executed
branch  1 never executed
    #####:  652:    assert(!lbMap || lbMap.getNumInputs() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  653:    assert(!ubMap || ubMap.getNumInputs() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  654:
        -:  655:    // Check if this slice is just an equality along this dimension. If so,
        -:  656:    // retrieve the existing loop it equates to and add it to the system.
    #####:  657:    if (lbMap && ubMap && lbMap.getNumResults() == 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  658:        ubMap.getNumResults() == 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  659:        lbMap.getResult(0) + 1 == ubMap.getResult(0) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  660:        // The condition above will be true for maps describing a single
        -:  661:        // iteration (e.g., lbMap.getResult(0) = 0, ubMap.getResult(0) = 1).
        -:  662:        // Make sure we skip those cases by checking that the lb result is not
        -:  663:        // just a constant.
    #####:  664:        !lbMap.getResult(0).isa<AffineConstantExpr>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  665:      // Limited support: we expect the lb result to be just a loop dimension.
        -:  666:      // Not supported otherwise for now.
    #####:  667:      AffineDimExpr result = lbMap.getResult(0).dyn_cast<AffineDimExpr>();
call    0 never executed
call    1 never executed
    #####:  668:      if (!result)
branch  0 never executed
branch  1 never executed
    #####:  669:        return failure();
        -:  670:
    #####:  671:      AffineForOp loop =
    #####:  672:          getForInductionVarOwner(operands[result.getPosition()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  673:      if (!loop)
branch  0 never executed
branch  1 never executed
    #####:  674:        return failure();
        -:  675:
    #####:  676:      if (failed(addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  677:        return failure();
    #####:  678:      continue;
        -:  679:    }
        -:  680:
        -:  681:    // This slice refers to a loop that doesn't exist in the IR yet. Add its
        -:  682:    // bounds to the system assuming its dimension variable position is the
        -:  683:    // same as the position of the loop in the loop nest.
    #####:  684:    if (lbMap && failed(addBound(BoundType::LB, i, lbMap, operands)))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  685:      return failure();
    #####:  686:    if (ubMap && failed(addBound(BoundType::UB, i, ubMap, operands)))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  687:      return failure();
        -:  688:  }
    #####:  689:  return success();
        -:  690:}
        -:  691:
function _ZN4mlir26FlatAffineValueConstraints19addAffineIfOpDomainENS_10AffineIfOpE called 0 returned 0% blocks executed 0%
    #####:  692:void FlatAffineValueConstraints::addAffineIfOpDomain(AffineIfOp ifOp) {
        -:  693:  // Create the base constraints from the integer set attached to ifOp.
    #####:  694:  FlatAffineValueConstraints cst(ifOp.getIntegerSet());
call    0 never executed
call    1 never executed
        -:  695:
        -:  696:  // Bind vars in the constraints to ifOp operands.
    #####:  697:  SmallVector<Value, 4> operands = ifOp.getOperands();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  698:  cst.setValues(0, cst.getNumDimAndSymbolVars(), operands);
call    0 never executed
        -:  699:
        -:  700:  // Merge the constraints from ifOp to the current domain. We need first merge
        -:  701:  // and align the IDs from both constraints, and then append the constraints
        -:  702:  // from the ifOp into the current one.
    #####:  703:  mergeAndAlignVarsWithOther(0, &cst);
call    0 never executed
    #####:  704:  append(cst);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  705:}
        -:  706:
function _ZNK4mlir26FlatAffineValueConstraints18hasConsistentStateEv called 0 returned 0% blocks executed 0%
    #####:  707:bool FlatAffineValueConstraints::hasConsistentState() const {
    #####:  708:  return IntegerPolyhedron::hasConsistentState() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  709:         values.size() == getNumDimAndSymbolVars();
branch  0 never executed
branch  1 never executed
        -:  710:}
        -:  711:
function _ZN4mlir26FlatAffineValueConstraints14removeVarRangeENS_10presburger7VarKindEjj called 0 returned 0% blocks executed 0%
    #####:  712:void FlatAffineValueConstraints::removeVarRange(VarKind kind, unsigned varStart,
        -:  713:                                                unsigned varLimit) {
    #####:  714:  IntegerPolyhedron::removeVarRange(kind, varStart, varLimit);
call    0 never executed
    #####:  715:  unsigned offset = getVarKindOffset(kind);
call    0 never executed
        -:  716:
    #####:  717:  if (kind != VarKind::Local) {
branch  0 never executed
branch  1 never executed
    #####:  718:    values.erase(values.begin() + varStart + offset,
    #####:  719:                 values.begin() + varLimit + offset);
call    0 never executed
        -:  720:  }
    #####:  721:}
        -:  722:
        -:  723:// Determine whether the variable at 'pos' (say var_r) can be expressed as
        -:  724:// modulo of another known variable (say var_n) w.r.t a constant. For example,
        -:  725:// if the following constraints hold true:
        -:  726:// ```
        -:  727:// 0 <= var_r <= divisor - 1
        -:  728:// var_n - (divisor * q_expr) = var_r
        -:  729:// ```
        -:  730:// where `var_n` is a known variable (called dividend), and `q_expr` is an
        -:  731:// `AffineExpr` (called the quotient expression), `var_r` can be written as:
        -:  732://
        -:  733:// `var_r = var_n mod divisor`.
        -:  734://
        -:  735:// Additionally, in a special case of the above constaints where `q_expr` is an
        -:  736:// variable itself that is not yet known (say `var_q`), it can be written as a
        -:  737:// floordiv in the following way:
        -:  738://
        -:  739:// `var_q = var_n floordiv divisor`.
        -:  740://
        -:  741:// Returns true if the above mod or floordiv are detected, updating 'memo' with
        -:  742:// these new expressions. Returns false otherwise.
function _ZL11detectAsModRKN4mlir26FlatAffineValueConstraintsEjllRN4llvm15SmallVectorImplINS_10AffineExprEEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  743:static bool detectAsMod(const FlatAffineValueConstraints &cst, unsigned pos,
        -:  744:                        int64_t lbConst, int64_t ubConst,
        -:  745:                        SmallVectorImpl<AffineExpr> &memo,
        -:  746:                        MLIRContext *context) {
    #####:  747:  assert(pos < cst.getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  748:
        -:  749:  // Check if a divisor satisfying the condition `0 <= var_r <= divisor - 1` can
        -:  750:  // be determined.
    #####:  751:  if (lbConst != 0 || ubConst < 1)
branch  0 never executed
branch  1 never executed
        -:  752:    return false;
    #####:  753:  int64_t divisor = ubConst + 1;
        -:  754:
        -:  755:  // Check for the aforementioned conditions in each equality.
    #####:  756:  for (unsigned curEquality = 0, numEqualities = cst.getNumEqualities();
    #####:  757:       curEquality < numEqualities; curEquality++) {
branch  0 never executed
branch  1 never executed
    #####:  758:    int64_t coefficientAtPos = cst.atEq64(curEquality, pos);
call    0 never executed
        -:  759:    // If current equality does not involve `var_r`, continue to the next
        -:  760:    // equality.
    #####:  761:    if (coefficientAtPos == 0)
branch  0 never executed
branch  1 never executed
    #####:  762:      continue;
        -:  763:
        -:  764:    // Constant term should be 0 in this equality.
    #####:  765:    if (cst.atEq64(curEquality, cst.getNumCols() - 1) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  766:      continue;
        -:  767:
        -:  768:    // Traverse through the equality and construct the dividend expression
        -:  769:    // `dividendExpr`, to contain all the variables which are known and are
        -:  770:    // not divisible by `(coefficientAtPos * divisor)`. Hope here is that the
        -:  771:    // `dividendExpr` gets simplified into a single variable `var_n` discussed
        -:  772:    // above.
    #####:  773:    auto dividendExpr = getAffineConstantExpr(0, context);
call    0 never executed
        -:  774:
        -:  775:    // Track the terms that go into quotient expression, later used to detect
        -:  776:    // additional floordiv.
    #####:  777:    unsigned quotientCount = 0;
    #####:  778:    int quotientPosition = -1;
    #####:  779:    int quotientSign = 1;
        -:  780:
        -:  781:    // Consider each term in the current equality.
    #####:  782:    unsigned curVar, e;
    #####:  783:    for (curVar = 0, e = cst.getNumDimAndSymbolVars(); curVar < e; ++curVar) {
branch  0 never executed
branch  1 never executed
        -:  784:      // Ignore var_r.
    #####:  785:      if (curVar == pos)
branch  0 never executed
branch  1 never executed
    #####:  786:        continue;
    #####:  787:      int64_t coefficientOfCurVar = cst.atEq64(curEquality, curVar);
call    0 never executed
        -:  788:      // Ignore vars that do not contribute to the current equality.
    #####:  789:      if (coefficientOfCurVar == 0)
branch  0 never executed
branch  1 never executed
    #####:  790:        continue;
        -:  791:      // Check if the current var goes into the quotient expression.
    #####:  792:      if (coefficientOfCurVar % (divisor * coefficientAtPos) == 0) {
branch  0 never executed
branch  1 never executed
    #####:  793:        quotientCount++;
    #####:  794:        quotientPosition = curVar;
    #####:  795:        quotientSign = (coefficientOfCurVar * coefficientAtPos) > 0 ? 1 : -1;
branch  0 never executed
branch  1 never executed
    #####:  796:        continue;
        -:  797:      }
        -:  798:      // Variables that are part of dividendExpr should be known.
    #####:  799:      if (!memo[curVar])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  800:        break;
        -:  801:      // Append the current variable to the dividend expression.
    #####:  802:      dividendExpr = dividendExpr + memo[curVar] * coefficientOfCurVar;
call    0 never executed
call    1 never executed
        -:  803:    }
        -:  804:
        -:  805:    // Can't construct expression as it depends on a yet uncomputed var.
    #####:  806:    if (curVar < e)
branch  0 never executed
branch  1 never executed
    #####:  807:      continue;
        -:  808:
        -:  809:    // Express `var_r` in terms of the other vars collected so far.
    #####:  810:    if (coefficientAtPos > 0)
branch  0 never executed
branch  1 never executed
    #####:  811:      dividendExpr = (-dividendExpr).floorDiv(coefficientAtPos);
call    0 never executed
call    1 never executed
        -:  812:    else
    #####:  813:      dividendExpr = dividendExpr.floorDiv(-coefficientAtPos);
call    0 never executed
        -:  814:
        -:  815:    // Simplify the expression.
    #####:  816:    dividendExpr = simplifyAffineExpr(dividendExpr, cst.getNumDimVars(),
    #####:  817:                                      cst.getNumSymbolVars());
call    0 never executed
        -:  818:    // Only if the final dividend expression is just a single var (which we call
        -:  819:    // `var_n`), we can proceed.
        -:  820:    // TODO: Handle AffineSymbolExpr as well. There is no reason to restrict it
        -:  821:    // to dims themselves.
    #####:  822:    auto dimExpr = dividendExpr.dyn_cast<AffineDimExpr>();
call    0 never executed
    #####:  823:    if (!dimExpr)
branch  0 never executed
branch  1 never executed
    #####:  824:      continue;
        -:  825:
        -:  826:    // Express `var_r` as `var_n % divisor` and store the expression in `memo`.
    #####:  827:    if (quotientCount >= 1) {
branch  0 never executed
branch  1 never executed
    #####:  828:      auto ub = cst.getConstantBound64(
    #####:  829:          FlatAffineValueConstraints::BoundType::UB, dimExpr.getPosition());
call    0 never executed
call    1 never executed
        -:  830:      // If `var_n` has an upperbound that is less than the divisor, mod can be
        -:  831:      // eliminated altogether.
    #####:  832:      if (ub && *ub < divisor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  833:        memo[pos] = dimExpr;
branch  0 never executed
branch  1 never executed
        -:  834:      else
    #####:  835:        memo[pos] = dimExpr % divisor;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  836:      // If a unique quotient `var_q` was seen, it can be expressed as
        -:  837:      // `var_n floordiv divisor`.
    #####:  838:      if (quotientCount == 1 && !memo[quotientPosition])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  839:        memo[quotientPosition] = dimExpr.floorDiv(divisor) * quotientSign;
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  840:
    #####:  841:      return true;
        -:  842:    }
        -:  843:  }
        -:  844:  return false;
        -:  845:}
        -:  846:
        -:  847:/// Check if the pos^th variable can be expressed as a floordiv of an affine
        -:  848:/// function of other variables (where the divisor is a positive constant)
        -:  849:/// given the initial set of expressions in `exprs`. If it can be, the
        -:  850:/// corresponding position in `exprs` is set as the detected affine expr. For
        -:  851:/// eg: 4q <= i + j <= 4q + 3   <=>   q = (i + j) floordiv 4. An equality can
        -:  852:/// also yield a floordiv: eg.  4q = i + j <=> q = (i + j) floordiv 4. 32q + 28
        -:  853:/// <= i <= 32q + 31 => q = i floordiv 32.
function _ZL16detectAsFloorDivRKN4mlir26FlatAffineValueConstraintsEjPNS_11MLIRContextERN4llvm15SmallVectorImplINS_10AffineExprEEE called 0 returned 0% blocks executed 0%
    #####:  854:static bool detectAsFloorDiv(const FlatAffineValueConstraints &cst,
        -:  855:                             unsigned pos, MLIRContext *context,
        -:  856:                             SmallVectorImpl<AffineExpr> &exprs) {
    #####:  857:  assert(pos < cst.getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  858:
        -:  859:  // Get upper-lower bound pair for this variable.
    #####:  860:  SmallVector<bool, 8> foundRepr(cst.getNumVars(), false);
call    0 never executed
    #####:  861:  for (unsigned i = 0, e = cst.getNumVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  862:    if (exprs[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  863:      foundRepr[i] = true;
branch  0 never executed
branch  1 never executed
        -:  864:
    #####:  865:  SmallVector<int64_t, 8> dividend(cst.getNumCols());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  866:  unsigned divisor;
    #####:  867:  auto ulPair = computeSingleVarRepr(cst, foundRepr, pos, dividend, divisor);
call    0 never executed
        -:  868:
        -:  869:  // No upper-lower bound pair found for this var.
    #####:  870:  if (ulPair.kind == ReprKind::None || ulPair.kind == ReprKind::Equality)
branch  0 never executed
branch  1 never executed
        -:  871:    return false;
        -:  872:
        -:  873:  // Construct the dividend expression.
    #####:  874:  auto dividendExpr = getAffineConstantExpr(dividend.back(), context);
call    0 never executed
call    1 never executed
    #####:  875:  for (unsigned c = 0, f = cst.getNumVars(); c < f; c++)
branch  0 never executed
branch  1 never executed
    #####:  876:    if (dividend[c] != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  877:      dividendExpr = dividendExpr + dividend[c] * exprs[c];
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  878:
        -:  879:  // Successfully detected the floordiv.
    #####:  880:  exprs[pos] = dividendExpr.floorDiv(divisor);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  881:  return true;
        -:  882:}
        -:  883:
        -:  884:std::pair<AffineMap, AffineMap>
function _ZNK4mlir26FlatAffineValueConstraints21getLowerAndUpperBoundEjjjjN4llvm8ArrayRefINS_10AffineExprEEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  885:FlatAffineValueConstraints::getLowerAndUpperBound(
        -:  886:    unsigned pos, unsigned offset, unsigned num, unsigned symStartPos,
        -:  887:    ArrayRef<AffineExpr> localExprs, MLIRContext *context) const {
    #####:  888:  assert(pos + offset < getNumDimVars() && "invalid dim start pos");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  889:  assert(symStartPos >= (pos + offset) && "invalid sym start pos");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  890:  assert(getNumLocalVars() == localExprs.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  891:         "incorrect local exprs count");
        -:  892:
    #####:  893:  SmallVector<unsigned, 4> lbIndices, ubIndices, eqIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  894:  getLowerAndUpperBoundIndices(pos + offset, &lbIndices, &ubIndices, &eqIndices,
call    0 never executed
        -:  895:                               offset, num);
        -:  896:
        -:  897:  /// Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos).
function _ZZNK4mlir26FlatAffineValueConstraints21getLowerAndUpperBoundEjjjjN4llvm8ArrayRefINS_10AffineExprEEEPNS_11MLIRContextEENKUlNS2_IlEERNS1_15SmallVectorImplIlEEE_clES7_SA_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  898:  auto addCoeffs = [&](ArrayRef<int64_t> a, SmallVectorImpl<int64_t> &b) {
    #####:  899:    b.clear();
    #####:  900:    for (unsigned i = 0, e = a.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  901:      if (i < offset || i >= offset + num)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  902:        b.push_back(a[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  903:    }
    #####:  904:  };
        -:  905:
    #####:  906:  SmallVector<int64_t, 8> lb, ub;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  907:  SmallVector<AffineExpr, 4> lbExprs;
branch  0 never executed
branch  1 never executed
    #####:  908:  unsigned dimCount = symStartPos - num;
    #####:  909:  unsigned symCount = getNumDimAndSymbolVars() - symStartPos;
branch  0 never executed
branch  1 never executed
    #####:  910:  lbExprs.reserve(lbIndices.size() + eqIndices.size());
branch  0 never executed
branch  1 never executed
        -:  911:  // Lower bound expressions.
    #####:  912:  for (auto idx : lbIndices) {
branch  0 never executed
branch  1 never executed
    #####:  913:    auto ineq = getInequality64(idx);
call    0 never executed
        -:  914:    // Extract the lower bound (in terms of other coeff's + const), i.e., if
        -:  915:    // i - j + 1 >= 0 is the constraint, 'pos' is for i the lower bound is j
        -:  916:    // - 1.
    #####:  917:    addCoeffs(ineq, lb);
call    0 never executed
    #####:  918:    std::transform(lb.begin(), lb.end(), lb.begin(), std::negate<int64_t>());
    #####:  919:    auto expr =
call    0 never executed
    #####:  920:        getAffineExprFromFlatForm(lb, dimCount, symCount, localExprs, context);
call    0 never executed
        -:  921:    // expr ceildiv divisor is (expr + divisor - 1) floordiv divisor
    #####:  922:    int64_t divisor = std::abs(ineq[pos + offset]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  923:    expr = (expr + divisor - 1).floorDiv(divisor);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  924:    lbExprs.push_back(expr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  925:  }
        -:  926:
    #####:  927:  SmallVector<AffineExpr, 4> ubExprs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  928:  ubExprs.reserve(ubIndices.size() + eqIndices.size());
branch  0 never executed
branch  1 never executed
        -:  929:  // Upper bound expressions.
    #####:  930:  for (auto idx : ubIndices) {
branch  0 never executed
branch  1 never executed
    #####:  931:    auto ineq = getInequality64(idx);
call    0 never executed
        -:  932:    // Extract the upper bound (in terms of other coeff's + const).
    #####:  933:    addCoeffs(ineq, ub);
call    0 never executed
    #####:  934:    auto expr =
call    0 never executed
    #####:  935:        getAffineExprFromFlatForm(ub, dimCount, symCount, localExprs, context);
call    0 never executed
    #####:  936:    expr = expr.floorDiv(std::abs(ineq[pos + offset]));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  937:    // Upper bound is exclusive.
    #####:  938:    ubExprs.push_back(expr + 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  939:  }
        -:  940:
        -:  941:  // Equalities. It's both a lower and a upper bound.
    #####:  942:  SmallVector<int64_t, 4> b;
branch  0 never executed
branch  1 never executed
    #####:  943:  for (auto idx : eqIndices) {
branch  0 never executed
branch  1 never executed
    #####:  944:    auto eq = getEquality64(idx);
call    0 never executed
    #####:  945:    addCoeffs(eq, b);
call    0 never executed
    #####:  946:    if (eq[pos + offset] > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  947:      std::transform(b.begin(), b.end(), b.begin(), std::negate<int64_t>());
        -:  948:
        -:  949:    // Extract the upper bound (in terms of other coeff's + const).
    #####:  950:    auto expr =
call    0 never executed
    #####:  951:        getAffineExprFromFlatForm(b, dimCount, symCount, localExprs, context);
call    0 never executed
    #####:  952:    expr = expr.floorDiv(std::abs(eq[pos + offset]));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  953:    // Upper bound is exclusive.
    #####:  954:    ubExprs.push_back(expr + 1);
call    0 never executed
call    1 never executed
        -:  955:    // Lower bound.
    #####:  956:    expr =
call    0 never executed
    #####:  957:        getAffineExprFromFlatForm(b, dimCount, symCount, localExprs, context);
call    0 never executed
    #####:  958:    expr = expr.ceilDiv(std::abs(eq[pos + offset]));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  959:    lbExprs.push_back(expr);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  960:  }
        -:  961:
    #####:  962:  auto lbMap = AffineMap::get(dimCount, symCount, lbExprs, context);
call    0 never executed
    #####:  963:  auto ubMap = AffineMap::get(dimCount, symCount, ubExprs, context);
call    0 never executed
        -:  964:
    #####:  965:  return {lbMap, ubMap};
branch  0 never executed
branch  1 never executed
        -:  966:}
        -:  967:
        -:  968:/// Computes the lower and upper bounds of the first 'num' dimensional
        -:  969:/// variables (starting at 'offset') as affine maps of the remaining
        -:  970:/// variables (dimensional and symbolic variables). Local variables are
        -:  971:/// themselves explicitly computed as affine functions of other variables in
        -:  972:/// this process if needed.
function _ZN4mlir26FlatAffineValueConstraints14getSliceBoundsEjjPNS_11MLIRContextEPN4llvm15SmallVectorImplINS_9AffineMapEEES7_b called 0 returned 0% blocks executed 0%
    #####:  973:void FlatAffineValueConstraints::getSliceBounds(
        -:  974:    unsigned offset, unsigned num, MLIRContext *context,
        -:  975:    SmallVectorImpl<AffineMap> *lbMaps, SmallVectorImpl<AffineMap> *ubMaps,
        -:  976:    bool getClosedUB) {
    #####:  977:  assert(num < getNumDimVars() && "invalid range");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  978:
        -:  979:  // Basic simplification.
    #####:  980:  normalizeConstraintsByGCD();
call    0 never executed
        -:  981:
    #####:  982:  LLVM_DEBUG(llvm::dbgs() << "getSliceBounds for first " << num
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  983:                          << " variables\n");
    #####:  984:  LLVM_DEBUG(dump());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  985:
        -:  986:  // Record computed/detected variables.
    #####:  987:  SmallVector<AffineExpr, 8> memo(getNumVars());
call    0 never executed
        -:  988:  // Initialize dimensional and symbolic variables.
    #####:  989:  for (unsigned i = 0, e = getNumDimVars(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:    if (i < offset)
branch  0 never executed
branch  1 never executed
    #####:  991:      memo[i] = getAffineDimExpr(i, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  992:    else if (i >= offset + num)
branch  0 never executed
branch  1 never executed
    #####:  993:      memo[i] = getAffineDimExpr(i - num, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  994:  }
    #####:  995:  for (unsigned i = getNumDimVars(), e = getNumDimAndSymbolVars(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####:  996:    memo[i] = getAffineSymbolExpr(i - getNumDimVars(), context);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  997:
    #####:  998:  bool changed;
    #####:  999:  do {
branch  0 never executed
branch  1 never executed
    #####: 1000:    changed = false;
        -: 1001:    // Identify yet unknown variables as constants or mod's / floordiv's of
        -: 1002:    // other variables if possible.
    #####: 1003:    for (unsigned pos = 0; pos < getNumVars(); pos++) {
branch  0 never executed
branch  1 never executed
    #####: 1004:      if (memo[pos])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1005:        continue;
        -: 1006:
    #####: 1007:      auto lbConst = getConstantBound64(BoundType::LB, pos);
call    0 never executed
    #####: 1008:      auto ubConst = getConstantBound64(BoundType::UB, pos);
call    0 never executed
    #####: 1009:      if (lbConst.has_value() && ubConst.has_value()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1010:        // Detect equality to a constant.
    #####: 1011:        if (lbConst.value() == ubConst.value()) {
branch  0 never executed
branch  1 never executed
    #####: 1012:          memo[pos] = getAffineConstantExpr(lbConst.value(), context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1013:          changed = true;
    #####: 1014:          continue;
        -: 1015:        }
        -: 1016:
        -: 1017:        // Detect an variable as modulo of another variable w.r.t a
        -: 1018:        // constant.
    #####: 1019:        if (detectAsMod(*this, pos, lbConst.value(), ubConst.value(), memo,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1020:                        context)) {
    #####: 1021:          changed = true;
    #####: 1022:          continue;
        -: 1023:        }
        -: 1024:      }
        -: 1025:
        -: 1026:      // Detect an variable as a floordiv of an affine function of other
        -: 1027:      // variables (divisor is a positive constant).
    #####: 1028:      if (detectAsFloorDiv(*this, pos, context, memo)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1029:        changed = true;
    #####: 1030:        continue;
        -: 1031:      }
        -: 1032:
        -: 1033:      // Detect an variable as an expression of other variables.
    #####: 1034:      unsigned idx;
    #####: 1035:      if (!findConstraintWithNonZeroAt(pos, /*isEq=*/true, &idx)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1036:        continue;
        -: 1037:      }
        -: 1038:
        -: 1039:      // Build AffineExpr solving for variable 'pos' in terms of all others.
    #####: 1040:      auto expr = getAffineConstantExpr(0, context);
call    0 never executed
    #####: 1041:      unsigned j, e;
    #####: 1042:      for (j = 0, e = getNumVars(); j < e; ++j) {
branch  0 never executed
branch  1 never executed
    #####: 1043:        if (j == pos)
branch  0 never executed
branch  1 never executed
    #####: 1044:          continue;
    #####: 1045:        int64_t c = atEq64(idx, j);
call    0 never executed
    #####: 1046:        if (c == 0)
branch  0 never executed
branch  1 never executed
    #####: 1047:          continue;
        -: 1048:        // If any of the involved IDs hasn't been found yet, we can't proceed.
    #####: 1049:        if (!memo[j])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1050:          break;
    #####: 1051:        expr = expr + memo[j] * c;
call    0 never executed
call    1 never executed
        -: 1052:      }
    #####: 1053:      if (j < e)
branch  0 never executed
branch  1 never executed
        -: 1054:        // Can't construct expression as it depends on a yet uncomputed
        -: 1055:        // variable.
    #####: 1056:        continue;
        -: 1057:
        -: 1058:      // Add constant term to AffineExpr.
    #####: 1059:      expr = expr + atEq64(idx, getNumVars());
call    0 never executed
call    1 never executed
    #####: 1060:      int64_t vPos = atEq64(idx, pos);
call    0 never executed
    #####: 1061:      assert(vPos != 0 && "expected non-zero here");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1062:      if (vPos > 0)
branch  0 never executed
branch  1 never executed
    #####: 1063:        expr = (-expr).floorDiv(vPos);
call    0 never executed
call    1 never executed
        -: 1064:      else
        -: 1065:        // vPos < 0.
    #####: 1066:        expr = expr.floorDiv(-vPos);
call    0 never executed
        -: 1067:      // Successfully constructed expression.
    #####: 1068:      memo[pos] = expr;
branch  0 never executed
branch  1 never executed
    #####: 1069:      changed = true;
        -: 1070:    }
        -: 1071:    // This loop is guaranteed to reach a fixed point - since once an
        -: 1072:    // variable's explicit form is computed (in memo[pos]), it's not updated
        -: 1073:    // again.
        -: 1074:  } while (changed);
        -: 1075:
    #####: 1076:  int64_t ubAdjustment = getClosedUB ? 0 : 1;
branch  0 never executed
branch  1 never executed
        -: 1077:
        -: 1078:  // Set the lower and upper bound maps for all the variables that were
        -: 1079:  // computed as affine expressions of the rest as the "detected expr" and
        -: 1080:  // "detected expr + 1" respectively; set the undetected ones to null.
    #####: 1081:  Optional<FlatAffineValueConstraints> tmpClone;
branch  0 never executed
branch  1 never executed
    #####: 1082:  for (unsigned pos = 0; pos < num; pos++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:    unsigned numMapDims = getNumDimVars() - num;
branch  0 never executed
branch  1 never executed
    #####: 1084:    unsigned numMapSymbols = getNumSymbolVars();
branch  0 never executed
branch  1 never executed
    #####: 1085:    AffineExpr expr = memo[pos + offset];
branch  0 never executed
branch  1 never executed
    #####: 1086:    if (expr)
branch  0 never executed
branch  1 never executed
    #####: 1087:      expr = simplifyAffineExpr(expr, numMapDims, numMapSymbols);
call    0 never executed
        -: 1088:
    #####: 1089:    AffineMap &lbMap = (*lbMaps)[pos];
branch  0 never executed
branch  1 never executed
    #####: 1090:    AffineMap &ubMap = (*ubMaps)[pos];
branch  0 never executed
branch  1 never executed
        -: 1091:
    #####: 1092:    if (expr) {
branch  0 never executed
branch  1 never executed
    #####: 1093:      lbMap = AffineMap::get(numMapDims, numMapSymbols, expr);
call    0 never executed
    #####: 1094:      ubMap = AffineMap::get(numMapDims, numMapSymbols, expr + ubAdjustment);
call    0 never executed
call    1 never executed
        -: 1095:    } else {
        -: 1096:      // TODO: Whenever there are local variables in the dependence
        -: 1097:      // constraints, we'll conservatively over-approximate, since we don't
        -: 1098:      // always explicitly compute them above (in the while loop).
    #####: 1099:      if (getNumLocalVars() == 0) {
branch  0 never executed
branch  1 never executed
        -: 1100:        // Work on a copy so that we don't update this constraint system.
    #####: 1101:        if (!tmpClone) {
branch  0 never executed
branch  1 never executed
    #####: 1102:          tmpClone.emplace(FlatAffineValueConstraints(*this));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1103:          // Removing redundant inequalities is necessary so that we don't get
        -: 1104:          // redundant loop bounds.
    #####: 1105:          tmpClone->removeRedundantInequalities();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1106:        }
    #####: 1107:        std::tie(lbMap, ubMap) = tmpClone->getLowerAndUpperBound(
branch  0 never executed
branch  1 never executed
    #####: 1108:            pos, offset, num, getNumDimVars(), /*localExprs=*/{}, context);
call    0 never executed
        -: 1109:      }
        -: 1110:
        -: 1111:      // If the above fails, we'll just use the constant lower bound and the
        -: 1112:      // constant upper bound (if they exist) as the slice bounds.
        -: 1113:      // TODO: being conservative for the moment in cases that
        -: 1114:      // lead to multiple bounds - until getConstDifference in LoopFusion.cpp is
        -: 1115:      // fixed (b/126426796).
    #####: 1116:      if (!lbMap || lbMap.getNumResults() > 1) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1117:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 1118:                   << "WARNING: Potentially over-approximating slice lb\n");
    #####: 1119:        auto lbConst = getConstantBound64(BoundType::LB, pos + offset);
call    0 never executed
    #####: 1120:        if (lbConst.has_value()) {
branch  0 never executed
branch  1 never executed
    #####: 1121:          lbMap =
call    0 never executed
        -: 1122:              AffineMap::get(numMapDims, numMapSymbols,
    #####: 1123:                             getAffineConstantExpr(lbConst.value(), context));
call    0 never executed
call    1 never executed
        -: 1124:        }
        -: 1125:      }
    #####: 1126:      if (!ubMap || ubMap.getNumResults() > 1) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1127:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 1128:                   << "WARNING: Potentially over-approximating slice ub\n");
    #####: 1129:        auto ubConst = getConstantBound64(BoundType::UB, pos + offset);
call    0 never executed
    #####: 1130:        if (ubConst.has_value()) {
branch  0 never executed
branch  1 never executed
    #####: 1131:          ubMap = AffineMap::get(
call    0 never executed
        -: 1132:              numMapDims, numMapSymbols,
    #####: 1133:              getAffineConstantExpr(ubConst.value() + ubAdjustment, context));
call    0 never executed
call    1 never executed
        -: 1134:        }
        -: 1135:      }
        -: 1136:    }
    #####: 1137:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -: 1138:               << "lb map for pos = " << Twine(pos + offset) << ", expr: ");
    #####: 1139:    LLVM_DEBUG(lbMap.dump(););
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1140:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -: 1141:               << "ub map for pos = " << Twine(pos + offset) << ", expr: ");
    #####: 1142:    LLVM_DEBUG(ubMap.dump(););
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1143:  }
    #####: 1144:}
        -: 1145:
function _ZN4mlir26FlatAffineValueConstraints31flattenAlignedMapAndMergeLocalsENS_9AffineMapEPSt6vectorIN4llvm11SmallVectorIlLj8EEESaIS5_EE called 0 returned 0% blocks executed 0%
    #####: 1146:LogicalResult FlatAffineValueConstraints::flattenAlignedMapAndMergeLocals(
        -: 1147:    AffineMap map, std::vector<SmallVector<int64_t, 8>> *flattenedExprs) {
    #####: 1148:  FlatAffineValueConstraints localCst;
call    0 never executed
    #####: 1149:  if (failed(getFlattenedAffineExprs(map, flattenedExprs, &localCst))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1150:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 1151:               << "composition unimplemented for semi-affine maps\n");
    #####: 1152:    return failure();
        -: 1153:  }
        -: 1154:
        -: 1155:  // Add localCst information.
    #####: 1156:  if (localCst.getNumLocalVars() > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1157:    unsigned numLocalVars = getNumLocalVars();
call    0 never executed
        -: 1158:    // Insert local dims of localCst at the beginning.
    #####: 1159:    insertLocalVar(/*pos=*/0, /*num=*/localCst.getNumLocalVars());
call    0 never executed
        -: 1160:    // Insert local dims of `this` at the end of localCst.
    #####: 1161:    localCst.appendLocalVar(/*num=*/numLocalVars);
call    0 never executed
        -: 1162:    // Dimensions of localCst and this constraint set match. Append localCst to
        -: 1163:    // this constraint set.
    #####: 1164:    append(localCst);
call    0 never executed
        -: 1165:  }
        -: 1166:
    #####: 1167:  return success();
call    0 never executed
        -: 1168:}
        -: 1169:
function _ZN4mlir26FlatAffineValueConstraints8addBoundENS_10presburger15IntegerRelation9BoundTypeEjNS_9AffineMapEb called 0 returned 0% blocks executed 0%
    #####: 1170:LogicalResult FlatAffineValueConstraints::addBound(BoundType type, unsigned pos,
        -: 1171:                                                   AffineMap boundMap,
        -: 1172:                                                   bool isClosedBound) {
    #####: 1173:  assert(boundMap.getNumDims() == getNumDimVars() && "dim mismatch");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1174:  assert(boundMap.getNumSymbols() == getNumSymbolVars() && "symbol mismatch");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1175:  assert(pos < getNumDimAndSymbolVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1176:  assert((type != BoundType::EQ || isClosedBound) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1177:         "EQ bound must be closed.");
        -: 1178:
        -: 1179:  // Equality follows the logic of lower bound except that we add an equality
        -: 1180:  // instead of an inequality.
    #####: 1181:  assert((type != BoundType::EQ || boundMap.getNumResults() == 1) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1182:         "single result expected");
    #####: 1183:  bool lower = type == BoundType::LB || type == BoundType::EQ;
        -: 1184:
    #####: 1185:  std::vector<SmallVector<int64_t, 8>> flatExprs;
call    0 never executed
    #####: 1186:  if (failed(flattenAlignedMapAndMergeLocals(boundMap, &flatExprs)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1187:    return failure();
    #####: 1188:  assert(flatExprs.size() == boundMap.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1189:
        -: 1190:  // Add one (in)equality for each result.
    #####: 1191:  for (const auto &flatExpr : flatExprs) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1192:    SmallVector<int64_t> ineq(getNumCols(), 0);
call    0 never executed
        -: 1193:    // Dims and symbols.
    #####: 1194:    for (unsigned j = 0, e = boundMap.getNumInputs(); j < e; j++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1195:      ineq[j] = lower ? -flatExpr[j] : flatExpr[j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1196:    }
        -: 1197:    // Invalid bound: pos appears in `boundMap`.
        -: 1198:    // TODO: This should be an assertion. Fix `addDomainFromSliceMaps` and/or
        -: 1199:    // its callers to prevent invalid bounds from being added.
    #####: 1200:    if (ineq[pos] != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1201:      continue;
branch  0 never executed
branch  1 never executed
    #####: 1202:    ineq[pos] = lower ? 1 : -1;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1203:    // Local columns of `ineq` are at the beginning.
    #####: 1204:    unsigned j = getNumDimVars() + getNumSymbolVars();
call    0 never executed
    #####: 1205:    unsigned end = flatExpr.size() - 1;
    #####: 1206:    for (unsigned i = boundMap.getNumInputs(); i < end; i++, j++) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1207:      ineq[j] = lower ? -flatExpr[i] : flatExpr[i];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1208:    }
        -: 1209:    // Make the bound closed in if flatExpr is open. The inequality is always
        -: 1210:    // created in the upper bound form, so the adjustment is -1.
    #####: 1211:    int64_t boundAdjustment = (isClosedBound || type == BoundType::EQ) ? 0 : -1;
branch  0 never executed
branch  1 never executed
        -: 1212:    // Constant term.
    #####: 1213:    ineq[getNumCols() - 1] = (lower ? -flatExpr[flatExpr.size() - 1]
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1214:                                    : flatExpr[flatExpr.size() - 1]) +
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1215:                             boundAdjustment;
    #####: 1216:    type == BoundType::EQ ? addEquality(ineq) : addInequality(ineq);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1217:  }
        -: 1218:
    #####: 1219:  return success();
call    0 never executed
        -: 1220:}
        -: 1221:
function _ZN4mlir26FlatAffineValueConstraints8addBoundENS_10presburger15IntegerRelation9BoundTypeEjNS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####: 1222:LogicalResult FlatAffineValueConstraints::addBound(BoundType type, unsigned pos,
        -: 1223:                                                   AffineMap boundMap) {
    #####: 1224:  return addBound(type, pos, boundMap, /*isClosedBound=*/type != BoundType::UB);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1225:}
        -: 1226:
        -: 1227:AffineMap
function _ZNK4mlir26FlatAffineValueConstraints17computeAlignedMapENS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1228:FlatAffineValueConstraints::computeAlignedMap(AffineMap map,
        -: 1229:                                              ValueRange operands) const {
    #####: 1230:  assert(map.getNumInputs() == operands.size() && "number of inputs mismatch");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1231:
    #####: 1232:  SmallVector<Value> dims, syms;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1233:#ifndef NDEBUG
    #####: 1234:  SmallVector<Value> newSyms;
branch  0 never executed
branch  1 never executed
    #####: 1235:  SmallVector<Value> *newSymsPtr = &newSyms;
        -: 1236:#else
        -: 1237:  SmallVector<Value> *newSymsPtr = nullptr;
        -: 1238:#endif // NDEBUG
        -: 1239:
    #####: 1240:  dims.reserve(getNumDimVars());
branch  0 never executed
branch  1 never executed
    #####: 1241:  syms.reserve(getNumSymbolVars());
branch  0 never executed
branch  1 never executed
    #####: 1242:  for (unsigned i = getVarKindOffset(VarKind::SetDim),
call    0 never executed
    #####: 1243:                e = getVarKindEnd(VarKind::SetDim);
call    0 never executed
    #####: 1244:       i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1245:    dims.push_back(values[i] ? *values[i] : Value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1246:  for (unsigned i = getVarKindOffset(VarKind::Symbol),
call    0 never executed
    #####: 1247:                e = getVarKindEnd(VarKind::Symbol);
call    0 never executed
    #####: 1248:       i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1249:    syms.push_back(values[i] ? *values[i] : Value());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1250:
    #####: 1251:  AffineMap alignedMap =
call    0 never executed
    #####: 1252:      alignAffineMapWithValues(map, operands, dims, syms, newSymsPtr);
call    0 never executed
call    1 never executed
        -: 1253:  // All symbols are already part of this FlatAffineConstraints.
    #####: 1254:  assert(syms.size() == newSymsPtr->size() && "unexpected new/missing symbols");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1255:  assert(std::equal(syms.begin(), syms.end(), newSymsPtr->begin()) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1256:         "unexpected new/missing symbols");
    #####: 1257:  return alignedMap;
branch  0 never executed
branch  1 never executed
        -: 1258:}
        -: 1259:
function _ZN4mlir26FlatAffineValueConstraints8addBoundENS_10presburger15IntegerRelation9BoundTypeEjNS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1260:LogicalResult FlatAffineValueConstraints::addBound(BoundType type, unsigned pos,
        -: 1261:                                                   AffineMap boundMap,
        -: 1262:                                                   ValueRange boundOperands) {
        -: 1263:  // Fully compose map and operands; canonicalize and simplify so that we
        -: 1264:  // transitively get to terminal symbols or loop IVs.
    #####: 1265:  auto map = boundMap;
    #####: 1266:  SmallVector<Value, 4> operands(boundOperands.begin(), boundOperands.end());
call    0 never executed
    #####: 1267:  fullyComposeAffineMapAndOperands(&map, &operands);
call    0 never executed
    #####: 1268:  map = simplifyAffineMap(map);
call    0 never executed
    #####: 1269:  canonicalizeMapAndOperands(&map, &operands);
call    0 never executed
    #####: 1270:  for (auto operand : operands)
branch  0 never executed
branch  1 never executed
    #####: 1271:    addInductionVarOrTerminalSymbol(operand);
call    0 never executed
    #####: 1272:  return addBound(type, pos, computeAlignedMap(map, operands));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1273:}
        -: 1274:
        -: 1275:// Adds slice lower bounds represented by lower bounds in 'lbMaps' and upper
        -: 1276:// bounds in 'ubMaps' to each value in `values' that appears in the constraint
        -: 1277:// system. Note that both lower/upper bounds share the same operand list
        -: 1278:// 'operands'.
        -: 1279:// This function assumes 'values.size' == 'lbMaps.size' == 'ubMaps.size', and
        -: 1280:// skips any null AffineMaps in 'lbMaps' or 'ubMaps'.
        -: 1281:// Note that both lower/upper bounds use operands from 'operands'.
        -: 1282:// Returns failure for unimplemented cases such as semi-affine expressions or
        -: 1283:// expressions with mod/floordiv.
function _ZN4mlir26FlatAffineValueConstraints14addSliceBoundsEN4llvm8ArrayRefINS_5ValueEEENS2_INS_9AffineMapEEES6_S4_ called 0 returned 0% blocks executed 0%
    #####: 1284:LogicalResult FlatAffineValueConstraints::addSliceBounds(
        -: 1285:    ArrayRef<Value> values, ArrayRef<AffineMap> lbMaps,
        -: 1286:    ArrayRef<AffineMap> ubMaps, ArrayRef<Value> operands) {
    #####: 1287:  assert(values.size() == lbMaps.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1288:  assert(lbMaps.size() == ubMaps.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1289:
    #####: 1290:  for (unsigned i = 0, e = lbMaps.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1291:    unsigned pos;
    #####: 1292:    if (!findVar(values[i], &pos))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1293:      continue;
        -: 1294:
    #####: 1295:    AffineMap lbMap = lbMaps[i];
branch  0 never executed
branch  1 never executed
    #####: 1296:    AffineMap ubMap = ubMaps[i];
branch  0 never executed
branch  1 never executed
    #####: 1297:    assert(!lbMap || lbMap.getNumInputs() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1298:    assert(!ubMap || ubMap.getNumInputs() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1299:
        -: 1300:    // Check if this slice is just an equality along this dimension.
    #####: 1301:    if (lbMap && ubMap && lbMap.getNumResults() == 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1302:        ubMap.getNumResults() == 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1303:        lbMap.getResult(0) + 1 == ubMap.getResult(0)) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1304:      if (failed(addBound(BoundType::EQ, pos, lbMap, operands)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1305:        return failure();
    #####: 1306:      continue;
        -: 1307:    }
        -: 1308:
        -: 1309:    // If lower or upper bound maps are null or provide no results, it implies
        -: 1310:    // that the source loop was not at all sliced, and the entire loop will be a
        -: 1311:    // part of the slice.
    #####: 1312:    if (lbMap && lbMap.getNumResults() != 0 && ubMap &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 1313:        ubMap.getNumResults() != 0) {
call    0 never executed
    #####: 1314:      if (failed(addBound(BoundType::LB, pos, lbMap, operands)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1315:        return failure();
    #####: 1316:      if (failed(addBound(BoundType::UB, pos, ubMap, operands)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1317:        return failure();
        -: 1318:    } else {
    #####: 1319:      auto loop = getForInductionVarOwner(values[i]);
call    0 never executed
    #####: 1320:      if (failed(this->addAffineForOpDomain(loop)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1321:        return failure();
        -: 1322:    }
        -: 1323:  }
    #####: 1324:  return success();
        -: 1325:}
        -: 1326:
function _ZNK4mlir26FlatAffineValueConstraints7findVarENS_5ValueEPj called 0 returned 0% blocks executed 0%
    #####: 1327:bool FlatAffineValueConstraints::findVar(Value val, unsigned *pos) const {
    #####: 1328:  unsigned i = 0;
    #####: 1329:  for (const auto &mayBeVar : values) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 1330:    if (mayBeVar && *mayBeVar == val) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
    #####: 1331:      *pos = i;
    #####: 1332:      return true;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1333:    }
    #####: 1334:    i++;
        -: 1335:  }
        -: 1336:  return false;
        -: 1337:}
        -: 1338:
function _ZNK4mlir26FlatAffineValueConstraints11containsVarENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 1339:bool FlatAffineValueConstraints::containsVar(Value val) const {
    #####: 1340:  return llvm::any_of(values, [&](const Optional<Value> &mayBeVar) {
branch  0 never executed
branch  1 never executed
        -: 1341:    return mayBeVar && *mayBeVar == val;
    #####: 1342:  });
        -: 1343:}
        -: 1344:
function _ZN4mlir26FlatAffineValueConstraints7swapVarEjj called 0 returned 0% blocks executed 0%
    #####: 1345:void FlatAffineValueConstraints::swapVar(unsigned posA, unsigned posB) {
    #####: 1346:  IntegerPolyhedron::swapVar(posA, posB);
call    0 never executed
        -: 1347:
    #####: 1348:  if (getVarKindAt(posA) == VarKind::Local &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1349:      getVarKindAt(posB) == VarKind::Local)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1350:    return;
        -: 1351:
        -: 1352:  // Treat value of a local variable as None.
    #####: 1353:  if (getVarKindAt(posA) == VarKind::Local)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1354:    values[posB] = None;
branch  0 never executed
branch  1 never executed
    #####: 1355:  else if (getVarKindAt(posB) == VarKind::Local)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1356:    values[posA] = None;
branch  0 never executed
branch  1 never executed
        -: 1357:  else
    #####: 1358:    std::swap(values[posA], values[posB]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1359:}
        -: 1360:
function _ZN4mlir26FlatAffineValueConstraints8addBoundENS_10presburger15IntegerRelation9BoundTypeENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####: 1361:void FlatAffineValueConstraints::addBound(BoundType type, Value val,
        -: 1362:                                          int64_t value) {
    #####: 1363:  unsigned pos;
    #####: 1364:  if (!findVar(val, &pos))
branch  0 never executed
branch  1 never executed
        -: 1365:    // This is a pre-condition for this method.
    #####: 1366:    assert(0 && "var not found");
call    0 never executed
    #####: 1367:  addBound(type, pos, value);
call    0 never executed
    #####: 1368:}
        -: 1369:
function _ZNK4mlir26FlatAffineValueConstraints10printSpaceERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####: 1370:void FlatAffineValueConstraints::printSpace(raw_ostream &os) const {
    #####: 1371:  IntegerPolyhedron::printSpace(os);
call    0 never executed
    #####: 1372:  os << "(";
call    0 never executed
    #####: 1373:  for (unsigned i = 0, e = getNumDimAndSymbolVars(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1374:    if (hasValue(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1375:      os << "Value ";
call    0 never executed
        -: 1376:    else
    #####: 1377:      os << "None ";
call    0 never executed
        -: 1378:  }
    #####: 1379:  for (unsigned i = getVarKindOffset(VarKind::Local),
call    0 never executed
    #####: 1380:                e = getVarKindEnd(VarKind::Local);
call    0 never executed
    #####: 1381:       i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1382:    os << "Local ";
call    0 never executed
    #####: 1383:  os << " const)\n";
call    0 never executed
    #####: 1384:}
        -: 1385:
function _ZN4mlir26FlatAffineValueConstraints16clearAndCopyFromERKNS_10presburger15IntegerRelationE called 0 returned 0% blocks executed 0%
    #####: 1386:void FlatAffineValueConstraints::clearAndCopyFrom(
        -: 1387:    const IntegerRelation &other) {
        -: 1388:
    #####: 1389:  if (auto *otherValueSet =
    #####: 1390:          dyn_cast<const FlatAffineValueConstraints>(&other)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1391:    *this = *otherValueSet;
call    0 never executed
        -: 1392:  } else {
    #####: 1393:    *static_cast<IntegerRelation *>(this) = other;
call    0 never executed
    #####: 1394:    values.clear();
call    0 never executed
    #####: 1395:    values.resize(getNumDimAndSymbolVars(), None);
call    0 never executed
        -: 1396:  }
    #####: 1397:}
        -: 1398:
function _ZN4mlir26FlatAffineValueConstraints23fourierMotzkinEliminateEjbPb called 0 returned 0% blocks executed 0%
    #####: 1399:void FlatAffineValueConstraints::fourierMotzkinEliminate(
        -: 1400:    unsigned pos, bool darkShadow, bool *isResultIntegerExact) {
    #####: 1401:  SmallVector<Optional<Value>, 8> newVals = values;
branch  0 never executed
branch  1 never executed
    #####: 1402:  if (getVarKindAt(pos) != VarKind::Local)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1403:    newVals.erase(newVals.begin() + pos);
call    0 never executed
        -: 1404:  // Note: Base implementation discards all associated Values.
    #####: 1405:  IntegerPolyhedron::fourierMotzkinEliminate(pos, darkShadow,
call    0 never executed
        -: 1406:                                             isResultIntegerExact);
    #####: 1407:  values = newVals;
call    0 never executed
    #####: 1408:  assert(values.size() == getNumDimAndSymbolVars());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1409:}
        -: 1410:
function _ZN4mlir26FlatAffineValueConstraints10projectOutENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 1411:void FlatAffineValueConstraints::projectOut(Value val) {
    #####: 1412:  unsigned pos;
    #####: 1413:  bool ret = findVar(val, &pos);
    #####: 1414:  assert(ret);
call    0 never executed
    #####: 1415:  (void)ret;
    #####: 1416:  fourierMotzkinEliminate(pos);
call    0 never executed
    #####: 1417:}
        -: 1418:
function _ZN4mlir26FlatAffineValueConstraints16unionBoundingBoxERKS0_ called 0 returned 0% blocks executed 0%
    #####: 1419:LogicalResult FlatAffineValueConstraints::unionBoundingBox(
        -: 1420:    const FlatAffineValueConstraints &otherCst) {
    #####: 1421:  assert(otherCst.getNumDimVars() == getNumDimVars() && "dims mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1422:  assert(otherCst.getMaybeValues()
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
        -: 1423:             .slice(0, getNumDimVars())
        -: 1424:             .equals(getMaybeValues().slice(0, getNumDimVars())) &&
        -: 1425:         "dim values mismatch");
    #####: 1426:  assert(otherCst.getNumLocalVars() == 0 && "local vars not supported here");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1427:  assert(getNumLocalVars() == 0 && "local vars not supported yet here");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1428:
        -: 1429:  // Align `other` to this.
    #####: 1430:  if (!areVarsAligned(*this, otherCst)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1431:    FlatAffineValueConstraints otherCopy(otherCst);
call    0 never executed
call    1 never executed
    #####: 1432:    mergeAndAlignVars(/*offset=*/getNumDimVars(), this, &otherCopy);
call    0 never executed
    #####: 1433:    return IntegerPolyhedron::unionBoundingBox(otherCopy);
call    0 never executed
        -: 1434:  }
        -: 1435:
    #####: 1436:  return IntegerPolyhedron::unionBoundingBox(otherCst);
call    0 never executed
        -: 1437:}
        -: 1438:
        -: 1439:/// Compute an explicit representation for local vars. For all systems coming
        -: 1440:/// from MLIR integer sets, maps, or expressions where local vars were
        -: 1441:/// introduced to model floordivs and mods, this always succeeds.
function _ZL16computeLocalVarsRKN4mlir26FlatAffineValueConstraintsERN4llvm15SmallVectorImplINS_10AffineExprEEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####: 1442:static LogicalResult computeLocalVars(const FlatAffineValueConstraints &cst,
        -: 1443:                                      SmallVectorImpl<AffineExpr> &memo,
        -: 1444:                                      MLIRContext *context) {
    #####: 1445:  unsigned numDims = cst.getNumDimVars();
    #####: 1446:  unsigned numSyms = cst.getNumSymbolVars();
        -: 1447:
        -: 1448:  // Initialize dimensional and symbolic variables.
    #####: 1449:  for (unsigned i = 0; i < numDims; i++)
branch  0 never executed
branch  1 never executed
    #####: 1450:    memo[i] = getAffineDimExpr(i, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1451:  for (unsigned i = numDims, e = numDims + numSyms; i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1452:    memo[i] = getAffineSymbolExpr(i - numDims, context);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1453:
    #####: 1454:  bool changed;
    #####: 1455:  do {
branch  0 never executed
branch  1 never executed
        -: 1456:    // Each time `changed` is true at the end of this iteration, one or more
        -: 1457:    // local vars would have been detected as floordivs and set in memo; so the
        -: 1458:    // number of null entries in memo[...] strictly reduces; so this converges.
    #####: 1459:    changed = false;
    #####: 1460:    for (unsigned i = 0, e = cst.getNumLocalVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1461:      if (!memo[numDims + numSyms + i] &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1462:          detectAsFloorDiv(cst, /*pos=*/numDims + numSyms + i, context, memo))
call    0 never executed
        -: 1463:        changed = true;
        -: 1464:  } while (changed);
        -: 1465:
    #####: 1466:  ArrayRef<AffineExpr> localExprs =
    #####: 1467:      ArrayRef<AffineExpr>(memo).take_back(cst.getNumLocalVars());
branch  0 never executed
branch  1 never executed
    #####: 1468:  return success(
    #####: 1469:      llvm::all_of(localExprs, [](AffineExpr expr) { return expr; }));
        -: 1470:}
        -: 1471:
function _ZNK4mlir26FlatAffineValueConstraints23getIneqAsAffineValueMapEjjRNS_14AffineValueMapEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####: 1472:void FlatAffineValueConstraints::getIneqAsAffineValueMap(
        -: 1473:    unsigned pos, unsigned ineqPos, AffineValueMap &vmap,
        -: 1474:    MLIRContext *context) const {
    #####: 1475:  unsigned numDims = getNumDimVars();
branch  0 never executed
branch  1 never executed
    #####: 1476:  unsigned numSyms = getNumSymbolVars();
branch  0 never executed
branch  1 never executed
        -: 1477:
    #####: 1478:  assert(pos < numDims && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1479:  assert(ineqPos < getNumInequalities() && "invalid inequality position");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1480:
        -: 1481:  // Get expressions for local vars.
    #####: 1482:  SmallVector<AffineExpr, 8> memo(getNumVars(), AffineExpr());
call    0 never executed
    #####: 1483:  if (failed(computeLocalVars(*this, memo, context)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1484:    assert(false &&
call    0 never executed
        -: 1485:           "one or more local exprs do not have an explicit representation");
    #####: 1486:  auto localExprs = ArrayRef<AffineExpr>(memo).take_back(getNumLocalVars());
branch  0 never executed
branch  1 never executed
        -: 1487:
        -: 1488:  // Compute the AffineExpr lower/upper bound for this inequality.
    #####: 1489:  SmallVector<int64_t, 8> inequality = getInequality64(ineqPos);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1490:  SmallVector<int64_t, 8> bound;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1491:  bound.reserve(getNumCols() - 1);
branch  0 never executed
branch  1 never executed
        -: 1492:  // Everything other than the coefficient at `pos`.
    #####: 1493:  bound.append(inequality.begin(), inequality.begin() + pos);
call    0 never executed
    #####: 1494:  bound.append(inequality.begin() + pos + 1, inequality.end());
call    0 never executed
        -: 1495:
    #####: 1496:  if (inequality[pos] > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1497:    // Lower bound.
    #####: 1498:    std::transform(bound.begin(), bound.end(), bound.begin(),
        -: 1499:                   std::negate<int64_t>());
        -: 1500:  else
        -: 1501:    // Upper bound (which is exclusive).
    #####: 1502:    bound.back() += 1;
call    0 never executed
        -: 1503:
        -: 1504:  // Convert to AffineExpr (tree) form.
    #####: 1505:  auto boundExpr = getAffineExprFromFlatForm(bound, numDims - 1, numSyms,
    #####: 1506:                                             localExprs, context);
call    0 never executed
        -: 1507:
        -: 1508:  // Get the values to bind to this affine expr (all dims and symbols).
    #####: 1509:  SmallVector<Value, 4> operands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1510:  getValues(0, pos, &operands);
call    0 never executed
    #####: 1511:  SmallVector<Value, 4> trailingOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1512:  getValues(pos + 1, getNumDimAndSymbolVars(), &trailingOperands);
call    0 never executed
    #####: 1513:  operands.append(trailingOperands.begin(), trailingOperands.end());
call    0 never executed
    #####: 1514:  vmap.reset(AffineMap::get(numDims - 1, numSyms, boundExpr), operands);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1515:}
        -: 1516:
        -: 1517:IntegerSet
function _ZNK4mlir26FlatAffineValueConstraints15getAsIntegerSetEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####: 1518:FlatAffineValueConstraints::getAsIntegerSet(MLIRContext *context) const {
    #####: 1519:  if (getNumConstraints() == 0)
branch  0 never executed
branch  1 never executed
        -: 1520:    // Return universal set (always true): 0 == 0.
    #####: 1521:    return IntegerSet::get(getNumDimVars(), getNumSymbolVars(),
    #####: 1522:                           getAffineConstantExpr(/*constant=*/0, context),
call    0 never executed
call    1 never executed
    #####: 1523:                           /*eqFlags=*/true);
call    0 never executed
call    1 never executed
        -: 1524:
        -: 1525:  // Construct local references.
    #####: 1526:  SmallVector<AffineExpr, 8> memo(getNumVars(), AffineExpr());
call    0 never executed
        -: 1527:
    #####: 1528:  if (failed(computeLocalVars(*this, memo, context))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1529:    // Check if the local variables without an explicit representation have
        -: 1530:    // zero coefficients everywhere.
    #####: 1531:    SmallVector<unsigned> noLocalRepVars;
    #####: 1532:    unsigned numDimsSymbols = getNumDimAndSymbolVars();
    #####: 1533:    for (unsigned i = numDimsSymbols, e = getNumVars(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1534:      if (!memo[i] && !isColZero(/*pos=*/i))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1535:        noLocalRepVars.push_back(i - numDimsSymbols);
call    0 never executed
        -: 1536:    }
    #####: 1537:    if (!noLocalRepVars.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1538:      LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
        -: 1539:        llvm::dbgs() << "local variables at position(s) ";
        -: 1540:        llvm::interleaveComma(noLocalRepVars, llvm::dbgs());
        -: 1541:        llvm::dbgs() << " do not have an explicit representation in:\n";
        -: 1542:        this->dump();
        -: 1543:      });
    #####: 1544:      return IntegerSet();
branch  0 never executed
branch  1 never executed
        -: 1545:    }
        -: 1546:  }
        -: 1547:
    #####: 1548:  ArrayRef<AffineExpr> localExprs =
branch  0 never executed
branch  1 never executed
    #####: 1549:      ArrayRef<AffineExpr>(memo).take_back(getNumLocalVars());
branch  0 never executed
branch  1 never executed
        -: 1550:
        -: 1551:  // Construct the IntegerSet from the equalities/inequalities.
    #####: 1552:  unsigned numDims = getNumDimVars();
call    0 never executed
    #####: 1553:  unsigned numSyms = getNumSymbolVars();
call    0 never executed
        -: 1554:
    #####: 1555:  SmallVector<bool, 16> eqFlags(getNumConstraints());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1556:  std::fill(eqFlags.begin(), eqFlags.begin() + getNumEqualities(), true);
    #####: 1557:  std::fill(eqFlags.begin() + getNumEqualities(), eqFlags.end(), false);
        -: 1558:
    #####: 1559:  SmallVector<AffineExpr, 8> exprs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1560:  exprs.reserve(getNumConstraints());
branch  0 never executed
branch  1 never executed
        -: 1561:
    #####: 1562:  for (unsigned i = 0, e = getNumEqualities(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1563:    exprs.push_back(getAffineExprFromFlatForm(getEquality64(i), numDims,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1564:                                              numSyms, localExprs, context));
    #####: 1565:  for (unsigned i = 0, e = getNumInequalities(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1566:    exprs.push_back(getAffineExprFromFlatForm(getInequality64(i), numDims,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1567:                                              numSyms, localExprs, context));
    #####: 1568:  return IntegerSet::get(numDims, numSyms, exprs, eqFlags);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1569:}
        -: 1570:
function _ZN4mlir24alignAffineMapWithValuesENS_9AffineMapENS_10ValueRangeES1_S1_PN4llvm11SmallVectorINS_5ValueELj6EEE called 0 returned 0% blocks executed 0%
    #####: 1571:AffineMap mlir::alignAffineMapWithValues(AffineMap map, ValueRange operands,
        -: 1572:                                         ValueRange dims, ValueRange syms,
        -: 1573:                                         SmallVector<Value> *newSyms) {
    #####: 1574:  assert(operands.size() == map.getNumInputs() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1575:         "expected same number of operands and map inputs");
    #####: 1576:  MLIRContext *ctx = map.getContext();
call    0 never executed
    #####: 1577:  Builder builder(ctx);
call    0 never executed
    #####: 1578:  SmallVector<AffineExpr> dimReplacements(map.getNumDims(), {});
call    0 never executed
call    1 never executed
    #####: 1579:  unsigned numSymbols = syms.size();
call    0 never executed
    #####: 1580:  SmallVector<AffineExpr> symReplacements(map.getNumSymbols(), {});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1581:  if (newSyms) {
branch  0 never executed
branch  1 never executed
    #####: 1582:    newSyms->clear();
call    0 never executed
    #####: 1583:    newSyms->append(syms.begin(), syms.end());
call    0 never executed
        -: 1584:  }
        -: 1585:
    #####: 1586:  for (const auto &operand : llvm::enumerate(operands)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1587:    // Compute replacement dim/sym of operand.
    #####: 1588:    AffineExpr replacement;
    #####: 1589:    auto dimIt = std::find(dims.begin(), dims.end(), operand.value());
call    0 never executed
call    1 never executed
    #####: 1590:    auto symIt = std::find(syms.begin(), syms.end(), operand.value());
call    0 never executed
call    1 never executed
    #####: 1591:    if (dimIt != dims.end()) {
branch  0 never executed
branch  1 never executed
    #####: 1592:      replacement =
branch  0 never executed
branch  1 never executed
    #####: 1593:          builder.getAffineDimExpr(std::distance(dims.begin(), dimIt));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1594:    } else if (symIt != syms.end()) {
branch  0 never executed
branch  1 never executed
    #####: 1595:      replacement =
branch  0 never executed
branch  1 never executed
    #####: 1596:          builder.getAffineSymbolExpr(std::distance(syms.begin(), symIt));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1597:    } else {
        -: 1598:      // This operand is neither a dimension nor a symbol. Add it as a new
        -: 1599:      // symbol.
    #####: 1600:      replacement = builder.getAffineSymbolExpr(numSymbols++);
call    0 never executed
    #####: 1601:      if (newSyms)
branch  0 never executed
branch  1 never executed
    #####: 1602:        newSyms->push_back(operand.value());
call    0 never executed
call    1 never executed
        -: 1603:    }
        -: 1604:    // Add to corresponding replacements vector.
    #####: 1605:    if (operand.index() < map.getNumDims()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1606:      dimReplacements[operand.index()] = replacement;
branch  0 never executed
branch  1 never executed
        -: 1607:    } else {
    #####: 1608:      symReplacements[operand.index() - map.getNumDims()] = replacement;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1609:    }
        -: 1610:  }
        -: 1611:
    #####: 1612:  return map.replaceDimsAndSymbols(dimReplacements, symReplacements,
    #####: 1613:                                   dims.size(), numSymbols);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1614:}
        -: 1615:
function _ZNK4mlir18FlatAffineRelation12getDomainSetEv called 0 returned 0% blocks executed 0%
    #####: 1616:FlatAffineValueConstraints FlatAffineRelation::getDomainSet() const {
    #####: 1617:  FlatAffineValueConstraints domain = *this;
call    0 never executed
        -: 1618:  // Convert all range variables to local variables.
    #####: 1619:  domain.convertToLocal(VarKind::SetDim, getNumDomainDims(),
    #####: 1620:                        getNumDomainDims() + getNumRangeDims());
call    0 never executed
    #####: 1621:  return domain;
        -: 1622:}
        -: 1623:
function _ZNK4mlir18FlatAffineRelation11getRangeSetEv called 0 returned 0% blocks executed 0%
    #####: 1624:FlatAffineValueConstraints FlatAffineRelation::getRangeSet() const {
    #####: 1625:  FlatAffineValueConstraints range = *this;
call    0 never executed
        -: 1626:  // Convert all domain variables to local variables.
    #####: 1627:  range.convertToLocal(VarKind::SetDim, 0, getNumDomainDims());
call    0 never executed
    #####: 1628:  return range;
        -: 1629:}
        -: 1630:
function _ZN4mlir18FlatAffineRelation7composeERKS0_ called 0 returned 0% blocks executed 0%
    #####: 1631:void FlatAffineRelation::compose(const FlatAffineRelation &other) {
    #####: 1632:  assert(getNumDomainDims() == other.getNumRangeDims() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1633:         "Domain of this and range of other do not match");
    #####: 1634:  assert(std::equal(values.begin(), values.begin() + getNumDomainDims(),
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1635:                    other.values.begin() + other.getNumDomainDims()) &&
        -: 1636:         "Domain of this and range of other do not match");
        -: 1637:
    #####: 1638:  FlatAffineRelation rel = other;
call    0 never executed
        -: 1639:
        -: 1640:  // Convert `rel` from
        -: 1641:  //    [otherDomain] -> [otherRange]
        -: 1642:  // to
        -: 1643:  //    [otherDomain] -> [otherRange thisRange]
        -: 1644:  // and `this` from
        -: 1645:  //    [thisDomain] -> [thisRange]
        -: 1646:  // to
        -: 1647:  //    [otherDomain thisDomain] -> [thisRange].
    #####: 1648:  unsigned removeDims = rel.getNumRangeDims();
call    0 never executed
    #####: 1649:  insertDomainVar(0, rel.getNumDomainDims());
call    0 never executed
    #####: 1650:  rel.appendRangeVar(getNumRangeDims());
call    0 never executed
        -: 1651:
        -: 1652:  // Merge symbol and local variables.
    #####: 1653:  mergeSymbolVars(rel);
    #####: 1654:  mergeLocalVars(rel);
call    0 never executed
        -: 1655:
        -: 1656:  // Convert `rel` from [otherDomain] -> [otherRange thisRange] to
        -: 1657:  // [otherDomain] -> [thisRange] by converting first otherRange range vars
        -: 1658:  // to local vars.
    #####: 1659:  rel.convertToLocal(VarKind::SetDim, rel.getNumDomainDims(),
    #####: 1660:                     rel.getNumDomainDims() + removeDims);
call    0 never executed
        -: 1661:  // Convert `this` from [otherDomain thisDomain] -> [thisRange] to
        -: 1662:  // [otherDomain] -> [thisRange] by converting last thisDomain domain vars
        -: 1663:  // to local vars.
    #####: 1664:  convertToLocal(VarKind::SetDim, getNumDomainDims() - removeDims,
call    0 never executed
        -: 1665:                 getNumDomainDims());
        -: 1666:
    #####: 1667:  auto thisMaybeValues = getMaybeValues(VarKind::SetDim);
call    0 never executed
    #####: 1668:  auto relMaybeValues = rel.getMaybeValues(VarKind::SetDim);
call    0 never executed
        -: 1669:
        -: 1670:  // Add and match domain of `rel` to domain of `this`.
    #####: 1671:  for (unsigned i = 0, e = rel.getNumDomainDims(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1672:    if (relMaybeValues[i].has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1673:      setValue(i, relMaybeValues[i].value());
call    0 never executed
        -: 1674:  // Add and match range of `this` to range of `rel`.
    #####: 1675:  for (unsigned i = 0, e = getNumRangeDims(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1676:    unsigned rangeIdx = rel.getNumDomainDims() + i;
branch  0 never executed
branch  1 never executed
    #####: 1677:    if (thisMaybeValues[rangeIdx].has_value())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1678:      rel.setValue(rangeIdx, thisMaybeValues[rangeIdx].value());
call    0 never executed
        -: 1679:  }
        -: 1680:
        -: 1681:  // Append `this` to `rel` and simplify constraints.
    #####: 1682:  rel.append(*this);
call    0 never executed
    #####: 1683:  rel.removeRedundantLocalVars();
call    0 never executed
        -: 1684:
    #####: 1685:  *this = rel;
call    0 never executed
call    1 never executed
    #####: 1686:}
        -: 1687:
function _ZN4mlir18FlatAffineRelation7inverseEv called 0 returned 0% blocks executed 0%
    #####: 1688:void FlatAffineRelation::inverse() {
    #####: 1689:  unsigned oldDomain = getNumDomainDims();
call    0 never executed
    #####: 1690:  unsigned oldRange = getNumRangeDims();
call    0 never executed
        -: 1691:  // Add new range vars.
    #####: 1692:  appendRangeVar(oldDomain);
        -: 1693:  // Swap new vars with domain.
    #####: 1694:  for (unsigned i = 0; i < oldDomain; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1695:    swapVar(i, oldDomain + oldRange + i);
call    0 never executed
        -: 1696:  // Remove the swapped domain.
    #####: 1697:  removeVarRange(0, oldDomain);
call    0 never executed
        -: 1698:  // Set domain and range as inverse.
    #####: 1699:  numDomainDims = oldRange;
    #####: 1700:  numRangeDims = oldDomain;
    #####: 1701:}
        -: 1702:
function _ZN4mlir18FlatAffineRelation15insertDomainVarEjj called 0 returned 0% blocks executed 0%
    #####: 1703:void FlatAffineRelation::insertDomainVar(unsigned pos, unsigned num) {
    #####: 1704:  assert(pos <= getNumDomainDims() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1705:         "Var cannot be inserted at invalid position");
    #####: 1706:  insertDimVar(pos, num);
call    0 never executed
    #####: 1707:  numDomainDims += num;
    #####: 1708:}
        -: 1709:
function _ZN4mlir18FlatAffineRelation14insertRangeVarEjj called 0 returned 0% blocks executed 0%
    #####: 1710:void FlatAffineRelation::insertRangeVar(unsigned pos, unsigned num) {
    #####: 1711:  assert(pos <= getNumRangeDims() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1712:         "Var cannot be inserted at invalid position");
    #####: 1713:  insertDimVar(getNumDomainDims() + pos, num);
call    0 never executed
    #####: 1714:  numRangeDims += num;
    #####: 1715:}
        -: 1716:
function _ZN4mlir18FlatAffineRelation15appendDomainVarEj called 0 returned 0% blocks executed 0%
    #####: 1717:void FlatAffineRelation::appendDomainVar(unsigned num) {
    #####: 1718:  insertDimVar(getNumDomainDims(), num);
call    0 never executed
    #####: 1719:  numDomainDims += num;
    #####: 1720:}
        -: 1721:
function _ZN4mlir18FlatAffineRelation14appendRangeVarEj called 0 returned 0% blocks executed 0%
    #####: 1722:void FlatAffineRelation::appendRangeVar(unsigned num) {
    #####: 1723:  insertDimVar(getNumDimVars(), num);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1724:  numRangeDims += num;
call    0 never executed
    #####: 1725:}
        -: 1726:
function _ZN4mlir18FlatAffineRelation14removeVarRangeENS_10presburger7VarKindEjj called 0 returned 0% blocks executed 0%
    #####: 1727:void FlatAffineRelation::removeVarRange(VarKind kind, unsigned varStart,
        -: 1728:                                        unsigned varLimit) {
    #####: 1729:  assert(varLimit <= getNumVarKind(kind));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1730:  if (varStart >= varLimit)
branch  0 never executed
branch  1 never executed
        -: 1731:    return;
        -: 1732:
    #####: 1733:  FlatAffineValueConstraints::removeVarRange(kind, varStart, varLimit);
call    0 never executed
        -: 1734:
        -: 1735:  // If kind is not SetDim, domain and range don't need to be updated.
    #####: 1736:  if (kind != VarKind::SetDim)
branch  0 never executed
branch  1 never executed
        -: 1737:    return;
        -: 1738:
        -: 1739:  // Compute number of domain and range variables to remove. This is done by
        -: 1740:  // intersecting the range of domain/range vars with range of vars to remove.
    #####: 1741:  unsigned intersectDomainLHS = std::min(varLimit, getNumDomainDims());
branch  0 never executed
branch  1 never executed
    #####: 1742:  unsigned intersectDomainRHS = varStart;
    #####: 1743:  unsigned intersectRangeLHS = std::min(varLimit, getNumDimVars());
branch  0 never executed
branch  1 never executed
    #####: 1744:  unsigned intersectRangeRHS = std::max(varStart, getNumDomainDims());
branch  0 never executed
branch  1 never executed
        -: 1745:
    #####: 1746:  if (intersectDomainLHS > intersectDomainRHS)
branch  0 never executed
branch  1 never executed
    #####: 1747:    numDomainDims -= intersectDomainLHS - intersectDomainRHS;
    #####: 1748:  if (intersectRangeLHS > intersectRangeRHS)
branch  0 never executed
branch  1 never executed
    #####: 1749:    numRangeDims -= intersectRangeLHS - intersectRangeRHS;
        -: 1750:}
        -: 1751:
function _ZN4mlir18getRelationFromMapERNS_9AffineMapERNS_18FlatAffineRelationE called 0 returned 0% blocks executed 0%
    #####: 1752:LogicalResult mlir::getRelationFromMap(AffineMap &map,
        -: 1753:                                       FlatAffineRelation &rel) {
        -: 1754:  // Get flattened affine expressions.
    #####: 1755:  std::vector<SmallVector<int64_t, 8>> flatExprs;
call    0 never executed
call    1 never executed
    #####: 1756:  FlatAffineValueConstraints localVarCst;
call    0 never executed
    #####: 1757:  if (failed(getFlattenedAffineExprs(map, &flatExprs, &localVarCst)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1758:    return failure();
        -: 1759:
    #####: 1760:  unsigned oldDimNum = localVarCst.getNumDimVars();
call    0 never executed
    #####: 1761:  unsigned oldCols = localVarCst.getNumCols();
call    0 never executed
    #####: 1762:  unsigned numRangeVars = map.getNumResults();
call    0 never executed
    #####: 1763:  unsigned numDomainVars = map.getNumDims();
call    0 never executed
        -: 1764:
        -: 1765:  // Add range as the new expressions.
    #####: 1766:  localVarCst.appendDimVar(numRangeVars);
call    0 never executed
        -: 1767:
        -: 1768:  // Add equalities between source and range.
    #####: 1769:  SmallVector<int64_t, 8> eq(localVarCst.getNumCols());
call    0 never executed
call    1 never executed
    #####: 1770:  for (unsigned i = 0, e = map.getNumResults(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1771:    // Zero fill.
    #####: 1772:    std::fill(eq.begin(), eq.end(), 0);
        -: 1773:    // Fill equality.
    #####: 1774:    for (unsigned j = 0, f = oldDimNum; j < f; ++j)
branch  0 never executed
branch  1 never executed
    #####: 1775:      eq[j] = flatExprs[i][j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1776:    for (unsigned j = oldDimNum, f = oldCols; j < f; ++j)
branch  0 never executed
branch  1 never executed
    #####: 1777:      eq[j + numRangeVars] = flatExprs[i][j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1778:    // Set this dimension to -1 to equate lhs and rhs and add equality.
    #####: 1779:    eq[numDomainVars + i] = -1;
branch  0 never executed
branch  1 never executed
    #####: 1780:    localVarCst.addEquality(eq);
call    0 never executed
        -: 1781:  }
        -: 1782:
        -: 1783:  // Create relation and return success.
    #####: 1784:  rel = FlatAffineRelation(numDomainVars, numRangeVars, localVarCst);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1785:  return success();
branch  0 never executed
branch  1 never executed
        -: 1786:}
        -: 1787:
function _ZN4mlir18getRelationFromMapERKNS_14AffineValueMapERNS_18FlatAffineRelationE called 0 returned 0% blocks executed 0%
    #####: 1788:LogicalResult mlir::getRelationFromMap(const AffineValueMap &map,
        -: 1789:                                       FlatAffineRelation &rel) {
        -: 1790:
    #####: 1791:  AffineMap affineMap = map.getAffineMap();
call    0 never executed
    #####: 1792:  if (failed(getRelationFromMap(affineMap, rel)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1793:    return failure();
        -: 1794:
        -: 1795:  // Set symbol values for domain dimensions and symbols.
    #####: 1796:  for (unsigned i = 0, e = rel.getNumDomainDims(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1797:    rel.setValue(i, map.getOperand(i));
call    0 never executed
call    1 never executed
    #####: 1798:  for (unsigned i = rel.getNumDimVars(), e = rel.getNumDimAndSymbolVars();
    #####: 1799:       i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1800:    rel.setValue(i, map.getOperand(i - rel.getNumRangeDims()));
call    0 never executed
call    1 never executed
        -: 1801:
    #####: 1802:  return success();
        -: 1803:}
        -: 1804:
        -: 1805:LogicalResult
function _ZN4mlir29getMultiAffineFunctionFromMapENS_9AffineMapERNS_10presburger19MultiAffineFunctionE called 0 returned 0% blocks executed 0%
    #####: 1806:mlir::getMultiAffineFunctionFromMap(AffineMap map,
        -: 1807:                                    MultiAffineFunction &multiAff) {
    #####: 1808:  FlatAffineValueConstraints cst;
call    0 never executed
call    1 never executed
    #####: 1809:  std::vector<SmallVector<int64_t, 8>> flattenedExprs;
call    0 never executed
    #####: 1810:  LogicalResult result = getFlattenedAffineExprs(map, &flattenedExprs, &cst);
call    0 never executed
        -: 1811:
    #####: 1812:  if (result.failed())
branch  0 never executed
branch  1 never executed
    #####: 1813:    return failure();
        -: 1814:
    #####: 1815:  DivisionRepr divs = cst.getLocalReprs();
call    0 never executed
call    1 never executed
    #####: 1816:  assert(divs.hasAllReprs() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1817:         "AffineMap cannot produce divs without local representation");
        -: 1818:
        -: 1819:  // TODO: We shouldn't have to do this conversion.
    #####: 1820:  Matrix mat(map.getNumResults(), map.getNumInputs() + divs.getNumDivs() + 1);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1821:  for (unsigned i = 0, e = flattenedExprs.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1822:    for (unsigned j = 0, f = flattenedExprs[i].size(); j < f; ++j)
branch  0 never executed
branch  1 never executed
    #####: 1823:      mat(i, j) = flattenedExprs[i][j];
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1824:
    #####: 1825:  multiAff = MultiAffineFunction(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1826:      PresburgerSpace::getRelationSpace(map.getNumDims(), map.getNumResults(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1827:                                        map.getNumSymbols(), divs.getNumDivs()),
    #####: 1828:      mat, divs);
call    0 never executed
        -: 1829:
    #####: 1830:  return success();
call    0 never executed
        -: 1831:}
