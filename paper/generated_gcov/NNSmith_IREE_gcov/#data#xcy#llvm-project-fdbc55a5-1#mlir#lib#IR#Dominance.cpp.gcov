        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/Dominance.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Dominance.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/Dominance.cpp.gcda
        -:    0:Runs:325565
        -:    1://===- Dominance.cpp - Dominator analysis for CFGs ------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Implementation of dominance related classes and instantiations of extern
        -:   10:// templates.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/Dominance.h"
        -:   15:#include "mlir/IR/Operation.h"
        -:   16:#include "mlir/IR/RegionKindInterface.h"
        -:   17:#include "llvm/ADT/DenseMap.h"
        -:   18:#include "llvm/Support/GenericDomTreeConstruction.h"
        -:   19:
        -:   20:using namespace mlir;
        -:   21:using namespace mlir::detail;
        -:   22:
        -:   23:template class llvm::DominatorTreeBase<Block, /*IsPostDom=*/false>;
        -:   24:template class llvm::DominatorTreeBase<Block, /*IsPostDom=*/true>;
        -:   25:template class llvm::DomTreeNodeBase<Block>;
        -:   26:
        -:   27://===----------------------------------------------------------------------===//
        -:   28:// DominanceInfoBase
        -:   29://===----------------------------------------------------------------------===//
        -:   30:
        -:   31:template <bool IsPostDom>
  1406987:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
 3421568*:   33:  for (auto entry : dominanceInfos)
  609265*:   34:    delete entry.second.getPointer();
  1405397:   35:}
------------------
_ZN4mlir6detail17DominanceInfoBaseILb0EED2Ev:
function _ZN4mlir6detail17DominanceInfoBaseILb0EED2Ev called 1402362 returned 100% blocks executed 100%
  1402362:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
  3412323:   33:  for (auto entry : dominanceInfos)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 30% (fallthrough)
branch  4 taken 70%
call    5 returned 100%
call    6 returned 100%
   609265:   34:    delete entry.second.getPointer();
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
  1400780:   35:}
call    0 returned 100%
------------------
_ZN4mlir6detail17DominanceInfoBaseILb1EED2Ev:
function _ZN4mlir6detail17DominanceInfoBaseILb1EED2Ev called 4625 returned 100% blocks executed 58%
     4625:   32:DominanceInfoBase<IsPostDom>::~DominanceInfoBase() {
    9245*:   33:  for (auto entry : dominanceInfos)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
    #####:   34:    delete entry.second.getPointer();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
     4617:   35:}
call    0 returned 100%
------------------
        -:   36:
        -:   37:/// Return the dom tree and "hasSSADominance" bit for the given region.  The
        -:   38:/// DomTree will be null for single-block regions.  This lazily constructs the
        -:   39:/// DomTree on demand when needsDomTree=true.
        -:   40:template <bool IsPostDom>
 7067865*:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
 7067865*:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
 7067893*:   46:  auto &entry = itAndInserted.first->second;
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
 7067899*:   51:  if (!itAndInserted.second) {
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
 6458633*:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
    #####:   55:      auto *domTree = new DomTree();
    #####:   56:      domTree->recalculate(*region);
    #####:   57:      entry.setPointer(domTree);
        -:   58:    }
 6458633*:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
  609266*:   64:  if (!region->hasOneBlock()) {
     939*:   65:    auto *domTree = new DomTree();
     939*:   66:    domTree->recalculate(*region);
     939*:   67:    entry.setPointer(domTree);
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
     939*:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
  608327*:   73:  if (Operation *parentOp = region->getParentOp()) {
  608327*:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
  608327*:   75:      entry.setInt(false);
  608327*:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
  608327*:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
        -:   80:    }
        -:   81:  }
        -:   82:
  608327*:   83:  return entry;
        -:   84:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE16getDominanceInfoEPNS_6RegionEb:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE16getDominanceInfoEPNS_6RegionEb called 7067865 returned 100% blocks executed 77%
  7067865:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
  7067865:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
call    0 returned 100%
call    1 returned 100%
  7067893:   46:  auto &entry = itAndInserted.first->second;
call    0 returned 100%
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
  7067899:   51:  if (!itAndInserted.second) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
 6458633*:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####:   55:      auto *domTree = new DomTree();
call    0 never executed
call    1 never executed
    #####:   56:      domTree->recalculate(*region);
call    0 never executed
    #####:   57:      entry.setPointer(domTree);
call    0 never executed
        -:   58:    }
  6458633:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
   609266:   64:  if (!region->hasOneBlock()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      939:   65:    auto *domTree = new DomTree();
call    0 returned 100%
call    1 returned 100%
      939:   66:    domTree->recalculate(*region);
call    0 returned 100%
      939:   67:    entry.setPointer(domTree);
call    0 returned 100%
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
      939:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
   608327:   73:  if (Operation *parentOp = region->getParentOp()) {
branch  0 taken 100%
branch  1 taken 0%
   608327:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   608327:   75:      entry.setInt(false);
   608327:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
   608327:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
call    0 returned 100%
call    1 returned 100%
        -:   80:    }
        -:   81:  }
        -:   82:
   608327:   83:  return entry;
        -:   84:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE16getDominanceInfoEPNS_6RegionEb:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE16getDominanceInfoEPNS_6RegionEb called 0 returned 0% blocks executed 0%
    #####:   41:auto DominanceInfoBase<IsPostDom>::getDominanceInfo(Region *region,
        -:   42:                                                    bool needsDomTree) const
        -:   43:    -> llvm::PointerIntPair<DomTree *, 1, bool> {
        -:   44:  // Check to see if we already have this information.
    #####:   45:  auto itAndInserted = dominanceInfos.insert({region, {nullptr, true}});
call    0 never executed
call    1 never executed
    #####:   46:  auto &entry = itAndInserted.first->second;
call    0 never executed
        -:   47:
        -:   48:  // This method builds on knowledge that multi-block regions always have
        -:   49:  // SSADominance.  Graph regions are only allowed to be single-block regions,
        -:   50:  // but of course single-block regions may also have SSA dominance.
    #####:   51:  if (!itAndInserted.second) {
branch  0 never executed
branch  1 never executed
        -:   52:    // We do have it, so we know the 'hasSSADominance' bit is correct, but we
        -:   53:    // may not have constructed a DominatorTree yet.  If we need it, build it.
    #####:   54:    if (needsDomTree && !entry.getPointer() && !region->hasOneBlock()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   55:      auto *domTree = new DomTree();
call    0 never executed
call    1 never executed
    #####:   56:      domTree->recalculate(*region);
call    0 never executed
    #####:   57:      entry.setPointer(domTree);
call    0 never executed
        -:   58:    }
    #####:   59:    return entry;
        -:   60:  }
        -:   61:
        -:   62:  // Nope, lazily construct it.  Create a DomTree if this is a multi-block
        -:   63:  // region.
    #####:   64:  if (!region->hasOneBlock()) {
branch  0 never executed
branch  1 never executed
    #####:   65:    auto *domTree = new DomTree();
call    0 never executed
call    1 never executed
    #####:   66:    domTree->recalculate(*region);
call    0 never executed
    #####:   67:    entry.setPointer(domTree);
call    0 never executed
        -:   68:    // Multiblock regions always have SSA dominance, leave `second` set to true.
    #####:   69:    return entry;
        -:   70:  }
        -:   71:
        -:   72:  // Single block regions have a more complicated predicate.
    #####:   73:  if (Operation *parentOp = region->getParentOp()) {
branch  0 never executed
branch  1 never executed
    #####:   74:    if (!parentOp->isRegistered()) { // We don't know about unregistered ops.
branch  0 never executed
branch  1 never executed
    #####:   75:      entry.setInt(false);
    #####:   76:    } else if (auto regionKindItf = dyn_cast<RegionKindInterface>(parentOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   77:      // Registered ops can opt-out of SSA dominance with
        -:   78:      // RegionKindInterface.
    #####:   79:      entry.setInt(regionKindItf.hasSSADominance(region->getRegionNumber()));
call    0 never executed
call    1 never executed
        -:   80:    }
        -:   81:  }
        -:   82:
    #####:   83:  return entry;
        -:   84:}
------------------
        -:   85:
        -:   86:/// Return the ancestor block enclosing the specified block.  This returns null
        -:   87:/// if we reach the top of the hierarchy.
    #####:   88:static Block *getAncestorBlock(Block *block) {
    #####:   89:  if (Operation *ancestorOp = block->getParentOp())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:   90:    return ancestorOp->getBlock();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   91:  return nullptr;
        -:   92:}
        -:   93:
        -:   94:/// Walks up the list of containers of the given block and calls the
        -:   95:/// user-defined traversal function for every pair of a region and block that
        -:   96:/// could be found during traversal. If the user-defined function returns true
        -:   97:/// for a given pair, traverseAncestors will return the current block. Nullptr
        -:   98:/// otherwise.
        -:   99:template <typename FuncT>
    #####:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
    #####:  101:  do {
        -:  102:    // Invoke the user-defined traversal function for each block.
    #####:  103:    if (func(block))
    #####:  104:      return block;
    #####:  105:  } while ((block = getAncestorBlock(block)));
        -:  106:  return nullptr;
        -:  107:}
------------------
_Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E0_ES2_S2_RKT_:
function _Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E0_ES2_S2_RKT_ called 0 returned 0% blocks executed 0%
    #####:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
    #####:  101:  do {
call    0 never executed
        -:  102:    // Invoke the user-defined traversal function for each block.
    #####:  103:    if (func(block))
    #####:  104:      return block;
    #####:  105:  } while ((block = getAncestorBlock(block)));
branch  0 never executed
branch  1 never executed
        -:  106:  return nullptr;
        -:  107:}
------------------
_Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E_ES2_S2_RKT_:
function _Z17traverseAncestorsIZL24tryGetBlocksInSameRegionRPN4mlir5BlockES3_EUlS2_E_ES2_S2_RKT_ called 0 returned 0% blocks executed 0%
    #####:  100:static Block *traverseAncestors(Block *block, const FuncT &func) {
    #####:  101:  do {
call    0 never executed
        -:  102:    // Invoke the user-defined traversal function for each block.
    #####:  103:    if (func(block))
    #####:  104:      return block;
    #####:  105:  } while ((block = getAncestorBlock(block)));
branch  0 never executed
branch  1 never executed
        -:  106:  return nullptr;
        -:  107:}
------------------
        -:  108:
        -:  109:/// Tries to update the given block references to live in the same region by
        -:  110:/// exploring the relationship of both blocks with respect to their regions.
function _ZL24tryGetBlocksInSameRegionRPN4mlir5BlockES2_ called 0 returned 0% blocks executed 0%
    #####:  111:static bool tryGetBlocksInSameRegion(Block *&a, Block *&b) {
        -:  112:  // If both block do not live in the same region, we will have to check their
        -:  113:  // parent operations.
    #####:  114:  Region *aRegion = a->getParent();
call    0 never executed
    #####:  115:  Region *bRegion = b->getParent();
call    0 never executed
    #####:  116:  if (aRegion == bRegion)
branch  0 never executed
branch  1 never executed
        -:  117:    return true;
        -:  118:
        -:  119:  // Iterate over all ancestors of `a`, counting the depth of `a`. If one of
        -:  120:  // `a`s ancestors are in the same region as `b`, then we stop early because we
        -:  121:  // found our NCA.
    #####:  122:  size_t aRegionDepth = 0;
    #####:  123:  if (Block *aResult = traverseAncestors(a, [&](Block *block) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  124:        ++aRegionDepth;
    #####:  125:        return block->getParent() == bRegion;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  126:      })) {
    #####:  127:    a = aResult;
    #####:  128:    return true;
        -:  129:  }
        -:  130:
        -:  131:  // Iterate over all ancestors of `b`, counting the depth of `b`. If one of
        -:  132:  // `b`s ancestors are in the same region as `a`, then we stop early because
        -:  133:  // we found our NCA.
    #####:  134:  size_t bRegionDepth = 0;
    #####:  135:  if (Block *bResult = traverseAncestors(b, [&](Block *block) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  136:        ++bRegionDepth;
    #####:  137:        return block->getParent() == aRegion;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  138:      })) {
    #####:  139:    b = bResult;
    #####:  140:    return true;
        -:  141:  }
        -:  142:
        -:  143:  // Otherwise we found two blocks that are siblings at some level.  Walk the
        -:  144:  // deepest one up until we reach the top or find an NCA.
    #####:  145:  while (true) {
    #####:  146:    if (aRegionDepth > bRegionDepth) {
branch  0 never executed
branch  1 never executed
    #####:  147:      a = getAncestorBlock(a);
call    0 never executed
    #####:  148:      --aRegionDepth;
    #####:  149:    } else if (aRegionDepth < bRegionDepth) {
branch  0 never executed
branch  1 never executed
    #####:  150:      b = getAncestorBlock(b);
call    0 never executed
    #####:  151:      --bRegionDepth;
        -:  152:    } else {
        -:  153:      break;
        -:  154:    }
        -:  155:  }
        -:  156:
        -:  157:  // If we found something with the same level, then we can march both up at the
        -:  158:  // same time from here on out.
    #####:  159:  while (a) {
branch  0 never executed
branch  1 never executed
        -:  160:    // If they are at the same level, and have the same parent region then we
        -:  161:    // succeeded.
    #####:  162:    if (a->getParent() == b->getParent())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  163:      return true;
        -:  164:
    #####:  165:    a = getAncestorBlock(a);
call    0 never executed
    #####:  166:    b = getAncestorBlock(b);
call    0 never executed
        -:  167:  }
        -:  168:
        -:  169:  // They don't share an NCA, perhaps they are in different modules or
        -:  170:  // something.
        -:  171:  return false;
        -:  172:}
        -:  173:
        -:  174:template <bool IsPostDom>
        -:  175:Block *
    #####:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
    #####:  179:  if (!a || !b)
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
    #####:  183:  if (a == b)
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
    #####:  187:  if (!tryGetBlocksInSameRegion(a, b))
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
    #####:  192:  if (a == b)
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
        -:  198:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE26findNearestCommonDominatorEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE26findNearestCommonDominatorEPNS_5BlockES4_ called 0 returned 0% blocks executed 0%
    #####:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
    #####:  179:  if (!a || !b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
    #####:  183:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
    #####:  187:  if (!tryGetBlocksInSameRegion(a, b))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
    #####:  192:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  198:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE26findNearestCommonDominatorEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE26findNearestCommonDominatorEPNS_5BlockES4_ called 0 returned 0% blocks executed 0%
    #####:  176:DominanceInfoBase<IsPostDom>::findNearestCommonDominator(Block *a,
        -:  177:                                                         Block *b) const {
        -:  178:  // If either a or b are null, then conservatively return nullptr.
    #####:  179:  if (!a || !b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  180:    return nullptr;
        -:  181:
        -:  182:  // If they are the same block, then we are done.
    #####:  183:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  184:    return a;
        -:  185:
        -:  186:  // Try to find blocks that are in the same region.
    #####:  187:  if (!tryGetBlocksInSameRegion(a, b))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  188:    return nullptr;
        -:  189:
        -:  190:  // If the common ancestor in a common region is the same block, then return
        -:  191:  // it.
    #####:  192:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  193:    return a;
        -:  194:
        -:  195:  // Otherwise, there must be multiple blocks in the region, check the
        -:  196:  // DomTree.
    #####:  197:  return getDomTree(a->getParent()).findNearestCommonDominator(a, b);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  198:}
------------------
        -:  199:
        -:  200:/// Return true if the specified block A properly dominates block B.
        -:  201:template <bool IsPostDom>
    4695*:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
    4695*:  203:  assert(a && b && "null blocks not allowed");
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
    4695*:  206:  if (a == b)
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
    4695*:  212:  Region *regionA = a->getParent();
    4695*:  213:  if (regionA != b->getParent()) {
    #####:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
    #####:  216:    if (b == nullptr)
    #####:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
    #####:  221:    if (a == b)
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
    4695*:  226:  return getDomTree(regionA).properlyDominates(a, b);
        -:  227:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE17properlyDominatesEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE17properlyDominatesEPNS_5BlockES4_ called 4695 returned 100% blocks executed 57%
     4695:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
    4695*:  203:  assert(a && b && "null blocks not allowed");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
     4695:  206:  if (a == b)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
     4695:  212:  Region *regionA = a->getParent();
call    0 returned 100%
     4695:  213:  if (regionA != b->getParent()) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
    #####:  216:    if (b == nullptr)
branch  0 never executed
branch  1 never executed
    #####:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
    #####:  221:    if (a == b)
branch  0 never executed
branch  1 never executed
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
     4695:  226:  return getDomTree(regionA).properlyDominates(a, b);
call    0 returned 100%
call    1 returned 100%
        -:  227:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE17properlyDominatesEPNS_5BlockES4_:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE17properlyDominatesEPNS_5BlockES4_ called 0 returned 0% blocks executed 0%
    #####:  202:bool DominanceInfoBase<IsPostDom>::properlyDominates(Block *a, Block *b) const {
    #####:  203:  assert(a && b && "null blocks not allowed");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  204:
        -:  205:  // A block dominates itself but does not properly dominate itself.
    #####:  206:  if (a == b)
branch  0 never executed
branch  1 never executed
        -:  207:    return false;
        -:  208:
        -:  209:  // If both blocks are not in the same region, `a` properly dominates `b` if
        -:  210:  // `b` is defined in an operation region that (recursively) ends up being
        -:  211:  // dominated by `a`. Walk up the list of containers enclosing B.
    #####:  212:  Region *regionA = a->getParent();
call    0 never executed
    #####:  213:  if (regionA != b->getParent()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:    b = regionA ? regionA->findAncestorBlockInRegion(*b) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  215:    // If we could not find a valid block b then it is a not a dominator.
    #####:  216:    if (b == nullptr)
branch  0 never executed
branch  1 never executed
    #####:  217:      return false;
        -:  218:
        -:  219:    // Check to see if the ancestor of `b` is the same block as `a`.  A properly
        -:  220:    // dominates B if it contains an op that contains the B block.
    #####:  221:    if (a == b)
branch  0 never executed
branch  1 never executed
        -:  222:      return true;
        -:  223:  }
        -:  224:
        -:  225:  // Otherwise, they are two different blocks in the same region, use DomTree.
    #####:  226:  return getDomTree(regionA).properlyDominates(a, b);
call    0 never executed
call    1 never executed
        -:  227:}
------------------
        -:  228:
        -:  229:/// Return true if the specified block is reachable from the entry block of
        -:  230:/// its region.
        -:  231:template <bool IsPostDom>
 1340121*:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
 1340121*:  234:  Region *region = a->getParent();
 1340113*:  235:  if (&region->front() == a)
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
    3756*:  239:  return getDomTree(region).isReachableFromEntry(a);
        -:  240:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb0EE20isReachableFromEntryEPNS_5BlockE:
function _ZNK4mlir6detail17DominanceInfoBaseILb0EE20isReachableFromEntryEPNS_5BlockE called 1340121 returned 100% blocks executed 100%
  1340121:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
  1340121:  234:  Region *region = a->getParent();
call    0 returned 100%
call    1 returned 100%
  1340113:  235:  if (&region->front() == a)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
     3756:  239:  return getDomTree(region).isReachableFromEntry(a);
call    0 returned 100%
call    1 returned 100%
        -:  240:}
------------------
_ZNK4mlir6detail17DominanceInfoBaseILb1EE20isReachableFromEntryEPNS_5BlockE:
function _ZNK4mlir6detail17DominanceInfoBaseILb1EE20isReachableFromEntryEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####:  232:bool DominanceInfoBase<IsPostDom>::isReachableFromEntry(Block *a) const {
        -:  233:  // If this is the first block in its region, then it is obviously reachable.
    #####:  234:  Region *region = a->getParent();
call    0 never executed
call    1 never executed
    #####:  235:  if (&region->front() == a)
branch  0 never executed
branch  1 never executed
        -:  236:    return true;
        -:  237:
        -:  238:  // Otherwise this is some block in a multi-block region.  Check DomTree.
    #####:  239:  return getDomTree(region).isReachableFromEntry(a);
call    0 never executed
        -:  240:}
------------------
        -:  241:
        -:  242:template class detail::DominanceInfoBase</*IsPostDom=*/true>;
        -:  243:template class detail::DominanceInfoBase</*IsPostDom=*/false>;
        -:  244:
        -:  245://===----------------------------------------------------------------------===//
        -:  246:// DominanceInfo
        -:  247://===----------------------------------------------------------------------===//
        -:  248:
        -:  249:/// Return true if operation `a` properly dominates operation `b`.  The
        -:  250:/// 'enclosingOpOk' flag says whether we should return true if the `b` op is
        -:  251:/// enclosed by a region on 'a'.
function _ZNK4mlir13DominanceInfo21properlyDominatesImplEPNS_9OperationES2_b called 7056756 returned 100% blocks executed 70%
  7056756:  252:bool DominanceInfo::properlyDominatesImpl(Operation *a, Operation *b,
        -:  253:                                          bool enclosingOpOk) const {
  7056756:  254:  Block *aBlock = a->getBlock(), *bBlock = b->getBlock();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 7056756*:  255:  assert(aBlock && bBlock && "operations must be in a block");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  256:
        -:  257:  // An instruction dominates, but does not properlyDominate, itself unless this
        -:  258:  // is a graph region.
  7056756:  259:  if (a == b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  260:    return !hasSSADominance(aBlock);
call    0 never executed
        -:  261:
        -:  262:  // If these ops are in different regions, then normalize one into the other.
  7056756:  263:  Region *aRegion = aBlock->getParent();
call    0 returned 100%
  7056756:  264:  if (aRegion != bBlock->getParent()) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        -:  265:    // Scoot up b's region tree until we find an operation in A's region that
        -:  266:    // encloses it.  If this fails, then we know there is no post-dom relation.
    1878*:  267:    b = aRegion ? aRegion->findAncestorOpInRegion(*b) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
     1878:  268:    if (!b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  269:      return false;
     1878:  270:    bBlock = b->getBlock();
call    0 returned 100%
    1878*:  271:    assert(bBlock->getParent() == aRegion);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  272:
        -:  273:    // If 'a' encloses 'b', then we consider it to dominate.
     1878:  274:    if (a == b && enclosingOpOk)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  275:      return true;
        -:  276:  }
        -:  277:
        -:  278:  // Ok, they are in the same region now.
  7056750:  279:  if (aBlock == bBlock) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  280:    // Dominance changes based on the region type. In a region with SSA
        -:  281:    // dominance, uses inside the same block must follow defs. In other
        -:  282:    // regions kinds, uses and defs can come in any order inside a block.
  7056750:  283:    if (hasSSADominance(aBlock)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken -0%
        -:  284:      // If the blocks are the same, then check if b is before a in the block.
  7056779:  285:      return a->isBeforeInBlock(b);
call    0 returned 100%
        -:  286:    }
        -:  287:    return true;
        -:  288:  }
        -:  289:
        -:  290:  // If the blocks are different, use DomTree to resolve the query.
    #####:  291:  return getDomTree(aRegion).properlyDominates(aBlock, bBlock);
call    0 never executed
call    1 never executed
        -:  292:}
        -:  293:
        -:  294:/// Return true if the `a` value properly dominates operation `b`, i.e if the
        -:  295:/// operation that defines `a` properlyDominates `b` and the operation that
        -:  296:/// defines `a` does not contain `b`.
function _ZNK4mlir13DominanceInfo17properlyDominatesENS_5ValueEPNS_9OperationE called 8728818 returned 100% blocks executed 100%
  8728818:  297:bool DominanceInfo::properlyDominates(Value a, Operation *b) const {
        -:  298:  // block arguments properly dominate all operations in their own block, so
        -:  299:  // we use a dominates check here, not a properlyDominates check.
  8728818:  300:  if (auto blockArg = dyn_cast<BlockArgument>(a))
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
  1672092:  301:    return dominates(blockArg.getOwner(), b->getBlock());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  302:
        -:  303:  // `a` properlyDominates `b` if the operation defining `a` properlyDominates
        -:  304:  // `b`, but `a` does not itself enclose `b` in one of its regions.
  7056763:  305:  return properlyDominatesImpl(a.getDefiningOp(), b, /*enclosingOpOk=*/false);
call    0 returned 100%
call    1 returned 100%
        -:  306:}
        -:  307:
        -:  308://===----------------------------------------------------------------------===//
        -:  309:// PostDominanceInfo
        -:  310://===----------------------------------------------------------------------===//
        -:  311:
        -:  312:/// Returns true if statement 'a' properly postdominates statement b.
function _ZN4mlir17PostDominanceInfo21properlyPostDominatesEPNS_9OperationES2_ called 0 returned 0% blocks executed 0%
    #####:  313:bool PostDominanceInfo::properlyPostDominates(Operation *a, Operation *b) {
    #####:  314:  auto *aBlock = a->getBlock(), *bBlock = b->getBlock();
branch  0 never executed
branch  1 never executed
    #####:  315:  assert(aBlock && bBlock && "operations must be in a block");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  316:
        -:  317:  // An instruction postDominates, but does not properlyPostDominate, itself
        -:  318:  // unless this is a graph region.
    #####:  319:  if (a == b)
branch  0 never executed
branch  1 never executed
    #####:  320:    return !hasSSADominance(aBlock);
call    0 never executed
        -:  321:
        -:  322:  // If these ops are in different regions, then normalize one into the other.
    #####:  323:  Region *aRegion = aBlock->getParent();
call    0 never executed
    #####:  324:  if (aRegion != bBlock->getParent()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  325:    // Scoot up b's region tree until we find an operation in A's region that
        -:  326:    // encloses it.  If this fails, then we know there is no post-dom relation.
    #####:  327:    b = aRegion ? aRegion->findAncestorOpInRegion(*b) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  328:    if (!b)
branch  0 never executed
branch  1 never executed
    #####:  329:      return false;
    #####:  330:    bBlock = b->getBlock();
call    0 never executed
    #####:  331:    assert(bBlock->getParent() == aRegion);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  332:
        -:  333:    // If 'a' encloses 'b', then we consider it to postdominate.
    #####:  334:    if (a == b)
branch  0 never executed
branch  1 never executed
        -:  335:      return true;
        -:  336:  }
        -:  337:
        -:  338:  // Ok, they are in the same region.  If they are in the same block, check if b
        -:  339:  // is before a in the block.
    #####:  340:  if (aBlock == bBlock) {
branch  0 never executed
branch  1 never executed
        -:  341:    // Dominance changes based on the region type.
    #####:  342:    if (hasSSADominance(aBlock)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  343:      // If the blocks are the same, then check if b is before a in the block.
    #####:  344:      return b->isBeforeInBlock(a);
call    0 never executed
        -:  345:    }
        -:  346:    return true;
        -:  347:  }
        -:  348:
        -:  349:  // If the blocks are different, check if a's block post dominates b's.
    #####:  350:  return getDomTree(aRegion).properlyDominates(aBlock, bBlock);
call    0 never executed
call    1 never executed
        -:  351:}
