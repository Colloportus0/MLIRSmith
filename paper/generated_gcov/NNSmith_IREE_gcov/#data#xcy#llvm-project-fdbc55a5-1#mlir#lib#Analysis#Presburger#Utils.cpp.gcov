        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Analysis/Presburger/Utils.cpp
        -:    0:Graph:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/Presburger/CMakeFiles/obj.MLIRPresburger.dir/Utils.cpp.gcda
        -:    0:Runs:325594
        -:    1://===- Utils.cpp - General utilities for Presburger library ---------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Utility functions required by the Presburger Library.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Analysis/Presburger/Utils.h"
        -:   14:#include "mlir/Analysis/Presburger/IntegerRelation.h"
        -:   15:#include "mlir/Analysis/Presburger/MPInt.h"
        -:   16:#include "mlir/Support/LogicalResult.h"
        -:   17:#include "mlir/Support/MathExtras.h"
        -:   18:#include <numeric>
        -:   19:
        -:   20:#include <numeric>
        -:   21:
        -:   22:using namespace mlir;
        -:   23:using namespace presburger;
        -:   24:
        -:   25:/// Normalize a division's `dividend` and the `divisor` by their GCD. For
        -:   26:/// example: if the dividend and divisor are [2,0,4] and 4 respectively,
        -:   27:/// they get normalized to [1,0,2] and 2. The divisor must be non-negative;
        -:   28:/// it is allowed for the divisor to be zero, but nothing is done in this case.
function _ZL22normalizeDivisionByGCDN4llvm15MutableArrayRefIN4mlir10presburger5MPIntEEERS3_ called 0 returned 0% blocks executed 0%
    #####:   29:static void normalizeDivisionByGCD(MutableArrayRef<MPInt> dividend,
        -:   30:                                   MPInt &divisor) {
    #####:   31:  assert(divisor > 0 && "divisor must be non-negative!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   32:  if (divisor == 0 || dividend.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   33:    return;
        -:   34:  // We take the absolute value of dividend's coefficients to make sure that
        -:   35:  // `gcd` is positive.
    #####:   36:  MPInt gcd = presburger::gcd(abs(dividend.front()), divisor);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   37:
        -:   38:  // The reason for ignoring the constant term is as follows.
        -:   39:  // For a division:
        -:   40:  //      floor((a + m.f(x))/(m.d))
        -:   41:  // It can be replaced by:
        -:   42:  //      floor((floor(a/m) + f(x))/d)
        -:   43:  // Since `{a/m}/d` in the dividend satisfies 0 <= {a/m}/d < 1/d, it will not
        -:   44:  // influence the result of the floor division and thus, can be ignored.
    #####:   45:  for (size_t i = 1, m = dividend.size() - 1; i < m; i++) {
branch  0 never executed
branch  1 never executed
    #####:   46:    gcd = presburger::gcd(abs(dividend[i]), gcd);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:   47:    if (gcd == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   48:      return;
branch  0 never executed
branch  1 never executed
        -:   49:  }
        -:   50:
        -:   51:  // Normalize the dividend and the denominator.
    #####:   52:  std::transform(dividend.begin(), dividend.end(), dividend.begin(),
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
function _ZZL22normalizeDivisionByGCDN4llvm15MutableArrayRefIN4mlir10presburger5MPIntEEERS3_ENKUlS5_E_clES5_ called 0 returned 0% blocks executed 0%
    #####:   53:                 [gcd](MPInt &n) { return floorDiv(n, gcd); });
branch  0 never executed
branch  1 never executed
    #####:   54:  divisor /= gcd;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   55:}
        -:   56:
        -:   57:/// Check if the pos^th variable can be represented as a division using upper
        -:   58:/// bound inequality at position `ubIneq` and lower bound inequality at position
        -:   59:/// `lbIneq`.
        -:   60:///
        -:   61:/// Let `var` be the pos^th variable, then `var` is equivalent to
        -:   62:/// `expr floordiv divisor` if there are constraints of the form:
        -:   63:///      0 <= expr - divisor * var <= divisor - 1
        -:   64:/// Rearranging, we have:
        -:   65:///       divisor * var - expr + (divisor - 1) >= 0  <-- Lower bound for 'var'
        -:   66:///      -divisor * var + expr                 >= 0  <-- Upper bound for 'var'
        -:   67:///
        -:   68:/// For example:
        -:   69:///     32*k >= 16*i + j - 31                 <-- Lower bound for 'k'
        -:   70:///     32*k  <= 16*i + j                     <-- Upper bound for 'k'
        -:   71:///     expr = 16*i + j, divisor = 32
        -:   72:///     k = ( 16*i + j ) floordiv 32
        -:   73:///
        -:   74:///     4q >= i + j - 2                       <-- Lower bound for 'q'
        -:   75:///     4q <= i + j + 1                       <-- Upper bound for 'q'
        -:   76:///     expr = i + j + 1, divisor = 4
        -:   77:///     q = (i + j + 1) floordiv 4
        -:   78://
        -:   79:/// This function also supports detecting divisions from bounds that are
        -:   80:/// strictly tighter than the division bounds described above, since tighter
        -:   81:/// bounds imply the division bounds. For example:
        -:   82:///     4q - i - j + 2 >= 0                       <-- Lower bound for 'q'
        -:   83:///    -4q + i + j     >= 0                       <-- Tight upper bound for 'q'
        -:   84:///
        -:   85:/// To extract floor divisions with tighter bounds, we assume that that the
        -:   86:/// constraints are of the form:
        -:   87:///     c <= expr - divisior * var <= divisor - 1, where 0 <= c <= divisor - 1
        -:   88:/// Rearranging, we have:
        -:   89:///     divisor * var - expr + (divisor - 1) >= 0  <-- Lower bound for 'var'
        -:   90:///    -divisor * var + expr - c             >= 0  <-- Upper bound for 'var'
        -:   91:///
        -:   92:/// If successful, `expr` is set to dividend of the division and `divisor` is
        -:   93:/// set to the denominator of the division, which will be positive.
        -:   94:/// The final division expression is normalized by GCD.
function _ZL10getDivReprRKN4mlir10presburger15IntegerRelationEjjjN4llvm15MutableArrayRefINS0_5MPIntEEERS6_ called 0 returned 0% blocks executed 0%
    #####:   95:static LogicalResult getDivRepr(const IntegerRelation &cst, unsigned pos,
        -:   96:                                unsigned ubIneq, unsigned lbIneq,
        -:   97:                                MutableArrayRef<MPInt> expr, MPInt &divisor) {
        -:   98:
    #####:   99:  assert(pos <= cst.getNumVars() && "Invalid variable position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  100:  assert(ubIneq <= cst.getNumInequalities() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  101:         "Invalid upper bound inequality position");
    #####:  102:  assert(lbIneq <= cst.getNumInequalities() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  103:         "Invalid upper bound inequality position");
    #####:  104:  assert(expr.size() == cst.getNumCols() && "Invalid expression size");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  105:  assert(cst.atIneq(lbIneq, pos) > 0 && "lbIneq is not a lower bound!");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  106:  assert(cst.atIneq(ubIneq, pos) < 0 && "ubIneq is not an upper bound!");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  107:
        -:  108:  // Extract divisor from the lower bound.
    #####:  109:  divisor = cst.atIneq(lbIneq, pos);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  110:
        -:  111:  // First, check if the constraints are opposite of each other except the
        -:  112:  // constant term.
    #####:  113:  unsigned i = 0, e = 0;
    #####:  114:  for (i = 0, e = cst.getNumVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  115:    if (cst.atIneq(ubIneq, i) != -cst.atIneq(lbIneq, i))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:  116:      break;
        -:  117:
    #####:  118:  if (i < e)
branch  0 never executed
branch  1 never executed
    #####:  119:    return failure();
        -:  120:
        -:  121:  // Then, check if the constant term is of the proper form.
        -:  122:  // Due to the form of the upper/lower bound inequalities, the sum of their
        -:  123:  // constants is `divisor - 1 - c`. From this, we can extract c:
    #####:  124:  MPInt constantSum = cst.atIneq(lbIneq, cst.getNumCols() - 1) +
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  125:                      cst.atIneq(ubIneq, cst.getNumCols() - 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:  MPInt c = divisor - 1 - constantSum;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  127:
        -:  128:  // Check if `c` satisfies the condition `0 <= c <= divisor - 1`.
        -:  129:  // This also implictly checks that `divisor` is positive.
    #####:  130:  if (!(0 <= c && c <= divisor - 1)) // NOLINT
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  131:    return failure();
        -:  132:
        -:  133:  // The inequality pair can be used to extract the division.
        -:  134:  // Set `expr` to the dividend of the division except the constant term, which
        -:  135:  // is set below.
    #####:  136:  for (i = 0, e = cst.getNumVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  137:    if (i != pos)
branch  0 never executed
branch  1 never executed
    #####:  138:      expr[i] = cst.atIneq(ubIneq, i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  139:
        -:  140:  // From the upper bound inequality's form, its constant term is equal to the
        -:  141:  // constant term of `expr`, minus `c`. From this,
        -:  142:  // constant term of `expr` = constant term of upper bound + `c`.
    #####:  143:  expr.back() = cst.atIneq(ubIneq, cst.getNumCols() - 1) + c;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  144:  normalizeDivisionByGCD(expr, divisor);
call    0 never executed
        -:  145:
    #####:  146:  return success();
branch  0 never executed
branch  1 never executed
        -:  147:}
        -:  148:
        -:  149:/// Check if the pos^th variable can be represented as a division using
        -:  150:/// equality at position `eqInd`.
        -:  151:///
        -:  152:/// For example:
        -:  153:///     32*k == 16*i + j - 31                 <-- `eqInd` for 'k'
        -:  154:///     expr = 16*i + j - 31, divisor = 32
        -:  155:///     k = (16*i + j - 31) floordiv 32
        -:  156:///
        -:  157:/// If successful, `expr` is set to dividend of the division and `divisor` is
        -:  158:/// set to the denominator of the division. The final division expression is
        -:  159:/// normalized by GCD.
function _ZL10getDivReprRKN4mlir10presburger15IntegerRelationEjjN4llvm15MutableArrayRefINS0_5MPIntEEERS6_ called 0 returned 0% blocks executed 0%
    #####:  160:static LogicalResult getDivRepr(const IntegerRelation &cst, unsigned pos,
        -:  161:                                unsigned eqInd, MutableArrayRef<MPInt> expr,
        -:  162:                                MPInt &divisor) {
        -:  163:
    #####:  164:  assert(pos <= cst.getNumVars() && "Invalid variable position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  165:  assert(eqInd <= cst.getNumEqualities() && "Invalid equality position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  166:  assert(expr.size() == cst.getNumCols() && "Invalid expression size");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  167:
        -:  168:  // Extract divisor, the divisor can be negative and hence its sign information
        -:  169:  // is stored in `signDiv` to reverse the sign of dividend's coefficients.
        -:  170:  // Equality must involve the pos-th variable and hence `tempDiv` != 0.
    #####:  171:  MPInt tempDiv = cst.atEq(eqInd, pos);
call    0 never executed
    #####:  172:  if (tempDiv == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  173:    return failure();
    #####:  174:  int signDiv = tempDiv < 0 ? -1 : 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  175:
        -:  176:  // The divisor is always a positive integer.
    #####:  177:  divisor = tempDiv * signDiv;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  178:
    #####:  179:  for (unsigned i = 0, e = cst.getNumVars(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  180:    if (i != pos)
branch  0 never executed
branch  1 never executed
    #####:  181:      expr[i] = -signDiv * cst.atEq(eqInd, i);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -:  182:
    #####:  183:  expr.back() = -signDiv * cst.atEq(eqInd, cst.getNumCols() - 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  184:  normalizeDivisionByGCD(expr, divisor);
call    0 never executed
        -:  185:
    #####:  186:  return success();
branch  0 never executed
branch  1 never executed
        -:  187:}
        -:  188:
        -:  189:// Returns `false` if the constraints depends on a variable for which an
        -:  190:// explicit representation has not been found yet, otherwise returns `true`.
function _ZL27checkExplicitRepresentationRKN4mlir10presburger15IntegerRelationEN4llvm8ArrayRefIbEENS5_INS0_5MPIntEEEj called 0 returned 0% blocks executed 0%
    #####:  191:static bool checkExplicitRepresentation(const IntegerRelation &cst,
        -:  192:                                        ArrayRef<bool> foundRepr,
        -:  193:                                        ArrayRef<MPInt> dividend,
        -:  194:                                        unsigned pos) {
        -:  195:  // Exit to avoid circular dependencies between divisions.
    #####:  196:  for (unsigned c = 0, e = cst.getNumVars(); c < e; ++c) {
branch  0 never executed
branch  1 never executed
    #####:  197:    if (c == pos)
branch  0 never executed
branch  1 never executed
    #####:  198:      continue;
        -:  199:
    #####:  200:    if (!foundRepr[c] && dividend[c] != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  201:      // Expression can't be constructed as it depends on a yet unknown
        -:  202:      // variable.
        -:  203:      //
        -:  204:      // TODO: Visit/compute the variables in an order so that this doesn't
        -:  205:      // happen. More complex but much more efficient.
        -:  206:      return false;
        -:  207:    }
        -:  208:  }
        -:  209:
        -:  210:  return true;
        -:  211:}
        -:  212:
        -:  213:/// Check if the pos^th variable can be expressed as a floordiv of an affine
        -:  214:/// function of other variables (where the divisor is a positive constant).
        -:  215:/// `foundRepr` contains a boolean for each variable indicating if the
        -:  216:/// explicit representation for that variable has already been computed.
        -:  217:/// Returns the `MaybeLocalRepr` struct which contains the indices of the
        -:  218:/// constraints that can be expressed as a floordiv of an affine function. If
        -:  219:/// the representation could be computed, `dividend` and `denominator` are set.
        -:  220:/// If the representation could not be computed, the kind attribute in
        -:  221:/// `MaybeLocalRepr` is set to None.
function _ZN4mlir10presburger20computeSingleVarReprERKNS0_15IntegerRelationEN4llvm8ArrayRefIbEEjNS4_15MutableArrayRefINS0_5MPIntEEERS8_ called 0 returned 0% blocks executed 0%
    #####:  222:MaybeLocalRepr presburger::computeSingleVarRepr(const IntegerRelation &cst,
        -:  223:                                                ArrayRef<bool> foundRepr,
        -:  224:                                                unsigned pos,
        -:  225:                                                MutableArrayRef<MPInt> dividend,
        -:  226:                                                MPInt &divisor) {
    #####:  227:  assert(pos < cst.getNumVars() && "invalid position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  228:  assert(foundRepr.size() == cst.getNumVars() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  229:         "Size of foundRepr does not match total number of variables");
    #####:  230:  assert(dividend.size() == cst.getNumCols() && "Invalid dividend size");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  231:
    #####:  232:  SmallVector<unsigned, 4> lbIndices, ubIndices, eqIndices;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  233:  cst.getLowerAndUpperBoundIndices(pos, &lbIndices, &ubIndices, &eqIndices);
call    0 never executed
    #####:  234:  MaybeLocalRepr repr{};
        -:  235:
    #####:  236:  for (unsigned ubPos : ubIndices) {
branch  0 never executed
branch  1 never executed
    #####:  237:    for (unsigned lbPos : lbIndices) {
branch  0 never executed
branch  1 never executed
        -:  238:      // Attempt to get divison representation from ubPos, lbPos.
    #####:  239:      if (failed(getDivRepr(cst, pos, ubPos, lbPos, dividend, divisor)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  240:        continue;
        -:  241:
    #####:  242:      if (!checkExplicitRepresentation(cst, foundRepr, dividend, pos))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  243:        continue;
        -:  244:
    #####:  245:      repr.kind = ReprKind::Inequality;
    #####:  246:      repr.repr.inequalityPair = {ubPos, lbPos};
    #####:  247:      return repr;
        -:  248:    }
        -:  249:  }
    #####:  250:  for (unsigned eqPos : eqIndices) {
branch  0 never executed
branch  1 never executed
        -:  251:    // Attempt to get divison representation from eqPos.
    #####:  252:    if (failed(getDivRepr(cst, pos, eqPos, dividend, divisor)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:      continue;
        -:  254:
    #####:  255:    if (!checkExplicitRepresentation(cst, foundRepr, dividend, pos))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  256:      continue;
        -:  257:
    #####:  258:    repr.kind = ReprKind::Equality;
    #####:  259:    repr.repr.equalityIdx = eqPos;
    #####:  260:    return repr;
        -:  261:  }
    #####:  262:  return repr;
        -:  263:}
        -:  264:
function _ZN4mlir10presburger20computeSingleVarReprERKNS0_15IntegerRelationEN4llvm8ArrayRefIbEEjRNS4_11SmallVectorIlLj8EEERj called 0 returned 0% blocks executed 0%
    #####:  265:MaybeLocalRepr presburger::computeSingleVarRepr(
        -:  266:    const IntegerRelation &cst, ArrayRef<bool> foundRepr, unsigned pos,
        -:  267:    SmallVector<int64_t, 8> &dividend, unsigned &divisor) {
    #####:  268:  SmallVector<MPInt, 8> dividendMPInt(cst.getNumCols());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  269:  MPInt divisorMPInt;
call    0 never executed
call    1 never executed
    #####:  270:  MaybeLocalRepr result =
call    0 never executed
    #####:  271:      computeSingleVarRepr(cst, foundRepr, pos, dividendMPInt, divisorMPInt);
call    0 never executed
    #####:  272:  dividend = getInt64Vec(dividendMPInt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  273:  divisor = unsigned(int64_t(divisorMPInt));
branch  0 never executed
branch  1 never executed
    #####:  274:  return result;
branch  0 never executed
branch  1 never executed
        -:  275:}
        -:  276:
function _ZN4mlir10presburger20getSubrangeBitVectorEjjj called 0 returned 0% blocks executed 0%
    #####:  277:llvm::SmallBitVector presburger::getSubrangeBitVector(unsigned len,
        -:  278:                                                      unsigned setOffset,
        -:  279:                                                      unsigned numSet) {
    #####:  280:  llvm::SmallBitVector vec(len, false);
call    0 never executed
    #####:  281:  vec.set(setOffset, setOffset + numSet);
call    0 never executed
    #####:  282:  return vec;
        -:  283:}
        -:  284:
function _ZN4mlir10presburger14mergeLocalVarsERNS0_15IntegerRelationES2_N4llvm12function_refIFbjjEEE called 0 returned 0% blocks executed 0%
    #####:  285:void presburger::mergeLocalVars(
        -:  286:    IntegerRelation &relA, IntegerRelation &relB,
        -:  287:    llvm::function_ref<bool(unsigned i, unsigned j)> merge) {
    #####:  288:  assert(relA.getSpace().isCompatible(relB.getSpace()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  289:         "Spaces should be compatible.");
        -:  290:
        -:  291:  // Merge local vars of relA and relB without using division information,
        -:  292:  // i.e. append local vars of `relB` to `relA` and insert local vars of `relA`
        -:  293:  // to `relB` at start of its local vars.
    #####:  294:  unsigned initLocals = relA.getNumLocalVars();
call    0 never executed
    #####:  295:  relA.insertVar(VarKind::Local, relA.getNumLocalVars(),
    #####:  296:                 relB.getNumLocalVars());
call    0 never executed
    #####:  297:  relB.insertVar(VarKind::Local, 0, initLocals);
call    0 never executed
        -:  298:
        -:  299:  // Get division representations from each rel.
    #####:  300:  DivisionRepr divsA = relA.getLocalReprs();
call    0 never executed
    #####:  301:  DivisionRepr divsB = relB.getLocalReprs();
call    0 never executed
call    1 never executed
        -:  302:
    #####:  303:  for (unsigned i = initLocals, e = divsB.getNumDivs(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  304:    divsA.setDiv(i, divsB.getDividend(i), divsB.getDenom(i));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  305:
        -:  306:  // Remove duplicate divisions from divsA. The removing duplicate divisions
        -:  307:  // call, calls `merge` to effectively merge divisions in relA and relB.
    #####:  308:  divsA.removeDuplicateDivs(merge);
call    0 never executed
call    1 never executed
    #####:  309:}
        -:  310:
function _ZN4mlir10presburger16getDivUpperBoundEN4llvm8ArrayRefINS0_5MPIntEEERKS3_j called 0 returned 0% blocks executed 0%
    #####:  311:SmallVector<MPInt, 8> presburger::getDivUpperBound(ArrayRef<MPInt> dividend,
        -:  312:                                                   const MPInt &divisor,
        -:  313:                                                   unsigned localVarIdx) {
    #####:  314:  assert(divisor > 0 && "divisor must be positive!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  315:  assert(dividend[localVarIdx] == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  316:         "Local to be set to division must have zero coeff!");
    #####:  317:  SmallVector<MPInt, 8> ineq(dividend.begin(), dividend.end());
call    0 never executed
    #####:  318:  ineq[localVarIdx] = -divisor;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  319:  return ineq;
        -:  320:}
        -:  321:
function _ZN4mlir10presburger16getDivLowerBoundEN4llvm8ArrayRefINS0_5MPIntEEERKS3_j called 0 returned 0% blocks executed 0%
    #####:  322:SmallVector<MPInt, 8> presburger::getDivLowerBound(ArrayRef<MPInt> dividend,
        -:  323:                                                   const MPInt &divisor,
        -:  324:                                                   unsigned localVarIdx) {
    #####:  325:  assert(divisor > 0 && "divisor must be positive!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  326:  assert(dividend[localVarIdx] == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  327:         "Local to be set to division must have zero coeff!");
    #####:  328:  SmallVector<MPInt, 8> ineq(dividend.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  329:  std::transform(dividend.begin(), dividend.end(), ineq.begin(),
call    0 never executed
        -:  330:                 std::negate<MPInt>());
    #####:  331:  ineq[localVarIdx] = divisor;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  332:  ineq.back() += divisor - 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  333:  return ineq;
        -:  334:}
        -:  335:
function _ZN4mlir10presburger8gcdRangeEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  336:MPInt presburger::gcdRange(ArrayRef<MPInt> range) {
    #####:  337:  MPInt gcd(0);
    #####:  338:  for (const MPInt &elem : range) {
branch  0 never executed
branch  1 never executed
    #####:  339:    gcd = presburger::gcd(gcd, abs(elem));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  340:    if (gcd == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  341:      return gcd;
        -:  342:  }
        -:  343:  return gcd;
        -:  344:}
        -:  345:
function _ZN4mlir10presburger14normalizeRangeEN4llvm15MutableArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  346:MPInt presburger::normalizeRange(MutableArrayRef<MPInt> range) {
    #####:  347:  MPInt gcd = gcdRange(range);
call    0 never executed
    #####:  348:  if ((gcd == 0) || (gcd == 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  349:    return gcd;
    #####:  350:  for (MPInt &elem : range)
branch  0 never executed
branch  1 never executed
    #####:  351:    elem /= gcd;
branch  0 never executed
branch  1 never executed
        -:  352:  return gcd;
        -:  353:}
        -:  354:
function _ZN4mlir10presburger12normalizeDivEN4llvm15MutableArrayRefINS0_5MPIntEEERS3_ called 0 returned 0% blocks executed 0%
    #####:  355:void presburger::normalizeDiv(MutableArrayRef<MPInt> num, MPInt &denom) {
    #####:  356:  assert(denom > 0 && "denom must be positive!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  357:  MPInt gcd = presburger::gcd(gcdRange(num), denom);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  358:  for (MPInt &coeff : num)
branch  0 never executed
branch  1 never executed
    #####:  359:    coeff /= gcd;
branch  0 never executed
branch  1 never executed
    #####:  360:  denom /= gcd;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  361:}
        -:  362:
function _ZN4mlir10presburger16getNegatedCoeffsEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  363:SmallVector<MPInt, 8> presburger::getNegatedCoeffs(ArrayRef<MPInt> coeffs) {
    #####:  364:  SmallVector<MPInt, 8> negatedCoeffs;
branch  0 never executed
branch  1 never executed
    #####:  365:  negatedCoeffs.reserve(coeffs.size());
branch  0 never executed
branch  1 never executed
    #####:  366:  for (const MPInt &coeff : coeffs)
branch  0 never executed
branch  1 never executed
    #####:  367:    negatedCoeffs.emplace_back(-coeff);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  368:  return negatedCoeffs;
        -:  369:}
        -:  370:
function _ZN4mlir10presburger17getComplementIneqEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  371:SmallVector<MPInt, 8> presburger::getComplementIneq(ArrayRef<MPInt> ineq) {
    #####:  372:  SmallVector<MPInt, 8> coeffs;
branch  0 never executed
branch  1 never executed
    #####:  373:  coeffs.reserve(ineq.size());
branch  0 never executed
branch  1 never executed
    #####:  374:  for (const MPInt &coeff : ineq)
branch  0 never executed
branch  1 never executed
    #####:  375:    coeffs.emplace_back(-coeff);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  376:  --coeffs.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  377:  return coeffs;
        -:  378:}
        -:  379:
        -:  380:SmallVector<Optional<MPInt>, 4>
function _ZNK4mlir10presburger12DivisionRepr11divValuesAtEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  381:DivisionRepr::divValuesAt(ArrayRef<MPInt> point) const {
    #####:  382:  assert(point.size() == getNumNonDivs() && "Incorrect point size");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  383:
    #####:  384:  SmallVector<Optional<MPInt>, 4> divValues(getNumDivs(), None);
call    0 never executed
call    1 never executed
    #####:  385:  bool changed = true;
    #####:  386:  while (changed) {
branch  0 never executed
branch  1 never executed
    #####:  387:    changed = false;
    #####:  388:    for (unsigned i = 0, e = getNumDivs(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
        -:  389:      // If division value is found, continue;
    #####:  390:      if (divValues[i])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  391:        continue;
        -:  392:
    #####:  393:      ArrayRef<MPInt> dividend = getDividend(i);
call    0 never executed
    #####:  394:      MPInt divVal(0);
        -:  395:
        -:  396:      // Check if we have all the division values required for this division.
    #####:  397:      unsigned j, f;
    #####:  398:      for (j = 0, f = getNumDivs(); j < f; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  399:        if (dividend[getDivOffset() + j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  400:          continue;
        -:  401:        // Division value required, but not found yet.
    #####:  402:        if (!divValues[j])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  403:          break;
    #####:  404:        divVal += dividend[getDivOffset() + j] * divValues[j].value();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  405:      }
        -:  406:
        -:  407:      // We have some division values that are still not found, but are required
        -:  408:      // to find the value of this division.
    #####:  409:      if (j < f)
branch  0 never executed
branch  1 never executed
    #####:  410:        continue;
branch  0 never executed
branch  1 never executed
        -:  411:
        -:  412:      // Fill remaining values.
    #####:  413:      divVal = std::inner_product(point.begin(), point.end(), dividend.begin(),
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  414:                                  divVal);
branch  0 never executed
branch  1 never executed
        -:  415:      // Add constant.
    #####:  416:      divVal += dividend.back();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  417:      // Take floor division with denominator.
    #####:  418:      divVal = floorDiv(divVal, denoms[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  419:
        -:  420:      // Set div value and continue.
    #####:  421:      divValues[i] = divVal;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  422:      changed = true;
branch  0 never executed
branch  1 never executed
        -:  423:    }
        -:  424:  }
        -:  425:
    #####:  426:  return divValues;
        -:  427:}
        -:  428:
function _ZN4mlir10presburger12DivisionRepr19removeDuplicateDivsEN4llvm12function_refIFbjjEEE called 0 returned 0% blocks executed 0%
    #####:  429:void DivisionRepr::removeDuplicateDivs(
        -:  430:    llvm::function_ref<bool(unsigned i, unsigned j)> merge) {
        -:  431:
        -:  432:  // Find and merge duplicate divisions.
        -:  433:  // TODO: Add division normalization to support divisions that differ by
        -:  434:  // a constant.
        -:  435:  // TODO: Add division ordering such that a division representation for local
        -:  436:  // variable at position `i` only depends on local variables at position <
        -:  437:  // `i`. This would make sure that all divisions depending on other local
        -:  438:  // variables that can be merged, are merged.
    #####:  439:  for (unsigned i = 0; i < getNumDivs(); ++i) {
branch  0 never executed
branch  1 never executed
        -:  440:    // Check if a division representation exists for the `i^th` local var.
    #####:  441:    if (denoms[i] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  442:      continue;
        -:  443:    // Check if a division exists which is a duplicate of the division at `i`.
    #####:  444:    for (unsigned j = i + 1; j < getNumDivs(); ++j) {
branch  0 never executed
branch  1 never executed
        -:  445:      // Check if a division representation exists for the `j^th` local var.
    #####:  446:      if (denoms[j] == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  447:        continue;
        -:  448:      // Check if the denominators match.
    #####:  449:      if (denoms[i] != denoms[j])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  450:        continue;
        -:  451:      // Check if the representations are equal.
    #####:  452:      if (dividends.getRow(i) != dividends.getRow(j))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        continue;
        -:  454:
        -:  455:      // Merge divisions at position `j` into division at position `i`. If
        -:  456:      // merge fails, do not merge these divs.
    #####:  457:      bool mergeResult = merge(i, j);
call    0 never executed
    #####:  458:      if (!mergeResult)
branch  0 never executed
branch  1 never executed
    #####:  459:        continue;
        -:  460:
        -:  461:      // Update division information to reflect merging.
    #####:  462:      unsigned divOffset = getDivOffset();
call    0 never executed
    #####:  463:      dividends.addToColumn(divOffset + j, divOffset + i, /*scale=*/1);
call    0 never executed
    #####:  464:      dividends.removeColumn(divOffset + j);
call    0 never executed
    #####:  465:      dividends.removeRow(j);
call    0 never executed
    #####:  466:      denoms.erase(denoms.begin() + j);
call    0 never executed
        -:  467:
        -:  468:      // Since `j` can never be zero, we do not need to worry about overflows.
    #####:  469:      --j;
        -:  470:    }
        -:  471:  }
    #####:  472:}
        -:  473:
function _ZN4mlir10presburger12DivisionRepr9insertDivEjN4llvm8ArrayRefINS0_5MPIntEEERKS4_ called 0 returned 0% blocks executed 0%
    #####:  474:void DivisionRepr::insertDiv(unsigned pos, ArrayRef<MPInt> dividend,
        -:  475:                             const MPInt &divisor) {
    #####:  476:  assert(pos <= getNumDivs() && "Invalid insertion position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  477:  assert(dividend.size() == getNumVars() + 1 && "Incorrect dividend size");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  478:
    #####:  479:  dividends.appendExtraRow(dividend);
call    0 never executed
    #####:  480:  denoms.insert(denoms.begin() + pos, divisor);
call    0 never executed
    #####:  481:  dividends.insertColumn(getDivOffset() + pos);
call    0 never executed
    #####:  482:}
        -:  483:
function _ZN4mlir10presburger12DivisionRepr9insertDivEjj called 0 returned 0% blocks executed 0%
    #####:  484:void DivisionRepr::insertDiv(unsigned pos, unsigned num) {
    #####:  485:  assert(pos <= getNumDivs() && "Invalid insertion position");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  486:  dividends.insertColumns(getDivOffset() + pos, num);
call    0 never executed
    #####:  487:  dividends.insertRows(pos, num);
call    0 never executed
    #####:  488:  denoms.insert(denoms.begin() + pos, num, MPInt(0));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  489:}
        -:  490:
function _ZNK4mlir10presburger12DivisionRepr5printERN4llvm11raw_ostreamE called 0 returned 0% blocks executed 0%
    #####:  491:void DivisionRepr::print(raw_ostream &os) const {
    #####:  492:  os << "Dividends:\n";
call    0 never executed
    #####:  493:  dividends.print(os);
call    0 never executed
    #####:  494:  os << "Denominators\n";
call    0 never executed
    #####:  495:  for (unsigned i = 0, e = denoms.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  496:    os << denoms[i] << " ";
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  497:  os << "\n";
call    0 never executed
    #####:  498:}
        -:  499:
function _ZNK4mlir10presburger12DivisionRepr4dumpEv called 0 returned 0% blocks executed 0%
    #####:  500:void DivisionRepr::dump() const { print(llvm::errs()); }
call    0 never executed
call    1 never executed
        -:  501:
function _ZN4mlir10presburger11getMPIntVecEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:  502:SmallVector<MPInt, 8> presburger::getMPIntVec(ArrayRef<int64_t> range) {
    #####:  503:  SmallVector<MPInt, 8> result(range.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  504:  std::transform(range.begin(), range.end(), result.begin(), mpintFromInt64);
call    0 never executed
    #####:  505:  return result;
        -:  506:}
        -:  507:
function _ZN4mlir10presburger11getInt64VecEN4llvm8ArrayRefINS0_5MPIntEEE called 0 returned 0% blocks executed 0%
    #####:  508:SmallVector<int64_t, 8> presburger::getInt64Vec(ArrayRef<MPInt> range) {
    #####:  509:  SmallVector<int64_t, 8> result(range.size());
call    0 never executed
    #####:  510:  std::transform(range.begin(), range.end(), result.begin(), int64FromMPInt);
    #####:  511:  return result;
        -:  512:}
