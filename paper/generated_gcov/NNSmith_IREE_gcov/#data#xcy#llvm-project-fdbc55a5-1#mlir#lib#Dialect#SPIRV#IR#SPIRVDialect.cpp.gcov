        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/Dialect/SPIRV/IR/SPIRVDialect.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SPIRV/IR/CMakeFiles/obj.MLIRSPIRVDialect.dir/SPIRVDialect.cpp.gcda
        -:    0:Runs:325552
        -:    1://===- LLVMDialect.cpp - MLIR SPIR-V dialect ------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the SPIR-V dialect in MLIR.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SPIRV/IR/SPIRVDialect.h"
        -:   14:#include "mlir/Dialect/SPIRV/IR/ParserUtils.h"
        -:   15:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.h"
        -:   16:#include "mlir/Dialect/SPIRV/IR/SPIRVTypes.h"
        -:   17:#include "mlir/Dialect/SPIRV/IR/TargetAndABI.h"
        -:   18:#include "mlir/IR/Builders.h"
        -:   19:#include "mlir/IR/BuiltinTypes.h"
        -:   20:#include "mlir/IR/DialectImplementation.h"
        -:   21:#include "mlir/IR/MLIRContext.h"
        -:   22:#include "mlir/Parser/Parser.h"
        -:   23:#include "mlir/Transforms/InliningUtils.h"
        -:   24:#include "llvm/ADT/DenseMap.h"
        -:   25:#include "llvm/ADT/Sequence.h"
        -:   26:#include "llvm/ADT/SetVector.h"
        -:   27:#include "llvm/ADT/StringExtras.h"
        -:   28:#include "llvm/ADT/StringMap.h"
        -:   29:#include "llvm/ADT/TypeSwitch.h"
        -:   30:#include "llvm/Support/raw_ostream.h"
        -:   31:
        -:   32:using namespace mlir;
        -:   33:using namespace mlir::spirv;
        -:   34:
        -:   35:#include "mlir/Dialect/SPIRV/IR/SPIRVOpsDialect.cpp.inc"
        -:   36:
        -:   37://===----------------------------------------------------------------------===//
        -:   38:// InlinerInterface
        -:   39://===----------------------------------------------------------------------===//
        -:   40:
        -:   41:/// Returns true if the given region contains spirv.Return or spirv.ReturnValue
        -:   42:/// ops.
    #####:   43:static inline bool containsReturn(Region &region) {
    #####:   44:  return llvm::any_of(region, [](Block &block) {
        -:   45:    Operation *terminator = block.getTerminator();
        -:   46:    return isa<spirv::ReturnOp, spirv::ReturnValueOp>(terminator);
        -:   47:  });
        -:   48:}
        -:   49:
        -:   50:namespace {
        -:   51:/// This class defines the interface for inlining within the SPIR-V dialect.
        -:   52:struct SPIRVInlinerInterface : public DialectInlinerInterface {
        -:   53:  using DialectInlinerInterface::DialectInlinerInterface;
        -:   54:
        -:   55:  /// All call operations within SPIRV can be inlined.
function _ZNK12_GLOBAL__N_121SPIRVInlinerInterface15isLegalToInlineEPN4mlir9OperationES3_b called 0 returned 0% blocks executed 0%
    #####:   56:  bool isLegalToInline(Operation *call, Operation *callable,
        -:   57:                       bool wouldBeCloned) const final {
    #####:   58:    return true;
        -:   59:  }
        -:   60:
        -:   61:  /// Returns true if the given region 'src' can be inlined into the region
        -:   62:  /// 'dest' that is attached to an operation registered to the current dialect.
function _ZNK12_GLOBAL__N_121SPIRVInlinerInterface15isLegalToInlineEPN4mlir6RegionES3_bRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:   63:  bool isLegalToInline(Region *dest, Region *src, bool wouldBeCloned,
        -:   64:                       BlockAndValueMapping &) const final {
        -:   65:    // Return true here when inlining into spirv.func, spirv.mlir.selection, and
        -:   66:    // spirv.mlir.loop operations.
    #####:   67:    auto *op = dest->getParentOp();
call    0 never executed
    #####:   68:    return isa<spirv::FuncOp, spirv::SelectionOp, spirv::LoopOp>(op);
call    0 never executed
        -:   69:  }
        -:   70:
        -:   71:  /// Returns true if the given operation 'op', that is registered to this
        -:   72:  /// dialect, can be inlined into the region 'dest' that is attached to an
        -:   73:  /// operation registered to the current dialect.
function _ZNK12_GLOBAL__N_121SPIRVInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:   74:  bool isLegalToInline(Operation *op, Region *dest, bool wouldBeCloned,
        -:   75:                       BlockAndValueMapping &) const final {
        -:   76:    // TODO: Enable inlining structured control flows with return.
    #####:   77:    if ((isa<spirv::SelectionOp, spirv::LoopOp>(op)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:        containsReturn(op->getRegion(0)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   79:      return false;
        -:   80:    // TODO: we need to filter OpKill here to avoid inlining it to
        -:   81:    // a loop continue construct:
        -:   82:    // https://github.com/KhronosGroup/SPIRV-Headers/issues/86
        -:   83:    // However OpKill is fragment shader specific and we don't support it yet.
        -:   84:    return true;
        -:   85:  }
        -:   86:
        -:   87:  /// Handle the given inlined terminator by replacing it with a new operation
        -:   88:  /// as necessary.
function _ZNK12_GLOBAL__N_121SPIRVInlinerInterface16handleTerminatorEPN4mlir9OperationEPNS1_5BlockE called 0 returned 0% blocks executed 0%
    #####:   89:  void handleTerminator(Operation *op, Block *newDest) const final {
    #####:   90:    if (auto returnOp = dyn_cast<spirv::ReturnOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   91:      OpBuilder(op).create<spirv::BranchOp>(op->getLoc(), newDest);
call    0 never executed
call    1 never executed
    #####:   92:      op->erase();
call    0 never executed
    #####:   93:    } else if (auto retValOp = dyn_cast<spirv::ReturnValueOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   94:      llvm_unreachable("unimplemented spirv.ReturnValue in inliner");
call    0 never executed
        -:   95:    }
    #####:   96:  }
        -:   97:
        -:   98:  /// Handle the given inlined terminator by replacing it with a new operation
        -:   99:  /// as necessary.
function _ZNK12_GLOBAL__N_121SPIRVInlinerInterface16handleTerminatorEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  100:  void handleTerminator(Operation *op,
        -:  101:                        ArrayRef<Value> valuesToRepl) const final {
        -:  102:    // Only spirv.ReturnValue needs to be handled here.
    #####:  103:    auto retValOp = dyn_cast<spirv::ReturnValueOp>(op);
call    0 never executed
    #####:  104:    if (!retValOp)
branch  0 never executed
branch  1 never executed
    #####:  105:      return;
        -:  106:
        -:  107:    // Replace the values directly with the return operands.
    #####:  108:    assert(valuesToRepl.size() == 1 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  109:           "spirv.ReturnValue expected to only handle one result");
    #####:  110:    valuesToRepl.front().replaceAllUsesWith(retValOp.getValue());
call    0 never executed
call    1 never executed
        -:  111:  }
        -:  112:};
        -:  113:} // namespace
        -:  114:
        -:  115://===----------------------------------------------------------------------===//
        -:  116:// SPIR-V Dialect
        -:  117://===----------------------------------------------------------------------===//
        -:  118:
function _ZN4mlir5spirv12SPIRVDialect10initializeEv called 11762 returned 100% blocks executed 100%
    11762:  119:void SPIRVDialect::initialize() {
    11762:  120:  registerAttributes();
call    0 returned 100%
    11762:  121:  registerTypes();
call    0 returned 100%
        -:  122:
        -:  123:  // Add SPIR-V ops.
    11762:  124:  addOperations<
        -:  125:#define GET_OP_LIST
        -:  126:#include "mlir/Dialect/SPIRV/IR/SPIRVOps.cpp.inc"
    11762:  127:      >();
call    0 returned 100%
        -:  128:
    11762:  129:  addInterfaces<SPIRVInlinerInterface>();
call    0 returned 100%
        -:  130:
        -:  131:  // Allow unknown operations because SPIR-V is extensible.
    11762:  132:  allowUnknownOperations();
    11762:  133:}
        -:  134:
function _ZN4mlir5spirv12SPIRVDialect16getAttributeNameB5cxx11ENS0_10DecorationE called 0 returned 0% blocks executed 0%
    #####:  135:std::string SPIRVDialect::getAttributeName(Decoration decoration) {
    #####:  136:  return llvm::convertToSnakeFromCamelCase(stringifyDecoration(decoration));
call    0 never executed
call    1 never executed
        -:  137:}
        -:  138:
        -:  139://===----------------------------------------------------------------------===//
        -:  140:// Type Parsing
        -:  141://===----------------------------------------------------------------------===//
        -:  142:
        -:  143:// Forward declarations.
        -:  144:template <typename ValTy>
        -:  145:static Optional<ValTy> parseAndVerify(SPIRVDialect const &dialect,
        -:  146:                                      DialectAsmParser &parser);
        -:  147:template <>
        -:  148:Optional<Type> parseAndVerify<Type>(SPIRVDialect const &dialect,
        -:  149:                                    DialectAsmParser &parser);
        -:  150:
        -:  151:template <>
        -:  152:Optional<unsigned> parseAndVerify<unsigned>(SPIRVDialect const &dialect,
        -:  153:                                            DialectAsmParser &parser);
        -:  154:
function _ZL18parseAndVerifyTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  155:static Type parseAndVerifyType(SPIRVDialect const &dialect,
        -:  156:                               DialectAsmParser &parser) {
    #####:  157:  Type type;
    #####:  158:  SMLoc typeLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  159:  if (parser.parseType(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:    return Type();
        -:  161:
        -:  162:  // Allow SPIR-V dialect types
    #####:  163:  if (&type.getDialect() == &dialect)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  164:    return type;
        -:  165:
        -:  166:  // Check other allowed types
    #####:  167:  if (auto t = type.dyn_cast<FloatType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  168:    if (type.isBF16()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  169:      parser.emitError(typeLoc, "cannot use 'bf16' to compose SPIR-V types");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  170:      return Type();
        -:  171:    }
    #####:  172:  } else if (auto t = type.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  173:    if (!ScalarType::isValid(t)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  174:      parser.emitError(typeLoc,
call    0 never executed
call    1 never executed
    #####:  175:                       "only 1/8/16/32/64-bit integer type allowed but found ")
call    0 never executed
    #####:  176:          << type;
call    0 never executed
    #####:  177:      return Type();
        -:  178:    }
    #####:  179:  } else if (auto t = type.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  180:    if (t.getRank() != 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  181:      parser.emitError(typeLoc, "only 1-D vector allowed but found ") << t;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  182:      return Type();
        -:  183:    }
    #####:  184:    if (t.getNumElements() > 4) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  185:      parser.emitError(
call    0 never executed
    #####:  186:          typeLoc, "vector length has to be less than or equal to 4 but found ")
call    0 never executed
    #####:  187:          << t.getNumElements();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  188:      return Type();
        -:  189:    }
        -:  190:  } else {
    #####:  191:    parser.emitError(typeLoc, "cannot use ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  192:        << type << " to compose SPIR-V types";
call    0 never executed
call    1 never executed
    #####:  193:    return Type();
        -:  194:  }
        -:  195:
    #####:  196:  return type;
        -:  197:}
        -:  198:
        -:  199:static Type parseAndVerifyMatrixType(SPIRVDialect const &dialect,
        -:  200:                                     DialectAsmParser &parser) {
        -:  201:  Type type;
        -:  202:  SMLoc typeLoc = parser.getCurrentLocation();
        -:  203:  if (parser.parseType(type))
        -:  204:    return Type();
        -:  205:
        -:  206:  if (auto t = type.dyn_cast<VectorType>()) {
        -:  207:    if (t.getRank() != 1) {
        -:  208:      parser.emitError(typeLoc, "only 1-D vector allowed but found ") << t;
        -:  209:      return Type();
        -:  210:    }
        -:  211:    if (t.getNumElements() > 4 || t.getNumElements() < 2) {
        -:  212:      parser.emitError(typeLoc,
        -:  213:                       "matrix columns size has to be less than or equal "
        -:  214:                       "to 4 and greater than or equal 2, but found ")
        -:  215:          << t.getNumElements();
        -:  216:      return Type();
        -:  217:    }
        -:  218:
        -:  219:    if (!t.getElementType().isa<FloatType>()) {
        -:  220:      parser.emitError(typeLoc, "matrix columns' elements must be of "
        -:  221:                                "Float type, got ")
        -:  222:          << t.getElementType();
        -:  223:      return Type();
        -:  224:    }
        -:  225:  } else {
        -:  226:    parser.emitError(typeLoc, "matrix must be composed using vector "
        -:  227:                              "type, got ")
        -:  228:        << type;
        -:  229:    return Type();
        -:  230:  }
        -:  231:
        -:  232:  return type;
        -:  233:}
        -:  234:
        -:  235:static Type parseAndVerifySampledImageType(SPIRVDialect const &dialect,
        -:  236:                                           DialectAsmParser &parser) {
        -:  237:  Type type;
        -:  238:  SMLoc typeLoc = parser.getCurrentLocation();
        -:  239:  if (parser.parseType(type))
        -:  240:    return Type();
        -:  241:
        -:  242:  if (!type.isa<ImageType>()) {
        -:  243:    parser.emitError(typeLoc,
        -:  244:                     "sampled image must be composed using image type, got ")
        -:  245:        << type;
        -:  246:    return Type();
        -:  247:  }
        -:  248:
        -:  249:  return type;
        -:  250:}
        -:  251:
        -:  252:/// Parses an optional `, stride = N` assembly segment. If no parsing failure
        -:  253:/// occurs, writes `N` to `stride` if existing and writes 0 to `stride` if
        -:  254:/// missing.
        -:  255:static LogicalResult parseOptionalArrayStride(const SPIRVDialect &dialect,
        -:  256:                                              DialectAsmParser &parser,
        -:  257:                                              unsigned &stride) {
        -:  258:  if (failed(parser.parseOptionalComma())) {
        -:  259:    stride = 0;
        -:  260:    return success();
        -:  261:  }
        -:  262:
        -:  263:  if (parser.parseKeyword("stride") || parser.parseEqual())
        -:  264:    return failure();
        -:  265:
        -:  266:  SMLoc strideLoc = parser.getCurrentLocation();
        -:  267:  Optional<unsigned> optStride = parseAndVerify<unsigned>(dialect, parser);
        -:  268:  if (!optStride)
        -:  269:    return failure();
        -:  270:
        -:  271:  if (!(stride = *optStride)) {
        -:  272:    parser.emitError(strideLoc, "ArrayStride must be greater than zero");
        -:  273:    return failure();
        -:  274:  }
        -:  275:  return success();
        -:  276:}
        -:  277:
        -:  278:// element-type ::= integer-type
        -:  279://                | floating-point-type
        -:  280://                | vector-type
        -:  281://                | spirv-type
        -:  282://
        -:  283:// array-type ::= `!spirv.array` `<` integer-literal `x` element-type
        -:  284://                (`,` `stride` `=` integer-literal)? `>`
function _ZL14parseArrayTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  285:static Type parseArrayType(SPIRVDialect const &dialect,
        -:  286:                           DialectAsmParser &parser) {
    #####:  287:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  288:    return Type();
        -:  289:
    #####:  290:  SmallVector<int64_t, 1> countDims;
call    0 never executed
    #####:  291:  SMLoc countLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  292:  if (parser.parseDimensionList(countDims, /*allowDynamic=*/false))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  293:    return Type();
    #####:  294:  if (countDims.size() != 1) {
branch  0 never executed
branch  1 never executed
    #####:  295:    parser.emitError(countLoc,
call    0 never executed
call    1 never executed
    #####:  296:                     "expected single integer for array element count");
call    0 never executed
    #####:  297:    return Type();
        -:  298:  }
        -:  299:
        -:  300:  // According to the SPIR-V spec:
        -:  301:  // "Length is the number of elements in the array. It must be at least 1."
    #####:  302:  int64_t count = countDims[0];
branch  0 never executed
branch  1 never executed
    #####:  303:  if (count == 0) {
branch  0 never executed
branch  1 never executed
    #####:  304:    parser.emitError(countLoc, "expected array length greater than 0");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  305:    return Type();
        -:  306:  }
        -:  307:
    #####:  308:  Type elementType = parseAndVerifyType(dialect, parser);
call    0 never executed
    #####:  309:  if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  310:    return Type();
        -:  311:
    #####:  312:  unsigned stride = 0;
    #####:  313:  if (failed(parseOptionalArrayStride(dialect, parser, stride)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  314:    return Type();
        -:  315:
    #####:  316:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  317:    return Type();
    #####:  318:  return ArrayType::get(elementType, count, stride);
call    0 never executed
        -:  319:}
        -:  320:
        -:  321:// cooperative-matrix-type ::= `!spirv.coopmatrix` `<` element-type ',' scope
        -:  322:// ','
        -:  323://                                                   rows ',' columns>`
function _ZL26parseCooperativeMatrixTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  324:static Type parseCooperativeMatrixType(SPIRVDialect const &dialect,
        -:  325:                                       DialectAsmParser &parser) {
    #####:  326:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:    return Type();
        -:  328:
    #####:  329:  SmallVector<int64_t, 2> dims;
call    0 never executed
    #####:  330:  SMLoc countLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  331:  if (parser.parseDimensionList(dims, /*allowDynamic=*/false))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  332:    return Type();
        -:  333:
    #####:  334:  if (dims.size() != 2) {
branch  0 never executed
branch  1 never executed
    #####:  335:    parser.emitError(countLoc, "expected rows and columns size");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  336:    return Type();
        -:  337:  }
        -:  338:
    #####:  339:  auto elementTy = parseAndVerifyType(dialect, parser);
call    0 never executed
    #####:  340:  if (!elementTy)
branch  0 never executed
branch  1 never executed
    #####:  341:    return Type();
        -:  342:
    #####:  343:  Scope scope;
    #####:  344:  if (parser.parseComma() || parseEnumKeywordAttr(scope, parser, "scope <id>"))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  345:    return Type();
        -:  346:
    #####:  347:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  348:    return Type();
    #####:  349:  return CooperativeMatrixNVType::get(elementTy, scope, dims[0], dims[1]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  350:}
        -:  351:
        -:  352:// joint-matrix-type ::= `!spirv.jointmatrix` `<`rows `x` columns `x`
        -:  353:// element-type
        -:  354://                                                       `,` layout `,` scope`>`
function _ZL20parseJointMatrixTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  355:static Type parseJointMatrixType(SPIRVDialect const &dialect,
        -:  356:                                 DialectAsmParser &parser) {
    #####:  357:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  358:    return Type();
        -:  359:
    #####:  360:  SmallVector<int64_t, 2> dims;
call    0 never executed
    #####:  361:  SMLoc countLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  362:  if (parser.parseDimensionList(dims, /*allowDynamic=*/false))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  363:    return Type();
        -:  364:
    #####:  365:  if (dims.size() != 2) {
branch  0 never executed
branch  1 never executed
    #####:  366:    parser.emitError(countLoc, "expected rows and columns size");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  367:    return Type();
        -:  368:  }
        -:  369:
    #####:  370:  auto elementTy = parseAndVerifyType(dialect, parser);
call    0 never executed
    #####:  371:  if (!elementTy)
branch  0 never executed
branch  1 never executed
    #####:  372:    return Type();
    #####:  373:  MatrixLayout matrixLayout;
    #####:  374:  if (parser.parseComma() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  375:      parseEnumKeywordAttr(matrixLayout, parser, "matrixLayout <id>"))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  376:    return Type();
    #####:  377:  Scope scope;
    #####:  378:  if (parser.parseComma() || parseEnumKeywordAttr(scope, parser, "scope <id>"))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  379:    return Type();
    #####:  380:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  381:    return Type();
    #####:  382:  return JointMatrixINTELType::get(elementTy, scope, dims[0], dims[1],
    #####:  383:                                   matrixLayout);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  384:}
        -:  385:
        -:  386:// TODO: Reorder methods to be utilities first and parse*Type
        -:  387:// methods in alphabetical order
        -:  388://
        -:  389:// storage-class ::= `UniformConstant`
        -:  390://                 | `Uniform`
        -:  391://                 | `Workgroup`
        -:  392://                 | <and other storage classes...>
        -:  393://
        -:  394:// pointer-type ::= `!spirv.ptr<` element-type `,` storage-class `>`
function _ZL16parsePointerTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  395:static Type parsePointerType(SPIRVDialect const &dialect,
        -:  396:                             DialectAsmParser &parser) {
    #####:  397:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  398:    return Type();
        -:  399:
    #####:  400:  auto pointeeType = parseAndVerifyType(dialect, parser);
call    0 never executed
    #####:  401:  if (!pointeeType)
branch  0 never executed
branch  1 never executed
    #####:  402:    return Type();
        -:  403:
    #####:  404:  StringRef storageClassSpec;
    #####:  405:  SMLoc storageClassLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  406:  if (parser.parseComma() || parser.parseKeyword(&storageClassSpec))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  407:    return Type();
        -:  408:
    #####:  409:  auto storageClass = symbolizeStorageClass(storageClassSpec);
call    0 never executed
    #####:  410:  if (!storageClass) {
branch  0 never executed
branch  1 never executed
    #####:  411:    parser.emitError(storageClassLoc, "unknown storage class: ")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  412:        << storageClassSpec;
call    0 never executed
    #####:  413:    return Type();
        -:  414:  }
    #####:  415:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  416:    return Type();
    #####:  417:  return PointerType::get(pointeeType, *storageClass);
call    0 never executed
        -:  418:}
        -:  419:
        -:  420:// runtime-array-type ::= `!spirv.rtarray` `<` element-type
        -:  421://                        (`,` `stride` `=` integer-literal)? `>`
function _ZL21parseRuntimeArrayTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  422:static Type parseRuntimeArrayType(SPIRVDialect const &dialect,
        -:  423:                                  DialectAsmParser &parser) {
    #####:  424:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  425:    return Type();
        -:  426:
    #####:  427:  Type elementType = parseAndVerifyType(dialect, parser);
call    0 never executed
    #####:  428:  if (!elementType)
branch  0 never executed
branch  1 never executed
    #####:  429:    return Type();
        -:  430:
    #####:  431:  unsigned stride = 0;
    #####:  432:  if (failed(parseOptionalArrayStride(dialect, parser, stride)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  433:    return Type();
        -:  434:
    #####:  435:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  436:    return Type();
    #####:  437:  return RuntimeArrayType::get(elementType, stride);
call    0 never executed
        -:  438:}
        -:  439:
        -:  440:// matrix-type ::= `!spirv.matrix` `<` integer-literal `x` element-type `>`
        -:  441:static Type parseMatrixType(SPIRVDialect const &dialect,
        -:  442:                            DialectAsmParser &parser) {
        -:  443:  if (parser.parseLess())
        -:  444:    return Type();
        -:  445:
        -:  446:  SmallVector<int64_t, 1> countDims;
        -:  447:  SMLoc countLoc = parser.getCurrentLocation();
        -:  448:  if (parser.parseDimensionList(countDims, /*allowDynamic=*/false))
        -:  449:    return Type();
        -:  450:  if (countDims.size() != 1) {
        -:  451:    parser.emitError(countLoc, "expected single unsigned "
        -:  452:                               "integer for number of columns");
        -:  453:    return Type();
        -:  454:  }
        -:  455:
        -:  456:  int64_t columnCount = countDims[0];
        -:  457:  // According to the specification, Matrices can have 2, 3, or 4 columns
        -:  458:  if (columnCount < 2 || columnCount > 4) {
        -:  459:    parser.emitError(countLoc, "matrix is expected to have 2, 3, or 4 "
        -:  460:                               "columns");
        -:  461:    return Type();
        -:  462:  }
        -:  463:
        -:  464:  Type columnType = parseAndVerifyMatrixType(dialect, parser);
        -:  465:  if (!columnType)
        -:  466:    return Type();
        -:  467:
        -:  468:  if (parser.parseGreater())
        -:  469:    return Type();
        -:  470:
        -:  471:  return MatrixType::get(columnType, columnCount);
        -:  472:}
        -:  473:
        -:  474:// Specialize this function to parse each of the parameters that define an
        -:  475:// ImageType. By default it assumes this is an enum type.
        -:  476:template <typename ValTy>
        -:  477:static Optional<ValTy> parseAndVerify(SPIRVDialect const &dialect,
        -:  478:                                      DialectAsmParser &parser) {
        -:  479:  StringRef enumSpec;
        -:  480:  SMLoc enumLoc = parser.getCurrentLocation();
        -:  481:  if (parser.parseKeyword(&enumSpec)) {
        -:  482:    return llvm::None;
        -:  483:  }
        -:  484:
        -:  485:  auto val = spirv::symbolizeEnum<ValTy>(enumSpec);
        -:  486:  if (!val)
        -:  487:    parser.emitError(enumLoc, "unknown attribute: '") << enumSpec << "'";
        -:  488:  return val;
        -:  489:}
        -:  490:
        -:  491:template <>
        -:  492:Optional<Type> parseAndVerify<Type>(SPIRVDialect const &dialect,
        -:  493:                                    DialectAsmParser &parser) {
        -:  494:  // TODO: Further verify that the element type can be sampled
        -:  495:  auto ty = parseAndVerifyType(dialect, parser);
        -:  496:  if (!ty)
        -:  497:    return llvm::None;
        -:  498:  return ty;
        -:  499:}
        -:  500:
        -:  501:template <typename IntTy>
        -:  502:static Optional<IntTy> parseAndVerifyInteger(SPIRVDialect const &dialect,
        -:  503:                                             DialectAsmParser &parser) {
        -:  504:  IntTy offsetVal = std::numeric_limits<IntTy>::max();
        -:  505:  if (parser.parseInteger(offsetVal))
        -:  506:    return llvm::None;
        -:  507:  return offsetVal;
        -:  508:}
        -:  509:
        -:  510:template <>
        -:  511:Optional<unsigned> parseAndVerify<unsigned>(SPIRVDialect const &dialect,
        -:  512:                                            DialectAsmParser &parser) {
        -:  513:  return parseAndVerifyInteger<unsigned>(dialect, parser);
        -:  514:}
        -:  515:
        -:  516:namespace {
        -:  517:// Functor object to parse a comma separated list of specs. The function
        -:  518:// parseAndVerify does the actual parsing and verification of individual
        -:  519:// elements. This is a functor since parsing the last element of the list
        -:  520:// (termination condition) needs partial specialization.
        -:  521:template <typename ParseType, typename... Args>
        -:  522:struct ParseCommaSeparatedList {
        -:  523:  Optional<std::tuple<ParseType, Args...>>
        -:  524:  operator()(SPIRVDialect const &dialect, DialectAsmParser &parser) const {
        -:  525:    auto parseVal = parseAndVerify<ParseType>(dialect, parser);
        -:  526:    if (!parseVal)
        -:  527:      return llvm::None;
        -:  528:
        -:  529:    auto numArgs = std::tuple_size<std::tuple<Args...>>::value;
        -:  530:    if (numArgs != 0 && failed(parser.parseComma()))
        -:  531:      return llvm::None;
        -:  532:    auto remainingValues = ParseCommaSeparatedList<Args...>{}(dialect, parser);
        -:  533:    if (!remainingValues)
        -:  534:      return llvm::None;
        -:  535:    return std::tuple_cat(std::tuple<ParseType>(parseVal.value()),
        -:  536:                          remainingValues.value());
        -:  537:  }
        -:  538:};
        -:  539:
        -:  540:// Partial specialization of the function to parse a comma separated list of
        -:  541:// specs to parse the last element of the list.
        -:  542:template <typename ParseType>
        -:  543:struct ParseCommaSeparatedList<ParseType> {
        -:  544:  Optional<std::tuple<ParseType>> operator()(SPIRVDialect const &dialect,
        -:  545:                                             DialectAsmParser &parser) const {
        -:  546:    if (auto value = parseAndVerify<ParseType>(dialect, parser))
        -:  547:      return std::tuple<ParseType>(*value);
        -:  548:    return llvm::None;
        -:  549:  }
        -:  550:};
        -:  551:} // namespace
        -:  552:
        -:  553:// dim ::= `1D` | `2D` | `3D` | `Cube` | <and other SPIR-V Dim specifiers...>
        -:  554://
        -:  555:// depth-info ::= `NoDepth` | `IsDepth` | `DepthUnknown`
        -:  556://
        -:  557:// arrayed-info ::= `NonArrayed` | `Arrayed`
        -:  558://
        -:  559:// sampling-info ::= `SingleSampled` | `MultiSampled`
        -:  560://
        -:  561:// sampler-use-info ::= `SamplerUnknown` | `NeedSampler` |  `NoSampler`
        -:  562://
        -:  563:// format ::= `Unknown` | `Rgba32f` | <and other SPIR-V Image formats...>
        -:  564://
        -:  565:// image-type ::= `!spirv.image<` element-type `,` dim `,` depth-info `,`
        -:  566://                              arrayed-info `,` sampling-info `,`
        -:  567://                              sampler-use-info `,` format `>`
function _ZL14parseImageTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  568:static Type parseImageType(SPIRVDialect const &dialect,
        -:  569:                           DialectAsmParser &parser) {
    #####:  570:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  571:    return Type();
        -:  572:
    #####:  573:  auto value =
        -:  574:      ParseCommaSeparatedList<Type, Dim, ImageDepthInfo, ImageArrayedInfo,
        -:  575:                              ImageSamplingInfo, ImageSamplerUseInfo,
    #####:  576:                              ImageFormat>{}(dialect, parser);
call    0 never executed
    #####:  577:  if (!value)
branch  0 never executed
branch  1 never executed
    #####:  578:    return Type();
        -:  579:
    #####:  580:  if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  581:    return Type();
    #####:  582:  return ImageType::get(*value);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  583:}
        -:  584:
        -:  585:// sampledImage-type :: = `!spirv.sampledImage<` image-type `>`
        -:  586:static Type parseSampledImageType(SPIRVDialect const &dialect,
        -:  587:                                  DialectAsmParser &parser) {
        -:  588:  if (parser.parseLess())
        -:  589:    return Type();
        -:  590:
        -:  591:  Type parsedType = parseAndVerifySampledImageType(dialect, parser);
        -:  592:  if (!parsedType)
        -:  593:    return Type();
        -:  594:
        -:  595:  if (parser.parseGreater())
        -:  596:    return Type();
        -:  597:  return SampledImageType::get(parsedType);
        -:  598:}
        -:  599:
        -:  600:// Parse decorations associated with a member.
function _ZL28parseStructMemberDecorationsRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserEN4llvm8ArrayRefINS_4TypeEEERNS6_15SmallVectorImplIjEERNSA_INS0_10StructType20MemberDecorationInfoEEE called 0 returned 0% blocks executed 0%
    #####:  601:static ParseResult parseStructMemberDecorations(
        -:  602:    SPIRVDialect const &dialect, DialectAsmParser &parser,
        -:  603:    ArrayRef<Type> memberTypes,
        -:  604:    SmallVectorImpl<StructType::OffsetInfo> &offsetInfo,
        -:  605:    SmallVectorImpl<StructType::MemberDecorationInfo> &memberDecorationInfo) {
        -:  606:
        -:  607:  // Check if the first element is offset.
    #####:  608:  SMLoc offsetLoc = parser.getCurrentLocation();
call    0 never executed
    #####:  609:  StructType::OffsetInfo offset = 0;
    #####:  610:  OptionalParseResult offsetParseResult = parser.parseOptionalInteger(offset);
call    0 never executed
    #####:  611:  if (offsetParseResult.has_value()) {
branch  0 never executed
branch  1 never executed
    #####:  612:    if (failed(*offsetParseResult))
branch  0 never executed
branch  1 never executed
    #####:  613:      return failure();
        -:  614:
    #####:  615:    if (offsetInfo.size() != memberTypes.size() - 1) {
branch  0 never executed
branch  1 never executed
    #####:  616:      return parser.emitError(offsetLoc,
call    0 never executed
call    1 never executed
        -:  617:                              "offset specification must be given for "
    #####:  618:                              "all members");
call    0 never executed
call    1 never executed
        -:  619:    }
    #####:  620:    offsetInfo.push_back(offset);
call    0 never executed
        -:  621:  }
        -:  622:
        -:  623:  // Check for no spirv::Decorations.
    #####:  624:  if (succeeded(parser.parseOptionalRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  625:    return success();
        -:  626:
        -:  627:  // If there was an offset, make sure to parse the comma.
    #####:  628:  if (offsetParseResult.has_value() && parser.parseComma())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  629:    return failure();
        -:  630:
        -:  631:  // Check for spirv::Decorations.
function _ZZL28parseStructMemberDecorationsRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserEN4llvm8ArrayRefINS_4TypeEEERNS6_15SmallVectorImplIjEERNSA_INS0_10StructType20MemberDecorationInfoEEEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####:  632:  auto parseDecorations = [&]() {
    #####:  633:    auto memberDecoration = parseAndVerify<spirv::Decoration>(dialect, parser);
call    0 never executed
    #####:  634:    if (!memberDecoration)
branch  0 never executed
branch  1 never executed
    #####:  635:      return failure();
        -:  636:
        -:  637:    // Parse member decoration value if it exists.
    #####:  638:    if (succeeded(parser.parseOptionalEqual())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  639:      auto memberDecorationValue =
    #####:  640:          parseAndVerifyInteger<uint32_t>(dialect, parser);
call    0 never executed
        -:  641:
    #####:  642:      if (!memberDecorationValue)
branch  0 never executed
branch  1 never executed
    #####:  643:        return failure();
        -:  644:
    #####:  645:      memberDecorationInfo.emplace_back(
branch  0 never executed
branch  1 never executed
    #####:  646:          static_cast<uint32_t>(memberTypes.size() - 1), 1,
    #####:  647:          memberDecoration.value(), memberDecorationValue.value());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  648:    } else {
    #####:  649:      memberDecorationInfo.emplace_back(
    #####:  650:          static_cast<uint32_t>(memberTypes.size() - 1), 0,
    #####:  651:          memberDecoration.value(), 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  652:    }
    #####:  653:    return success();
    #####:  654:  };
    #####:  655:  if (failed(parser.parseCommaSeparatedList(parseDecorations)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  656:      failed(parser.parseRSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  657:    return failure();
        -:  658:
    #####:  659:  return success();
        -:  660:}
        -:  661:
        -:  662:// struct-member-decoration ::= integer-literal? spirv-decoration*
        -:  663:// struct-type ::=
        -:  664://             `!spirv.struct<` (id `,`)?
        -:  665://                          `(`
        -:  666://                            (spirv-type (`[` struct-member-decoration `]`)?)*
        -:  667://                          `)>`
function _ZL15parseStructTypeRKN4mlir5spirv12SPIRVDialectERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  668:static Type parseStructType(SPIRVDialect const &dialect,
        -:  669:                            DialectAsmParser &parser) {
        -:  670:  // TODO: This function is quite lengthy. Break it down into smaller chunks.
        -:  671:
        -:  672:  // To properly resolve recursive references while parsing recursive struct
        -:  673:  // types, we need to maintain a list of enclosing struct type names. This set
        -:  674:  // maintains the names of struct types in which the type we are about to parse
        -:  675:  // is nested.
        -:  676:  //
        -:  677:  // Note: This has to be thread_local to enable multiple threads to safely
        -:  678:  // parse concurrently.
    #####:  679:  thread_local SetVector<StringRef> structContext;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  680:
    #####:  681:  static auto removeIdentifierAndFail = [](SetVector<StringRef> &structContext,
        -:  682:                                           StringRef identifier) {
    #####:  683:    if (!identifier.empty())
    #####:  684:      structContext.remove(identifier);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  685:
    #####:  686:    return Type();
        -:  687:  };
        -:  688:
    #####:  689:  if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  690:    return Type();
        -:  691:
    #####:  692:  StringRef identifier;
        -:  693:
        -:  694:  // Check if this is an identified struct type.
    #####:  695:  if (succeeded(parser.parseOptionalKeyword(&identifier))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  696:    // Check if this is a possible recursive reference.
    #####:  697:    if (succeeded(parser.parseOptionalGreater())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  698:      if (structContext.count(identifier) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  699:        parser.emitError(
call    0 never executed
call    1 never executed
    #####:  700:            parser.getNameLoc(),
call    0 never executed
    #####:  701:            "recursive struct reference not nested in struct definition");
call    0 never executed
        -:  702:
    #####:  703:        return Type();
        -:  704:      }
        -:  705:
    #####:  706:      return StructType::getIdentified(dialect.getContext(), identifier);
call    0 never executed
        -:  707:    }
        -:  708:
    #####:  709:    if (failed(parser.parseComma()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  710:      return Type();
        -:  711:
    #####:  712:    if (structContext.count(identifier) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  713:      parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  714:                       "identifier already used for an enclosing struct");
call    0 never executed
        -:  715:
    #####:  716:      return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
        -:  717:    }
        -:  718:
    #####:  719:    structContext.insert(identifier);
call    0 never executed
        -:  720:  }
        -:  721:
    #####:  722:  if (failed(parser.parseLParen()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  723:    return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
        -:  724:
    #####:  725:  if (succeeded(parser.parseOptionalRParen()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  726:      succeeded(parser.parseOptionalGreater())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  727:    if (!identifier.empty())
branch  0 never executed
branch  1 never executed
    #####:  728:      structContext.remove(identifier);
call    0 never executed
        -:  729:
    #####:  730:    return StructType::getEmpty(dialect.getContext(), identifier);
call    0 never executed
        -:  731:  }
        -:  732:
    #####:  733:  StructType idStructTy;
        -:  734:
    #####:  735:  if (!identifier.empty())
branch  0 never executed
branch  1 never executed
    #####:  736:    idStructTy = StructType::getIdentified(dialect.getContext(), identifier);
call    0 never executed
        -:  737:
    #####:  738:  SmallVector<Type, 4> memberTypes;
    #####:  739:  SmallVector<StructType::OffsetInfo, 4> offsetInfo;
branch  0 never executed
branch  1 never executed
    #####:  740:  SmallVector<StructType::MemberDecorationInfo, 4> memberDecorationInfo;
branch  0 never executed
branch  1 never executed
        -:  741:
    #####:  742:  do {
    #####:  743:    Type memberType;
    #####:  744:    if (parser.parseType(memberType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  745:      return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
    #####:  746:    memberTypes.push_back(memberType);
call    0 never executed
        -:  747:
    #####:  748:    if (succeeded(parser.parseOptionalLSquare()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  749:      if (parseStructMemberDecorations(dialect, parser, memberTypes, offsetInfo,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  750:                                       memberDecorationInfo))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  751:        return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
    #####:  752:  } while (succeeded(parser.parseOptionalComma()));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  753:
    #####:  754:  if (!offsetInfo.empty() && memberTypes.size() != offsetInfo.size()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  755:    parser.emitError(parser.getNameLoc(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  756:                     "offset specification must be given for all members");
call    0 never executed
    #####:  757:    return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
        -:  758:  }
        -:  759:
    #####:  760:  if (failed(parser.parseRParen()) || failed(parser.parseGreater()))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  761:    return removeIdentifierAndFail(structContext, identifier);
branch  0 never executed
branch  1 never executed
        -:  762:
    #####:  763:  if (!identifier.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  764:    if (failed(idStructTy.trySetBody(memberTypes, offsetInfo,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  765:                                     memberDecorationInfo)))
    #####:  766:      return Type();
        -:  767:
    #####:  768:    structContext.remove(identifier);
call    0 never executed
    #####:  769:    return idStructTy;
        -:  770:  }
        -:  771:
    #####:  772:  return StructType::get(memberTypes, offsetInfo, memberDecorationInfo);
call    0 never executed
        -:  773:}
        -:  774:
        -:  775:// spirv-type ::= array-type
        -:  776://              | element-type
        -:  777://              | image-type
        -:  778://              | pointer-type
        -:  779://              | runtime-array-type
        -:  780://              | sampled-image-type
        -:  781://              | struct-type
function _ZNK4mlir5spirv12SPIRVDialect9parseTypeERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  782:Type SPIRVDialect::parseType(DialectAsmParser &parser) const {
    #####:  783:  StringRef keyword;
    #####:  784:  if (parser.parseKeyword(&keyword))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  785:    return Type();
        -:  786:
    #####:  787:  if (keyword == "array")
branch  0 never executed
branch  1 never executed
    #####:  788:    return parseArrayType(*this, parser);
call    0 never executed
    #####:  789:  if (keyword == "coopmatrix")
branch  0 never executed
branch  1 never executed
    #####:  790:    return parseCooperativeMatrixType(*this, parser);
call    0 never executed
    #####:  791:  if (keyword == "jointmatrix")
branch  0 never executed
branch  1 never executed
    #####:  792:    return parseJointMatrixType(*this, parser);
call    0 never executed
    #####:  793:  if (keyword == "image")
branch  0 never executed
branch  1 never executed
    #####:  794:    return parseImageType(*this, parser);
call    0 never executed
    #####:  795:  if (keyword == "ptr")
branch  0 never executed
branch  1 never executed
    #####:  796:    return parsePointerType(*this, parser);
call    0 never executed
    #####:  797:  if (keyword == "rtarray")
branch  0 never executed
branch  1 never executed
    #####:  798:    return parseRuntimeArrayType(*this, parser);
call    0 never executed
    #####:  799:  if (keyword == "sampled_image")
branch  0 never executed
branch  1 never executed
    #####:  800:    return parseSampledImageType(*this, parser);
call    0 never executed
    #####:  801:  if (keyword == "struct")
branch  0 never executed
branch  1 never executed
    #####:  802:    return parseStructType(*this, parser);
call    0 never executed
    #####:  803:  if (keyword == "matrix")
branch  0 never executed
branch  1 never executed
    #####:  804:    return parseMatrixType(*this, parser);
call    0 never executed
    #####:  805:  parser.emitError(parser.getNameLoc(), "unknown SPIR-V type: ") << keyword;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  806:  return Type();
        -:  807:}
        -:  808:
        -:  809://===----------------------------------------------------------------------===//
        -:  810:// Type Printing
        -:  811://===----------------------------------------------------------------------===//
        -:  812:
function _ZL5printN4mlir5spirv9ArrayTypeERNS_17DialectAsmPrinterE called 2042 returned 100% blocks executed 74%
     2042:  813:static void print(ArrayType type, DialectAsmPrinter &os) {
     8168:  814:  os << "array<" << type.getNumElements() << " x " << type.getElementType();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
     2042:  815:  if (unsigned stride = type.getArrayStride())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  816:    os << ", stride=" << stride;
call    0 never executed
call    1 never executed
     2042:  817:  os << ">";
call    0 returned 100%
     2042:  818:}
        -:  819:
function _ZL5printN4mlir5spirv16RuntimeArrayTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  820:static void print(RuntimeArrayType type, DialectAsmPrinter &os) {
    #####:  821:  os << "rtarray<" << type.getElementType();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  822:  if (unsigned stride = type.getArrayStride())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  823:    os << ", stride=" << stride;
call    0 never executed
call    1 never executed
    #####:  824:  os << ">";
call    0 never executed
    #####:  825:}
        -:  826:
function _ZL5printN4mlir5spirv11PointerTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  827:static void print(PointerType type, DialectAsmPrinter &os) {
    #####:  828:  os << "ptr<" << type.getPointeeType() << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  829:     << stringifyStorageClass(type.getStorageClass()) << ">";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  830:}
        -:  831:
function _ZL5printN4mlir5spirv9ImageTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  832:static void print(ImageType type, DialectAsmPrinter &os) {
    #####:  833:  os << "image<" << type.getElementType() << ", " << stringifyDim(type.getDim())
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  834:     << ", " << stringifyImageDepthInfo(type.getDepthInfo()) << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  835:     << stringifyImageArrayedInfo(type.getArrayedInfo()) << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  836:     << stringifyImageSamplingInfo(type.getSamplingInfo()) << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  837:     << stringifyImageSamplerUseInfo(type.getSamplerUseInfo()) << ", "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  838:     << stringifyImageFormat(type.getImageFormat()) << ">";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  839:}
        -:  840:
function _ZL5printN4mlir5spirv16SampledImageTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  841:static void print(SampledImageType type, DialectAsmPrinter &os) {
    #####:  842:  os << "sampled_image<" << type.getImageType() << ">";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  843:}
        -:  844:
function _ZL5printN4mlir5spirv10StructTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  845:static void print(StructType type, DialectAsmPrinter &os) {
    #####:  846:  thread_local SetVector<StringRef> structContext;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  847:
    #####:  848:  os << "struct<";
call    0 never executed
        -:  849:
    #####:  850:  if (type.isIdentified()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  851:    os << type.getIdentifier();
call    0 never executed
call    1 never executed
        -:  852:
    #####:  853:    if (structContext.count(type.getIdentifier())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  854:      os << ">";
call    0 never executed
    #####:  855:      return;
        -:  856:    }
        -:  857:
    #####:  858:    os << ", ";
call    0 never executed
    #####:  859:    structContext.insert(type.getIdentifier());
call    0 never executed
call    1 never executed
        -:  860:  }
        -:  861:
    #####:  862:  os << "(";
call    0 never executed
        -:  863:
function _ZZL5printN4mlir5spirv10StructTypeERNS_17DialectAsmPrinterEENKUljE_clEj.isra.0 called 0 returned 0% blocks executed 0%
    #####:  864:  auto printMember = [&](unsigned i) {
    #####:  865:    os << type.getElementType(i);
call    0 never executed
call    1 never executed
    #####:  866:    SmallVector<spirv::StructType::MemberDecorationInfo, 0> decorations;
call    0 never executed
    #####:  867:    type.getMemberDecorations(i, decorations);
call    0 never executed
    #####:  868:    if (type.hasOffset() || !decorations.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  869:      os << " [";
call    0 never executed
    #####:  870:      if (type.hasOffset()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  871:        os << type.getMemberOffset(i);
call    0 never executed
call    1 never executed
    #####:  872:        if (!decorations.empty())
branch  0 never executed
branch  1 never executed
    #####:  873:          os << ", ";
call    0 never executed
        -:  874:      }
function _ZZZL5printN4mlir5spirv10StructTypeERNS_17DialectAsmPrinterEENKUljE_clEjENKUlNS1_20MemberDecorationInfoEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  875:      auto eachFn = [&os](spirv::StructType::MemberDecorationInfo decoration) {
    #####:  876:        os << stringifyDecoration(decoration.decoration);
call    0 never executed
call    1 never executed
    #####:  877:        if (decoration.hasValue) {
branch  0 never executed
branch  1 never executed
    #####:  878:          os << "=" << decoration.decorationValue;
call    0 never executed
call    1 never executed
        -:  879:        }
    #####:  880:      };
    #####:  881:      llvm::interleaveComma(decorations, os, eachFn);
call    0 never executed
    #####:  882:      os << "]";
call    0 never executed
        -:  883:    }
    #####:  884:  };
    #####:  885:  llvm::interleaveComma(llvm::seq<unsigned>(0, type.getNumElements()), os,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  886:                        printMember);
    #####:  887:  os << ")>";
call    0 never executed
        -:  888:
    #####:  889:  if (type.isIdentified())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  890:    structContext.remove(type.getIdentifier());
call    0 never executed
call    1 never executed
        -:  891:}
        -:  892:
function _ZL5printN4mlir5spirv23CooperativeMatrixNVTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  893:static void print(CooperativeMatrixNVType type, DialectAsmPrinter &os) {
    #####:  894:  os << "coopmatrix<" << type.getRows() << "x" << type.getColumns() << "x";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  895:  os << type.getElementType() << ", " << stringifyScope(type.getScope());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  896:  os << ">";
call    0 never executed
    #####:  897:}
        -:  898:
function _ZL5printN4mlir5spirv20JointMatrixINTELTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  899:static void print(JointMatrixINTELType type, DialectAsmPrinter &os) {
    #####:  900:  os << "jointmatrix<" << type.getRows() << "x" << type.getColumns() << "x";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  901:  os << type.getElementType() << ", "
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  902:     << stringifyMatrixLayout(type.getMatrixLayout());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  903:  os << ", " << stringifyScope(type.getScope()) << ">";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  904:}
        -:  905:
function _ZL5printN4mlir5spirv10MatrixTypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  906:static void print(MatrixType type, DialectAsmPrinter &os) {
    #####:  907:  os << "matrix<" << type.getNumColumns() << " x " << type.getColumnType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  908:  os << ">";
call    0 never executed
    #####:  909:}
        -:  910:
function _ZNK4mlir5spirv12SPIRVDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterE called 2042 returned 100% blocks executed 92%
     2042:  911:void SPIRVDialect::printType(Type type, DialectAsmPrinter &os) const {
     2042:  912:  TypeSwitch<Type>(type)
call    0 returned 100%
        -:  913:      .Case<ArrayType, CooperativeMatrixNVType, JointMatrixINTELType,
        -:  914:            PointerType, RuntimeArrayType, ImageType, SampledImageType,
    4084*:  915:            StructType, MatrixType>([&](auto type) { print(type, os); })
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 returned 100%
call    9 returned 100%
function _ZZNK4mlir5spirv12SPIRVDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterEENKUlS2_E0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    2042*:  916:      .Default([](Type) { llvm_unreachable("unhandled SPIR-V type"); });
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2042:  917:}
        -:  918:
        -:  919://===----------------------------------------------------------------------===//
        -:  920:// Constant
        -:  921://===----------------------------------------------------------------------===//
        -:  922:
function _ZN4mlir5spirv12SPIRVDialect19materializeConstantERNS_9OpBuilderENS_9AttributeENS_4TypeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  923:Operation *SPIRVDialect::materializeConstant(OpBuilder &builder,
        -:  924:                                             Attribute value, Type type,
        -:  925:                                             Location loc) {
    #####:  926:  if (!spirv::ConstantOp::isBuildableWith(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  927:    return nullptr;
        -:  928:
    #####:  929:  return builder.create<spirv::ConstantOp>(loc, type, value);
call    0 never executed
        -:  930:}
        -:  931:
        -:  932://===----------------------------------------------------------------------===//
        -:  933:// Shader Interface ABI
        -:  934://===----------------------------------------------------------------------===//
        -:  935:
function _ZN4mlir5spirv12SPIRVDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  936:LogicalResult SPIRVDialect::verifyOperationAttribute(Operation *op,
        -:  937:                                                     NamedAttribute attribute) {
    #####:  938:  StringRef symbol = attribute.getName().strref();
call    0 never executed
call    1 never executed
    #####:  939:  Attribute attr = attribute.getValue();
call    0 never executed
        -:  940:
    #####:  941:  if (symbol == spirv::getEntryPointABIAttrName()) {
call    0 never executed
    #####:  942:    if (!attr.isa<spirv::EntryPointABIAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  943:      return op->emitError("'")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  944:             << symbol << "' attribute must be an entry point ABI attribute";
call    0 never executed
call    1 never executed
        -:  945:    }
    #####:  946:  } else if (symbol == spirv::getTargetEnvAttrName()) {
call    0 never executed
    #####:  947:    if (!attr.isa<spirv::TargetEnvAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  948:      return op->emitError("'") << symbol << "' must be a spirv::TargetEnvAttr";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  949:  } else {
    #####:  950:    return op->emitError("found unsupported '")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  951:           << symbol << "' attribute on operation";
call    0 never executed
call    1 never executed
        -:  952:  }
        -:  953:
    #####:  954:  return success();
        -:  955:}
        -:  956:
        -:  957:/// Verifies the given SPIR-V `attribute` attached to a value of the given
        -:  958:/// `valueType` is valid.
function _ZL21verifyRegionAttributeN4mlir8LocationENS_4TypeENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  959:static LogicalResult verifyRegionAttribute(Location loc, Type valueType,
        -:  960:                                           NamedAttribute attribute) {
    #####:  961:  StringRef symbol = attribute.getName().strref();
call    0 never executed
call    1 never executed
    #####:  962:  Attribute attr = attribute.getValue();
call    0 never executed
        -:  963:
    #####:  964:  if (symbol != spirv::getInterfaceVarABIAttrName())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  965:    return emitError(loc, "found unsupported '")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  966:           << symbol << "' attribute on region argument";
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:  auto varABIAttr = attr.dyn_cast<spirv::InterfaceVarABIAttr>();
call    0 never executed
    #####:  969:  if (!varABIAttr)
branch  0 never executed
branch  1 never executed
    #####:  970:    return emitError(loc, "'")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  971:           << symbol << "' must be a spirv::InterfaceVarABIAttr";
call    0 never executed
call    1 never executed
        -:  972:
    #####:  973:  if (varABIAttr.getStorageClass() && !valueType.isIntOrIndexOrFloat())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  974:    return emitError(loc, "'") << symbol
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  975:                               << "' attribute cannot specify storage class "
    #####:  976:                                  "when attaching to a non-scalar value";
call    0 never executed
        -:  977:
    #####:  978:  return success();
        -:  979:}
        -:  980:
function _ZN4mlir5spirv12SPIRVDialect24verifyRegionArgAttributeEPNS_9OperationEjjNS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  981:LogicalResult SPIRVDialect::verifyRegionArgAttribute(Operation *op,
        -:  982:                                                     unsigned regionIndex,
        -:  983:                                                     unsigned argIndex,
        -:  984:                                                     NamedAttribute attribute) {
    #####:  985:  return verifyRegionAttribute(
    #####:  986:      op->getLoc(), op->getRegion(regionIndex).getArgument(argIndex).getType(),
call    0 never executed
call    1 never executed
    #####:  987:      attribute);
call    0 never executed
        -:  988:}
        -:  989:
function _ZN4mlir5spirv12SPIRVDialect27verifyRegionResultAttributeEPNS_9OperationEjjNS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  990:LogicalResult SPIRVDialect::verifyRegionResultAttribute(
        -:  991:    Operation *op, unsigned /*regionIndex*/, unsigned /*resultIndex*/,
        -:  992:    NamedAttribute attribute) {
    #####:  993:  return op->emitError("cannot attach SPIR-V attributes to region result");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  994:}
