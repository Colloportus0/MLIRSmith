        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-1/mlir/lib/IR/AffineMap.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineMap.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/AffineMap.cpp.gcda
        -:    0:Runs:325564
        -:    1://===- AffineMap.cpp - MLIR Affine Map Classes ----------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/AffineMap.h"
        -:   10:#include "AffineMapDetail.h"
        -:   11:#include "mlir/IR/BuiltinAttributes.h"
        -:   12:#include "mlir/IR/BuiltinTypes.h"
        -:   13:#include "mlir/Support/LogicalResult.h"
        -:   14:#include "mlir/Support/MathExtras.h"
        -:   15:#include "llvm/ADT/SmallBitVector.h"
        -:   16:#include "llvm/ADT/SmallSet.h"
        -:   17:#include "llvm/ADT/StringRef.h"
        -:   18:#include "llvm/Support/raw_ostream.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23:namespace {
        -:   24:
        -:   25:// AffineExprConstantFolder evaluates an affine expression using constant
        -:   26:// operands passed in 'operandConsts'. Returns an IntegerAttr attribute
        -:   27:// representing the constant value of the affine expression evaluated on
        -:   28:// constant 'operandConsts', or nullptr if it can't be folded.
        -:   29:class AffineExprConstantFolder {
        -:   30:public:
    #####:   31:  AffineExprConstantFolder(unsigned numDims, ArrayRef<Attribute> operandConsts)
    #####:   32:      : numDims(numDims), operandConsts(operandConsts) {}
        -:   33:
        -:   34:  /// Attempt to constant fold the specified affine expr, or return null on
        -:   35:  /// failure.
function _ZN12_GLOBAL__N_124AffineExprConstantFolder12constantFoldEN4mlir10AffineExprE called 0 returned 0% blocks executed 0%
    #####:   36:  IntegerAttr constantFold(AffineExpr expr) {
    #####:   37:    if (auto result = constantFoldImpl(expr))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   38:      return IntegerAttr::get(IndexType::get(expr.getContext()), *result);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   39:    return nullptr;
        -:   40:  }
        -:   41:
        -:   42:private:
function _ZN12_GLOBAL__N_124AffineExprConstantFolder16constantFoldImplEN4mlir10AffineExprE called 0 returned 0% blocks executed 0%
    #####:   43:  Optional<int64_t> constantFoldImpl(AffineExpr expr) {
    #####:   44:    switch (expr.getKind()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:   45:    case AffineExprKind::Add:
    #####:   46:      return constantFoldBinExpr(
    #####:   47:          expr, [](int64_t lhs, int64_t rhs) { return lhs + rhs; });
call    0 never executed
    #####:   48:    case AffineExprKind::Mul:
    #####:   49:      return constantFoldBinExpr(
    #####:   50:          expr, [](int64_t lhs, int64_t rhs) { return lhs * rhs; });
call    0 never executed
    #####:   51:    case AffineExprKind::Mod:
    #####:   52:      return constantFoldBinExpr(
    #####:   53:          expr, [](int64_t lhs, int64_t rhs) { return mod(lhs, rhs); });
call    0 never executed
    #####:   54:    case AffineExprKind::FloorDiv:
    #####:   55:      return constantFoldBinExpr(
    #####:   56:          expr, [](int64_t lhs, int64_t rhs) { return floorDiv(lhs, rhs); });
call    0 never executed
    #####:   57:    case AffineExprKind::CeilDiv:
    #####:   58:      return constantFoldBinExpr(
    #####:   59:          expr, [](int64_t lhs, int64_t rhs) { return ceilDiv(lhs, rhs); });
call    0 never executed
    #####:   60:    case AffineExprKind::Constant:
    #####:   61:      return expr.cast<AffineConstantExpr>().getValue();
call    0 never executed
call    1 never executed
    #####:   62:    case AffineExprKind::DimId:
    #####:   63:      if (auto attr = operandConsts[expr.cast<AffineDimExpr>().getPosition()]
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   64:                          .dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
    #####:   65:        return attr.getInt();
call    0 never executed
    #####:   66:      return llvm::None;
    #####:   67:    case AffineExprKind::SymbolId:
    #####:   68:      if (auto attr = operandConsts[numDims +
branch  0 never executed
branch  1 never executed
    #####:   69:                                    expr.cast<AffineSymbolExpr>().getPosition()]
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   70:                          .dyn_cast_or_null<IntegerAttr>())
branch  0 never executed
branch  1 never executed
    #####:   71:        return attr.getInt();
call    0 never executed
    #####:   72:      return llvm::None;
        -:   73:    }
    #####:   74:    llvm_unreachable("Unknown AffineExpr");
call    0 never executed
        -:   75:  }
        -:   76:
        -:   77:  // TODO: Change these to operate on APInts too.
function _ZN12_GLOBAL__N_124AffineExprConstantFolder19constantFoldBinExprEN4mlir10AffineExprEPFlllE called 0 returned 0% blocks executed 0%
    #####:   78:  Optional<int64_t> constantFoldBinExpr(AffineExpr expr,
        -:   79:                                        int64_t (*op)(int64_t, int64_t)) {
    #####:   80:    auto binOpExpr = expr.cast<AffineBinaryOpExpr>();
call    0 never executed
    #####:   81:    if (auto lhs = constantFoldImpl(binOpExpr.getLHS()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   82:      if (auto rhs = constantFoldImpl(binOpExpr.getRHS()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   83:        return op(*lhs, *rhs);
call    0 never executed
    #####:   84:    return llvm::None;
        -:   85:  }
        -:   86:
        -:   87:  // The number of dimension operands in AffineMap containing this expression.
        -:   88:  unsigned numDims;
        -:   89:  // The constant valued operands used to evaluate this AffineExpr.
        -:   90:  ArrayRef<Attribute> operandConsts;
        -:   91:};
        -:   92:
        -:   93:} // namespace
        -:   94:
        -:   95:/// Returns a single constant result affine map.
function _ZN4mlir9AffineMap14getConstantMapElPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:   96:AffineMap AffineMap::getConstantMap(int64_t val, MLIRContext *context) {
    #####:   97:  return get(/*dimCount=*/0, /*symbolCount=*/0,
    #####:   98:             {getAffineConstantExpr(val, context)});
call    0 never executed
call    1 never executed
        -:   99:}
        -:  100:
        -:  101:/// Returns an identity affine map (d0, ..., dn) -> (dp, ..., dn) on the most
        -:  102:/// minor dimensions.
function _ZN4mlir9AffineMap19getMinorIdentityMapEjjPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  103:AffineMap AffineMap::getMinorIdentityMap(unsigned dims, unsigned results,
        -:  104:                                         MLIRContext *context) {
    #####:  105:  assert(dims >= results && "Dimension mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  106:  auto id = AffineMap::getMultiDimIdentityMap(dims, context);
call    0 never executed
    #####:  107:  return AffineMap::get(dims, 0, id.getResults().take_back(results), context);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  108:}
        -:  109:
function _ZNK4mlir9AffineMap15isMinorIdentityEv called 0 returned 0% blocks executed 0%
    #####:  110:bool AffineMap::isMinorIdentity() const {
    #####:  111:  return getNumDims() >= getNumResults() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  112:         *this ==
branch  0 never executed
branch  1 never executed
    #####:  113:             getMinorIdentityMap(getNumDims(), getNumResults(), getContext());
        -:  114:}
        -:  115:
        -:  116:/// Returns true if this affine map is a minor identity up to broadcasted
        -:  117:/// dimensions which are indicated by value 0 in the result.
function _ZNK4mlir9AffineMap31isMinorIdentityWithBroadcastingEPN4llvm15SmallVectorImplIjEE called 0 returned 0% blocks executed 0%
    #####:  118:bool AffineMap::isMinorIdentityWithBroadcasting(
        -:  119:    SmallVectorImpl<unsigned> *broadcastedDims) const {
    #####:  120:  if (broadcastedDims)
branch  0 never executed
branch  1 never executed
    #####:  121:    broadcastedDims->clear();
    #####:  122:  if (getNumDims() < getNumResults())
branch  0 never executed
branch  1 never executed
        -:  123:    return false;
    #####:  124:  unsigned suffixStart = getNumDims() - getNumResults();
    #####:  125:  for (const auto &idxAndExpr : llvm::enumerate(getResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  126:    unsigned resIdx = idxAndExpr.index();
call    0 never executed
    #####:  127:    AffineExpr expr = idxAndExpr.value();
call    0 never executed
    #####:  128:    if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  129:      // Each result may be either a constant 0 (broadcasted dimension).
    #####:  130:      if (constExpr.getValue() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        return false;
    #####:  132:      if (broadcastedDims)
branch  0 never executed
branch  1 never executed
    #####:  133:        broadcastedDims->push_back(resIdx);
call    0 never executed
    #####:  134:    } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  135:      // Or it may be the input dimension corresponding to this result position.
    #####:  136:      if (dimExpr.getPosition() != suffixStart + resIdx)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  137:        return false;
        -:  138:    } else {
        -:  139:      return false;
        -:  140:    }
        -:  141:  }
    #####:  142:  return true;
        -:  143:}
        -:  144:
        -:  145:/// Return true if this affine map can be converted to a minor identity with
        -:  146:/// broadcast by doing a permute. Return a permutation (there may be
        -:  147:/// several) to apply to get to a minor identity with broadcasts.
        -:  148:/// Ex:
        -:  149:///  * (d0, d1, d2) -> (0, d1) maps to minor identity (d1, 0 = d2) with
        -:  150:///  perm = [1, 0] and broadcast d2
        -:  151:///  * (d0, d1, d2) -> (d0, 0) cannot be mapped to a minor identity by
        -:  152:///  permutation + broadcast
        -:  153:///  * (d0, d1, d2, d3) -> (0, d1, d3) maps to minor identity (d1, 0 = d2, d3)
        -:  154:///  with perm = [1, 0, 2] and broadcast d2
        -:  155:///  * (d0, d1) -> (d1, 0, 0, d0) maps to minor identity (d0, d1) with extra
        -:  156:///  leading broadcat dimensions. The map returned would be (0, 0, d0, d1) with
        -:  157:///  perm = [3, 0, 1, 2]
function _ZNK4mlir9AffineMap44isPermutationOfMinorIdentityWithBroadcastingERN4llvm15SmallVectorImplIjEE called 0 returned 0% blocks executed 0%
    #####:  158:bool AffineMap::isPermutationOfMinorIdentityWithBroadcasting(
        -:  159:    SmallVectorImpl<unsigned> &permutedDims) const {
    #####:  160:  unsigned projectionStart =
    #####:  161:      getNumResults() < getNumInputs() ? getNumInputs() - getNumResults() : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  162:  permutedDims.clear();
call    0 never executed
    #####:  163:  SmallVector<unsigned> broadcastDims;
call    0 never executed
    #####:  164:  permutedDims.resize(getNumResults(), 0);
        -:  165:  // If there are more results than input dimensions we want the new map to
        -:  166:  // start with broadcast dimensions in order to be a minor identity with
        -:  167:  // broadcasting.
    #####:  168:  unsigned leadingBroadcast =
    #####:  169:      getNumResults() > getNumInputs() ? getNumResults() - getNumInputs() : 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  170:  llvm::SmallBitVector dimFound(std::max(getNumInputs(), getNumResults()),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  171:                                false);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  172:  for (const auto &idxAndExpr : llvm::enumerate(getResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  173:    unsigned resIdx = idxAndExpr.index();
call    0 never executed
    #####:  174:    AffineExpr expr = idxAndExpr.value();
call    0 never executed
        -:  175:    // Each result may be either a constant 0 (broadcast dimension) or a
        -:  176:    // dimension.
    #####:  177:    if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  178:      if (constExpr.getValue() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  179:        return false;
    #####:  180:      broadcastDims.push_back(resIdx);
call    0 never executed
    #####:  181:    } else if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  182:      if (dimExpr.getPosition() < projectionStart)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  183:        return false;
    #####:  184:      unsigned newPosition =
    #####:  185:          dimExpr.getPosition() - projectionStart + leadingBroadcast;
call    0 never executed
    #####:  186:      permutedDims[resIdx] = newPosition;
branch  0 never executed
branch  1 never executed
    #####:  187:      dimFound[newPosition] = true;
call    0 never executed
call    1 never executed
        -:  188:    } else {
        -:  189:      return false;
        -:  190:    }
        -:  191:  }
        -:  192:  // Find a permuation for the broadcast dimension. Since they are broadcasted
        -:  193:  // any valid permutation is acceptable. We just permute the dim into a slot
        -:  194:  // without an existing dimension.
    #####:  195:  unsigned pos = 0;
    #####:  196:  for (auto dim : broadcastDims) {
branch  0 never executed
branch  1 never executed
    #####:  197:    while (pos < dimFound.size() && dimFound[pos]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  198:      pos++;
        -:  199:    }
    #####:  200:    permutedDims[dim] = pos++;
branch  0 never executed
branch  1 never executed
        -:  201:  }
        -:  202:  return true;
        -:  203:}
        -:  204:
        -:  205:/// Returns an AffineMap representing a permutation.
function _ZN4mlir9AffineMap17getPermutationMapEN4llvm8ArrayRefIjEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####:  206:AffineMap AffineMap::getPermutationMap(ArrayRef<unsigned> permutation,
        -:  207:                                       MLIRContext *context) {
    #####:  208:  assert(!permutation.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  209:         "Cannot create permutation map from empty permutation vector");
    #####:  210:  SmallVector<AffineExpr, 4> affExprs;
    #####:  211:  for (auto index : permutation)
branch  0 never executed
branch  1 never executed
    #####:  212:    affExprs.push_back(getAffineDimExpr(index, context));
call    0 never executed
call    1 never executed
    #####:  213:  const auto *m = std::max_element(permutation.begin(), permutation.end());
branch  0 never executed
branch  1 never executed
    #####:  214:  auto permutationMap = AffineMap::get(*m + 1, 0, affExprs, context);
call    0 never executed
    #####:  215:  assert(permutationMap.isPermutation() && "Invalid permutation vector");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  216:  return permutationMap;
branch  0 never executed
branch  1 never executed
        -:  217:}
        -:  218:
        -:  219:template <typename AffineExprContainer>
        -:  220:static SmallVector<AffineMap, 4>
     105*:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
     105*:  222:  assert(!exprsList.empty());
     105*:  223:  assert(!exprsList[0].empty());
     105*:  224:  auto context = exprsList[0][0].getContext();
     105*:  225:  int64_t maxDim = -1, maxSym = -1;
     105*:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
     105*:  227:  SmallVector<AffineMap, 4> maps;
     105*:  228:  maps.reserve(exprsList.size());
     210*:  229:  for (const auto &exprs : exprsList)
     105*:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
     105*:  232:  return maps;
        -:  233:}
------------------
_Z17inferFromExprListIN4llvm11SmallVectorIN4mlir10AffineExprELj4EEEENS1_INS2_9AffineMapELj4EEENS0_8ArrayRefIT_EE:
function _Z17inferFromExprListIN4llvm11SmallVectorIN4mlir10AffineExprELj4EEEENS1_INS2_9AffineMapELj4EEENS0_8ArrayRefIT_EE called 0 returned 0% blocks executed 0%
    #####:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
    #####:  222:  assert(!exprsList.empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  223:  assert(!exprsList[0].empty());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  224:  auto context = exprsList[0][0].getContext();
call    0 never executed
    #####:  225:  int64_t maxDim = -1, maxSym = -1;
    #####:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  227:  SmallVector<AffineMap, 4> maps;
    #####:  228:  maps.reserve(exprsList.size());
branch  0 never executed
branch  1 never executed
    #####:  229:  for (const auto &exprs : exprsList)
branch  0 never executed
branch  1 never executed
    #####:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
call    0 never executed
call    1 never executed
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
    #####:  232:  return maps;
        -:  233:}
------------------
_Z17inferFromExprListIN4llvm8ArrayRefIN4mlir10AffineExprEEEENS0_11SmallVectorINS2_9AffineMapELj4EEENS1_IT_EE:
function _Z17inferFromExprListIN4llvm8ArrayRefIN4mlir10AffineExprEEEENS0_11SmallVectorINS2_9AffineMapELj4EEENS1_IT_EE called 105 returned 100% blocks executed 73%
      105:  221:inferFromExprList(ArrayRef<AffineExprContainer> exprsList) {
     105*:  222:  assert(!exprsList.empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     105*:  223:  assert(!exprsList[0].empty());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      105:  224:  auto context = exprsList[0][0].getContext();
call    0 returned 100%
      105:  225:  int64_t maxDim = -1, maxSym = -1;
      105:  226:  getMaxDimAndSymbol(exprsList, maxDim, maxSym);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
      105:  227:  SmallVector<AffineMap, 4> maps;
      105:  228:  maps.reserve(exprsList.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      210:  229:  for (const auto &exprs : exprsList)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      105:  230:    maps.push_back(AffineMap::get(/*dimCount=*/maxDim + 1,
call    0 returned 100%
call    1 returned 100%
        -:  231:                                  /*symbolCount=*/maxSym + 1, exprs, context));
      105:  232:  return maps;
        -:  233:}
------------------
        -:  234:
        -:  235:SmallVector<AffineMap, 4>
function _ZN4mlir9AffineMap17inferFromExprListEN4llvm8ArrayRefINS2_INS_10AffineExprEEEEE called 105 returned 100% blocks executed 100%
      105:  236:AffineMap::inferFromExprList(ArrayRef<ArrayRef<AffineExpr>> exprsList) {
      105:  237:  return ::inferFromExprList(exprsList);
call    0 returned 100%
        -:  238:}
        -:  239:
        -:  240:SmallVector<AffineMap, 4>
function _ZN4mlir9AffineMap17inferFromExprListEN4llvm8ArrayRefINS1_11SmallVectorINS_10AffineExprELj4EEEEE called 0 returned 0% blocks executed 0%
    #####:  241:AffineMap::inferFromExprList(ArrayRef<SmallVector<AffineExpr, 4>> exprsList) {
    #####:  242:  return ::inferFromExprList(exprsList);
call    0 never executed
call    1 never executed
        -:  243:}
        -:  244:
function _ZN4mlir9AffineMap32getLargestKnownDivisorOfMapExprsEv called 0 returned 0% blocks executed 0%
    #####:  245:uint64_t AffineMap::getLargestKnownDivisorOfMapExprs() {
    #####:  246:  uint64_t gcd = 0;
    #####:  247:  for (AffineExpr resultExpr : getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  248:    uint64_t thisGcd = resultExpr.getLargestKnownDivisor();
call    0 never executed
    #####:  249:    gcd = std::gcd(gcd, thisGcd);
        -:  250:  }
    #####:  251:  if (gcd == 0)
branch  0 never executed
branch  1 never executed
    #####:  252:    gcd = std::numeric_limits<uint64_t>::max();
    #####:  253:  return gcd;
        -:  254:}
        -:  255:
function _ZN4mlir9AffineMap22getMultiDimIdentityMapEjPNS_11MLIRContextE called 11887 returned 100% blocks executed 100%
    11887:  256:AffineMap AffineMap::getMultiDimIdentityMap(unsigned numDims,
        -:  257:                                            MLIRContext *context) {
    11887:  258:  SmallVector<AffineExpr, 4> dimExprs;
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
    11887:  259:  dimExprs.reserve(numDims);
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
    55699:  260:  for (unsigned i = 0; i < numDims; ++i)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
    43812:  261:    dimExprs.push_back(mlir::getAffineDimExpr(i, context));
call    0 returned 100%
call    1 returned 100%
    11887:  262:  return get(/*dimCount=*/numDims, /*symbolCount=*/0, dimExprs, context);
call    0 returned 100%
branch  1 taken 19% (fallthrough)
branch  2 taken 81%
        -:  263:}
        -:  264:
function _ZNK4mlir9AffineMap10getContextEv called 11911 returned 100% blocks executed 100%
   11911*:  265:MLIRContext *AffineMap::getContext() const { return map->context; }
        -:  266:
function _ZNK4mlir9AffineMap10isIdentityEv called 13308 returned 100% blocks executed 78%
    13308:  267:bool AffineMap::isIdentity() const {
    13308:  268:  if (getNumDims() != getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  269:    return false;
    13308:  270:  ArrayRef<AffineExpr> results = getResults();
call    0 returned 100%
    61981:  271:  for (unsigned i = 0, numDims = getNumDims(); i < numDims; ++i) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
    48673:  272:    auto expr = results[i].dyn_cast<AffineDimExpr>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
    48673:  273:    if (!expr || expr.getPosition() != i)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  274:      return false;
        -:  275:  }
        -:  276:  return true;
        -:  277:}
        -:  278:
function _ZNK4mlir9AffineMap7isEmptyEv called 0 returned 0% blocks executed 0%
    #####:  279:bool AffineMap::isEmpty() const {
    #####:  280:  return getNumDims() == 0 && getNumSymbols() == 0 && getNumResults() == 0;
branch  0 never executed
branch  1 never executed
        -:  281:}
        -:  282:
function _ZNK4mlir9AffineMap16isSingleConstantEv called 0 returned 0% blocks executed 0%
    #####:  283:bool AffineMap::isSingleConstant() const {
    #####:  284:  return getNumResults() == 1 && getResult(0).isa<AffineConstantExpr>();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  285:}
        -:  286:
function _ZNK4mlir9AffineMap10isConstantEv called 0 returned 0% blocks executed 0%
    #####:  287:bool AffineMap::isConstant() const {
    #####:  288:  return llvm::all_of(getResults(), [](AffineExpr expr) {
call    0 never executed
call    1 never executed
        -:  289:    return expr.isa<AffineConstantExpr>();
    #####:  290:  });
        -:  291:}
        -:  292:
function _ZNK4mlir9AffineMap23getSingleConstantResultEv called 0 returned 0% blocks executed 0%
    #####:  293:int64_t AffineMap::getSingleConstantResult() const {
    #####:  294:  assert(isSingleConstant() && "map must have a single constant result");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  295:  return getResult(0).cast<AffineConstantExpr>().getValue();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  296:}
        -:  297:
function _ZNK4mlir9AffineMap18getConstantResultsEv called 0 returned 0% blocks executed 0%
    #####:  298:SmallVector<int64_t> AffineMap::getConstantResults() const {
    #####:  299:  assert(isConstant() && "map must have only constant results");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  300:  SmallVector<int64_t> result;
call    0 never executed
    #####:  301:  for (auto expr : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  302:    result.emplace_back(expr.cast<AffineConstantExpr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  303:  return result;
        -:  304:}
        -:  305:
function _ZNK4mlir9AffineMap10getNumDimsEv called 12142 returned 100% blocks executed 67%
   38758*:  306:unsigned AffineMap::getNumDims() const {
   38758*:  307:  assert(map && "uninitialized map storage");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
branch 17 taken 0% (fallthrough)
branch 18 taken 100%
call   19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 taken 0% (fallthrough)
branch 24 taken 100%
call   25 never executed
branch 26 taken 0% (fallthrough)
branch 27 taken 100%
call   28 never executed
branch 29 never executed
branch 30 never executed
call   31 never executed
branch 32 never executed
branch 33 never executed
call   34 never executed
branch 35 never executed
branch 36 never executed
call   37 never executed
branch 38 never executed
branch 39 never executed
call   40 never executed
   13308*:  308:  return map->numDims;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  309:}
function _ZNK4mlir9AffineMap13getNumSymbolsEv called 129 returned 100% blocks executed 67%
     129*:  310:unsigned AffineMap::getNumSymbols() const {
     129*:  311:  assert(map && "uninitialized map storage");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
call   15 never executed
    #####:  312:  return map->numSymbols;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  313:}
function _ZNK4mlir9AffineMap13getNumResultsEv called 105 returned 100% blocks executed 100%
   13413*:  314:unsigned AffineMap::getNumResults() const { return getResults().size(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
call   37 returned 100%
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 returned 100%
branch 45 taken 100% (fallthrough)
branch 46 taken 0%
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
branch 59 never executed
branch 60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
branch 64 never executed
branch 65 never executed
call   66 never executed
branch 67 never executed
branch 68 never executed
function _ZNK4mlir9AffineMap12getNumInputsEv called 0 returned 0% blocks executed 0%
    #####:  315:unsigned AffineMap::getNumInputs() const {
    #####:  316:  assert(map && "uninitialized map storage");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  317:  return map->numDims + map->numSymbols;
        -:  318:}
function _ZNK4mlir9AffineMap10getResultsEv called 26745 returned 100% blocks executed 67%
    26745:  319:ArrayRef<AffineExpr> AffineMap::getResults() const {
   26745*:  320:  assert(map && "uninitialized map storage");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    26745:  321:  return map->results();
        -:  322:}
function _ZNK4mlir9AffineMap9getResultEj called 0 returned 0% blocks executed 0%
    #####:  323:AffineExpr AffineMap::getResult(unsigned idx) const {
    #####:  324:  return getResults()[idx];
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  325:}
        -:  326:
function _ZNK4mlir9AffineMap14getDimPositionEj called 0 returned 0% blocks executed 0%
    #####:  327:unsigned AffineMap::getDimPosition(unsigned idx) const {
    #####:  328:  return getResult(idx).cast<AffineDimExpr>().getPosition();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  329:}
        -:  330:
function _ZNK4mlir9AffineMap19getPermutedPositionEj called 0 returned 0% blocks executed 0%
    #####:  331:unsigned AffineMap::getPermutedPosition(unsigned input) const {
    #####:  332:  assert(isPermutation() && "invalid permutation request");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  333:  for (unsigned i = 0, numResults = getNumResults(); i < numResults; i++)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  334:    if (getDimPosition(i) == input)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:      return i;
    #####:  336:  llvm_unreachable("incorrect permutation request");
        -:  337:}
        -:  338:
        -:  339:/// Folds the results of the application of an affine map on the provided
        -:  340:/// operands to a constant if possible. Returns false if the folding happens,
        -:  341:/// true otherwise.
        -:  342:LogicalResult
function _ZNK4mlir9AffineMap12constantFoldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplIS3_EE called 0 returned 0% blocks executed 0%
    #####:  343:AffineMap::constantFold(ArrayRef<Attribute> operandConstants,
        -:  344:                        SmallVectorImpl<Attribute> &results) const {
        -:  345:  // Attempt partial folding.
    #####:  346:  SmallVector<int64_t, 2> integers;
call    0 never executed
    #####:  347:  partialConstantFold(operandConstants, &integers);
call    0 never executed
        -:  348:
        -:  349:  // If all expressions folded to a constant, populate results with attributes
        -:  350:  // containing those constants.
    #####:  351:  if (integers.empty())
branch  0 never executed
branch  1 never executed
    #####:  352:    return failure();
        -:  353:
function _ZZNK4mlir9AffineMap12constantFoldEN4llvm8ArrayRefINS_9AttributeEEERNS1_15SmallVectorImplIS3_EEENKUllE_clEl.isra.0 called 0 returned 0% blocks executed 0%
    #####:  354:  auto range = llvm::map_range(integers, [this](int64_t i) {
    #####:  355:    return IntegerAttr::get(IndexType::get(getContext()), i);
call    0 never executed
call    1 never executed
    #####:  356:  });
call    0 never executed
    #####:  357:  results.append(range.begin(), range.end());
call    0 never executed
    #####:  358:  return success();
branch  0 never executed
branch  1 never executed
        -:  359:}
        -:  360:
        -:  361:AffineMap
function _ZNK4mlir9AffineMap19partialConstantFoldEN4llvm8ArrayRefINS_9AttributeEEEPNS1_15SmallVectorImplIlEE called 0 returned 0% blocks executed 0%
    #####:  362:AffineMap::partialConstantFold(ArrayRef<Attribute> operandConstants,
        -:  363:                               SmallVectorImpl<int64_t> *results) const {
    #####:  364:  assert(getNumInputs() == operandConstants.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  365:
        -:  366:  // Fold each of the result expressions.
    #####:  367:  AffineExprConstantFolder exprFolder(getNumDims(), operandConstants);
branch  0 never executed
branch  1 never executed
    #####:  368:  SmallVector<AffineExpr, 4> exprs;
call    0 never executed
    #####:  369:  exprs.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  370:
    #####:  371:  for (auto expr : getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  372:    auto folded = exprFolder.constantFold(expr);
call    0 never executed
        -:  373:    // If did not fold to a constant, keep the original expression, and clear
        -:  374:    // the integer results vector.
    #####:  375:    if (folded) {
branch  0 never executed
branch  1 never executed
    #####:  376:      exprs.push_back(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  377:          getAffineConstantExpr(folded.getInt(), folded.getContext()));
    #####:  378:      if (results)
branch  0 never executed
branch  1 never executed
    #####:  379:        results->push_back(folded.getInt());
call    0 never executed
call    1 never executed
        -:  380:    } else {
    #####:  381:      exprs.push_back(expr);
call    0 never executed
    #####:  382:      if (results) {
branch  0 never executed
branch  1 never executed
    #####:  383:        results->clear();
    #####:  384:        results = nullptr;
        -:  385:      }
        -:  386:    }
        -:  387:  }
        -:  388:
    #####:  389:  return get(getNumDims(), getNumSymbols(), exprs, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  390:}
        -:  391:
        -:  392:/// Walk all of the AffineExpr's in this mapping. Each node in an expression
        -:  393:/// tree is visited in postorder.
function _ZNK4mlir9AffineMap9walkExprsEN4llvm12function_refIFvNS_10AffineExprEEEE called 0 returned 0% blocks executed 0%
    #####:  394:void AffineMap::walkExprs(llvm::function_ref<void(AffineExpr)> callback) const {
    #####:  395:  for (auto expr : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  396:    expr.walk(callback);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  397:}
        -:  398:
        -:  399:/// This method substitutes any uses of dimensions and symbols (e.g.
        -:  400:/// dim#0 with dimReplacements[0]) in subexpressions and returns the modified
        -:  401:/// expression mapping.  Because this can be used to eliminate dims and
        -:  402:/// symbols, the client needs to specify the number of dims and symbols in
        -:  403:/// the result.  The returned map always has the same number of results.
function _ZNK4mlir9AffineMap21replaceDimsAndSymbolsEN4llvm8ArrayRefINS_10AffineExprEEES4_jj called 0 returned 0% blocks executed 0%
    #####:  404:AffineMap AffineMap::replaceDimsAndSymbols(ArrayRef<AffineExpr> dimReplacements,
        -:  405:                                           ArrayRef<AffineExpr> symReplacements,
        -:  406:                                           unsigned numResultDims,
        -:  407:                                           unsigned numResultSyms) const {
    #####:  408:  SmallVector<AffineExpr, 8> results;
call    0 never executed
    #####:  409:  results.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  410:  for (auto expr : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  411:    results.push_back(
call    0 never executed
call    1 never executed
        -:  412:        expr.replaceDimsAndSymbols(dimReplacements, symReplacements));
    #####:  413:  return get(numResultDims, numResultSyms, results, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  414:}
        -:  415:
        -:  416:/// Sparse replace method. Apply AffineExpr::replace(`expr`, `replacement`) to
        -:  417:/// each of the results and return a new AffineMap with the new results and
        -:  418:/// with the specified number of dims and symbols.
function _ZNK4mlir9AffineMap7replaceENS_10AffineExprES1_jj called 0 returned 0% blocks executed 0%
    #####:  419:AffineMap AffineMap::replace(AffineExpr expr, AffineExpr replacement,
        -:  420:                             unsigned numResultDims,
        -:  421:                             unsigned numResultSyms) const {
    #####:  422:  SmallVector<AffineExpr, 4> newResults;
call    0 never executed
    #####:  423:  newResults.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  424:  for (AffineExpr e : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  425:    newResults.push_back(e.replace(expr, replacement));
call    0 never executed
call    1 never executed
    #####:  426:  return AffineMap::get(numResultDims, numResultSyms, newResults, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  427:}
        -:  428:
        -:  429:/// Sparse replace method. Apply AffineExpr::replace(`map`) to each of the
        -:  430:/// results and return a new AffineMap with the new results and with the
        -:  431:/// specified number of dims and symbols.
function _ZNK4mlir9AffineMap7replaceERKN4llvm8DenseMapINS_10AffineExprES3_NS1_12DenseMapInfoIS3_vEENS1_6detail12DenseMapPairIS3_S3_EEEEjj called 0 returned 0% blocks executed 0%
    #####:  432:AffineMap AffineMap::replace(const DenseMap<AffineExpr, AffineExpr> &map,
        -:  433:                             unsigned numResultDims,
        -:  434:                             unsigned numResultSyms) const {
    #####:  435:  SmallVector<AffineExpr, 4> newResults;
call    0 never executed
    #####:  436:  newResults.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  437:  for (AffineExpr e : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  438:    newResults.push_back(e.replace(map));
call    0 never executed
call    1 never executed
    #####:  439:  return AffineMap::get(numResultDims, numResultSyms, newResults, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  440:}
        -:  441:
        -:  442:AffineMap
function _ZNK4mlir9AffineMap7replaceERKN4llvm8DenseMapINS_10AffineExprES3_NS1_12DenseMapInfoIS3_vEENS1_6detail12DenseMapPairIS3_S3_EEEE called 0 returned 0% blocks executed 0%
    #####:  443:AffineMap::replace(const DenseMap<AffineExpr, AffineExpr> &map) const {
    #####:  444:  SmallVector<AffineExpr, 4> newResults;
call    0 never executed
    #####:  445:  newResults.reserve(getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  446:  for (AffineExpr e : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  447:    newResults.push_back(e.replace(map));
call    0 never executed
call    1 never executed
    #####:  448:  return AffineMap::inferFromExprList(newResults).front();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  449:}
        -:  450:
function _ZNK4mlir9AffineMap7composeES0_ called 0 returned 0% blocks executed 0%
    #####:  451:AffineMap AffineMap::compose(AffineMap map) const {
    #####:  452:  assert(getNumDims() == map.getNumResults() && "Number of results mismatch");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  453:  // Prepare `map` by concatenating the symbols and rewriting its exprs.
    #####:  454:  unsigned numDims = map.getNumDims();
branch  0 never executed
branch  1 never executed
    #####:  455:  unsigned numSymbolsThisMap = getNumSymbols();
branch  0 never executed
branch  1 never executed
    #####:  456:  unsigned numSymbols = numSymbolsThisMap + map.getNumSymbols();
    #####:  457:  SmallVector<AffineExpr, 8> newDims(numDims);
call    0 never executed
    #####:  458:  for (unsigned idx = 0; idx < numDims; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  459:    newDims[idx] = getAffineDimExpr(idx, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  460:  }
    #####:  461:  SmallVector<AffineExpr, 8> newSymbols(numSymbols - numSymbolsThisMap);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  462:  for (unsigned idx = numSymbolsThisMap; idx < numSymbols; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  463:    newSymbols[idx - numSymbolsThisMap] =
branch  0 never executed
branch  1 never executed
    #####:  464:        getAffineSymbolExpr(idx, getContext());
call    0 never executed
        -:  465:  }
    #####:  466:  auto newMap =
call    0 never executed
    #####:  467:      map.replaceDimsAndSymbols(newDims, newSymbols, numDims, numSymbols);
call    0 never executed
    #####:  468:  SmallVector<AffineExpr, 8> exprs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  469:  exprs.reserve(getResults().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  470:  for (auto expr : getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  471:    exprs.push_back(expr.compose(newMap));
call    0 never executed
call    1 never executed
    #####:  472:  return AffineMap::get(numDims, numSymbols, exprs, map.getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  473:}
        -:  474:
function _ZNK4mlir9AffineMap7composeEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:  475:SmallVector<int64_t, 4> AffineMap::compose(ArrayRef<int64_t> values) const {
    #####:  476:  assert(getNumSymbols() == 0 && "Expected symbol-less map");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  477:  SmallVector<AffineExpr, 4> exprs;
branch  0 never executed
branch  1 never executed
    #####:  478:  exprs.reserve(values.size());
branch  0 never executed
branch  1 never executed
    #####:  479:  MLIRContext *ctx = getContext();
    #####:  480:  for (auto v : values)
branch  0 never executed
branch  1 never executed
    #####:  481:    exprs.push_back(getAffineConstantExpr(v, ctx));
call    0 never executed
call    1 never executed
    #####:  482:  auto resMap = compose(AffineMap::get(0, 0, exprs, ctx));
call    0 never executed
call    1 never executed
    #####:  483:  SmallVector<int64_t, 4> res;
call    0 never executed
    #####:  484:  res.reserve(resMap.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  485:  for (auto e : resMap.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  486:    res.push_back(e.cast<AffineConstantExpr>().getValue());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  487:  return res;
branch  0 never executed
branch  1 never executed
        -:  488:}
        -:  489:
function _ZNK4mlir9AffineMap22isProjectedPermutationEb called 0 returned 0% blocks executed 0%
    #####:  490:bool AffineMap::isProjectedPermutation(bool allowZeroInResults) const {
    #####:  491:  if (getNumSymbols() > 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  492:    return false;
        -:  493:
        -:  494:  // Having more results than inputs means that results have duplicated dims or
        -:  495:  // zeros that can't be mapped to input dims.
    #####:  496:  if (getNumResults() > getNumInputs())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  497:    return false;
        -:  498:
    #####:  499:  SmallVector<bool, 8> seen(getNumInputs(), false);
call    0 never executed
        -:  500:  // A projected permutation can have, at most, only one instance of each input
        -:  501:  // dimension in the result expressions. Zeros are allowed as long as the
        -:  502:  // number of result expressions is lower or equal than the number of input
        -:  503:  // expressions.
    #####:  504:  for (auto expr : getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  505:    if (auto dim = expr.dyn_cast<AffineDimExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:      if (seen[dim.getPosition()])
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  507:        return false;
    #####:  508:      seen[dim.getPosition()] = true;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  509:    } else {
    #####:  510:      auto constExpr = expr.dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####:  511:      if (!allowZeroInResults || !constExpr || constExpr.getValue() != 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  512:        return false;
        -:  513:    }
        -:  514:  }
        -:  515:
        -:  516:  // Results are either dims or zeros and zeros can be mapped to input dims.
    #####:  517:  return true;
        -:  518:}
        -:  519:
function _ZNK4mlir9AffineMap13isPermutationEv called 0 returned 0% blocks executed 0%
    #####:  520:bool AffineMap::isPermutation() const {
    #####:  521:  if (getNumDims() != getNumResults())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  522:    return false;
    #####:  523:  return isProjectedPermutation();
call    0 never executed
        -:  524:}
        -:  525:
function _ZNK4mlir9AffineMap9getSubMapEN4llvm8ArrayRefIjEE called 0 returned 0% blocks executed 0%
    #####:  526:AffineMap AffineMap::getSubMap(ArrayRef<unsigned> resultPos) const {
    #####:  527:  SmallVector<AffineExpr, 4> exprs;
branch  0 never executed
branch  1 never executed
    #####:  528:  exprs.reserve(resultPos.size());
branch  0 never executed
branch  1 never executed
    #####:  529:  for (auto idx : resultPos)
branch  0 never executed
branch  1 never executed
    #####:  530:    exprs.push_back(getResult(idx));
call    0 never executed
call    1 never executed
    #####:  531:  return AffineMap::get(getNumDims(), getNumSymbols(), exprs, getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  532:}
        -:  533:
function _ZNK4mlir9AffineMap11getSliceMapEjj called 0 returned 0% blocks executed 0%
    #####:  534:AffineMap AffineMap::getSliceMap(unsigned start, unsigned length) const {
    #####:  535:  return AffineMap::get(getNumDims(), getNumSymbols(),
    #####:  536:                        getResults().slice(start, length), getContext());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  537:}
        -:  538:
function _ZNK4mlir9AffineMap14getMajorSubMapEj called 0 returned 0% blocks executed 0%
    #####:  539:AffineMap AffineMap::getMajorSubMap(unsigned numResults) const {
    #####:  540:  if (numResults == 0)
branch  0 never executed
branch  1 never executed
    #####:  541:    return AffineMap();
    #####:  542:  if (numResults > getNumResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  543:    return *this;
    #####:  544:  return getSliceMap(0, numResults);
call    0 never executed
        -:  545:}
        -:  546:
function _ZNK4mlir9AffineMap14getMinorSubMapEj called 0 returned 0% blocks executed 0%
    #####:  547:AffineMap AffineMap::getMinorSubMap(unsigned numResults) const {
    #####:  548:  if (numResults == 0)
branch  0 never executed
branch  1 never executed
    #####:  549:    return AffineMap();
    #####:  550:  if (numResults > getNumResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  551:    return *this;
    #####:  552:  return getSliceMap(getNumResults() - numResults, numResults);
call    0 never executed
call    1 never executed
        -:  553:}
        -:  554:
function _ZN4mlir12compressDimsENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  555:AffineMap mlir::compressDims(AffineMap map,
        -:  556:                             const llvm::SmallBitVector &unusedDims) {
    #####:  557:  unsigned numDims = 0;
    #####:  558:  SmallVector<AffineExpr> dimReplacements;
branch  0 never executed
branch  1 never executed
    #####:  559:  dimReplacements.reserve(map.getNumDims());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:  MLIRContext *context = map.getContext();
    #####:  561:  for (unsigned dim = 0, e = map.getNumDims(); dim < e; ++dim) {
branch  0 never executed
branch  1 never executed
    #####:  562:    if (unusedDims.test(dim))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  563:      dimReplacements.push_back(getAffineConstantExpr(0, context));
call    0 never executed
call    1 never executed
        -:  564:    else
    #####:  565:      dimReplacements.push_back(getAffineDimExpr(numDims++, context));
call    0 never executed
call    1 never executed
        -:  566:  }
    #####:  567:  SmallVector<AffineExpr> resultExprs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  568:  resultExprs.reserve(map.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  569:  for (auto e : map.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  570:    resultExprs.push_back(e.replaceDims(dimReplacements));
call    0 never executed
call    1 never executed
    #####:  571:  return AffineMap::get(numDims, map.getNumSymbols(), resultExprs, context);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  572:}
        -:  573:
function _ZN4mlir18compressUnusedDimsENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  574:AffineMap mlir::compressUnusedDims(AffineMap map) {
    #####:  575:  return compressDims(map, getUnusedDimsBitVector({map}));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  576:}
        -:  577:
        -:  578:static SmallVector<AffineMap>
function _ZL18compressUnusedImplN4llvm8ArrayRefIN4mlir9AffineMapEEENS_12function_refIFS2_S2_EEE called 0 returned 0% blocks executed 0%
    #####:  579:compressUnusedImpl(ArrayRef<AffineMap> maps,
        -:  580:                   llvm::function_ref<AffineMap(AffineMap)> compressionFun) {
    #####:  581:  if (maps.empty())
branch  0 never executed
branch  1 never executed
    #####:  582:    return SmallVector<AffineMap>();
    #####:  583:  SmallVector<AffineExpr> allExprs;
call    0 never executed
    #####:  584:  allExprs.reserve(maps.size() * maps.front().getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  585:  unsigned numDims = maps.front().getNumDims(),
branch  0 never executed
branch  1 never executed
    #####:  586:           numSymbols = maps.front().getNumSymbols();
    #####:  587:  for (auto m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  588:    assert(numDims == m.getNumDims() && numSymbols == m.getNumSymbols() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  589:           "expected maps with same num dims and symbols");
    #####:  590:    llvm::append_range(allExprs, m.getResults());
call    0 never executed
call    1 never executed
        -:  591:  }
    #####:  592:  AffineMap unifiedMap = compressionFun(
call    0 never executed
    #####:  593:      AffineMap::get(numDims, numSymbols, allExprs, maps.front().getContext()));
call    0 never executed
call    1 never executed
    #####:  594:  unsigned unifiedNumDims = unifiedMap.getNumDims(),
branch  0 never executed
branch  1 never executed
    #####:  595:           unifiedNumSymbols = unifiedMap.getNumSymbols();
    #####:  596:  ArrayRef<AffineExpr> unifiedResults = unifiedMap.getResults();
call    0 never executed
    #####:  597:  SmallVector<AffineMap> res;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  598:  res.reserve(maps.size());
branch  0 never executed
branch  1 never executed
    #####:  599:  for (auto m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  600:    res.push_back(AffineMap::get(unifiedNumDims, unifiedNumSymbols,
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  601:                                 unifiedResults.take_front(m.getNumResults()),
branch  0 never executed
branch  1 never executed
        -:  602:                                 m.getContext()));
    #####:  603:    unifiedResults = unifiedResults.drop_front(m.getNumResults());
call    0 never executed
call    1 never executed
        -:  604:  }
    #####:  605:  return res;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  606:}
        -:  607:
function _ZN4mlir18compressUnusedDimsEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  608:SmallVector<AffineMap> mlir::compressUnusedDims(ArrayRef<AffineMap> maps) {
    #####:  609:  return compressUnusedImpl(maps,
    #####:  610:                            [](AffineMap m) { return compressUnusedDims(m); });
call    0 never executed
call    1 never executed
        -:  611:}
        -:  612:
function _ZN4mlir15compressSymbolsENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  613:AffineMap mlir::compressSymbols(AffineMap map,
        -:  614:                                const llvm::SmallBitVector &unusedSymbols) {
    #####:  615:  unsigned numSymbols = 0;
    #####:  616:  SmallVector<AffineExpr> symReplacements;
branch  0 never executed
branch  1 never executed
    #####:  617:  symReplacements.reserve(map.getNumSymbols());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  618:  MLIRContext *context = map.getContext();
    #####:  619:  for (unsigned sym = 0, e = map.getNumSymbols(); sym < e; ++sym) {
branch  0 never executed
branch  1 never executed
    #####:  620:    if (unusedSymbols.test(sym))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  621:      symReplacements.push_back(getAffineConstantExpr(0, context));
call    0 never executed
call    1 never executed
        -:  622:    else
    #####:  623:      symReplacements.push_back(getAffineSymbolExpr(numSymbols++, context));
call    0 never executed
call    1 never executed
        -:  624:  }
    #####:  625:  SmallVector<AffineExpr> resultExprs;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  626:  resultExprs.reserve(map.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  627:  for (auto e : map.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  628:    resultExprs.push_back(e.replaceSymbols(symReplacements));
call    0 never executed
call    1 never executed
    #####:  629:  return AffineMap::get(map.getNumDims(), numSymbols, resultExprs, context);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  630:}
        -:  631:
function _ZN4mlir21compressUnusedSymbolsENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  632:AffineMap mlir::compressUnusedSymbols(AffineMap map) {
    #####:  633:  llvm::SmallBitVector unusedSymbols(map.getNumSymbols(), true);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
function _ZZN4mlir21compressUnusedSymbolsENS_9AffineMapEENKUlNS_10AffineExprEE_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  634:  map.walkExprs([&](AffineExpr expr) {
call    0 never executed
    #####:  635:    if (auto symExpr = expr.dyn_cast<AffineSymbolExpr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  636:      unusedSymbols.reset(symExpr.getPosition());
call    0 never executed
call    1 never executed
    #####:  637:  });
    #####:  638:  return compressSymbols(map, unusedSymbols);
call    0 never executed
        -:  639:}
        -:  640:
function _ZN4mlir21compressUnusedSymbolsEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  641:SmallVector<AffineMap> mlir::compressUnusedSymbols(ArrayRef<AffineMap> maps) {
    #####:  642:  return compressUnusedImpl(
    #####:  643:      maps, [](AffineMap m) { return compressUnusedSymbols(m); });
call    0 never executed
call    1 never executed
        -:  644:}
        -:  645:
function _ZN4mlir17simplifyAffineMapENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  646:AffineMap mlir::simplifyAffineMap(AffineMap map) {
    #####:  647:  SmallVector<AffineExpr, 8> exprs;
call    0 never executed
    #####:  648:  for (auto e : map.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  649:    exprs.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  650:        simplifyAffineExpr(e, map.getNumDims(), map.getNumSymbols()));
        -:  651:  }
    #####:  652:  return AffineMap::get(map.getNumDims(), map.getNumSymbols(), exprs,
    #####:  653:                        map.getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  654:}
        -:  655:
function _ZN4mlir20removeDuplicateExprsENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  656:AffineMap mlir::removeDuplicateExprs(AffineMap map) {
    #####:  657:  auto results = map.getResults();
call    0 never executed
    #####:  658:  SmallVector<AffineExpr, 4> uniqueExprs(results.begin(), results.end());
call    0 never executed
    #####:  659:  uniqueExprs.erase(std::unique(uniqueExprs.begin(), uniqueExprs.end()),
call    0 never executed
call    1 never executed
    #####:  660:                    uniqueExprs.end());
call    0 never executed
    #####:  661:  return AffineMap::get(map.getNumDims(), map.getNumSymbols(), uniqueExprs,
    #####:  662:                        map.getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  663:}
        -:  664:
function _ZN4mlir18inversePermutationENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  665:AffineMap mlir::inversePermutation(AffineMap map) {
    #####:  666:  if (map.isEmpty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  667:    return map;
    #####:  668:  assert(map.getNumSymbols() == 0 && "expected map without symbols");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  669:  SmallVector<AffineExpr, 4> exprs(map.getNumDims());
call    0 never executed
    #####:  670:  for (const auto &en : llvm::enumerate(map.getResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  671:    auto expr = en.value();
call    0 never executed
        -:  672:    // Skip non-permutations.
    #####:  673:    if (auto d = expr.dyn_cast<AffineDimExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  674:      if (exprs[d.getPosition()])
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  675:        continue;
    #####:  676:      exprs[d.getPosition()] = getAffineDimExpr(en.index(), d.getContext());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  677:    }
        -:  678:  }
    #####:  679:  SmallVector<AffineExpr, 4> seenExprs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  680:  seenExprs.reserve(map.getNumDims());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  681:  for (auto expr : exprs)
branch  0 never executed
branch  1 never executed
    #####:  682:    if (expr)
branch  0 never executed
branch  1 never executed
    #####:  683:      seenExprs.push_back(expr);
call    0 never executed
    #####:  684:  if (seenExprs.size() != map.getNumInputs())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  685:    return AffineMap();
    #####:  686:  return AffineMap::get(map.getNumResults(), 0, seenExprs, map.getContext());
call    0 never executed
call    1 never executed
        -:  687:}
        -:  688:
function _ZN4mlir39inverseAndBroadcastProjectedPermutationENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  689:AffineMap mlir::inverseAndBroadcastProjectedPermutation(AffineMap map) {
    #####:  690:  assert(map.isProjectedPermutation(/*allowZeroInResults=*/true));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  691:  MLIRContext *context = map.getContext();
    #####:  692:  AffineExpr zero = mlir::getAffineConstantExpr(0, context);
call    0 never executed
        -:  693:  // Start with all the results as 0.
    #####:  694:  SmallVector<AffineExpr, 4> exprs(map.getNumInputs(), zero);
call    0 never executed
call    1 never executed
    #####:  695:  for (unsigned i : llvm::seq(unsigned(0), map.getNumResults())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  696:    // Skip zeros from input map. 'exprs' is already initialized to zero.
    #####:  697:    if (auto constExpr = map.getResult(i).dyn_cast<AffineConstantExpr>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  698:      assert(constExpr.getValue() == 0 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  699:             "Unexpected constant in projected permutation");
    #####:  700:      (void)constExpr;
    #####:  701:      continue;
        -:  702:    }
        -:  703:
        -:  704:    // Reverse each dimension existing in the original map result.
    #####:  705:    exprs[map.getDimPosition(i)] = getAffineDimExpr(i, context);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  706:  }
    #####:  707:  return AffineMap::get(map.getNumResults(), /*symbolCount=*/0, exprs, context);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  708:}
        -:  709:
function _ZN4mlir16concatAffineMapsEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  710:AffineMap mlir::concatAffineMaps(ArrayRef<AffineMap> maps) {
    #####:  711:  unsigned numResults = 0, numDims = 0, numSymbols = 0;
    #####:  712:  for (auto m : maps)
branch  0 never executed
branch  1 never executed
    #####:  713:    numResults += m.getNumResults();
call    0 never executed
    #####:  714:  SmallVector<AffineExpr, 8> results;
branch  0 never executed
branch  1 never executed
    #####:  715:  results.reserve(numResults);
branch  0 never executed
branch  1 never executed
    #####:  716:  for (auto m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  717:    for (auto res : m.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  718:      results.push_back(res.shiftSymbols(m.getNumSymbols(), numSymbols));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  719:
    #####:  720:    numSymbols += m.getNumSymbols();
branch  0 never executed
branch  1 never executed
    #####:  721:    numDims = std::max(m.getNumDims(), numDims);
branch  0 never executed
branch  1 never executed
        -:  722:  }
    #####:  723:  return AffineMap::get(numDims, numSymbols, results,
branch  0 never executed
branch  1 never executed
    #####:  724:                        maps.front().getContext());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  725:}
        -:  726:
function _ZN4mlir15getProjectedMapENS_9AffineMapERKN4llvm14SmallBitVectorE called 0 returned 0% blocks executed 0%
    #####:  727:AffineMap mlir::getProjectedMap(AffineMap map,
        -:  728:                                const llvm::SmallBitVector &unusedDims) {
    #####:  729:  return compressUnusedSymbols(compressDims(map, unusedDims));
call    0 never executed
call    1 never executed
        -:  730:}
        -:  731:
function _ZN4mlir22getUnusedDimsBitVectorEN4llvm8ArrayRefINS_9AffineMapEEE called 0 returned 0% blocks executed 0%
    #####:  732:llvm::SmallBitVector mlir::getUnusedDimsBitVector(ArrayRef<AffineMap> maps) {
    #####:  733:  unsigned numDims = maps[0].getNumDims();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  734:  llvm::SmallBitVector numDimsBitVector(numDims, true);
call    0 never executed
    #####:  735:  for (const auto &m : maps) {
branch  0 never executed
branch  1 never executed
    #####:  736:    for (unsigned i = 0; i < numDims; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  737:      if (m.isFunctionOfDim(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  738:        numDimsBitVector.reset(i);
call    0 never executed
        -:  739:    }
        -:  740:  }
    #####:  741:  return numDimsBitVector;
        -:  742:}
        -:  743:
        -:  744://===----------------------------------------------------------------------===//
        -:  745:// MutableAffineMap.
        -:  746://===----------------------------------------------------------------------===//
        -:  747:
function _ZN4mlir16MutableAffineMapC2ENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  748:MutableAffineMap::MutableAffineMap(AffineMap map)
    #####:  749:    : results(map.getResults().begin(), map.getResults().end()),
call    0 never executed
    #####:  750:      numDims(map.getNumDims()), numSymbols(map.getNumSymbols()),
    #####:  751:      context(map.getContext()) {}
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  752:
function _ZN4mlir16MutableAffineMap5resetENS_9AffineMapE called 0 returned 0% blocks executed 0%
    #####:  753:void MutableAffineMap::reset(AffineMap map) {
    #####:  754:  results.clear();
branch  0 never executed
branch  1 never executed
    #####:  755:  numDims = map.getNumDims();
branch  0 never executed
branch  1 never executed
    #####:  756:  numSymbols = map.getNumSymbols();
    #####:  757:  context = map.getContext();
    #####:  758:  llvm::append_range(results, map.getResults());
call    0 never executed
call    1 never executed
    #####:  759:}
        -:  760:
function _ZNK4mlir16MutableAffineMap12isMultipleOfEjl called 0 returned 0% blocks executed 0%
    #####:  761:bool MutableAffineMap::isMultipleOf(unsigned idx, int64_t factor) const {
    #####:  762:  if (results[idx].isMultipleOf(factor))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  763:    return true;
        -:  764:
        -:  765:  // TODO: use simplifyAffineExpr and FlatAffineConstraints to
        -:  766:  // complete this (for a more powerful analysis).
        -:  767:  return false;
        -:  768:}
        -:  769:
        -:  770:// Simplifies the result affine expressions of this map. The expressions have to
        -:  771:// be pure for the simplification implemented.
function _ZN4mlir16MutableAffineMap8simplifyEv called 0 returned 0% blocks executed 0%
    #####:  772:void MutableAffineMap::simplify() {
        -:  773:  // Simplify each of the results if possible.
        -:  774:  // TODO: functional-style map
    #####:  775:  for (unsigned i = 0, e = getNumResults(); i < e; i++) {
branch  0 never executed
branch  1 never executed
    #####:  776:    results[i] = simplifyAffineExpr(getResult(i), numDims, numSymbols);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  777:  }
    #####:  778:}
        -:  779:
function _ZNK4mlir16MutableAffineMap12getAffineMapEv called 0 returned 0% blocks executed 0%
    #####:  780:AffineMap MutableAffineMap::getAffineMap() const {
    #####:  781:  return AffineMap::get(numDims, numSymbols, results, context);
call    0 never executed
        -:  782:}
