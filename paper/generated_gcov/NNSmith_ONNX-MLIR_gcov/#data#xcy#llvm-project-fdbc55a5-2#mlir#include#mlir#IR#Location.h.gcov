        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/IR/Location.h
        -:    0:Graph:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Parser/CMakeFiles/obj.MLIRParser.dir/Parser.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- Location.h - MLIR Location Classes -----------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// These classes provide the ability to relate MLIR objects back to source
        -:   10:// location position information.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef MLIR_IR_LOCATION_H
        -:   15:#define MLIR_IR_LOCATION_H
        -:   16:
        -:   17:#include "mlir/IR/Attributes.h"
        -:   18:#include "mlir/IR/SubElementInterfaces.h"
        -:   19:#include "llvm/Support/PointerLikeTypeTraits.h"
        -:   20:
        -:   21:namespace mlir {
        -:   22:
        -:   23:class Location;
        -:   24:class WalkResult;
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// LocationAttr
        -:   28://===----------------------------------------------------------------------===//
        -:   29:
        -:   30:/// Location objects represent source locations information in MLIR.
        -:   31:/// LocationAttr acts as the anchor for all Location based attributes.
        -:   32:class LocationAttr : public Attribute {
        -:   33:public:
        -:   34:  using Attribute::Attribute;
        -:   35:
        -:   36:  /// Walk all of the locations nested under, and including, the current.
        -:   37:  WalkResult walk(function_ref<WalkResult(Location)> walkFn);
        -:   38:
        -:   39:  /// Return an instance of the given location type if one is nested under the
        -:   40:  /// current location. Returns nullptr if one could not be found.
        -:   41:  template <typename T>
        -:   42:  T findInstanceOf() {
        -:   43:    T result = {};
        -:   44:    walk([&](auto loc) {
        -:   45:      if (auto typedLoc = llvm::dyn_cast<T>(loc)) {
        -:   46:        result = typedLoc;
        -:   47:        return WalkResult::interrupt();
        -:   48:      }
        -:   49:      return WalkResult::advance();
        -:   50:    });
        -:   51:    return result;
        -:   52:  }
        -:   53:
        -:   54:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:   55:  static bool classof(Attribute attr);
        -:   56:};
        -:   57:
        -:   58://===----------------------------------------------------------------------===//
        -:   59:// Location
        -:   60://===----------------------------------------------------------------------===//
        -:   61:
        -:   62:/// This class defines the main interface for locations in MLIR and acts as a
        -:   63:/// non-nullable wrapper around a LocationAttr.
        -:   64:class Location {
        -:   65:public:
    #####:   66:  Location(LocationAttr loc) : impl(loc) {
    #####:   67:    assert(loc && "location should never be null.");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   68:  }
        -:   69:  Location(const LocationAttr::ImplType *impl) : impl(impl) {
        -:   70:    assert(impl && "location should never be null.");
        -:   71:  }
        -:   72:
        -:   73:  /// Return the context this location is uniqued in.
        -:   74:  MLIRContext *getContext() const { return impl.getContext(); }
        -:   75:
        -:   76:  /// Access the impl location attribute.
        -:   77:  operator LocationAttr() const { return impl; }
        -:   78:  LocationAttr *operator->() const { return const_cast<LocationAttr *>(&impl); }
        -:   79:
        -:   80:  /// Type casting utilities on the underlying location.
        -:   81:  template <typename U>
        -:   82:  bool isa() const {
        -:   83:    return llvm::isa<U>(*this);
        -:   84:  }
        -:   85:  template <typename U>
        -:   86:  U dyn_cast() const {
        -:   87:    return llvm::dyn_cast<U>(*this);
        -:   88:  }
        -:   89:  template <typename U>
        -:   90:  U cast() const {
        -:   91:    return llvm::cast<U>(*this);
        -:   92:  }
        -:   93:
        -:   94:  /// Comparison operators.
        -:   95:  bool operator==(Location rhs) const { return impl == rhs.impl; }
        -:   96:  bool operator!=(Location rhs) const { return !(*this == rhs); }
        -:   97:
        -:   98:  /// Print the location.
        -:   99:  void print(raw_ostream &os) const { impl.print(os); }
        -:  100:  void dump() const { impl.dump(); }
        -:  101:
        -:  102:  friend ::llvm::hash_code hash_value(Location arg);
        -:  103:
        -:  104:  /// Methods for supporting PointerLikeTypeTraits.
        -:  105:  const void *getAsOpaquePointer() const { return impl.getAsOpaquePointer(); }
        -:  106:  static Location getFromOpaquePointer(const void *pointer) {
        -:  107:    return LocationAttr(reinterpret_cast<const AttributeStorage *>(pointer));
        -:  108:  }
        -:  109:
        -:  110:protected:
        -:  111:  /// The internal backing location attribute.
        -:  112:  LocationAttr impl;
        -:  113:};
        -:  114:
        -:  115:inline raw_ostream &operator<<(raw_ostream &os, const Location &loc) {
        -:  116:  loc.print(os);
        -:  117:  return os;
        -:  118:}
        -:  119:
        -:  120:// Make Location hashable.
        -:  121:inline ::llvm::hash_code hash_value(Location arg) {
        -:  122:  return hash_value(arg.impl);
        -:  123:}
        -:  124:
        -:  125:} // namespace mlir
        -:  126:
        -:  127://===----------------------------------------------------------------------===//
        -:  128:// Tablegen Attribute Declarations
        -:  129://===----------------------------------------------------------------------===//
        -:  130:
        -:  131:#define GET_ATTRDEF_CLASSES
        -:  132:#include "mlir/IR/BuiltinLocationAttributes.h.inc"
        -:  133:
        -:  134:namespace mlir {
        -:  135:
        -:  136://===----------------------------------------------------------------------===//
        -:  137:// FusedLoc
        -:  138://===----------------------------------------------------------------------===//
        -:  139:
        -:  140:/// This class represents a fused location whose metadata is known to be an
        -:  141:/// instance of the given type.
        -:  142:template <typename MetadataT>
        -:  143:class FusedLocWith : public FusedLoc {
        -:  144:public:
        -:  145:  using FusedLoc::FusedLoc;
        -:  146:
        -:  147:  /// Return the metadata associated with this fused location.
        -:  148:  MetadataT getMetadata() const {
        -:  149:    return FusedLoc::getMetadata().template cast<MetadataT>();
        -:  150:  }
        -:  151:
        -:  152:  /// Support llvm style casting.
        -:  153:  static bool classof(Attribute attr) {
        -:  154:    auto fusedLoc = attr.dyn_cast<FusedLoc>();
        -:  155:    return fusedLoc && fusedLoc.getMetadata().isa_and_nonnull<MetadataT>();
        -:  156:  }
        -:  157:};
        -:  158:
        -:  159://===----------------------------------------------------------------------===//
        -:  160:// OpaqueLoc
        -:  161://===----------------------------------------------------------------------===//
        -:  162:
        -:  163:/// Returns an instance of opaque location which contains a given pointer to
        -:  164:/// an object. The corresponding MLIR location is set to UnknownLoc.
        -:  165:template <typename T>
        -:  166:inline OpaqueLoc OpaqueLoc::get(T underlyingLocation, MLIRContext *context) {
        -:  167:  return get(reinterpret_cast<uintptr_t>(underlyingLocation), TypeID::get<T>(),
        -:  168:             UnknownLoc::get(context));
        -:  169:}
        -:  170:} // namespace mlir
        -:  171:
        -:  172://===----------------------------------------------------------------------===//
        -:  173:// LLVM Utilities
        -:  174://===----------------------------------------------------------------------===//
        -:  175:
        -:  176:namespace llvm {
        -:  177:
        -:  178:// Type hash just like pointers.
        -:  179:template <>
        -:  180:struct DenseMapInfo<mlir::Location> {
        -:  181:  static mlir::Location getEmptyKey() {
        -:  182:    auto *pointer = llvm::DenseMapInfo<void *>::getEmptyKey();
        -:  183:    return mlir::Location::getFromOpaquePointer(pointer);
        -:  184:  }
        -:  185:  static mlir::Location getTombstoneKey() {
        -:  186:    auto *pointer = llvm::DenseMapInfo<void *>::getTombstoneKey();
        -:  187:    return mlir::Location::getFromOpaquePointer(pointer);
        -:  188:  }
        -:  189:  static unsigned getHashValue(mlir::Location val) {
        -:  190:    return mlir::hash_value(val);
        -:  191:  }
        -:  192:  static bool isEqual(mlir::Location LHS, mlir::Location RHS) {
        -:  193:    return LHS == RHS;
        -:  194:  }
        -:  195:};
        -:  196:
        -:  197:/// We align LocationStorage by 8, so allow LLVM to steal the low bits.
        -:  198:template <>
        -:  199:struct PointerLikeTypeTraits<mlir::Location> {
        -:  200:public:
        -:  201:  static inline void *getAsVoidPointer(mlir::Location I) {
        -:  202:    return const_cast<void *>(I.getAsOpaquePointer());
        -:  203:  }
        -:  204:  static inline mlir::Location getFromVoidPointer(void *P) {
        -:  205:    return mlir::Location::getFromOpaquePointer(P);
        -:  206:  }
        -:  207:  static constexpr int NumLowBitsAvailable =
        -:  208:      PointerLikeTypeTraits<mlir::Attribute>::NumLowBitsAvailable;
        -:  209:};
        -:  210:
        -:  211:/// The constructors in mlir::Location ensure that the class is a non-nullable
        -:  212:/// wrapper around mlir::LocationAttr. Override default behavior and always
        -:  213:/// return true for isPresent().
        -:  214:template <>
        -:  215:struct ValueIsPresent<mlir::Location> {
        -:  216:  using UnwrappedType = mlir::Location;
        -:  217:  static inline bool isPresent(const mlir::Location &location) { return true; }
        -:  218:};
        -:  219:
        -:  220:/// Add support for llvm style casts. We provide a cast between To and From if
        -:  221:/// From is mlir::Location or derives from it.
        -:  222:template <typename To, typename From>
        -:  223:struct CastInfo<To, From,
        -:  224:                std::enable_if_t<
        -:  225:                    std::is_same_v<mlir::Location, std::remove_const_t<From>> ||
        -:  226:                    std::is_base_of_v<mlir::Location, From>>>
        -:  227:    : DefaultDoCastIfPossible<To, From, CastInfo<To, From>> {
        -:  228:
        -:  229:  static inline bool isPossible(mlir::Location location) {
        -:  230:    /// Return a constant true instead of a dynamic true when casting to self or
        -:  231:    /// up the hierarchy. Additionally, all casting info is deferred to the
        -:  232:    /// wrapped mlir::LocationAttr instance stored in mlir::Location.
        -:  233:    return std::is_same_v<To, std::remove_const_t<From>> ||
        -:  234:           isa<To>(static_cast<mlir::LocationAttr>(location));
        -:  235:  }
        -:  236:
        -:  237:  static inline To castFailed() { return To(); }
        -:  238:
        -:  239:  static inline To doCast(mlir::Location location) {
        -:  240:    return To(location->getImpl());
        -:  241:  }
        -:  242:};
        -:  243:
        -:  244:} // namespace llvm
        -:  245:
        -:  246:#endif
