        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/IR/OperationSupport.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/OperationSupport.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- OperationSupport.cpp -----------------------------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains out-of-line implementations of the support types that
        -:   10:// Operation and related classes build on top of.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/IR/OperationSupport.h"
        -:   15:#include "mlir/IR/BuiltinAttributes.h"
        -:   16:#include "mlir/IR/BuiltinTypes.h"
        -:   17:#include "mlir/IR/OpDefinition.h"
        -:   18:#include "llvm/ADT/BitVector.h"
        -:   19:#include <numeric>
        -:   20:
        -:   21:using namespace mlir;
        -:   22:
        -:   23://===----------------------------------------------------------------------===//
        -:   24:// NamedAttrList
        -:   25://===----------------------------------------------------------------------===//
        -:   26:
function _ZN4mlir13NamedAttrListC2EN4llvm8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:   27:NamedAttrList::NamedAttrList(ArrayRef<NamedAttribute> attributes) {
call    0 never executed
86687322*:   28:  assign(attributes.begin(), attributes.end());
call    0 returned 100%
call    1 never executed
    #####:   29:}
        -:   30:
function _ZN4mlir13NamedAttrListC2ENS_14DictionaryAttrE called 86687322 returned 100% blocks executed 86%
 86687322:   31:NamedAttrList::NamedAttrList(DictionaryAttr attributes)
 86687322:   32:    : NamedAttrList(attributes ? attributes.getValue()
call    0 returned 100%
173374644:   33:                               : ArrayRef<NamedAttribute>()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
 86687322:   34:  dictionarySorted.setPointerAndInt(attributes, true);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 86687322:   35:}
        -:   36:
function _ZN4mlir13NamedAttrListC2EPKNS_14NamedAttributeES3_ called 0 returned 0% blocks executed 0%
    #####:   37:NamedAttrList::NamedAttrList(const_iterator inStart, const_iterator inEnd) {
call    0 never executed
call    1 never executed
    #####:   38:  assign(inStart, inEnd);
    #####:   39:}
        -:   40:
function _ZNK4mlir13NamedAttrList8getAttrsEv called 0 returned 0% blocks executed 0%
    #####:   41:ArrayRef<NamedAttribute> NamedAttrList::getAttrs() const { return attrs; }
        -:   42:
function _ZNK4mlir13NamedAttrList13findDuplicateEv called 84393204 returned 100% blocks executed 100%
 84393204:   43:Optional<NamedAttribute> NamedAttrList::findDuplicate() const {
 84393204:   44:  Optional<NamedAttribute> duplicate =
call    0 returned 100%
 84393204:   45:      DictionaryAttr::findDuplicate(attrs, isSorted());
call    0 returned 100%
        -:   46:  // DictionaryAttr::findDuplicate will sort the list, so reset the sorted
        -:   47:  // state.
 84393204:   48:  if (!isSorted())
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
  2668184:   49:    dictionarySorted.setPointerAndInt(nullptr, true);
 84393204:   50:  return duplicate;
        -:   51:}
        -:   52:
function _ZNK4mlir13NamedAttrList13getDictionaryEPNS_11MLIRContextE called 175610017 returned 100% blocks executed 100%
175610017:   53:DictionaryAttr NamedAttrList::getDictionary(MLIRContext *context) const {
175610017:   54:  if (!isSorted()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     8358:   55:    DictionaryAttr::sortInPlace(attrs);
call    0 returned 100%
     8358:   56:    dictionarySorted.setPointerAndInt(nullptr, true);
        -:   57:  }
175610017:   58:  if (!dictionarySorted.getPointer())
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
 93344366:   59:    dictionarySorted.setPointer(DictionaryAttr::getWithSorted(context, attrs));
call    0 returned 100%
call    1 returned 100%
175610017:   60:  return dictionarySorted.getPointer().cast<DictionaryAttr>();
call    0 returned 100%
        -:   61:}
        -:   62:
        -:   63:/// Add an attribute with the specified name.
function _ZN4mlir13NamedAttrList6appendEN4llvm9StringRefENS_9AttributeE called 46511192 returned 100% blocks executed 100%
 46511192:   64:void NamedAttrList::append(StringRef name, Attribute attr) {
 46511192:   65:  append(StringAttr::get(attr.getContext(), name), attr);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
 46511192:   66:}
        -:   67:
        -:   68:/// Replaces the attributes with new list of attributes.
function _ZN4mlir13NamedAttrList6assignEPKNS_14NamedAttributeES3_ called 0 returned 0% blocks executed 0%
86687322*:   69:void NamedAttrList::assign(const_iterator inStart, const_iterator inEnd) {
86687322*:   70:  DictionaryAttr::sort(ArrayRef<NamedAttribute>{inStart, inEnd}, attrs);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 never executed
86687322*:   71:  dictionarySorted.setPointerAndInt(nullptr, true);
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   72:}
        -:   73:
function _ZN4mlir13NamedAttrList9push_backENS_14NamedAttributeE called 68640248 returned 100% blocks executed 100%
 68640248:   74:void NamedAttrList::push_back(NamedAttribute newAttribute) {
 68640248:   75:  if (isSorted())
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
 65019406:   76:    dictionarySorted.setInt(attrs.empty() || attrs.back() < newAttribute);
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 58% (fallthrough)
branch  5 taken 42%
 68640248:   77:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
 68640248:   78:  attrs.push_back(newAttribute);
call    0 returned 100%
 68640248:   79:}
        -:   80:
        -:   81:/// Return the specified attribute if present, null otherwise.
function _ZNK4mlir13NamedAttrList3getEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:   82:Attribute NamedAttrList::get(StringRef name) const {
    #####:   83:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   84:  return it.second ? it.first->getValue() : Attribute();
branch  0 never executed
branch  1 never executed
        -:   85:}
function _ZNK4mlir13NamedAttrList3getENS_10StringAttrE called 7707416 returned 100% blocks executed 100%
  7707416:   86:Attribute NamedAttrList::get(StringAttr name) const {
  7707416:   87:  auto it = findAttr(*this, name);
call    0 returned 100%
  7707416:   88:  return it.second ? it.first->getValue() : Attribute();
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:   89:}
        -:   90:
        -:   91:/// Return the specified named attribute if present, None otherwise.
function _ZNK4mlir13NamedAttrList8getNamedEN4llvm9StringRefE called 285109 returned 100% blocks executed 80%
   285109:   92:Optional<NamedAttribute> NamedAttrList::getNamed(StringRef name) const {
   285109:   93:  auto it = findAttr(*this, name);
call    0 returned 100%
  285109*:   94:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   95:}
function _ZNK4mlir13NamedAttrList8getNamedENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:   96:Optional<NamedAttribute> NamedAttrList::getNamed(StringAttr name) const {
    #####:   97:  auto it = findAttr(*this, name);
call    0 never executed
    #####:   98:  return it.second ? *it.first : Optional<NamedAttribute>();
branch  0 never executed
branch  1 never executed
        -:   99:}
        -:  100:
        -:  101:/// If the an attribute exists with the specified name, change it to the new
        -:  102:/// value.  Otherwise, add a new attribute with the specified name/value.
function _ZN4mlir13NamedAttrList3setENS_10StringAttrENS_9AttributeE called 3967165 returned 100% blocks executed 89%
  3967165:  103:Attribute NamedAttrList::set(StringAttr name, Attribute value) {
 3967165*:  104:  assert(value && "attributes may never be null");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  105:
        -:  106:  // Look for an existing attribute with the given name, and set its value
        -:  107:  // in-place. Return the previous value of the attribute, if there was one.
  3967165:  108:  auto it = findAttr(*this, name);
call    0 returned 100%
  3967165:  109:  if (it.second) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  110:    // Update the existing attribute by swapping out the old value for the new
        -:  111:    // value. Return the old value.
  3954528:  112:    Attribute oldValue = it.first->getValue();
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  3954528:  113:    if (it.first->getValue() != value) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
  3944124:  114:      it.first->setValue(value);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  115:
        -:  116:      // If the attributes have changed, the dictionary is invalidated.
  3944124:  117:      dictionarySorted.setPointer(nullptr);
call    0 returned 100%
        -:  118:    }
  3954528:  119:    return oldValue;
        -:  120:  }
        -:  121:  // Perform a string lookup to insert the new attribute into its sorted
        -:  122:  // position.
    12637:  123:  if (isSorted())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    12637:  124:    it = findAttr(*this, name.strref());
call    0 returned 100%
call    1 returned 100%
    12637:  125:  attrs.insert(it.first, {name, value});
call    0 returned 100%
call    1 returned 100%
        -:  126:  // Invalidate the dictionary. Return null as there was no previous value.
    12637:  127:  dictionarySorted.setPointer(nullptr);
call    0 returned 100%
    12637:  128:  return Attribute();
        -:  129:}
        -:  130:
function _ZN4mlir13NamedAttrList3setEN4llvm9StringRefENS_9AttributeE called 3078401 returned 100% blocks executed 86%
  3078401:  131:Attribute NamedAttrList::set(StringRef name, Attribute value) {
 3078401*:  132:  assert(value && "attributes may never be null");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  3078401:  133:  return set(mlir::StringAttr::get(value.getContext(), name), value);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  134:}
        -:  135:
        -:  136:Attribute
function _ZN4mlir13NamedAttrList9eraseImplEPNS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  137:NamedAttrList::eraseImpl(SmallVectorImpl<NamedAttribute>::iterator it) {
        -:  138:  // Erasing does not affect the sorted property.
    #####:  139:  Attribute attr = it->getValue();
call    0 never executed
    #####:  140:  attrs.erase(it);
call    0 never executed
    #####:  141:  dictionarySorted.setPointer(nullptr);
call    0 never executed
    #####:  142:  return attr;
        -:  143:}
        -:  144:
function _ZN4mlir13NamedAttrList5eraseENS_10StringAttrE called 568690 returned 100% blocks executed 80%
   568690:  145:Attribute NamedAttrList::erase(StringAttr name) {
   568690:  146:  auto it = findAttr(*this, name);
call    0 returned 100%
  568690*:  147:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  148:}
        -:  149:
function _ZN4mlir13NamedAttrList5eraseEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  150:Attribute NamedAttrList::erase(StringRef name) {
    #####:  151:  auto it = findAttr(*this, name);
call    0 never executed
    #####:  152:  return it.second ? eraseImpl(it.first) : Attribute();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  153:}
        -:  154:
        -:  155:NamedAttrList &
function _ZN4mlir13NamedAttrListaSERKN4llvm15SmallVectorImplINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  156:NamedAttrList::operator=(const SmallVectorImpl<NamedAttribute> &rhs) {
    #####:  157:  assign(rhs.begin(), rhs.end());
call    0 never executed
    #####:  158:  return *this;
        -:  159:}
        -:  160:
function _ZNK4mlir13NamedAttrListcvN4llvm8ArrayRefINS_14NamedAttributeEEEEv called 0 returned 0% blocks executed 0%
    #####:  161:NamedAttrList::operator ArrayRef<NamedAttribute>() const { return attrs; }
        -:  162:
        -:  163://===----------------------------------------------------------------------===//
        -:  164:// OperationState
        -:  165://===----------------------------------------------------------------------===//
        -:  166:
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefE called 22437 returned 100% blocks executed 100%
    22437:  167:OperationState::OperationState(Location location, StringRef name)
    22437:  168:    : location(location), name(name, location->getContext()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  169:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameE called 84526784 returned 100% blocks executed 100%
 84526784:  170:OperationState::OperationState(Location location, OperationName name)
 84526784:  171:    : location(location), name(name) {}
call    0 returned 100%
        -:  172:
function _ZN4mlir14OperationStateC2ENS_8LocationENS_13OperationNameENS_10ValueRangeENS_9TypeRangeEN4llvm8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS5_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 0 returned 0% blocks executed 0%
    #####:  173:OperationState::OperationState(Location location, OperationName name,
        -:  174:                               ValueRange operands, TypeRange types,
        -:  175:                               ArrayRef<NamedAttribute> attributes,
        -:  176:                               BlockRange successors,
    #####:  177:                               MutableArrayRef<std::unique_ptr<Region>> regions)
        -:  178:    : location(location), name(name),
        -:  179:      operands(operands.begin(), operands.end()),
        -:  180:      types(types.begin(), types.end()),
        -:  181:      attributes(attributes.begin(), attributes.end()),
    #####:  182:      successors(successors.begin(), successors.end()) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  183:  for (std::unique_ptr<Region> &r : regions)
branch  0 never executed
branch  1 never executed
    #####:  184:    this->regions.push_back(std::move(r));
call    0 never executed
    #####:  185:}
function _ZN4mlir14OperationStateC2ENS_8LocationEN4llvm9StringRefENS_10ValueRangeENS_9TypeRangeENS2_8ArrayRefINS_14NamedAttributeEEENS_10BlockRangeENS2_15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteISC_EEEE called 0 returned 0% blocks executed 0%
    #####:  186:OperationState::OperationState(Location location, StringRef name,
        -:  187:                               ValueRange operands, TypeRange types,
        -:  188:                               ArrayRef<NamedAttribute> attributes,
        -:  189:                               BlockRange successors,
    #####:  190:                               MutableArrayRef<std::unique_ptr<Region>> regions)
call    0 never executed
        -:  191:    : OperationState(location, OperationName(name, location.getContext()),
    #####:  192:                     operands, types, attributes, successors, regions) {}
call    0 never executed
call    1 never executed
        -:  193:
function _ZN4mlir14OperationState11addOperandsENS_10ValueRangeE called 11763 returned 100% blocks executed 100%
    11763:  194:void OperationState::addOperands(ValueRange newOperands) {
    11763:  195:  operands.append(newOperands.begin(), newOperands.end());
call    0 returned 100%
    11763:  196:}
        -:  197:
function _ZN4mlir14OperationState13addSuccessorsENS_10BlockRangeE called 0 returned 0% blocks executed 0%
    #####:  198:void OperationState::addSuccessors(BlockRange newSuccessors) {
    #####:  199:  successors.append(newSuccessors.begin(), newSuccessors.end());
call    0 never executed
    #####:  200:}
        -:  201:
function _ZN4mlir14OperationState9addRegionEv called 2779813 returned 100% blocks executed 100%
  2779813:  202:Region *OperationState::addRegion() {
  2779813:  203:  regions.emplace_back(new Region);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  2779813:  204:  return regions.back().get();
call    0 returned 100%
        -:  205:}
        -:  206:
function _ZN4mlir14OperationState9addRegionEOSt10unique_ptrINS_6RegionESt14default_deleteIS2_EE called 100916 returned 100% blocks executed 100%
  100916*:  207:void OperationState::addRegion(std::unique_ptr<Region> &&region) {
  100916*:  208:  regions.push_back(std::move(region));
call    0 never executed
call    1 returned 100%
   100916:  209:}
        -:  210:
function _ZN4mlir14OperationState10addRegionsEN4llvm15MutableArrayRefISt10unique_ptrINS_6RegionESt14default_deleteIS4_EEEE called 0 returned 0% blocks executed 0%
    #####:  211:void OperationState::addRegions(
        -:  212:    MutableArrayRef<std::unique_ptr<Region>> regions) {
    #####:  213:  for (std::unique_ptr<Region> &region : regions)
branch  0 never executed
branch  1 never executed
    #####:  214:    addRegion(std::move(region));
call    0 never executed
    #####:  215:}
        -:  216:
        -:  217://===----------------------------------------------------------------------===//
        -:  218:// OperandStorage
        -:  219://===----------------------------------------------------------------------===//
        -:  220:
function _ZN4mlir6detail14OperandStorageC2EPNS_9OperationEPNS_9OpOperandENS_10ValueRangeE called 59864213 returned 100% blocks executed 100%
 59864213:  221:detail::OperandStorage::OperandStorage(Operation *owner,
        -:  222:                                       OpOperand *trailingOperands,
 59864213:  223:                                       ValueRange values)
 59864213:  224:    : isStorageDynamic(false), operandStorage(trailingOperands) {
 59864213:  225:  numOperands = capacity = values.size();
158566159:  226:  for (unsigned i = 0; i < numOperands; ++i)
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
123094955:  227:    new (&operandStorage[i]) OpOperand(owner, values[i]);
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
 59864213:  228:}
        -:  229:
function _ZN4mlir6detail14OperandStorageD2Ev called 59852454 returned 100% blocks executed 89%
119704908:  230:detail::OperandStorage::~OperandStorage() {
157599784:  231:  for (auto &operand : getOperands())
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
100906119:  232:    operand.~OpOperand();
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  233:
        -:  234:  // If the storage is dynamic, deallocate it.
 59852454:  235:  if (isStorageDynamic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  236:    free(operandStorage);
 59852454:  237:}
        -:  238:
        -:  239:/// Replace the operands contained in the storage with the ones provided in
        -:  240:/// 'values'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationENS_10ValueRangeE called 6126 returned 100% blocks executed 92%
     6126:  241:void detail::OperandStorage::setOperands(Operation *owner, ValueRange values) {
     6126:  242:  MutableArrayRef<OpOperand> storageOperands = resize(owner, values.size());
call    0 returned 100%
    20618:  243:  for (unsigned i = 0, e = values.size(); i != e; ++i)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
    28984:  244:    storageOperands[i].set(values[i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
branch  3 taken 42% (fallthrough)
branch  4 taken 58%
     6126:  245:}
        -:  246:
        -:  247:/// Replace the operands beginning at 'start' and ending at 'start' + 'length'
        -:  248:/// with the ones provided in 'operands'. 'operands' may be smaller or larger
        -:  249:/// than the range pointed to by 'start'+'length'.
function _ZN4mlir6detail14OperandStorage11setOperandsEPNS_9OperationEjjNS_10ValueRangeE called 1726348 returned 100% blocks executed 24%
  1726348:  250:void detail::OperandStorage::setOperands(Operation *owner, unsigned start,
        -:  251:                                         unsigned length, ValueRange operands) {
        -:  252:  // If the new size is the same, we can update inplace.
  1726348:  253:  unsigned newSize = operands.size();
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
  1726348:  254:  if (newSize == length) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   863174:  255:    MutableArrayRef<OpOperand> storageOperands = getOperands();
  863174*:  256:    for (unsigned i = 0, e = length; i != e; ++i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  257:      storageOperands[start + i].set(operands[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  258:    return;
        -:  259:  }
        -:  260:  // If the new size is greater, remove the extra operands and set the rest
        -:  261:  // inplace.
   863174:  262:  if (newSize < length) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   863174:  263:    eraseOperands(start + operands.size(), length - newSize);
call    0 returned 100%
   863174:  264:    setOperands(owner, start, newSize, operands);
   863174:  265:    return;
call    0 returned 100%
        -:  266:  }
        -:  267:  // Otherwise, the new size is greater so we need to grow the storage.
    #####:  268:  auto storageOperands = resize(owner, size() + (newSize - length));
call    0 never executed
        -:  269:
        -:  270:  // Shift operands to the right to make space for the new operands.
    #####:  271:  unsigned rotateSize = storageOperands.size() - (start + length);
branch  0 never executed
branch  1 never executed
    #####:  272:  auto rbegin = storageOperands.rbegin();
branch  0 never executed
branch  1 never executed
    #####:  273:  std::rotate(rbegin, std::next(rbegin, newSize - length), rbegin + rotateSize);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  274:
        -:  275:  // Update the operands inplace.
    #####:  276:  for (unsigned i = 0, e = operands.size(); i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  277:    storageOperands[start + i].set(operands[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  278:}
        -:  279:
        -:  280:/// Erase an operand held by the storage.
function _ZN4mlir6detail14OperandStorage13eraseOperandsEjj called 863174 returned 100% blocks executed 45%
   863174:  281:void detail::OperandStorage::eraseOperands(unsigned start, unsigned length) {
   863174:  282:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  863174*:  283:  assert((start + length) <= operands.size());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
   863174:  284:  numOperands -= length;
        -:  285:
        -:  286:  // Shift all operands down if the operand to remove is not at the end.
   863174:  287:  if (start != numOperands) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  288:    auto *indexIt = std::next(operands.begin(), start);
branch  0 never executed
branch  1 never executed
    #####:  289:    std::rotate(indexIt, std::next(indexIt, length), operands.end());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  290:  }
  1807423:  291:  for (unsigned i = 0; i != length; ++i)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
  1888498:  292:    operands[numOperands + i].~OpOperand();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   863174:  293:}
        -:  294:
function _ZN4mlir6detail14OperandStorage13eraseOperandsERKN4llvm9BitVectorE called 0 returned 0% blocks executed 0%
    #####:  295:void detail::OperandStorage::eraseOperands(const BitVector &eraseIndices) {
    #####:  296:  MutableArrayRef<OpOperand> operands = getOperands();
branch  0 never executed
branch  1 never executed
    #####:  297:  assert(eraseIndices.size() == operands.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  298:
        -:  299:  // Check that at least one operand is erased.
    #####:  300:  int firstErasedIndice = eraseIndices.find_first();
call    0 never executed
    #####:  301:  if (firstErasedIndice == -1)
branch  0 never executed
branch  1 never executed
    #####:  302:    return;
        -:  303:
        -:  304:  // Shift all of the removed operands to the end, and destroy them.
    #####:  305:  numOperands = firstErasedIndice;
    #####:  306:  for (unsigned i = firstErasedIndice + 1, e = operands.size(); i < e; ++i)
branch  0 never executed
branch  1 never executed
    #####:  307:    if (!eraseIndices.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  308:      operands[numOperands++] = std::move(operands[i]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  309:  for (OpOperand &operand : operands.drop_front(numOperands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  310:    operand.~OpOperand();
branch  0 never executed
branch  1 never executed
        -:  311:}
        -:  312:
        -:  313:/// Resize the storage to the given size. Returns the array containing the new
        -:  314:/// operands.
function _ZN4mlir6detail14OperandStorage6resizeEPNS_9OperationEj called 6126 returned 100% blocks executed 18%
     6126:  315:MutableArrayRef<OpOperand> detail::OperandStorage::resize(Operation *owner,
        -:  316:                                                          unsigned newSize) {
        -:  317:  // If the number of operands is less than or equal to the current amount, we
        -:  318:  // can just update in place.
     6126:  319:  MutableArrayRef<OpOperand> origOperands = getOperands();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     6126:  320:  if (newSize <= numOperands) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  321:    // If the number of new size is less than the current, remove any extra
        -:  322:    // operands.
    #####:  323:    for (unsigned i = newSize; i != numOperands; ++i)
branch  0 never executed
branch  1 never executed
    #####:  324:      origOperands[i].~OpOperand();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  325:    numOperands = newSize;
    #####:  326:    return origOperands.take_front(newSize);
branch  0 never executed
branch  1 never executed
        -:  327:  }
        -:  328:
        -:  329:  // If the new size is within the original inline capacity, grow inplace.
     6126:  330:  if (newSize <= capacity) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    14492:  331:    OpOperand *opBegin = origOperands.data();
    14492:  332:    for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
     8366:  333:      new (&opBegin[numOperands]) OpOperand(owner);
     6126:  334:    return MutableArrayRef<OpOperand>(opBegin, newSize);
        -:  335:  }
        -:  336:
        -:  337:  // Otherwise, we need to allocate a new storage.
    #####:  338:  unsigned newCapacity =
    #####:  339:      std::max(unsigned(llvm::NextPowerOf2(capacity + 2)), newSize);
branch  0 never executed
branch  1 never executed
    #####:  340:  OpOperand *newOperandStorage =
    #####:  341:      reinterpret_cast<OpOperand *>(malloc(sizeof(OpOperand) * newCapacity));
        -:  342:
        -:  343:  // Move the current operands to the new storage.
    #####:  344:  MutableArrayRef<OpOperand> newOperands(newOperandStorage, newSize);
    #####:  345:  std::uninitialized_move(origOperands.begin(), origOperands.end(),
        -:  346:                          newOperands.begin());
        -:  347:
        -:  348:  // Destroy the original operands.
    #####:  349:  for (auto &operand : origOperands)
branch  0 never executed
branch  1 never executed
    #####:  350:    operand.~OpOperand();
branch  0 never executed
branch  1 never executed
        -:  351:
        -:  352:  // Initialize any new operands.
    #####:  353:  for (unsigned e = newSize; numOperands != e; ++numOperands)
branch  0 never executed
branch  1 never executed
    #####:  354:    new (&newOperands[numOperands]) OpOperand(owner);
branch  0 never executed
branch  1 never executed
        -:  355:
        -:  356:  // If the current storage is dynamic, free it.
    #####:  357:  if (isStorageDynamic)
branch  0 never executed
branch  1 never executed
    #####:  358:    free(operandStorage);
        -:  359:
        -:  360:  // Update the storage representation to use the new dynamic storage.
    #####:  361:  operandStorage = newOperandStorage;
    #####:  362:  capacity = newCapacity;
    #####:  363:  isStorageDynamic = true;
    #####:  364:  return newOperands;
        -:  365:}
        -:  366:
        -:  367://===----------------------------------------------------------------------===//
        -:  368:// Operation Value-Iterators
        -:  369://===----------------------------------------------------------------------===//
        -:  370:
        -:  371://===----------------------------------------------------------------------===//
        -:  372:// OperandRange
        -:  373:
function _ZNK4mlir12OperandRange20getBeginOperandIndexEv called 1679754 returned 100% blocks executed 75%
  1679754:  374:unsigned OperandRange::getBeginOperandIndex() const {
 1679754*:  375:  assert(!empty() && "range must not be empty");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  1679754:  376:  return base->getOperandNumber();
call    0 returned 100%
        -:  377:}
        -:  378:
function _ZNK4mlir12OperandRange5splitENS_6detail18DenseArrayAttrImplIiEE called 0 returned 0% blocks executed 0%
    #####:  379:OperandRangeRange OperandRange::split(DenseI32ArrayAttr segmentSizes) const {
    #####:  380:  return OperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  381:}
        -:  382:
        -:  383://===----------------------------------------------------------------------===//
        -:  384:// OperandRangeRange
        -:  385:
function _ZN4mlir17OperandRangeRangeC2ENS_12OperandRangeENS_9AttributeE called 0 returned 0% blocks executed 0%
    #####:  386:OperandRangeRange::OperandRangeRange(OperandRange operands,
    #####:  387:                                     Attribute operandSegments)
call    0 never executed
        -:  388:    : OperandRangeRange(OwnerT(operands.getBase(), operandSegments), 0,
    #####:  389:                        operandSegments.cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
        -:  390:
function _ZNK4mlir17OperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  391:OperandRange OperandRangeRange::join() const {
    #####:  392:  const OwnerT &owner = getBase();
call    0 never executed
    #####:  393:  ArrayRef<int32_t> sizeData = owner.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  394:  return OperandRange(owner.first,
    #####:  395:                      std::accumulate(sizeData.begin(), sizeData.end(), 0));
        -:  396:}
        -:  397:
function _ZN4mlir17OperandRangeRange11dereferenceERKSt4pairIPNS_9OpOperandENS_9AttributeEEl called 0 returned 0% blocks executed 0%
    #####:  398:OperandRange OperandRangeRange::dereference(const OwnerT &object,
        -:  399:                                            ptrdiff_t index) {
    #####:  400:  ArrayRef<int32_t> sizeData = object.second.cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  401:  uint32_t startIndex =
    #####:  402:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  403:  return OperandRange(object.first + startIndex, *(sizeData.begin() + index));
        -:  404:}
        -:  405:
        -:  406://===----------------------------------------------------------------------===//
        -:  407:// MutableOperandRange
        -:  408:
        -:  409:/// Construct a new mutable range from the given operand, operand start index,
        -:  410:/// and range length.
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationEjjN4llvm8ArrayRefISt4pairIjNS_14NamedAttributeEEEE called 135686586 returned 100% blocks executed 75%
135686586:  411:MutableOperandRange::MutableOperandRange(
        -:  412:    Operation *owner, unsigned start, unsigned length,
135686586:  413:    ArrayRef<OperandSegment> operandSegments)
        -:  414:    : owner(owner), start(start), length(length),
135686586:  415:      operandSegments(operandSegments.begin(), operandSegments.end()) {
call    0 returned 100%
271415558*:  416:  assert((start + length) <= owner->getNumOperands() && "invalid range");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
135707779:  417:}
function _ZN4mlir19MutableOperandRangeC2EPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  418:MutableOperandRange::MutableOperandRange(Operation *owner)
branch  0 never executed
branch  1 never executed
    #####:  419:    : MutableOperandRange(owner, /*start=*/0, owner->getNumOperands()) {}
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  420:
        -:  421:/// Slice this range into a sub range, with the additional operand segment.
        -:  422:MutableOperandRange
function _ZNK4mlir19MutableOperandRange5sliceEjjN4llvm8OptionalISt4pairIjNS_14NamedAttributeEEEE called 0 returned 0% blocks executed 0%
    #####:  423:MutableOperandRange::slice(unsigned subStart, unsigned subLen,
        -:  424:                           Optional<OperandSegment> segment) const {
    #####:  425:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  426:  MutableOperandRange subSlice(owner, start + subStart, subLen,
    #####:  427:                               operandSegments);
call    0 never executed
    #####:  428:  if (segment)
branch  0 never executed
branch  1 never executed
    #####:  429:    subSlice.operandSegments.push_back(*segment);
call    0 never executed
    #####:  430:  return subSlice;
        -:  431:}
        -:  432:
        -:  433:/// Append the given values to the range.
function _ZN4mlir19MutableOperandRange6appendENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  434:void MutableOperandRange::append(ValueRange values) {
    #####:  435:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  436:    return;
    #####:  437:  owner->insertOperands(start + length, values);
call    0 never executed
    #####:  438:  updateLength(length + values.size());
call    0 never executed
        -:  439:}
        -:  440:
        -:  441:/// Assign this range to the given values.
function _ZN4mlir19MutableOperandRange6assignENS_10ValueRangeE called 863174 returned 100% blocks executed 100%
   863174:  442:void MutableOperandRange::assign(ValueRange values) {
   863174:  443:  owner->setOperands(start, length, values);
call    0 returned 100%
   863174:  444:  if (length != values.size())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   863174:  445:    updateLength(/*newLength=*/values.size());
call    0 returned 100%
   863174:  446:}
        -:  447:
        -:  448:/// Assign the range to the given value.
function _ZN4mlir19MutableOperandRange6assignENS_5ValueE called 3653654 returned 100% blocks executed 50%
  3653654:  449:void MutableOperandRange::assign(Value value) {
  3653654:  450:  if (length == 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  3653654:  451:    owner->setOperand(start, value);
call    0 returned 100%
        -:  452:  } else {
    #####:  453:    owner->setOperands(start, length, value);
call    0 never executed
call    1 never executed
    #####:  454:    updateLength(/*newLength=*/1);
call    0 never executed
        -:  455:  }
  3653654:  456:}
        -:  457:
        -:  458:/// Erase the operands within the given sub-range.
function _ZN4mlir19MutableOperandRange5eraseEjj called 0 returned 0% blocks executed 0%
    #####:  459:void MutableOperandRange::erase(unsigned subStart, unsigned subLen) {
    #####:  460:  assert((subStart + subLen) <= length && "invalid sub-range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  461:  if (length == 0)
branch  0 never executed
branch  1 never executed
        -:  462:    return;
    #####:  463:  owner->eraseOperands(start + subStart, subLen);
call    0 never executed
    #####:  464:  updateLength(length - subLen);
call    0 never executed
        -:  465:}
        -:  466:
        -:  467:/// Clear this range and erase all of the operands.
function _ZN4mlir19MutableOperandRange5clearEv called 0 returned 0% blocks executed 0%
    #####:  468:void MutableOperandRange::clear() {
    #####:  469:  if (length != 0) {
branch  0 never executed
branch  1 never executed
    #####:  470:    owner->eraseOperands(start, length);
call    0 never executed
    #####:  471:    updateLength(/*newLength=*/0);
call    0 never executed
        -:  472:  }
    #####:  473:}
        -:  474:
        -:  475:/// Allow implicit conversion to an OperandRange.
function _ZNK4mlir19MutableOperandRangecvNS_12OperandRangeEEv called 59236123 returned 100% blocks executed 100%
 59236123:  476:MutableOperandRange::operator OperandRange() const {
 59236123:  477:  return owner->getOperands().slice(start, length);
call    0 returned 100%
call    1 returned 100%
        -:  478:}
        -:  479:
        -:  480:MutableOperandRangeRange
function _ZNK4mlir19MutableOperandRange5splitENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  481:MutableOperandRange::split(NamedAttribute segmentSizes) const {
    #####:  482:  return MutableOperandRangeRange(*this, segmentSizes);
call    0 never executed
        -:  483:}
        -:  484:
        -:  485:/// Update the length of this range to the one provided.
function _ZN4mlir19MutableOperandRange12updateLengthEj called 863174 returned 100% blocks executed 18%
   863174:  486:void MutableOperandRange::updateLength(unsigned newLength) {
   863174:  487:  int32_t diff = int32_t(newLength) - int32_t(length);
   863174:  488:  length = newLength;
        -:  489:
        -:  490:  // Update any of the provided segment attributes.
  863174*:  491:  for (OperandSegment &segment : operandSegments) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  492:    auto attr = segment.second.getValue().cast<DenseI32ArrayAttr>();
call    0 never executed
    #####:  493:    SmallVector<int32_t, 8> segments(attr.asArrayRef());
call    0 never executed
call    1 never executed
    #####:  494:    segments[segment.first] += diff;
branch  0 never executed
branch  1 never executed
    #####:  495:    segment.second.setValue(
call    0 never executed
    #####:  496:        DenseI32ArrayAttr::get(attr.getContext(), segments));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  497:    owner->setAttr(segment.second.getName(), segment.second.getValue());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  498:  }
   863174:  499:}
        -:  500:
        -:  501://===----------------------------------------------------------------------===//
        -:  502:// MutableOperandRangeRange
        -:  503:
function _ZN4mlir24MutableOperandRangeRangeC2ERKNS_19MutableOperandRangeENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  504:MutableOperandRangeRange::MutableOperandRangeRange(
    #####:  505:    const MutableOperandRange &operands, NamedAttribute operandSegmentAttr)
        -:  506:    : MutableOperandRangeRange(
    #####:  507:          OwnerT(operands, operandSegmentAttr), 0,
call    0 never executed
    #####:  508:          operandSegmentAttr.getValue().cast<DenseI32ArrayAttr>().size()) {}
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  509:
function _ZNK4mlir24MutableOperandRangeRange4joinEv called 0 returned 0% blocks executed 0%
    #####:  510:MutableOperandRange MutableOperandRangeRange::join() const {
    #####:  511:  return getBase().first;
branch  0 never executed
branch  1 never executed
        -:  512:}
        -:  513:
function _ZNK4mlir24MutableOperandRangeRangecvNS_17OperandRangeRangeEEv called 0 returned 0% blocks executed 0%
    #####:  514:MutableOperandRangeRange::operator OperandRangeRange() const {
    #####:  515:  return OperandRangeRange(getBase().first, getBase().second.getValue());
call    0 never executed
call    1 never executed
        -:  516:}
        -:  517:
function _ZN4mlir24MutableOperandRangeRange11dereferenceERKSt4pairINS_19MutableOperandRangeENS_14NamedAttributeEEl called 0 returned 0% blocks executed 0%
    #####:  518:MutableOperandRange MutableOperandRangeRange::dereference(const OwnerT &object,
        -:  519:                                                          ptrdiff_t index) {
    #####:  520:  ArrayRef<int32_t> sizeData =
    #####:  521:      object.second.getValue().cast<DenseI32ArrayAttr>();
call    0 never executed
call    1 never executed
    #####:  522:  uint32_t startIndex =
    #####:  523:      std::accumulate(sizeData.begin(), sizeData.begin() + index, 0);
    #####:  524:  return object.first.slice(
    #####:  525:      startIndex, *(sizeData.begin() + index),
call    0 never executed
    #####:  526:      MutableOperandRange::OperandSegment(index, object.second));
call    0 never executed
        -:  527:}
        -:  528:
        -:  529://===----------------------------------------------------------------------===//
        -:  530:// ResultRange
        -:  531:
function _ZN4mlir11ResultRangeC2ENS_8OpResultE called 0 returned 0% blocks executed 0%
    #####:  532:ResultRange::ResultRange(OpResult result)
    #####:  533:    : ResultRange(static_cast<detail::OpResultImpl *>(Value(result).getImpl()),
    #####:  534:                  1) {}
        -:  535:
function _ZNK4mlir11ResultRange7getUsesEv called 0 returned 0% blocks executed 0%
    #####:  536:ResultRange::use_range ResultRange::getUses() const {
    #####:  537:  return {use_begin(), use_end()};
        -:  538:}
function _ZNK4mlir11ResultRange9use_beginEv called 409497 returned 100% blocks executed 100%
  409497*:  539:ResultRange::use_iterator ResultRange::use_begin() const {
  818994*:  540:  return use_iterator(*this);
        -:  541:}
function _ZNK4mlir11ResultRange7use_endEv called 409497 returned 100% blocks executed 100%
  409497*:  542:ResultRange::use_iterator ResultRange::use_end() const {
  409497*:  543:  return use_iterator(*this, /*end=*/true);
        -:  544:}
function _ZN4mlir11ResultRange8getUsersEv called 0 returned 0% blocks executed 0%
    #####:  545:ResultRange::user_range ResultRange::getUsers() {
    #####:  546:  return {user_begin(), user_end()};
call    0 never executed
        -:  547:}
function _ZN4mlir11ResultRange10user_beginEv called 0 returned 0% blocks executed 0%
    #####:  548:ResultRange::user_iterator ResultRange::user_begin() {
    #####:  549:  return user_iterator(use_begin());
        -:  550:}
function _ZN4mlir11ResultRange8user_endEv called 0 returned 0% blocks executed 0%
    #####:  551:ResultRange::user_iterator ResultRange::user_end() {
    #####:  552:  return user_iterator(use_end());
        -:  553:}
        -:  554:
function _ZN4mlir11ResultRange11UseIteratorC2ES0_b called 0 returned 0% blocks executed 0%
  818994*:  555:ResultRange::UseIterator::UseIterator(ResultRange results, bool end)
  409497*:  556:    : it(end ? results.end() : results.begin()), endIt(results.end()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 taken 100% (fallthrough)
branch  7 taken 1%
branch  8 never executed
branch  9 never executed
        -:  557:  // Only initialize current use if there are results/can be uses.
  409497*:  558:  if (it != endIt)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 1%
branch  6 never executed
branch  7 never executed
  408985*:  559:    skipOverResultsWithNoUsers();
call    0 never executed
call    1 never executed
call    2 returned 100%
call    3 never executed
    #####:  560:}
        -:  561:
function _ZN4mlir11ResultRange11UseIteratorppEv called 549396 returned 100% blocks executed 100%
   549396:  562:ResultRange::UseIterator &ResultRange::UseIterator::operator++() {
        -:  563:  // We increment over uses, if we reach the last use then move to next
        -:  564:  // result.
   549396:  565:  if (use != (*it).use_end())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   549396:  566:    ++use;
   549396:  567:  if (use == (*it).use_end()) {
call    0 returned 100%
branch  1 taken 74% (fallthrough)
branch  2 taken 26%
   404889:  568:    ++it;
call    0 returned 100%
   404889:  569:    skipOverResultsWithNoUsers();
call    0 returned 100%
        -:  570:  }
   549396:  571:  return *this;
        -:  572:}
        -:  573:
function _ZN4mlir11ResultRange11UseIterator26skipOverResultsWithNoUsersEv called 813874 returned 100% blocks executed 92%
   813874:  574:void ResultRange::UseIterator::skipOverResultsWithNoUsers() {
   408985:  575:  while (it != endIt && (*it).use_empty())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
  813874*:  576:    ++it;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  577:
        -:  578:  // If we are at the last result, then set use to first use of
        -:  579:  // first result (sentinel value used for end).
   813874:  580:  if (it == endIt)
branch  0 taken 100%
branch  1 taken 0%
   404889:  581:    use = {};
        -:  582:  else
   408985:  583:    use = (*it).use_begin();
call    0 returned 100%
   813874:  584:}
        -:  585:
function _ZN4mlir11ResultRange18replaceAllUsesWithEPNS_9OperationE called 2537135 returned 100% blocks executed 100%
  2537135:  586:void ResultRange::replaceAllUsesWith(Operation *op) {
  5074270:  587:  replaceAllUsesWith(op->getResults());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
  2537135:  588:}
        -:  589:
        -:  590://===----------------------------------------------------------------------===//
        -:  591:// ValueRange
        -:  592:
function _ZN4mlir10ValueRangeC2EN4llvm8ArrayRefINS_5ValueEEE called 86939893 returned 100% blocks executed 100%
 90428217:  593:ValueRange::ValueRange(ArrayRef<Value> values)
 90428217:  594:    : ValueRange(values.data(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
function _ZN4mlir10ValueRangeC2ENS_12OperandRangeE called 279538401 returned 100% blocks executed 100%
290691476:  595:ValueRange::ValueRange(OperandRange values)
290691476:  596:    : ValueRange(values.begin().getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
function _ZN4mlir10ValueRangeC2ENS_11ResultRangeE called 1020414 returned 100% blocks executed 100%
 11975963:  597:ValueRange::ValueRange(ResultRange values)
 11975963:  598:    : ValueRange(values.getBase(), values.size()) {}
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
call    5 returned 100%
        -:  599:
        -:  600:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange11offset_baseERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 0 returned 0% blocks executed 0%
    #####:  601:ValueRange::OwnerT ValueRange::offset_base(const OwnerT &owner,
        -:  602:                                           ptrdiff_t index) {
    #####:  603:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  604:    return {value + index};
call    0 never executed
    #####:  605:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  606:    return {operand + index};
call    0 never executed
    #####:  607:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  608:}
        -:  609:/// See `llvm::detail::indexed_accessor_range_base` for details.
function _ZN4mlir10ValueRange20dereference_iteratorERKN4llvm12PointerUnionIJPKNS_5ValueEPNS_9OpOperandEPNS_6detail12OpResultImplEEEEl called 359896498 returned 100% blocks executed 100%
359896498:  610:Value ValueRange::dereference_iterator(const OwnerT &owner, ptrdiff_t index) {
359896498:  611:  if (const auto *value = owner.dyn_cast<const Value *>())
call    0 returned 100%
branch  1 taken 30% (fallthrough)
branch  2 taken 70%
106614003:  612:    return value[index];
253278393:  613:  if (auto *operand = owner.dyn_cast<OpOperand *>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
252807617:  614:    return operand[index].get();
   463968:  615:  return owner.get<detail::OpResultImpl *>()->getNextResultAtOffset(index);
call    0 returned 100%
call    1 returned 100%
        -:  616:}
        -:  617:
        -:  618://===----------------------------------------------------------------------===//
        -:  619:// Operation Equivalency
        -:  620://===----------------------------------------------------------------------===//
        -:  621:
function _ZN4mlir20OperationEquivalence11computeHashEPNS_9OperationEN4llvm12function_refIFNS3_9hash_codeENS_5ValueEEEES8_NS0_5FlagsE called 10739761 returned 100% blocks executed 97%
 10739761:  622:llvm::hash_code OperationEquivalence::computeHash(
        -:  623:    Operation *op, function_ref<llvm::hash_code(Value)> hashOperands,
        -:  624:    function_ref<llvm::hash_code(Value)> hashResults, Flags flags) {
        -:  625:  // Hash operations based upon their:
        -:  626:  //   - Operation Name
        -:  627:  //   - Attributes
        -:  628:  //   - Result Types
 10739761:  629:  llvm::hash_code hash = llvm::hash_combine(
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
 10739761:  630:      op->getName(), op->getAttrDictionary(), op->getResultTypes());
call    0 returned 100%
        -:  631:
        -:  632:  //   - Operands
 10739761:  633:  ValueRange operands = op->getOperands();
call    0 returned 100%
call    1 returned 100%
 10739761:  634:  SmallVector<Value> operandStorage;
call    0 returned 100%
 10739761:  635:  if (op->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 31% (fallthrough)
branch  2 taken 69%
  3380660:  636:    operandStorage.append(operands.begin(), operands.end());
call    0 returned 100%
  3380660:  637:    llvm::sort(operandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  638:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  639:    });
  3380660:  640:    operands = operandStorage;
call    0 returned 100%
        -:  641:  }
 43799255:  642:  for (Value operand : operands)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
 16529747:  643:    hash = llvm::hash_combine(hash, hashOperands(operand));
call    0 returned 100%
call    1 returned 100%
        -:  644:
        -:  645:  //   - Operands
 28234377:  646:  for (Value result : op->getResults())
branch  0 taken 81%
branch  1 taken 19%
branch  2 taken 45% (fallthrough)
branch  3 taken 55%
call    4 returned 100%
  8747308:  647:    hash = llvm::hash_combine(hash, hashResults(result));
call    0 returned 100%
call    1 returned 100%
 10739761:  648:  return hash;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  649:}
        -:  650:
        -:  651:static bool
function _ZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsE called 0 returned 0% blocks executed 0%
    #####:  652:isRegionEquivalentTo(Region *lhs, Region *rhs,
        -:  653:                     function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  654:                     function_ref<LogicalResult(Value, Value)> mapResults,
        -:  655:                     OperationEquivalence::Flags flags) {
    #####:  656:  DenseMap<Block *, Block *> blocksMap;
call    0 never executed
function _ZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ called 0 returned 0% blocks executed 0%
    #####:  657:  auto blocksEquivalent = [&](Block &lBlock, Block &rBlock) {
        -:  658:    // Check block arguments.
    #####:  659:    if (lBlock.getNumArguments() != rBlock.getNumArguments())
branch  0 never executed
branch  1 never executed
        -:  660:      return false;
        -:  661:
        -:  662:    // Map the two blocks.
    #####:  663:    auto insertion = blocksMap.insert({&lBlock, &rBlock});
call    0 never executed
    #####:  664:    if (insertion.first->getSecond() != &rBlock)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  665:      return false;
        -:  666:
    #####:  667:    for (auto argPair :
    #####:  668:         llvm::zip(lBlock.getArguments(), rBlock.getArguments())) {
branch  0 never executed
branch  1 never executed
    #####:  669:      Value curArg = std::get<0>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  670:      Value otherArg = std::get<1>(argPair);
branch  0 never executed
branch  1 never executed
    #####:  671:      if (curArg.getType() != otherArg.getType())
branch  0 never executed
branch  1 never executed
    #####:  672:        return false;
    #####:  673:      if (!(flags & OperationEquivalence::IgnoreLocations) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  674:          curArg.getLoc() != otherArg.getLoc())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  675:        return false;
        -:  676:      // Check if this value was already mapped to another value.
    #####:  677:      if (failed(mapOperands(curArg, otherArg)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  678:        return false;
        -:  679:    }
        -:  680:
function _ZZZL20isRegionEquivalentToPN4mlir6RegionES1_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES5_EEES7_NS_20OperationEquivalence5FlagsEENKUlRNS_5BlockESB_E_clESB_SB_ENKUlRNS_9OperationESE_E_clESE_SE_ called 0 returned 0% blocks executed 0%
    #####:  681:    auto opsEquivalent = [&](Operation &lOp, Operation &rOp) {
        -:  682:      // Check for op equality (recursively).
    #####:  683:      if (!OperationEquivalence::isEquivalentTo(&lOp, &rOp, mapOperands,
branch  0 never executed
branch  1 never executed
    #####:  684:                                                mapResults, flags))
call    0 never executed
        -:  685:        return false;
        -:  686:      // Check successor mapping.
    #####:  687:      for (auto successorsPair :
call    0 never executed
    #####:  688:           llvm::zip(lOp.getSuccessors(), rOp.getSuccessors())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  689:        Block *curSuccessor = std::get<0>(successorsPair);
call    0 never executed
    #####:  690:        Block *otherSuccessor = std::get<1>(successorsPair);
call    0 never executed
    #####:  691:        auto insertion = blocksMap.insert({curSuccessor, otherSuccessor});
call    0 never executed
    #####:  692:        if (insertion.first->getSecond() != otherSuccessor)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  693:          return false;
        -:  694:      }
    #####:  695:      return true;
    #####:  696:    };
    #####:  697:    return llvm::all_of_zip(lBlock, rBlock, opsEquivalent);
call    0 never executed
    #####:  698:  };
    #####:  699:  return llvm::all_of_zip(*lhs, *rhs, blocksEquivalent);
call    0 never executed
call    1 never executed
        -:  700:}
        -:  701:
function _ZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsE called 1814499 returned 100% blocks executed 83%
  1814499:  702:bool OperationEquivalence::isEquivalentTo(
        -:  703:    Operation *lhs, Operation *rhs,
        -:  704:    function_ref<LogicalResult(Value, Value)> mapOperands,
        -:  705:    function_ref<LogicalResult(Value, Value)> mapResults, Flags flags) {
  1814499:  706:  if (lhs == rhs)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  707:    return true;
        -:  708:
        -:  709:  // Compare the operation properties.
  1814499:  710:  if (lhs->getName() != rhs->getName() ||
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 54% (fallthrough)
branch  3 taken 46%
   380977:  711:      lhs->getAttrDictionary() != rhs->getAttrDictionary() ||
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
   206657:  712:      lhs->getNumRegions() != rhs->getNumRegions() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   206657:  713:      lhs->getNumSuccessors() != rhs->getNumSuccessors() ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2151524:  714:      lhs->getNumOperands() != rhs->getNumOperands() ||
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
branch  2 taken 63% (fallthrough)
branch  3 taken 37%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
   206657:  715:      lhs->getNumResults() != rhs->getNumResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  716:    return false;
  206657*:  717:  if (!(flags & IgnoreLocations) && lhs->getLoc() != rhs->getLoc())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  718:    return false;
        -:  719:
   206657:  720:  ValueRange lhsOperands = lhs->getOperands(), rhsOperands = rhs->getOperands();
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
   413314:  721:  SmallVector<Value> lhsOperandStorage, rhsOperandStorage;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   206657:  722:  if (lhs->hasTrait<mlir::OpTrait::IsCommutative>()) {
call    0 returned 100%
branch  1 taken 26% (fallthrough)
branch  2 taken 74%
    53832:  723:    lhsOperandStorage.append(lhsOperands.begin(), lhsOperands.end());
call    0 returned 100%
    53832:  724:    llvm::sort(lhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  725:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  726:    });
    53832:  727:    lhsOperands = lhsOperandStorage;
call    0 returned 100%
        -:  728:
    53832:  729:    rhsOperandStorage.append(rhsOperands.begin(), rhsOperands.end());
call    0 returned 100%
    53832:  730:    llvm::sort(rhsOperandStorage, [](Value a, Value b) -> bool {
call    0 returned 100%
        -:  731:      return a.getAsOpaquePointer() < b.getAsOpaquePointer();
        -:  732:    });
    53832:  733:    rhsOperands = rhsOperandStorage;
call    0 returned 100%
        -:  734:  }
   206657:  735:  auto checkValueRangeMapping =
function _ZZN4mlir20OperationEquivalence14isEquivalentToEPNS_9OperationES2_N4llvm12function_refIFNS_13LogicalResultENS_5ValueES6_EEES8_NS0_5FlagsEENKUlNS_10ValueRangeESA_S8_E1_clESA_SA_S8_.isra.0 called 314551 returned 100% blocks executed 100%
   314551:  736:      [](ValueRange lhs, ValueRange rhs,
        -:  737:         function_ref<LogicalResult(Value, Value)> mapValues) {
   483020:  738:        for (auto operandPair : llvm::zip(lhs, rhs)) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
   267785:  739:          Value curArg = std::get<0>(operandPair);
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
   267785:  740:          Value otherArg = std::get<1>(operandPair);
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
   267785:  741:          if (curArg.getType() != otherArg.getType())
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
    99316:  742:            return false;
   246974:  743:          if (failed(mapValues(curArg, otherArg)))
call    0 returned 100%
branch  1 taken 68% (fallthrough)
branch  2 taken 32%
        -:  744:            return false;
        -:  745:        }
   215235:  746:        return true;
        -:  747:      };
        -:  748:  // Check mapping of operands and results.
   206657:  749:  if (!checkValueRangeMapping(lhsOperands, rhsOperands, mapOperands))
call    0 returned 100%
branch  1 taken 52% (fallthrough)
branch  2 taken 48%
        -:  750:    return false;
   323682:  751:  if (!checkValueRangeMapping(lhs->getResults(), rhs->getResults(), mapResults))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 99% (fallthrough)
branch  8 taken 1%
        -:  752:    return false;
  258813*:  753:  for (auto regionPair : llvm::zip(lhs->getRegions(), rhs->getRegions()))
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  754:    if (!isRegionEquivalentTo(&std::get<0>(regionPair),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  755:                              &std::get<1>(regionPair), mapOperands, mapResults,
call    0 never executed
        -:  756:                              flags))
    #####:  757:      return false;
   107341:  758:  return true;
        -:  759:}
