        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/SCF/Transforms/TileUsingInterface.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SCF/Transforms/CMakeFiles/obj.MLIRSCFTransforms.dir/TileUsingInterface.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SCF/Transforms/CMakeFiles/obj.MLIRSCFTransforms.dir/TileUsingInterface.cpp.gcda
        -:    0:Runs:128629
        -:    1://===- Tiling.cpp - Implementation of tiling using TilingInterface -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the tiling using TilingInterface.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/SCF/Transforms/TileUsingInterface.h"
        -:   14:
        -:   15:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   16:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   17:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   18:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   19:#include "mlir/Dialect/SCF/Utils/Utils.h"
        -:   20:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   21:#include "mlir/IR/Matchers.h"
        -:   22:#include "mlir/IR/PatternMatch.h"
        -:   23:#include "mlir/Interfaces/DestinationStyleOpInterface.h"
        -:   24:#include "mlir/Interfaces/TilingInterface.h"
        -:   25:#include "llvm/Support/Debug.h"
        -:   26:
        -:   27:#define DEBUG_TYPE "tile-using-interface"
        -:   28:
        -:   29:using namespace mlir;
        -:   30:
        -:   31:scf::SCFTilingOptions &
function _ZN4mlir3scf16SCFTilingOptions12setTileSizesEN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   32:scf::SCFTilingOptions::setTileSizes(ArrayRef<int64_t> ts) {
    #####:   33:  assert(!tileSizeComputationFunction && "tile sizes already set");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   34:  SmallVector<int64_t> tileSizes(ts.begin(), ts.end());
call    0 never executed
function _ZZN4mlir3scf16SCFTilingOptions12setTileSizesEN4llvm8ArrayRefIlEEENKUlRNS_9OpBuilderEPNS_9OperationEE_clES6_S8_ called 0 returned 0% blocks executed 0%
    #####:   35:  tileSizeComputationFunction = [tileSizes](OpBuilder &b, Operation *op) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:   36:    OpBuilder::InsertionGuard guard(b);
call    0 never executed
    #####:   37:    b.setInsertionPointToStart(
    #####:   38:        &op->getParentOfType<func::FuncOp>().getBody().front());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   39:    return llvm::to_vector<4>(map_range(tileSizes, [&](int64_t s) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   40:      Value v = b.create<arith::ConstantIndexOp>(op->getLoc(), s);
        -:   41:      return v;
    #####:   42:    }));
    #####:   43:  };
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   44:  return *this;
branch  0 never executed
branch  1 never executed
        -:   45:}
        -:   46:
        -:   47:/// Helper method to adjust the interchange vector to match the iteration
        -:   48:/// domain.
        -:   49:static SmallVector<int64_t>
function _ZL21fillInterchangeVectorN4llvm8ArrayRefIlEEm called 0 returned 0% blocks executed 0%
    #####:   50:fillInterchangeVector(ArrayRef<int64_t> interchangeVector,
        -:   51:                      size_t iterationDomainSize) {
    #####:   52:  SmallVector<int64_t> filledVector = llvm::to_vector(interchangeVector);
call    0 never executed
    #####:   53:  if (filledVector.size() < iterationDomainSize) {
branch  0 never executed
branch  1 never executed
    #####:   54:    auto range = llvm::seq<int64_t>(filledVector.size(), iterationDomainSize);
call    0 never executed
    #####:   55:    filledVector.append(range.begin(), range.end());
call    0 never executed
        -:   56:  }
    #####:   57:  if (filledVector.size() > iterationDomainSize)
branch  0 never executed
branch  1 never executed
    #####:   58:    filledVector.resize(iterationDomainSize);
call    0 never executed
    #####:   59:  return filledVector;
        -:   60:}
        -:   61:
        -:   62:/// Helper method to apply permutation to a vector
        -:   63:template <typename T>
    #####:   64:static SmallVector<T> applyPermutationToVector(const SmallVector<T> &vector,
        -:   65:                                               ArrayRef<int64_t> interchange) {
    #####:   66:  assert(interchange.size() == vector.size());
        -:   67:  return llvm::to_vector(
    #####:   68:      llvm::map_range(interchange, [&](int64_t val) { return vector[val]; }));
        -:   69:}
------------------
_Z24applyPermutationToVectorIN4mlir12OpFoldResultEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE:
function _Z24applyPermutationToVectorIN4mlir12OpFoldResultEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   64:static SmallVector<T> applyPermutationToVector(const SmallVector<T> &vector,
        -:   65:                                               ArrayRef<int64_t> interchange) {
    #####:   66:  assert(interchange.size() == vector.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   67:  return llvm::to_vector(
    #####:   68:      llvm::map_range(interchange, [&](int64_t val) { return vector[val]; }));
call    0 never executed
        -:   69:}
------------------
_Z24applyPermutationToVectorIN4mlir5ValueEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE:
function _Z24applyPermutationToVectorIN4mlir5ValueEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   64:static SmallVector<T> applyPermutationToVector(const SmallVector<T> &vector,
        -:   65:                                               ArrayRef<int64_t> interchange) {
    #####:   66:  assert(interchange.size() == vector.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   67:  return llvm::to_vector(
    #####:   68:      llvm::map_range(interchange, [&](int64_t val) { return vector[val]; }));
call    0 never executed
        -:   69:}
------------------
_Z24applyPermutationToVectorIN4mlir5RangeEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE:
function _Z24applyPermutationToVectorIN4mlir5RangeEEN4llvm11SmallVectorIT_XsrNS2_42CalculateSmallVectorDefaultInlinedElementsIS4_EE5valueEEERKS7_NS2_8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   64:static SmallVector<T> applyPermutationToVector(const SmallVector<T> &vector,
        -:   65:                                               ArrayRef<int64_t> interchange) {
    #####:   66:  assert(interchange.size() == vector.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   67:  return llvm::to_vector(
    #####:   68:      llvm::map_range(interchange, [&](int64_t val) { return vector[val]; }));
call    0 never executed
        -:   69:}
------------------
        -:   70:/// Helper method to apply to invert a permutation.
        -:   71:static SmallVector<int64_t>
function _ZL23invertPermutationVectorN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   72:invertPermutationVector(ArrayRef<int64_t> interchange) {
    #####:   73:  SmallVector<int64_t> inversion(interchange.size());
call    0 never executed
    #####:   74:  for (const auto &pos : llvm::enumerate(interchange)) {
branch  0 never executed
branch  1 never executed
    #####:   75:    inversion[pos.value()] = pos.index();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   76:  }
    #####:   77:  return inversion;
        -:   78:}
        -:   79:/// Method to check if an interchange vector is a permutation.
function _ZL13isPermutationN4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:   80:static bool isPermutation(ArrayRef<int64_t> interchange) {
    #####:   81:  llvm::SmallDenseSet<int64_t, 4> seenVals;
call    0 never executed
    #####:   82:  for (auto val : interchange) {
branch  0 never executed
branch  1 never executed
    #####:   83:    if (seenVals.count(val))
call    0 never executed
    #####:   84:      return false;
    #####:   85:    seenVals.insert(val);
call    0 never executed
        -:   86:  }
    #####:   87:  return seenVals.size() == interchange.size();
        -:   88:}
        -:   89:
        -:   90://===----------------------------------------------------------------------===//
        -:   91:// tileUsingSCFForOp implementation.
        -:   92://===----------------------------------------------------------------------===//
        -:   93:
        -:   94:// Check if `stride` evenly divides the trip count `size - offset`.
function _ZL26tileDividesIterationDomainN4mlir5RangeE called 0 returned 0% blocks executed 0%
    #####:   95:static bool tileDividesIterationDomain(Range loopRange) {
    #####:   96:  Optional<int64_t> offsetAsInt = getConstantIntValue(loopRange.offset);
call    0 never executed
    #####:   97:  if (!offsetAsInt)
branch  0 never executed
branch  1 never executed
        -:   98:    return false;
    #####:   99:  Optional<int64_t> sizeAsInt = getConstantIntValue(loopRange.size);
call    0 never executed
    #####:  100:  if (!sizeAsInt)
branch  0 never executed
branch  1 never executed
        -:  101:    return false;
    #####:  102:  Optional<int64_t> strideAsInt = getConstantIntValue(loopRange.stride);
call    0 never executed
    #####:  103:  if (!strideAsInt)
branch  0 never executed
branch  1 never executed
        -:  104:    return false;
    #####:  105:  return ((sizeAsInt.value() - offsetAsInt.value()) % strideAsInt.value() == 0);
        -:  106:}
        -:  107:
        -:  108:/// Returns the bounded tile size given the current `iv`, `loopRange` and
        -:  109:/// `tileSize`, i.e., `min(tileSize, range.end() - iv)`.
        -:  110:static OpFoldResult getBoundedTileSize(OpBuilder &b, Location loc,
        -:  111:                                       Range loopRange, Value iv,
        -:  112:                                       Value tileSize) {
        -:  113:  Optional<int64_t> ts = getConstantIntValue(tileSize);
        -:  114:  if (ts && ts.value() == 1)
        -:  115:    return getAsOpFoldResult(tileSize);
        -:  116:
        -:  117:  if (tileDividesIterationDomain(
        -:  118:          Range{loopRange.offset, loopRange.size, tileSize}))
        -:  119:    return tileSize;
        -:  120:
        -:  121:  // The tile size to use (to avoid out of bounds access) is  minimum of
        -:  122:  // `tileSize` and `ub - iv`, where `iv` is the induction variable of the tiled
        -:  123:  // loop.
        -:  124:  AffineExpr s0, s1, d0;
        -:  125:  bindDims(b.getContext(), d0);
        -:  126:  bindSymbols(b.getContext(), s0, s1);
        -:  127:  AffineMap minMap = AffineMap::get(1, 2, {s0, s1 - d0}, b.getContext());
        -:  128:  Value size = getValueOrCreateConstantIndexOp(b, loc, loopRange.size);
        -:  129:  return makeComposedFoldedAffineMin(
        -:  130:      b, loc, minMap, SmallVector<OpFoldResult>{iv, tileSize, size});
        -:  131:}
        -:  132:
        -:  133:/// Generate an empty loop nest that represents the tiled loop nest shell.
        -:  134:/// - `loopRanges` specifies the lb, ub and step of the untiled iteration space.
        -:  135:/// - `tileSizeVals` is the tile sizes to use. Zero represent untiled loops.
        -:  136:/// - In `offsets` and `sizes` return the multi-dimensional offset and size of
        -:  137:/// the
        -:  138:///   tile processed within the inner most loop.
        -:  139:static SmallVector<scf::ForOp>
function _ZL20generateTileLoopNestRN4mlir9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS4_INS_5ValueEEERNS3_11SmallVectorINS_12OpFoldResultELj6EEESC_ called 0 returned 0% blocks executed 0%
    #####:  140:generateTileLoopNest(OpBuilder &builder, Location loc,
        -:  141:                     ArrayRef<Range> loopRanges, ArrayRef<Value> tileSizeVals,
        -:  142:                     SmallVector<OpFoldResult> &offsets,
        -:  143:                     SmallVector<OpFoldResult> &sizes) {
    #####:  144:  assert(!loopRanges.empty() && "expected at least one loop range");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  145:  assert(loopRanges.size() == tileSizeVals.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  146:         "expected as many tile sizes as loop ranges");
    #####:  147:  OpBuilder::InsertionGuard guard(builder);
call    0 never executed
    #####:  148:  SmallVector<scf::ForOp> loops;
call    0 never executed
    #####:  149:  offsets.resize(loopRanges.size());
call    0 never executed
    #####:  150:  sizes.resize(loopRanges.size());
call    0 never executed
        -:  151:
    #####:  152:  for (auto loopRange : llvm::enumerate(loopRanges)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  153:    Value offset =
    #####:  154:        getValueOrCreateConstantIndexOp(builder, loc, loopRange.value().offset);
call    0 never executed
    #####:  155:    Value size =
    #####:  156:        getValueOrCreateConstantIndexOp(builder, loc, loopRange.value().size);
call    0 never executed
    #####:  157:    Value tileSize = tileSizeVals[loopRange.index()];
branch  0 never executed
branch  1 never executed
        -:  158:    // No loops if tile size is zero. Set offset and size to the loop
        -:  159:    // offset and size.
    #####:  160:    if (matchPattern(tileSize, m_Zero())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  161:      offsets[loopRange.index()] = offset;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  162:      sizes[loopRange.index()] = size;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  163:      continue;
        -:  164:    }
        -:  165:
    #####:  166:    auto loop = builder.create<scf::ForOp>(
    #####:  167:        loc, offset, size, tileSize, ValueRange{},
call    0 never executed
function _ZZL20generateTileLoopNestRN4mlir9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS4_INS_5ValueEEERNS3_11SmallVectorINS_12OpFoldResultELj6EEESC_ENKUlS1_S2_S7_NS_10ValueRangeEE_clES1_S2_S7_SD_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  168:        [&](OpBuilder &bodyBuilder, Location bodyLoc, Value iv,
        -:  169:            ValueRange /*iterArgs*/) {
    #####:  170:          sizes[loopRange.index()] = getBoundedTileSize(
branch  0 never executed
branch  1 never executed
    #####:  171:              bodyBuilder, bodyLoc, loopRange.value(), iv, tileSize);
call    0 never executed
    #####:  172:          builder.create<scf::YieldOp>(loc);
call    0 never executed
    #####:  173:        });
call    0 never executed
call    1 never executed
    #####:  174:    offsets[loopRange.index()] = loop.getInductionVar();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  175:    loops.push_back(loop);
call    0 never executed
    #####:  176:    builder.setInsertionPoint(loop.getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  177:  }
    #####:  178:  return loops;
branch  0 never executed
branch  1 never executed
        -:  179:}
        -:  180:
        -:  181:/// For a value to be yielded (`yieldedValue`) from within a loop nest `loops`,
        -:  182:/// construct the destructive update pattern that inserts the yielded
        -:  183:/// value into a destination tensor provided by `initValue` at offset
        -:  184:/// `tileOffsets` and size `tileSizes`. For example,
        -:  185:///
        -:  186:/// ```mlir
        -:  187:/// scf.for %iv0 = ... {
        -:  188:///   %0 = tiled_op
        -:  189:/// }
        -:  190:/// ```
        -:  191:///
        -:  192:/// is transformed to
        -:  193:///
        -:  194:/// ```mlir
        -:  195:/// scf.for %iv0 = ... iter_args(%arg = %0) {
        -:  196:///   %1 = tensor.extract_slice %arg
        -:  197:///   %2 = tiled_op
        -:  198:///   %3 = tensor.insert_slice %2 into %arg
        -:  199:///   scf.yield %3
        -:  200:/// }
        -:  201:/// ```
        -:  202:/// TODO: This API can be cleaned up by using `SubsetExtractOpInterface`.
        -:  203:static FailureOr<SmallVector<Value>>
function _ZL16yieldTiledValuesRN4mlir12RewriterBaseENS_10ValueRangeES2_N4llvm8ArrayRefINS3_11SmallVectorINS_12OpFoldResultELj6EEEEES8_NS3_15MutableArrayRefINS_3scf5ForOpEEE called 0 returned 0% blocks executed 0%
    #####:  204:yieldTiledValues(RewriterBase &rewriter, ValueRange initValues,
        -:  205:                 ValueRange yieldedValues,
        -:  206:                 ArrayRef<SmallVector<OpFoldResult>> tileOffsetsList,
        -:  207:                 ArrayRef<SmallVector<OpFoldResult>> tileSizesList,
        -:  208:                 MutableArrayRef<scf::ForOp> loops) {
    #####:  209:  NewYieldValueFn yieldValueFn =
function _ZZL16yieldTiledValuesRN4mlir12RewriterBaseENS_10ValueRangeES2_N4llvm8ArrayRefINS3_11SmallVectorINS_12OpFoldResultELj6EEEEES8_NS3_15MutableArrayRefINS_3scf5ForOpEEEENKUlRNS_9OpBuilderENS_8LocationENS4_INS_13BlockArgumentEEEE_clESE_SF_SH_ called 0 returned 0% blocks executed 0%
    #####:  210:      [&](OpBuilder &b, Location loc,
        -:  211:          ArrayRef<BlockArgument> newBBArgs) -> SmallVector<Value> {
    #####:  212:    SmallVector<Value> inserts;
    #####:  213:    for (const auto &yieldedValue : llvm::enumerate(yieldedValues)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  214:      ArrayRef<OpFoldResult> tileOffsets =
    #####:  215:          tileOffsetsList[yieldedValue.index()];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  216:      ArrayRef<OpFoldResult> tileSizes = tileSizesList[yieldedValue.index()];
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  217:      SmallVector<OpFoldResult> tileStrides(tileOffsets.size(),
    #####:  218:                                            b.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  219:      Value insert = b.create<tensor::InsertSliceOp>(
    #####:  220:          loc, yieldedValue.value(), newBBArgs[yieldedValue.index()],
    #####:  221:          tileOffsets, tileSizes, tileStrides);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  222:      inserts.push_back(insert);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  223:    }
    #####:  224:    return inserts;
    #####:  225:  };
call    0 never executed
        -:  226:
    #####:  227:  SmallVector<scf::ForOp> newLoops =
        -:  228:      replaceLoopNestWithNewYields(rewriter, loops, initValues, yieldValueFn,
    #####:  229:                                   /*replaceIterOperandsUsesInLoop =*/false);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  230:  for (const auto &loop : llvm::enumerate(loops)) {
branch  0 never executed
branch  1 never executed
    #####:  231:    rewriter.eraseOp(loop.value());
call    0 never executed
    #####:  232:    loops[loop.index()] = newLoops[loop.index()];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  233:  }
    #####:  234:  return llvm::to_vector(llvm::map_range(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  235:      loops.front().getResults().take_back(yieldedValues.size()),
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  236:      [](OpResult r) -> Value { return r; }));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  237:}
        -:  238:
        -:  239:/// If the tiled operation is destination passing style, update the
        -:  240:/// slice of the destination used (which refers to the untiled destination)
        -:  241:/// to use the corresponding region argument of the innermost loop.
        -:  242:///
        -:  243:/// ```mlir
        -:  244:/// %0 =
        -:  245:/// scf.for %iv0 = ... iter_args(%arg = %0) {
        -:  246:///   %1 = tensor.extract_slice %0
        -:  247:///   %2 = tiled_op
        -:  248:///   %3 = tensor.insert_slice %2 into %arg
        -:  249:///   scf.yield %3
        -:  250:/// }
        -:  251:/// ```
        -:  252:///
        -:  253:/// is transformed to
        -:  254:///
        -:  255:/// ```mlir
        -:  256:/// scf.for %iv0 = ... iter_args(%arg = %0) {
        -:  257:///   %1 = tensor.extract_slice %arg
        -:  258:///   %2 = tiled_op
        -:  259:///   %3 = tensor.insert_slice %2 into %arg
        -:  260:///   scf.yield %3
        -:  261:/// }
        -:  262:/// ```
        -:  263:static void
        -:  264:updateDestinationOperandsForTiledOp(OpBuilder &builder,
        -:  265:                                    ValueRange tiledOpDestinationValues,
        -:  266:                                    ValueRange bbArgsList) {
        -:  267:  for (const auto &destValue : llvm::enumerate(tiledOpDestinationValues)) {
        -:  268:    auto sliceOp = destValue.value().getDefiningOp<tensor::ExtractSliceOp>();
        -:  269:    if (!sliceOp)
        -:  270:      continue;
        -:  271:    sliceOp.setOperand(0, bbArgsList[destValue.index()]);
        -:  272:  }
        -:  273:}
        -:  274:
        -:  275:/// Implementation of tiling transformation of `op` that implements the
        -:  276:/// `TilingInterface` using `scf.for` to iterate over the tiles.
        -:  277:FailureOr<scf::SCFTilingResult>
function _ZN4mlir3scf17tileUsingSCFForOpERNS_12RewriterBaseENS_15TilingInterfaceERKNS0_16SCFTilingOptionsE called 0 returned 0% blocks executed 0%
    #####:  278:mlir::scf::tileUsingSCFForOp(RewriterBase &rewriter, TilingInterface op,
        -:  279:                             const scf::SCFTilingOptions &options) {
    #####:  280:  OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  281:  rewriter.setInsertionPointAfter(op);
call    0 never executed
        -:  282:
    #####:  283:  if (!options.tileSizeComputationFunction) {
branch  0 never executed
branch  1 never executed
    #####:  284:    return rewriter.notifyMatchFailure(
    #####:  285:        op, "missing tile size computation function");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  286:  }
        -:  287:
        -:  288:  // Get destination tensors.
    #####:  289:  SmallVector<Value> destinationTensors;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  290:  if (failed(tensor::getOrCreateDestinations(rewriter, op.getLoc(), op,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:                                             destinationTensors)))
    #####:  292:    return rewriter.notifyMatchFailure(op, "failed to get destinations");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:
        -:  294:  // 1. Get the range of the loops that are represented by the operation.
    #####:  295:  SmallVector<Range> iterationDomain = op.getIterationDomain(rewriter);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  296:  size_t numLoops = iterationDomain.size();
branch  0 never executed
branch  1 never executed
    #####:  297:  if (numLoops == 0) {
branch  0 never executed
branch  1 never executed
    #####:  298:    return rewriter.notifyMatchFailure(
    #####:  299:        op, "unable to tile op with no iteration domain");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  300:  }
        -:  301:
        -:  302:  // 2. Materialize the tile sizes. Enforce the convention that "tiling by zero"
        -:  303:  // skips tiling a particular dimension. This convention is significantly
        -:  304:  // simpler to handle instead of adjusting affine maps to account for missing
        -:  305:  // dimensions.
    #####:  306:  SmallVector<Value> tileSizeVector =
    #####:  307:      options.tileSizeComputationFunction(rewriter, op);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  308:  if (tileSizeVector.size() < iterationDomain.size()) {
branch  0 never executed
branch  1 never executed
    #####:  309:    auto zero = rewriter.create<arith::ConstantIndexOp>(op.getLoc(), 0);
call    0 never executed
    #####:  310:    tileSizeVector.append(numLoops - tileSizeVector.size(), zero);
call    0 never executed
        -:  311:  }
        -:  312:
    #####:  313:  scf::SCFTilingResult tilingResult;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  314:  SmallVector<OpFoldResult> offsets, sizes;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  315:  {
        -:  316:    // If there is an interchange specified, permute the iteration domain and
        -:  317:    // the tile sizes.
    #####:  318:    SmallVector<int64_t> interchangeVector;
    #####:  319:    if (!options.interchangeVector.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  320:      interchangeVector = fillInterchangeVector(options.interchangeVector,
call    0 never executed
call    1 never executed
    #####:  321:                                                iterationDomain.size());
branch  0 never executed
branch  1 never executed
        -:  322:    }
    #####:  323:    if (!interchangeVector.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  324:      if (!isPermutation(interchangeVector)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  325:        return rewriter.notifyMatchFailure(
        -:  326:            op, "invalid intechange vector, not a permutation of the entire "
    #####:  327:                "iteration space");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  328:      }
        -:  329:
    #####:  330:      iterationDomain =
call    0 never executed
    #####:  331:          applyPermutationToVector(iterationDomain, interchangeVector);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  332:      tileSizeVector =
call    0 never executed
    #####:  333:          applyPermutationToVector(tileSizeVector, interchangeVector);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  334:    }
        -:  335:
        -:  336:    // 3. Materialize an empty loop nest that iterates over the tiles. These
        -:  337:    // loops for now do not return any values even if the original operation has
        -:  338:    // results.
    #####:  339:    tilingResult.loops = generateTileLoopNest(
call    0 never executed
call    1 never executed
    #####:  340:        rewriter, op.getLoc(), iterationDomain, tileSizeVector, offsets, sizes);
branch  0 never executed
branch  1 never executed
        -:  341:
    #####:  342:    if (!interchangeVector.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  343:      auto inversePermutation = invertPermutationVector(interchangeVector);
call    0 never executed
    #####:  344:      offsets = applyPermutationToVector(offsets, inversePermutation);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  345:      sizes = applyPermutationToVector(sizes, inversePermutation);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  346:    }
        -:  347:  }
        -:  348:
    #####:  349:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
        -:  350:    if (!tilingResult.loops.empty()) {
        -:  351:      llvm::dbgs() << "LoopNest shell :\n";
        -:  352:      tilingResult.loops.front().dump();
        -:  353:      llvm::dbgs() << "\n";
        -:  354:    }
        -:  355:  });
        -:  356:
        -:  357:  // 4. Generate the tiled implementation within the inner most loop.
    #####:  358:  if (!tilingResult.loops.empty())
branch  0 never executed
branch  1 never executed
    #####:  359:    rewriter.setInsertionPoint(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  360:        tilingResult.loops.back().getBody()->getTerminator());
call    0 never executed
    #####:  361:  SmallVector<Operation *> tiledImplementation =
call    0 never executed
    #####:  362:      op.getTiledImplementation(rewriter, offsets, sizes);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  363:  if (tiledImplementation.size() != 1) {
branch  0 never executed
branch  1 never executed
    #####:  364:    return rewriter.notifyMatchFailure(
    #####:  365:        op, "expected tiled implementation to return a single op");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  366:  }
    #####:  367:  tilingResult.tiledOp = tiledImplementation[0];
branch  0 never executed
branch  1 never executed
    #####:  368:  if (op->getNumResults() == 0) {
branch  0 never executed
branch  1 never executed
        -:  369:    // nothing more to do.
    #####:  370:    return tilingResult;
call    0 never executed
        -:  371:  }
        -:  372:
        -:  373:  // If loops are empty, the tiled op is used as the replacement for the untiled
        -:  374:  // op.
    #####:  375:  if (tilingResult.loops.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  376:    tilingResult.replacements = llvm::to_vector(
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  377:        llvm::map_range(tiledImplementation[0]->getResults(),
branch  0 never executed
branch  1 never executed
    #####:  378:                        [](OpResult result) -> Value { return result; }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  379:    return tilingResult;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  380:  }
        -:  381:
        -:  382:  // 5. Yield all the results of the tiled operation. The surrounding loop
        -:  383:  //    nest is modified to insert a destructive update pattern to yield
        -:  384:  //    from the loop nest values to replace the untiled op with.
    #####:  385:  int64_t numResults = op->getNumResults();
call    0 never executed
    #####:  386:  SmallVector<SmallVector<OpFoldResult>> resultOffsetsList(numResults),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  387:      resultSizesList(numResults);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  388:  for (const auto &result : llvm::enumerate(op->getResults())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  389:    if (failed(op.getResultTilePosition(rewriter, result.index(), offsets,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  390:                                        sizes,
    #####:  391:                                        resultOffsetsList[result.index()],
call    0 never executed
    #####:  392:                                        resultSizesList[result.index()]))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  393:      return rewriter.notifyMatchFailure(
    #####:  394:          op, "failed to get slice of result produced");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  395:    }
        -:  396:  }
        -:  397:
    #####:  398:  FailureOr<SmallVector<Value>> replacementOr = yieldTiledValues(
branch  0 never executed
branch  1 never executed
    #####:  399:      rewriter, destinationTensors, tilingResult.tiledOp->getResults(),
    #####:  400:      resultOffsetsList, resultSizesList, tilingResult.loops);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  401:  if (failed(replacementOr))
branch  0 never executed
branch  1 never executed
    #####:  402:    return rewriter.notifyMatchFailure(op, "failed to yield replacement");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  403:
    #####:  404:  if (auto dstOp =
branch  0 never executed
branch  1 never executed
    #####:  405:          dyn_cast<DestinationStyleOpInterface>(tilingResult.tiledOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  406:    auto innerMostLoop = tilingResult.loops.back();
call    0 never executed
    #####:  407:    SmallVector<Value> destinationTensors = dstOp.getDpsInitOperands();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  408:    assert(destinationTensors.size() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  409:               innerMostLoop.getRegionIterArgs().size() &&
        -:  410:           "unexpected number of outputs");
    #####:  411:    updateDestinationOperandsForTiledOp(rewriter, destinationTensors,
call    0 never executed
call    1 never executed
    #####:  412:                                        innerMostLoop.getRegionIterArgs());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  413:  }
        -:  414:
    #####:  415:  tilingResult.replacements = replacementOr.value();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  416:
    #####:  417:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
        -:  418:    if (!tilingResult.loops.empty()) {
        -:  419:      llvm::dbgs() << "After tiled implementation :\n";
        -:  420:      tilingResult.loops.front().dump();
        -:  421:      llvm::dbgs() << "\n";
        -:  422:    }
        -:  423:  });
    #####:  424:  return tilingResult;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  425:}
        -:  426:
        -:  427://===----------------------------------------------------------------------===//
        -:  428:// tileConsumerAndFuseProducerGreedilyUsingSCFForOp implementation.
        -:  429://===----------------------------------------------------------------------===//
        -:  430:
        -:  431:/// Return the untiled producer whose slice is used in a tiled consumer. The
        -:  432:/// method traverses the tile loop nest (`loops`) if needed, and returns the
        -:  433:/// `iter_args` of the outer most that is encountered. Traversing the iter_args
        -:  434:/// indicates that this is a destination operand of the consumer. If there was
        -:  435:/// no loop traversal needed, the second value of the returned tuple is empty.
        -:  436:static std::tuple<OpResult, Optional<OpOperand *>>
function _ZL33getUntiledProducerFromSliceSourcePN4mlir9OpOperandEN4llvm8ArrayRefINS_3scf5ForOpEEE called 0 returned 0% blocks executed 0%
    #####:  437:getUntiledProducerFromSliceSource(OpOperand *source,
        -:  438:                                  ArrayRef<scf::ForOp> loops) {
    #####:  439:  Optional<OpOperand *> destinationIterArg;
    #####:  440:  auto loopIt = loops.rbegin();
    #####:  441:  while (auto iterArg = source->get().dyn_cast<BlockArgument>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  442:    scf::ForOp loop = *loopIt;
call    0 never executed
    #####:  443:    if (iterArg.getOwner()->getParentOp() != loop)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  444:      break;
    #####:  445:    source = &loop.getOpOperandForRegionIterArg(iterArg);
call    0 never executed
    #####:  446:    loopIt++;
    #####:  447:  }
    #####:  448:  if (loopIt == loops.rend())
branch  0 never executed
branch  1 never executed
    #####:  449:    destinationIterArg = source;
    #####:  450:  return {source->get().dyn_cast<OpResult>(), destinationIterArg};
call    0 never executed
        -:  451:}
        -:  452:
        -:  453:/// Implementation of tile consumer and fuse producer greedily.
        -:  454:FailureOr<scf::SCFTileAndFuseResult>
function _ZN4mlir3scf48tileConsumerAndFuseProducerGreedilyUsingSCFForOpERNS_12RewriterBaseENS_15TilingInterfaceERKNS0_21SCFTileAndFuseOptionsE called 0 returned 0% blocks executed 0%
    #####:  455:mlir::scf::tileConsumerAndFuseProducerGreedilyUsingSCFForOp(
        -:  456:    RewriterBase &rewriter, TilingInterface consumer,
        -:  457:    const scf::SCFTileAndFuseOptions &options) {
        -:  458:  // This transformation is only valid for ops that return values (i.e. not
        -:  459:  // valid to use with operations that have memref operands).
    #####:  460:  if (!consumer->getNumResults()) {
branch  0 never executed
branch  1 never executed
    #####:  461:    return rewriter.notifyMatchFailure(
    #####:  462:        consumer, "invalid pattern for op with no results");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  463:  }
        -:  464:
        -:  465:  // 1. First tile the consumer.
    #####:  466:  scf::SCFTileAndFuseResult tileAndFuseResult;
call    0 never executed
    #####:  467:  llvm::SmallDenseMap<Value, int64_t> yieldedValueToResultNumber;
call    0 never executed
call    1 never executed
    #####:  468:  {
    #####:  469:    FailureOr<scf::SCFTilingResult> tilingResult =
    #####:  470:        tileUsingSCFForOp(rewriter, consumer, options.tilingOptions);
call    0 never executed
    #####:  471:    if (failed(tilingResult))
branch  0 never executed
branch  1 never executed
    #####:  472:      return rewriter.notifyMatchFailure(consumer, "failed to tile consumer");
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  473:    tileAndFuseResult.tiledAndFusedOps.insert(tilingResult->tiledOp);
call    0 never executed
    #####:  474:    tileAndFuseResult.loops = std::move(tilingResult->loops);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  475:    for (const auto &result : llvm::enumerate(
branch  0 never executed
branch  1 never executed
    #####:  476:             llvm::zip(consumer->getResults(), tilingResult->replacements))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  477:      tileAndFuseResult.replacements[std::get<0>(result.value())] =
call    0 never executed
call    1 never executed
    #####:  478:          std::get<1>(result.value());
call    0 never executed
    #####:  479:      yieldedValueToResultNumber[tilingResult->tiledOp->getResult(
    #####:  480:          result.index())] = result.index();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -:  481:    }
        -:  482:  }
        -:  483:
        -:  484:  // If there are no loops generated, fusion is immaterial.
    #####:  485:  if (tileAndFuseResult.loops.empty())
branch  0 never executed
branch  1 never executed
    #####:  486:    return tileAndFuseResult;
call    0 never executed
        -:  487:
        -:  488:  // 2. Typically, the operands of the tiled operation are slices of the
        -:  489:  //    operands of the untiled operation. These are expressed in IR using
        -:  490:  //    `tensor.extract_slice` operations with source being the operands of the
        -:  491:  //    untiled operation. Create a worklist of these `tensor.extract_slice`
        -:  492:  //    operations. If the producers of the source of the `tensor.extract_slice`
        -:  493:  //    can be tiled such that the tiled value is generated in-place, that
        -:  494:  //    effectively tiles + fuses the operations.
function _ZZN4mlir3scf48tileConsumerAndFuseProducerGreedilyUsingSCFForOpERNS_12RewriterBaseENS_15TilingInterfaceERKNS0_21SCFTileAndFuseOptionsEENKUlPNS_9OperationERSt5dequeINS_6tensor14ExtractSliceOpESaISB_EEE_clES8_SE_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  495:  auto addCandidateSlices = [](Operation *fusedOp,
        -:  496:                               std::deque<tensor::ExtractSliceOp> &candidates) {
    #####:  497:    for (Value operand : fusedOp->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  498:      if (auto sliceOp = operand.getDefiningOp<tensor::ExtractSliceOp>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  499:        candidates.push_back(sliceOp);
branch  0 never executed
branch  1 never executed
    #####:  500:  };
        -:  501:
    #####:  502:  std::deque<tensor::ExtractSliceOp> candidates;
call    0 never executed
call    1 never executed
    #####:  503:  addCandidateSlices(tileAndFuseResult.tiledAndFusedOps.back(), candidates);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  504:  OpBuilder::InsertionGuard g(rewriter);
call    0 never executed
    #####:  505:  while (!candidates.empty()) {
branch  0 never executed
branch  1 never executed
        -:  506:    // 2a. Traverse the slices in BFS fashion.
    #####:  507:    tensor::ExtractSliceOp candidateSliceOp = candidates.front();
call    0 never executed
    #####:  508:    candidates.pop_front();
call    0 never executed
        -:  509:
        -:  510:    // 2b. Get the producer of the source (potentially walking through
        -:  511:    // `iter_args` of nested `scf.for`)
    #####:  512:    auto [fusableProducer, destinationIterArg] =
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  513:        getUntiledProducerFromSliceSource(&candidateSliceOp->getOpOperand(0),
    #####:  514:                                          tileAndFuseResult.loops);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  515:    if (!fusableProducer)
branch  0 never executed
branch  1 never executed
    #####:  516:      continue;
        -:  517:
        -:  518:    // 2c. Generate the tiled implementation of the producer of the source
    #####:  519:    rewriter.setInsertionPoint(candidateSliceOp);
call    0 never executed
    #####:  520:    FailureOr<Value> fusedProducerValue =
        -:  521:        tensor::replaceExtractSliceWithTiledProducer(rewriter, candidateSliceOp,
    #####:  522:                                                     fusableProducer);
call    0 never executed
    #####:  523:    if (failed(fusedProducerValue))
branch  0 never executed
branch  1 never executed
    #####:  524:      continue;
    #####:  525:    rewriter.replaceOp(candidateSliceOp, fusedProducerValue.value());
call    0 never executed
call    1 never executed
        -:  526:
        -:  527:    // 2d. The operands of the fused producer might themselved be slices of
        -:  528:    //     values produced by operations that implement the `TilingInterface`.
        -:  529:    //     Add these operations to the worklist.
    #####:  530:    Operation *fusedProducer = fusedProducerValue->getDefiningOp();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  531:    tileAndFuseResult.tiledAndFusedOps.insert(fusedProducer);
call    0 never executed
    #####:  532:    addCandidateSlices(fusedProducer, candidates);
call    0 never executed
        -:  533:
        -:  534:    // 2e. If the slice is for a destination operand, for example,
        -:  535:    //
        -:  536:    // ```mlir
        -:  537:    // %0 = linalg.init
        -:  538:    // %1 = linalg.fill .. outs(%0 : )
        -:  539:    // %2 = scf.for .. iter_args(%arg0 = %1) {
        -:  540:    //   %3 = scf.for .. iter_args(%arg1 = %arg0) {
        -:  541:    //     %4 = tensor.extract_slice %arg1 [..]
        -:  542:    //     .. = linalg.matmul .. outs(%4 : )
        -:  543:    //   }
        -:  544:    // }
        -:  545:    // ```
        -:  546:    //
        -:  547:    // the IR is currently
        -:  548:    //
        -:  549:    // ```
        -:  550:    // %0 = linalg.init
        -:  551:    // %1 = linalg.fill
        -:  552:    // %2 = scf.for .. iter_args(%arg0 = %1 /* incorrect value */ ) {
        -:  553:    //   %3 = scf.for .. iter_args(%arg1 = %arg0) {
        -:  554:    //     %4 = tensor.extract_slice %0 /*incorrect value */ [..]
        -:  555:    //     %5 = linalg.fill .. outs(%4 : )
        -:  556:    //     .. = linalg.matmul .. outs(%5 : )
        -:  557:    //   }
        -:  558:    // }
        -:  559:    // ```
        -:  560:    //
        -:  561:    // The untiled `linalg.fill` is still used as the `init_value` since it
        -:  562:    // was originally a destination operand of the untiled `linalg.matmul`.
        -:  563:    // When fusing an operand that is a destination operand.
        -:  564:    //   - Update the iter_arg of the outer most loop to use the destination
        -:  565:    //     of the untiled producer.
        -:  566:    //   - Update the destination of the slice of the tiled producer generated
        -:  567:    //     to use the same basic block argument as the slice that was used to
        -:  568:    //     generate inplace the tiled implementation of the producer.
        -:  569:    // With this the IR will be.
        -:  570:    //
        -:  571:    // ```
        -:  572:    // %0 = linalg.init
        -:  573:    // %1 = scf.for .. iter_args(%arg0 = %0 /* corrected value */ ) {
        -:  574:    //   %2 = scf.for .. iter_args(%arg1 = %arg0) {
        -:  575:    //     %3 = tensor.extract_slice %arg1 /* corrected value */ [..]
        -:  576:    //     %4 = linalg.fill .. outs(%3 : )
        -:  577:    //     .. = linalg.matmul .. outs(%4 : )
        -:  578:    //   }
        -:  579:    // }
        -:  580:    // ```
        -:  581:    // TODO: This can be modeled better if the `DestinationStyleOpInterface`.
        -:  582:    // Update to use that when it does become available.
    #####:  583:    scf::ForOp outerMostLoop = tileAndFuseResult.loops.front();
branch  0 never executed
branch  1 never executed
    #####:  584:    Optional<unsigned> iterArgNumber;
    #####:  585:    if (destinationIterArg) {
branch  0 never executed
branch  1 never executed
    #####:  586:      iterArgNumber = outerMostLoop.getIterArgNumberForOpOperand(
call    0 never executed
    #####:  587:          *destinationIterArg.value());
call    0 never executed
        -:  588:    }
    #####:  589:    if (iterArgNumber) {
branch  0 never executed
branch  1 never executed
    #####:  590:      int64_t resultNumber = fusableProducer.getResultNumber();
call    0 never executed
    #####:  591:      if (auto dstOp = dyn_cast<DestinationStyleOpInterface>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  592:              fusableProducer.getOwner())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  593:        outerMostLoop.setIterArg(
call    0 never executed
    #####:  594:            iterArgNumber.value(),
call    0 never executed
    #####:  595:            dstOp.getTiedOpOperand(fusableProducer)->get());
call    0 never executed
        -:  596:      }
    #####:  597:      if (auto dstOp = fusedProducerValue.value()
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  598:                           .getDefiningOp<DestinationStyleOpInterface>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  599:        scf::ForOp innerMostLoop = tileAndFuseResult.loops.back();
call    0 never executed
    #####:  600:        updateDestinationOperandsForTiledOp(
call    0 never executed
    #####:  601:            rewriter, dstOp.getDpsInitOperand(resultNumber)->get(),
call    0 never executed
call    1 never executed
    #####:  602:            innerMostLoop.getRegionIterArgs()[iterArgNumber.value()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  603:      }
        -:  604:    }
        -:  605:  }
    #####:  606:  return tileAndFuseResult;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  607:}
        -:  608:
        -:  609://===----------------------------------------------------------------------===//
        -:  610:// lowerToLoopsUsingSCFForOp implementation.
        -:  611://===----------------------------------------------------------------------===//
        -:  612:
        -:  613:FailureOr<SmallVector<scf::ForOp>>
function _ZN4mlir3scf25lowerToLoopsUsingSCFForOpERNS_12RewriterBaseENS_15TilingInterfaceE called 0 returned 0% blocks executed 0%
    #####:  614:mlir::scf::lowerToLoopsUsingSCFForOp(RewriterBase &rewriter,
        -:  615:                                     TilingInterface op) {
        -:  616:  // TODO: Handle cases where the op has results if needed.
    #####:  617:  if (op->getNumResults() > 0) {
branch  0 never executed
branch  1 never executed
    #####:  618:    return rewriter.notifyMatchFailure(
    #####:  619:        op, "unable to lower to loops operations with return values");
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  620:  }
        -:  621:
    #####:  622:  SmallVector<Range> domain = op.getIterationDomain(rewriter);
call    0 never executed
    #####:  623:  SmallVector<Value> ivs;
branch  0 never executed
branch  1 never executed
    #####:  624:  SmallVector<scf::ForOp> loops;
branch  0 never executed
branch  1 never executed
    #####:  625:  Location loc = op.getLoc();
    #####:  626:  for (auto loopRange : domain) {
branch  0 never executed
branch  1 never executed
    #####:  627:    Value offsetVal =
    #####:  628:        getValueOrCreateConstantIndexOp(rewriter, loc, loopRange.offset);
call    0 never executed
    #####:  629:    Value sizeVal =
    #####:  630:        getValueOrCreateConstantIndexOp(rewriter, loc, loopRange.size);
call    0 never executed
    #####:  631:    Value strideVal =
    #####:  632:        getValueOrCreateConstantIndexOp(rewriter, loc, loopRange.stride);
call    0 never executed
    #####:  633:    auto loop = rewriter.create<scf::ForOp>(op.getLoc(), offsetVal, sizeVal,
    #####:  634:                                            strideVal, ValueRange{});
call    0 never executed
call    1 never executed
    #####:  635:    loops.push_back(loop);
call    0 never executed
    #####:  636:    ivs.push_back(loop.getInductionVar());
call    0 never executed
call    1 never executed
    #####:  637:    rewriter.setInsertionPoint(loop.getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  638:  }
    #####:  639:  if (failed(op.generateScalarImplementation(rewriter, op.getLoc(), ivs))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  640:    return failure();
        -:  641:  }
    #####:  642:  return loops;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  643:}
