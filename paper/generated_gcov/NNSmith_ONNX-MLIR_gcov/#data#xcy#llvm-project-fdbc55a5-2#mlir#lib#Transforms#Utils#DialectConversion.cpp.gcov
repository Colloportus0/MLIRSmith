        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Transforms/Utils/DialectConversion.cpp
        -:    0:Graph:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/DialectConversion.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Transforms/Utils/CMakeFiles/obj.MLIRTransformUtils.dir/DialectConversion.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- DialectConversion.cpp - MLIR dialect conversion generic pass -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Transforms/DialectConversion.h"
        -:   10:#include "mlir/IR/Block.h"
        -:   11:#include "mlir/IR/BlockAndValueMapping.h"
        -:   12:#include "mlir/IR/Builders.h"
        -:   13:#include "mlir/IR/BuiltinOps.h"
        -:   14:#include "mlir/IR/FunctionInterfaces.h"
        -:   15:#include "mlir/Rewrite/PatternApplicator.h"
        -:   16:#include "llvm/ADT/ScopeExit.h"
        -:   17:#include "llvm/ADT/SetVector.h"
        -:   18:#include "llvm/ADT/SmallPtrSet.h"
        -:   19:#include "llvm/Support/Debug.h"
        -:   20:#include "llvm/Support/FormatVariadic.h"
        -:   21:#include "llvm/Support/SaveAndRestore.h"
        -:   22:#include "llvm/Support/ScopedPrinter.h"
        -:   23:
        -:   24:using namespace mlir;
        -:   25:using namespace mlir::detail;
        -:   26:
        -:   27:#define DEBUG_TYPE "dialect-conversion"
        -:   28:
        -:   29:/// Recursively collect all of the operations to convert from within 'region'.
        -:   30:/// If 'target' is nonnull, operations that are recursively legal have their
        -:   31:/// regions pre-filtered to avoid considering them for legalization.
        -:   32:static LogicalResult
function _ZL20computeConversionSetN4llvm14iterator_rangeINS_14ilist_iteratorINS_12ilist_detail12node_optionsIN4mlir5BlockELb1ELb0EvEELb0ELb0EEEEENS4_8LocationERNS_15SmallVectorImplIPNS4_9OperationEEEPNS4_16ConversionTargetE called 967715 returned 100% blocks executed 84%
   967715:   33:computeConversionSet(iterator_range<Region::iterator> region,
        -:   34:                     Location regionLoc,
        -:   35:                     SmallVectorImpl<Operation *> &toConvert,
        -:   36:                     ConversionTarget *target = nullptr) {
   967715:   37:  if (region.empty())
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
   681433:   38:    return success();
        -:   39:
        -:   40:  // Traverse starting from the entry block.
   286282:   41:  SmallVector<Block *, 16> worklist(1, &*region.begin());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
   572564:   42:  DenseSet<Block *> visitedBlocks;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
   286282:   43:  visitedBlocks.insert(worklist.front());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
  3419606:   44:  while (!worklist.empty()) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
  3133324:   45:    Block *block = worklist.pop_back_val();
call    0 returned 100%
        -:   46:
        -:   47:    // Compute the conversion set of each of the nested operations.
 30269306:   48:    for (Operation &op : *block) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
call    2 returned 100%
 27135982:   49:      toConvert.emplace_back(&op);
call    0 returned 100%
        -:   50:
        -:   51:      // Don't check this operation's children for conversion if the operation
        -:   52:      // is recursively legal.
 27135982:   53:      auto legalityInfo = target ? target->isLegal(&op)
call    0 returned 100%
 27135982:   54:                                 : Optional<ConversionTarget::LegalOpDetails>();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
27135982*:   55:      if (legalityInfo && legalityInfo->isRecursivelyLegal)
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   56:        continue;
 35068951:   57:      for (auto &region : op.getRegions()) {
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
   931989:   58:        if (failed(computeConversionSet(region.getBlocks(), region.getLoc(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   59:                                        toConvert, target)))
    #####:   60:          return failure();
        -:   61:      }
        -:   62:    }
        -:   63:
        -:   64:    // Recurse to children that haven't been visited.
  6893655:   65:    for (Block *succ : block->getSuccessors())
call    0 returned 100%
branch  1 taken 55% (fallthrough)
branch  2 taken 45%
call    3 returned 100%
  3760331:   66:      if (visitedBlocks.insert(succ).second)
call    0 returned 100%
branch  1 taken 76%
branch  2 taken 24%
  2847042:   67:        worklist.push_back(succ);
call    0 returned 100%
        -:   68:  }
        -:   69:
        -:   70:  // Check that all blocks in the region were visited.
   572564:   71:  if (llvm::any_of(llvm::drop_begin(region, 1),
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  2847042:   72:                   [&](Block &block) { return !visitedBlocks.count(&block); }))
call    0 returned 100%
    #####:   73:    return emitError(regionLoc, "unreachable blocks were not converted");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
   286282:   74:  return success();
call    0 returned 100%
        -:   75:}
        -:   76:
        -:   77:/// A utility function to log a successful result for the given reason.
        -:   78:template <typename... Args>
    #####:   79:static void logSuccess(llvm::ScopedPrinter &os, StringRef fmt, Args &&...args) {
    #####:   80:  LLVM_DEBUG({
        -:   81:    os.unindent();
        -:   82:    os.startLine() << "} -> SUCCESS";
        -:   83:    if (!fmt.empty())
        -:   84:      os.getOStream() << " : "
        -:   85:                      << llvm::formatv(fmt.data(), std::forward<Args>(args)...);
        -:   86:    os.getOStream() << "\n";
        -:   87:  });
    #####:   88:}
------------------
_Z10logSuccessIJEEvRN4llvm13ScopedPrinterENS0_9StringRefEDpOT_:
function _Z10logSuccessIJEEvRN4llvm13ScopedPrinterENS0_9StringRefEDpOT_ called 0 returned 0% blocks executed 0%
    #####:   79:static void logSuccess(llvm::ScopedPrinter &os, StringRef fmt, Args &&...args) {
    #####:   80:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
        -:   81:    os.unindent();
        -:   82:    os.startLine() << "} -> SUCCESS";
        -:   83:    if (!fmt.empty())
        -:   84:      os.getOStream() << " : "
        -:   85:                      << llvm::formatv(fmt.data(), std::forward<Args>(args)...);
        -:   86:    os.getOStream() << "\n";
        -:   87:  });
    #####:   88:}
------------------
_Z10logSuccessIJPKcEEvRN4llvm13ScopedPrinterENS2_9StringRefEDpOT_:
function _Z10logSuccessIJPKcEEvRN4llvm13ScopedPrinterENS2_9StringRefEDpOT_ called 0 returned 0% blocks executed 0%
    #####:   79:static void logSuccess(llvm::ScopedPrinter &os, StringRef fmt, Args &&...args) {
    #####:   80:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
        -:   81:    os.unindent();
        -:   82:    os.startLine() << "} -> SUCCESS";
        -:   83:    if (!fmt.empty())
        -:   84:      os.getOStream() << " : "
        -:   85:                      << llvm::formatv(fmt.data(), std::forward<Args>(args)...);
        -:   86:    os.getOStream() << "\n";
        -:   87:  });
    #####:   88:}
------------------
        -:   89:
        -:   90:/// A utility function to log a failure result for the given reason.
        -:   91:template <typename... Args>
        -:   92:static void logFailure(llvm::ScopedPrinter &os, StringRef fmt, Args &&...args) {
        -:   93:  LLVM_DEBUG({
        -:   94:    os.unindent();
        -:   95:    os.startLine() << "} -> FAILURE : "
        -:   96:                   << llvm::formatv(fmt.data(), std::forward<Args>(args)...)
        -:   97:                   << "\n";
        -:   98:  });
        -:   99:}
        -:  100:
        -:  101://===----------------------------------------------------------------------===//
        -:  102:// ConversionValueMapping
        -:  103://===----------------------------------------------------------------------===//
        -:  104:
        -:  105:namespace {
        -:  106:/// This class wraps a BlockAndValueMapping to provide recursive lookup
        -:  107:/// functionality, i.e. we will traverse if the mapped value also has a mapping.
    35726:  108:struct ConversionValueMapping {
        -:  109:  /// Lookup a mapped value within the map. If a mapping for the provided value
        -:  110:  /// does not exist then return the provided value. If `desiredType` is
        -:  111:  /// non-null, returns the most recently mapped value with that type. If an
        -:  112:  /// operand of that type does not exist, defaults to normal behavior.
        -:  113:  Value lookupOrDefault(Value from, Type desiredType = nullptr) const;
        -:  114:
        -:  115:  /// Lookup a mapped value within the map, or return null if a mapping does not
        -:  116:  /// exist. If a mapping exists, this follows the same behavior of
        -:  117:  /// `lookupOrDefault`.
        -:  118:  Value lookupOrNull(Value from, Type desiredType = nullptr) const;
        -:  119:
        -:  120:  /// Map a value to the one provided.
function _ZN12_GLOBAL__N_122ConversionValueMapping3mapEN4mlir5ValueES2_ called 408698 returned 100% blocks executed 27%
   408698:  121:  void map(Value oldVal, Value newVal) {
  408698*:  122:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
        -:  123:      for (Value it = newVal; it; it = mapping.lookupOrNull(it))
        -:  124:        assert(it != oldVal && "inserting cyclic mapping");
        -:  125:    });
   408698:  126:    mapping.map(oldVal, newVal);
call    0 returned 100%
   408698:  127:  }
        -:  128:
        -:  129:  /// Try to map a value to the one provided. Returns false if a transitive
        -:  130:  /// mapping from the new value to the old value already exists, true if the
        -:  131:  /// map was updated.
        -:  132:  bool tryMap(Value oldVal, Value newVal);
        -:  133:
        -:  134:  /// Drop the last mapping for the given value.
    #####:  135:  void erase(Value value) { mapping.erase(value); }
        -:  136:
        -:  137:  /// Returns the inverse raw value mapping (without recursive query support).
function _ZNK12_GLOBAL__N_122ConversionValueMapping10getInverseEv called 0 returned 0% blocks executed 0%
    #####:  138:  DenseMap<Value, SmallVector<Value>> getInverse() const {
    #####:  139:    DenseMap<Value, SmallVector<Value>> inverse;
call    0 never executed
    #####:  140:    for (auto &it : mapping.getValueMap())
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  141:      inverse[it.second].push_back(it.first);
call    0 never executed
call    1 never executed
    #####:  142:    return inverse;
        -:  143:  }
        -:  144:
        -:  145:private:
        -:  146:  /// Current value mappings.
        -:  147:  BlockAndValueMapping mapping;
        -:  148:};
        -:  149:} // namespace
        -:  150:
function _ZNK12_GLOBAL__N_122ConversionValueMapping15lookupOrDefaultEN4mlir5ValueENS1_4TypeE called 408698 returned 100% blocks executed 62%
   408698:  151:Value ConversionValueMapping::lookupOrDefault(Value from,
        -:  152:                                              Type desiredType) const {
        -:  153:  // If there was no desired type, simply find the leaf value.
   408698:  154:  if (!desiredType) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  155:    // If this value had a valid mapping, unmap that value as well in the case
        -:  156:    // that it was also replaced.
    #####:  157:    while (auto mappedValue = mapping.lookupOrNull(from))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  158:      from = mappedValue;
    #####:  159:    return from;
        -:  160:  }
        -:  161:
        -:  162:  // Otherwise, try to find the deepest value that has the desired type.
   408698:  163:  Value desiredValue;
  1244728:  164:  do {
   826713:  165:    if (from.getType() == desiredType)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   826713:  166:      desiredValue = from;
        -:  167:
   826713:  168:    Value mappedValue = mapping.lookupOrNull(from);
call    0 returned 100%
   826713:  169:    if (!mappedValue)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:  170:      break;
   418015:  171:    from = mappedValue;
        -:  172:  } while (true);
        -:  173:
        -:  174:  // If the desired value was found use it, otherwise default to the leaf value.
   408698:  175:  return desiredValue ? desiredValue : from;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  176:}
        -:  177:
function _ZNK12_GLOBAL__N_122ConversionValueMapping12lookupOrNullEN4mlir5ValueENS1_4TypeE called 408698 returned 100% blocks executed 86%
   408698:  178:Value ConversionValueMapping::lookupOrNull(Value from, Type desiredType) const {
   408698:  179:  Value result = lookupOrDefault(from, desiredType);
call    0 returned 100%
   408698:  180:  if (result == from || (desiredType && result.getType() != desiredType))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  181:    return nullptr;
   408698:  182:  return result;
        -:  183:}
        -:  184:
function _ZN12_GLOBAL__N_122ConversionValueMapping6tryMapEN4mlir5ValueES2_ called 0 returned 0% blocks executed 0%
    #####:  185:bool ConversionValueMapping::tryMap(Value oldVal, Value newVal) {
    #####:  186:  for (Value it = newVal; it; it = mapping.lookupOrNull(it))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  187:    if (it == oldVal)
branch  0 never executed
branch  1 never executed
    #####:  188:      return false;
    #####:  189:  map(oldVal, newVal);
    #####:  190:  return true;
call    0 never executed
        -:  191:}
        -:  192:
        -:  193://===----------------------------------------------------------------------===//
        -:  194:// Rewriter and Translation State
        -:  195://===----------------------------------------------------------------------===//
        -:  196:namespace {
        -:  197:/// This class contains a snapshot of the current conversion rewriter state.
        -:  198:/// This is useful when saving and undoing a set of rewrites.
        -:  199:struct RewriterState {
 29366800:  200:  RewriterState(unsigned numCreatedOps, unsigned numUnresolvedMaterializations,
        -:  201:                unsigned numReplacements, unsigned numArgReplacements,
        -:  202:                unsigned numBlockActions, unsigned numIgnoredOperations,
        -:  203:                unsigned numRootUpdates)
 29366800:  204:      : numCreatedOps(numCreatedOps),
        -:  205:        numUnresolvedMaterializations(numUnresolvedMaterializations),
        -:  206:        numReplacements(numReplacements),
        -:  207:        numArgReplacements(numArgReplacements),
        -:  208:        numBlockActions(numBlockActions),
        -:  209:        numIgnoredOperations(numIgnoredOperations),
 29366800:  210:        numRootUpdates(numRootUpdates) {}
        -:  211:
        -:  212:  /// The current number of created operations.
        -:  213:  unsigned numCreatedOps;
        -:  214:
        -:  215:  /// The current number of unresolved materializations.
        -:  216:  unsigned numUnresolvedMaterializations;
        -:  217:
        -:  218:  /// The current number of replacements queued.
        -:  219:  unsigned numReplacements;
        -:  220:
        -:  221:  /// The current number of argument replacements queued.
        -:  222:  unsigned numArgReplacements;
        -:  223:
        -:  224:  /// The current number of block actions performed.
        -:  225:  unsigned numBlockActions;
        -:  226:
        -:  227:  /// The current number of ignored operations.
        -:  228:  unsigned numIgnoredOperations;
        -:  229:
        -:  230:  /// The current number of operations that were updated in place.
        -:  231:  unsigned numRootUpdates;
        -:  232:};
        -:  233:
        -:  234://===----------------------------------------------------------------------===//
        -:  235:// OperationTransactionState
        -:  236:
        -:  237:/// The state of an operation that was updated by a pattern in-place. This
        -:  238:/// contains all of the necessary information to reconstruct an operation that
        -:  239:/// was updated in place.
        -:  240:class OperationTransactionState {
        -:  241:public:
    #####:  242:  OperationTransactionState() = default;
function _ZN12_GLOBAL__N_125OperationTransactionStateC2EPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  243:  OperationTransactionState(Operation *op)
    #####:  244:      : op(op), loc(op->getLoc()), attrs(op->getAttrDictionary()),
        -:  245:        operands(op->operand_begin(), op->operand_end()),
    #####:  246:        successors(op->successor_begin(), op->successor_end()) {}
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  247:
        -:  248:  /// Discard the transaction state and reset the state of the original
        -:  249:  /// operation.
function _ZNK12_GLOBAL__N_125OperationTransactionState14resetOperationEv called 0 returned 0% blocks executed 0%
    #####:  250:  void resetOperation() const {
    #####:  251:    op->setLoc(loc);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  252:    op->setAttrs(attrs);
branch  0 never executed
branch  1 never executed
    #####:  253:    op->setOperands(operands);
call    0 never executed
call    1 never executed
    #####:  254:    for (const auto &it : llvm::enumerate(successors))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  255:      op->setSuccessor(it.value(), it.index());
call    0 never executed
    #####:  256:  }
        -:  257:
        -:  258:  /// Return the original operation of this state.
        -:  259:  Operation *getOperation() const { return op; }
        -:  260:
        -:  261:private:
        -:  262:  Operation *op;
        -:  263:  LocationAttr loc;
        -:  264:  DictionaryAttr attrs;
        -:  265:  SmallVector<Value, 8> operands;
        -:  266:  SmallVector<Block *, 2> successors;
        -:  267:};
        -:  268:
        -:  269://===----------------------------------------------------------------------===//
        -:  270:// OpReplacement
        -:  271:
        -:  272:/// This class represents one requested operation replacement via 'replaceOp' or
        -:  273:/// 'eraseOp`.
        -:  274:struct OpReplacement {
   408698:  275:  OpReplacement(TypeConverter *converter = nullptr) : converter(converter) {}
        -:  276:
        -:  277:  /// An optional type converter that can be used to materialize conversions
        -:  278:  /// between the new and old values if necessary.
        -:  279:  TypeConverter *converter;
        -:  280:};
        -:  281:
        -:  282://===----------------------------------------------------------------------===//
        -:  283:// BlockAction
        -:  284:
        -:  285:/// The kind of the block action performed during the rewrite.  Actions can be
        -:  286:/// undone if the conversion fails.
        -:  287:enum class BlockActionKind {
        -:  288:  Create,
        -:  289:  Erase,
        -:  290:  Merge,
        -:  291:  Move,
        -:  292:  Split,
        -:  293:  TypeConversion
        -:  294:};
        -:  295:
        -:  296:/// Original position of the given block in its parent region. During undo
        -:  297:/// actions, the block needs to be placed after `insertAfterBlock`.
        -:  298:struct BlockPosition {
        -:  299:  Region *region;
        -:  300:  Block *insertAfterBlock;
        -:  301:};
        -:  302:
        -:  303:/// Information needed to undo the merge actions.
        -:  304:/// - the source block, and
        -:  305:/// - the Operation that was the last operation in the dest block before the
        -:  306:///   merge (could be null if the dest block was empty).
        -:  307:struct MergeInfo {
        -:  308:  Block *sourceBlock;
        -:  309:  Operation *destBlockLastInst;
        -:  310:};
        -:  311:
        -:  312:/// The storage class for an undoable block action (one of BlockActionKind),
        -:  313:/// contains the information necessary to undo this action.
        -:  314:struct BlockAction {
    #####:  315:  static BlockAction getCreate(Block *block) {
    #####:  316:    return {BlockActionKind::Create, block, {}};
        -:  317:  }
    #####:  318:  static BlockAction getErase(Block *block, BlockPosition originalPosition) {
    #####:  319:    return {BlockActionKind::Erase, block, {originalPosition}};
        -:  320:  }
    #####:  321:  static BlockAction getMerge(Block *block, Block *sourceBlock) {
    #####:  322:    BlockAction action{BlockActionKind::Merge, block, {}};
    #####:  323:    action.mergeInfo = {sourceBlock, block->empty() ? nullptr : &block->back()};
call    0 never executed
    #####:  324:    return action;
        -:  325:  }
    #####:  326:  static BlockAction getMove(Block *block, BlockPosition originalPosition) {
    #####:  327:    return {BlockActionKind::Move, block, {originalPosition}};
        -:  328:  }
    #####:  329:  static BlockAction getSplit(Block *block, Block *originalBlock) {
    #####:  330:    BlockAction action{BlockActionKind::Split, block, {}};
    #####:  331:    action.originalBlock = originalBlock;
    #####:  332:    return action;
        -:  333:  }
    #####:  334:  static BlockAction getTypeConversion(Block *block) {
    #####:  335:    return BlockAction{BlockActionKind::TypeConversion, block, {}};
        -:  336:  }
        -:  337:
        -:  338:  // The action kind.
        -:  339:  BlockActionKind kind;
        -:  340:
        -:  341:  // A pointer to the block that was created by the action.
        -:  342:  Block *block;
        -:  343:
        -:  344:  union {
        -:  345:    // In use if kind == BlockActionKind::Move or BlockActionKind::Erase, and
        -:  346:    // contains a pointer to the region that originally contained the block as
        -:  347:    // well as the position of the block in that region.
        -:  348:    BlockPosition originalPosition;
        -:  349:    // In use if kind == BlockActionKind::Split and contains a pointer to the
        -:  350:    // block that was split into two parts.
        -:  351:    Block *originalBlock;
        -:  352:    // In use if kind == BlockActionKind::Merge, and contains the information
        -:  353:    // needed to undo the merge.
        -:  354:    MergeInfo mergeInfo;
        -:  355:  };
        -:  356:};
        -:  357:
        -:  358://===----------------------------------------------------------------------===//
        -:  359:// UnresolvedMaterialization
        -:  360:
        -:  361:/// This class represents an unresolved materialization, i.e. a materialization
        -:  362:/// that was inserted during conversion that needs to be legalized at the end of
        -:  363:/// the conversion process.
        -:  364:class UnresolvedMaterialization {
        -:  365:public:
        -:  366:  /// The type of materialization.
        -:  367:  enum Kind {
        -:  368:    /// This materialization materializes a conversion for an illegal block
        -:  369:    /// argument type, to a legal one.
        -:  370:    Argument,
        -:  371:
        -:  372:    /// This materialization materializes a conversion from an illegal type to a
        -:  373:    /// legal one.
        -:  374:    Target
        -:  375:  };
        -:  376:
        -:  377:  UnresolvedMaterialization(UnrealizedConversionCastOp op = nullptr,
        -:  378:                            TypeConverter *converter = nullptr,
        -:  379:                            Kind kind = Target, Type origOutputType = nullptr)
        -:  380:      : op(op), converterAndKind(converter, kind),
        -:  381:        origOutputType(origOutputType) {}
        -:  382:
        -:  383:  /// Return the temporary conversion operation inserted for this
        -:  384:  /// materialization.
    #####:  385:  UnrealizedConversionCastOp getOp() const { return op; }
        -:  386:
        -:  387:  /// Return the type converter of this materialization (which may be null).
    #####:  388:  TypeConverter *getConverter() const { return converterAndKind.getPointer(); }
        -:  389:
        -:  390:  /// Return the kind of this materialization.
    #####:  391:  Kind getKind() const { return converterAndKind.getInt(); }
        -:  392:
        -:  393:  /// Set the kind of this materialization.
        -:  394:  void setKind(Kind kind) { converterAndKind.setInt(kind); }
        -:  395:
        -:  396:  /// Return the original illegal output type of the input values.
    #####:  397:  Type getOrigOutputType() const { return origOutputType; }
        -:  398:
        -:  399:private:
        -:  400:  /// The unresolved materialization operation created during conversion.
        -:  401:  UnrealizedConversionCastOp op;
        -:  402:
        -:  403:  /// The corresponding type converter to use when resolving this
        -:  404:  /// materialization, and the kind of this materialization.
        -:  405:  llvm::PointerIntPair<TypeConverter *, 1, Kind> converterAndKind;
        -:  406:
        -:  407:  /// The original output type. This is only used for argument conversions.
        -:  408:  Type origOutputType;
        -:  409:};
        -:  410:} // namespace
        -:  411:
        -:  412:/// Build an unresolved materialization operation given an output type and set
        -:  413:/// of input operands.
function _ZL30buildUnresolvedMaterializationN12_GLOBAL__N_125UnresolvedMaterialization4KindEPN4mlir5BlockEN4llvm14ilist_iteratorINS5_12ilist_detail12node_optionsINS2_9OperationELb1ELb0EvEELb0ELb0EEENS2_8LocationENS2_10ValueRangeENS2_4TypeESE_PNS2_13TypeConverterERNS5_15SmallVectorImplIS0_EE called 0 returned 0% blocks executed 0%
    #####:  414:static Value buildUnresolvedMaterialization(
        -:  415:    UnresolvedMaterialization::Kind kind, Block *insertBlock,
        -:  416:    Block::iterator insertPt, Location loc, ValueRange inputs, Type outputType,
        -:  417:    Type origOutputType, TypeConverter *converter,
        -:  418:    SmallVectorImpl<UnresolvedMaterialization> &unresolvedMaterializations) {
        -:  419:  // Avoid materializing an unnecessary cast.
    #####:  420:  if (inputs.size() == 1 && inputs.front().getType() == outputType)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  421:    return inputs.front();
call    0 never executed
        -:  422:
        -:  423:  // Create an unresolved materialization. We use a new OpBuilder to avoid
        -:  424:  // tracking the materialization like we do for other operations.
    #####:  425:  OpBuilder builder(insertBlock, insertPt);
call    0 never executed
    #####:  426:  auto convertOp =
    #####:  427:      builder.create<UnrealizedConversionCastOp>(loc, outputType, inputs);
call    0 never executed
    #####:  428:  unresolvedMaterializations.emplace_back(convertOp, converter, kind,
    #####:  429:                                          origOutputType);
call    0 never executed
    #####:  430:  return convertOp.getResult(0);
        -:  431:}
    #####:  432:static Value buildUnresolvedArgumentMaterialization(
        -:  433:    PatternRewriter &rewriter, Location loc, ValueRange inputs,
        -:  434:    Type origOutputType, Type outputType, TypeConverter *converter,
        -:  435:    SmallVectorImpl<UnresolvedMaterialization> &unresolvedMaterializations) {
    #####:  436:  return buildUnresolvedMaterialization(
        -:  437:      UnresolvedMaterialization::Argument, rewriter.getInsertionBlock(),
        -:  438:      rewriter.getInsertionPoint(), loc, inputs, outputType, origOutputType,
    #####:  439:      converter, unresolvedMaterializations);
call    0 never executed
        -:  440:}
function _ZL36buildUnresolvedTargetMaterializationN4mlir8LocationENS_5ValueENS_4TypeEPNS_13TypeConverterERN4llvm15SmallVectorImplIN12_GLOBAL__N_125UnresolvedMaterializationEEE called 0 returned 0% blocks executed 0%
    #####:  441:static Value buildUnresolvedTargetMaterialization(
        -:  442:    Location loc, Value input, Type outputType, TypeConverter *converter,
        -:  443:    SmallVectorImpl<UnresolvedMaterialization> &unresolvedMaterializations) {
    #####:  444:  Block *insertBlock = input.getParentBlock();
call    0 never executed
    #####:  445:  Block::iterator insertPt = insertBlock->begin();
call    0 never executed
    #####:  446:  if (OpResult inputRes = input.dyn_cast<OpResult>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  447:    insertPt = ++inputRes.getOwner()->getIterator();
call    0 never executed
        -:  448:
    #####:  449:  return buildUnresolvedMaterialization(
call    0 never executed
        -:  450:      UnresolvedMaterialization::Target, insertBlock, insertPt, loc, input,
    #####:  451:      outputType, outputType, converter, unresolvedMaterializations);
call    0 never executed
        -:  452:}
        -:  453:
        -:  454://===----------------------------------------------------------------------===//
        -:  455:// ArgConverter
        -:  456://===----------------------------------------------------------------------===//
        -:  457:namespace {
        -:  458:/// This class provides a simple interface for converting the types of block
        -:  459:/// arguments. This is done by creating a new block that contains the new legal
        -:  460:/// types and extracting the block that contains the old illegal types to allow
        -:  461:/// for undoing pending rewrites in the case of failure.
        -:  462:struct ArgConverter {
function _ZN12_GLOBAL__N_112ArgConverterC2ERN4mlir15PatternRewriterERN4llvm15SmallVectorImplINS_25UnresolvedMaterializationEEE called 35726 returned 100% blocks executed 100%
    35726:  463:  ArgConverter(
        -:  464:      PatternRewriter &rewriter,
        -:  465:      SmallVectorImpl<UnresolvedMaterialization> &unresolvedMaterializations)
    35726:  466:      : rewriter(rewriter),
    35726:  467:        unresolvedMaterializations(unresolvedMaterializations) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -:  468:
        -:  469:  /// This structure contains the information pertaining to an argument that has
        -:  470:  /// been converted.
        -:  471:  struct ConvertedArgInfo {
    #####:  472:    ConvertedArgInfo(unsigned newArgIdx, unsigned newArgSize,
        -:  473:                     Value castValue = nullptr)
        -:  474:        : newArgIdx(newArgIdx), newArgSize(newArgSize), castValue(castValue) {}
        -:  475:
        -:  476:    /// The start index of in the new argument list that contains arguments that
        -:  477:    /// replace the original.
        -:  478:    unsigned newArgIdx;
        -:  479:
        -:  480:    /// The number of arguments that replaced the original argument.
        -:  481:    unsigned newArgSize;
        -:  482:
        -:  483:    /// The cast value that was created to cast from the new arguments to the
        -:  484:    /// old. This only used if 'newArgSize' > 1.
        -:  485:    Value castValue;
        -:  486:  };
        -:  487:
        -:  488:  /// This structure contains information pertaining to a block that has had its
        -:  489:  /// signature converted.
    #####:  490:  struct ConvertedBlockInfo {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
call   16 never executed
branch 17 never executed
branch 18 never executed
    #####:  491:    ConvertedBlockInfo(Block *origBlock, TypeConverter *converter)
    #####:  492:        : origBlock(origBlock), converter(converter) {}
        -:  493:
        -:  494:    /// The original block that was requested to have its signature converted.
        -:  495:    Block *origBlock;
        -:  496:
        -:  497:    /// The conversion information for each of the arguments. The information is
        -:  498:    /// None if the argument was dropped during conversion.
        -:  499:    SmallVector<Optional<ConvertedArgInfo>, 1> argInfo;
        -:  500:
        -:  501:    /// The type converter used to convert the arguments.
        -:  502:    TypeConverter *converter;
        -:  503:  };
        -:  504:
        -:  505:  /// Return if the signature of the given block has already been converted.
function _ZNK12_GLOBAL__N_112ArgConverter16hasBeenConvertedEPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  506:  bool hasBeenConverted(Block *block) const {
    #####:  507:    return conversionInfo.count(block) || convertedBlocks.count(block);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  508:  }
        -:  509:
        -:  510:  /// Set the type converter to use for the given region.
function _ZN12_GLOBAL__N_112ArgConverter12setConverterEPN4mlir6RegionEPNS1_13TypeConverterE called 0 returned 0% blocks executed 0%
    #####:  511:  void setConverter(Region *region, TypeConverter *typeConverter) {
    #####:  512:    assert(typeConverter && "expected valid type converter");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  513:    regionToConverter[region] = typeConverter;
call    0 never executed
    #####:  514:  }
        -:  515:
        -:  516:  /// Return the type converter to use for the given region, or null if there
        -:  517:  /// isn't one.
        -:  518:  TypeConverter *getConverter(Region *region) {
        -:  519:    return regionToConverter.lookup(region);
        -:  520:  }
        -:  521:
        -:  522:  //===--------------------------------------------------------------------===//
        -:  523:  // Rewrite Application
        -:  524:  //===--------------------------------------------------------------------===//
        -:  525:
        -:  526:  /// Erase any rewrites registered for the blocks within the given operation
        -:  527:  /// which is about to be removed. This merely drops the rewrites without
        -:  528:  /// undoing them.
        -:  529:  void notifyOpRemoved(Operation *op);
        -:  530:
        -:  531:  /// Cleanup and undo any generated conversions for the arguments of block.
        -:  532:  /// This method replaces the new block with the original, reverting the IR to
        -:  533:  /// its original state.
        -:  534:  void discardRewrites(Block *block);
        -:  535:
        -:  536:  /// Fully replace uses of the old arguments with the new.
        -:  537:  void applyRewrites(ConversionValueMapping &mapping);
        -:  538:
        -:  539:  /// Materialize any necessary conversions for converted arguments that have
        -:  540:  /// live users, using the provided `findLiveUser` to search for a user that
        -:  541:  /// survives the conversion process.
        -:  542:  LogicalResult
        -:  543:  materializeLiveConversions(ConversionValueMapping &mapping,
        -:  544:                             OpBuilder &builder,
        -:  545:                             function_ref<Operation *(Value)> findLiveUser);
        -:  546:
        -:  547:  //===--------------------------------------------------------------------===//
        -:  548:  // Conversion
        -:  549:  //===--------------------------------------------------------------------===//
        -:  550:
        -:  551:  /// Attempt to convert the signature of the given block, if successful a new
        -:  552:  /// block is returned containing the new arguments. Returns `block` if it did
        -:  553:  /// not require conversion.
        -:  554:  FailureOr<Block *>
        -:  555:  convertSignature(Block *block, TypeConverter *converter,
        -:  556:                   ConversionValueMapping &mapping,
        -:  557:                   SmallVectorImpl<BlockArgument> &argReplacements);
        -:  558:
        -:  559:  /// Apply the given signature conversion on the given block. The new block
        -:  560:  /// containing the updated signature is returned. If no conversions were
        -:  561:  /// necessary, e.g. if the block has no arguments, `block` is returned.
        -:  562:  /// `converter` is used to generate any necessary cast operations that
        -:  563:  /// translate between the origin argument types and those specified in the
        -:  564:  /// signature conversion.
        -:  565:  Block *applySignatureConversion(
        -:  566:      Block *block, TypeConverter *converter,
        -:  567:      TypeConverter::SignatureConversion &signatureConversion,
        -:  568:      ConversionValueMapping &mapping,
        -:  569:      SmallVectorImpl<BlockArgument> &argReplacements);
        -:  570:
        -:  571:  /// Insert a new conversion into the cache.
        -:  572:  void insertConversion(Block *newBlock, ConvertedBlockInfo &&info);
        -:  573:
        -:  574:  /// A collection of blocks that have had their arguments converted. This is a
        -:  575:  /// map from the new replacement block, back to the original block.
        -:  576:  llvm::MapVector<Block *, ConvertedBlockInfo> conversionInfo;
        -:  577:
        -:  578:  /// The set of original blocks that were converted.
        -:  579:  DenseSet<Block *> convertedBlocks;
        -:  580:
        -:  581:  /// A mapping from valid regions, to those containing the original blocks of a
        -:  582:  /// conversion.
        -:  583:  DenseMap<Region *, std::unique_ptr<Region>> regionMapping;
        -:  584:
        -:  585:  /// A mapping of regions to type converters that should be used when
        -:  586:  /// converting the arguments of blocks within that region.
        -:  587:  DenseMap<Region *, TypeConverter *> regionToConverter;
        -:  588:
        -:  589:  /// The pattern rewriter to use when materializing conversions.
        -:  590:  PatternRewriter &rewriter;
        -:  591:
        -:  592:  /// An ordered set of unresolved materializations during conversion.
        -:  593:  SmallVectorImpl<UnresolvedMaterialization> &unresolvedMaterializations;
        -:  594:};
        -:  595:} // namespace
        -:  596:
        -:  597://===----------------------------------------------------------------------===//
        -:  598:// Rewrite Application
        -:  599:
function _ZN12_GLOBAL__N_112ArgConverter15notifyOpRemovedEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  600:void ArgConverter::notifyOpRemoved(Operation *op) {
    #####:  601:  if (conversionInfo.empty())
branch  0 never executed
branch  1 never executed
        -:  602:    return;
        -:  603:
    #####:  604:  for (Region &region : op->getRegions()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  605:    for (Block &block : region) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  606:      // Drop any rewrites from within.
    #####:  607:      for (Operation &nestedOp : block)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  608:        if (nestedOp.getNumRegions())
branch  0 never executed
branch  1 never executed
    #####:  609:          notifyOpRemoved(&nestedOp);
call    0 never executed
        -:  610:
        -:  611:      // Check if this block was converted.
    #####:  612:      auto it = conversionInfo.find(&block);
call    0 never executed
    #####:  613:      if (it == conversionInfo.end())
branch  0 never executed
branch  1 never executed
    #####:  614:        continue;
        -:  615:
        -:  616:      // Drop all uses of the original arguments and delete the original block.
    #####:  617:      Block *origBlock = it->second.origBlock;
    #####:  618:      for (BlockArgument arg : origBlock->getArguments())
branch  0 never executed
branch  1 never executed
    #####:  619:        arg.dropAllUses();
    #####:  620:      conversionInfo.erase(it);
call    0 never executed
        -:  621:    }
        -:  622:  }
        -:  623:}
        -:  624:
function _ZN12_GLOBAL__N_112ArgConverter15discardRewritesEPN4mlir5BlockE called 0 returned 0% blocks executed 0%
    #####:  625:void ArgConverter::discardRewrites(Block *block) {
    #####:  626:  auto it = conversionInfo.find(block);
call    0 never executed
    #####:  627:  if (it == conversionInfo.end())
branch  0 never executed
branch  1 never executed
    #####:  628:    return;
    #####:  629:  Block *origBlock = it->second.origBlock;
        -:  630:
        -:  631:  // Drop all uses of the new block arguments and replace uses of the new block.
    #####:  632:  for (int i = block->getNumArguments() - 1; i >= 0; --i)
branch  0 never executed
branch  1 never executed
    #####:  633:    block->getArgument(i).dropAllUses();
    #####:  634:  block->replaceAllUsesWith(origBlock);
call    0 never executed
        -:  635:
        -:  636:  // Move the operations back the original block and the delete the new block.
    #####:  637:  origBlock->getOperations().splice(origBlock->end(), block->getOperations());
call    0 never executed
    #####:  638:  origBlock->moveBefore(block);
call    0 never executed
    #####:  639:  block->erase();
call    0 never executed
        -:  640:
    #####:  641:  convertedBlocks.erase(origBlock);
call    0 never executed
    #####:  642:  conversionInfo.erase(it);
call    0 never executed
        -:  643:}
        -:  644:
function _ZN12_GLOBAL__N_112ArgConverter13applyRewritesERNS_22ConversionValueMappingE called 35199 returned 100% blocks executed 14%
    35199:  645:void ArgConverter::applyRewrites(ConversionValueMapping &mapping) {
   35199*:  646:  for (auto &info : conversionInfo) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:    ConvertedBlockInfo &blockInfo = info.second;
    #####:  648:    Block *origBlock = blockInfo.origBlock;
        -:  649:
        -:  650:    // Process the remapping for each of the original arguments.
    #####:  651:    for (unsigned i = 0, e = origBlock->getNumArguments(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  652:      Optional<ConvertedArgInfo> &argInfo = blockInfo.argInfo[i];
branch  0 never executed
branch  1 never executed
    #####:  653:      BlockArgument origArg = origBlock->getArgument(i);
branch  0 never executed
branch  1 never executed
        -:  654:
        -:  655:      // Handle the case of a 1->0 value mapping.
    #####:  656:      if (!argInfo) {
branch  0 never executed
branch  1 never executed
    #####:  657:        if (Value newArg = mapping.lookupOrNull(origArg, origArg.getType()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  658:          origArg.replaceAllUsesWith(newArg);
call    0 never executed
    #####:  659:        continue;
        -:  660:      }
        -:  661:
        -:  662:      // Otherwise this is a 1->1+ value mapping.
    #####:  663:      Value castValue = argInfo->castValue;
branch  0 never executed
branch  1 never executed
    #####:  664:      assert(argInfo->newArgSize >= 1 && castValue && "expected 1->1+ mapping");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  665:
        -:  666:      // If the argument is still used, replace it with the generated cast.
    #####:  667:      if (!origArg.use_empty()) {
branch  0 never executed
branch  1 never executed
    #####:  668:        origArg.replaceAllUsesWith(
call    0 never executed
call    1 never executed
        -:  669:            mapping.lookupOrDefault(castValue, origArg.getType()));
        -:  670:      }
        -:  671:    }
        -:  672:  }
    35199:  673:}
        -:  674:
        -:  675:LogicalResult ArgConverter::materializeLiveConversions(
        -:  676:    ConversionValueMapping &mapping, OpBuilder &builder,
        -:  677:    function_ref<Operation *(Value)> findLiveUser) {
        -:  678:  for (auto &info : conversionInfo) {
        -:  679:    Block *newBlock = info.first;
        -:  680:    ConvertedBlockInfo &blockInfo = info.second;
        -:  681:    Block *origBlock = blockInfo.origBlock;
        -:  682:
        -:  683:    // Process the remapping for each of the original arguments.
        -:  684:    for (unsigned i = 0, e = origBlock->getNumArguments(); i != e; ++i) {
        -:  685:      // If the type of this argument changed and the argument is still live, we
        -:  686:      // need to materialize a conversion.
        -:  687:      BlockArgument origArg = origBlock->getArgument(i);
        -:  688:      if (mapping.lookupOrNull(origArg, origArg.getType()))
        -:  689:        continue;
        -:  690:      Operation *liveUser = findLiveUser(origArg);
        -:  691:      if (!liveUser)
        -:  692:        continue;
        -:  693:
        -:  694:      Value replacementValue = mapping.lookupOrDefault(origArg);
        -:  695:      bool isDroppedArg = replacementValue == origArg;
        -:  696:      if (isDroppedArg)
        -:  697:        rewriter.setInsertionPointToStart(newBlock);
        -:  698:      else
        -:  699:        rewriter.setInsertionPointAfterValue(replacementValue);
        -:  700:      Value newArg;
        -:  701:      if (blockInfo.converter) {
        -:  702:        newArg = blockInfo.converter->materializeSourceConversion(
        -:  703:            rewriter, origArg.getLoc(), origArg.getType(),
        -:  704:            isDroppedArg ? ValueRange() : ValueRange(replacementValue));
        -:  705:        assert((!newArg || newArg.getType() == origArg.getType()) &&
        -:  706:               "materialization hook did not provide a value of the expected "
        -:  707:               "type");
        -:  708:      }
        -:  709:      if (!newArg) {
        -:  710:        InFlightDiagnostic diag =
        -:  711:            emitError(origArg.getLoc())
        -:  712:            << "failed to materialize conversion for block argument #" << i
        -:  713:            << " that remained live after conversion, type was "
        -:  714:            << origArg.getType();
        -:  715:        if (!isDroppedArg)
        -:  716:          diag << ", with target type " << replacementValue.getType();
        -:  717:        diag.attachNote(liveUser->getLoc())
        -:  718:            << "see existing live user here: " << *liveUser;
        -:  719:        return failure();
        -:  720:      }
        -:  721:      mapping.map(origArg, newArg);
        -:  722:    }
        -:  723:  }
        -:  724:  return success();
        -:  725:}
        -:  726:
        -:  727://===----------------------------------------------------------------------===//
        -:  728:// Conversion
        -:  729:
function _ZN12_GLOBAL__N_112ArgConverter16convertSignatureEPN4mlir5BlockEPNS1_13TypeConverterERNS_22ConversionValueMappingERN4llvm15SmallVectorImplINS1_13BlockArgumentEEE called 0 returned 0% blocks executed 0%
    #####:  730:FailureOr<Block *> ArgConverter::convertSignature(
        -:  731:    Block *block, TypeConverter *converter, ConversionValueMapping &mapping,
        -:  732:    SmallVectorImpl<BlockArgument> &argReplacements) {
        -:  733:  // Check if the block was already converted. If the block is detached,
        -:  734:  // conservatively assume it is going to be deleted.
    #####:  735:  if (hasBeenConverted(block) || !block->getParent())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  736:    return block;
        -:  737:  // If a converter wasn't provided, and the block wasn't already converted,
        -:  738:  // there is nothing we can do.
    #####:  739:  if (!converter)
branch  0 never executed
branch  1 never executed
    #####:  740:    return failure();
        -:  741:
        -:  742:  // Try to convert the signature for the block with the provided converter.
    #####:  743:  if (auto conversion = converter->convertBlockSignature(block))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  744:    return applySignatureConversion(block, converter, *conversion, mapping,
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  745:                                    argReplacements);
branch  0 never executed
branch  1 never executed
    #####:  746:  return failure();
        -:  747:}
        -:  748:
function _ZN12_GLOBAL__N_112ArgConverter24applySignatureConversionEPN4mlir5BlockEPNS1_13TypeConverterERNS4_19SignatureConversionERNS_22ConversionValueMappingERN4llvm15SmallVectorImplINS1_13BlockArgumentEEE called 0 returned 0% blocks executed 0%
    #####:  749:Block *ArgConverter::applySignatureConversion(
        -:  750:    Block *block, TypeConverter *converter,
        -:  751:    TypeConverter::SignatureConversion &signatureConversion,
        -:  752:    ConversionValueMapping &mapping,
        -:  753:    SmallVectorImpl<BlockArgument> &argReplacements) {
        -:  754:  // If no arguments are being changed or added, there is nothing to do.
    #####:  755:  unsigned origArgCount = block->getNumArguments();
branch  0 never executed
branch  1 never executed
    #####:  756:  auto convertedTypes = signatureConversion.getConvertedTypes();
branch  0 never executed
branch  1 never executed
    #####:  757:  if (origArgCount == 0 && convertedTypes.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  758:    return block;
        -:  759:
        -:  760:  // Split the block at the beginning to get a new block to use for the updated
        -:  761:  // signature.
    #####:  762:  Block *newBlock = block->splitBlock(block->begin());
call    0 never executed
    #####:  763:  block->replaceAllUsesWith(newBlock);
call    0 never executed
        -:  764:
        -:  765:  // FIXME: We should map the new arguments to proper locations.
    #####:  766:  SmallVector<Location> newLocs(convertedTypes.size(),
    #####:  767:                                rewriter.getUnknownLoc());
call    0 never executed
call    1 never executed
    #####:  768:  SmallVector<Value, 4> newArgRange(
    #####:  769:      newBlock->addArguments(convertedTypes, newLocs));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  770:  ArrayRef<Value> newArgs(newArgRange);
call    0 never executed
        -:  771:
        -:  772:  // Remap each of the original arguments as determined by the signature
        -:  773:  // conversion.
    #####:  774:  ConvertedBlockInfo info(block, converter);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  775:  info.argInfo.resize(origArgCount);
call    0 never executed
        -:  776:
    #####:  777:  OpBuilder::InsertionGuard guard(rewriter);
branch  0 never executed
branch  1 never executed
    #####:  778:  rewriter.setInsertionPointToStart(newBlock);
    #####:  779:  for (unsigned i = 0; i != origArgCount; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  780:    auto inputMap = signatureConversion.getInputMapping(i);
call    0 never executed
    #####:  781:    if (!inputMap)
branch  0 never executed
branch  1 never executed
    #####:  782:      continue;
    #####:  783:    BlockArgument origArg = block->getArgument(i);
branch  0 never executed
branch  1 never executed
        -:  784:
        -:  785:    // If inputMap->replacementValue is not nullptr, then the argument is
        -:  786:    // dropped and a replacement value is provided to be the remappedValue.
    #####:  787:    if (inputMap->replacementValue) {
branch  0 never executed
branch  1 never executed
    #####:  788:      assert(inputMap->size == 0 &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  789:             "invalid to provide a replacement value when the argument isn't "
        -:  790:             "dropped");
    #####:  791:      mapping.map(origArg, inputMap->replacementValue);
call    0 never executed
    #####:  792:      argReplacements.push_back(origArg);
call    0 never executed
    #####:  793:      continue;
        -:  794:    }
        -:  795:
        -:  796:    // Otherwise, this is a 1->1+ mapping.
    #####:  797:    auto replArgs = newArgs.slice(inputMap->inputNo, inputMap->size);
call    0 never executed
    #####:  798:    Value newArg;
        -:  799:
        -:  800:    // If this is a 1->1 mapping and the types of new and replacement arguments
        -:  801:    // match (i.e. it's an identity map), then the argument is mapped to its
        -:  802:    // original type.
        -:  803:    // FIXME: We simply pass through the replacement argument if there wasn't a
        -:  804:    // converter, which isn't great as it allows implicit type conversions to
        -:  805:    // appear. We should properly restructure this code to handle cases where a
        -:  806:    // converter isn't provided and also to properly handle the case where an
        -:  807:    // argument materialization is actually a temporary source materialization
        -:  808:    // (e.g. in the case of 1->N).
    #####:  809:    if (replArgs.size() == 1 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  810:        (!converter || replArgs[0].getType() == origArg.getType())) {
branch  0 never executed
branch  1 never executed
    #####:  811:      newArg = replArgs.front();
        -:  812:    } else {
    #####:  813:      Type origOutputType = origArg.getType();
call    0 never executed
        -:  814:
        -:  815:      // Legalize the argument output type.
    #####:  816:      Type outputType = origOutputType;
    #####:  817:      if (Type legalOutputType = converter->convertType(outputType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  818:        outputType = legalOutputType;
        -:  819:
    #####:  820:      newArg = buildUnresolvedArgumentMaterialization(
        -:  821:          rewriter, origArg.getLoc(), replArgs, origOutputType, outputType,
    #####:  822:          converter, unresolvedMaterializations);
call    0 never executed
call    1 never executed
        -:  823:    }
        -:  824:
    #####:  825:    mapping.map(origArg, newArg);
call    0 never executed
    #####:  826:    argReplacements.push_back(origArg);
call    0 never executed
    #####:  827:    info.argInfo[i] =
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  828:        ConvertedArgInfo(inputMap->inputNo, inputMap->size, newArg);
branch  0 never executed
branch  1 never executed
        -:  829:  }
        -:  830:
        -:  831:  // Remove the original block from the region and return the new one.
    #####:  832:  insertConversion(newBlock, std::move(info));
call    0 never executed
    #####:  833:  return newBlock;
branch  0 never executed
branch  1 never executed
        -:  834:}
        -:  835:
function _ZN12_GLOBAL__N_112ArgConverter16insertConversionEPN4mlir5BlockEONS0_18ConvertedBlockInfoE called 0 returned 0% blocks executed 0%
    #####:  836:void ArgConverter::insertConversion(Block *newBlock,
        -:  837:                                    ConvertedBlockInfo &&info) {
        -:  838:  // Get a region to insert the old block.
    #####:  839:  Region *region = newBlock->getParent();
call    0 never executed
    #####:  840:  std::unique_ptr<Region> &mappedRegion = regionMapping[region];
call    0 never executed
    #####:  841:  if (!mappedRegion)
branch  0 never executed
branch  1 never executed
    #####:  842:    mappedRegion = std::make_unique<Region>(region->getParentOp());
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  843:
        -:  844:  // Move the original block to the mapped region and emplace the conversion.
    #####:  845:  mappedRegion->getBlocks().splice(mappedRegion->end(), region->getBlocks(),
branch  0 never executed
branch  1 never executed
    #####:  846:                                   info.origBlock->getIterator());
branch  0 never executed
branch  1 never executed
    #####:  847:  convertedBlocks.insert(info.origBlock);
call    0 never executed
    #####:  848:  conversionInfo.insert({newBlock, std::move(info)});
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  849:}
        -:  850:
        -:  851://===----------------------------------------------------------------------===//
        -:  852:// ConversionPatternRewriterImpl
        -:  853://===----------------------------------------------------------------------===//
        -:  854:namespace mlir {
        -:  855:namespace detail {
        -:  856:struct ConversionPatternRewriterImpl {
function _ZN4mlir6detail29ConversionPatternRewriterImplC2ERNS_15PatternRewriterE called 35726 returned 100% blocks executed 100%
    35726:  857:  explicit ConversionPatternRewriterImpl(PatternRewriter &rewriter)
    35726:  858:      : argConverter(rewriter, unresolvedMaterializations),
    35726:  859:        notifyCallback(nullptr) {}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  860:
        -:  861:  /// Cleanup and destroy any generated rewrite operations. This method is
        -:  862:  /// invoked when the conversion process fails.
        -:  863:  void discardRewrites();
        -:  864:
        -:  865:  /// Apply all requested operation rewrites. This method is invoked when the
        -:  866:  /// conversion process succeeds.
        -:  867:  void applyRewrites();
        -:  868:
        -:  869:  //===--------------------------------------------------------------------===//
        -:  870:  // State Management
        -:  871:  //===--------------------------------------------------------------------===//
        -:  872:
        -:  873:  /// Return the current state of the rewriter.
        -:  874:  RewriterState getCurrentState();
        -:  875:
        -:  876:  /// Reset the state of the rewriter to a previously saved point.
        -:  877:  void resetState(RewriterState state);
        -:  878:
        -:  879:  /// Erase any blocks that were unlinked from their regions and stored in block
        -:  880:  /// actions.
        -:  881:  void eraseDanglingBlocks();
        -:  882:
        -:  883:  /// Undo the block actions (motions, splits) one by one in reverse order until
        -:  884:  /// "numActionsToKeep" actions remains.
        -:  885:  void undoBlockActions(unsigned numActionsToKeep = 0);
        -:  886:
        -:  887:  /// Remap the given values to those with potentially different types. Returns
        -:  888:  /// success if the values could be remapped, failure otherwise. `valueDiagTag`
        -:  889:  /// is the tag used when describing a value within a diagnostic, e.g.
        -:  890:  /// "operand".
        -:  891:  LogicalResult remapValues(StringRef valueDiagTag, Optional<Location> inputLoc,
        -:  892:                            PatternRewriter &rewriter, ValueRange values,
        -:  893:                            SmallVectorImpl<Value> &remapped);
        -:  894:
        -:  895:  /// Returns true if the given operation is ignored, and does not need to be
        -:  896:  /// converted.
        -:  897:  bool isOpIgnored(Operation *op) const;
        -:  898:
        -:  899:  /// Recursively marks the nested operations under 'op' as ignored. This
        -:  900:  /// removes them from being considered for legalization.
        -:  901:  void markNestedOpsIgnored(Operation *op);
        -:  902:
        -:  903:  //===--------------------------------------------------------------------===//
        -:  904:  // Type Conversion
        -:  905:  //===--------------------------------------------------------------------===//
        -:  906:
        -:  907:  /// Convert the signature of the given block.
        -:  908:  FailureOr<Block *> convertBlockSignature(
        -:  909:      Block *block, TypeConverter *converter,
        -:  910:      TypeConverter::SignatureConversion *conversion = nullptr);
        -:  911:
        -:  912:  /// Apply a signature conversion on the given region, using `converter` for
        -:  913:  /// materializations if not null.
        -:  914:  Block *
        -:  915:  applySignatureConversion(Region *region,
        -:  916:                           TypeConverter::SignatureConversion &conversion,
        -:  917:                           TypeConverter *converter);
        -:  918:
        -:  919:  /// Convert the types of block arguments within the given region.
        -:  920:  FailureOr<Block *>
        -:  921:  convertRegionTypes(Region *region, TypeConverter &converter,
        -:  922:                     TypeConverter::SignatureConversion *entryConversion);
        -:  923:
        -:  924:  /// Convert the types of non-entry block arguments within the given region.
        -:  925:  LogicalResult convertNonEntryRegionTypes(
        -:  926:      Region *region, TypeConverter &converter,
        -:  927:      ArrayRef<TypeConverter::SignatureConversion> blockConversions = {});
        -:  928:
        -:  929:  //===--------------------------------------------------------------------===//
        -:  930:  // Rewriter Notification Hooks
        -:  931:  //===--------------------------------------------------------------------===//
        -:  932:
        -:  933:  /// PatternRewriter hook for replacing the results of an operation.
        -:  934:  void notifyOpReplaced(Operation *op, ValueRange newValues);
        -:  935:
        -:  936:  /// Notifies that a block is about to be erased.
        -:  937:  void notifyBlockIsBeingErased(Block *block);
        -:  938:
        -:  939:  /// Notifies that a block was created.
        -:  940:  void notifyCreatedBlock(Block *block);
        -:  941:
        -:  942:  /// Notifies that a block was split.
        -:  943:  void notifySplitBlock(Block *block, Block *continuation);
        -:  944:
        -:  945:  /// Notifies that `block` is being merged with `srcBlock`.
        -:  946:  void notifyBlocksBeingMerged(Block *block, Block *srcBlock);
        -:  947:
        -:  948:  /// Notifies that the blocks of a region are about to be moved.
        -:  949:  void notifyRegionIsBeingInlinedBefore(Region &region, Region &parent,
        -:  950:                                        Region::iterator before);
        -:  951:
        -:  952:  /// Notifies that the blocks of a region were cloned into another.
        -:  953:  void notifyRegionWasClonedBefore(iterator_range<Region::iterator> &blocks,
        -:  954:                                   Location origRegionLoc);
        -:  955:
        -:  956:  /// Notifies that a pattern match failed for the given reason.
        -:  957:  LogicalResult
        -:  958:  notifyMatchFailure(Location loc,
        -:  959:                     function_ref<void(Diagnostic &)> reasonCallback);
        -:  960:
        -:  961:  //===--------------------------------------------------------------------===//
        -:  962:  // State
        -:  963:  //===--------------------------------------------------------------------===//
        -:  964:
        -:  965:  // Mapping between replaced values that differ in type. This happens when
        -:  966:  // replacing a value with one of a different type.
        -:  967:  ConversionValueMapping mapping;
        -:  968:
        -:  969:  /// Utility used to convert block arguments.
        -:  970:  ArgConverter argConverter;
        -:  971:
        -:  972:  /// Ordered vector of all of the newly created operations during conversion.
        -:  973:  SmallVector<Operation *> createdOps;
        -:  974:
        -:  975:  /// Ordered vector of all unresolved type conversion materializations during
        -:  976:  /// conversion.
        -:  977:  SmallVector<UnresolvedMaterialization> unresolvedMaterializations;
        -:  978:
        -:  979:  /// Ordered map of requested operation replacements.
        -:  980:  llvm::MapVector<Operation *, OpReplacement> replacements;
        -:  981:
        -:  982:  /// Ordered vector of any requested block argument replacements.
        -:  983:  SmallVector<BlockArgument, 4> argReplacements;
        -:  984:
        -:  985:  /// Ordered list of block operations (creations, splits, motions).
        -:  986:  SmallVector<BlockAction, 4> blockActions;
        -:  987:
        -:  988:  /// A set of operations that should no longer be considered for legalization,
        -:  989:  /// but were not directly replace/erased/etc. by a pattern. These are
        -:  990:  /// generally child operations of other operations who were
        -:  991:  /// replaced/erased/etc. This is not meant to be an exhaustive list of all
        -:  992:  /// operations, but the minimal set that can be used to detect if a given
        -:  993:  /// operation should be `ignored`. For example, we may add the operations that
        -:  994:  /// define non-empty regions to the set, but not any of the others. This
        -:  995:  /// simplifies the amount of memory needed as we can query if the parent
        -:  996:  /// operation was ignored.
        -:  997:  SetVector<Operation *> ignoredOps;
        -:  998:
        -:  999:  /// A transaction state for each of operations that were updated in-place.
        -: 1000:  SmallVector<OperationTransactionState, 4> rootUpdates;
        -: 1001:
        -: 1002:  /// A vector of indices into `replacements` of operations that were replaced
        -: 1003:  /// with values with different result types than the original operation, e.g.
        -: 1004:  /// 1->N conversion of some kind.
        -: 1005:  SmallVector<unsigned, 4> operationsWithChangedResults;
        -: 1006:
        -: 1007:  /// The current type converter, or nullptr if no type converter is currently
        -: 1008:  /// active.
        -: 1009:  TypeConverter *currentTypeConverter = nullptr;
        -: 1010:
        -: 1011:  /// This allows the user to collect the match failure message.
        -: 1012:  function_ref<void(Diagnostic &)> notifyCallback;
        -: 1013:
        -: 1014:#ifndef NDEBUG
        -: 1015:  /// A set of operations that have pending updates. This tracking isn't
        -: 1016:  /// strictly necessary, and is thus only active during debug builds for extra
        -: 1017:  /// verification.
        -: 1018:  SmallPtrSet<Operation *, 1> pendingRootUpdates;
        -: 1019:
        -: 1020:  /// A logger used to emit diagnostics during the conversion process.
        -: 1021:  llvm::ScopedPrinter logger{llvm::dbgs()};
        -: 1022:#endif
        -: 1023:};
        -: 1024:} // namespace detail
        -: 1025:} // namespace mlir
        -: 1026:
        -: 1027:/// Detach any operations nested in the given operation from their parent
        -: 1028:/// blocks, and erase the given operation. This can be used when the nested
        -: 1029:/// operations are scheduled for erasure themselves, so deleting the regions of
        -: 1030:/// the given operation together with their content would result in double-free.
        -: 1031:/// This happens, for example, when rolling back op creation in the reverse
        -: 1032:/// order and if the nested ops were created before the parent op. This function
        -: 1033:/// does not need to collect nested ops recursively because it is expected to
        -: 1034:/// also be called for each nested op when it is about to be deleted.
function _ZL20detachNestedAndErasePN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####: 1035:static void detachNestedAndErase(Operation *op) {
    #####: 1036:  for (Region &region : op->getRegions()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1037:    for (Block &block : region.getBlocks()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1038:      while (!block.getOperations().empty())
branch  0 never executed
branch  1 never executed
    #####: 1039:        block.getOperations().remove(block.getOperations().begin());
call    0 never executed
    #####: 1040:      block.dropAllDefinedValueUses();
call    0 never executed
        -: 1041:    }
        -: 1042:  }
    #####: 1043:  op->dropAllUses();
call    0 never executed
    #####: 1044:  op->erase();
call    0 never executed
    #####: 1045:}
        -: 1046:
function _ZN4mlir6detail29ConversionPatternRewriterImpl15discardRewritesEv called 527 returned 100% blocks executed 57%
      527: 1047:void ConversionPatternRewriterImpl::discardRewrites() {
        -: 1048:  // Reset any operations that were updated in place.
     527*: 1049:  for (auto &state : rootUpdates)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1050:    state.resetOperation();
call    0 never executed
        -: 1051:
      527: 1052:  undoBlockActions();
call    0 returned 100%
        -: 1053:
        -: 1054:  // Remove any newly created ops.
     527*: 1055:  for (UnresolvedMaterialization &materialization : unresolvedMaterializations)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1056:    detachNestedAndErase(materialization.getOp());
call    0 never executed
     527*: 1057:  for (auto *op : llvm::reverse(createdOps))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    #####: 1058:    detachNestedAndErase(op);
call    0 never executed
      527: 1059:}
        -: 1060:
function _ZN4mlir6detail29ConversionPatternRewriterImpl13applyRewritesEv called 35199 returned 100% blocks executed 60%
    35199: 1061:void ConversionPatternRewriterImpl::applyRewrites() {
        -: 1062:  // Apply all of the rewrites replacements requested during conversion.
   443897: 1063:  for (auto &repl : replacements) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
  1226094: 1064:    for (OpResult result : repl.first->getResults())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
call    4 returned 100%
   408698: 1065:      if (Value newValue = mapping.lookupOrNull(result, result.getType()))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   408698: 1066:        result.replaceAllUsesWith(newValue);
call    0 returned 100%
        -: 1067:
        -: 1068:    // If this operation defines any regions, drop any pending argument
        -: 1069:    // rewrites.
   408698: 1070:    if (repl.first->getNumRegions())
branch  0 taken 0%
branch  1 taken 100%
    #####: 1071:      argConverter.notifyOpRemoved(repl.first);
call    0 never executed
        -: 1072:  }
        -: 1073:
        -: 1074:  // Apply all of the requested argument replacements.
   35199*: 1075:  for (BlockArgument arg : argReplacements) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1076:    Value repl = mapping.lookupOrNull(arg, arg.getType());
call    0 never executed
    #####: 1077:    if (!repl)
branch  0 never executed
branch  1 never executed
    #####: 1078:      continue;
        -: 1079:
    #####: 1080:    if (repl.isa<BlockArgument>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1081:      arg.replaceAllUsesWith(repl);
call    0 never executed
    #####: 1082:      continue;
        -: 1083:    }
        -: 1084:
        -: 1085:    // If the replacement value is an operation, we check to make sure that we
        -: 1086:    // don't replace uses that are within the parent operation of the
        -: 1087:    // replacement value.
    #####: 1088:    Operation *replOp = repl.cast<OpResult>().getOwner();
call    0 never executed
call    1 never executed
    #####: 1089:    Block *replBlock = replOp->getBlock();
call    0 never executed
    #####: 1090:    arg.replaceUsesWithIf(repl, [&](OpOperand &operand) {
call    0 never executed
    #####: 1091:      Operation *user = operand.getOwner();
branch  0 never executed
branch  1 never executed
    #####: 1092:      return user->getBlock() != replBlock || replOp->isBeforeInBlock(user);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1093:    });
        -: 1094:  }
        -: 1095:
        -: 1096:  // Drop all of the unresolved materialization operations created during
        -: 1097:  // conversion.
   35199*: 1098:  for (auto &mat : unresolvedMaterializations) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1099:    mat.getOp()->dropAllUses();
call    0 never executed
    #####: 1100:    mat.getOp()->erase();
call    0 never executed
        -: 1101:  }
        -: 1102:
        -: 1103:  // In a second pass, erase all of the replaced operations in reverse. This
        -: 1104:  // allows processing nested operations before their parent region is
        -: 1105:  // destroyed. Because we process in reverse order, producers may be deleted
        -: 1106:  // before their users (a pattern deleting a producer and then the consumer)
        -: 1107:  // so we first drop all uses explicitly.
   443897: 1108:  for (auto &repl : llvm::reverse(replacements)) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
   408698: 1109:    repl.first->dropAllUses();
call    0 returned 100%
   408698: 1110:    repl.first->erase();
call    0 returned 100%
        -: 1111:  }
        -: 1112:
    35199: 1113:  argConverter.applyRewrites(mapping);
call    0 returned 100%
        -: 1114:
        -: 1115:  // Now that the ops have been erased, also erase dangling blocks.
    35199: 1116:  eraseDanglingBlocks();
call    0 returned 100%
    35199: 1117:}
        -: 1118:
        -: 1119://===----------------------------------------------------------------------===//
        -: 1120:// State Management
        -: 1121:
 29366800: 1122:RewriterState ConversionPatternRewriterImpl::getCurrentState() {
 29366800: 1123:  return RewriterState(createdOps.size(), unresolvedMaterializations.size(),
 29366800: 1124:                       replacements.size(), argReplacements.size(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 29366800: 1125:                       blockActions.size(), ignoredOps.size(),
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 29366800: 1126:                       rootUpdates.size());
        -: 1127:}
        -: 1128:
function _ZN4mlir6detail29ConversionPatternRewriterImpl10resetStateEN12_GLOBAL__N_113RewriterStateE called 0 returned 0% blocks executed 0%
    #####: 1129:void ConversionPatternRewriterImpl::resetState(RewriterState state) {
        -: 1130:  // Reset any operations that were updated in place.
    #####: 1131:  for (unsigned i = state.numRootUpdates, e = rootUpdates.size(); i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1132:    rootUpdates[i].resetOperation();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1133:  rootUpdates.resize(state.numRootUpdates);
call    0 never executed
        -: 1134:
        -: 1135:  // Reset any replaced arguments.
    #####: 1136:  for (BlockArgument replacedArg :
    #####: 1137:       llvm::drop_begin(argReplacements, state.numArgReplacements))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1138:    mapping.erase(replacedArg);
call    0 never executed
    #####: 1139:  argReplacements.resize(state.numArgReplacements);
call    0 never executed
        -: 1140:
        -: 1141:  // Undo any block actions.
    #####: 1142:  undoBlockActions(state.numBlockActions);
call    0 never executed
        -: 1143:
        -: 1144:  // Reset any replaced operations and undo any saved mappings.
    #####: 1145:  for (auto &repl : llvm::drop_begin(replacements, state.numReplacements))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1146:    for (auto result : repl.first->getResults())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1147:      mapping.erase(result);
call    0 never executed
    #####: 1148:  while (replacements.size() != state.numReplacements)
branch  0 never executed
branch  1 never executed
    #####: 1149:    replacements.pop_back();
call    0 never executed
        -: 1150:
        -: 1151:  // Pop all of the newly inserted materializations.
    #####: 1152:  while (unresolvedMaterializations.size() !=
branch  0 never executed
branch  1 never executed
    #####: 1153:         state.numUnresolvedMaterializations) {
branch  0 never executed
branch  1 never executed
    #####: 1154:    UnresolvedMaterialization mat = unresolvedMaterializations.pop_back_val();
call    0 never executed
    #####: 1155:    UnrealizedConversionCastOp op = mat.getOp();
        -: 1156:
        -: 1157:    // If this was a target materialization, drop the mapping that was inserted.
    #####: 1158:    if (mat.getKind() == UnresolvedMaterialization::Target) {
branch  0 never executed
branch  1 never executed
    #####: 1159:      for (Value input : op->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1160:        mapping.erase(input);
call    0 never executed
        -: 1161:    }
    #####: 1162:    detachNestedAndErase(op);
call    0 never executed
        -: 1163:  }
        -: 1164:
        -: 1165:  // Pop all of the newly created operations.
    #####: 1166:  while (createdOps.size() != state.numCreatedOps) {
branch  0 never executed
branch  1 never executed
    #####: 1167:    detachNestedAndErase(createdOps.back());
call    0 never executed
call    1 never executed
    #####: 1168:    createdOps.pop_back();
call    0 never executed
        -: 1169:  }
        -: 1170:
        -: 1171:  // Pop all of the recorded ignored operations that are no longer valid.
    #####: 1172:  while (ignoredOps.size() != state.numIgnoredOperations)
branch  0 never executed
branch  1 never executed
    #####: 1173:    ignoredOps.pop_back();
call    0 never executed
        -: 1174:
        -: 1175:  // Reset operations with changed results.
    #####: 1176:  while (!operationsWithChangedResults.empty() &&
branch  0 never executed
branch  1 never executed
    #####: 1177:         operationsWithChangedResults.back() >= state.numReplacements)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1178:    operationsWithChangedResults.pop_back();
    #####: 1179:}
        -: 1180:
function _ZN4mlir6detail29ConversionPatternRewriterImpl19eraseDanglingBlocksEv called 35199 returned 100% blocks executed 38%
    35199: 1181:void ConversionPatternRewriterImpl::eraseDanglingBlocks() {
   35199*: 1182:  for (auto &action : blockActions)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1183:    if (action.kind == BlockActionKind::Erase)
branch  0 never executed
branch  1 never executed
    #####: 1184:      delete action.block;
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    35199: 1185:}
        -: 1186:
function _ZN4mlir6detail29ConversionPatternRewriterImpl16undoBlockActionsEj called 527 returned 100% blocks executed 13%
      527: 1187:void ConversionPatternRewriterImpl::undoBlockActions(
        -: 1188:    unsigned numActionsToKeep) {
    #####: 1189:  for (auto &action :
    1054*: 1190:       llvm::reverse(llvm::drop_begin(blockActions, numActionsToKeep))) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1191:    switch (action.kind) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -: 1192:    // Delete the created block.
    #####: 1193:    case BlockActionKind::Create: {
        -: 1194:      // Unlink all of the operations within this block, they will be deleted
        -: 1195:      // separately.
    #####: 1196:      auto &blockOps = action.block->getOperations();
    #####: 1197:      while (!blockOps.empty())
branch  0 never executed
branch  1 never executed
    #####: 1198:        blockOps.remove(blockOps.begin());
call    0 never executed
    #####: 1199:      action.block->dropAllDefinedValueUses();
call    0 never executed
    #####: 1200:      action.block->erase();
    #####: 1201:      break;
call    0 never executed
        -: 1202:    }
        -: 1203:    // Put the block (owned by action) back into its original position.
    #####: 1204:    case BlockActionKind::Erase: {
    #####: 1205:      auto &blockList = action.originalPosition.region->getBlocks();
branch  0 never executed
branch  1 never executed
    #####: 1206:      Block *insertAfterBlock = action.originalPosition.insertAfterBlock;
    #####: 1207:      blockList.insert((insertAfterBlock
    #####: 1208:                            ? std::next(Region::iterator(insertAfterBlock))
    #####: 1209:                            : blockList.begin()),
call    0 never executed
    #####: 1210:                       action.block);
branch  0 never executed
branch  1 never executed
    #####: 1211:      break;
call    0 never executed
        -: 1212:    }
        -: 1213:    // Split the block at the position which was originally the end of the
        -: 1214:    // destination block (owned by action), and put the instructions back into
        -: 1215:    // the block used before the merge.
    #####: 1216:    case BlockActionKind::Merge: {
    #####: 1217:      Block *sourceBlock = action.mergeInfo.sourceBlock;
    #####: 1218:      Block::iterator splitPoint =
    #####: 1219:          (action.mergeInfo.destBlockLastInst
    #####: 1220:               ? ++Block::iterator(action.mergeInfo.destBlockLastInst)
call    0 never executed
    #####: 1221:               : action.block->begin());
branch  0 never executed
branch  1 never executed
    #####: 1222:      sourceBlock->getOperations().splice(sourceBlock->begin(),
branch  0 never executed
branch  1 never executed
    #####: 1223:                                          action.block->getOperations(),
branch  0 never executed
branch  1 never executed
    #####: 1224:                                          splitPoint, action.block->end());
branch  0 never executed
branch  1 never executed
    #####: 1225:      break;
        -: 1226:    }
        -: 1227:    // Move the block back to its original position.
    #####: 1228:    case BlockActionKind::Move: {
    #####: 1229:      Region *originalRegion = action.originalPosition.region;
    #####: 1230:      Block *insertAfterBlock = action.originalPosition.insertAfterBlock;
    #####: 1231:      originalRegion->getBlocks().splice(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1232:          (insertAfterBlock ? std::next(Region::iterator(insertAfterBlock))
    #####: 1233:                            : originalRegion->end()),
    #####: 1234:          action.block->getParent()->getBlocks(), action.block);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1235:      break;
call    0 never executed
        -: 1236:    }
        -: 1237:    // Merge back the block that was split out.
    #####: 1238:    case BlockActionKind::Split: {
    #####: 1239:      action.originalBlock->getOperations().splice(
call    0 never executed
    #####: 1240:          action.originalBlock->end(), action.block->getOperations());
call    0 never executed
    #####: 1241:      action.block->dropAllDefinedValueUses();
call    0 never executed
    #####: 1242:      action.block->erase();
    #####: 1243:      break;
call    0 never executed
        -: 1244:    }
        -: 1245:    // Undo the type conversion.
    #####: 1246:    case BlockActionKind::TypeConversion: {
    #####: 1247:      argConverter.discardRewrites(action.block);
    #####: 1248:      break;
call    0 never executed
        -: 1249:    }
        -: 1250:    }
        -: 1251:  }
      527: 1252:  blockActions.resize(numActionsToKeep);
call    0 returned 100%
      527: 1253:}
        -: 1254:
function _ZN4mlir6detail29ConversionPatternRewriterImpl11remapValuesEN4llvm9StringRefENS2_8OptionalINS_8LocationEEERNS_15PatternRewriterENS_10ValueRangeERNS2_15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1255:LogicalResult ConversionPatternRewriterImpl::remapValues(
        -: 1256:    StringRef valueDiagTag, Optional<Location> inputLoc,
        -: 1257:    PatternRewriter &rewriter, ValueRange values,
        -: 1258:    SmallVectorImpl<Value> &remapped) {
    #####: 1259:  remapped.reserve(llvm::size(values));
branch  0 never executed
branch  1 never executed
        -: 1260:
    #####: 1261:  SmallVector<Type, 1> legalTypes;
    #####: 1262:  for (const auto &it : llvm::enumerate(values)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1263:    Value operand = it.value();
call    0 never executed
    #####: 1264:    Type origType = operand.getType();
branch  0 never executed
branch  1 never executed
        -: 1265:
        -: 1266:    // If a converter was provided, get the desired legal types for this
        -: 1267:    // operand.
    #####: 1268:    Type desiredType;
    #####: 1269:    if (currentTypeConverter) {
branch  0 never executed
branch  1 never executed
        -: 1270:      // If there is no legal conversion, fail to match this pattern.
    #####: 1271:      legalTypes.clear();
call    0 never executed
    #####: 1272:      if (failed(currentTypeConverter->convertType(origType, legalTypes))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1273:        Location operandLoc = inputLoc ? *inputLoc : operand.getLoc();
branch  0 never executed
branch  1 never executed
call    2 never executed
function _ZZN4mlir6detail29ConversionPatternRewriterImpl11remapValuesEN4llvm9StringRefENS2_8OptionalINS_8LocationEEERNS_15PatternRewriterENS_10ValueRangeERNS2_15SmallVectorImplINS_5ValueEEEENKUlRNS_10DiagnosticEE_clESF_ called 0 returned 0% blocks executed 0%
    #####: 1274:        return notifyMatchFailure(operandLoc, [=](Diagnostic &diag) {
    #####: 1275:          diag << "unable to convert type for " << valueDiagTag << " #"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1276:               << it.index() << ", type was " << origType;
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1277:        });
call    0 never executed
        -: 1278:      }
        -: 1279:      // TODO: There currently isn't any mechanism to do 1->N type conversion
        -: 1280:      // via the PatternRewriter replacement API, so for now we just ignore it.
    #####: 1281:      if (legalTypes.size() == 1)
branch  0 never executed
branch  1 never executed
    #####: 1282:        desiredType = legalTypes.front();
        -: 1283:    } else {
        -: 1284:      // TODO: What we should do here is just set `desiredType` to `origType`
        -: 1285:      // and then handle the necessary type conversions after the conversion
        -: 1286:      // process has finished. Unfortunately a lot of patterns currently rely on
        -: 1287:      // receiving the new operands even if the types change, so we keep the
        -: 1288:      // original behavior here for now until all of the patterns relying on
        -: 1289:      // this get updated.
        -: 1290:    }
    #####: 1291:    Value newOperand = mapping.lookupOrDefault(operand, desiredType);
call    0 never executed
        -: 1292:
        -: 1293:    // Handle the case where the conversion was 1->1 and the new operand type
        -: 1294:    // isn't legal.
    #####: 1295:    Type newOperandType = newOperand.getType();
branch  0 never executed
branch  1 never executed
    #####: 1296:    if (currentTypeConverter && desiredType && newOperandType != desiredType) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1297:      Location operandLoc = inputLoc ? *inputLoc : operand.getLoc();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1298:      Value castValue = buildUnresolvedTargetMaterialization(
        -: 1299:          operandLoc, newOperand, desiredType, currentTypeConverter,
    #####: 1300:          unresolvedMaterializations);
call    0 never executed
    #####: 1301:      mapping.map(mapping.lookupOrDefault(newOperand), castValue);
call    0 never executed
call    1 never executed
    #####: 1302:      newOperand = castValue;
        -: 1303:    }
    #####: 1304:    remapped.push_back(newOperand);
call    0 never executed
        -: 1305:  }
    #####: 1306:  return success();
branch  0 never executed
branch  1 never executed
        -: 1307:}
        -: 1308:
function _ZNK4mlir6detail29ConversionPatternRewriterImpl11isOpIgnoredEPNS_9OperationE called 14887749 returned 100% blocks executed 100%
 14887749: 1309:bool ConversionPatternRewriterImpl::isOpIgnored(Operation *op) const {
        -: 1310:  // Check to see if this operation was replaced or its parent ignored.
 44634895: 1311:  return replacements.count(op) || ignoredOps.count(op->getParentOp());
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 1%
call    5 returned 100%
        -: 1312:}
        -: 1313:
function _ZN4mlir6detail29ConversionPatternRewriterImpl20markNestedOpsIgnoredEPNS_9OperationE called 0 returned 0% blocks executed 0%
  408698*: 1314:void ConversionPatternRewriterImpl::markNestedOpsIgnored(Operation *op) {
        -: 1315:  // Walk this operation and collect nested operations that define non-empty
        -: 1316:  // regions. We mark such operations as 'ignored' so that we know we don't have
        -: 1317:  // to convert them, or their nested ops.
    #####: 1318:  if (op->getNumRegions() == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1319:    return;
function _ZZN4mlir6detail29ConversionPatternRewriterImpl20markNestedOpsIgnoredEPNS_9OperationEENKUlS3_E_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1320:  op->walk([&](Operation *op) {
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1321:    if (llvm::any_of(op->getRegions(),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1322:                     [](Region &region) { return !region.empty(); }))
    #####: 1323:      ignoredOps.insert(op);
call    0 never executed
    #####: 1324:  });
        -: 1325:}
        -: 1326:
        -: 1327://===----------------------------------------------------------------------===//
        -: 1328:// Type Conversion
        -: 1329:
function _ZN4mlir6detail29ConversionPatternRewriterImpl21convertBlockSignatureEPNS_5BlockEPNS_13TypeConverterEPNS4_19SignatureConversionE called 0 returned 0% blocks executed 0%
    #####: 1330:FailureOr<Block *> ConversionPatternRewriterImpl::convertBlockSignature(
        -: 1331:    Block *block, TypeConverter *converter,
        -: 1332:    TypeConverter::SignatureConversion *conversion) {
    #####: 1333:  FailureOr<Block *> result =
    #####: 1334:      conversion ? argConverter.applySignatureConversion(
    #####: 1335:                       block, converter, *conversion, mapping, argReplacements)
call    0 never executed
    #####: 1336:                 : argConverter.convertSignature(block, converter, mapping,
    #####: 1337:                                                 argReplacements);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1338:  if (failed(result))
branch  0 never executed
branch  1 never executed
    #####: 1339:    return failure();
    #####: 1340:  if (Block *newBlock = *result) {
branch  0 never executed
branch  1 never executed
    #####: 1341:    if (newBlock != block)
branch  0 never executed
branch  1 never executed
    #####: 1342:      blockActions.push_back(BlockAction::getTypeConversion(newBlock));
call    0 never executed
        -: 1343:  }
    #####: 1344:  return result;
        -: 1345:}
        -: 1346:
function _ZN4mlir6detail29ConversionPatternRewriterImpl24applySignatureConversionEPNS_6RegionERNS_13TypeConverter19SignatureConversionEPS4_ called 0 returned 0% blocks executed 0%
    #####: 1347:Block *ConversionPatternRewriterImpl::applySignatureConversion(
        -: 1348:    Region *region, TypeConverter::SignatureConversion &conversion,
        -: 1349:    TypeConverter *converter) {
    #####: 1350:  if (!region->empty())
branch  0 never executed
branch  1 never executed
    #####: 1351:    return *convertBlockSignature(&region->front(), converter, &conversion);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1352:  return nullptr;
        -: 1353:}
        -: 1354:
function _ZN4mlir6detail29ConversionPatternRewriterImpl18convertRegionTypesEPNS_6RegionERNS_13TypeConverterEPNS4_19SignatureConversionE called 0 returned 0% blocks executed 0%
    #####: 1355:FailureOr<Block *> ConversionPatternRewriterImpl::convertRegionTypes(
        -: 1356:    Region *region, TypeConverter &converter,
        -: 1357:    TypeConverter::SignatureConversion *entryConversion) {
    #####: 1358:  argConverter.setConverter(region, &converter);
call    0 never executed
    #####: 1359:  if (region->empty())
branch  0 never executed
branch  1 never executed
    #####: 1360:    return nullptr;
        -: 1361:
    #####: 1362:  if (failed(convertNonEntryRegionTypes(region, converter)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1363:    return failure();
        -: 1364:
    #####: 1365:  FailureOr<Block *> newEntry =
call    0 never executed
    #####: 1366:      convertBlockSignature(&region->front(), &converter, entryConversion);
call    0 never executed
    #####: 1367:  return newEntry;
        -: 1368:}
        -: 1369:
function _ZN4mlir6detail29ConversionPatternRewriterImpl26convertNonEntryRegionTypesEPNS_6RegionERNS_13TypeConverterEN4llvm8ArrayRefINS4_19SignatureConversionEEE called 0 returned 0% blocks executed 0%
    #####: 1370:LogicalResult ConversionPatternRewriterImpl::convertNonEntryRegionTypes(
        -: 1371:    Region *region, TypeConverter &converter,
        -: 1372:    ArrayRef<TypeConverter::SignatureConversion> blockConversions) {
    #####: 1373:  argConverter.setConverter(region, &converter);
call    0 never executed
    #####: 1374:  if (region->empty())
branch  0 never executed
branch  1 never executed
    #####: 1375:    return success();
        -: 1376:
        -: 1377:  // Convert the arguments of each block within the region.
    #####: 1378:  int blockIdx = 0;
    #####: 1379:  assert((blockConversions.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1380:          blockConversions.size() == region->getBlocks().size() - 1) &&
        -: 1381:         "expected either to provide no SignatureConversions at all or to "
        -: 1382:         "provide a SignatureConversion for each non-entry block");
        -: 1383:
    #####: 1384:  for (Block &block :
branch  0 never executed
branch  1 never executed
    #####: 1385:       llvm::make_early_inc_range(llvm::drop_begin(*region, 1))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1386:    TypeConverter::SignatureConversion *blockConversion =
    #####: 1387:        blockConversions.empty()
branch  0 never executed
branch  1 never executed
    #####: 1388:            ? nullptr
branch  0 never executed
branch  1 never executed
        -: 1389:            : const_cast<TypeConverter::SignatureConversion *>(
    #####: 1390:                  &blockConversions[blockIdx++]);
branch  0 never executed
branch  1 never executed
        -: 1391:
    #####: 1392:    if (failed(convertBlockSignature(&block, &converter, blockConversion)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1393:      return failure();
        -: 1394:  }
    #####: 1395:  return success();
        -: 1396:}
        -: 1397:
        -: 1398://===----------------------------------------------------------------------===//
        -: 1399:// Rewriter Notification Hooks
        -: 1400:
function _ZN4mlir6detail29ConversionPatternRewriterImpl16notifyOpReplacedEPNS_9OperationENS_10ValueRangeE called 408698 returned 100% blocks executed 73%
   408698: 1401:void ConversionPatternRewriterImpl::notifyOpReplaced(Operation *op,
        -: 1402:                                                     ValueRange newValues) {
  408698*: 1403:  assert(newValues.size() == op->getNumResults());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  408698*: 1404:  assert(!replacements.count(op) && "operation was already replaced");
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -: 1405:
        -: 1406:  // Track if any of the results changed, e.g. erased and replaced with null.
   408698: 1407:  bool resultChanged = false;
        -: 1408:
        -: 1409:  // Create mappings for each of the new result values.
  1634792: 1410:  for (auto [newValue, result] : llvm::zip(newValues, op->getResults())) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
  408698*: 1411:    if (!newValue) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1412:      resultChanged = true;
    #####: 1413:      continue;
        -: 1414:    }
        -: 1415:    // Remap, and check for any result type changes.
   408698: 1416:    mapping.map(result, newValue);
call    0 returned 100%
   408698: 1417:    resultChanged |= (newValue.getType() != result.getType());
        -: 1418:  }
   408698: 1419:  if (resultChanged)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1420:    operationsWithChangedResults.push_back(replacements.size());
call    0 never executed
        -: 1421:
        -: 1422:  // Record the requested operation replacement.
   408698: 1423:  replacements.insert(std::make_pair(op, OpReplacement(currentTypeConverter)));
call    0 returned 100%
        -: 1424:
        -: 1425:  // Mark this operation as recursively ignored so that we don't need to
        -: 1426:  // convert any nested operations.
   408698: 1427:  markNestedOpsIgnored(op);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   408698: 1428:}
        -: 1429:
function _ZN4mlir6detail29ConversionPatternRewriterImpl24notifyBlockIsBeingErasedEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####: 1430:void ConversionPatternRewriterImpl::notifyBlockIsBeingErased(Block *block) {
    #####: 1431:  Region *region = block->getParent();
call    0 never executed
    #####: 1432:  Block *origPrevBlock = block->getPrevNode();
call    0 never executed
    #####: 1433:  blockActions.push_back(BlockAction::getErase(block, {region, origPrevBlock}));
call    0 never executed
    #####: 1434:}
        -: 1435:
function _ZN4mlir6detail29ConversionPatternRewriterImpl18notifyCreatedBlockEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####: 1436:void ConversionPatternRewriterImpl::notifyCreatedBlock(Block *block) {
    #####: 1437:  blockActions.push_back(BlockAction::getCreate(block));
call    0 never executed
call    1 never executed
    #####: 1438:}
        -: 1439:
function _ZN4mlir6detail29ConversionPatternRewriterImpl16notifySplitBlockEPNS_5BlockES3_ called 0 returned 0% blocks executed 0%
    #####: 1440:void ConversionPatternRewriterImpl::notifySplitBlock(Block *block,
        -: 1441:                                                     Block *continuation) {
    #####: 1442:  blockActions.push_back(BlockAction::getSplit(continuation, block));
call    0 never executed
call    1 never executed
    #####: 1443:}
        -: 1444:
function _ZN4mlir6detail29ConversionPatternRewriterImpl23notifyBlocksBeingMergedEPNS_5BlockES3_ called 0 returned 0% blocks executed 0%
    #####: 1445:void ConversionPatternRewriterImpl::notifyBlocksBeingMerged(Block *block,
        -: 1446:                                                            Block *srcBlock) {
    #####: 1447:  blockActions.push_back(BlockAction::getMerge(block, srcBlock));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1448:}
        -: 1449:
function _ZN4mlir6detail29ConversionPatternRewriterImpl32notifyRegionIsBeingInlinedBeforeERNS_6RegionES3_N4llvm14ilist_iteratorINS4_12ilist_detail12node_optionsINS_5BlockELb1ELb0EvEELb0ELb0EEE called 0 returned 0% blocks executed 0%
    #####: 1450:void ConversionPatternRewriterImpl::notifyRegionIsBeingInlinedBefore(
        -: 1451:    Region &region, Region &parent, Region::iterator before) {
    #####: 1452:  if (region.empty())
branch  0 never executed
branch  1 never executed
        -: 1453:    return;
    #####: 1454:  Block *laterBlock = &region.back();
call    0 never executed
    #####: 1455:  for (auto &earlierBlock : llvm::drop_begin(llvm::reverse(region), 1)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1456:    blockActions.push_back(
    #####: 1457:        BlockAction::getMove(laterBlock, {&region, &earlierBlock}));
call    0 never executed
    #####: 1458:    laterBlock = &earlierBlock;
        -: 1459:  }
    #####: 1460:  blockActions.push_back(BlockAction::getMove(laterBlock, {&region, nullptr}));
call    0 never executed
        -: 1461:}
        -: 1462:
function _ZN4mlir6detail29ConversionPatternRewriterImpl27notifyRegionWasClonedBeforeERN4llvm14iterator_rangeINS2_14ilist_iteratorINS2_12ilist_detail12node_optionsINS_5BlockELb1ELb0EvEELb0ELb0EEEEENS_8LocationE called 0 returned 0% blocks executed 0%
    #####: 1463:void ConversionPatternRewriterImpl::notifyRegionWasClonedBefore(
        -: 1464:    iterator_range<Region::iterator> &blocks, Location origRegionLoc) {
    #####: 1465:  for (Block &block : blocks)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1466:    blockActions.push_back(BlockAction::getCreate(&block));
call    0 never executed
        -: 1467:
        -: 1468:  // Compute the conversion set for the inlined region.
    #####: 1469:  auto result = computeConversionSet(blocks, origRegionLoc, createdOps);
call    0 never executed
        -: 1470:
        -: 1471:  // This original region has already had its conversion set computed, so there
        -: 1472:  // shouldn't be any new failures.
    #####: 1473:  (void)result;
    #####: 1474:  assert(succeeded(result) && "expected region to have no unreachable blocks");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1475:}
        -: 1476:
function _ZN4mlir6detail29ConversionPatternRewriterImpl18notifyMatchFailureENS_8LocationEN4llvm12function_refIFvRNS_10DiagnosticEEEE called 0 returned 0% blocks executed 0%
    #####: 1477:LogicalResult ConversionPatternRewriterImpl::notifyMatchFailure(
        -: 1478:    Location loc, function_ref<void(Diagnostic &)> reasonCallback) {
    #####: 1479:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
call   16 never executed
        -: 1480:    Diagnostic diag(loc, DiagnosticSeverity::Remark);
        -: 1481:    reasonCallback(diag);
        -: 1482:    logger.startLine() << "** Failure : " << diag.str() << "\n";
        -: 1483:    if (notifyCallback)
        -: 1484:      notifyCallback(diag);
        -: 1485:  });
    #####: 1486:  return failure();
        -: 1487:}
        -: 1488:
        -: 1489://===----------------------------------------------------------------------===//
        -: 1490:// ConversionPatternRewriter
        -: 1491://===----------------------------------------------------------------------===//
        -: 1492:
function _ZN4mlir25ConversionPatternRewriterC2EPNS_11MLIRContextE called 35726 returned 100% blocks executed 100%
    35726: 1493:ConversionPatternRewriter::ConversionPatternRewriter(MLIRContext *ctx)
        -: 1494:    : PatternRewriter(ctx),
    35726: 1495:      impl(new detail::ConversionPatternRewriterImpl(*this)) {}
call    0 returned 100%
call    1 returned 100%
        -: 1496:ConversionPatternRewriter::~ConversionPatternRewriter() = default;
        -: 1497:
function _ZN4mlir25ConversionPatternRewriter15replaceOpWithIfEPNS_9OperationENS_10ValueRangeEPbN4llvm15unique_functionIKFbRNS_9OpOperandEEEE called 0 returned 0% blocks executed 0%
    #####: 1498:void ConversionPatternRewriter::replaceOpWithIf(
        -: 1499:    Operation *op, ValueRange newValues, bool *allUsesReplaced,
        -: 1500:    llvm::unique_function<bool(OpOperand &) const> functor) {
        -: 1501:  // TODO: To support this we will need to rework a bit of how replacements are
        -: 1502:  // tracked, given that this isn't guranteed to replace all of the uses of an
        -: 1503:  // operation. The main change is that now an operation can be replaced
        -: 1504:  // multiple times, in parts. The current "set" based tracking is mainly useful
        -: 1505:  // for tracking if a replaced operation should be ignored, i.e. if all of the
        -: 1506:  // uses will be replaced.
    #####: 1507:  llvm_unreachable(
        -: 1508:      "replaceOpWithIf is currently not supported by DialectConversion");
        -: 1509:}
        -: 1510:
function _ZN4mlir25ConversionPatternRewriter9replaceOpEPNS_9OperationENS_10ValueRangeE called 408698 returned 100% blocks executed 27%
   408698: 1511:void ConversionPatternRewriter::replaceOp(Operation *op, ValueRange newValues) {
  408698*: 1512:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -: 1513:    impl->logger.startLine()
        -: 1514:        << "** Replace : '" << op->getName() << "'(" << op << ")\n";
        -: 1515:  });
   408698: 1516:  impl->notifyOpReplaced(op, newValues);
call    0 returned 100%
   408698: 1517:}
        -: 1518:
function _ZN4mlir25ConversionPatternRewriter7eraseOpEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1519:void ConversionPatternRewriter::eraseOp(Operation *op) {
    #####: 1520:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -: 1521:    impl->logger.startLine()
        -: 1522:        << "** Erase   : '" << op->getName() << "'(" << op << ")\n";
        -: 1523:  });
    #####: 1524:  SmallVector<Value, 1> nullRepls(op->getNumResults(), nullptr);
call    0 never executed
    #####: 1525:  impl->notifyOpReplaced(op, nullRepls);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1526:}
        -: 1527:
function _ZN4mlir25ConversionPatternRewriter10eraseBlockEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####: 1528:void ConversionPatternRewriter::eraseBlock(Block *block) {
    #####: 1529:  impl->notifyBlockIsBeingErased(block);
call    0 never executed
        -: 1530:
        -: 1531:  // Mark all ops for erasure.
    #####: 1532:  for (Operation &op : *block)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1533:    eraseOp(&op);
call    0 never executed
        -: 1534:
        -: 1535:  // Unlink the block from its parent region. The block is kept in the block
        -: 1536:  // action and will be actually destroyed when rewrites are applied. This
        -: 1537:  // allows us to keep the operations in the block live and undo the removal by
        -: 1538:  // re-inserting the block.
    #####: 1539:  block->getParent()->getBlocks().remove(block);
call    0 never executed
call    1 never executed
    #####: 1540:}
        -: 1541:
function _ZN4mlir25ConversionPatternRewriter24applySignatureConversionEPNS_6RegionERNS_13TypeConverter19SignatureConversionEPS3_ called 0 returned 0% blocks executed 0%
    #####: 1542:Block *ConversionPatternRewriter::applySignatureConversion(
        -: 1543:    Region *region, TypeConverter::SignatureConversion &conversion,
        -: 1544:    TypeConverter *converter) {
    #####: 1545:  return impl->applySignatureConversion(region, conversion, converter);
call    0 never executed
        -: 1546:}
        -: 1547:
function _ZN4mlir25ConversionPatternRewriter18convertRegionTypesEPNS_6RegionERNS_13TypeConverterEPNS3_19SignatureConversionE called 0 returned 0% blocks executed 0%
    #####: 1548:FailureOr<Block *> ConversionPatternRewriter::convertRegionTypes(
        -: 1549:    Region *region, TypeConverter &converter,
        -: 1550:    TypeConverter::SignatureConversion *entryConversion) {
    #####: 1551:  return impl->convertRegionTypes(region, converter, entryConversion);
call    0 never executed
        -: 1552:}
        -: 1553:
function _ZN4mlir25ConversionPatternRewriter26convertNonEntryRegionTypesEPNS_6RegionERNS_13TypeConverterEN4llvm8ArrayRefINS3_19SignatureConversionEEE called 0 returned 0% blocks executed 0%
    #####: 1554:LogicalResult ConversionPatternRewriter::convertNonEntryRegionTypes(
        -: 1555:    Region *region, TypeConverter &converter,
        -: 1556:    ArrayRef<TypeConverter::SignatureConversion> blockConversions) {
    #####: 1557:  return impl->convertNonEntryRegionTypes(region, converter, blockConversions);
call    0 never executed
        -: 1558:}
        -: 1559:
function _ZN4mlir25ConversionPatternRewriter26replaceUsesOfBlockArgumentENS_13BlockArgumentENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 1560:void ConversionPatternRewriter::replaceUsesOfBlockArgument(BlockArgument from,
        -: 1561:                                                           Value to) {
    #####: 1562:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
        -: 1563:    Operation *parentOp = from.getOwner()->getParentOp();
        -: 1564:    impl->logger.startLine() << "** Replace Argument : '" << from
        -: 1565:                             << "'(in region of '" << parentOp->getName()
        -: 1566:                             << "'(" << from.getOwner()->getParentOp() << ")\n";
        -: 1567:  });
    #####: 1568:  impl->argReplacements.push_back(from);
call    0 never executed
    #####: 1569:  impl->mapping.map(impl->mapping.lookupOrDefault(from), to);
call    0 never executed
call    1 never executed
    #####: 1570:}
        -: 1571:
function _ZN4mlir25ConversionPatternRewriter16getRemappedValueENS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 1572:Value ConversionPatternRewriter::getRemappedValue(Value key) {
    #####: 1573:  SmallVector<Value> remappedValues;
call    0 never executed
    #####: 1574:  if (failed(impl->remapValues("value", /*inputLoc=*/llvm::None, *this, key,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1575:                               remappedValues)))
    #####: 1576:    return nullptr;
    #####: 1577:  return remappedValues.front();
branch  0 never executed
branch  1 never executed
        -: 1578:}
        -: 1579:
        -: 1580:LogicalResult
function _ZN4mlir25ConversionPatternRewriter17getRemappedValuesENS_10ValueRangeERN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1581:ConversionPatternRewriter::getRemappedValues(ValueRange keys,
        -: 1582:                                             SmallVectorImpl<Value> &results) {
    #####: 1583:  if (keys.empty())
branch  0 never executed
branch  1 never executed
    #####: 1584:    return success();
    #####: 1585:  return impl->remapValues("value", /*inputLoc=*/llvm::None, *this, keys,
    #####: 1586:                           results);
call    0 never executed
        -: 1587:}
        -: 1588:
function _ZN4mlir25ConversionPatternRewriter18notifyBlockCreatedEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####: 1589:void ConversionPatternRewriter::notifyBlockCreated(Block *block) {
    #####: 1590:  impl->notifyCreatedBlock(block);
call    0 never executed
    #####: 1591:}
        -: 1592:
function _ZN4mlir25ConversionPatternRewriter10splitBlockEPNS_5BlockEN4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsINS_9OperationELb1ELb0EvEELb0ELb0EEE called 0 returned 0% blocks executed 0%
    #####: 1593:Block *ConversionPatternRewriter::splitBlock(Block *block,
        -: 1594:                                             Block::iterator before) {
    #####: 1595:  auto *continuation = PatternRewriter::splitBlock(block, before);
call    0 never executed
    #####: 1596:  impl->notifySplitBlock(block, continuation);
call    0 never executed
    #####: 1597:  return continuation;
        -: 1598:}
        -: 1599:
function _ZN4mlir25ConversionPatternRewriter11mergeBlocksEPNS_5BlockES2_NS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####: 1600:void ConversionPatternRewriter::mergeBlocks(Block *source, Block *dest,
        -: 1601:                                            ValueRange argValues) {
    #####: 1602:  impl->notifyBlocksBeingMerged(dest, source);
call    0 never executed
    #####: 1603:  assert(llvm::all_of(source->getPredecessors(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1604:                      [dest](Block *succ) { return succ == dest; }) &&
        -: 1605:         "expected 'source' to have no predecessors or only 'dest'");
    #####: 1606:  assert(argValues.size() == source->getNumArguments() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1607:         "incorrect # of argument replacement values");
    #####: 1608:  for (auto it : llvm::zip(source->getArguments(), argValues))
branch  0 never executed
branch  1 never executed
    #####: 1609:    replaceUsesOfBlockArgument(std::get<0>(it), std::get<1>(it));
call    0 never executed
    #####: 1610:  dest->getOperations().splice(dest->end(), source->getOperations());
call    0 never executed
    #####: 1611:  eraseBlock(source);
call    0 never executed
    #####: 1612:}
        -: 1613:
function _ZN4mlir25ConversionPatternRewriter18inlineRegionBeforeERNS_6RegionES2_N4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsINS_5BlockELb1ELb0EvEELb0ELb0EEE called 0 returned 0% blocks executed 0%
    #####: 1614:void ConversionPatternRewriter::inlineRegionBefore(Region &region,
        -: 1615:                                                   Region &parent,
        -: 1616:                                                   Region::iterator before) {
    #####: 1617:  impl->notifyRegionIsBeingInlinedBefore(region, parent, before);
call    0 never executed
    #####: 1618:  PatternRewriter::inlineRegionBefore(region, parent, before);
call    0 never executed
    #####: 1619:}
        -: 1620:
function _ZN4mlir25ConversionPatternRewriter17cloneRegionBeforeERNS_6RegionES2_N4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsINS_5BlockELb1ELb0EvEELb0ELb0EEERNS_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####: 1621:void ConversionPatternRewriter::cloneRegionBefore(
        -: 1622:    Region &region, Region &parent, Region::iterator before,
        -: 1623:    BlockAndValueMapping &mapping) {
    #####: 1624:  if (region.empty())
branch  0 never executed
branch  1 never executed
    #####: 1625:    return;
    #####: 1626:  PatternRewriter::cloneRegionBefore(region, parent, before, mapping);
call    0 never executed
        -: 1627:
        -: 1628:  // Collect the range of the cloned blocks.
    #####: 1629:  auto clonedBeginIt = mapping.lookup(&region.front())->getIterator();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1630:  auto clonedBlocks = llvm::make_range(clonedBeginIt, before);
call    0 never executed
    #####: 1631:  impl->notifyRegionWasClonedBefore(clonedBlocks, region.getLoc());
call    0 never executed
call    1 never executed
        -: 1632:}
        -: 1633:
function _ZN4mlir25ConversionPatternRewriter23notifyOperationInsertedEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1634:void ConversionPatternRewriter::notifyOperationInserted(Operation *op) {
    #####: 1635:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -: 1636:    impl->logger.startLine()
        -: 1637:        << "** Insert  : '" << op->getName() << "'(" << op << ")\n";
        -: 1638:  });
    #####: 1639:  impl->createdOps.push_back(op);
call    0 never executed
    #####: 1640:}
        -: 1641:
function _ZN4mlir25ConversionPatternRewriter15startRootUpdateEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1642:void ConversionPatternRewriter::startRootUpdate(Operation *op) {
        -: 1643:#ifndef NDEBUG
    #####: 1644:  impl->pendingRootUpdates.insert(op);
call    0 never executed
        -: 1645:#endif
    #####: 1646:  impl->rootUpdates.emplace_back(op);
call    0 never executed
    #####: 1647:}
        -: 1648:
function _ZN4mlir25ConversionPatternRewriter18finalizeRootUpdateEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1649:void ConversionPatternRewriter::finalizeRootUpdate(Operation *op) {
        -: 1650:  // There is nothing to do here, we only need to track the operation at the
        -: 1651:  // start of the update.
        -: 1652:#ifndef NDEBUG
    #####: 1653:  assert(impl->pendingRootUpdates.erase(op) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1654:         "operation did not have a pending in-place update");
        -: 1655:#endif
    #####: 1656:}
        -: 1657:
function _ZN4mlir25ConversionPatternRewriter16cancelRootUpdateEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 1658:void ConversionPatternRewriter::cancelRootUpdate(Operation *op) {
        -: 1659:#ifndef NDEBUG
    #####: 1660:  assert(impl->pendingRootUpdates.erase(op) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1661:         "operation did not have a pending in-place update");
        -: 1662:#endif
        -: 1663:  // Erase the last update for this operation.
    #####: 1664:  auto stateHasOp = [op](const auto &it) { return it.getOperation() == op; };
    #####: 1665:  auto &rootUpdates = impl->rootUpdates;
call    0 never executed
    #####: 1666:  auto it = llvm::find_if(llvm::reverse(rootUpdates), stateHasOp);
call    0 never executed
    #####: 1667:  assert(it != rootUpdates.rend() && "no root update started on op");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1668:  (*it).resetOperation();
call    0 never executed
    #####: 1669:  int updateIdx = std::prev(rootUpdates.rend()) - it;
call    0 never executed
    #####: 1670:  rootUpdates.erase(rootUpdates.begin() + updateIdx);
call    0 never executed
    #####: 1671:}
        -: 1672:
function _ZN4mlir25ConversionPatternRewriter18notifyMatchFailureENS_8LocationEN4llvm12function_refIFvRNS_10DiagnosticEEEE called 0 returned 0% blocks executed 0%
    #####: 1673:LogicalResult ConversionPatternRewriter::notifyMatchFailure(
        -: 1674:    Location loc, function_ref<void(Diagnostic &)> reasonCallback) {
    #####: 1675:  return impl->notifyMatchFailure(loc, reasonCallback);
call    0 never executed
        -: 1676:}
        -: 1677:
function _ZN4mlir25ConversionPatternRewriter7getImplEv called 0 returned 0% blocks executed 0%
71039989*: 1678:detail::ConversionPatternRewriterImpl &ConversionPatternRewriter::getImpl() {
    #####: 1679:  return *impl;
call    0 never executed
        -: 1680:}
        -: 1681:
        -: 1682://===----------------------------------------------------------------------===//
        -: 1683:// ConversionPattern
        -: 1684://===----------------------------------------------------------------------===//
        -: 1685:
        -: 1686:LogicalResult
function _ZNK4mlir17ConversionPattern15matchAndRewriteEPNS_9OperationERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1687:ConversionPattern::matchAndRewrite(Operation *op,
        -: 1688:                                   PatternRewriter &rewriter) const {
    #####: 1689:  auto &dialectRewriter = static_cast<ConversionPatternRewriter &>(rewriter);
    #####: 1690:  auto &rewriterImpl = dialectRewriter.getImpl();
call    0 never executed
        -: 1691:
        -: 1692:  // Track the current conversion pattern type converter in the rewriter.
    #####: 1693:  llvm::SaveAndRestore<TypeConverter *> currentConverterGuard(
    #####: 1694:      rewriterImpl.currentTypeConverter, getTypeConverter());
call    0 never executed
        -: 1695:
        -: 1696:  // Remap the operands of the operation.
    #####: 1697:  SmallVector<Value, 4> operands;
call    0 never executed
    #####: 1698:  if (failed(rewriterImpl.remapValues("operand", op->getLoc(), rewriter,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1699:                                      op->getOperands(), operands))) {
    #####: 1700:    return failure();
branch  0 never executed
branch  1 never executed
        -: 1701:  }
    #####: 1702:  return matchAndRewrite(op, operands, dialectRewriter);
call    0 never executed
        -: 1703:}
        -: 1704:
        -: 1705://===----------------------------------------------------------------------===//
        -: 1706:// OperationLegalizer
        -: 1707://===----------------------------------------------------------------------===//
        -: 1708:
        -: 1709:namespace {
        -: 1710:/// A set of rewrite patterns that can be used to legalize a given operation.
        -: 1711:using LegalizationPatterns = SmallVector<const Pattern *, 1>;
        -: 1712:
        -: 1713:/// This class defines a recursive operation legalizer.
        -: 1714:class OperationLegalizer {
        -: 1715:public:
        -: 1716:  using LegalizationAction = ConversionTarget::LegalizationAction;
        -: 1717:
        -: 1718:  OperationLegalizer(ConversionTarget &targetInfo,
        -: 1719:                     const FrozenRewritePatternSet &patterns);
        -: 1720:
        -: 1721:  /// Returns true if the given operation is known to be illegal on the target.
        -: 1722:  bool isIllegal(Operation *op) const;
        -: 1723:
        -: 1724:  /// Attempt to legalize the given operation. Returns success if the operation
        -: 1725:  /// was legalized, failure otherwise.
        -: 1726:  LogicalResult legalize(Operation *op, ConversionPatternRewriter &rewriter);
        -: 1727:
        -: 1728:  /// Returns the conversion target in use by the legalizer.
    35726: 1729:  ConversionTarget &getTarget() { return target; }
        -: 1730:
        -: 1731:private:
        -: 1732:  /// Attempt to legalize the given operation by folding it.
        -: 1733:  LogicalResult legalizeWithFold(Operation *op,
        -: 1734:                                 ConversionPatternRewriter &rewriter);
        -: 1735:
        -: 1736:  /// Attempt to legalize the given operation by applying a pattern. Returns
        -: 1737:  /// success if the operation was legalized, failure otherwise.
        -: 1738:  LogicalResult legalizeWithPattern(Operation *op,
        -: 1739:                                    ConversionPatternRewriter &rewriter);
        -: 1740:
        -: 1741:  /// Return true if the given pattern may be applied to the given operation,
        -: 1742:  /// false otherwise.
        -: 1743:  bool canApplyPattern(Operation *op, const Pattern &pattern,
        -: 1744:                       ConversionPatternRewriter &rewriter);
        -: 1745:
        -: 1746:  /// Legalize the resultant IR after successfully applying the given pattern.
        -: 1747:  LogicalResult legalizePatternResult(Operation *op, const Pattern &pattern,
        -: 1748:                                      ConversionPatternRewriter &rewriter,
        -: 1749:                                      RewriterState &curState);
        -: 1750:
        -: 1751:  /// Legalizes the actions registered during the execution of a pattern.
        -: 1752:  LogicalResult legalizePatternBlockActions(Operation *op,
        -: 1753:                                            ConversionPatternRewriter &rewriter,
        -: 1754:                                            ConversionPatternRewriterImpl &impl,
        -: 1755:                                            RewriterState &state,
        -: 1756:                                            RewriterState &newState);
        -: 1757:  LogicalResult legalizePatternCreatedOperations(
        -: 1758:      ConversionPatternRewriter &rewriter, ConversionPatternRewriterImpl &impl,
        -: 1759:      RewriterState &state, RewriterState &newState);
        -: 1760:  LogicalResult legalizePatternRootUpdates(ConversionPatternRewriter &rewriter,
        -: 1761:                                           ConversionPatternRewriterImpl &impl,
        -: 1762:                                           RewriterState &state,
        -: 1763:                                           RewriterState &newState);
        -: 1764:
        -: 1765:  //===--------------------------------------------------------------------===//
        -: 1766:  // Cost Model
        -: 1767:  //===--------------------------------------------------------------------===//
        -: 1768:
        -: 1769:  /// Build an optimistic legalization graph given the provided patterns. This
        -: 1770:  /// function populates 'anyOpLegalizerPatterns' and 'legalizerPatterns' with
        -: 1771:  /// patterns for operations that are not directly legal, but may be
        -: 1772:  /// transitively legal for the current target given the provided patterns.
        -: 1773:  void buildLegalizationGraph(
        -: 1774:      LegalizationPatterns &anyOpLegalizerPatterns,
        -: 1775:      DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns);
        -: 1776:
        -: 1777:  /// Compute the benefit of each node within the computed legalization graph.
        -: 1778:  /// This orders the patterns within 'legalizerPatterns' based upon two
        -: 1779:  /// criteria:
        -: 1780:  ///  1) Prefer patterns that have the lowest legalization depth, i.e.
        -: 1781:  ///     represent the more direct mapping to the target.
        -: 1782:  ///  2) When comparing patterns with the same legalization depth, prefer the
        -: 1783:  ///     pattern with the highest PatternBenefit. This allows for users to
        -: 1784:  ///     prefer specific legalizations over others.
        -: 1785:  void computeLegalizationGraphBenefit(
        -: 1786:      LegalizationPatterns &anyOpLegalizerPatterns,
        -: 1787:      DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns);
        -: 1788:
        -: 1789:  /// Compute the legalization depth when legalizing an operation of the given
        -: 1790:  /// type.
        -: 1791:  unsigned computeOpLegalizationDepth(
        -: 1792:      OperationName op, DenseMap<OperationName, unsigned> &minOpPatternDepth,
        -: 1793:      DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns);
        -: 1794:
        -: 1795:  /// Apply the conversion cost model to the given set of patterns, and return
        -: 1796:  /// the smallest legalization depth of any of the patterns. See
        -: 1797:  /// `computeLegalizationGraphBenefit` for the breakdown of the cost model.
        -: 1798:  unsigned applyCostModelToPatterns(
        -: 1799:      LegalizationPatterns &patterns,
        -: 1800:      DenseMap<OperationName, unsigned> &minOpPatternDepth,
        -: 1801:      DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns);
        -: 1802:
        -: 1803:  /// The current set of patterns that have been applied.
        -: 1804:  SmallPtrSet<const Pattern *, 8> appliedPatterns;
        -: 1805:
        -: 1806:  /// The legalization information provided by the target.
        -: 1807:  ConversionTarget &target;
        -: 1808:
        -: 1809:  /// The pattern applicator to use for conversions.
        -: 1810:  PatternApplicator applicator;
        -: 1811:};
        -: 1812:} // namespace
        -: 1813:
function _ZN12_GLOBAL__N_118OperationLegalizerC2ERN4mlir16ConversionTargetERKNS1_23FrozenRewritePatternSetE called 35726 returned 100% blocks executed 100%
    35726: 1814:OperationLegalizer::OperationLegalizer(ConversionTarget &targetInfo,
    35726: 1815:                                       const FrozenRewritePatternSet &patterns)
    35726: 1816:    : target(targetInfo), applicator(patterns) {
call    0 returned 100%
call    1 returned 100%
        -: 1817:  // The set of patterns that can be applied to illegal operations to transform
        -: 1818:  // them into legal ones.
    35726: 1819:  DenseMap<OperationName, LegalizationPatterns> legalizerPatterns;
call    0 returned 100%
    71452: 1820:  LegalizationPatterns anyOpLegalizerPatterns;
call    0 returned 100%
call    1 returned 100%
        -: 1821:
    35726: 1822:  buildLegalizationGraph(anyOpLegalizerPatterns, legalizerPatterns);
call    0 returned 100%
    35726: 1823:  computeLegalizationGraphBenefit(anyOpLegalizerPatterns, legalizerPatterns);
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
    35726: 1824:}
        -: 1825:
 14478524: 1826:bool OperationLegalizer::isIllegal(Operation *op) const {
 14478524: 1827:  return target.isIllegal(op);
        -: 1828:}
        -: 1829:
        -: 1830:LogicalResult
function _ZN12_GLOBAL__N_118OperationLegalizer8legalizeEPN4mlir9OperationERNS1_25ConversionPatternRewriterE called 26749714 returned 100% blocks executed 24%
 26749714: 1831:OperationLegalizer::legalize(Operation *op,
        -: 1832:                             ConversionPatternRewriter &rewriter) {
        -: 1833:#ifndef NDEBUG
 26749714: 1834:  const char *logLineComment =
        -: 1835:      "//===-------------------------------------------===//\n";
        -: 1836:
 26749714: 1837:  auto &logger = rewriter.getImpl().logger;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1838:#endif
26749714*: 1839:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
        -: 1840:    logger.getOStream() << "\n";
        -: 1841:    logger.startLine() << logLineComment;
        -: 1842:    logger.startLine() << "Legalizing operation : '" << op->getName() << "'("
        -: 1843:                       << op << ") {\n";
        -: 1844:    logger.indent();
        -: 1845:
        -: 1846:    // If the operation has no regions, just print it here.
        -: 1847:    if (op->getNumRegions() == 0) {
        -: 1848:      op->print(logger.startLine(), OpPrintingFlags().printGenericOpForm());
        -: 1849:      logger.getOStream() << "\n\n";
        -: 1850:    }
        -: 1851:  });
        -: 1852:
        -: 1853:  // Check if this operation is legal on the target.
 26749714: 1854:  if (auto legalityInfo = target.isLegal(op)) {
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
11861965*: 1855:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -: 1856:      logSuccess(
        -: 1857:          logger, "operation marked legal by the target{0}",
        -: 1858:          legalityInfo->isRecursivelyLegal
        -: 1859:              ? "; NOTE: operation is recursively legal; skipping internals"
        -: 1860:              : "");
        -: 1861:      logger.startLine() << logLineComment;
        -: 1862:    });
        -: 1863:
        -: 1864:    // If this operation is recursively legal, mark its children as ignored so
        -: 1865:    // that we don't consider them for legalization.
 11861965: 1866:    if (legalityInfo->isRecursivelyLegal)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1867:      rewriter.getImpl().markNestedOpsIgnored(op);
branch  0 never executed
branch  1 never executed
 11861965: 1868:    return success();
        -: 1869:  }
        -: 1870:
        -: 1871:  // Check to see if the operation is ignored and doesn't need to be converted.
 14887749: 1872:  if (rewriter.getImpl().isOpIgnored(op)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1873:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1874:      logSuccess(logger, "operation marked 'ignored' during conversion");
        -: 1875:      logger.startLine() << logLineComment;
        -: 1876:    });
    #####: 1877:    return success();
        -: 1878:  }
        -: 1879:
        -: 1880:  // If the operation isn't legal, try to fold it in-place.
        -: 1881:  // TODO: Should we always try to do this, even if the op is
        -: 1882:  // already legal?
 14887749: 1883:  if (succeeded(legalizeWithFold(op, rewriter))) {
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
  408698*: 1884:    LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1885:      logSuccess(logger, "operation was folded");
        -: 1886:      logger.startLine() << logLineComment;
        -: 1887:    });
   408698: 1888:    return success();
        -: 1889:  }
        -: 1890:
        -: 1891:  // Otherwise, we need to apply a legalization pattern to this operation.
 14479051: 1892:  if (succeeded(legalizeWithPattern(op, rewriter))) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 1893:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1894:      logSuccess(logger, "");
        -: 1895:      logger.startLine() << logLineComment;
        -: 1896:    });
    #####: 1897:    return success();
        -: 1898:  }
        -: 1899:
14479051*: 1900:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -: 1901:    logFailure(logger, "no matched legalization pattern");
        -: 1902:    logger.startLine() << logLineComment;
        -: 1903:  });
 14479051: 1904:  return failure();
        -: 1905:}
        -: 1906:
        -: 1907:LogicalResult
function _ZN12_GLOBAL__N_118OperationLegalizer16legalizeWithFoldEPN4mlir9OperationERNS1_25ConversionPatternRewriterE called 14887749 returned 100% blocks executed 36%
 14887749: 1908:OperationLegalizer::legalizeWithFold(Operation *op,
        -: 1909:                                     ConversionPatternRewriter &rewriter) {
 14887749: 1910:  auto &rewriterImpl = rewriter.getImpl();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 14887749: 1911:  RewriterState curState = rewriterImpl.getCurrentState();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1912:
14887749*: 1913:  LLVM_DEBUG({
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 1914:    rewriterImpl.logger.startLine() << "* Fold {\n";
        -: 1915:    rewriterImpl.logger.indent();
        -: 1916:  });
        -: 1917:
        -: 1918:  // Try to fold the operation.
 14887749: 1919:  SmallVector<Value, 2> replacementValues;
call    0 returned 100%
 14887749: 1920:  rewriter.setInsertionPoint(op);
call    0 returned 100%
 14887749: 1921:  if (failed(rewriter.tryFold(op, replacementValues))) {
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
14479051*: 1922:    LLVM_DEBUG(logFailure(rewriterImpl.logger, "unable to fold"));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
 14479051: 1923:    return failure();
        -: 1924:  }
        -: 1925:
        -: 1926:  // Insert a replacement for 'op' with the folded replacement values.
   408698: 1927:  rewriter.replaceOp(op, replacementValues);
call    0 returned 100%
call    1 returned 100%
        -: 1928:
        -: 1929:  // Recursively legalize any new constant operations.
  408698*: 1930:  for (unsigned i = curState.numCreatedOps, e = rewriterImpl.createdOps.size();
   408698: 1931:       i != e; ++i) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1932:    Operation *cstOp = rewriterImpl.createdOps[i];
branch  0 never executed
branch  1 never executed
    #####: 1933:    if (failed(legalize(cstOp, rewriter))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1934:      LLVM_DEBUG(logFailure(rewriterImpl.logger,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 1935:                            "failed to legalize generated constant '{0}'",
        -: 1936:                            cstOp->getName()));
    #####: 1937:      rewriterImpl.resetState(curState);
call    0 never executed
    #####: 1938:      return failure();
        -: 1939:    }
        -: 1940:  }
        -: 1941:
  408698*: 1942:  LLVM_DEBUG(logSuccess(rewriterImpl.logger, ""));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
 14887749: 1943:  return success();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1944:}
        -: 1945:
        -: 1946:LogicalResult
function _ZN12_GLOBAL__N_118OperationLegalizer19legalizeWithPatternEPN4mlir9OperationERNS1_25ConversionPatternRewriterE called 14479051 returned 100% blocks executed 100%
 14479051: 1947:OperationLegalizer::legalizeWithPattern(Operation *op,
        -: 1948:                                        ConversionPatternRewriter &rewriter) {
 14479051: 1949:  auto &rewriterImpl = rewriter.getImpl();
call    0 returned 100%
        -: 1950:
        -: 1951:  // Functor that returns if the given pattern may be applied.
14479051*: 1952:  auto canApply = [&](const Pattern &pattern) {
    #####: 1953:    return canApplyPattern(op, pattern, rewriter);
call    0 never executed
 14479051: 1954:  };
        -: 1955:
        -: 1956:  // Functor that cleans up the rewriter state after a pattern failed to match.
 14479051: 1957:  RewriterState curState = rewriterImpl.getCurrentState();
call    0 returned 100%
function _ZZN12_GLOBAL__N_118OperationLegalizer19legalizeWithPatternEPN4mlir9OperationERNS1_25ConversionPatternRewriterEENKUlRKNS1_7PatternEE0_clES8_ called 0 returned 0% blocks executed 0%
14479051*: 1958:  auto onFailure = [&](const Pattern &pattern) {
    #####: 1959:    LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
        -: 1960:      logFailure(rewriterImpl.logger, "pattern failed to match");
        -: 1961:      if (rewriterImpl.notifyCallback) {
        -: 1962:        Diagnostic diag(op->getLoc(), DiagnosticSeverity::Remark);
        -: 1963:        diag << "Failed to apply pattern \"" << pattern.getDebugName()
        -: 1964:             << "\" on op:\n"
        -: 1965:             << *op;
        -: 1966:        rewriterImpl.notifyCallback(diag);
        -: 1967:      }
        -: 1968:    });
    #####: 1969:    rewriterImpl.resetState(curState);
call    0 never executed
    #####: 1970:    appliedPatterns.erase(&pattern);
call    0 never executed
14479051*: 1971:  };
        -: 1972:
        -: 1973:  // Functor that performs additional legalization when a pattern is
        -: 1974:  // successfully applied.
function _ZZN12_GLOBAL__N_118OperationLegalizer19legalizeWithPatternEPN4mlir9OperationERNS1_25ConversionPatternRewriterEENKUlRKNS1_7PatternEE1_clES8_ called 0 returned 0% blocks executed 0%
14479051*: 1975:  auto onSuccess = [&](const Pattern &pattern) {
    #####: 1976:    auto result = legalizePatternResult(op, pattern, rewriter, curState);
call    0 never executed
    #####: 1977:    appliedPatterns.erase(&pattern);
call    0 never executed
    #####: 1978:    if (failed(result))
branch  0 never executed
branch  1 never executed
    #####: 1979:      rewriterImpl.resetState(curState);
call    0 never executed
    #####: 1980:    return result;
 14479051: 1981:  };
        -: 1982:
        -: 1983:  // Try to match and rewrite a pattern on this operation.
 14479051: 1984:  return applicator.matchAndRewrite(op, rewriter, canApply, onFailure,
 14479051: 1985:                                    onSuccess);
call    0 returned 100%
        -: 1986:}
        -: 1987:
function _ZN12_GLOBAL__N_118OperationLegalizer15canApplyPatternEPN4mlir9OperationERKNS1_7PatternERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1988:bool OperationLegalizer::canApplyPattern(Operation *op, const Pattern &pattern,
        -: 1989:                                         ConversionPatternRewriter &rewriter) {
    #####: 1990:  LLVM_DEBUG({
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
        -: 1991:    auto &os = rewriter.getImpl().logger;
        -: 1992:    os.getOStream() << "\n";
        -: 1993:    os.startLine() << "* Pattern : '" << op->getName() << " -> (";
        -: 1994:    llvm::interleaveComma(pattern.getGeneratedOps(), os.getOStream());
        -: 1995:    os.getOStream() << ")' {\n";
        -: 1996:    os.indent();
        -: 1997:  });
        -: 1998:
        -: 1999:  // Ensure that we don't cycle by not allowing the same pattern to be
        -: 2000:  // applied twice in the same recursion stack if it is not known to be safe.
    #####: 2001:  if (!pattern.hasBoundedRewriteRecursion() &&
branch  0 never executed
branch  1 never executed
    #####: 2002:      !appliedPatterns.insert(&pattern).second) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2003:    LLVM_DEBUG(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -: 2004:        logFailure(rewriter.getImpl().logger, "pattern was already applied"));
    #####: 2005:    return false;
        -: 2006:  }
        -: 2007:  return true;
        -: 2008:}
        -: 2009:
        -: 2010:LogicalResult
        -: 2011:OperationLegalizer::legalizePatternResult(Operation *op, const Pattern &pattern,
        -: 2012:                                          ConversionPatternRewriter &rewriter,
        -: 2013:                                          RewriterState &curState) {
        -: 2014:  auto &impl = rewriter.getImpl();
        -: 2015:
        -: 2016:#ifndef NDEBUG
        -: 2017:  assert(impl.pendingRootUpdates.empty() && "dangling root updates");
        -: 2018:#endif
        -: 2019:
        -: 2020:  // Check that the root was either replaced or updated in place.
function _ZZN12_GLOBAL__N_118OperationLegalizer21legalizePatternResultEPN4mlir9OperationERKNS1_7PatternERNS1_25ConversionPatternRewriterERNS_13RewriterStateEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####: 2021:  auto replacedRoot = [&] {
    #####: 2022:    return llvm::any_of(
    #####: 2023:        llvm::drop_begin(impl.replacements, curState.numReplacements),
call    0 never executed
    #####: 2024:        [op](auto &it) { return it.first == op; });
branch  0 never executed
branch  1 never executed
        -: 2025:  };
function _ZZN12_GLOBAL__N_118OperationLegalizer21legalizePatternResultEPN4mlir9OperationERKNS1_7PatternERNS1_25ConversionPatternRewriterERNS_13RewriterStateEENKUlvE0_clEv called 0 returned 0% blocks executed 0%
    #####: 2026:  auto updatedRootInPlace = [&] {
    #####: 2027:    return llvm::any_of(
    #####: 2028:        llvm::drop_begin(impl.rootUpdates, curState.numRootUpdates),
    #####: 2029:        [op](auto &state) { return state.getOperation() == op; });
branch  0 never executed
branch  1 never executed
        -: 2030:  };
        -: 2031:  (void)replacedRoot;
        -: 2032:  (void)updatedRootInPlace;
        -: 2033:  assert((replacedRoot() || updatedRootInPlace()) &&
        -: 2034:         "expected pattern to replace the root operation");
        -: 2035:
        -: 2036:  // Legalize each of the actions registered during application.
        -: 2037:  RewriterState newState = impl.getCurrentState();
        -: 2038:  if (failed(legalizePatternBlockActions(op, rewriter, impl, curState,
        -: 2039:                                         newState)) ||
        -: 2040:      failed(legalizePatternRootUpdates(rewriter, impl, curState, newState)) ||
        -: 2041:      failed(legalizePatternCreatedOperations(rewriter, impl, curState,
        -: 2042:                                              newState))) {
        -: 2043:    return failure();
        -: 2044:  }
        -: 2045:
        -: 2046:  LLVM_DEBUG(logSuccess(impl.logger, "pattern applied successfully"));
        -: 2047:  return success();
        -: 2048:}
        -: 2049:
        -: 2050:LogicalResult OperationLegalizer::legalizePatternBlockActions(
        -: 2051:    Operation *op, ConversionPatternRewriter &rewriter,
        -: 2052:    ConversionPatternRewriterImpl &impl, RewriterState &state,
        -: 2053:    RewriterState &newState) {
        -: 2054:  SmallPtrSet<Operation *, 16> operationsToIgnore;
        -: 2055:
        -: 2056:  // If the pattern moved or created any blocks, make sure the types of block
        -: 2057:  // arguments get legalized.
        -: 2058:  for (int i = state.numBlockActions, e = newState.numBlockActions; i != e;
        -: 2059:       ++i) {
        -: 2060:    auto &action = impl.blockActions[i];
        -: 2061:    if (action.kind == BlockActionKind::TypeConversion ||
        -: 2062:        action.kind == BlockActionKind::Erase)
        -: 2063:      continue;
        -: 2064:    // Only check blocks outside of the current operation.
        -: 2065:    Operation *parentOp = action.block->getParentOp();
        -: 2066:    if (!parentOp || parentOp == op || action.block->getNumArguments() == 0)
        -: 2067:      continue;
        -: 2068:
        -: 2069:    // If the region of the block has a type converter, try to convert the block
        -: 2070:    // directly.
        -: 2071:    if (auto *converter =
        -: 2072:            impl.argConverter.getConverter(action.block->getParent())) {
        -: 2073:      if (failed(impl.convertBlockSignature(action.block, converter))) {
        -: 2074:        LLVM_DEBUG(logFailure(impl.logger, "failed to convert types of moved "
        -: 2075:                                           "block"));
        -: 2076:        return failure();
        -: 2077:      }
        -: 2078:      continue;
        -: 2079:    }
        -: 2080:
        -: 2081:    // Otherwise, check that this operation isn't one generated by this pattern.
        -: 2082:    // This is because we will attempt to legalize the parent operation, and
        -: 2083:    // blocks in regions created by this pattern will already be legalized later
        -: 2084:    // on. If we haven't built the set yet, build it now.
        -: 2085:    if (operationsToIgnore.empty()) {
        -: 2086:      auto createdOps = ArrayRef<Operation *>(impl.createdOps)
        -: 2087:                            .drop_front(state.numCreatedOps);
        -: 2088:      operationsToIgnore.insert(createdOps.begin(), createdOps.end());
        -: 2089:    }
        -: 2090:
        -: 2091:    // If this operation should be considered for re-legalization, try it.
        -: 2092:    if (operationsToIgnore.insert(parentOp).second &&
        -: 2093:        failed(legalize(parentOp, rewriter))) {
        -: 2094:      LLVM_DEBUG(logFailure(
        -: 2095:          impl.logger, "operation '{0}'({1}) became illegal after block action",
        -: 2096:          parentOp->getName(), parentOp));
        -: 2097:      return failure();
        -: 2098:    }
        -: 2099:  }
        -: 2100:  return success();
        -: 2101:}
        -: 2102:
        -: 2103:LogicalResult OperationLegalizer::legalizePatternCreatedOperations(
        -: 2104:    ConversionPatternRewriter &rewriter, ConversionPatternRewriterImpl &impl,
        -: 2105:    RewriterState &state, RewriterState &newState) {
        -: 2106:  for (int i = state.numCreatedOps, e = newState.numCreatedOps; i != e; ++i) {
        -: 2107:    Operation *op = impl.createdOps[i];
        -: 2108:    if (failed(legalize(op, rewriter))) {
        -: 2109:      LLVM_DEBUG(logFailure(impl.logger,
        -: 2110:                            "failed to legalize generated operation '{0}'({1})",
        -: 2111:                            op->getName(), op));
        -: 2112:      return failure();
        -: 2113:    }
        -: 2114:  }
        -: 2115:  return success();
        -: 2116:}
        -: 2117:
        -: 2118:LogicalResult OperationLegalizer::legalizePatternRootUpdates(
        -: 2119:    ConversionPatternRewriter &rewriter, ConversionPatternRewriterImpl &impl,
        -: 2120:    RewriterState &state, RewriterState &newState) {
        -: 2121:  for (int i = state.numRootUpdates, e = newState.numRootUpdates; i != e; ++i) {
        -: 2122:    Operation *op = impl.rootUpdates[i].getOperation();
        -: 2123:    if (failed(legalize(op, rewriter))) {
        -: 2124:      LLVM_DEBUG(logFailure(
        -: 2125:          impl.logger, "failed to legalize operation updated in-place '{0}'",
        -: 2126:          op->getName()));
        -: 2127:      return failure();
        -: 2128:    }
        -: 2129:  }
        -: 2130:  return success();
        -: 2131:}
        -: 2132:
        -: 2133://===----------------------------------------------------------------------===//
        -: 2134:// Cost Model
        -: 2135:
function _ZN12_GLOBAL__N_118OperationLegalizer22buildLegalizationGraphERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameES7_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_S7_EEEE called 35726 returned 100% blocks executed 86%
    35726: 2136:void OperationLegalizer::buildLegalizationGraph(
        -: 2137:    LegalizationPatterns &anyOpLegalizerPatterns,
        -: 2138:    DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns) {
        -: 2139:  // A mapping between an operation and a set of operations that can be used to
        -: 2140:  // generate it.
    69659: 2141:  DenseMap<OperationName, SmallPtrSet<OperationName, 2>> parentOps;
call    0 returned 100%
call    1 returned 100%
        -: 2142:  // A mapping between an operation and any currently invalid patterns it has.
    69659: 2143:  DenseMap<OperationName, SmallPtrSet<const Pattern *, 2>> invalidPatterns;
call    0 returned 100%
call    1 returned 100%
        -: 2144:  // A worklist of patterns to consider for legality.
    69659: 2145:  SetVector<const Pattern *> patternWorklist;
call    0 returned 100%
call    1 returned 100%
        -: 2146:
        -: 2147:  // Build the mapping from operations to the parent ops that may generate them.
function _ZZN12_GLOBAL__N_118OperationLegalizer22buildLegalizationGraphERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameES7_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_S7_EEEEENKUlRS5_E_clESI_ called 771799 returned 100% blocks executed 89%
    35726: 2148:  applicator.walkAllPatterns([&](const Pattern &pattern) {
call    0 returned 100%
   771799: 2149:    Optional<OperationName> root = pattern.getRootKind();
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -: 2150:
        -: 2151:    // If the pattern has no specific root, we can't analyze the relationship
        -: 2152:    // between the root op and generated operations. Given that, add all such
        -: 2153:    // patterns to the legalization set.
   771799: 2154:    if (!root) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    12376: 2155:      anyOpLegalizerPatterns.push_back(&pattern);
    24752: 2156:      return;
call    0 returned 100%
        -: 2157:    }
        -: 2158:
        -: 2159:    // Skip operations that are always known to be legal.
 1027814*: 2160:    if (target.getOpAction(*root) == LegalizationAction::Legal)
call    0 returned 100%
branch  1 taken 65% (fallthrough)
branch  2 taken 35%
    #####: 2161:      return;
        -: 2162:
        -: 2163:    // Add this pattern to the invalid set for the root op and record this root
        -: 2164:    // as a parent for any generated operations.
   759423: 2165:    invalidPatterns[*root].insert(&pattern);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
   798167: 2166:    for (auto op : pattern.getGeneratedOps())
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
    38744: 2167:      parentOps[op].insert(*root);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -: 2168:
        -: 2169:    // Add this pattern to the worklist.
   759423: 2170:    patternWorklist.insert(&pattern);
call    0 returned 100%
        -: 2171:  });
        -: 2172:
        -: 2173:  // If there are any patterns that don't have a specific root kind, we can't
        -: 2174:  // make direct assumptions about what operations will never be legalized.
        -: 2175:  // Note: Technically we could, but it would require an analysis that may
        -: 2176:  // recurse into itself. It would be better to perform this kind of filtering
        -: 2177:  // at a higher level than here anyways.
    35726: 2178:  if (!anyOpLegalizerPatterns.empty()) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     3386: 2179:    for (const Pattern *pattern : patternWorklist)
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     3186: 2180:      legalizerPatterns[*pattern->getRootKind()].push_back(pattern);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
call    5 returned 100%
     1793: 2181:    return;
call    0 returned 100%
        -: 2182:  }
        -: 2183:
   793491: 2184:  while (!patternWorklist.empty()) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
   759558: 2185:    auto *pattern = patternWorklist.pop_back_val();
call    0 returned 100%
        -: 2186:
        -: 2187:    // Check to see if any of the generated operations are invalid.
function _ZZN12_GLOBAL__N_118OperationLegalizer22buildLegalizationGraphERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameES7_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_S7_EEEEENKUlSA_E0_clESA_.isra.0 called 34367 returned 100% blocks executed 89%
   793925: 2188:    if (llvm::any_of(pattern->getGeneratedOps(), [&](OperationName op) {
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
    34367: 2189:          Optional<LegalizationAction> action = target.getOpAction(op);
call    0 returned 100%
    68734: 2190:          return !legalizerPatterns.count(op) &&
call    0 returned 100%
branch  1 taken 11% (fallthrough)
branch  2 taken 89%
    31283: 2191:                 (!action || action == LegalizationAction::Illegal);
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2192:        }))
    27687: 2193:      continue;
        -: 2194:
        -: 2195:    // Otherwise, if all of the generated operation are valid, this op is now
        -: 2196:    // legal so add all of the child patterns to the worklist.
  1463742: 2197:    legalizerPatterns[*pattern->getRootKind()].push_back(pattern);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
call    5 returned 100%
  1463742: 2198:    invalidPatterns[*pattern->getRootKind()].erase(pattern);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
call    5 returned 100%
        -: 2199:
        -: 2200:    // Add any invalid patterns of the parent operations to see if they have now
        -: 2201:    // become legal.
  1467335: 2202:    for (auto op : parentOps[*pattern->getRootKind()])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
call    5 returned 100%
call    6 returned 100%
branch  7 taken 1% (fallthrough)
branch  8 taken 100%
call    9 returned 100%
call   10 returned 100%
     3593: 2203:      patternWorklist.set_union(invalidPatterns[op]);
call    0 returned 100%
call    1 returned 100%
        -: 2204:  }
        -: 2205:}
        -: 2206:
function _ZN12_GLOBAL__N_118OperationLegalizer31computeLegalizationGraphBenefitERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameES7_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_S7_EEEE called 35726 returned 100% blocks executed 100%
    35726: 2207:void OperationLegalizer::computeLegalizationGraphBenefit(
        -: 2208:    LegalizationPatterns &anyOpLegalizerPatterns,
        -: 2209:    DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns) {
        -: 2210:  // The smallest pattern depth, when legalizing an operation.
    35726: 2211:  DenseMap<OperationName, unsigned> minOpPatternDepth;
call    0 returned 100%
        -: 2212:
        -: 2213:  // For each operation that is transitively legal, compute a cost for it.
   721275: 2214:  for (auto &opIt : legalizerPatterns)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 95% (fallthrough)
branch  4 taken 5%
call    5 returned 100%
call    6 returned 100%
   651343: 2215:    if (!minOpPatternDepth.count(opIt.first))
call    0 returned 100%
   648303: 2216:      computeOpLegalizationDepth(opIt.first, minOpPatternDepth,
call    0 returned 100%
        -: 2217:                                 legalizerPatterns);
        -: 2218:
        -: 2219:  // Apply the cost model to the patterns that can match any operation. Those
        -: 2220:  // with a specific operation type are already resolved when computing the op
        -: 2221:  // legalization depth.
    35726: 2222:  if (!anyOpLegalizerPatterns.empty())
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     1793: 2223:    applyCostModelToPatterns(anyOpLegalizerPatterns, minOpPatternDepth,
call    0 returned 100%
        -: 2224:                             legalizerPatterns);
        -: 2225:
        -: 2226:  // Apply a cost model to the pattern applicator. We order patterns first by
        -: 2227:  // depth then benefit. `legalizerPatterns` contains per-op patterns by
        -: 2228:  // decreasing benefit.
function _ZZN12_GLOBAL__N_118OperationLegalizer31computeLegalizationGraphBenefitERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameES7_NS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_S7_EEEEENKUlRS5_E_clESI_.isra.0 called 771799 returned 100% blocks executed 100%
    35726: 2229:  applicator.applyCostModel([&](const Pattern &pattern) {
call    0 returned 100%
call    1 returned 100%
   771799: 2230:    ArrayRef<const Pattern *> orderedPatternList;
  1543598: 2231:    if (Optional<OperationName> rootName = pattern.getRootKind())
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
   759423: 2232:      orderedPatternList = legalizerPatterns[*rootName];
call    0 returned 100%
        -: 2233:    else
    12376: 2234:      orderedPatternList = anyOpLegalizerPatterns;
        -: 2235:
        -: 2236:    // If the pattern is not found, then it was removed and cannot be matched.
   771799: 2237:    auto *it = llvm::find(orderedPatternList, &pattern);
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
   771799: 2238:    if (it == orderedPatternList.end())
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
    25959: 2239:      return PatternBenefit::impossibleToMatch();
        -: 2240:
        -: 2241:    // Patterns found earlier in the list have higher benefit.
   745840: 2242:    return PatternBenefit(std::distance(it, orderedPatternList.end()));
call    0 returned 100%
        -: 2243:  });
    35726: 2244:}
        -: 2245:
function _ZN12_GLOBAL__N_118OperationLegalizer26computeOpLegalizationDepthEN4mlir13OperationNameERN4llvm8DenseMapIS2_jNS3_12DenseMapInfoIS2_vEENS3_6detail12DenseMapPairIS2_jEEEERNS4_IS2_NS3_11SmallVectorIPKNS1_7PatternELj1EEES6_NS8_IS2_SG_EEEE called 654471 returned 100% blocks executed 100%
   654471: 2246:unsigned OperationLegalizer::computeOpLegalizationDepth(
        -: 2247:    OperationName op, DenseMap<OperationName, unsigned> &minOpPatternDepth,
        -: 2248:    DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns) {
        -: 2249:  // Check for existing depth.
   654471: 2250:  auto depthIt = minOpPatternDepth.find(op);
call    0 returned 100%
   654471: 2251:  if (depthIt != minOpPatternDepth.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
     1564: 2252:    return depthIt->second;
call    0 returned 100%
        -: 2253:
        -: 2254:  // If a mapping for this operation does not exist, then this operation
        -: 2255:  // is always legal. Return 0 as the depth for a directly legal operation.
   652907: 2256:  auto opPatternsIt = legalizerPatterns.find(op);
call    0 returned 100%
   652907: 2257:  if (opPatternsIt == legalizerPatterns.end() || opPatternsIt->second.empty())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 1%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     3084: 2258:    return 0u;
        -: 2259:
        -: 2260:  // Record this initial depth in case we encounter this op again when
        -: 2261:  // recursively computing the depth.
   649823: 2262:  minOpPatternDepth.try_emplace(op, std::numeric_limits<unsigned>::max());
call    0 returned 100%
        -: 2263:
        -: 2264:  // Apply the cost model to the operation patterns, and update the minimum
        -: 2265:  // depth.
  1949469: 2266:  unsigned minDepth = applyCostModelToPatterns(
   649823: 2267:      opPatternsIt->second, minOpPatternDepth, legalizerPatterns);
call    0 returned 100%
call    1 returned 100%
   649823: 2268:  minOpPatternDepth[op] = minDepth;
call    0 returned 100%
   649823: 2269:  return minDepth;
        -: 2270:}
        -: 2271:
function _ZN12_GLOBAL__N_118OperationLegalizer24applyCostModelToPatternsERN4llvm11SmallVectorIPKN4mlir7PatternELj1EEERNS1_8DenseMapINS3_13OperationNameEjNS1_12DenseMapInfoISA_vEENS1_6detail12DenseMapPairISA_jEEEERNS9_ISA_S7_SC_NSE_ISA_S7_EEEE called 651616 returned 100% blocks executed 100%
   651616: 2272:unsigned OperationLegalizer::applyCostModelToPatterns(
        -: 2273:    LegalizationPatterns &patterns,
        -: 2274:    DenseMap<OperationName, unsigned> &minOpPatternDepth,
        -: 2275:    DenseMap<OperationName, LegalizationPatterns> &legalizerPatterns) {
   651616: 2276:  unsigned minDepth = std::numeric_limits<unsigned>::max();
        -: 2277:
        -: 2278:  // Compute the depth for each pattern within the set.
   651616: 2279:  SmallVector<std::pair<const Pattern *, unsigned>, 4> patternsByDepth;
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
   651616: 2280:  patternsByDepth.reserve(patterns.size());
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
  1397456: 2281:  for (const Pattern *pattern : patterns) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
   745840: 2282:    unsigned depth = 1;
   752008: 2283:    for (auto generatedOp : pattern->getGeneratedOps()) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
     6168: 2284:      unsigned generatedOpDepth = computeOpLegalizationDepth(
call    0 returned 100%
        -: 2285:          generatedOp, minOpPatternDepth, legalizerPatterns);
     9252: 2286:      depth = std::max(depth, generatedOpDepth + 1);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -: 2287:    }
   745840: 2288:    patternsByDepth.emplace_back(pattern, depth);
call    0 returned 100%
        -: 2289:
        -: 2290:    // Update the minimum depth of the pattern list.
  1397701: 2291:    minDepth = std::min(minDepth, depth);
branch  0 taken 87% (fallthrough)
branch  1 taken 13%
        -: 2292:  }
        -: 2293:
        -: 2294:  // If the operation only has one legalization pattern, there is no need to
        -: 2295:  // sort them.
   651616: 2296:  if (patternsByDepth.size() == 1)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
   584958: 2297:    return minDepth;
        -: 2298:
        -: 2299:  // Sort the patterns by those likely to be the most beneficial.
    66658: 2300:  llvm::array_pod_sort(patternsByDepth.begin(), patternsByDepth.end(),
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2301:                       [](const std::pair<const Pattern *, unsigned> *lhs,
        -: 2302:                          const std::pair<const Pattern *, unsigned> *rhs) {
        -: 2303:                         // First sort by the smaller pattern legalization
        -: 2304:                         // depth.
        -: 2305:                         if (lhs->second != rhs->second)
        -: 2306:                           return llvm::array_pod_sort_comparator<unsigned>(
        -: 2307:                               &lhs->second, &rhs->second);
        -: 2308:
        -: 2309:                         // Then sort by the larger pattern benefit.
        -: 2310:                         auto lhsBenefit = lhs->first->getBenefit();
        -: 2311:                         auto rhsBenefit = rhs->first->getBenefit();
        -: 2312:                         return llvm::array_pod_sort_comparator<PatternBenefit>(
        -: 2313:                             &rhsBenefit, &lhsBenefit);
        -: 2314:                       });
        -: 2315:
        -: 2316:  // Update the legalization pattern to use the new sorted list.
    66658: 2317:  patterns.clear();
   227540: 2318:  for (auto &patternIt : patternsByDepth)
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
   160882: 2319:    patterns.push_back(patternIt.first);
call    0 returned 100%
    66658: 2320:  return minDepth;
        -: 2321:}
        -: 2322:
        -: 2323://===----------------------------------------------------------------------===//
        -: 2324:// OperationConverter
        -: 2325://===----------------------------------------------------------------------===//
        -: 2326:namespace {
        -: 2327:enum OpConversionMode {
        -: 2328:  /// In this mode, the conversion will ignore failed conversions to allow
        -: 2329:  /// illegal operations to co-exist in the IR.
        -: 2330:  Partial,
        -: 2331:
        -: 2332:  /// In this mode, all operations must be legal for the given target for the
        -: 2333:  /// conversion to succeed.
        -: 2334:  Full,
        -: 2335:
        -: 2336:  /// In this mode, operations are analyzed for legality. No actual rewrites are
        -: 2337:  /// applied to the operations on success.
        -: 2338:  Analysis,
        -: 2339:};
        -: 2340:
        -: 2341:// This class converts operations to a given conversion target via a set of
        -: 2342:// rewrite patterns. The conversion behaves differently depending on the
        -: 2343:// conversion mode.
   35726*: 2344:struct OperationConverter {
   35726*: 2345:  explicit OperationConverter(ConversionTarget &target,
        -: 2346:                              const FrozenRewritePatternSet &patterns,
        -: 2347:                              OpConversionMode mode,
        -: 2348:                              DenseSet<Operation *> *trackedOps = nullptr)
   71452*: 2349:      : opLegalizer(target, patterns), mode(mode), trackedOps(trackedOps) {}
        -: 2350:
        -: 2351:  /// Converts the given operations to the conversion target.
        -: 2352:  LogicalResult
        -: 2353:  convertOperations(ArrayRef<Operation *> ops,
        -: 2354:                    function_ref<void(Diagnostic &)> notifyCallback = nullptr);
        -: 2355:
        -: 2356:private:
        -: 2357:  /// Converts an operation with the given rewriter.
        -: 2358:  LogicalResult convert(ConversionPatternRewriter &rewriter, Operation *op);
        -: 2359:
        -: 2360:  /// This method is called after the conversion process to legalize any
        -: 2361:  /// remaining artifacts and complete the conversion.
        -: 2362:  LogicalResult finalize(ConversionPatternRewriter &rewriter);
        -: 2363:
        -: 2364:  /// Legalize the types of converted block arguments.
        -: 2365:  LogicalResult
        -: 2366:  legalizeConvertedArgumentTypes(ConversionPatternRewriter &rewriter,
        -: 2367:                                 ConversionPatternRewriterImpl &rewriterImpl);
        -: 2368:
        -: 2369:  /// Legalize any unresolved type materializations.
        -: 2370:  LogicalResult legalizeUnresolvedMaterializations(
        -: 2371:      ConversionPatternRewriter &rewriter,
        -: 2372:      ConversionPatternRewriterImpl &rewriterImpl,
        -: 2373:      Optional<DenseMap<Value, SmallVector<Value>>> &inverseMapping);
        -: 2374:
        -: 2375:  /// Legalize an operation result that was marked as "erased".
        -: 2376:  LogicalResult
        -: 2377:  legalizeErasedResult(Operation *op, OpResult result,
        -: 2378:                       ConversionPatternRewriterImpl &rewriterImpl);
        -: 2379:
        -: 2380:  /// Legalize an operation result that was replaced with a value of a different
        -: 2381:  /// type.
        -: 2382:  LogicalResult legalizeChangedResultType(
        -: 2383:      Operation *op, OpResult result, Value newValue,
        -: 2384:      TypeConverter *replConverter, ConversionPatternRewriter &rewriter,
        -: 2385:      ConversionPatternRewriterImpl &rewriterImpl,
        -: 2386:      const DenseMap<Value, SmallVector<Value>> &inverseMapping);
        -: 2387:
        -: 2388:  /// The legalizer to use when converting operations.
        -: 2389:  OperationLegalizer opLegalizer;
        -: 2390:
        -: 2391:  /// The conversion mode to use when legalizing operations.
        -: 2392:  OpConversionMode mode;
        -: 2393:
        -: 2394:  /// A set of pre-existing operations. When mode == OpConversionMode::Analysis,
        -: 2395:  /// this is populated with ops found to be legalizable to the target.
        -: 2396:  /// When mode == OpConversionMode::Partial, this is populated with ops found
        -: 2397:  /// *not* to be legalizable to the target.
        -: 2398:  DenseSet<Operation *> *trackedOps;
        -: 2399:};
        -: 2400:} // namespace
        -: 2401:
function _ZN12_GLOBAL__N_118OperationConverter7convertERN4mlir25ConversionPatternRewriterEPNS1_9OperationE called 26749714 returned 100% blocks executed 67%
 26749714: 2402:LogicalResult OperationConverter::convert(ConversionPatternRewriter &rewriter,
        -: 2403:                                          Operation *op) {
        -: 2404:  // Legalize the given operation.
 26749714: 2405:  if (failed(opLegalizer.legalize(op, rewriter))) {
call    0 returned 100%
branch  1 taken 54% (fallthrough)
branch  2 taken 46%
        -: 2406:    // Handle the case of a failed conversion for each of the different modes.
        -: 2407:    // Full conversions expect all operations to be converted.
 14479051: 2408:    if (mode == OpConversionMode::Full)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     1054: 2409:      return op->emitError()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      527: 2410:             << "failed to legalize operation '" << op->getName() << "'";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        -: 2411:    // Partial conversions allow conversions to fail iff the operation was not
        -: 2412:    // explicitly marked as illegal. If the user provided a nonlegalizableOps
        -: 2413:    // set, non-legalizable ops are included.
 14478524: 2414:    if (mode == OpConversionMode::Partial) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 14478524: 2415:      if (opLegalizer.isIllegal(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2416:        return op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2417:               << "failed to legalize operation '" << op->getName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2418:               << "' that was explicitly marked illegal";
call    0 never executed
 14478524: 2419:      if (trackedOps)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
   764661: 2420:        trackedOps->insert(op);
call    0 returned 100%
        -: 2421:    }
 12270663: 2422:  } else if (mode == OpConversionMode::Analysis) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2423:    // Analysis conversions don't fail if any operations fail to legalize,
        -: 2424:    // they are only interested in the operations that were successfully
        -: 2425:    // legalized.
    #####: 2426:    trackedOps->insert(op);
call    0 never executed
        -: 2427:  }
 26749187: 2428:  return success();
        -: 2429:}
        -: 2430:
function _ZN12_GLOBAL__N_118OperationConverter17convertOperationsEN4llvm8ArrayRefIPN4mlir9OperationEEENS1_12function_refIFvRNS3_10DiagnosticEEEE called 35726 returned 100% blocks executed 88%
    35726: 2431:LogicalResult OperationConverter::convertOperations(
        -: 2432:    ArrayRef<Operation *> ops,
        -: 2433:    function_ref<void(Diagnostic &)> notifyCallback) {
    35726: 2434:  if (ops.empty())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2435:    return success();
    35726: 2436:  ConversionTarget &target = opLegalizer.getTarget();
        -: 2437:
        -: 2438:  // Compute the set of operations and blocks to convert.
    35726: 2439:  SmallVector<Operation *> toConvert;
    71452: 2440:  for (auto *op : ops) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    35726: 2441:    toConvert.emplace_back(op);
call    0 returned 100%
   107178: 2442:    for (auto &region : op->getRegions())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
    35726: 2443:      if (failed(computeConversionSet(region.getBlocks(), region.getLoc(),
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2444:                                      toConvert, &target)))
    #####: 2445:        return failure();
        -: 2446:  }
        -: 2447:
        -: 2448:  // Convert each operation and discard rewrites on failure.
    35726: 2449:  ConversionPatternRewriter rewriter(ops.front()->getContext());
call    0 returned 100%
call    1 returned 100%
    35726: 2450:  ConversionPatternRewriterImpl &rewriterImpl = rewriter.getImpl();
    35726: 2451:  rewriterImpl.notifyCallback = notifyCallback;
        -: 2452:
 26784913: 2453:  for (auto *op : toConvert)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
 26749714: 2454:    if (failed(convert(rewriter, op)))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
      527: 2455:      return rewriterImpl.discardRewrites(), failure();
call    0 returned 100%
        -: 2456:
        -: 2457:  // Now that all of the operations have been converted, finalize the conversion
        -: 2458:  // process to ensure any lingering conversion artifacts are cleaned up and
        -: 2459:  // legalized.
    35199: 2460:  if (failed(finalize(rewriter)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2461:    return rewriterImpl.discardRewrites(), failure();
call    0 never executed
        -: 2462:
        -: 2463:  // After a successful conversion, apply rewrites if this is not an analysis
        -: 2464:  // conversion.
    35199: 2465:  if (mode == OpConversionMode::Analysis) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2466:    rewriterImpl.discardRewrites();
call    0 never executed
        -: 2467:  } else {
    35199: 2468:    rewriterImpl.applyRewrites();
call    0 returned 100%
        -: 2469:
        -: 2470:    // It is possible for a later pattern to erase an op that was originally
        -: 2471:    // identified as illegal and added to the trackedOps, remove it now after
        -: 2472:    // replacements have been computed.
    35199: 2473:    if (trackedOps)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
    25046: 2474:      for (auto &repl : rewriterImpl.replacements)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
    24039: 2475:        trackedOps->erase(repl.first);
call    0 returned 100%
        -: 2476:  }
    35726: 2477:  return success();
call    0 returned 100%
        -: 2478:}
        -: 2479:
        -: 2480:LogicalResult
        -: 2481:OperationConverter::finalize(ConversionPatternRewriter &rewriter) {
        -: 2482:  Optional<DenseMap<Value, SmallVector<Value>>> inverseMapping;
        -: 2483:  ConversionPatternRewriterImpl &rewriterImpl = rewriter.getImpl();
        -: 2484:  if (failed(legalizeUnresolvedMaterializations(rewriter, rewriterImpl,
        -: 2485:                                                inverseMapping)) ||
        -: 2486:      failed(legalizeConvertedArgumentTypes(rewriter, rewriterImpl)))
        -: 2487:    return failure();
        -: 2488:
        -: 2489:  if (rewriterImpl.operationsWithChangedResults.empty())
        -: 2490:    return success();
        -: 2491:
        -: 2492:  // Process requested operation replacements.
        -: 2493:  for (unsigned i = 0, e = rewriterImpl.operationsWithChangedResults.size();
        -: 2494:       i != e; ++i) {
        -: 2495:    unsigned replIdx = rewriterImpl.operationsWithChangedResults[i];
        -: 2496:    auto &repl = *(rewriterImpl.replacements.begin() + replIdx);
        -: 2497:    for (OpResult result : repl.first->getResults()) {
        -: 2498:      Value newValue = rewriterImpl.mapping.lookupOrNull(result);
        -: 2499:
        -: 2500:      // If the operation result was replaced with null, all of the uses of this
        -: 2501:      // value should be replaced.
        -: 2502:      if (!newValue) {
        -: 2503:        if (failed(legalizeErasedResult(repl.first, result, rewriterImpl)))
        -: 2504:          return failure();
        -: 2505:        continue;
        -: 2506:      }
        -: 2507:
        -: 2508:      // Otherwise, check to see if the type of the result changed.
        -: 2509:      if (result.getType() == newValue.getType())
        -: 2510:        continue;
        -: 2511:
        -: 2512:      // Compute the inverse mapping only if it is really needed.
        -: 2513:      if (!inverseMapping)
        -: 2514:        inverseMapping = rewriterImpl.mapping.getInverse();
        -: 2515:
        -: 2516:      // Legalize this result.
        -: 2517:      rewriter.setInsertionPoint(repl.first);
        -: 2518:      if (failed(legalizeChangedResultType(repl.first, result, newValue,
        -: 2519:                                           repl.second.converter, rewriter,
        -: 2520:                                           rewriterImpl, *inverseMapping)))
        -: 2521:        return failure();
        -: 2522:
        -: 2523:      // Update the end iterator for this loop in the case it was updated
        -: 2524:      // when legalizing generated conversion operations.
        -: 2525:      e = rewriterImpl.operationsWithChangedResults.size();
        -: 2526:    }
        -: 2527:  }
        -: 2528:  return success();
        -: 2529:}
        -: 2530:
        -: 2531:LogicalResult OperationConverter::legalizeConvertedArgumentTypes(
        -: 2532:    ConversionPatternRewriter &rewriter,
        -: 2533:    ConversionPatternRewriterImpl &rewriterImpl) {
        -: 2534:  // Functor used to check if all users of a value will be dead after
        -: 2535:  // conversion.
function _ZZN12_GLOBAL__N_118OperationConverter30legalizeConvertedArgumentTypesERN4mlir25ConversionPatternRewriterERNS1_6detail29ConversionPatternRewriterImplEENKUlNS1_5ValueEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2536:  auto findLiveUser = [&](Value val) {
    #####: 2537:    auto liveUserIt = llvm::find_if_not(val.getUsers(), [&](Operation *user) {
    #####: 2538:      return rewriterImpl.isOpIgnored(user);
call    0 never executed
    #####: 2539:    });
call    0 never executed
    #####: 2540:    return liveUserIt == val.user_end() ? nullptr : *liveUserIt;
branch  0 never executed
branch  1 never executed
        -: 2541:  };
        -: 2542:  return rewriterImpl.argConverter.materializeLiveConversions(
        -: 2543:      rewriterImpl.mapping, rewriter, findLiveUser);
        -: 2544:}
        -: 2545:
        -: 2546:/// Replace the results of a materialization operation with the given values.
        -: 2547:static void
function _ZL22replaceMaterializationRN4mlir6detail29ConversionPatternRewriterImplENS_11ResultRangeENS_10ValueRangeERN4llvm8DenseMapINS_5ValueENS5_11SmallVectorIS7_Lj6EEENS5_12DenseMapInfoIS7_vEENS5_6detail12DenseMapPairIS7_S9_EEEE called 0 returned 0% blocks executed 0%
    #####: 2548:replaceMaterialization(ConversionPatternRewriterImpl &rewriterImpl,
        -: 2549:                       ResultRange matResults, ValueRange values,
        -: 2550:                       DenseMap<Value, SmallVector<Value>> &inverseMapping) {
    #####: 2551:  matResults.replaceAllUsesWith(values);
call    0 never executed
        -: 2552:
        -: 2553:  // For each of the materialization results, update the inverse mappings to
        -: 2554:  // point to the replacement values.
    #####: 2555:  for (auto [matResult, newValue] : llvm::zip(matResults, values)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2556:    auto inverseMapIt = inverseMapping.find(matResult);
call    0 never executed
    #####: 2557:    if (inverseMapIt == inverseMapping.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2558:      continue;
        -: 2559:
        -: 2560:    // Update the reverse mapping, or remove the mapping if we couldn't update
        -: 2561:    // it. Not being able to update signals that the mapping would have become
        -: 2562:    // circular (i.e. %foo -> newValue -> %foo), which may occur as values are
        -: 2563:    // propagated through temporary materializations. We simply drop the
        -: 2564:    // mapping, and let the post-conversion replacement logic handle updating
        -: 2565:    // uses.
    #####: 2566:    for (Value inverseMapVal : inverseMapIt->second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2567:      if (!rewriterImpl.mapping.tryMap(inverseMapVal, newValue))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2568:        rewriterImpl.mapping.erase(inverseMapVal);
call    0 never executed
        -: 2569:  }
    #####: 2570:}
        -: 2571:
        -: 2572:/// Compute all of the unresolved materializations that will persist beyond the
        -: 2573:/// conversion process, and require inserting a proper user materialization for.
        -: 2574:static void computeNecessaryMaterializations(
        -: 2575:    DenseMap<Operation *, UnresolvedMaterialization *> &materializationOps,
        -: 2576:    ConversionPatternRewriter &rewriter,
        -: 2577:    ConversionPatternRewriterImpl &rewriterImpl,
        -: 2578:    DenseMap<Value, SmallVector<Value>> &inverseMapping,
        -: 2579:    SetVector<UnresolvedMaterialization *> &necessaryMaterializations) {
function _ZZL32computeNecessaryMaterializationsRN4llvm8DenseMapIPN4mlir9OperationEPN12_GLOBAL__N_125UnresolvedMaterializationENS_12DenseMapInfoIS3_vEENS_6detail12DenseMapPairIS3_S6_EEEERNS1_25ConversionPatternRewriterERNS1_6detail29ConversionPatternRewriterImplERNS0_INS1_5ValueENS_11SmallVectorISJ_Lj6EEENS7_ISJ_vEENSA_ISJ_SL_EEEERNS_9SetVectorIS6_St6vectorIS6_SaIS6_EENS_8DenseSetIS6_NS7_IS6_vEEEEEEENKUlSJ_E_clESJ_ called 0 returned 0% blocks executed 0%
    #####: 2580:  auto isLive = [&](Value value) {
function _ZZZL32computeNecessaryMaterializationsRN4llvm8DenseMapIPN4mlir9OperationEPN12_GLOBAL__N_125UnresolvedMaterializationENS_12DenseMapInfoIS3_vEENS_6detail12DenseMapPairIS3_S6_EEEERNS1_25ConversionPatternRewriterERNS1_6detail29ConversionPatternRewriterImplERNS0_INS1_5ValueENS_11SmallVectorISJ_Lj6EEENS7_ISJ_vEENSA_ISJ_SL_EEEERNS_9SetVectorIS6_St6vectorIS6_SaIS6_EENS_8DenseSetIS6_NS7_IS6_vEEEEEEENKUlSJ_E_clESJ_ENKUlS3_E_clES3_ called 0 returned 0% blocks executed 0%
    #####: 2581:    auto findFn = [&](Operation *user) {
    #####: 2582:      auto matIt = materializationOps.find(user);
call    0 never executed
    #####: 2583:      if (matIt != materializationOps.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2584:        return !necessaryMaterializations.count(matIt->second);
call    0 never executed
call    1 never executed
    #####: 2585:      return rewriterImpl.isOpIgnored(user);
call    0 never executed
    #####: 2586:    };
        -: 2587:    // This value may be replacing another value that has a live user.
    #####: 2588:    for (Value inv : inverseMapping.lookup(value))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2589:      if (llvm::find_if_not(inv.getUsers(), findFn) != inv.user_end())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2590:        return true;
branch  0 never executed
branch  1 never executed
        -: 2591:    // Or have live users itself.
    #####: 2592:    return llvm::find_if_not(value.getUsers(), findFn) != value.user_end();
call    0 never executed
        -: 2593:  };
        -: 2594:
        -: 2595:  llvm::unique_function<Value(Value, Value, Type)> lookupRemappedValue =
function _ZZL32computeNecessaryMaterializationsRN4llvm8DenseMapIPN4mlir9OperationEPN12_GLOBAL__N_125UnresolvedMaterializationENS_12DenseMapInfoIS3_vEENS_6detail12DenseMapPairIS3_S6_EEEERNS1_25ConversionPatternRewriterERNS1_6detail29ConversionPatternRewriterImplERNS0_INS1_5ValueENS_11SmallVectorISJ_Lj6EEENS7_ISJ_vEENSA_ISJ_SL_EEEERNS_9SetVectorIS6_St6vectorIS6_SaIS6_EENS_8DenseSetIS6_NS7_IS6_vEEEEEEENKUlSJ_SJ_NS1_4TypeEE0_clESJ_SJ_SZ_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2596:      [&](Value invalidRoot, Value value, Type type) {
        -: 2597:        // Check to see if the input operation was remapped to a variant of the
        -: 2598:        // output.
    #####: 2599:        Value remappedValue = rewriterImpl.mapping.lookupOrDefault(value, type);
call    0 never executed
    #####: 2600:        if (remappedValue.getType() == type && remappedValue != invalidRoot)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2601:          return remappedValue;
        -: 2602:
        -: 2603:        // Check to see if the input is a materialization operation that
        -: 2604:        // provides an inverse conversion. We just check blindly for
        -: 2605:        // UnrealizedConversionCastOp here, but it has no effect on correctness.
    #####: 2606:        auto inputCastOp = value.getDefiningOp<UnrealizedConversionCastOp>();
call    0 never executed
    #####: 2607:        if (inputCastOp && inputCastOp->getNumOperands() == 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 2608:          return lookupRemappedValue(invalidRoot, inputCastOp->getOperand(0),
    #####: 2609:                                     type);
call    0 never executed
call    1 never executed
        -: 2610:
    #####: 2611:        return Value();
        -: 2612:      };
        -: 2613:
        -: 2614:  SetVector<UnresolvedMaterialization *> worklist;
        -: 2615:  for (auto &mat : rewriterImpl.unresolvedMaterializations) {
        -: 2616:    materializationOps.try_emplace(mat.getOp(), &mat);
        -: 2617:    worklist.insert(&mat);
        -: 2618:  }
        -: 2619:  while (!worklist.empty()) {
        -: 2620:    UnresolvedMaterialization *mat = worklist.pop_back_val();
        -: 2621:    UnrealizedConversionCastOp op = mat->getOp();
        -: 2622:
        -: 2623:    // We currently only handle target materializations here.
        -: 2624:    assert(op->getNumResults() == 1 && "unexpected materialization type");
        -: 2625:    OpResult opResult = op->getOpResult(0);
        -: 2626:    Type outputType = opResult.getType();
        -: 2627:    Operation::operand_range inputOperands = op.getOperands();
        -: 2628:
        -: 2629:    // Try to forward propagate operands for user conversion casts that result
        -: 2630:    // in the input types of the current cast.
        -: 2631:    for (Operation *user : llvm::make_early_inc_range(opResult.getUsers())) {
        -: 2632:      auto castOp = dyn_cast<UnrealizedConversionCastOp>(user);
        -: 2633:      if (!castOp)
        -: 2634:        continue;
        -: 2635:      if (castOp->getResultTypes() == inputOperands.getTypes()) {
        -: 2636:        replaceMaterialization(rewriterImpl, opResult, inputOperands,
        -: 2637:                               inverseMapping);
        -: 2638:        necessaryMaterializations.remove(materializationOps.lookup(user));
        -: 2639:      }
        -: 2640:    }
        -: 2641:
        -: 2642:    // Try to avoid materializing a resolved materialization if possible.
        -: 2643:    // Handle the case of a 1-1 materialization.
        -: 2644:    if (inputOperands.size() == 1) {
        -: 2645:      // Check to see if the input operation was remapped to a variant of the
        -: 2646:      // output.
        -: 2647:      Value remappedValue =
        -: 2648:          lookupRemappedValue(opResult, inputOperands[0], outputType);
        -: 2649:      if (remappedValue && remappedValue != opResult) {
        -: 2650:        replaceMaterialization(rewriterImpl, opResult, remappedValue,
        -: 2651:                               inverseMapping);
        -: 2652:        necessaryMaterializations.remove(mat);
        -: 2653:        continue;
        -: 2654:      }
        -: 2655:    } else {
        -: 2656:      // TODO: Avoid materializing other types of conversions here.
        -: 2657:    }
        -: 2658:
        -: 2659:    // Check to see if this is an argument materialization.
        -: 2660:    auto isBlockArg = [](Value v) { return v.isa<BlockArgument>(); };
        -: 2661:    if (llvm::any_of(op->getOperands(), isBlockArg) ||
        -: 2662:        llvm::any_of(inverseMapping[op->getResult(0)], isBlockArg)) {
        -: 2663:      mat->setKind(UnresolvedMaterialization::Argument);
        -: 2664:    }
        -: 2665:
        -: 2666:    // If the materialization does not have any live users, we don't need to
        -: 2667:    // generate a user materialization for it.
        -: 2668:    // FIXME: For argument materializations, we currently need to check if any
        -: 2669:    // of the inverse mapped values are used because some patterns expect blind
        -: 2670:    // value replacement even if the types differ in some cases. When those
        -: 2671:    // patterns are fixed, we can drop the argument special case here.
        -: 2672:    bool isMaterializationLive = isLive(opResult);
        -: 2673:    if (mat->getKind() == UnresolvedMaterialization::Argument)
        -: 2674:      isMaterializationLive |= llvm::any_of(inverseMapping[opResult], isLive);
        -: 2675:    if (!isMaterializationLive)
        -: 2676:      continue;
        -: 2677:    if (!necessaryMaterializations.insert(mat))
        -: 2678:      continue;
        -: 2679:
        -: 2680:    // Reprocess input materializations to see if they have an updated status.
        -: 2681:    for (Value input : inputOperands) {
        -: 2682:      if (auto parentOp = input.getDefiningOp<UnrealizedConversionCastOp>()) {
        -: 2683:        if (auto *mat = materializationOps.lookup(parentOp))
        -: 2684:          worklist.insert(mat);
        -: 2685:      }
        -: 2686:    }
        -: 2687:  }
        -: 2688:}
        -: 2689:
        -: 2690:/// Legalize the given unresolved materialization. Returns success if the
        -: 2691:/// materialization was legalized, failure otherise.
function _ZL33legalizeUnresolvedMaterializationRN12_GLOBAL__N_125UnresolvedMaterializationERN4llvm8DenseMapIPN4mlir9OperationEPS0_NS2_12DenseMapInfoIS6_vEENS2_6detail12DenseMapPairIS6_S7_EEEERNS4_25ConversionPatternRewriterERNS4_6detail29ConversionPatternRewriterImplERNS3_INS4_5ValueENS2_11SmallVectorISK_Lj6EEENS8_ISK_vEENSB_ISK_SM_EEEE called 0 returned 0% blocks executed 0%
    #####: 2692:static LogicalResult legalizeUnresolvedMaterialization(
        -: 2693:    UnresolvedMaterialization &mat,
        -: 2694:    DenseMap<Operation *, UnresolvedMaterialization *> &materializationOps,
        -: 2695:    ConversionPatternRewriter &rewriter,
        -: 2696:    ConversionPatternRewriterImpl &rewriterImpl,
        -: 2697:    DenseMap<Value, SmallVector<Value>> &inverseMapping) {
function _ZZL33legalizeUnresolvedMaterializationRN12_GLOBAL__N_125UnresolvedMaterializationERN4llvm8DenseMapIPN4mlir9OperationEPS0_NS2_12DenseMapInfoIS6_vEENS2_6detail12DenseMapPairIS6_S7_EEEERNS4_25ConversionPatternRewriterERNS4_6detail29ConversionPatternRewriterImplERNS3_INS4_5ValueENS2_11SmallVectorISK_Lj6EEENS8_ISK_vEENSB_ISK_SM_EEEEENKUlOT_E_clINS2_14iterator_rangeINS4_17ValueUserIteratorINS4_11ResultRange11UseIteratorENS4_9OpOperandEEEEEEEDaSS_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2698:  auto findLiveUser = [&](auto &&users) {
    #####: 2699:    auto liveUserIt = llvm::find_if_not(
branch  0 never executed
branch  1 never executed
    #####: 2700:        users, [&](Operation *user) { return rewriterImpl.isOpIgnored(user); });
call    0 never executed
    #####: 2701:    return liveUserIt == users.end() ? nullptr : *liveUserIt;
branch  0 never executed
branch  1 never executed
    #####: 2702:  };
        -: 2703:
    #####: 2704:  llvm::unique_function<Value(Value, Type)> lookupRemappedValue =
function _ZZL33legalizeUnresolvedMaterializationRN12_GLOBAL__N_125UnresolvedMaterializationERN4llvm8DenseMapIPN4mlir9OperationEPS0_NS2_12DenseMapInfoIS6_vEENS2_6detail12DenseMapPairIS6_S7_EEEERNS4_25ConversionPatternRewriterERNS4_6detail29ConversionPatternRewriterImplERNS3_INS4_5ValueENS2_11SmallVectorISK_Lj6EEENS8_ISK_vEENSB_ISK_SM_EEEEENKUlSK_NS4_4TypeEE0_clESK_SR_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 2705:      [&](Value value, Type type) {
        -: 2706:        // Check to see if the input operation was remapped to a variant of the
        -: 2707:        // output.
    #####: 2708:        Value remappedValue = rewriterImpl.mapping.lookupOrDefault(value, type);
call    0 never executed
    #####: 2709:        if (remappedValue.getType() == type)
branch  0 never executed
branch  1 never executed
    #####: 2710:          return remappedValue;
    #####: 2711:        return Value();
    #####: 2712:      };
call    0 never executed
        -: 2713:
    #####: 2714:  UnrealizedConversionCastOp op = mat.getOp();
    #####: 2715:  if (!rewriterImpl.ignoredOps.insert(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2716:    return success();
call    0 never executed
        -: 2717:
        -: 2718:  // We currently only handle target materializations here.
    #####: 2719:  OpResult opResult = op->getOpResult(0);
call    0 never executed
    #####: 2720:  Operation::operand_range inputOperands = op.getOperands();
call    0 never executed
    #####: 2721:  Type outputType = opResult.getType();
call    0 never executed
        -: 2722:
        -: 2723:  // If any input to this materialization is another materialization, resolve
        -: 2724:  // the input first.
    #####: 2725:  for (Value value : op->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 2726:    auto valueCast = value.getDefiningOp<UnrealizedConversionCastOp>();
call    0 never executed
    #####: 2727:    if (!valueCast)
branch  0 never executed
branch  1 never executed
    #####: 2728:      continue;
        -: 2729:
    #####: 2730:    auto matIt = materializationOps.find(valueCast);
call    0 never executed
    #####: 2731:    if (matIt != materializationOps.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2732:      if (failed(legalizeUnresolvedMaterialization(
branch  0 never executed
branch  1 never executed
    #####: 2733:              *matIt->second, materializationOps, rewriter, rewriterImpl,
call    0 never executed
call    1 never executed
        -: 2734:              inverseMapping)))
    #####: 2735:        return failure();
        -: 2736:  }
        -: 2737:
        -: 2738:  // Perform a last ditch attempt to avoid materializing a resolved
        -: 2739:  // materialization if possible.
        -: 2740:  // Handle the case of a 1-1 materialization.
    #####: 2741:  if (inputOperands.size() == 1) {
branch  0 never executed
branch  1 never executed
        -: 2742:    // Check to see if the input operation was remapped to a variant of the
        -: 2743:    // output.
    #####: 2744:    Value remappedValue = lookupRemappedValue(inputOperands[0], outputType);
call    0 never executed
    #####: 2745:    if (remappedValue && remappedValue != opResult) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2746:      replaceMaterialization(rewriterImpl, opResult, remappedValue,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2747:                             inverseMapping);
    #####: 2748:      return success();
        -: 2749:    }
        -: 2750:  } else {
        -: 2751:    // TODO: Avoid materializing other types of conversions here.
        -: 2752:  }
        -: 2753:
        -: 2754:  // Try to materialize the conversion.
    #####: 2755:  if (TypeConverter *converter = mat.getConverter()) {
branch  0 never executed
branch  1 never executed
        -: 2756:    // FIXME: Determine a suitable insertion location when there are multiple
        -: 2757:    // inputs.
    #####: 2758:    if (inputOperands.size() == 1)
branch  0 never executed
branch  1 never executed
    #####: 2759:      rewriter.setInsertionPointAfterValue(inputOperands.front());
call    0 never executed
        -: 2760:    else
    #####: 2761:      rewriter.setInsertionPoint(op);
call    0 never executed
        -: 2762:
    #####: 2763:    Value newMaterialization;
    #####: 2764:    switch (mat.getKind()) {
branch  0 never executed
branch  1 never executed
    #####: 2765:    case UnresolvedMaterialization::Argument:
        -: 2766:      // Try to materialize an argument conversion.
        -: 2767:      // FIXME: The current argument materialization hook expects the original
        -: 2768:      // output type, even though it doesn't use that as the actual output type
        -: 2769:      // of the generated IR. The output type is just used as an indicator of
        -: 2770:      // the type of materialization to do. This behavior is really awkward in
        -: 2771:      // that it diverges from the behavior of the other hooks, and can be
        -: 2772:      // easily misunderstood. We should clean up the argument hooks to better
        -: 2773:      // represent the desired invariants we actually care about.
    #####: 2774:      newMaterialization = converter->materializeArgumentConversion(
    #####: 2775:          rewriter, op->getLoc(), mat.getOrigOutputType(), inputOperands);
call    0 never executed
call    1 never executed
    #####: 2776:      if (newMaterialization)
branch  0 never executed
branch  1 never executed
        -: 2777:        break;
        -: 2778:
        -: 2779:      // If an argument materialization failed, fallback to trying a target
        -: 2780:      // materialization.
    #####: 2781:      [[fallthrough]];
    #####: 2782:    case UnresolvedMaterialization::Target:
    #####: 2783:      newMaterialization = converter->materializeTargetConversion(
    #####: 2784:          rewriter, op->getLoc(), outputType, inputOperands);
call    0 never executed
call    1 never executed
    #####: 2785:      break;
        -: 2786:    }
    #####: 2787:    if (newMaterialization) {
branch  0 never executed
branch  1 never executed
    #####: 2788:      replaceMaterialization(rewriterImpl, opResult, newMaterialization,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2789:                             inverseMapping);
    #####: 2790:      return success();
        -: 2791:    }
        -: 2792:  }
        -: 2793:
    #####: 2794:  InFlightDiagnostic diag = op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2795:                            << "failed to legalize unresolved materialization "
    #####: 2796:                               "from "
    #####: 2797:                            << inputOperands.getTypes() << " to " << outputType
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 2798:                            << " that remained live after conversion";
call    0 never executed
call    1 never executed
    #####: 2799:  if (Operation *liveUser = findLiveUser(op->getUsers())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2800:    diag.attachNote(liveUser->getLoc())
call    0 never executed
    #####: 2801:        << "see existing live user here: " << *liveUser;
call    0 never executed
call    1 never executed
        -: 2802:  }
    #####: 2803:  return failure();
call    0 never executed
        -: 2804:}
        -: 2805:
        -: 2806:LogicalResult OperationConverter::legalizeUnresolvedMaterializations(
        -: 2807:    ConversionPatternRewriter &rewriter,
        -: 2808:    ConversionPatternRewriterImpl &rewriterImpl,
        -: 2809:    Optional<DenseMap<Value, SmallVector<Value>>> &inverseMapping) {
        -: 2810:  if (rewriterImpl.unresolvedMaterializations.empty())
        -: 2811:    return success();
        -: 2812:  inverseMapping = rewriterImpl.mapping.getInverse();
        -: 2813:
        -: 2814:  // As an initial step, compute all of the inserted materializations that we
        -: 2815:  // expect to persist beyond the conversion process.
        -: 2816:  DenseMap<Operation *, UnresolvedMaterialization *> materializationOps;
        -: 2817:  SetVector<UnresolvedMaterialization *> necessaryMaterializations;
        -: 2818:  computeNecessaryMaterializations(materializationOps, rewriter, rewriterImpl,
        -: 2819:                                   *inverseMapping, necessaryMaterializations);
        -: 2820:
        -: 2821:  // Once computed, legalize any necessary materializations.
        -: 2822:  for (auto *mat : necessaryMaterializations) {
        -: 2823:    if (failed(legalizeUnresolvedMaterialization(
        -: 2824:            *mat, materializationOps, rewriter, rewriterImpl, *inverseMapping)))
        -: 2825:      return failure();
        -: 2826:  }
        -: 2827:  return success();
        -: 2828:}
        -: 2829:
        -: 2830:LogicalResult OperationConverter::legalizeErasedResult(
        -: 2831:    Operation *op, OpResult result,
        -: 2832:    ConversionPatternRewriterImpl &rewriterImpl) {
        -: 2833:  // If the operation result was replaced with null, all of the uses of this
        -: 2834:  // value should be replaced.
    #####: 2835:  auto liveUserIt = llvm::find_if_not(result.getUsers(), [&](Operation *user) {
    #####: 2836:    return rewriterImpl.isOpIgnored(user);
call    0 never executed
        -: 2837:  });
        -: 2838:  if (liveUserIt != result.user_end()) {
        -: 2839:    InFlightDiagnostic diag = op->emitError("failed to legalize operation '")
        -: 2840:                              << op->getName() << "' marked as erased";
        -: 2841:    diag.attachNote(liveUserIt->getLoc())
        -: 2842:        << "found live user of result #" << result.getResultNumber() << ": "
        -: 2843:        << *liveUserIt;
        -: 2844:    return failure();
        -: 2845:  }
        -: 2846:  return success();
        -: 2847:}
        -: 2848:
        -: 2849:/// Finds a user of the given value, or of any other value that the given value
        -: 2850:/// replaced, that was not replaced in the conversion process.
function _ZL22findLiveUserOfReplacedN4mlir5ValueERNS_6detail29ConversionPatternRewriterImplERKN4llvm8DenseMapIS0_NS4_11SmallVectorIS0_Lj6EEENS4_12DenseMapInfoIS0_vEENS4_6detail12DenseMapPairIS0_S7_EEEE called 0 returned 0% blocks executed 0%
    #####: 2851:static Operation *findLiveUserOfReplaced(
        -: 2852:    Value initialValue, ConversionPatternRewriterImpl &rewriterImpl,
        -: 2853:    const DenseMap<Value, SmallVector<Value>> &inverseMapping) {
    #####: 2854:  SmallVector<Value> worklist(1, initialValue);
call    0 never executed
    #####: 2855:  while (!worklist.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 2856:    Value value = worklist.pop_back_val();
call    0 never executed
        -: 2857:
        -: 2858:    // Walk the users of this value to see if there are any live users that
        -: 2859:    // weren't replaced during conversion.
    #####: 2860:    auto liveUserIt = llvm::find_if_not(value.getUsers(), [&](Operation *user) {
    #####: 2861:      return rewriterImpl.isOpIgnored(user);
call    0 never executed
    #####: 2862:    });
call    0 never executed
    #####: 2863:    if (liveUserIt != value.user_end())
branch  0 never executed
branch  1 never executed
    #####: 2864:      return *liveUserIt;
    #####: 2865:    auto mapIt = inverseMapping.find(value);
call    0 never executed
    #####: 2866:    if (mapIt != inverseMapping.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2867:      worklist.append(mapIt->second);
call    0 never executed
call    1 never executed
        -: 2868:  }
        -: 2869:  return nullptr;
        -: 2870:}
        -: 2871:
        -: 2872:LogicalResult OperationConverter::legalizeChangedResultType(
        -: 2873:    Operation *op, OpResult result, Value newValue,
        -: 2874:    TypeConverter *replConverter, ConversionPatternRewriter &rewriter,
        -: 2875:    ConversionPatternRewriterImpl &rewriterImpl,
        -: 2876:    const DenseMap<Value, SmallVector<Value>> &inverseMapping) {
        -: 2877:  Operation *liveUser =
        -: 2878:      findLiveUserOfReplaced(result, rewriterImpl, inverseMapping);
        -: 2879:  if (!liveUser)
        -: 2880:    return success();
        -: 2881:
        -: 2882:  // Functor used to emit a conversion error for a failed materialization.
function _ZZN12_GLOBAL__N_118OperationConverter25legalizeChangedResultTypeEPN4mlir9OperationENS1_8OpResultENS1_5ValueEPNS1_13TypeConverterERNS1_25ConversionPatternRewriterERNS1_6detail29ConversionPatternRewriterImplERKN4llvm8DenseMapIS5_NSD_11SmallVectorIS5_Lj6EEENSD_12DenseMapInfoIS5_vEENSD_6detail12DenseMapPairIS5_SG_EEEEENKUlvE_clEv called 0 returned 0% blocks executed 0%
    #####: 2883:  auto emitConversionError = [&] {
    #####: 2884:    InFlightDiagnostic diag = op->emitError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2885:                              << "failed to materialize conversion for result #"
    #####: 2886:                              << result.getResultNumber() << " of operation '"
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2887:                              << op->getName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2888:                              << "' that remained live after conversion";
call    0 never executed
call    1 never executed
    #####: 2889:    diag.attachNote(liveUser->getLoc())
call    0 never executed
    #####: 2890:        << "see existing live user here: " << *liveUser;
call    0 never executed
call    1 never executed
    #####: 2891:    return failure();
call    0 never executed
        -: 2892:  };
        -: 2893:
        -: 2894:  // If the replacement has a type converter, attempt to materialize a
        -: 2895:  // conversion back to the original type.
        -: 2896:  if (!replConverter)
        -: 2897:    return emitConversionError();
        -: 2898:
        -: 2899:  // Materialize a conversion for this live result value.
        -: 2900:  Type resultType = result.getType();
        -: 2901:  Value convertedValue = replConverter->materializeSourceConversion(
        -: 2902:      rewriter, op->getLoc(), resultType, newValue);
        -: 2903:  if (!convertedValue)
        -: 2904:    return emitConversionError();
        -: 2905:
        -: 2906:  rewriterImpl.mapping.map(result, convertedValue);
        -: 2907:  return success();
        -: 2908:}
        -: 2909:
        -: 2910://===----------------------------------------------------------------------===//
        -: 2911:// Type Conversion
        -: 2912://===----------------------------------------------------------------------===//
        -: 2913:
function _ZN4mlir13TypeConverter19SignatureConversion9addInputsEjN4llvm8ArrayRefINS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 2914:void TypeConverter::SignatureConversion::addInputs(unsigned origInputNo,
        -: 2915:                                                   ArrayRef<Type> types) {
    #####: 2916:  assert(!types.empty() && "expected valid types");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2917:  remapInput(origInputNo, /*newInputNo=*/argTypes.size(), types.size());
call    0 never executed
    #####: 2918:  addInputs(types);
call    0 never executed
    #####: 2919:}
        -: 2920:
function _ZN4mlir13TypeConverter19SignatureConversion9addInputsEN4llvm8ArrayRefINS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 2921:void TypeConverter::SignatureConversion::addInputs(ArrayRef<Type> types) {
    #####: 2922:  assert(!types.empty() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 2923:         "1->0 type remappings don't need to be added explicitly");
    #####: 2924:  argTypes.append(types.begin(), types.end());
call    0 never executed
    #####: 2925:}
        -: 2926:
function _ZN4mlir13TypeConverter19SignatureConversion10remapInputEjjj called 0 returned 0% blocks executed 0%
    #####: 2927:void TypeConverter::SignatureConversion::remapInput(unsigned origInputNo,
        -: 2928:                                                    unsigned newInputNo,
        -: 2929:                                                    unsigned newInputCount) {
    #####: 2930:  assert(!remappedInputs[origInputNo] && "input has already been remapped");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 2931:  assert(newInputCount != 0 && "expected valid input count");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2932:  remappedInputs[origInputNo] =
    #####: 2933:      InputMapping{newInputNo, newInputCount, /*replacementValue=*/nullptr};
    #####: 2934:}
        -: 2935:
function _ZN4mlir13TypeConverter19SignatureConversion10remapInputEjNS_5ValueE called 0 returned 0% blocks executed 0%
    #####: 2936:void TypeConverter::SignatureConversion::remapInput(unsigned origInputNo,
        -: 2937:                                                    Value replacementValue) {
    #####: 2938:  assert(!remappedInputs[origInputNo] && "input has already been remapped");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 2939:  remappedInputs[origInputNo] =
    #####: 2940:      InputMapping{origInputNo, /*size=*/0, replacementValue};
    #####: 2941:}
        -: 2942:
function _ZN4mlir13TypeConverter11convertTypeENS_4TypeERN4llvm15SmallVectorImplIS1_EE called 0 returned 0% blocks executed 0%
    #####: 2943:LogicalResult TypeConverter::convertType(Type t,
        -: 2944:                                         SmallVectorImpl<Type> &results) {
    #####: 2945:  auto existingIt = cachedDirectConversions.find(t);
call    0 never executed
    #####: 2946:  if (existingIt != cachedDirectConversions.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2947:    if (existingIt->second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2948:      results.push_back(existingIt->second);
call    0 never executed
    #####: 2949:    return success(existingIt->second != nullptr);
call    0 never executed
        -: 2950:  }
    #####: 2951:  auto multiIt = cachedMultiConversions.find(t);
call    0 never executed
    #####: 2952:  if (multiIt != cachedMultiConversions.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2953:    results.append(multiIt->second.begin(), multiIt->second.end());
call    0 never executed
call    1 never executed
    #####: 2954:    return success();
        -: 2955:  }
        -: 2956:
        -: 2957:  // Walk the added converters in reverse order to apply the most recently
        -: 2958:  // registered first.
    #####: 2959:  size_t currentCount = results.size();
call    0 never executed
    #####: 2960:  conversionCallStack.push_back(t);
call    0 never executed
    #####: 2961:  auto popConversionCallStack =
    #####: 2962:      llvm::make_scope_exit([this]() { conversionCallStack.pop_back(); });
call    0 never executed
    #####: 2963:  for (ConversionCallbackFn &converter : llvm::reverse(conversions)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2964:    if (Optional<LogicalResult> result =
branch  0 never executed
branch  1 never executed
    #####: 2965:            converter(t, results, conversionCallStack)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2966:      if (!succeeded(*result)) {
branch  0 never executed
branch  1 never executed
    #####: 2967:        cachedDirectConversions.try_emplace(t, nullptr);
call    0 never executed
    #####: 2968:        return failure();
        -: 2969:      }
    #####: 2970:      auto newTypes = ArrayRef<Type>(results).drop_front(currentCount);
call    0 never executed
    #####: 2971:      if (newTypes.size() == 1)
branch  0 never executed
branch  1 never executed
    #####: 2972:        cachedDirectConversions.try_emplace(t, newTypes.front());
call    0 never executed
        -: 2973:      else
    #####: 2974:        cachedMultiConversions.try_emplace(t, llvm::to_vector<2>(newTypes));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2975:      return success();
        -: 2976:    }
        -: 2977:  }
    #####: 2978:  return failure();
call    0 never executed
        -: 2979:}
        -: 2980:
function _ZN4mlir13TypeConverter11convertTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2981:Type TypeConverter::convertType(Type t) {
        -: 2982:  // Use the multi-type result version to convert the type.
    #####: 2983:  SmallVector<Type, 1> results;
call    0 never executed
    #####: 2984:  if (failed(convertType(t, results)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2985:    return nullptr;
        -: 2986:
        -: 2987:  // Check to ensure that only one type was produced.
    #####: 2988:  return results.size() == 1 ? results.front() : nullptr;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2989:}
        -: 2990:
function _ZN4mlir13TypeConverter12convertTypesENS_9TypeRangeERN4llvm15SmallVectorImplINS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####: 2991:LogicalResult TypeConverter::convertTypes(TypeRange types,
        -: 2992:                                          SmallVectorImpl<Type> &results) {
    #####: 2993:  for (Type type : types)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2994:    if (failed(convertType(type, results)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2995:      return failure();
    #####: 2996:  return success();
        -: 2997:}
        -: 2998:
function _ZN4mlir13TypeConverter7isLegalENS_4TypeE called 0 returned 0% blocks executed 0%
    #####: 2999:bool TypeConverter::isLegal(Type type) { return convertType(type) == type; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
call   18 never executed
branch 19 never executed
branch 20 never executed
call   21 never executed
branch 22 never executed
branch 23 never executed
call   24 never executed
function _ZN4mlir13TypeConverter7isLegalEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####: 3000:bool TypeConverter::isLegal(Operation *op) {
    #####: 3001:  return isLegal(op->getOperandTypes()) && isLegal(op->getResultTypes());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 3002:}
        -: 3003:
function _ZN4mlir13TypeConverter7isLegalEPNS_6RegionE called 0 returned 0% blocks executed 0%
    #####: 3004:bool TypeConverter::isLegal(Region *region) {
    #####: 3005:  return llvm::all_of(*region, [this](Block &block) {
call    0 never executed
    #####: 3006:    return isLegal(block.getArgumentTypes());
call    0 never executed
call    1 never executed
    #####: 3007:  });
        -: 3008:}
        -: 3009:
function _ZN4mlir13TypeConverter16isSignatureLegalENS_12FunctionTypeE called 0 returned 0% blocks executed 0%
    #####: 3010:bool TypeConverter::isSignatureLegal(FunctionType ty) {
    #####: 3011:  return isLegal(llvm::concat<const Type>(ty.getInputs(), ty.getResults()));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3012:}
        -: 3013:
function _ZN4mlir13TypeConverter19convertSignatureArgEjNS_4TypeERNS0_19SignatureConversionE called 0 returned 0% blocks executed 0%
    #####: 3014:LogicalResult TypeConverter::convertSignatureArg(unsigned inputNo, Type type,
        -: 3015:                                                 SignatureConversion &result) {
        -: 3016:  // Try to convert the given input type.
    #####: 3017:  SmallVector<Type, 1> convertedTypes;
call    0 never executed
    #####: 3018:  if (failed(convertType(type, convertedTypes)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3019:    return failure();
        -: 3020:
        -: 3021:  // If this argument is being dropped, there is nothing left to do.
    #####: 3022:  if (convertedTypes.empty())
branch  0 never executed
branch  1 never executed
    #####: 3023:    return success();
        -: 3024:
        -: 3025:  // Otherwise, add the new inputs.
    #####: 3026:  result.addInputs(inputNo, convertedTypes);
call    0 never executed
    #####: 3027:  return success();
branch  0 never executed
branch  1 never executed
        -: 3028:}
function _ZN4mlir13TypeConverter20convertSignatureArgsENS_9TypeRangeERNS0_19SignatureConversionEj called 0 returned 0% blocks executed 0%
    #####: 3029:LogicalResult TypeConverter::convertSignatureArgs(TypeRange types,
        -: 3030:                                                  SignatureConversion &result,
        -: 3031:                                                  unsigned origInputOffset) {
    #####: 3032:  for (unsigned i = 0, e = types.size(); i != e; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3033:    if (failed(convertSignatureArg(origInputOffset + i, types[i], result)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3034:      return failure();
    #####: 3035:  return success();
        -: 3036:}
        -: 3037:
function _ZN4mlir13TypeConverter21materializeConversionEN4llvm15MutableArrayRefISt8functionIFNS1_8OptionalINS_5ValueEEERNS_9OpBuilderENS_4TypeENS_10ValueRangeENS_8LocationEEEEES8_SB_S9_SA_ called 0 returned 0% blocks executed 0%
    #####: 3038:Value TypeConverter::materializeConversion(
        -: 3039:    MutableArrayRef<MaterializationCallbackFn> materializations,
        -: 3040:    OpBuilder &builder, Location loc, Type resultType, ValueRange inputs) {
    #####: 3041:  for (MaterializationCallbackFn &fn : llvm::reverse(materializations))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3042:    if (Optional<Value> result = fn(builder, resultType, inputs, loc))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3043:      return *result;
    #####: 3044:  return nullptr;
        -: 3045:}
        -: 3046:
function _ZN4mlir13TypeConverter21convertBlockSignatureEPNS_5BlockE called 0 returned 0% blocks executed 0%
    #####: 3047:auto TypeConverter::convertBlockSignature(Block *block)
        -: 3048:    -> Optional<SignatureConversion> {
    #####: 3049:  SignatureConversion conversion(block->getNumArguments());
call    0 never executed
    #####: 3050:  if (failed(convertSignatureArgs(block->getArgumentTypes(), conversion)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 3051:    return llvm::None;
    #####: 3052:  return conversion;
call    0 never executed
call    1 never executed
        -: 3053:}
        -: 3054:
        -: 3055://===----------------------------------------------------------------------===//
        -: 3056:// FunctionOpInterfaceSignatureConversion
        -: 3057://===----------------------------------------------------------------------===//
        -: 3058:
        -: 3059:/// Create a default conversion pattern that rewrites the type signature of a
        -: 3060:/// FunctionOpInterface op. This only supports ops which use FunctionType to
        -: 3061:/// represent their type.
        -: 3062:namespace {
        -: 3063:struct FunctionOpInterfaceSignatureConversion : public ConversionPattern {
        -: 3064:  FunctionOpInterfaceSignatureConversion(StringRef functionLikeOpName,
        -: 3065:                                         MLIRContext *ctx,
        -: 3066:                                         TypeConverter &converter)
        -: 3067:      : ConversionPattern(converter, functionLikeOpName, /*benefit=*/1, ctx) {}
        -: 3068:
        -: 3069:  LogicalResult
function _ZNK12_GLOBAL__N_138FunctionOpInterfaceSignatureConversion15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 3070:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -: 3071:                  ConversionPatternRewriter &rewriter) const override {
    #####: 3072:    FunctionOpInterface funcOp = cast<FunctionOpInterface>(op);
call    0 never executed
    #####: 3073:    FunctionType type = funcOp.getFunctionType().cast<FunctionType>();
call    0 never executed
call    1 never executed
        -: 3074:
        -: 3075:    // Convert the original function types.
    #####: 3076:    TypeConverter::SignatureConversion result(type.getNumInputs());
call    0 never executed
call    1 never executed
    #####: 3077:    SmallVector<Type, 1> newResults;
call    0 never executed
    #####: 3078:    if (failed(typeConverter->convertSignatureArgs(type.getInputs(), result)) ||
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 3079:        failed(typeConverter->convertTypes(type.getResults(), newResults)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 3080:        failed(rewriter.convertRegionTypes(&funcOp.getFunctionBody(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3081:                                           *typeConverter, &result)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3082:      return failure();
        -: 3083:
        -: 3084:    // Update the function signature in-place.
    #####: 3085:    auto newType = FunctionType::get(rewriter.getContext(),
call    0 never executed
    #####: 3086:                                     result.getConvertedTypes(), newResults);
call    0 never executed
call    1 never executed
        -: 3087:
    #####: 3088:    rewriter.updateRootInPlace(op, [&] { funcOp.setType(newType); });
call    0 never executed
call    1 never executed
call    2 never executed
        -: 3089:
    #####: 3090:    return success();
branch  0 never executed
branch  1 never executed
        -: 3091:  }
        -: 3092:};
        -: 3093:} // namespace
        -: 3094:
function _ZN4mlir48populateFunctionOpInterfaceTypeConversionPatternEN4llvm9StringRefERNS_17RewritePatternSetERNS_13TypeConverterE called 4155 returned 100% blocks executed 100%
     4155: 3095:void mlir::populateFunctionOpInterfaceTypeConversionPattern(
        -: 3096:    StringRef functionLikeOpName, RewritePatternSet &patterns,
        -: 3097:    TypeConverter &converter) {
     4155: 3098:  patterns.add<FunctionOpInterfaceSignatureConversion>(
     4155: 3099:      functionLikeOpName, patterns.getContext(), converter);
call    0 returned 100%
     4155: 3100:}
        -: 3101:
        -: 3102://===----------------------------------------------------------------------===//
        -: 3103:// ConversionTarget
        -: 3104://===----------------------------------------------------------------------===//
        -: 3105:
function _ZN4mlir16ConversionTarget11setOpActionENS_13OperationNameENS0_18LegalizationActionE called 126696 returned 100% blocks executed 100%
   126696: 3106:void ConversionTarget::setOpAction(OperationName op,
        -: 3107:                                   LegalizationAction action) {
   126696: 3108:  legalOperations[op].action = action;
call    0 returned 100%
   126696: 3109:}
        -: 3110:
function _ZN4mlir16ConversionTarget16setDialectActionEN4llvm8ArrayRefINS1_9StringRefEEENS0_18LegalizationActionE called 44226 returned 100% blocks executed 100%
    44226: 3111:void ConversionTarget::setDialectAction(ArrayRef<StringRef> dialectNames,
        -: 3112:                                        LegalizationAction action) {
   110298: 3113:  for (StringRef dialect : dialectNames)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
    66072: 3114:    legalDialects[dialect] = action;
call    0 returned 100%
    44226: 3115:}
        -: 3116:
function _ZNK4mlir16ConversionTarget11getOpActionENS_13OperationNameE called 793790 returned 100% blocks executed 100%
   793790: 3117:auto ConversionTarget::getOpAction(OperationName op) const
        -: 3118:    -> Optional<LegalizationAction> {
   793790: 3119:  Optional<LegalizationInfo> info = getOpInfo(op);
call    0 returned 100%
   793790: 3120:  return info ? info->action : Optional<LegalizationAction>();
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
branch  2 taken 34% (fallthrough)
branch  3 taken 66%
        -: 3121:}
        -: 3122:
function _ZNK4mlir16ConversionTarget7isLegalEPNS_9OperationE called 53885696 returned 100% blocks executed 88%
 53885696: 3123:auto ConversionTarget::isLegal(Operation *op) const
        -: 3124:    -> Optional<LegalOpDetails> {
 53885696: 3125:  Optional<LegalizationInfo> info = getOpInfo(op->getName());
call    0 returned 100%
 53885696: 3126:  if (!info)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
 30169137: 3127:    return llvm::None;
        -: 3128:
        -: 3129:  // Returns true if this operation instance is known to be legal.
function _ZZNK4mlir16ConversionTarget7isLegalEPNS_9OperationEENKUlvE_clEv.isra.0 called 23716559 returned 100% blocks executed 77%
 23716559: 3130:  auto isOpLegal = [&] {
        -: 3131:    // Handle dynamic legality either with the provided legality function.
 23716559: 3132:    if (info->action == LegalizationAction::Dynamic) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 21% (fallthrough)
branch  3 taken 79%
  5083413: 3133:      Optional<bool> result = info->legalityFn(op);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
  5083413: 3134:      if (result)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  5083413: 3135:        return *result;
        -: 3136:    }
        -: 3137:
        -: 3138:    // Otherwise, the operation is only legal if it was marked 'Legal'.
 18633146: 3139:    return info->action == LegalizationAction::Legal;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
 23716559: 3140:  };
 23716559: 3141:  if (!isOpLegal())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 3142:    return llvm::None;
        -: 3143:
        -: 3144:  // This operation is legal, compute any additional legality information.
 23716559: 3145:  LegalOpDetails legalityDetails;
 23716559: 3146:  if (info->isRecursivelyLegal) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
      515: 3147:    auto legalityFnIt = opRecursiveLegalityFns.find(op->getName());
call    0 returned 100%
      515: 3148:    if (legalityFnIt != opRecursiveLegalityFns.end()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1030: 3149:      legalityDetails.isRecursivelyLegal =
     1545: 3150:          legalityFnIt->second(op).value_or(true);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -: 3151:    } else {
        -: 3152:      legalityDetails.isRecursivelyLegal = true;
        -: 3153:    }
        -: 3154:  }
 23716559: 3155:  return legalityDetails;
        -: 3156:}
        -: 3157:
function _ZNK4mlir16ConversionTarget9isIllegalEPNS_9OperationE called 14478524 returned 100% blocks executed 31%
 14478524: 3158:bool ConversionTarget::isIllegal(Operation *op) const {
 14478524: 3159:  Optional<LegalizationInfo> info = getOpInfo(op->getName());
call    0 returned 100%
 14478524: 3160:  if (!info)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3161:    return false;
        -: 3162:
    #####: 3163:  if (info->action == LegalizationAction::Dynamic) {
branch  0 never executed
branch  1 never executed
    #####: 3164:    Optional<bool> result = info->legalityFn(op);
branch  0 never executed
branch  1 never executed
    #####: 3165:    if (!result)
branch  0 never executed
branch  1 never executed
        -: 3166:      return false;
        -: 3167:
    #####: 3168:    return !(*result);
        -: 3169:  }
        -: 3170:
    #####: 3171:  return info->action == LegalizationAction::Illegal;
        -: 3172:}
        -: 3173:
function _ZL24composeLegalityCallbacksSt8functionIFN4llvm8OptionalIbEEPN4mlir9OperationEEES7_ called 67085 returned 100% blocks executed 43%
    67085: 3174:static ConversionTarget::DynamicLegalityCallbackFn composeLegalityCallbacks(
        -: 3175:    ConversionTarget::DynamicLegalityCallbackFn oldCallback,
        -: 3176:    ConversionTarget::DynamicLegalityCallbackFn newCallback) {
    67085: 3177:  if (!oldCallback)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    67085: 3178:    return newCallback;
        -: 3179:
function _ZZL24composeLegalityCallbacksSt8functionIFN4llvm8OptionalIbEEPN4mlir9OperationEEES7_ENKUlS5_E_clES5_ called 0 returned 0% blocks executed 0%
    #####: 3180:  auto chain = [oldCl = std::move(oldCallback), newCl = std::move(newCallback)](
call    0 never executed
        -: 3181:                   Operation *op) -> Optional<bool> {
    #####: 3182:    if (Optional<bool> result = newCl(op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 3183:      return *result;
        -: 3184:
    #####: 3185:    return oldCl(op);
branch  0 never executed
branch  1 never executed
    #####: 3186:  };
    #####: 3187:  return chain;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 3188:}
        -: 3189:
function _ZN4mlir16ConversionTarget19setLegalityCallbackENS_13OperationNameERKSt8functionIFN4llvm8OptionalIbEEPNS_9OperationEEE called 55426 returned 100% blocks executed 72%
    55426: 3190:void ConversionTarget::setLegalityCallback(
        -: 3191:    OperationName name, const DynamicLegalityCallbackFn &callback) {
   55426*: 3192:  assert(callback && "expected valid legality callback");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    55426: 3193:  auto infoIt = legalOperations.find(name);
call    0 returned 100%
   55426*: 3194:  assert(infoIt != legalOperations.end() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 3195:         infoIt->second.action == LegalizationAction::Dynamic &&
        -: 3196:         "expected operation to already be marked as dynamically legal");
   110852: 3197:  infoIt->second.legalityFn =
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
    55426: 3198:      composeLegalityCallbacks(std::move(infoIt->second.legalityFn), callback);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    55426: 3199:}
        -: 3200:
function _ZN4mlir16ConversionTarget22markOpRecursivelyLegalENS_13OperationNameERKSt8functionIFN4llvm8OptionalIbEEPNS_9OperationEEE called 1018 returned 100% blocks executed 74%
     1018: 3201:void ConversionTarget::markOpRecursivelyLegal(
        -: 3202:    OperationName name, const DynamicLegalityCallbackFn &callback) {
     1018: 3203:  auto infoIt = legalOperations.find(name);
call    0 returned 100%
    1018*: 3204:  assert(infoIt != legalOperations.end() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 3205:         infoIt->second.action != LegalizationAction::Illegal &&
        -: 3206:         "expected operation to already be marked as legal");
     1018: 3207:  infoIt->second.isRecursivelyLegal = true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1018: 3208:  if (callback)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3054: 3209:    opRecursiveLegalityFns[name] = composeLegalityCallbacks(
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
     2036: 3210:        std::move(opRecursiveLegalityFns[name]), callback);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        -: 3211:  else
    #####: 3212:    opRecursiveLegalityFns.erase(name);
call    0 never executed
     1018: 3213:}
        -: 3214:
function _ZN4mlir16ConversionTarget19setLegalityCallbackEN4llvm8ArrayRefINS1_9StringRefEEERKSt8functionIFNS1_8OptionalIbEEPNS_9OperationEEE called 5810 returned 100% blocks executed 79%
     5810: 3215:void ConversionTarget::setLegalityCallback(
        -: 3216:    ArrayRef<StringRef> dialects, const DynamicLegalityCallbackFn &callback) {
    5810*: 3217:  assert(callback && "expected valid legality callback");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    13237: 3218:  for (StringRef dialect : dialects)
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
    22281: 3219:    dialectLegalityFns[dialect] = composeLegalityCallbacks(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    14854: 3220:        std::move(dialectLegalityFns[dialect]), callback);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
     5810: 3221:}
        -: 3222:
function _ZN4mlir16ConversionTarget19setLegalityCallbackERKSt8functionIFN4llvm8OptionalIbEEPNS_9OperationEEE called 3214 returned 100% blocks executed 60%
     3214: 3223:void ConversionTarget::setLegalityCallback(
        -: 3224:    const DynamicLegalityCallbackFn &callback) {
    3214*: 3225:  assert(callback && "expected valid legality callback");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     3214: 3226:  unknownLegalityFn = composeLegalityCallbacks(unknownLegalityFn, callback);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
branch  7 taken 0% (fallthrough)
branch  8 taken 100%
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
     3214: 3227:}
        -: 3228:
function _ZNK4mlir16ConversionTarget9getOpInfoENS_13OperationNameE called 69158010 returned 100% blocks executed 100%
 69158010: 3229:auto ConversionTarget::getOpInfo(OperationName op) const
        -: 3230:    -> Optional<LegalizationInfo> {
        -: 3231:  // Check for info for this specific operation.
 69158010: 3232:  auto it = legalOperations.find(op);
call    0 returned 100%
 69158010: 3233:  if (it != legalOperations.end())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    88353: 3234:    return it->second;
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -: 3235:  // Check for info for the parent dialect.
 69069657: 3236:  auto dialectIt = legalDialects.find(op.getDialectNamespace());
call    0 returned 100%
call    1 returned 100%
 69069657: 3237:  if (dialectIt != legalDialects.end()) {
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
 37631406: 3238:    DynamicLegalityCallbackFn callback;
call    0 returned 100%
 18815703: 3239:    auto dialectFn = dialectLegalityFns.find(op.getDialectNamespace());
call    0 returned 100%
call    1 returned 100%
 18815703: 3240:    if (dialectFn != dialectLegalityFns.end())
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
    18284: 3241:      callback = dialectFn->second;
call    0 returned 100%
 18833987: 3242:    return LegalizationInfo{dialectIt->second, /*isRecursivelyLegal=*/false,
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
 18815703: 3243:                            callback};
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -: 3244:  }
        -: 3245:  // Otherwise, check if we mark unknown operations as dynamic.
 50253954: 3246:  if (unknownLegalityFn)
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
  5084490: 3247:    return LegalizationInfo{LegalizationAction::Dynamic,
  5084490: 3248:                            /*isRecursivelyLegal=*/false, unknownLegalityFn};
call    0 returned 100%
 45169464: 3249:  return llvm::None;
        -: 3250:}
        -: 3251:
        -: 3252://===----------------------------------------------------------------------===//
        -: 3253:// Op Conversion Entry Points
        -: 3254://===----------------------------------------------------------------------===//
        -: 3255:
        -: 3256://===----------------------------------------------------------------------===//
        -: 3257:// Partial Conversion
        -: 3258:
        -: 3259:LogicalResult
function _ZN4mlir22applyPartialConversionEN4llvm8ArrayRefIPNS_9OperationEEERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetEPNS0_8DenseSetIS3_NS0_12DenseMapInfoIS3_vEEEE called 34118 returned 100% blocks executed 100%
    34118: 3260:mlir::applyPartialConversion(ArrayRef<Operation *> ops,
        -: 3261:                             ConversionTarget &target,
        -: 3262:                             const FrozenRewritePatternSet &patterns,
        -: 3263:                             DenseSet<Operation *> *unconvertedOps) {
    34118: 3264:  OperationConverter opConverter(target, patterns, OpConversionMode::Partial,
call    0 returned 100%
    68236: 3265:                                 unconvertedOps);
    34118: 3266:  return opConverter.convertOperations(ops);
call    0 returned 100%
call    1 returned 100%
        -: 3267:}
        -: 3268:LogicalResult
function _ZN4mlir22applyPartialConversionEPNS_9OperationERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetEPN4llvm8DenseSetIS1_NS7_12DenseMapInfoIS1_vEEEE called 34118 returned 100% blocks executed 100%
    34118: 3269:mlir::applyPartialConversion(Operation *op, ConversionTarget &target,
        -: 3270:                             const FrozenRewritePatternSet &patterns,
        -: 3271:                             DenseSet<Operation *> *unconvertedOps) {
    34118: 3272:  return applyPartialConversion(llvm::makeArrayRef(op), target, patterns,
call    0 returned 100%
    34118: 3273:                                unconvertedOps);
call    0 returned 100%
        -: 3274:}
        -: 3275:
        -: 3276://===----------------------------------------------------------------------===//
        -: 3277:// Full Conversion
        -: 3278:
        -: 3279:LogicalResult
function _ZN4mlir19applyFullConversionEN4llvm8ArrayRefIPNS_9OperationEEERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetE called 1608 returned 100% blocks executed 100%
     1608: 3280:mlir::applyFullConversion(ArrayRef<Operation *> ops, ConversionTarget &target,
        -: 3281:                          const FrozenRewritePatternSet &patterns) {
     1608: 3282:  OperationConverter opConverter(target, patterns, OpConversionMode::Full);
call    0 returned 100%
     1608: 3283:  return opConverter.convertOperations(ops);
call    0 returned 100%
call    1 returned 100%
        -: 3284:}
        -: 3285:LogicalResult
function _ZN4mlir19applyFullConversionEPNS_9OperationERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetE called 1608 returned 100% blocks executed 100%
     1608: 3286:mlir::applyFullConversion(Operation *op, ConversionTarget &target,
        -: 3287:                          const FrozenRewritePatternSet &patterns) {
     1608: 3288:  return applyFullConversion(llvm::makeArrayRef(op), target, patterns);
call    0 returned 100%
        -: 3289:}
        -: 3290:
        -: 3291://===----------------------------------------------------------------------===//
        -: 3292:// Analysis Conversion
        -: 3293:
        -: 3294:LogicalResult
function _ZN4mlir23applyAnalysisConversionEN4llvm8ArrayRefIPNS_9OperationEEERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetERNS0_8DenseSetIS3_NS0_12DenseMapInfoIS3_vEEEENS0_12function_refIFvRNS_10DiagnosticEEEE called 0 returned 0% blocks executed 0%
    #####: 3295:mlir::applyAnalysisConversion(ArrayRef<Operation *> ops,
        -: 3296:                              ConversionTarget &target,
        -: 3297:                              const FrozenRewritePatternSet &patterns,
        -: 3298:                              DenseSet<Operation *> &convertedOps,
        -: 3299:                              function_ref<void(Diagnostic &)> notifyCallback) {
    #####: 3300:  OperationConverter opConverter(target, patterns, OpConversionMode::Analysis,
call    0 never executed
    #####: 3301:                                 &convertedOps);
    #####: 3302:  return opConverter.convertOperations(ops, notifyCallback);
call    0 never executed
call    1 never executed
        -: 3303:}
        -: 3304:LogicalResult
function _ZN4mlir23applyAnalysisConversionEPNS_9OperationERNS_16ConversionTargetERKNS_23FrozenRewritePatternSetERN4llvm8DenseSetIS1_NS7_12DenseMapInfoIS1_vEEEENS7_12function_refIFvRNS_10DiagnosticEEEE called 0 returned 0% blocks executed 0%
    #####: 3305:mlir::applyAnalysisConversion(Operation *op, ConversionTarget &target,
        -: 3306:                              const FrozenRewritePatternSet &patterns,
        -: 3307:                              DenseSet<Operation *> &convertedOps,
        -: 3308:                              function_ref<void(Diagnostic &)> notifyCallback) {
    #####: 3309:  return applyAnalysisConversion(llvm::makeArrayRef(op), target, patterns,
call    0 never executed
    #####: 3310:                                 convertedOps, notifyCallback);
call    0 never executed
        -: 3311:}
