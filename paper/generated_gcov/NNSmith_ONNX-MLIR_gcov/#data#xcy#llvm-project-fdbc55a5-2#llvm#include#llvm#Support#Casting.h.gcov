        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/Support/Casting.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===- llvm/Support/Casting.h - Allow flexible, checked, casts --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines the isa<X>(), cast<X>(), dyn_cast<X>(),
        -:   10:// cast_if_present<X>(), and dyn_cast_if_present<X>() templates.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef LLVM_SUPPORT_CASTING_H
        -:   15:#define LLVM_SUPPORT_CASTING_H
        -:   16:
        -:   17:#include "llvm/ADT/Optional.h"
        -:   18:#include "llvm/Support/Compiler.h"
        -:   19:#include "llvm/Support/type_traits.h"
        -:   20:#include <cassert>
        -:   21:#include <memory>
        -:   22:#include <type_traits>
        -:   23:
        -:   24:namespace llvm {
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// simplify_type
        -:   28://===----------------------------------------------------------------------===//
        -:   29:
        -:   30:/// Define a template that can be specialized by smart pointers to reflect the
        -:   31:/// fact that they are automatically dereferenced, and are not involved with the
        -:   32:/// template selection process...  the default implementation is a noop.
        -:   33:// TODO: rename this and/or replace it with other cast traits.
        -:   34:template <typename From> struct simplify_type {
        -:   35:  using SimpleType = From; // The real type this represents...
        -:   36:
        -:   37:  // An accessor to get the real value...
    #####:   38:  static SimpleType &getSimplifiedValue(From &Val) { return Val; }
        -:   39:};
        -:   40:
        -:   41:template <typename From> struct simplify_type<const From> {
        -:   42:  using NonConstSimpleType = typename simplify_type<From>::SimpleType;
        -:   43:  using SimpleType = typename add_const_past_pointer<NonConstSimpleType>::type;
        -:   44:  using RetType =
        -:   45:      typename add_lvalue_reference_if_not_pointer<SimpleType>::type;
        -:   46:
    #####:   47:  static RetType getSimplifiedValue(const From &Val) {
    #####:   48:    return simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val));
        -:   49:  }
        -:   50:};
        -:   51:
        -:   52:// TODO: add this namespace once everyone is switched to using the new
        -:   53://       interface.
        -:   54:// namespace detail {
        -:   55:
        -:   56://===----------------------------------------------------------------------===//
        -:   57:// isa_impl
        -:   58://===----------------------------------------------------------------------===//
        -:   59:
        -:   60:// The core of the implementation of isa<X> is here; To and From should be
        -:   61:// the names of classes.  This template can be specialized to customize the
        -:   62:// implementation of isa<> without rewriting it from scratch.
        -:   63:template <typename To, typename From, typename Enabler = void> struct isa_impl {
    #####:   64:  static inline bool doit(const From &Val) { return To::classof(&Val); }
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
        -:   65:};
        -:   66:
        -:   67:// Always allow upcasts, and perform no dynamic check for them.
        -:   68:template <typename To, typename From>
        -:   69:struct isa_impl<To, From, std::enable_if_t<std::is_base_of<To, From>::value>> {
    #####:   70:  static inline bool doit(const From &) { return true; }
        -:   71:};
        -:   72:
        -:   73:template <typename To, typename From> struct isa_impl_cl {
        -:   74:  static inline bool doit(const From &Val) {
        -:   75:    return isa_impl<To, From>::doit(Val);
        -:   76:  }
        -:   77:};
        -:   78:
        -:   79:template <typename To, typename From> struct isa_impl_cl<To, const From> {
        -:   80:  static inline bool doit(const From &Val) {
        -:   81:    return isa_impl<To, From>::doit(Val);
        -:   82:  }
        -:   83:};
        -:   84:
        -:   85:template <typename To, typename From>
        -:   86:struct isa_impl_cl<To, const std::unique_ptr<From>> {
        -:   87:  static inline bool doit(const std::unique_ptr<From> &Val) {
        -:   88:    assert(Val && "isa<> used on a null pointer");
        -:   89:    return isa_impl_cl<To, From>::doit(*Val);
        -:   90:  }
        -:   91:};
        -:   92:
        -:   93:template <typename To, typename From> struct isa_impl_cl<To, From *> {
        -:   94:  static inline bool doit(const From *Val) {
        -:   95:    assert(Val && "isa<> used on a null pointer");
        -:   96:    return isa_impl<To, From>::doit(*Val);
        -:   97:  }
        -:   98:};
        -:   99:
        -:  100:template <typename To, typename From> struct isa_impl_cl<To, From *const> {
        -:  101:  static inline bool doit(const From *Val) {
        -:  102:    assert(Val && "isa<> used on a null pointer");
        -:  103:    return isa_impl<To, From>::doit(*Val);
        -:  104:  }
        -:  105:};
        -:  106:
        -:  107:template <typename To, typename From> struct isa_impl_cl<To, const From *> {
    #####:  108:  static inline bool doit(const From *Val) {
    #####:  109:    assert(Val && "isa<> used on a null pointer");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
    #####:  110:    return isa_impl<To, From>::doit(*Val);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
        -:  111:  }
------------------
_ZN4llvm11isa_impl_clINS_14FPMathOperatorEPKNS_8CallInstEE4doitES4_:
function _ZN4llvm11isa_impl_clINS_14FPMathOperatorEPKNS_8CallInstEE4doitES4_ called 0 returned 0% blocks executed 0%
    #####:  108:  static inline bool doit(const From *Val) {
    #####:  109:    assert(Val && "isa<> used on a null pointer");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  110:    return isa_impl<To, From>::doit(*Val);
        -:  111:  }
------------------
_ZN4llvm11isa_impl_clINS_10VectorTypeEPKNS_4TypeEE4doitES4_:
function _ZN4llvm11isa_impl_clINS_10VectorTypeEPKNS_4TypeEE4doitES4_ called 0 returned 0% blocks executed 0%
    #####:  108:  static inline bool doit(const From *Val) {
    #####:  109:    assert(Val && "isa<> used on a null pointer");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  110:    return isa_impl<To, From>::doit(*Val);
        -:  111:  }
------------------
        -:  112:};
        -:  113:
        -:  114:template <typename To, typename From>
        -:  115:struct isa_impl_cl<To, const From *const> {
        -:  116:  static inline bool doit(const From *Val) {
        -:  117:    assert(Val && "isa<> used on a null pointer");
        -:  118:    return isa_impl<To, From>::doit(*Val);
        -:  119:  }
        -:  120:};
        -:  121:
        -:  122:template <typename To, typename From, typename SimpleFrom>
        -:  123:struct isa_impl_wrap {
        -:  124:  // When From != SimplifiedType, we can simplify the type some more by using
        -:  125:  // the simplify_type template.
    #####:  126:  static bool doit(const From &Val) {
        -:  127:    return isa_impl_wrap<To, SimpleFrom,
        -:  128:                         typename simplify_type<SimpleFrom>::SimpleType>::
    #####:  129:        doit(simplify_type<const From>::getSimplifiedValue(Val));
        -:  130:  }
        -:  131:};
        -:  132:
        -:  133:template <typename To, typename FromTy>
        -:  134:struct isa_impl_wrap<To, FromTy, FromTy> {
        -:  135:  // When From == SimpleType, we are as simple as we are going to get.
    #####:  136:  static bool doit(const FromTy &Val) {
    #####:  137:    return isa_impl_cl<To, FromTy>::doit(Val);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:  138:  }
        -:  139:};
        -:  140:
        -:  141://===----------------------------------------------------------------------===//
        -:  142:// cast_retty + cast_retty_impl
        -:  143://===----------------------------------------------------------------------===//
        -:  144:
        -:  145:template <class To, class From> struct cast_retty;
        -:  146:
        -:  147:// Calculate what type the 'cast' function should return, based on a requested
        -:  148:// type of To and a source type of From.
        -:  149:template <class To, class From> struct cast_retty_impl {
        -:  150:  using ret_type = To &; // Normal case, return Ty&
        -:  151:};
        -:  152:template <class To, class From> struct cast_retty_impl<To, const From> {
        -:  153:  using ret_type = const To &; // Normal case, return Ty&
        -:  154:};
        -:  155:
        -:  156:template <class To, class From> struct cast_retty_impl<To, From *> {
        -:  157:  using ret_type = To *; // Pointer arg case, return Ty*
        -:  158:};
        -:  159:
        -:  160:template <class To, class From> struct cast_retty_impl<To, const From *> {
        -:  161:  using ret_type = const To *; // Constant pointer arg case, return const Ty*
        -:  162:};
        -:  163:
        -:  164:template <class To, class From> struct cast_retty_impl<To, const From *const> {
        -:  165:  using ret_type = const To *; // Constant pointer arg case, return const Ty*
        -:  166:};
        -:  167:
        -:  168:template <class To, class From>
        -:  169:struct cast_retty_impl<To, std::unique_ptr<From>> {
        -:  170:private:
        -:  171:  using PointerType = typename cast_retty_impl<To, From *>::ret_type;
        -:  172:  using ResultType = std::remove_pointer_t<PointerType>;
        -:  173:
        -:  174:public:
        -:  175:  using ret_type = std::unique_ptr<ResultType>;
        -:  176:};
        -:  177:
        -:  178:template <class To, class From, class SimpleFrom> struct cast_retty_wrap {
        -:  179:  // When the simplified type and the from type are not the same, use the type
        -:  180:  // simplifier to reduce the type, then reuse cast_retty_impl to get the
        -:  181:  // resultant type.
        -:  182:  using ret_type = typename cast_retty<To, SimpleFrom>::ret_type;
        -:  183:};
        -:  184:
        -:  185:template <class To, class FromTy> struct cast_retty_wrap<To, FromTy, FromTy> {
        -:  186:  // When the simplified type is equal to the from type, use it directly.
        -:  187:  using ret_type = typename cast_retty_impl<To, FromTy>::ret_type;
        -:  188:};
        -:  189:
        -:  190:template <class To, class From> struct cast_retty {
        -:  191:  using ret_type = typename cast_retty_wrap<
        -:  192:      To, From, typename simplify_type<From>::SimpleType>::ret_type;
        -:  193:};
        -:  194:
        -:  195://===----------------------------------------------------------------------===//
        -:  196:// cast_convert_val
        -:  197://===----------------------------------------------------------------------===//
        -:  198:
        -:  199:// Ensure the non-simple values are converted using the simplify_type template
        -:  200:// that may be specialized by smart pointers...
        -:  201://
        -:  202:template <class To, class From, class SimpleFrom> struct cast_convert_val {
        -:  203:  // This is not a simple type, use the template to simplify it...
        -:  204:  static typename cast_retty<To, From>::ret_type doit(const From &Val) {
        -:  205:    return cast_convert_val<To, SimpleFrom,
        -:  206:                            typename simplify_type<SimpleFrom>::SimpleType>::
        -:  207:        doit(simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val)));
        -:  208:  }
        -:  209:};
        -:  210:
        -:  211:template <class To, class FromTy> struct cast_convert_val<To, FromTy, FromTy> {
        -:  212:  // If it's a reference, switch to a pointer to do the cast and then deref it.
        -:  213:  static typename cast_retty<To, FromTy>::ret_type doit(const FromTy &Val) {
        -:  214:    return *(std::remove_reference_t<typename cast_retty<To, FromTy>::ret_type>
        -:  215:                 *)&const_cast<FromTy &>(Val);
        -:  216:  }
        -:  217:};
        -:  218:
        -:  219:template <class To, class FromTy>
        -:  220:struct cast_convert_val<To, FromTy *, FromTy *> {
        -:  221:  // If it's a pointer, we can use c-style casting directly.
    #####:  222:  static typename cast_retty<To, FromTy *>::ret_type doit(const FromTy *Val) {
        -:  223:    return (typename cast_retty<To, FromTy *>::ret_type) const_cast<FromTy *>(
        -:  224:        Val);
        -:  225:  }
        -:  226:};
        -:  227:
        -:  228://===----------------------------------------------------------------------===//
        -:  229:// is_simple_type
        -:  230://===----------------------------------------------------------------------===//
        -:  231:
        -:  232:template <class X> struct is_simple_type {
        -:  233:  static const bool value =
        -:  234:      std::is_same<X, typename simplify_type<X>::SimpleType>::value;
        -:  235:};
        -:  236:
        -:  237:// } // namespace detail
        -:  238:
        -:  239://===----------------------------------------------------------------------===//
        -:  240:// CastIsPossible
        -:  241://===----------------------------------------------------------------------===//
        -:  242:
        -:  243:/// This struct provides a way to check if a given cast is possible. It provides
        -:  244:/// a static function called isPossible that is used to check if a cast can be
        -:  245:/// performed. It should be overridden like this:
        -:  246:///
        -:  247:/// template<> struct CastIsPossible<foo, bar> {
        -:  248:///   static inline bool isPossible(const bar &b) {
        -:  249:///     return bar.isFoo();
        -:  250:///   }
        -:  251:/// };
        -:  252:template <typename To, typename From, typename Enable = void>
        -:  253:struct CastIsPossible {
    #####:  254:  static inline bool isPossible(const From &f) {
        -:  255:    return isa_impl_wrap<
        -:  256:        To, const From,
    #####:  257:        typename simplify_type<const From>::SimpleType>::doit(f);
        -:  258:  }
        -:  259:};
        -:  260:
        -:  261:// Needed for optional unwrapping. This could be implemented with isa_impl, but
        -:  262:// we want to implement things in the new method and move old implementations
        -:  263:// over. In fact, some of the isa_impl templates should be moved over to
        -:  264:// CastIsPossible.
        -:  265:template <typename To, typename From>
        -:  266:struct CastIsPossible<To, Optional<From>> {
        -:  267:  static inline bool isPossible(const Optional<From> &f) {
        -:  268:    assert(f && "CastIsPossible::isPossible called on a nullopt!");
        -:  269:    return isa_impl_wrap<
        -:  270:        To, const From,
        -:  271:        typename simplify_type<const From>::SimpleType>::doit(*f);
        -:  272:  }
        -:  273:};
        -:  274:
        -:  275:/// Upcasting (from derived to base) and casting from a type to itself should
        -:  276:/// always be possible.
        -:  277:template <typename To, typename From>
        -:  278:struct CastIsPossible<To, From,
        -:  279:                      std::enable_if_t<std::is_base_of<To, From>::value>> {
        -:  280:  static inline bool isPossible(const From &f) { return true; }
        -:  281:};
        -:  282:
        -:  283://===----------------------------------------------------------------------===//
        -:  284:// Cast traits
        -:  285://===----------------------------------------------------------------------===//
        -:  286:
        -:  287:/// All of these cast traits are meant to be implementations for useful casts
        -:  288:/// that users may want to use that are outside the standard behavior. An
        -:  289:/// example of how to use a special cast called `CastTrait` is:
        -:  290:///
        -:  291:/// template<> struct CastInfo<foo, bar> : public CastTrait<foo, bar> {};
        -:  292:///
        -:  293:/// Essentially, if your use case falls directly into one of the use cases
        -:  294:/// supported by a given cast trait, simply inherit your special CastInfo
        -:  295:/// directly from one of these to avoid having to reimplement the boilerplate
        -:  296:/// `isPossible/castFailed/doCast/doCastIfPossible`. A cast trait can also
        -:  297:/// provide a subset of those functions.
        -:  298:
        -:  299:/// This cast trait just provides castFailed for the specified `To` type to make
        -:  300:/// CastInfo specializations more declarative. In order to use this, the target
        -:  301:/// result type must be `To` and `To` must be constructible from `nullptr`.
        -:  302:template <typename To> struct NullableValueCastFailed {
    #####:  303:  static To castFailed() { return To(nullptr); }
        -:  304:};
        -:  305:
        -:  306:/// This cast trait just provides the default implementation of doCastIfPossible
        -:  307:/// to make CastInfo specializations more declarative. The `Derived` template
        -:  308:/// parameter *must* be provided for forwarding castFailed and doCast.
        -:  309:template <typename To, typename From, typename Derived>
        -:  310:struct DefaultDoCastIfPossible {
    #####:  311:  static To doCastIfPossible(From f) {
    #####:  312:    if (!Derived::isPossible(f))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
branch 62 never executed
branch 63 never executed
branch 64 never executed
branch 65 never executed
branch 66 never executed
branch 67 never executed
branch 68 never executed
branch 69 never executed
branch 70 never executed
branch 71 never executed
branch 72 never executed
branch 73 never executed
branch 74 never executed
branch 75 never executed
branch 76 never executed
branch 77 never executed
branch 78 never executed
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 never executed
branch 84 never executed
branch 85 never executed
branch 86 never executed
branch 87 never executed
branch 88 never executed
branch 89 never executed
branch 90 never executed
branch 91 never executed
branch 92 never executed
branch 93 never executed
branch 94 never executed
branch 95 never executed
branch 96 never executed
branch 97 never executed
branch 98 never executed
branch 99 never executed
branch 100 never executed
branch 101 never executed
branch 102 never executed
branch 103 never executed
branch 104 never executed
branch 105 never executed
branch 106 never executed
branch 107 never executed
branch 108 never executed
branch 109 never executed
branch 110 never executed
branch 111 never executed
branch 112 never executed
branch 113 never executed
branch 114 never executed
branch 115 never executed
branch 116 never executed
branch 117 never executed
branch 118 never executed
branch 119 never executed
branch 120 never executed
branch 121 never executed
branch 122 never executed
branch 123 never executed
branch 124 never executed
branch 125 never executed
branch 126 never executed
branch 127 never executed
branch 128 never executed
branch 129 never executed
branch 130 never executed
branch 131 never executed
branch 132 never executed
branch 133 never executed
branch 134 never executed
branch 135 never executed
branch 136 never executed
branch 137 never executed
branch 138 never executed
branch 139 never executed
branch 140 never executed
branch 141 never executed
branch 142 never executed
branch 143 never executed
branch 144 never executed
branch 145 never executed
branch 146 never executed
branch 147 never executed
branch 148 never executed
branch 149 never executed
branch 150 never executed
branch 151 never executed
branch 152 never executed
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 never executed
branch 164 never executed
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 never executed
branch 178 never executed
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 never executed
branch 186 never executed
branch 187 never executed
branch 188 never executed
branch 189 never executed
branch 190 never executed
branch 191 never executed
branch 192 never executed
branch 193 never executed
branch 194 never executed
branch 195 never executed
branch 196 never executed
branch 197 never executed
branch 198 never executed
branch 199 never executed
branch 200 never executed
branch 201 never executed
branch 202 never executed
branch 203 never executed
branch 204 never executed
branch 205 never executed
branch 206 never executed
branch 207 never executed
branch 208 never executed
branch 209 never executed
branch 210 never executed
branch 211 never executed
branch 212 never executed
branch 213 never executed
branch 214 never executed
branch 215 never executed
branch 216 never executed
branch 217 never executed
branch 218 never executed
branch 219 never executed
branch 220 never executed
branch 221 never executed
branch 222 never executed
branch 223 never executed
branch 224 never executed
branch 225 never executed
branch 226 never executed
branch 227 never executed
branch 228 never executed
branch 229 never executed
branch 230 never executed
branch 231 never executed
branch 232 never executed
branch 233 never executed
branch 234 never executed
branch 235 never executed
branch 236 never executed
branch 237 never executed
branch 238 never executed
branch 239 never executed
branch 240 never executed
branch 241 never executed
branch 242 never executed
branch 243 never executed
branch 244 never executed
branch 245 never executed
branch 246 never executed
branch 247 never executed
branch 248 never executed
branch 249 never executed
branch 250 never executed
branch 251 never executed
branch 252 never executed
branch 253 never executed
branch 254 never executed
branch 255 never executed
branch 256 never executed
branch 257 never executed
branch 258 never executed
branch 259 never executed
branch 260 never executed
branch 261 never executed
branch 262 never executed
branch 263 never executed
branch 264 never executed
branch 265 never executed
branch 266 never executed
branch 267 never executed
branch 268 never executed
branch 269 never executed
branch 270 never executed
branch 271 never executed
branch 272 never executed
branch 273 never executed
branch 274 never executed
branch 275 never executed
branch 276 never executed
branch 277 never executed
branch 278 never executed
branch 279 never executed
branch 280 never executed
branch 281 never executed
branch 282 never executed
branch 283 never executed
branch 284 never executed
branch 285 never executed
branch 286 never executed
branch 287 never executed
branch 288 never executed
branch 289 never executed
branch 290 never executed
branch 291 never executed
branch 292 never executed
branch 293 never executed
branch 294 never executed
branch 295 never executed
branch 296 never executed
branch 297 never executed
branch 298 never executed
branch 299 never executed
branch 300 never executed
branch 301 never executed
branch 302 never executed
branch 303 never executed
branch 304 never executed
branch 305 never executed
branch 306 never executed
branch 307 never executed
branch 308 never executed
branch 309 never executed
branch 310 never executed
branch 311 never executed
branch 312 never executed
branch 313 never executed
branch 314 never executed
branch 315 never executed
branch 316 never executed
branch 317 never executed
branch 318 never executed
branch 319 never executed
branch 320 never executed
branch 321 never executed
branch 322 never executed
branch 323 never executed
branch 324 never executed
branch 325 never executed
branch 326 never executed
branch 327 never executed
branch 328 never executed
branch 329 never executed
branch 330 never executed
branch 331 never executed
branch 332 never executed
branch 333 never executed
branch 334 never executed
branch 335 never executed
branch 336 never executed
branch 337 never executed
branch 338 never executed
branch 339 never executed
branch 340 never executed
branch 341 never executed
branch 342 never executed
branch 343 never executed
branch 344 never executed
branch 345 never executed
branch 346 never executed
branch 347 never executed
branch 348 never executed
branch 349 never executed
branch 350 never executed
branch 351 never executed
branch 352 never executed
branch 353 never executed
branch 354 never executed
branch 355 never executed
branch 356 never executed
branch 357 never executed
branch 358 never executed
branch 359 never executed
branch 360 never executed
branch 361 never executed
branch 362 never executed
branch 363 never executed
branch 364 never executed
branch 365 never executed
branch 366 never executed
branch 367 never executed
branch 368 never executed
branch 369 never executed
branch 370 never executed
branch 371 never executed
branch 372 never executed
branch 373 never executed
branch 374 never executed
branch 375 never executed
branch 376 never executed
branch 377 never executed
branch 378 never executed
branch 379 never executed
branch 380 never executed
branch 381 never executed
branch 382 never executed
branch 383 never executed
branch 384 never executed
branch 385 never executed
branch 386 never executed
branch 387 never executed
branch 388 never executed
branch 389 never executed
branch 390 never executed
branch 391 never executed
branch 392 never executed
branch 393 never executed
branch 394 never executed
branch 395 never executed
branch 396 never executed
branch 397 never executed
branch 398 never executed
branch 399 never executed
branch 400 never executed
branch 401 never executed
branch 402 never executed
branch 403 never executed
branch 404 never executed
branch 405 never executed
branch 406 never executed
branch 407 never executed
branch 408 never executed
branch 409 never executed
branch 410 never executed
branch 411 never executed
        -:  313:      return Derived::castFailed();
    #####:  314:    return Derived::doCast(f);
        -:  315:  }
------------------
_ZN4llvm23DefaultDoCastIfPossibleIN4mlir4LLVM15LoopOptionsAttrEKNS1_9AttributeENS_8CastInfoIS3_S5_vEEE16doCastIfPossibleES4_:
function _ZN4llvm23DefaultDoCastIfPossibleIN4mlir4LLVM15LoopOptionsAttrEKNS1_9AttributeENS_8CastInfoIS3_S5_vEEE16doCastIfPossibleES4_ called 0 returned 0% blocks executed 0%
    #####:  311:  static To doCastIfPossible(From f) {
branch  0 never executed
branch  1 never executed
    #####:  312:    if (!Derived::isPossible(f))
branch  0 never executed
branch  1 never executed
        -:  313:      return Derived::castFailed();
    #####:  314:    return Derived::doCast(f);
        -:  315:  }
------------------
_ZN4llvm23DefaultDoCastIfPossibleIN4mlir13SymbolRefAttrEKNS1_9AttributeENS_8CastInfoIS2_S4_vEEE16doCastIfPossibleES3_:
function _ZN4llvm23DefaultDoCastIfPossibleIN4mlir13SymbolRefAttrEKNS1_9AttributeENS_8CastInfoIS2_S4_vEEE16doCastIfPossibleES3_ called 0 returned 0% blocks executed 0%
    #####:  311:  static To doCastIfPossible(From f) {
branch  0 never executed
branch  1 never executed
    #####:  312:    if (!Derived::isPossible(f))
branch  0 never executed
branch  1 never executed
        -:  313:      return Derived::castFailed();
    #####:  314:    return Derived::doCast(f);
        -:  315:  }
------------------
_ZN4llvm23DefaultDoCastIfPossibleIN4mlir4LLVM22FastmathFlagsInterfaceERNS1_9OperationENS_8CastInfoIS3_S4_vEEE16doCastIfPossibleES5_:
function _ZN4llvm23DefaultDoCastIfPossibleIN4mlir4LLVM22FastmathFlagsInterfaceERNS1_9OperationENS_8CastInfoIS3_S4_vEEE16doCastIfPossibleES5_ called 0 returned 0% blocks executed 0%
    #####:  311:  static To doCastIfPossible(From f) {
call    0 never executed
    #####:  312:    if (!Derived::isPossible(f))
branch  0 never executed
branch  1 never executed
        -:  313:      return Derived::castFailed();
    #####:  314:    return Derived::doCast(f);
        -:  315:  }
------------------
        -:  316:};
        -:  317:
        -:  318:namespace detail {
        -:  319:/// A helper to derive the type to use with `Self` for cast traits, when the
        -:  320:/// provided CRTP derived type is allowed to be void.
        -:  321:template <typename OptionalDerived, typename Default>
        -:  322:using SelfType = std::conditional_t<std::is_same<OptionalDerived, void>::value,
        -:  323:                                    Default, OptionalDerived>;
        -:  324:} // namespace detail
        -:  325:
        -:  326:/// This cast trait provides casting for the specific case of casting to a
        -:  327:/// value-typed object from a pointer-typed object. Note that `To` must be
        -:  328:/// nullable/constructible from a pointer to `From` to use this cast.
        -:  329:template <typename To, typename From, typename Derived = void>
        -:  330:struct ValueFromPointerCast
        -:  331:    : public CastIsPossible<To, From *>,
        -:  332:      public NullableValueCastFailed<To>,
        -:  333:      public DefaultDoCastIfPossible<
        -:  334:          To, From *,
        -:  335:          detail::SelfType<Derived, ValueFromPointerCast<To, From>>> {
        -:  336:  static inline To doCast(From *f) { return To(f); }
        -:  337:};
        -:  338:
        -:  339:/// This cast trait provides std::unique_ptr casting. It has the semantics of
        -:  340:/// moving the contents of the input unique_ptr into the output unique_ptr
        -:  341:/// during the cast. It's also a good example of how to implement a move-only
        -:  342:/// cast.
        -:  343:template <typename To, typename From, typename Derived = void>
        -:  344:struct UniquePtrCast : public CastIsPossible<To, From *> {
        -:  345:  using Self = detail::SelfType<Derived, UniquePtrCast<To, From>>;
        -:  346:  using CastResultType = std::unique_ptr<
        -:  347:      std::remove_reference_t<typename cast_retty<To, From>::ret_type>>;
        -:  348:
        -:  349:  static inline CastResultType doCast(std::unique_ptr<From> &&f) {
        -:  350:    return CastResultType((typename CastResultType::element_type *)f.release());
        -:  351:  }
        -:  352:
        -:  353:  static inline CastResultType castFailed() { return CastResultType(nullptr); }
        -:  354:
        -:  355:  static inline CastResultType doCastIfPossible(std::unique_ptr<From> &&f) {
        -:  356:    if (!Self::isPossible(f))
        -:  357:      return castFailed();
        -:  358:    return doCast(f);
        -:  359:  }
        -:  360:};
        -:  361:
        -:  362:/// This cast trait provides Optional<T> casting. This means that if you have a
        -:  363:/// value type, you can cast it to another value type and have dyn_cast return
        -:  364:/// an Optional<T>.
        -:  365:template <typename To, typename From, typename Derived = void>
        -:  366:struct OptionalValueCast
        -:  367:    : public CastIsPossible<To, From>,
        -:  368:      public DefaultDoCastIfPossible<
        -:  369:          Optional<To>, From,
        -:  370:          detail::SelfType<Derived, OptionalValueCast<To, From>>> {
        -:  371:  static inline Optional<To> castFailed() { return Optional<To>{}; }
        -:  372:
        -:  373:  static inline Optional<To> doCast(const From &f) { return To(f); }
        -:  374:};
        -:  375:
        -:  376:/// Provides a cast trait that strips `const` from types to make it easier to
        -:  377:/// implement a const-version of a non-const cast. It just removes boilerplate
        -:  378:/// and reduces the amount of code you as the user need to implement. You can
        -:  379:/// use it like this:
        -:  380:///
        -:  381:/// template<> struct CastInfo<foo, bar> {
        -:  382:///   ...verbose implementation...
        -:  383:/// };
        -:  384:///
        -:  385:/// template<> struct CastInfo<foo, const bar> : public
        -:  386:///        ConstStrippingForwardingCast<foo, const bar, CastInfo<foo, bar>> {};
        -:  387:///
        -:  388:template <typename To, typename From, typename ForwardTo>
        -:  389:struct ConstStrippingForwardingCast {
        -:  390:  // Remove the pointer if it exists, then we can get rid of consts/volatiles.
        -:  391:  using DecayedFrom = std::remove_cv_t<std::remove_pointer_t<From>>;
        -:  392:  // Now if it's a pointer, add it back. Otherwise, we want a ref.
        -:  393:  using NonConstFrom = std::conditional_t<std::is_pointer<From>::value,
        -:  394:                                          DecayedFrom *, DecayedFrom &>;
        -:  395:
    #####:  396:  static inline bool isPossible(const From &f) {
    #####:  397:    return ForwardTo::isPossible(const_cast<NonConstFrom>(f));
        -:  398:  }
        -:  399:
        -:  400:  static inline decltype(auto) castFailed() { return ForwardTo::castFailed(); }
        -:  401:
    #####:  402:  static inline decltype(auto) doCast(const From &f) {
call    0 never executed
    #####:  403:    return ForwardTo::doCast(const_cast<NonConstFrom>(f));
        -:  404:  }
        -:  405:
    #####:  406:  static inline decltype(auto) doCastIfPossible(const From &f) {
    #####:  407:    return ForwardTo::doCastIfPossible(const_cast<NonConstFrom>(f));
        -:  408:  }
        -:  409:};
        -:  410:
        -:  411:/// Provides a cast trait that uses a defined pointer to pointer cast as a base
        -:  412:/// for reference-to-reference casts. Note that it does not provide castFailed
        -:  413:/// and doCastIfPossible because a pointer-to-pointer cast would likely just
        -:  414:/// return `nullptr` which could cause nullptr dereference. You can use it like
        -:  415:/// this:
        -:  416:///
        -:  417:///   template <> struct CastInfo<foo, bar *> { ... verbose implementation... };
        -:  418:///
        -:  419:///   template <>
        -:  420:///   struct CastInfo<foo, bar>
        -:  421:///       : public ForwardToPointerCast<foo, bar, CastInfo<foo, bar *>> {};
        -:  422:///
        -:  423:template <typename To, typename From, typename ForwardTo>
        -:  424:struct ForwardToPointerCast {
        -:  425:  static inline bool isPossible(const From &f) {
        -:  426:    return ForwardTo::isPossible(&f);
        -:  427:  }
        -:  428:
        -:  429:  static inline decltype(auto) doCast(const From &f) {
        -:  430:    return *ForwardTo::doCast(&f);
        -:  431:  }
        -:  432:};
        -:  433:
        -:  434://===----------------------------------------------------------------------===//
        -:  435:// CastInfo
        -:  436://===----------------------------------------------------------------------===//
        -:  437:
        -:  438:/// This struct provides a method for customizing the way a cast is performed.
        -:  439:/// It inherits from CastIsPossible, to support the case of declaring many
        -:  440:/// CastIsPossible specializations without having to specialize the full
        -:  441:/// CastInfo.
        -:  442:///
        -:  443:/// In order to specialize different behaviors, specify different functions in
        -:  444:/// your CastInfo specialization.
        -:  445:/// For isa<> customization, provide:
        -:  446:///
        -:  447:///   `static bool isPossible(const From &f)`
        -:  448:///
        -:  449:/// For cast<> customization, provide:
        -:  450:///
        -:  451:///  `static To doCast(const From &f)`
        -:  452:///
        -:  453:/// For dyn_cast<> and the *_if_present<> variants' customization, provide:
        -:  454:///
        -:  455:///  `static To castFailed()` and `static To doCastIfPossible(const From &f)`
        -:  456:///
        -:  457:/// Your specialization might look something like this:
        -:  458:///
        -:  459:///  template<> struct CastInfo<foo, bar> : public CastIsPossible<foo, bar> {
        -:  460:///    static inline foo doCast(const bar &b) {
        -:  461:///      return foo(const_cast<bar &>(b));
        -:  462:///    }
        -:  463:///    static inline foo castFailed() { return foo(); }
        -:  464:///    static inline foo doCastIfPossible(const bar &b) {
        -:  465:///      if (!CastInfo<foo, bar>::isPossible(b))
        -:  466:///        return castFailed();
        -:  467:///      return doCast(b);
        -:  468:///    }
        -:  469:///  };
        -:  470:
        -:  471:// The default implementations of CastInfo don't use cast traits for now because
        -:  472:// we need to specify types all over the place due to the current expected
        -:  473:// casting behavior and the way cast_retty works. New use cases can and should
        -:  474:// take advantage of the cast traits whenever possible!
        -:  475:
        -:  476:template <typename To, typename From, typename Enable = void>
        -:  477:struct CastInfo : public CastIsPossible<To, From> {
        -:  478:  using Self = CastInfo<To, From, Enable>;
        -:  479:
        -:  480:  using CastReturnType = typename cast_retty<To, From>::ret_type;
        -:  481:
    #####:  482:  static inline CastReturnType doCast(const From &f) {
        -:  483:    return cast_convert_val<
        -:  484:        To, From,
    #####:  485:        typename simplify_type<From>::SimpleType>::doit(const_cast<From &>(f));
        -:  486:  }
        -:  487:
        -:  488:  // This assumes that you can construct the cast return type from `nullptr`.
        -:  489:  // This is largely to support legacy use cases - if you don't want this
        -:  490:  // behavior you should specialize CastInfo for your use case.
        -:  491:  static inline CastReturnType castFailed() { return CastReturnType(nullptr); }
        -:  492:
    #####:  493:  static inline CastReturnType doCastIfPossible(const From &f) {
    #####:  494:    if (!Self::isPossible(f))
branch  0 never executed
branch  1 never executed
        -:  495:      return castFailed();
    #####:  496:    return doCast(f);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  497:  }
        -:  498:};
        -:  499:
        -:  500:/// This struct provides an overload for CastInfo where From has simplify_type
        -:  501:/// defined. This simply forwards to the appropriate CastInfo with the
        -:  502:/// simplified type/value, so you don't have to implement both.
        -:  503:template <typename To, typename From>
        -:  504:struct CastInfo<To, From, std::enable_if_t<!is_simple_type<From>::value>> {
        -:  505:  using Self = CastInfo<To, From>;
        -:  506:  using SimpleFrom = typename simplify_type<From>::SimpleType;
        -:  507:  using SimplifiedSelf = CastInfo<To, SimpleFrom>;
        -:  508:
    #####:  509:  static inline bool isPossible(From &f) {
        -:  510:    return SimplifiedSelf::isPossible(
    #####:  511:        simplify_type<From>::getSimplifiedValue(f));
        -:  512:  }
        -:  513:
        -:  514:  static inline decltype(auto) doCast(From &f) {
        -:  515:    return SimplifiedSelf::doCast(simplify_type<From>::getSimplifiedValue(f));
        -:  516:  }
        -:  517:
        -:  518:  static inline decltype(auto) castFailed() {
        -:  519:    return SimplifiedSelf::castFailed();
        -:  520:  }
        -:  521:
        -:  522:  static inline decltype(auto) doCastIfPossible(From &f) {
        -:  523:    return SimplifiedSelf::doCastIfPossible(
        -:  524:        simplify_type<From>::getSimplifiedValue(f));
        -:  525:  }
        -:  526:};
        -:  527:
        -:  528://===----------------------------------------------------------------------===//
        -:  529:// Pre-specialized CastInfo
        -:  530://===----------------------------------------------------------------------===//
        -:  531:
        -:  532:/// Provide a CastInfo specialized for std::unique_ptr.
        -:  533:template <typename To, typename From>
        -:  534:struct CastInfo<To, std::unique_ptr<From>> : public UniquePtrCast<To, From> {};
        -:  535:
        -:  536:/// Provide a CastInfo specialized for Optional<From>. It's assumed that if the
        -:  537:/// input is Optional<From> that the output can be Optional<To>. If that's not
        -:  538:/// the case, specialize CastInfo for your use case.
        -:  539:template <typename To, typename From>
        -:  540:struct CastInfo<To, Optional<From>> : public OptionalValueCast<To, From> {};
        -:  541:
        -:  542:/// isa<X> - Return true if the parameter to the template is an instance of one
        -:  543:/// of the template type arguments.  Used like this:
        -:  544:///
        -:  545:///  if (isa<Type>(myVal)) { ... }
        -:  546:///  if (isa<Type0, Type1, Type2>(myVal)) { ... }
        -:  547:template <typename To, typename From>
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
call   22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir13SymbolRefAttrENS1_9AttributeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir13SymbolRefAttrENS1_9AttributeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir11IntegerTypeENS1_4TypeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir11IntegerTypeENS1_4TypeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir8TypeAttrENS1_9AttributeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir8TypeAttrENS1_9AttributeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir4LLVM15LLVMPointerTypeENS1_4TypeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir4LLVM15LLVMPointerTypeENS1_4TypeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir9ArrayAttrENS1_9AttributeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir9ArrayAttrENS1_9AttributeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
_ZN4llvm3isaIN4mlir14DictionaryAttrENS1_9AttributeEEEbRKT0_:
function _ZN4llvm3isaIN4mlir14DictionaryAttrENS1_9AttributeEEEbRKT0_ called 0 returned 0% blocks executed 0%
    #####:  548:[[nodiscard]] inline bool isa(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  549:  return CastInfo<To, const From>::isPossible(Val);
        -:  550:}
------------------
        -:  551:
        -:  552:template <typename First, typename Second, typename... Rest, typename From>
        -:  553:[[nodiscard]] inline bool isa(const From &Val) {
        -:  554:  return isa<First>(Val) || isa<Second, Rest...>(Val);
        -:  555:}
        -:  556:
        -:  557:/// cast<X> - Return the argument parameter cast to the specified type.  This
        -:  558:/// casting operator asserts that the type is correct, so it does not return
        -:  559:/// null on failure.  It does not allow a null argument (use cast_if_present for
        -:  560:/// that). It is typically used like this:
        -:  561:///
        -:  562:///  cast<Instruction>(myVal)->getParent()
        -:  563:
        -:  564:template <typename To, typename From>
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
call    1 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
call    0 never executed
call    1 never executed
        -:  568:}
------------------
_ZN4llvm4castIN4mlir11IntegerTypeENS1_4TypeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir11IntegerTypeENS1_4TypeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir13SymbolRefAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir13SymbolRefAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir20DenseIntElementsAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir20DenseIntElementsAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir8TypeAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir8TypeAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir4LLVM14LLVMStructTypeENS1_4TypeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir4LLVM14LLVMStructTypeENS1_4TypeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir11IntegerAttrENS_12PointerUnionIJS2_PNS_5ValueEEEEEEDcRKT0_:
function _ZN4llvm4castIN4mlir11IntegerAttrENS_12PointerUnionIJS2_PNS_5ValueEEEEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir4LLVM15LLVMPointerTypeENS1_4TypeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir4LLVM15LLVMPointerTypeENS1_4TypeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir9ArrayAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir9ArrayAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir14DictionaryAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir14DictionaryAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
_ZN4llvm4castIN4mlir12ElementsAttrENS1_9AttributeEEEDcRKT0_:
function _ZN4llvm4castIN4mlir12ElementsAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  565:[[nodiscard]] inline decltype(auto) cast(const From &Val) {
call    0 never executed
    #####:  566:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  567:  return CastInfo<To, const From>::doCast(Val);
        -:  568:}
------------------
        -:  569:
        -:  570:template <typename To, typename From>
        -:  571:[[nodiscard]] inline decltype(auto) cast(From &Val) {
        -:  572:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
        -:  573:  return CastInfo<To, From>::doCast(Val);
        -:  574:}
        -:  575:
        -:  576:template <typename To, typename From>
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_12FunctionTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_12FunctionTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_18ConstantAsMetadataENS_15ValueAsMetadataEEEDcPT0_:
function _ZN4llvm4castINS_18ConstantAsMetadataENS_15ValueAsMetadataEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_10VectorTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_10VectorTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_10StructTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_10StructTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_9ArrayTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_9ArrayTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_11PointerTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_11PointerTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_11IntegerTypeENS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_11IntegerTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
_ZN4llvm4castINS_11IntegerTypeEKNS_4TypeEEEDcPT0_:
function _ZN4llvm4castINS_11IntegerTypeEKNS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  577:[[nodiscard]] inline decltype(auto) cast(From *Val) {
    #####:  578:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  579:  return CastInfo<To, From *>::doCast(Val);
        -:  580:}
------------------
        -:  581:
        -:  582:template <typename To, typename From>
        -:  583:[[nodiscard]] inline decltype(auto) cast(std::unique_ptr<From> &&Val) {
        -:  584:  assert(isa<To>(Val) && "cast<Ty>() argument of incompatible type!");
        -:  585:  return CastInfo<To, std::unique_ptr<From>>::doCast(std::move(Val));
        -:  586:}
        -:  587:
        -:  588://===----------------------------------------------------------------------===//
        -:  589:// ValueIsPresent
        -:  590://===----------------------------------------------------------------------===//
        -:  591:
        -:  592:template <typename T>
        -:  593:constexpr bool IsNullable =
        -:  594:    std::is_pointer_v<T> || std::is_constructible_v<T, std::nullptr_t>;
        -:  595:
        -:  596:/// ValueIsPresent provides a way to check if a value is, well, present. For
        -:  597:/// pointers, this is the equivalent of checking against nullptr, for Optionals
        -:  598:/// this is the equivalent of checking hasValue(). It also provides a method for
        -:  599:/// unwrapping a value (think calling .value() on an optional).
        -:  600:
        -:  601:// Generic values can't *not* be present.
        -:  602:template <typename T, typename Enable = void> struct ValueIsPresent {
        -:  603:  using UnwrappedType = T;
    #####:  604:  static inline bool isPresent(const T &t) { return true; }
        -:  605:  static inline decltype(auto) unwrapValue(T &t) { return t; }
        -:  606:};
        -:  607:
        -:  608:// Optional provides its own way to check if something is present.
        -:  609:template <typename T> struct ValueIsPresent<Optional<T>> {
        -:  610:  using UnwrappedType = T;
        -:  611:  static inline bool isPresent(const Optional<T> &t) { return t.has_value(); }
        -:  612:  static inline decltype(auto) unwrapValue(Optional<T> &t) { return t.value(); }
        -:  613:};
        -:  614:
        -:  615:// If something is "nullable" then we just compare it to nullptr to see if it
        -:  616:// exists.
        -:  617:template <typename T>
        -:  618:struct ValueIsPresent<T, std::enable_if_t<IsNullable<T>>> {
        -:  619:  using UnwrappedType = T;
    #####:  620:  static inline bool isPresent(const T &t) { return t != T(nullptr); }
    #####:  621:  static inline decltype(auto) unwrapValue(T &t) { return t; }
        -:  622:};
        -:  623:
        -:  624:namespace detail {
        -:  625:// Convenience function we can use to check if a value is present. Because of
        -:  626:// simplify_type, we have to call it on the simplified type for now.
    #####:  627:template <typename T> inline bool isPresent(const T &t) {
    #####:  628:  return ValueIsPresent<typename simplify_type<T>::SimpleType>::isPresent(
    #####:  629:      simplify_type<T>::getSimplifiedValue(const_cast<T &>(t)));
        -:  630:}
        -:  631:
        -:  632:// Convenience function we can use to unwrap a value.
    #####:  633:template <typename T> inline decltype(auto) unwrapValue(T &t) {
    #####:  634:  return ValueIsPresent<T>::unwrapValue(t);
        -:  635:}
        -:  636:} // namespace detail
        -:  637:
        -:  638:/// dyn_cast<X> - Return the argument parameter cast to the specified type. This
        -:  639:/// casting operator returns null if the argument is of the wrong type, so it
        -:  640:/// can be used to test for a type as well as cast if successful. The value
        -:  641:/// passed in must be present, if not, use dyn_cast_if_present. This should be
        -:  642:/// used in the context of an if statement like this:
        -:  643:///
        -:  644:///  if (const Instruction *I = dyn_cast<Instruction>(myVal)) { ... }
        -:  645:
        -:  646:template <typename To, typename From>
function _ZN4llvm8dyn_castIN4mlir13SymbolRefAttrENS1_9AttributeEEEDcRKT0_ called 0 returned 0% blocks executed 0%
    #####:  647:[[nodiscard]] inline decltype(auto) dyn_cast(const From &Val) {
branch  0 never executed
branch  1 never executed
    #####:  648:  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  649:  return CastInfo<To, const From>::doCastIfPossible(Val);
call    0 never executed
        -:  650:}
        -:  651:
        -:  652:template <typename To, typename From>
    #####:  653:[[nodiscard]] inline decltype(auto) dyn_cast(From &Val) {
    #####:  654:  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
call   134 never executed
call   135 never executed
call   136 never executed
call   137 never executed
call   138 never executed
call   139 never executed
call   140 never executed
call   141 never executed
call   142 never executed
call   143 never executed
call   144 never executed
call   145 never executed
call   146 never executed
call   147 never executed
call   148 never executed
call   149 never executed
call   150 never executed
call   151 never executed
call   152 never executed
call   153 never executed
call   154 never executed
call   155 never executed
call   156 never executed
call   157 never executed
call   158 never executed
call   159 never executed
call   160 never executed
call   161 never executed
call   162 never executed
call   163 never executed
call   164 never executed
call   165 never executed
call   166 never executed
call   167 never executed
call   168 never executed
call   169 never executed
call   170 never executed
call   171 never executed
call   172 never executed
call   173 never executed
call   174 never executed
call   175 never executed
call   176 never executed
call   177 never executed
call   178 never executed
call   179 never executed
call   180 never executed
call   181 never executed
call   182 never executed
call   183 never executed
call   184 never executed
call   185 never executed
call   186 never executed
call   187 never executed
call   188 never executed
call   189 never executed
call   190 never executed
call   191 never executed
call   192 never executed
call   193 never executed
call   194 never executed
call   195 never executed
call   196 never executed
call   197 never executed
call   198 never executed
call   199 never executed
call   200 never executed
call   201 never executed
call   202 never executed
call   203 never executed
    #####:  655:  return CastInfo<To, From>::doCastIfPossible(Val);
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
branch 52 never executed
branch 53 never executed
branch 54 never executed
branch 55 never executed
branch 56 never executed
branch 57 never executed
branch 58 never executed
branch 59 never executed
branch 60 never executed
branch 61 never executed
branch 62 never executed
branch 63 never executed
branch 64 never executed
branch 65 never executed
branch 66 never executed
branch 67 never executed
branch 68 never executed
branch 69 never executed
branch 70 never executed
branch 71 never executed
branch 72 never executed
branch 73 never executed
branch 74 never executed
branch 75 never executed
branch 76 never executed
branch 77 never executed
branch 78 never executed
branch 79 never executed
branch 80 never executed
branch 81 never executed
branch 82 never executed
branch 83 never executed
branch 84 never executed
branch 85 never executed
branch 86 never executed
branch 87 never executed
branch 88 never executed
branch 89 never executed
branch 90 never executed
branch 91 never executed
branch 92 never executed
branch 93 never executed
branch 94 never executed
branch 95 never executed
branch 96 never executed
branch 97 never executed
branch 98 never executed
branch 99 never executed
branch 100 never executed
branch 101 never executed
branch 102 never executed
branch 103 never executed
branch 104 never executed
branch 105 never executed
branch 106 never executed
branch 107 never executed
branch 108 never executed
branch 109 never executed
branch 110 never executed
branch 111 never executed
branch 112 never executed
branch 113 never executed
branch 114 never executed
branch 115 never executed
branch 116 never executed
branch 117 never executed
branch 118 never executed
branch 119 never executed
branch 120 never executed
branch 121 never executed
branch 122 never executed
branch 123 never executed
branch 124 never executed
branch 125 never executed
branch 126 never executed
branch 127 never executed
branch 128 never executed
branch 129 never executed
branch 130 never executed
branch 131 never executed
branch 132 never executed
branch 133 never executed
branch 134 never executed
branch 135 never executed
branch 136 never executed
branch 137 never executed
branch 138 never executed
branch 139 never executed
branch 140 never executed
branch 141 never executed
branch 142 never executed
branch 143 never executed
branch 144 never executed
branch 145 never executed
branch 146 never executed
branch 147 never executed
branch 148 never executed
branch 149 never executed
branch 150 never executed
branch 151 never executed
branch 152 never executed
branch 153 never executed
branch 154 never executed
branch 155 never executed
branch 156 never executed
branch 157 never executed
branch 158 never executed
branch 159 never executed
branch 160 never executed
branch 161 never executed
branch 162 never executed
branch 163 never executed
branch 164 never executed
branch 165 never executed
branch 166 never executed
branch 167 never executed
branch 168 never executed
branch 169 never executed
branch 170 never executed
branch 171 never executed
branch 172 never executed
branch 173 never executed
branch 174 never executed
branch 175 never executed
branch 176 never executed
branch 177 never executed
branch 178 never executed
branch 179 never executed
branch 180 never executed
branch 181 never executed
branch 182 never executed
branch 183 never executed
branch 184 never executed
branch 185 never executed
branch 186 never executed
branch 187 never executed
branch 188 never executed
branch 189 never executed
branch 190 never executed
branch 191 never executed
branch 192 never executed
branch 193 never executed
branch 194 never executed
branch 195 never executed
branch 196 never executed
branch 197 never executed
branch 198 never executed
branch 199 never executed
branch 200 never executed
branch 201 never executed
branch 202 never executed
branch 203 never executed
branch 204 never executed
branch 205 never executed
branch 206 never executed
branch 207 never executed
branch 208 never executed
branch 209 never executed
branch 210 never executed
branch 211 never executed
branch 212 never executed
branch 213 never executed
branch 214 never executed
branch 215 never executed
branch 216 never executed
branch 217 never executed
branch 218 never executed
branch 219 never executed
branch 220 never executed
branch 221 never executed
branch 222 never executed
branch 223 never executed
branch 224 never executed
branch 225 never executed
branch 226 never executed
branch 227 never executed
branch 228 never executed
branch 229 never executed
branch 230 never executed
branch 231 never executed
branch 232 never executed
branch 233 never executed
branch 234 never executed
branch 235 never executed
branch 236 never executed
branch 237 never executed
branch 238 never executed
branch 239 never executed
branch 240 never executed
branch 241 never executed
branch 242 never executed
branch 243 never executed
branch 244 never executed
branch 245 never executed
branch 246 never executed
branch 247 never executed
branch 248 never executed
branch 249 never executed
branch 250 never executed
branch 251 never executed
branch 252 never executed
branch 253 never executed
branch 254 never executed
branch 255 never executed
branch 256 never executed
branch 257 never executed
branch 258 never executed
branch 259 never executed
branch 260 never executed
branch 261 never executed
branch 262 never executed
branch 263 never executed
branch 264 never executed
branch 265 never executed
branch 266 never executed
branch 267 never executed
branch 268 never executed
branch 269 never executed
branch 270 never executed
branch 271 never executed
branch 272 never executed
branch 273 never executed
branch 274 never executed
branch 275 never executed
branch 276 never executed
branch 277 never executed
branch 278 never executed
branch 279 never executed
branch 280 never executed
branch 281 never executed
branch 282 never executed
branch 283 never executed
branch 284 never executed
branch 285 never executed
branch 286 never executed
branch 287 never executed
branch 288 never executed
branch 289 never executed
branch 290 never executed
branch 291 never executed
branch 292 never executed
branch 293 never executed
branch 294 never executed
branch 295 never executed
branch 296 never executed
branch 297 never executed
branch 298 never executed
branch 299 never executed
branch 300 never executed
branch 301 never executed
branch 302 never executed
branch 303 never executed
branch 304 never executed
branch 305 never executed
branch 306 never executed
branch 307 never executed
branch 308 never executed
branch 309 never executed
branch 310 never executed
branch 311 never executed
branch 312 never executed
branch 313 never executed
branch 314 never executed
branch 315 never executed
branch 316 never executed
branch 317 never executed
branch 318 never executed
branch 319 never executed
branch 320 never executed
branch 321 never executed
branch 322 never executed
branch 323 never executed
branch 324 never executed
branch 325 never executed
branch 326 never executed
branch 327 never executed
branch 328 never executed
branch 329 never executed
branch 330 never executed
branch 331 never executed
branch 332 never executed
branch 333 never executed
branch 334 never executed
branch 335 never executed
branch 336 never executed
branch 337 never executed
branch 338 never executed
branch 339 never executed
branch 340 never executed
branch 341 never executed
branch 342 never executed
branch 343 never executed
branch 344 never executed
branch 345 never executed
branch 346 never executed
branch 347 never executed
branch 348 never executed
branch 349 never executed
branch 350 never executed
branch 351 never executed
branch 352 never executed
branch 353 never executed
branch 354 never executed
branch 355 never executed
branch 356 never executed
branch 357 never executed
branch 358 never executed
branch 359 never executed
branch 360 never executed
branch 361 never executed
branch 362 never executed
branch 363 never executed
branch 364 never executed
branch 365 never executed
branch 366 never executed
branch 367 never executed
branch 368 never executed
branch 369 never executed
branch 370 never executed
branch 371 never executed
branch 372 never executed
branch 373 never executed
branch 374 never executed
branch 375 never executed
branch 376 never executed
branch 377 never executed
branch 378 never executed
branch 379 never executed
branch 380 never executed
branch 381 never executed
branch 382 never executed
branch 383 never executed
branch 384 never executed
branch 385 never executed
branch 386 never executed
branch 387 never executed
branch 388 never executed
branch 389 never executed
branch 390 never executed
branch 391 never executed
branch 392 never executed
branch 393 never executed
branch 394 never executed
branch 395 never executed
branch 396 never executed
branch 397 never executed
branch 398 never executed
branch 399 never executed
branch 400 never executed
branch 401 never executed
branch 402 never executed
branch 403 never executed
branch 404 never executed
branch 405 never executed
branch 406 never executed
branch 407 never executed
branch 408 never executed
        -:  656:}
        -:  657:
        -:  658:template <typename To, typename From>
function _ZN4llvm8dyn_castINS_10VectorTypeENS_4TypeEEEDcPT0_ called 0 returned 0% blocks executed 0%
    #####:  659:[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {
    #####:  660:  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
call   17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
branch 21 never executed
branch 22 never executed
call   23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 never executed
branch 45 never executed
branch 46 never executed
call   47 never executed
branch 48 never executed
branch 49 never executed
call   50 never executed
branch 51 never executed
branch 52 never executed
call   53 never executed
branch 54 never executed
branch 55 never executed
call   56 never executed
branch 57 never executed
branch 58 never executed
call   59 never executed
branch 60 never executed
branch 61 never executed
call   62 never executed
branch 63 never executed
branch 64 never executed
call   65 never executed
branch 66 never executed
branch 67 never executed
call   68 never executed
branch 69 never executed
branch 70 never executed
call   71 never executed
branch 72 never executed
branch 73 never executed
call   74 never executed
    #####:  661:  return CastInfo<To, From *>::doCastIfPossible(Val);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
branch 50 never executed
branch 51 never executed
call   52 never executed
        -:  662:}
        -:  663:
        -:  664:template <typename To, typename From>
        -:  665:[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr<From> &&Val) {
        -:  666:  assert(detail::isPresent(Val) && "dyn_cast on a non-existent value");
        -:  667:  return CastInfo<To, std::unique_ptr<From>>::doCastIfPossible(
        -:  668:      std::forward<std::unique_ptr<From> &&>(Val));
        -:  669:}
        -:  670:
        -:  671:/// isa_and_present<X> - Functionally identical to isa, except that a null value
        -:  672:/// is accepted.
        -:  673:template <typename... X, class Y>
        -:  674:[[nodiscard]] inline bool isa_and_present(const Y &Val) {
        -:  675:  if (!detail::isPresent(Val))
        -:  676:    return false;
        -:  677:  return isa<X...>(Val);
        -:  678:}
        -:  679:
        -:  680:template <typename... X, class Y>
        -:  681:[[nodiscard]] inline bool isa_and_nonnull(const Y &Val) {
        -:  682:  return isa_and_present<X...>(Val);
        -:  683:}
        -:  684:
        -:  685:/// cast_if_present<X> - Functionally identical to cast, except that a null
        -:  686:/// value is accepted.
        -:  687:template <class X, class Y>
        -:  688:[[nodiscard]] inline auto cast_if_present(const Y &Val) {
        -:  689:  if (!detail::isPresent(Val))
        -:  690:    return CastInfo<X, const Y>::castFailed();
        -:  691:  assert(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!");
        -:  692:  return cast<X>(detail::unwrapValue(Val));
        -:  693:}
        -:  694:
        -:  695:template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y &Val) {
        -:  696:  if (!detail::isPresent(Val))
        -:  697:    return CastInfo<X, Y>::castFailed();
        -:  698:  assert(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!");
        -:  699:  return cast<X>(detail::unwrapValue(Val));
        -:  700:}
        -:  701:
    #####:  702:template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y *Val) {
    #####:  703:  if (!detail::isPresent(Val))
        -:  704:    return CastInfo<X, Y *>::castFailed();
    #####:  705:  assert(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!");
    #####:  706:  return cast<X>(detail::unwrapValue(Val));
        -:  707:}
        -:  708:
        -:  709:template <class X, class Y>
        -:  710:[[nodiscard]] inline auto cast_if_present(std::unique_ptr<Y> &&Val) {
        -:  711:  if (!detail::isPresent(Val))
        -:  712:    return UniquePtrCast<X, Y>::castFailed();
        -:  713:  return UniquePtrCast<X, Y>::doCast(std::move(Val));
        -:  714:}
        -:  715:
        -:  716:// Provide a forwarding from cast_or_null to cast_if_present for current
        -:  717:// users. This is deprecated and will be removed in a future patch, use
        -:  718:// cast_if_present instead.
        -:  719:template <class X, class Y> auto cast_or_null(const Y &Val) {
        -:  720:  return cast_if_present<X>(Val);
        -:  721:}
        -:  722:
        -:  723:template <class X, class Y> auto cast_or_null(Y &Val) {
        -:  724:  return cast_if_present<X>(Val);
        -:  725:}
        -:  726:
    #####:  727:template <class X, class Y> auto cast_or_null(Y *Val) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  728:  return cast_if_present<X>(Val);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  729:}
        -:  730:
        -:  731:template <class X, class Y> auto cast_or_null(std::unique_ptr<Y> &&Val) {
        -:  732:  return cast_if_present<X>(std::move(Val));
        -:  733:}
        -:  734:
        -:  735:/// dyn_cast_if_present<X> - Functionally identical to dyn_cast, except that a
        -:  736:/// null (or none in the case of optionals) value is accepted.
function _ZN4llvm19dyn_cast_if_presentIN4mlir17FlatSymbolRefAttrENS1_9AttributeEEEDaRKT0_ called 0 returned 0% blocks executed 0%
    #####:  737:template <class X, class Y> auto dyn_cast_if_present(const Y &Val) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  738:  if (!detail::isPresent(Val))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  739:    return CastInfo<X, const Y>::castFailed();
    #####:  740:  return CastInfo<X, const Y>::doCastIfPossible(detail::unwrapValue(Val));
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  741:}
        -:  742:
        -:  743:template <class X, class Y> auto dyn_cast_if_present(Y &Val) {
        -:  744:  if (!detail::isPresent(Val))
        -:  745:    return CastInfo<X, Y>::castFailed();
        -:  746:  return CastInfo<X, Y>::doCastIfPossible(detail::unwrapValue(Val));
        -:  747:}
        -:  748:
        -:  749:template <class X, class Y> auto dyn_cast_if_present(Y *Val) {
        -:  750:  if (!detail::isPresent(Val))
        -:  751:    return CastInfo<X, Y *>::castFailed();
        -:  752:  return CastInfo<X, Y *>::doCastIfPossible(detail::unwrapValue(Val));
        -:  753:}
        -:  754:
        -:  755:// Forwards to dyn_cast_if_present to avoid breaking current users. This is
        -:  756:// deprecated and will be removed in a future patch, use
        -:  757:// cast_if_present instead.
        -:  758:template <class X, class Y> auto dyn_cast_or_null(const Y &Val) {
        -:  759:  return dyn_cast_if_present<X>(Val);
        -:  760:}
        -:  761:
        -:  762:template <class X, class Y> auto dyn_cast_or_null(Y &Val) {
        -:  763:  return dyn_cast_if_present<X>(Val);
        -:  764:}
        -:  765:
        -:  766:template <class X, class Y> auto dyn_cast_or_null(Y *Val) {
        -:  767:  return dyn_cast_if_present<X>(Val);
        -:  768:}
        -:  769:
        -:  770:/// unique_dyn_cast<X> - Given a unique_ptr<Y>, try to return a unique_ptr<X>,
        -:  771:/// taking ownership of the input pointer iff isa<X>(Val) is true.  If the
        -:  772:/// cast is successful, From refers to nullptr on exit and the casted value
        -:  773:/// is returned.  If the cast is unsuccessful, the function returns nullptr
        -:  774:/// and From is unchanged.
        -:  775:template <class X, class Y>
        -:  776:[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
        -:  777:unique_dyn_cast(std::unique_ptr<Y> &Val) {
        -:  778:  if (!isa<X>(Val))
        -:  779:    return nullptr;
        -:  780:  return cast<X>(std::move(Val));
        -:  781:}
        -:  782:
        -:  783:template <class X, class Y>
        -:  784:[[nodiscard]] inline auto unique_dyn_cast(std::unique_ptr<Y> &&Val) {
        -:  785:  return unique_dyn_cast<X, Y>(Val);
        -:  786:}
        -:  787:
        -:  788:// unique_dyn_cast_or_null<X> - Functionally identical to unique_dyn_cast,
        -:  789:// except that a null value is accepted.
        -:  790:template <class X, class Y>
        -:  791:[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
        -:  792:unique_dyn_cast_or_null(std::unique_ptr<Y> &Val) {
        -:  793:  if (!Val)
        -:  794:    return nullptr;
        -:  795:  return unique_dyn_cast<X, Y>(Val);
        -:  796:}
        -:  797:
        -:  798:template <class X, class Y>
        -:  799:[[nodiscard]] inline auto unique_dyn_cast_or_null(std::unique_ptr<Y> &&Val) {
        -:  800:  return unique_dyn_cast_or_null<X, Y>(Val);
        -:  801:}
        -:  802:
        -:  803:} // end namespace llvm
        -:  804:
        -:  805:#endif // LLVM_SUPPORT_CASTING_H
