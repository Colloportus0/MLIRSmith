        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Affine/Utils/Utils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Affine/Utils/CMakeFiles/obj.MLIRAffineUtils.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Affine/Utils/CMakeFiles/obj.MLIRAffineUtils.dir/Utils.cpp.gcda
        -:    0:Runs:128624
        -:    1://===- Utils.cpp ---- Utilities for affine dialect transformation ---------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements miscellaneous transformation utilities for the Affine
        -:   10:// dialect.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#include "mlir/Dialect/Affine/Utils.h"
        -:   15:
        -:   16:#include "mlir/Dialect/Affine/Analysis/Utils.h"
        -:   17:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   18:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   19:#include "mlir/Dialect/Affine/LoopUtils.h"
        -:   20:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   21:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   22:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   23:#include "mlir/IR/AffineExprVisitor.h"
        -:   24:#include "mlir/IR/BlockAndValueMapping.h"
        -:   25:#include "mlir/IR/Dominance.h"
        -:   26:#include "mlir/IR/IntegerSet.h"
        -:   27:#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
        -:   28:
        -:   29:#define DEBUG_TYPE "affine-utils"
        -:   30:
        -:   31:using namespace mlir;
        -:   32:using namespace presburger;
        -:   33:
        -:   34:namespace {
        -:   35:/// Visit affine expressions recursively and build the sequence of operations
        -:   36:/// that correspond to it.  Visitation functions return an Value of the
        -:   37:/// expression subtree they visited or `nullptr` on error.
        -:   38:class AffineApplyExpander
        -:   39:    : public AffineExprVisitor<AffineApplyExpander, Value> {
        -:   40:public:
        -:   41:  /// This internal class expects arguments to be non-null, checks must be
        -:   42:  /// performed at the call site.
    #####:   43:  AffineApplyExpander(OpBuilder &builder, ValueRange dimValues,
        -:   44:                      ValueRange symbolValues, Location loc)
    #####:   45:      : builder(builder), dimValues(dimValues), symbolValues(symbolValues),
    #####:   46:        loc(loc) {}
        -:   47:
        -:   48:  template <typename OpTy>
    #####:   49:  Value buildBinaryExpr(AffineBinaryOpExpr expr) {
    #####:   50:    auto lhs = visit(expr.getLHS());
    #####:   51:    auto rhs = visit(expr.getRHS());
    #####:   52:    if (!lhs || !rhs)
    #####:   53:      return nullptr;
    #####:   54:    auto op = builder.create<OpTy>(loc, lhs, rhs);
    #####:   55:    return op.getResult();
        -:   56:  }
------------------
_ZN12_GLOBAL__N_119AffineApplyExpander15buildBinaryExprIN4mlir5arith6MulIOpEEENS2_5ValueENS2_18AffineBinaryOpExprE:
function _ZN12_GLOBAL__N_119AffineApplyExpander15buildBinaryExprIN4mlir5arith6MulIOpEEENS2_5ValueENS2_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   49:  Value buildBinaryExpr(AffineBinaryOpExpr expr) {
    #####:   50:    auto lhs = visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:   51:    auto rhs = visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:   52:    if (!lhs || !rhs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   53:      return nullptr;
    #####:   54:    auto op = builder.create<OpTy>(loc, lhs, rhs);
call    0 never executed
    #####:   55:    return op.getResult();
call    0 never executed
        -:   56:  }
------------------
_ZN12_GLOBAL__N_119AffineApplyExpander15buildBinaryExprIN4mlir5arith6AddIOpEEENS2_5ValueENS2_18AffineBinaryOpExprE:
function _ZN12_GLOBAL__N_119AffineApplyExpander15buildBinaryExprIN4mlir5arith6AddIOpEEENS2_5ValueENS2_18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   49:  Value buildBinaryExpr(AffineBinaryOpExpr expr) {
    #####:   50:    auto lhs = visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:   51:    auto rhs = visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:   52:    if (!lhs || !rhs)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   53:      return nullptr;
    #####:   54:    auto op = builder.create<OpTy>(loc, lhs, rhs);
call    0 never executed
    #####:   55:    return op.getResult();
call    0 never executed
        -:   56:  }
------------------
        -:   57:
function _ZN12_GLOBAL__N_119AffineApplyExpander12visitAddExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   58:  Value visitAddExpr(AffineBinaryOpExpr expr) {
    #####:   59:    return buildBinaryExpr<arith::AddIOp>(expr);
call    0 never executed
        -:   60:  }
        -:   61:
function _ZN12_GLOBAL__N_119AffineApplyExpander12visitMulExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   62:  Value visitMulExpr(AffineBinaryOpExpr expr) {
    #####:   63:    return buildBinaryExpr<arith::MulIOp>(expr);
call    0 never executed
        -:   64:  }
        -:   65:
        -:   66:  /// Euclidean modulo operation: negative RHS is not allowed.
        -:   67:  /// Remainder of the euclidean integer division is always non-negative.
        -:   68:  ///
        -:   69:  /// Implemented as
        -:   70:  ///
        -:   71:  ///     a mod b =
        -:   72:  ///         let remainder = srem a, b;
        -:   73:  ///             negative = a < 0 in
        -:   74:  ///         select negative, remainder + b, remainder.
function _ZN12_GLOBAL__N_119AffineApplyExpander12visitModExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   75:  Value visitModExpr(AffineBinaryOpExpr expr) {
    #####:   76:    auto rhsConst = expr.getRHS().dyn_cast<AffineConstantExpr>();
call    0 never executed
call    1 never executed
    #####:   77:    if (!rhsConst) {
branch  0 never executed
branch  1 never executed
    #####:   78:      emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:   79:          loc,
        -:   80:          "semi-affine expressions (modulo by non-const) are not supported");
    #####:   81:      return nullptr;
        -:   82:    }
    #####:   83:    if (rhsConst.getValue() <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   84:      emitError(loc, "modulo by non-positive value is not supported");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   85:      return nullptr;
        -:   86:    }
        -:   87:
    #####:   88:    auto lhs = visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:   89:    auto rhs = visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:   90:    assert(lhs && rhs && "unexpected affine expr lowering failure");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:   91:
    #####:   92:    Value remainder = builder.create<arith::RemSIOp>(loc, lhs, rhs);
call    0 never executed
call    1 never executed
    #####:   93:    Value zeroCst = builder.create<arith::ConstantIndexOp>(loc, 0);
call    0 never executed
call    1 never executed
    #####:   94:    Value isRemainderNegative = builder.create<arith::CmpIOp>(
    #####:   95:        loc, arith::CmpIPredicate::slt, remainder, zeroCst);
call    0 never executed
call    1 never executed
    #####:   96:    Value correctedRemainder =
    #####:   97:        builder.create<arith::AddIOp>(loc, remainder, rhs);
call    0 never executed
call    1 never executed
    #####:   98:    Value result = builder.create<arith::SelectOp>(
    #####:   99:        loc, isRemainderNegative, correctedRemainder, remainder);
call    0 never executed
    #####:  100:    return result;
        -:  101:  }
        -:  102:
        -:  103:  /// Floor division operation (rounds towards negative infinity).
        -:  104:  ///
        -:  105:  /// For positive divisors, it can be implemented without branching and with a
        -:  106:  /// single division operation as
        -:  107:  ///
        -:  108:  ///        a floordiv b =
        -:  109:  ///            let negative = a < 0 in
        -:  110:  ///            let absolute = negative ? -a - 1 : a in
        -:  111:  ///            let quotient = absolute / b in
        -:  112:  ///                negative ? -quotient - 1 : quotient
function _ZN12_GLOBAL__N_119AffineApplyExpander17visitFloorDivExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:  113:  Value visitFloorDivExpr(AffineBinaryOpExpr expr) {
    #####:  114:    auto rhsConst = expr.getRHS().dyn_cast<AffineConstantExpr>();
call    0 never executed
call    1 never executed
    #####:  115:    if (!rhsConst) {
branch  0 never executed
branch  1 never executed
    #####:  116:      emitError(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  117:          loc,
        -:  118:          "semi-affine expressions (division by non-const) are not supported");
    #####:  119:      return nullptr;
        -:  120:    }
    #####:  121:    if (rhsConst.getValue() <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  122:      emitError(loc, "division by non-positive value is not supported");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  123:      return nullptr;
        -:  124:    }
        -:  125:
    #####:  126:    auto lhs = visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:  127:    auto rhs = visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:  128:    assert(lhs && rhs && "unexpected affine expr lowering failure");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  129:
    #####:  130:    Value zeroCst = builder.create<arith::ConstantIndexOp>(loc, 0);
call    0 never executed
call    1 never executed
    #####:  131:    Value noneCst = builder.create<arith::ConstantIndexOp>(loc, -1);
call    0 never executed
call    1 never executed
    #####:  132:    Value negative = builder.create<arith::CmpIOp>(
    #####:  133:        loc, arith::CmpIPredicate::slt, lhs, zeroCst);
call    0 never executed
call    1 never executed
    #####:  134:    Value negatedDecremented = builder.create<arith::SubIOp>(loc, noneCst, lhs);
call    0 never executed
call    1 never executed
    #####:  135:    Value dividend =
    #####:  136:        builder.create<arith::SelectOp>(loc, negative, negatedDecremented, lhs);
call    0 never executed
call    1 never executed
    #####:  137:    Value quotient = builder.create<arith::DivSIOp>(loc, dividend, rhs);
call    0 never executed
call    1 never executed
    #####:  138:    Value correctedQuotient =
    #####:  139:        builder.create<arith::SubIOp>(loc, noneCst, quotient);
call    0 never executed
call    1 never executed
    #####:  140:    Value result = builder.create<arith::SelectOp>(loc, negative,
    #####:  141:                                                   correctedQuotient, quotient);
call    0 never executed
    #####:  142:    return result;
        -:  143:  }
        -:  144:
        -:  145:  /// Ceiling division operation (rounds towards positive infinity).
        -:  146:  ///
        -:  147:  /// For positive divisors, it can be implemented without branching and with a
        -:  148:  /// single division operation as
        -:  149:  ///
        -:  150:  ///     a ceildiv b =
        -:  151:  ///         let negative = a <= 0 in
        -:  152:  ///         let absolute = negative ? -a : a - 1 in
        -:  153:  ///         let quotient = absolute / b in
        -:  154:  ///             negative ? -quotient : quotient + 1
function _ZN12_GLOBAL__N_119AffineApplyExpander16visitCeilDivExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:  155:  Value visitCeilDivExpr(AffineBinaryOpExpr expr) {
    #####:  156:    auto rhsConst = expr.getRHS().dyn_cast<AffineConstantExpr>();
call    0 never executed
call    1 never executed
    #####:  157:    if (!rhsConst) {
branch  0 never executed
branch  1 never executed
    #####:  158:      emitError(loc) << "semi-affine expressions (division by non-const) are "
call    0 never executed
call    1 never executed
    #####:  159:                        "not supported";
call    0 never executed
    #####:  160:      return nullptr;
        -:  161:    }
    #####:  162:    if (rhsConst.getValue() <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  163:      emitError(loc, "division by non-positive value is not supported");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  164:      return nullptr;
        -:  165:    }
    #####:  166:    auto lhs = visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:  167:    auto rhs = visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:  168:    assert(lhs && rhs && "unexpected affine expr lowering failure");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  169:
    #####:  170:    Value zeroCst = builder.create<arith::ConstantIndexOp>(loc, 0);
call    0 never executed
call    1 never executed
    #####:  171:    Value oneCst = builder.create<arith::ConstantIndexOp>(loc, 1);
call    0 never executed
call    1 never executed
    #####:  172:    Value nonPositive = builder.create<arith::CmpIOp>(
    #####:  173:        loc, arith::CmpIPredicate::sle, lhs, zeroCst);
call    0 never executed
call    1 never executed
    #####:  174:    Value negated = builder.create<arith::SubIOp>(loc, zeroCst, lhs);
call    0 never executed
call    1 never executed
    #####:  175:    Value decremented = builder.create<arith::SubIOp>(loc, lhs, oneCst);
call    0 never executed
call    1 never executed
    #####:  176:    Value dividend =
    #####:  177:        builder.create<arith::SelectOp>(loc, nonPositive, negated, decremented);
call    0 never executed
call    1 never executed
    #####:  178:    Value quotient = builder.create<arith::DivSIOp>(loc, dividend, rhs);
call    0 never executed
call    1 never executed
    #####:  179:    Value negatedQuotient =
    #####:  180:        builder.create<arith::SubIOp>(loc, zeroCst, quotient);
call    0 never executed
call    1 never executed
    #####:  181:    Value incrementedQuotient =
    #####:  182:        builder.create<arith::AddIOp>(loc, quotient, oneCst);
call    0 never executed
call    1 never executed
    #####:  183:    Value result = builder.create<arith::SelectOp>(
    #####:  184:        loc, nonPositive, negatedQuotient, incrementedQuotient);
call    0 never executed
    #####:  185:    return result;
        -:  186:  }
        -:  187:
        -:  188:  Value visitConstantExpr(AffineConstantExpr expr) {
        -:  189:    auto op = builder.create<arith::ConstantIndexOp>(loc, expr.getValue());
        -:  190:    return op.getResult();
        -:  191:  }
        -:  192:
function _ZN12_GLOBAL__N_119AffineApplyExpander12visitDimExprEN4mlir13AffineDimExprE called 0 returned 0% blocks executed 0%
    #####:  193:  Value visitDimExpr(AffineDimExpr expr) {
    #####:  194:    assert(expr.getPosition() < dimValues.size() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  195:           "affine dim position out of range");
    #####:  196:    return dimValues[expr.getPosition()];
call    0 never executed
call    1 never executed
        -:  197:  }
        -:  198:
function _ZN12_GLOBAL__N_119AffineApplyExpander15visitSymbolExprEN4mlir16AffineSymbolExprE called 0 returned 0% blocks executed 0%
    #####:  199:  Value visitSymbolExpr(AffineSymbolExpr expr) {
    #####:  200:    assert(expr.getPosition() < symbolValues.size() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  201:           "symbol dim position out of range");
    #####:  202:    return symbolValues[expr.getPosition()];
call    0 never executed
call    1 never executed
        -:  203:  }
        -:  204:
        -:  205:private:
        -:  206:  OpBuilder &builder;
        -:  207:  ValueRange dimValues;
        -:  208:  ValueRange symbolValues;
        -:  209:
        -:  210:  Location loc;
        -:  211:};
        -:  212:} // namespace
        -:  213:
        -:  214:/// Create a sequence of operations that implement the `expr` applied to the
        -:  215:/// given dimension and symbol values.
function _ZN4mlir16expandAffineExprERNS_9OpBuilderENS_8LocationENS_10AffineExprENS_10ValueRangeES4_ called 0 returned 0% blocks executed 0%
    #####:  216:mlir::Value mlir::expandAffineExpr(OpBuilder &builder, Location loc,
        -:  217:                                   AffineExpr expr, ValueRange dimValues,
        -:  218:                                   ValueRange symbolValues) {
    #####:  219:  return AffineApplyExpander(builder, dimValues, symbolValues, loc).visit(expr);
call    0 never executed
        -:  220:}
        -:  221:
        -:  222:/// Create a sequence of operations that implement the `affineMap` applied to
        -:  223:/// the given `operands` (as it it were an AffineApplyOp).
function _ZN4mlir15expandAffineMapERNS_9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  224:Optional<SmallVector<Value, 8>> mlir::expandAffineMap(OpBuilder &builder,
        -:  225:                                                      Location loc,
        -:  226:                                                      AffineMap affineMap,
        -:  227:                                                      ValueRange operands) {
    #####:  228:  auto numDims = affineMap.getNumDims();
call    0 never executed
    #####:  229:  auto expanded = llvm::to_vector<8>(
    #####:  230:      llvm::map_range(affineMap.getResults(),
function _ZZN4mlir15expandAffineMapERNS_9OpBuilderENS_8LocationENS_9AffineMapENS_10ValueRangeEENKUlNS_10AffineExprEE_clES5_ called 0 returned 0% blocks executed 0%
    #####:  231:                      [numDims, &builder, loc, operands](AffineExpr expr) {
call    0 never executed
    #####:  232:                        return expandAffineExpr(builder, loc, expr,
        -:  233:                                                operands.take_front(numDims),
    #####:  234:                                                operands.drop_front(numDims));
call    0 never executed
call    1 never executed
    #####:  235:                      }));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  236:  if (llvm::all_of(expanded, [](Value v) { return v; }))
branch  0 never executed
branch  1 never executed
    #####:  237:    return expanded;
branch  0 never executed
branch  1 never executed
    #####:  238:  return None;
branch  0 never executed
branch  1 never executed
        -:  239:}
        -:  240:
        -:  241:/// Promotes the `then` or the `else` block of `ifOp` (depending on whether
        -:  242:/// `elseBlock` is false or true) into `ifOp`'s containing block, and discards
        -:  243:/// the rest of the op.
function _ZL14promoteIfBlockN4mlir10AffineIfOpEb called 0 returned 0% blocks executed 0%
    #####:  244:static void promoteIfBlock(AffineIfOp ifOp, bool elseBlock) {
    #####:  245:  if (elseBlock)
branch  0 never executed
branch  1 never executed
    #####:  246:    assert(ifOp.hasElse() && "else block expected");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  247:
    #####:  248:  Block *destBlock = ifOp->getBlock();
branch  0 never executed
branch  1 never executed
    #####:  249:  Block *srcBlock = elseBlock ? ifOp.getElseBlock() : ifOp.getThenBlock();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  250:  destBlock->getOperations().splice(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  251:      Block::iterator(ifOp), srcBlock->getOperations(), srcBlock->begin(),
call    0 never executed
        -:  252:      std::prev(srcBlock->end()));
    #####:  253:  ifOp.erase();
call    0 never executed
    #####:  254:}
        -:  255:
        -:  256:/// Returns the outermost affine.for/parallel op that the `ifOp` is invariant
        -:  257:/// on. The `ifOp` could be hoisted and placed right before such an operation.
        -:  258:/// This method assumes that the ifOp has been canonicalized (to be correct and
        -:  259:/// effective).
function _ZL26getOutermostInvariantForOpN4mlir10AffineIfOpE called 0 returned 0% blocks executed 0%
    #####:  260:static Operation *getOutermostInvariantForOp(AffineIfOp ifOp) {
        -:  261:  // Walk up the parents past all for op that this conditional is invariant on.
    #####:  262:  auto ifOperands = ifOp.getOperands();
call    0 never executed
    #####:  263:  auto *res = ifOp.getOperation();
    #####:  264:  while (!isa<func::FuncOp>(res->getParentOp())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  265:    auto *parentOp = res->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  266:    if (auto forOp = dyn_cast<AffineForOp>(parentOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  267:      if (llvm::is_contained(ifOperands, forOp.getInductionVar()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  268:        break;
    #####:  269:    } else if (auto parallelOp = dyn_cast<AffineParallelOp>(parentOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  270:      for (auto iv : parallelOp.getIVs())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  271:        if (llvm::is_contained(ifOperands, iv))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  272:          break;
    #####:  273:    } else if (!isa<AffineIfOp>(parentOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  274:      // Won't walk up past anything other than affine.for/if ops.
        -:  275:      break;
        -:  276:    }
        -:  277:    // You can always hoist up past any affine.if ops.
    #####:  278:    res = parentOp;
        -:  279:  }
    #####:  280:  return res;
        -:  281:}
        -:  282:
        -:  283:/// A helper for the mechanics of mlir::hoistAffineIfOp. Hoists `ifOp` just over
        -:  284:/// `hoistOverOp`. Returns the new hoisted op if any hoisting happened,
        -:  285:/// otherwise the same `ifOp`.
function _ZL15hoistAffineIfOpN4mlir10AffineIfOpEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  286:static AffineIfOp hoistAffineIfOp(AffineIfOp ifOp, Operation *hoistOverOp) {
        -:  287:  // No hoisting to do.
    #####:  288:  if (hoistOverOp == ifOp)
branch  0 never executed
branch  1 never executed
    #####:  289:    return ifOp;
        -:  290:
        -:  291:  // Create the hoisted 'if' first. Then, clone the op we are hoisting over for
        -:  292:  // the else block. Then drop the else block of the original 'if' in the 'then'
        -:  293:  // branch while promoting its then block, and analogously drop the 'then'
        -:  294:  // block of the original 'if' from the 'else' branch while promoting its else
        -:  295:  // block.
    #####:  296:  BlockAndValueMapping operandMap;
call    0 never executed
    #####:  297:  OpBuilder b(hoistOverOp);
call    0 never executed
    #####:  298:  auto hoistedIfOp = b.create<AffineIfOp>(ifOp.getLoc(), ifOp.getIntegerSet(),
    #####:  299:                                          ifOp.getOperands(),
call    0 never executed
    #####:  300:                                          /*elseBlock=*/true);
call    0 never executed
call    1 never executed
        -:  301:
        -:  302:  // Create a clone of hoistOverOp to use for the else branch of the hoisted
        -:  303:  // conditional. The else block may get optimized away if empty.
    #####:  304:  Operation *hoistOverOpClone = nullptr;
        -:  305:  // We use this unique name to identify/find  `ifOp`'s clone in the else
        -:  306:  // version.
    #####:  307:  StringAttr idForIfOp = b.getStringAttr("__mlir_if_hoisting");
call    0 never executed
call    1 never executed
    #####:  308:  operandMap.clear();
call    0 never executed
    #####:  309:  b.setInsertionPointAfter(hoistOverOp);
call    0 never executed
        -:  310:  // We'll set an attribute to identify this op in a clone of this sub-tree.
    #####:  311:  ifOp->setAttr(idForIfOp, b.getBoolAttr(true));
call    0 never executed
call    1 never executed
    #####:  312:  hoistOverOpClone = b.clone(*hoistOverOp, operandMap);
call    0 never executed
        -:  313:
        -:  314:  // Promote the 'then' block of the original affine.if in the then version.
    #####:  315:  promoteIfBlock(ifOp, /*elseBlock=*/false);
call    0 never executed
        -:  316:
        -:  317:  // Move the then version to the hoisted if op's 'then' block.
    #####:  318:  auto *thenBlock = hoistedIfOp.getThenBlock();
call    0 never executed
    #####:  319:  thenBlock->getOperations().splice(thenBlock->begin(),
call    0 never executed
    #####:  320:                                    hoistOverOp->getBlock()->getOperations(),
branch  0 never executed
branch  1 never executed
        -:  321:                                    Block::iterator(hoistOverOp));
        -:  322:
        -:  323:  // Find the clone of the original affine.if op in the else version.
    #####:  324:  AffineIfOp ifCloneInElse;
call    0 never executed
function _ZZL15hoistAffineIfOpN4mlir10AffineIfOpEPNS_9OperationEENKUlS0_E_clES0_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  325:  hoistOverOpClone->walk([&](AffineIfOp ifClone) {
    #####:  326:    if (!ifClone->getAttr(idForIfOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:      return WalkResult::advance();
    #####:  328:    ifCloneInElse = ifClone;
    #####:  329:    return WalkResult::interrupt();
    #####:  330:  });
call    0 never executed
    #####:  331:  assert(ifCloneInElse && "if op clone should exist");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  332:  // For the else block, promote the else block of the original 'if' if it had
        -:  333:  // one; otherwise, the op itself is to be erased.
    #####:  334:  if (!ifCloneInElse.hasElse())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  335:    ifCloneInElse.erase();
call    0 never executed
        -:  336:  else
    #####:  337:    promoteIfBlock(ifCloneInElse, /*elseBlock=*/true);
call    0 never executed
        -:  338:
        -:  339:  // Move the else version into the else block of the hoisted if op.
    #####:  340:  auto *elseBlock = hoistedIfOp.getElseBlock();
call    0 never executed
    #####:  341:  elseBlock->getOperations().splice(
call    0 never executed
    #####:  342:      elseBlock->begin(), hoistOverOpClone->getBlock()->getOperations(),
branch  0 never executed
branch  1 never executed
        -:  343:      Block::iterator(hoistOverOpClone));
        -:  344:
    #####:  345:  return hoistedIfOp;
call    0 never executed
        -:  346:}
        -:  347:
        -:  348:LogicalResult
function _ZN4mlir17affineParallelizeENS_11AffineForOpEN4llvm8ArrayRefINS_13LoopReductionEEE called 0 returned 0% blocks executed 0%
    #####:  349:mlir::affineParallelize(AffineForOp forOp,
        -:  350:                        ArrayRef<LoopReduction> parallelReductions) {
        -:  351:  // Fail early if there are iter arguments that are not reductions.
    #####:  352:  unsigned numReductions = parallelReductions.size();
call    0 never executed
    #####:  353:  if (numReductions != forOp.getNumIterOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  354:    return failure();
        -:  355:
    #####:  356:  Location loc = forOp.getLoc();
call    0 never executed
    #####:  357:  OpBuilder outsideBuilder(forOp);
call    0 never executed
    #####:  358:  AffineMap lowerBoundMap = forOp.getLowerBoundMap();
call    0 never executed
    #####:  359:  ValueRange lowerBoundOperands = forOp.getLowerBoundOperands();
call    0 never executed
call    1 never executed
    #####:  360:  AffineMap upperBoundMap = forOp.getUpperBoundMap();
call    0 never executed
    #####:  361:  ValueRange upperBoundOperands = forOp.getUpperBoundOperands();
call    0 never executed
call    1 never executed
        -:  362:
        -:  363:  // Creating empty 1-D affine.parallel op.
    #####:  364:  auto reducedValues = llvm::to_vector<4>(llvm::map_range(
    #####:  365:      parallelReductions, [](const LoopReduction &red) { return red.value; }));
call    0 never executed
    #####:  366:  auto reductionKinds = llvm::to_vector<4>(llvm::map_range(
    #####:  367:      parallelReductions, [](const LoopReduction &red) { return red.kind; }));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  368:  AffineParallelOp newPloop = outsideBuilder.create<AffineParallelOp>(
    #####:  369:      loc, ValueRange(reducedValues).getTypes(), reductionKinds,
call    0 never executed
    #####:  370:      llvm::makeArrayRef(lowerBoundMap), lowerBoundOperands,
    #####:  371:      llvm::makeArrayRef(upperBoundMap), upperBoundOperands,
call    0 never executed
    #####:  372:      llvm::makeArrayRef(forOp.getStep()));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  373:  // Steal the body of the old affine for op.
    #####:  374:  newPloop.getRegion().takeBody(forOp.getRegion());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  375:  Operation *yieldOp = &newPloop.getBody()->back();
call    0 never executed
call    1 never executed
        -:  376:
        -:  377:  // Handle the initial values of reductions because the parallel loop always
        -:  378:  // starts from the neutral value.
    #####:  379:  SmallVector<Value> newResults;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  380:  newResults.reserve(numReductions);
branch  0 never executed
branch  1 never executed
    #####:  381:  for (unsigned i = 0; i < numReductions; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  382:    Value init = forOp.getIterOperands()[i];
call    0 never executed
call    1 never executed
        -:  383:    // This works because we are only handling single-op reductions at the
        -:  384:    // moment. A switch on reduction kind or a mechanism to collect operations
        -:  385:    // participating in the reduction will be necessary for multi-op reductions.
    #####:  386:    Operation *reductionOp = yieldOp->getOperand(i).getDefiningOp();
call    0 never executed
call    1 never executed
    #####:  387:    assert(reductionOp && "yielded value is expected to be produced by an op");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  388:    outsideBuilder.getInsertionBlock()->getOperations().splice(
call    0 never executed
call    1 never executed
    #####:  389:        outsideBuilder.getInsertionPoint(), newPloop.getBody()->getOperations(),
call    0 never executed
call    1 never executed
        -:  390:        reductionOp);
    #####:  391:    reductionOp->setOperands({init, newPloop->getResult(i)});
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  392:    forOp->getResult(i).replaceAllUsesWith(reductionOp->getResult(0));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  393:  }
        -:  394:
        -:  395:  // Update the loop terminator to yield reduced values bypassing the reduction
        -:  396:  // operation itself (now moved outside of the loop) and erase the block
        -:  397:  // arguments that correspond to reductions. Note that the loop always has one
        -:  398:  // "main" induction variable whenc coming from a non-parallel for.
    #####:  399:  unsigned numIVs = 1;
    #####:  400:  yieldOp->setOperands(reducedValues);
call    0 never executed
call    1 never executed
    #####:  401:  newPloop.getBody()->eraseArguments(numIVs, numReductions);
call    0 never executed
call    1 never executed
        -:  402:
    #####:  403:  forOp.erase();
call    0 never executed
    #####:  404:  return success();
branch  0 never executed
branch  1 never executed
        -:  405:}
        -:  406:
        -:  407:// Returns success if any hoisting happened.
function _ZN4mlir15hoistAffineIfOpENS_10AffineIfOpEPb called 0 returned 0% blocks executed 0%
    #####:  408:LogicalResult mlir::hoistAffineIfOp(AffineIfOp ifOp, bool *folded) {
        -:  409:  // Bail out early if the ifOp returns a result.  TODO: Consider how to
        -:  410:  // properly support this case.
    #####:  411:  if (ifOp.getNumResults() != 0)
branch  0 never executed
branch  1 never executed
    #####:  412:    return failure();
        -:  413:
        -:  414:  // Apply canonicalization patterns and folding - this is necessary for the
        -:  415:  // hoisting check to be correct (operands should be composed), and to be more
        -:  416:  // effective (no unused operands). Since the pattern rewriter's folding is
        -:  417:  // entangled with application of patterns, we may fold/end up erasing the op,
        -:  418:  // in which case we return with `folded` being set.
    #####:  419:  RewritePatternSet patterns(ifOp.getContext());
call    0 never executed
call    1 never executed
    #####:  420:  AffineIfOp::getCanonicalizationPatterns(patterns, ifOp.getContext());
call    0 never executed
call    1 never executed
    #####:  421:  bool erased;
    #####:  422:  FrozenRewritePatternSet frozenPatterns(std::move(patterns));
call    0 never executed
call    1 never executed
    #####:  423:  (void)applyOpPatternsAndFold(ifOp, frozenPatterns, &erased);
call    0 never executed
    #####:  424:  if (erased) {
branch  0 never executed
branch  1 never executed
    #####:  425:    if (folded)
branch  0 never executed
branch  1 never executed
    #####:  426:      *folded = true;
    #####:  427:    return failure();
        -:  428:  }
    #####:  429:  if (folded)
branch  0 never executed
branch  1 never executed
    #####:  430:    *folded = false;
        -:  431:
        -:  432:  // The folding above should have ensured this, but the affine.if's
        -:  433:  // canonicalization is missing composition of affine.applys into it.
function _ZZN4mlir15hoistAffineIfOpENS_10AffineIfOpEPbENKUlNS_5ValueEE_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  434:  assert(llvm::all_of(ifOp.getOperands(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
        -:  435:                      [](Value v) {
        -:  436:                        return isTopLevelValue(v) || isForInductionVar(v);
        -:  437:                      }) &&
        -:  438:         "operands not composed");
        -:  439:
        -:  440:  // We are going hoist as high as possible.
        -:  441:  // TODO: this could be customized in the future.
    #####:  442:  auto *hoistOverOp = getOutermostInvariantForOp(ifOp);
call    0 never executed
        -:  443:
    #####:  444:  AffineIfOp hoistedIfOp = ::hoistAffineIfOp(ifOp, hoistOverOp);
call    0 never executed
        -:  445:  // Nothing to hoist over.
    #####:  446:  if (hoistedIfOp == ifOp)
branch  0 never executed
branch  1 never executed
    #####:  447:    return failure();
        -:  448:
        -:  449:  // Canonicalize to remove dead else blocks (happens whenever an 'if' moves up
        -:  450:  // a sequence of affine.fors that are all perfectly nested).
    #####:  451:  (void)applyPatternsAndFoldGreedily(
        -:  452:      hoistedIfOp->getParentWithTrait<OpTrait::IsIsolatedFromAbove>(),
    #####:  453:      frozenPatterns);
call    0 never executed
call    1 never executed
        -:  454:
    #####:  455:  return success();
call    0 never executed
        -:  456:}
        -:  457:
        -:  458:// Return the min expr after replacing the given dim.
function _ZN4mlir12substWithMinENS_10AffineExprES0_S0_S0_b called 0 returned 0% blocks executed 0%
    #####:  459:AffineExpr mlir::substWithMin(AffineExpr e, AffineExpr dim, AffineExpr min,
        -:  460:                              AffineExpr max, bool positivePath) {
    #####:  461:  if (e == dim)
branch  0 never executed
branch  1 never executed
    #####:  462:    return positivePath ? min : max;
branch  0 never executed
branch  1 never executed
    #####:  463:  if (auto bin = e.dyn_cast<AffineBinaryOpExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  464:    AffineExpr lhs = bin.getLHS();
call    0 never executed
    #####:  465:    AffineExpr rhs = bin.getRHS();
call    0 never executed
    #####:  466:    if (bin.getKind() == mlir::AffineExprKind::Add)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  467:      return substWithMin(lhs, dim, min, max, positivePath) +
call    0 never executed
    #####:  468:             substWithMin(rhs, dim, min, max, positivePath);
call    0 never executed
call    1 never executed
        -:  469:
    #####:  470:    auto c1 = bin.getLHS().dyn_cast<AffineConstantExpr>();
call    0 never executed
call    1 never executed
    #####:  471:    auto c2 = bin.getRHS().dyn_cast<AffineConstantExpr>();
call    0 never executed
call    1 never executed
    #####:  472:    if (c1 && c1.getValue() < 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  473:      return getAffineBinaryOpExpr(
    #####:  474:          bin.getKind(), c1, substWithMin(rhs, dim, min, max, !positivePath));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  475:    if (c2 && c2.getValue() < 0)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  476:      return getAffineBinaryOpExpr(
    #####:  477:          bin.getKind(), substWithMin(lhs, dim, min, max, !positivePath), c2);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  478:    return getAffineBinaryOpExpr(
        -:  479:        bin.getKind(), substWithMin(lhs, dim, min, max, positivePath),
    #####:  480:        substWithMin(rhs, dim, min, max, positivePath));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  481:  }
    #####:  482:  return e;
        -:  483:}
        -:  484:
function _ZN4mlir23normalizeAffineParallelENS_16AffineParallelOpE called 0 returned 0% blocks executed 0%
    #####:  485:void mlir::normalizeAffineParallel(AffineParallelOp op) {
        -:  486:  // Loops with min/max in bounds are not normalized at the moment.
    #####:  487:  if (op.hasMinMaxBounds())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  488:    return;
        -:  489:
    #####:  490:  AffineMap lbMap = op.getLowerBoundsMap();
call    0 never executed
    #####:  491:  SmallVector<int64_t, 8> steps = op.getSteps();
call    0 never executed
        -:  492:  // No need to do any work if the parallel op is already normalized.
    #####:  493:  bool isAlreadyNormalized =
function _ZZN4mlir23normalizeAffineParallelENS_16AffineParallelOpEENKUlT_E_clISt5tupleIJRlRKNS_10AffineExprEEEEEDaS1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  494:      llvm::all_of(llvm::zip(steps, lbMap.getResults()), [](auto tuple) {
call    0 never executed
call    1 never executed
    #####:  495:        int64_t step = std::get<0>(tuple);
call    0 never executed
    #####:  496:        auto lbExpr =
    #####:  497:            std::get<1>(tuple).template dyn_cast<AffineConstantExpr>();
call    0 never executed
    #####:  498:        return lbExpr && lbExpr.getValue() == 0 && step == 1;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  499:      });
    #####:  500:  if (isAlreadyNormalized)
branch  0 never executed
branch  1 never executed
    #####:  501:    return;
branch  0 never executed
branch  1 never executed
        -:  502:
    #####:  503:  AffineValueMap ranges;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  504:  AffineValueMap::difference(op.getUpperBoundsValueMap(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  505:                             op.getLowerBoundsValueMap(), &ranges);
call    0 never executed
call    1 never executed
    #####:  506:  auto builder = OpBuilder::atBlockBegin(op.getBody());
call    0 never executed
call    1 never executed
    #####:  507:  auto zeroExpr = builder.getAffineConstantExpr(0);
call    0 never executed
    #####:  508:  SmallVector<AffineExpr, 8> lbExprs;
call    0 never executed
    #####:  509:  SmallVector<AffineExpr, 8> ubExprs;
branch  0 never executed
branch  1 never executed
    #####:  510:  for (unsigned i = 0, e = steps.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  511:    int64_t step = steps[i];
branch  0 never executed
branch  1 never executed
        -:  512:
        -:  513:    // Adjust the lower bound to be 0.
    #####:  514:    lbExprs.push_back(zeroExpr);
call    0 never executed
        -:  515:
        -:  516:    // Adjust the upper bound expression: 'range / step'.
    #####:  517:    AffineExpr ubExpr = ranges.getResult(i).ceilDiv(step);
call    0 never executed
call    1 never executed
    #####:  518:    ubExprs.push_back(ubExpr);
call    0 never executed
        -:  519:
        -:  520:    // Adjust the corresponding IV: 'lb + i * step'.
    #####:  521:    BlockArgument iv = op.getBody()->getArgument(i);
call    0 never executed
call    1 never executed
    #####:  522:    AffineExpr lbExpr = lbMap.getResult(i);
call    0 never executed
    #####:  523:    unsigned nDims = lbMap.getNumDims();
call    0 never executed
    #####:  524:    auto expr = lbExpr + builder.getAffineDimExpr(nDims) * step;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  525:    auto map = AffineMap::get(/*dimCount=*/nDims + 1,
    #####:  526:                              /*symbolCount=*/lbMap.getNumSymbols(), expr);
call    0 never executed
call    1 never executed
        -:  527:
        -:  528:    // Use an 'affine.apply' op that will be simplified later in subsequent
        -:  529:    // canonicalizations.
    #####:  530:    OperandRange lbOperands = op.getLowerBoundsOperands();
call    0 never executed
    #####:  531:    OperandRange dimOperands = lbOperands.take_front(nDims);
call    0 never executed
    #####:  532:    OperandRange symbolOperands = lbOperands.drop_front(nDims);
call    0 never executed
    #####:  533:    SmallVector<Value, 8> applyOperands{dimOperands};
call    0 never executed
    #####:  534:    applyOperands.push_back(iv);
call    0 never executed
    #####:  535:    applyOperands.append(symbolOperands.begin(), symbolOperands.end());
call    0 never executed
    #####:  536:    auto apply = builder.create<AffineApplyOp>(op.getLoc(), map, applyOperands);
call    0 never executed
    #####:  537:    iv.replaceAllUsesExcept(apply, apply);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  538:  }
        -:  539:
    #####:  540:  SmallVector<int64_t, 8> newSteps(op.getNumDims(), 1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  541:  op.setSteps(newSteps);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  542:  auto newLowerMap = AffineMap::get(
call    0 never executed
    #####:  543:      /*dimCount=*/0, /*symbolCount=*/0, lbExprs, op.getContext());
call    0 never executed
    #####:  544:  op.setLowerBounds({}, newLowerMap);
call    0 never executed
call    1 never executed
    #####:  545:  auto newUpperMap = AffineMap::get(ranges.getNumDims(), ranges.getNumSymbols(),
call    0 never executed
    #####:  546:                                    ubExprs, op.getContext());
call    0 never executed
    #####:  547:  op.setUpperBounds(ranges.getOperands(), newUpperMap);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  548:}
        -:  549:
        -:  550:/// Normalizes affine.for ops. If the affine.for op has only a single iteration
        -:  551:/// only then it is simply promoted, else it is normalized in the traditional
        -:  552:/// way, by converting the lower bound to zero and loop step to one. The upper
        -:  553:/// bound is set to the trip count of the loop. For now, original loops must
        -:  554:/// have lower bound with a single result only. There is no such restriction on
        -:  555:/// upper bounds.
function _ZN4mlir18normalizeAffineForENS_11AffineForOpE called 0 returned 0% blocks executed 0%
    #####:  556:LogicalResult mlir::normalizeAffineFor(AffineForOp op) {
    #####:  557:  if (succeeded(promoteIfSingleIteration(op)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  558:    return success();
        -:  559:
        -:  560:  // Check if the forop is already normalized.
    #####:  561:  if (op.hasConstantLowerBound() && (op.getConstantLowerBound() == 0) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  562:      (op.getStep() == 1))
call    0 never executed
    #####:  563:    return success();
        -:  564:
        -:  565:  // Check if the lower bound has a single result only. Loops with a max lower
        -:  566:  // bound can't be normalized without additional support like
        -:  567:  // affine.execute_region's. If the lower bound does not have a single result
        -:  568:  // then skip this op.
    #####:  569:  if (op.getLowerBoundMap().getNumResults() != 1)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  570:    return failure();
        -:  571:
    #####:  572:  Location loc = op.getLoc();
call    0 never executed
    #####:  573:  OpBuilder opBuilder(op);
call    0 never executed
    #####:  574:  int64_t origLoopStep = op.getStep();
call    0 never executed
        -:  575:
        -:  576:  // Calculate upperBound for normalized loop.
    #####:  577:  SmallVector<Value, 4> ubOperands;
call    0 never executed
    #####:  578:  AffineBound lb = op.getLowerBound();
call    0 never executed
    #####:  579:  AffineBound ub = op.getUpperBound();
call    0 never executed
    #####:  580:  ubOperands.reserve(ub.getNumOperands() + lb.getNumOperands());
branch  0 never executed
branch  1 never executed
    #####:  581:  AffineMap origLbMap = lb.getMap();
call    0 never executed
    #####:  582:  AffineMap origUbMap = ub.getMap();
        -:  583:
        -:  584:  // Add dimension operands from upper/lower bound.
    #####:  585:  for (unsigned j = 0, e = origUbMap.getNumDims(); j < e; ++j)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  586:    ubOperands.push_back(ub.getOperand(j));
call    0 never executed
call    1 never executed
    #####:  587:  for (unsigned j = 0, e = origLbMap.getNumDims(); j < e; ++j)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  588:    ubOperands.push_back(lb.getOperand(j));
call    0 never executed
call    1 never executed
        -:  589:
        -:  590:  // Add symbol operands from upper/lower bound.
    #####:  591:  for (unsigned j = 0, e = origUbMap.getNumSymbols(); j < e; ++j)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  592:    ubOperands.push_back(ub.getOperand(origUbMap.getNumDims() + j));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  593:  for (unsigned j = 0, e = origLbMap.getNumSymbols(); j < e; ++j)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  594:    ubOperands.push_back(lb.getOperand(origLbMap.getNumDims() + j));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  595:
        -:  596:  // Add original result expressions from lower/upper bound map.
    #####:  597:  SmallVector<AffineExpr, 1> origLbExprs(origLbMap.getResults().begin(),
call    0 never executed
    #####:  598:                                         origLbMap.getResults().end());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  599:  SmallVector<AffineExpr, 2> origUbExprs(origUbMap.getResults().begin(),
call    0 never executed
    #####:  600:                                         origUbMap.getResults().end());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  601:  SmallVector<AffineExpr, 4> newUbExprs;
branch  0 never executed
branch  1 never executed
        -:  602:
        -:  603:  // The original upperBound can have more than one result. For the new
        -:  604:  // upperBound of this loop, take difference of all possible combinations of
        -:  605:  // the ub results and lb result and ceildiv with the loop step. For e.g.,
        -:  606:  //
        -:  607:  //  affine.for %i1 = 0 to min affine_map<(d0)[] -> (d0 + 32, 1024)>(%i0)
        -:  608:  //  will have an upperBound map as,
        -:  609:  //  affine_map<(d0)[] -> (((d0 + 32) - 0) ceildiv 1, (1024 - 0) ceildiv
        -:  610:  //  1)>(%i0)
        -:  611:  //
        -:  612:  // Insert all combinations of upper/lower bound results.
    #####:  613:  for (unsigned i = 0, e = origUbExprs.size(); i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  614:    newUbExprs.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  615:        (origUbExprs[i] - origLbExprs[0]).ceilDiv(origLoopStep));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  616:  }
        -:  617:
        -:  618:  // Construct newUbMap.
    #####:  619:  AffineMap newUbMap =
    #####:  620:      AffineMap::get(origLbMap.getNumDims() + origUbMap.getNumDims(),
call    0 never executed
    #####:  621:                     origLbMap.getNumSymbols() + origUbMap.getNumSymbols(),
call    0 never executed
call    1 never executed
    #####:  622:                     newUbExprs, opBuilder.getContext());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  623:  canonicalizeMapAndOperands(&newUbMap, &ubOperands);
call    0 never executed
        -:  624:
    #####:  625:  SmallVector<Value, 4> lbOperands(lb.getOperands().begin(),
    #####:  626:                                   lb.getOperands().begin() +
call    0 never executed
    #####:  627:                                       lb.getMap().getNumDims());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  628:
        -:  629:  // Normalize the loop.
    #####:  630:  op.setUpperBound(ubOperands, newUbMap);
call    0 never executed
call    1 never executed
    #####:  631:  op.setLowerBound({}, opBuilder.getConstantAffineMap(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  632:  op.setStep(1);
call    0 never executed
        -:  633:
        -:  634:  // Calculate the Value of new loopIV. Create affine.apply for the value of
        -:  635:  // the loopIV in normalized loop.
    #####:  636:  opBuilder.setInsertionPointToStart(op.getBody());
call    0 never executed
call    1 never executed
        -:  637:  // Add an extra dim operand for loopIV.
    #####:  638:  lbOperands.push_back(op.getInductionVar());
call    0 never executed
call    1 never executed
        -:  639:  // Add symbol operands from lower bound.
    #####:  640:  for (unsigned j = 0, e = origLbMap.getNumSymbols(); j < e; ++j)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  641:    lbOperands.push_back(lb.getOperand(origLbMap.getNumDims() + j));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  642:
    #####:  643:  AffineExpr origIVExpr = opBuilder.getAffineDimExpr(lb.getMap().getNumDims());
call    0 never executed
call    1 never executed
    #####:  644:  AffineExpr newIVExpr = origIVExpr * origLoopStep + origLbMap.getResult(0);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  645:  AffineMap ivMap = AffineMap::get(origLbMap.getNumDims() + 1,
call    0 never executed
    #####:  646:                                   origLbMap.getNumSymbols(), newIVExpr);
call    0 never executed
call    1 never executed
    #####:  647:  canonicalizeMapAndOperands(&ivMap, &lbOperands);
call    0 never executed
    #####:  648:  Operation *newIV = opBuilder.create<AffineApplyOp>(loc, ivMap, lbOperands);
call    0 never executed
call    1 never executed
    #####:  649:  op.getInductionVar().replaceAllUsesExcept(newIV->getResult(0), newIV);
call    0 never executed
call    1 never executed
    #####:  650:  return success();
branch  0 never executed
branch  1 never executed
        -:  651:}
        -:  652:
        -:  653:template <typename EffectType, typename T>
    #####:  654:bool mlir::hasNoInterveningEffect(Operation *start, T memOp) {
    #####:  655:  auto isLocallyAllocated = [](Value memref) {
    #####:  656:    auto *defOp = memref.getDefiningOp();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  657:    return defOp && hasSingleEffect<MemoryEffects::Allocate>(defOp, memref);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
        -:  658:  };
        -:  659:
        -:  660:  // A boolean representing whether an intervening operation could have impacted
        -:  661:  // memOp.
    #####:  662:  bool hasSideEffect = false;
        -:  663:
        -:  664:  // Check whether the effect on memOp can be caused by a given operation op.
    #####:  665:  Value memref = memOp.getMemRef();
    #####:  666:  std::function<void(Operation *)> checkOperation = [&](Operation *op) {
        -:  667:    // If the effect has alreay been found, early exit,
    #####:  668:    if (hasSideEffect)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  669:      return;
        -:  670:
    #####:  671:    if (auto memEffect = dyn_cast<MemoryEffectOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  672:      SmallVector<MemoryEffects::EffectInstance, 1> effects;
    #####:  673:      memEffect.getEffects(effects);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  674:
    #####:  675:      bool opMayHaveEffect = false;
    #####:  676:      for (auto effect : effects) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  677:        // If op causes EffectType on a potentially aliasing location for
        -:  678:        // memOp, mark as having the effect.
    #####:  679:        if (isa<EffectType>(effect.getEffect())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  680:          // TODO: This should be replaced with a check for no aliasing.
        -:  681:          // Aliasing information should be passed to this method.
    #####:  682:          if (effect.getValue() && effect.getValue() != memref &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  683:              isLocallyAllocated(memref) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####:  684:              isLocallyAllocated(effect.getValue()))
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  685:            continue;
        -:  686:          opMayHaveEffect = true;
        -:  687:          break;
        -:  688:        }
        -:  689:      }
        -:  690:
    #####:  691:      if (!opMayHaveEffect)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  692:        return;
        -:  693:
        -:  694:      // If the side effect comes from an affine read or write, try to
        -:  695:      // prove the side effecting `op` cannot reach `memOp`.
    #####:  696:      if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  697:        MemRefAccess srcAccess(op);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  698:        MemRefAccess destAccess(memOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  699:        // Affine dependence analysis here is applicable only if both ops
        -:  700:        // operate on the same memref and if `op`, `memOp`, and `start` are in
        -:  701:        // the same AffineScope.
    #####:  702:        if (srcAccess.memref == destAccess.memref &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  703:            getAffineScope(op) == getAffineScope(memOp) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
call   14 never executed
call   15 never executed
branch 16 never executed
branch 17 never executed
    #####:  704:            getAffineScope(op) == getAffineScope(start)) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
        -:  705:          // Number of loops containing the start op and the ending operation.
        -:  706:          unsigned minSurroundingLoops =
    #####:  707:              getNumCommonSurroundingLoops(*start, *memOp);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  708:
        -:  709:          // Number of loops containing the operation `op` which has the
        -:  710:          // potential memory side effect and can occur on a path between
        -:  711:          // `start` and `memOp`.
    #####:  712:          unsigned nsLoops = getNumCommonSurroundingLoops(*op, *memOp);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  713:
        -:  714:          // For ease, let's consider the case that `op` is a store and we're
        -:  715:          // looking for other potential stores (e.g `op`) that overwrite memory
        -:  716:          // after `start`, and before being read in `memOp`. In this case, we
        -:  717:          // only need to consider other potential stores with depth >
        -:  718:          // minSurrounding loops since `start` would overwrite any store with a
        -:  719:          // smaller number of surrounding loops before.
        -:  720:          unsigned d;
    #####:  721:          FlatAffineValueConstraints dependenceConstraints;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####:  722:          for (d = nsLoops + 1; d > minSurroundingLoops; d--) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  723:            DependenceResult result = checkMemrefAccessDependence(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  724:                srcAccess, destAccess, d, &dependenceConstraints,
        -:  725:                /*dependenceComponents=*/nullptr);
        -:  726:            // A dependence failure or the presence of a dependence implies a
        -:  727:            // side effect.
    #####:  728:            if (!noDependence(result)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  729:              hasSideEffect = true;
    #####:  730:              return;
        -:  731:            }
        -:  732:          }
        -:  733:
        -:  734:          // No side effect was seen, simply return.
        -:  735:          return;
        -:  736:        }
        -:  737:        // TODO: Check here if the memrefs alias: there is no side effect if
        -:  738:        // `srcAccess.memref` and `destAccess.memref` don't alias.
        -:  739:      }
        -:  740:      // We have an op with a memory effect and we cannot prove if it
        -:  741:      // intervenes.
    #####:  742:      hasSideEffect = true;
    #####:  743:      return;
        -:  744:    }
        -:  745:
    #####:  746:    if (op->hasTrait<OpTrait::HasRecursiveMemoryEffects>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  747:      // Recurse into the regions for this op and check whether the internal
        -:  748:      // operations may have the side effect `EffectType` on memOp.
    #####:  749:      for (Region &region : op->getRegions())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  750:        for (Block &block : region)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  751:          for (Operation &op : block)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####:  752:            checkOperation(&op);
        -:  753:      return;
        -:  754:    }
        -:  755:
        -:  756:    // Otherwise, conservatively assume generic operations have the effect
        -:  757:    // on the operation
    #####:  758:    hasSideEffect = true;
        -:  759:  };
        -:  760:
        -:  761:  // Check all paths from ancestor op `parent` to the operation `to` for the
        -:  762:  // effect. It is known that `to` must be contained within `parent`.
    #####:  763:  auto until = [&](Operation *parent, Operation *to) {
        -:  764:    // TODO check only the paths from `parent` to `to`.
        -:  765:    // Currently we fallback and check the entire parent op, rather than
        -:  766:    // just the paths from the parent path, stopping after reaching `to`.
        -:  767:    // This is conservatively correct, but could be made more aggressive.
    #####:  768:    assert(parent->isAncestor(to));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  769:    checkOperation(parent);
        -:  770:  };
        -:  771:
        -:  772:  // Check for all paths from operation `from` to operation `untilOp` for the
        -:  773:  // given memory effect.
    #####:  774:  std::function<void(Operation *, Operation *)> recur =
    #####:  775:      [&](Operation *from, Operation *untilOp) {
    #####:  776:        assert(
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
call   20 never executed
        -:  777:            from->getParentRegion()->isAncestor(untilOp->getParentRegion()) &&
        -:  778:            "Checking for side effect between two operations without a common "
        -:  779:            "ancestor");
        -:  780:
        -:  781:        // If the operations are in different regions, recursively consider all
        -:  782:        // path from `from` to the parent of `to` and all paths from the parent
        -:  783:        // of `to` to `to`.
    #####:  784:        if (from->getParentRegion() != untilOp->getParentRegion()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
    #####:  785:          recur(from, untilOp->getParentOp());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  786:          until(untilOp->getParentOp(), untilOp);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
    #####:  787:          return;
        -:  788:        }
        -:  789:
        -:  790:        // Now, assuming that `from` and `to` exist in the same region, perform
        -:  791:        // a CFG traversal to check all the relevant operations.
        -:  792:
        -:  793:        // Additional blocks to consider.
    #####:  794:        SmallVector<Block *, 2> todoBlocks;
        -:  795:        {
        -:  796:          // First consider the parent block of `from` an check all operations
        -:  797:          // after `from`.
    #####:  798:          for (auto iter = ++from->getIterator(), end = from->getBlock()->end();
    #####:  799:               iter != end && &*iter != untilOp; ++iter) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
branch 13 never executed
branch 14 never executed
    #####:  800:            checkOperation(&*iter);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
        -:  801:          }
        -:  802:
        -:  803:          // If the parent of `from` doesn't contain `to`, add the successors
        -:  804:          // to the list of blocks to check.
    #####:  805:          if (untilOp->getBlock() != from->getBlock())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  806:            for (Block *succ : from->getBlock()->getSuccessors())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
branch 11 never executed
branch 12 never executed
call   13 never executed
call   14 never executed
    #####:  807:              todoBlocks.push_back(succ);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  808:        }
        -:  809:
    #####:  810:        SmallPtrSet<Block *, 4> done;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  811:        // Traverse the CFG until hitting `to`.
    #####:  812:        while (!todoBlocks.empty()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  813:          Block *blk = todoBlocks.pop_back_val();
    #####:  814:          if (done.count(blk))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  815:            continue;
    #####:  816:          done.insert(blk);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  817:          for (auto &op : *blk) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
    #####:  818:            if (&op == untilOp)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  819:              break;
    #####:  820:            checkOperation(&op);
    #####:  821:            if (&op == blk->getTerminator())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  822:              for (Block *succ : blk->getSuccessors())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
    #####:  823:                todoBlocks.push_back(succ);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  824:          }
        -:  825:        }
        -:  826:      };
    #####:  827:  recur(start, memOp);
    #####:  828:  return !hasSideEffect;
        -:  829:}
------------------
_ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects4ReadENS_22AffineWriteOpInterfaceEEEbPNS_9OperationET0_:
function _ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects4ReadENS_22AffineWriteOpInterfaceEEEbPNS_9OperationET0_ called 0 returned 0% blocks executed 0%
    #####:  654:bool mlir::hasNoInterveningEffect(Operation *start, T memOp) {
        -:  655:  auto isLocallyAllocated = [](Value memref) {
        -:  656:    auto *defOp = memref.getDefiningOp();
        -:  657:    return defOp && hasSingleEffect<MemoryEffects::Allocate>(defOp, memref);
        -:  658:  };
        -:  659:
        -:  660:  // A boolean representing whether an intervening operation could have impacted
        -:  661:  // memOp.
    #####:  662:  bool hasSideEffect = false;
        -:  663:
        -:  664:  // Check whether the effect on memOp can be caused by a given operation op.
    #####:  665:  Value memref = memOp.getMemRef();
call    0 never executed
    #####:  666:  std::function<void(Operation *)> checkOperation = [&](Operation *op) {
call    0 never executed
        -:  667:    // If the effect has alreay been found, early exit,
        -:  668:    if (hasSideEffect)
        -:  669:      return;
        -:  670:
        -:  671:    if (auto memEffect = dyn_cast<MemoryEffectOpInterface>(op)) {
        -:  672:      SmallVector<MemoryEffects::EffectInstance, 1> effects;
        -:  673:      memEffect.getEffects(effects);
        -:  674:
        -:  675:      bool opMayHaveEffect = false;
        -:  676:      for (auto effect : effects) {
        -:  677:        // If op causes EffectType on a potentially aliasing location for
        -:  678:        // memOp, mark as having the effect.
        -:  679:        if (isa<EffectType>(effect.getEffect())) {
        -:  680:          // TODO: This should be replaced with a check for no aliasing.
        -:  681:          // Aliasing information should be passed to this method.
        -:  682:          if (effect.getValue() && effect.getValue() != memref &&
        -:  683:              isLocallyAllocated(memref) &&
        -:  684:              isLocallyAllocated(effect.getValue()))
        -:  685:            continue;
        -:  686:          opMayHaveEffect = true;
        -:  687:          break;
        -:  688:        }
        -:  689:      }
        -:  690:
        -:  691:      if (!opMayHaveEffect)
        -:  692:        return;
        -:  693:
        -:  694:      // If the side effect comes from an affine read or write, try to
        -:  695:      // prove the side effecting `op` cannot reach `memOp`.
        -:  696:      if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) {
        -:  697:        MemRefAccess srcAccess(op);
        -:  698:        MemRefAccess destAccess(memOp);
        -:  699:        // Affine dependence analysis here is applicable only if both ops
        -:  700:        // operate on the same memref and if `op`, `memOp`, and `start` are in
        -:  701:        // the same AffineScope.
        -:  702:        if (srcAccess.memref == destAccess.memref &&
        -:  703:            getAffineScope(op) == getAffineScope(memOp) &&
        -:  704:            getAffineScope(op) == getAffineScope(start)) {
        -:  705:          // Number of loops containing the start op and the ending operation.
        -:  706:          unsigned minSurroundingLoops =
        -:  707:              getNumCommonSurroundingLoops(*start, *memOp);
        -:  708:
        -:  709:          // Number of loops containing the operation `op` which has the
        -:  710:          // potential memory side effect and can occur on a path between
        -:  711:          // `start` and `memOp`.
        -:  712:          unsigned nsLoops = getNumCommonSurroundingLoops(*op, *memOp);
        -:  713:
        -:  714:          // For ease, let's consider the case that `op` is a store and we're
        -:  715:          // looking for other potential stores (e.g `op`) that overwrite memory
        -:  716:          // after `start`, and before being read in `memOp`. In this case, we
        -:  717:          // only need to consider other potential stores with depth >
        -:  718:          // minSurrounding loops since `start` would overwrite any store with a
        -:  719:          // smaller number of surrounding loops before.
        -:  720:          unsigned d;
        -:  721:          FlatAffineValueConstraints dependenceConstraints;
        -:  722:          for (d = nsLoops + 1; d > minSurroundingLoops; d--) {
        -:  723:            DependenceResult result = checkMemrefAccessDependence(
        -:  724:                srcAccess, destAccess, d, &dependenceConstraints,
        -:  725:                /*dependenceComponents=*/nullptr);
        -:  726:            // A dependence failure or the presence of a dependence implies a
        -:  727:            // side effect.
        -:  728:            if (!noDependence(result)) {
        -:  729:              hasSideEffect = true;
        -:  730:              return;
        -:  731:            }
        -:  732:          }
        -:  733:
        -:  734:          // No side effect was seen, simply return.
        -:  735:          return;
        -:  736:        }
        -:  737:        // TODO: Check here if the memrefs alias: there is no side effect if
        -:  738:        // `srcAccess.memref` and `destAccess.memref` don't alias.
        -:  739:      }
        -:  740:      // We have an op with a memory effect and we cannot prove if it
        -:  741:      // intervenes.
        -:  742:      hasSideEffect = true;
        -:  743:      return;
        -:  744:    }
        -:  745:
        -:  746:    if (op->hasTrait<OpTrait::HasRecursiveMemoryEffects>()) {
        -:  747:      // Recurse into the regions for this op and check whether the internal
        -:  748:      // operations may have the side effect `EffectType` on memOp.
        -:  749:      for (Region &region : op->getRegions())
        -:  750:        for (Block &block : region)
        -:  751:          for (Operation &op : block)
        -:  752:            checkOperation(&op);
        -:  753:      return;
        -:  754:    }
        -:  755:
        -:  756:    // Otherwise, conservatively assume generic operations have the effect
        -:  757:    // on the operation
        -:  758:    hasSideEffect = true;
        -:  759:  };
        -:  760:
        -:  761:  // Check all paths from ancestor op `parent` to the operation `to` for the
        -:  762:  // effect. It is known that `to` must be contained within `parent`.
    #####:  763:  auto until = [&](Operation *parent, Operation *to) {
        -:  764:    // TODO check only the paths from `parent` to `to`.
        -:  765:    // Currently we fallback and check the entire parent op, rather than
        -:  766:    // just the paths from the parent path, stopping after reaching `to`.
        -:  767:    // This is conservatively correct, but could be made more aggressive.
        -:  768:    assert(parent->isAncestor(to));
        -:  769:    checkOperation(parent);
        -:  770:  };
        -:  771:
        -:  772:  // Check for all paths from operation `from` to operation `untilOp` for the
        -:  773:  // given memory effect.
    #####:  774:  std::function<void(Operation *, Operation *)> recur =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  775:      [&](Operation *from, Operation *untilOp) {
        -:  776:        assert(
        -:  777:            from->getParentRegion()->isAncestor(untilOp->getParentRegion()) &&
        -:  778:            "Checking for side effect between two operations without a common "
        -:  779:            "ancestor");
        -:  780:
        -:  781:        // If the operations are in different regions, recursively consider all
        -:  782:        // path from `from` to the parent of `to` and all paths from the parent
        -:  783:        // of `to` to `to`.
        -:  784:        if (from->getParentRegion() != untilOp->getParentRegion()) {
        -:  785:          recur(from, untilOp->getParentOp());
        -:  786:          until(untilOp->getParentOp(), untilOp);
        -:  787:          return;
        -:  788:        }
        -:  789:
        -:  790:        // Now, assuming that `from` and `to` exist in the same region, perform
        -:  791:        // a CFG traversal to check all the relevant operations.
        -:  792:
        -:  793:        // Additional blocks to consider.
        -:  794:        SmallVector<Block *, 2> todoBlocks;
        -:  795:        {
        -:  796:          // First consider the parent block of `from` an check all operations
        -:  797:          // after `from`.
        -:  798:          for (auto iter = ++from->getIterator(), end = from->getBlock()->end();
        -:  799:               iter != end && &*iter != untilOp; ++iter) {
        -:  800:            checkOperation(&*iter);
        -:  801:          }
        -:  802:
        -:  803:          // If the parent of `from` doesn't contain `to`, add the successors
        -:  804:          // to the list of blocks to check.
        -:  805:          if (untilOp->getBlock() != from->getBlock())
        -:  806:            for (Block *succ : from->getBlock()->getSuccessors())
        -:  807:              todoBlocks.push_back(succ);
        -:  808:        }
        -:  809:
        -:  810:        SmallPtrSet<Block *, 4> done;
        -:  811:        // Traverse the CFG until hitting `to`.
        -:  812:        while (!todoBlocks.empty()) {
        -:  813:          Block *blk = todoBlocks.pop_back_val();
        -:  814:          if (done.count(blk))
        -:  815:            continue;
        -:  816:          done.insert(blk);
        -:  817:          for (auto &op : *blk) {
        -:  818:            if (&op == untilOp)
        -:  819:              break;
        -:  820:            checkOperation(&op);
        -:  821:            if (&op == blk->getTerminator())
        -:  822:              for (Block *succ : blk->getSuccessors())
        -:  823:                todoBlocks.push_back(succ);
        -:  824:          }
        -:  825:        }
        -:  826:      };
    #####:  827:  recur(start, memOp);
call    0 never executed
    #####:  828:  return !hasSideEffect;
branch  0 never executed
branch  1 never executed
        -:  829:}
------------------
_ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects5WriteENS_21AffineReadOpInterfaceEEEbPNS_9OperationET0_:
function _ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects5WriteENS_21AffineReadOpInterfaceEEEbPNS_9OperationET0_ called 0 returned 0% blocks executed 0%
    #####:  654:bool mlir::hasNoInterveningEffect(Operation *start, T memOp) {
        -:  655:  auto isLocallyAllocated = [](Value memref) {
        -:  656:    auto *defOp = memref.getDefiningOp();
        -:  657:    return defOp && hasSingleEffect<MemoryEffects::Allocate>(defOp, memref);
        -:  658:  };
        -:  659:
        -:  660:  // A boolean representing whether an intervening operation could have impacted
        -:  661:  // memOp.
    #####:  662:  bool hasSideEffect = false;
        -:  663:
        -:  664:  // Check whether the effect on memOp can be caused by a given operation op.
    #####:  665:  Value memref = memOp.getMemRef();
call    0 never executed
    #####:  666:  std::function<void(Operation *)> checkOperation = [&](Operation *op) {
call    0 never executed
        -:  667:    // If the effect has alreay been found, early exit,
        -:  668:    if (hasSideEffect)
        -:  669:      return;
        -:  670:
        -:  671:    if (auto memEffect = dyn_cast<MemoryEffectOpInterface>(op)) {
        -:  672:      SmallVector<MemoryEffects::EffectInstance, 1> effects;
        -:  673:      memEffect.getEffects(effects);
        -:  674:
        -:  675:      bool opMayHaveEffect = false;
        -:  676:      for (auto effect : effects) {
        -:  677:        // If op causes EffectType on a potentially aliasing location for
        -:  678:        // memOp, mark as having the effect.
        -:  679:        if (isa<EffectType>(effect.getEffect())) {
        -:  680:          // TODO: This should be replaced with a check for no aliasing.
        -:  681:          // Aliasing information should be passed to this method.
        -:  682:          if (effect.getValue() && effect.getValue() != memref &&
        -:  683:              isLocallyAllocated(memref) &&
        -:  684:              isLocallyAllocated(effect.getValue()))
        -:  685:            continue;
        -:  686:          opMayHaveEffect = true;
        -:  687:          break;
        -:  688:        }
        -:  689:      }
        -:  690:
        -:  691:      if (!opMayHaveEffect)
        -:  692:        return;
        -:  693:
        -:  694:      // If the side effect comes from an affine read or write, try to
        -:  695:      // prove the side effecting `op` cannot reach `memOp`.
        -:  696:      if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) {
        -:  697:        MemRefAccess srcAccess(op);
        -:  698:        MemRefAccess destAccess(memOp);
        -:  699:        // Affine dependence analysis here is applicable only if both ops
        -:  700:        // operate on the same memref and if `op`, `memOp`, and `start` are in
        -:  701:        // the same AffineScope.
        -:  702:        if (srcAccess.memref == destAccess.memref &&
        -:  703:            getAffineScope(op) == getAffineScope(memOp) &&
        -:  704:            getAffineScope(op) == getAffineScope(start)) {
        -:  705:          // Number of loops containing the start op and the ending operation.
        -:  706:          unsigned minSurroundingLoops =
        -:  707:              getNumCommonSurroundingLoops(*start, *memOp);
        -:  708:
        -:  709:          // Number of loops containing the operation `op` which has the
        -:  710:          // potential memory side effect and can occur on a path between
        -:  711:          // `start` and `memOp`.
        -:  712:          unsigned nsLoops = getNumCommonSurroundingLoops(*op, *memOp);
        -:  713:
        -:  714:          // For ease, let's consider the case that `op` is a store and we're
        -:  715:          // looking for other potential stores (e.g `op`) that overwrite memory
        -:  716:          // after `start`, and before being read in `memOp`. In this case, we
        -:  717:          // only need to consider other potential stores with depth >
        -:  718:          // minSurrounding loops since `start` would overwrite any store with a
        -:  719:          // smaller number of surrounding loops before.
        -:  720:          unsigned d;
        -:  721:          FlatAffineValueConstraints dependenceConstraints;
        -:  722:          for (d = nsLoops + 1; d > minSurroundingLoops; d--) {
        -:  723:            DependenceResult result = checkMemrefAccessDependence(
        -:  724:                srcAccess, destAccess, d, &dependenceConstraints,
        -:  725:                /*dependenceComponents=*/nullptr);
        -:  726:            // A dependence failure or the presence of a dependence implies a
        -:  727:            // side effect.
        -:  728:            if (!noDependence(result)) {
        -:  729:              hasSideEffect = true;
        -:  730:              return;
        -:  731:            }
        -:  732:          }
        -:  733:
        -:  734:          // No side effect was seen, simply return.
        -:  735:          return;
        -:  736:        }
        -:  737:        // TODO: Check here if the memrefs alias: there is no side effect if
        -:  738:        // `srcAccess.memref` and `destAccess.memref` don't alias.
        -:  739:      }
        -:  740:      // We have an op with a memory effect and we cannot prove if it
        -:  741:      // intervenes.
        -:  742:      hasSideEffect = true;
        -:  743:      return;
        -:  744:    }
        -:  745:
        -:  746:    if (op->hasTrait<OpTrait::HasRecursiveMemoryEffects>()) {
        -:  747:      // Recurse into the regions for this op and check whether the internal
        -:  748:      // operations may have the side effect `EffectType` on memOp.
        -:  749:      for (Region &region : op->getRegions())
        -:  750:        for (Block &block : region)
        -:  751:          for (Operation &op : block)
        -:  752:            checkOperation(&op);
        -:  753:      return;
        -:  754:    }
        -:  755:
        -:  756:    // Otherwise, conservatively assume generic operations have the effect
        -:  757:    // on the operation
        -:  758:    hasSideEffect = true;
        -:  759:  };
        -:  760:
        -:  761:  // Check all paths from ancestor op `parent` to the operation `to` for the
        -:  762:  // effect. It is known that `to` must be contained within `parent`.
    #####:  763:  auto until = [&](Operation *parent, Operation *to) {
        -:  764:    // TODO check only the paths from `parent` to `to`.
        -:  765:    // Currently we fallback and check the entire parent op, rather than
        -:  766:    // just the paths from the parent path, stopping after reaching `to`.
        -:  767:    // This is conservatively correct, but could be made more aggressive.
        -:  768:    assert(parent->isAncestor(to));
        -:  769:    checkOperation(parent);
        -:  770:  };
        -:  771:
        -:  772:  // Check for all paths from operation `from` to operation `untilOp` for the
        -:  773:  // given memory effect.
    #####:  774:  std::function<void(Operation *, Operation *)> recur =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  775:      [&](Operation *from, Operation *untilOp) {
        -:  776:        assert(
        -:  777:            from->getParentRegion()->isAncestor(untilOp->getParentRegion()) &&
        -:  778:            "Checking for side effect between two operations without a common "
        -:  779:            "ancestor");
        -:  780:
        -:  781:        // If the operations are in different regions, recursively consider all
        -:  782:        // path from `from` to the parent of `to` and all paths from the parent
        -:  783:        // of `to` to `to`.
        -:  784:        if (from->getParentRegion() != untilOp->getParentRegion()) {
        -:  785:          recur(from, untilOp->getParentOp());
        -:  786:          until(untilOp->getParentOp(), untilOp);
        -:  787:          return;
        -:  788:        }
        -:  789:
        -:  790:        // Now, assuming that `from` and `to` exist in the same region, perform
        -:  791:        // a CFG traversal to check all the relevant operations.
        -:  792:
        -:  793:        // Additional blocks to consider.
        -:  794:        SmallVector<Block *, 2> todoBlocks;
        -:  795:        {
        -:  796:          // First consider the parent block of `from` an check all operations
        -:  797:          // after `from`.
        -:  798:          for (auto iter = ++from->getIterator(), end = from->getBlock()->end();
        -:  799:               iter != end && &*iter != untilOp; ++iter) {
        -:  800:            checkOperation(&*iter);
        -:  801:          }
        -:  802:
        -:  803:          // If the parent of `from` doesn't contain `to`, add the successors
        -:  804:          // to the list of blocks to check.
        -:  805:          if (untilOp->getBlock() != from->getBlock())
        -:  806:            for (Block *succ : from->getBlock()->getSuccessors())
        -:  807:              todoBlocks.push_back(succ);
        -:  808:        }
        -:  809:
        -:  810:        SmallPtrSet<Block *, 4> done;
        -:  811:        // Traverse the CFG until hitting `to`.
        -:  812:        while (!todoBlocks.empty()) {
        -:  813:          Block *blk = todoBlocks.pop_back_val();
        -:  814:          if (done.count(blk))
        -:  815:            continue;
        -:  816:          done.insert(blk);
        -:  817:          for (auto &op : *blk) {
        -:  818:            if (&op == untilOp)
        -:  819:              break;
        -:  820:            checkOperation(&op);
        -:  821:            if (&op == blk->getTerminator())
        -:  822:              for (Block *succ : blk->getSuccessors())
        -:  823:                todoBlocks.push_back(succ);
        -:  824:          }
        -:  825:        }
        -:  826:      };
    #####:  827:  recur(start, memOp);
call    0 never executed
    #####:  828:  return !hasSideEffect;
branch  0 never executed
branch  1 never executed
        -:  829:}
------------------
_ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects4ReadENS_21AffineReadOpInterfaceEEEbPNS_9OperationET0_:
function _ZN4mlir22hasNoInterveningEffectINS_13MemoryEffects4ReadENS_21AffineReadOpInterfaceEEEbPNS_9OperationET0_ called 0 returned 0% blocks executed 0%
    #####:  654:bool mlir::hasNoInterveningEffect(Operation *start, T memOp) {
        -:  655:  auto isLocallyAllocated = [](Value memref) {
        -:  656:    auto *defOp = memref.getDefiningOp();
        -:  657:    return defOp && hasSingleEffect<MemoryEffects::Allocate>(defOp, memref);
        -:  658:  };
        -:  659:
        -:  660:  // A boolean representing whether an intervening operation could have impacted
        -:  661:  // memOp.
    #####:  662:  bool hasSideEffect = false;
        -:  663:
        -:  664:  // Check whether the effect on memOp can be caused by a given operation op.
    #####:  665:  Value memref = memOp.getMemRef();
call    0 never executed
    #####:  666:  std::function<void(Operation *)> checkOperation = [&](Operation *op) {
call    0 never executed
        -:  667:    // If the effect has alreay been found, early exit,
        -:  668:    if (hasSideEffect)
        -:  669:      return;
        -:  670:
        -:  671:    if (auto memEffect = dyn_cast<MemoryEffectOpInterface>(op)) {
        -:  672:      SmallVector<MemoryEffects::EffectInstance, 1> effects;
        -:  673:      memEffect.getEffects(effects);
        -:  674:
        -:  675:      bool opMayHaveEffect = false;
        -:  676:      for (auto effect : effects) {
        -:  677:        // If op causes EffectType on a potentially aliasing location for
        -:  678:        // memOp, mark as having the effect.
        -:  679:        if (isa<EffectType>(effect.getEffect())) {
        -:  680:          // TODO: This should be replaced with a check for no aliasing.
        -:  681:          // Aliasing information should be passed to this method.
        -:  682:          if (effect.getValue() && effect.getValue() != memref &&
        -:  683:              isLocallyAllocated(memref) &&
        -:  684:              isLocallyAllocated(effect.getValue()))
        -:  685:            continue;
        -:  686:          opMayHaveEffect = true;
        -:  687:          break;
        -:  688:        }
        -:  689:      }
        -:  690:
        -:  691:      if (!opMayHaveEffect)
        -:  692:        return;
        -:  693:
        -:  694:      // If the side effect comes from an affine read or write, try to
        -:  695:      // prove the side effecting `op` cannot reach `memOp`.
        -:  696:      if (isa<AffineReadOpInterface, AffineWriteOpInterface>(op)) {
        -:  697:        MemRefAccess srcAccess(op);
        -:  698:        MemRefAccess destAccess(memOp);
        -:  699:        // Affine dependence analysis here is applicable only if both ops
        -:  700:        // operate on the same memref and if `op`, `memOp`, and `start` are in
        -:  701:        // the same AffineScope.
        -:  702:        if (srcAccess.memref == destAccess.memref &&
        -:  703:            getAffineScope(op) == getAffineScope(memOp) &&
        -:  704:            getAffineScope(op) == getAffineScope(start)) {
        -:  705:          // Number of loops containing the start op and the ending operation.
        -:  706:          unsigned minSurroundingLoops =
        -:  707:              getNumCommonSurroundingLoops(*start, *memOp);
        -:  708:
        -:  709:          // Number of loops containing the operation `op` which has the
        -:  710:          // potential memory side effect and can occur on a path between
        -:  711:          // `start` and `memOp`.
        -:  712:          unsigned nsLoops = getNumCommonSurroundingLoops(*op, *memOp);
        -:  713:
        -:  714:          // For ease, let's consider the case that `op` is a store and we're
        -:  715:          // looking for other potential stores (e.g `op`) that overwrite memory
        -:  716:          // after `start`, and before being read in `memOp`. In this case, we
        -:  717:          // only need to consider other potential stores with depth >
        -:  718:          // minSurrounding loops since `start` would overwrite any store with a
        -:  719:          // smaller number of surrounding loops before.
        -:  720:          unsigned d;
        -:  721:          FlatAffineValueConstraints dependenceConstraints;
        -:  722:          for (d = nsLoops + 1; d > minSurroundingLoops; d--) {
        -:  723:            DependenceResult result = checkMemrefAccessDependence(
        -:  724:                srcAccess, destAccess, d, &dependenceConstraints,
        -:  725:                /*dependenceComponents=*/nullptr);
        -:  726:            // A dependence failure or the presence of a dependence implies a
        -:  727:            // side effect.
        -:  728:            if (!noDependence(result)) {
        -:  729:              hasSideEffect = true;
        -:  730:              return;
        -:  731:            }
        -:  732:          }
        -:  733:
        -:  734:          // No side effect was seen, simply return.
        -:  735:          return;
        -:  736:        }
        -:  737:        // TODO: Check here if the memrefs alias: there is no side effect if
        -:  738:        // `srcAccess.memref` and `destAccess.memref` don't alias.
        -:  739:      }
        -:  740:      // We have an op with a memory effect and we cannot prove if it
        -:  741:      // intervenes.
        -:  742:      hasSideEffect = true;
        -:  743:      return;
        -:  744:    }
        -:  745:
        -:  746:    if (op->hasTrait<OpTrait::HasRecursiveMemoryEffects>()) {
        -:  747:      // Recurse into the regions for this op and check whether the internal
        -:  748:      // operations may have the side effect `EffectType` on memOp.
        -:  749:      for (Region &region : op->getRegions())
        -:  750:        for (Block &block : region)
        -:  751:          for (Operation &op : block)
        -:  752:            checkOperation(&op);
        -:  753:      return;
        -:  754:    }
        -:  755:
        -:  756:    // Otherwise, conservatively assume generic operations have the effect
        -:  757:    // on the operation
        -:  758:    hasSideEffect = true;
        -:  759:  };
        -:  760:
        -:  761:  // Check all paths from ancestor op `parent` to the operation `to` for the
        -:  762:  // effect. It is known that `to` must be contained within `parent`.
    #####:  763:  auto until = [&](Operation *parent, Operation *to) {
        -:  764:    // TODO check only the paths from `parent` to `to`.
        -:  765:    // Currently we fallback and check the entire parent op, rather than
        -:  766:    // just the paths from the parent path, stopping after reaching `to`.
        -:  767:    // This is conservatively correct, but could be made more aggressive.
        -:  768:    assert(parent->isAncestor(to));
        -:  769:    checkOperation(parent);
        -:  770:  };
        -:  771:
        -:  772:  // Check for all paths from operation `from` to operation `untilOp` for the
        -:  773:  // given memory effect.
    #####:  774:  std::function<void(Operation *, Operation *)> recur =
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  775:      [&](Operation *from, Operation *untilOp) {
        -:  776:        assert(
        -:  777:            from->getParentRegion()->isAncestor(untilOp->getParentRegion()) &&
        -:  778:            "Checking for side effect between two operations without a common "
        -:  779:            "ancestor");
        -:  780:
        -:  781:        // If the operations are in different regions, recursively consider all
        -:  782:        // path from `from` to the parent of `to` and all paths from the parent
        -:  783:        // of `to` to `to`.
        -:  784:        if (from->getParentRegion() != untilOp->getParentRegion()) {
        -:  785:          recur(from, untilOp->getParentOp());
        -:  786:          until(untilOp->getParentOp(), untilOp);
        -:  787:          return;
        -:  788:        }
        -:  789:
        -:  790:        // Now, assuming that `from` and `to` exist in the same region, perform
        -:  791:        // a CFG traversal to check all the relevant operations.
        -:  792:
        -:  793:        // Additional blocks to consider.
        -:  794:        SmallVector<Block *, 2> todoBlocks;
        -:  795:        {
        -:  796:          // First consider the parent block of `from` an check all operations
        -:  797:          // after `from`.
        -:  798:          for (auto iter = ++from->getIterator(), end = from->getBlock()->end();
        -:  799:               iter != end && &*iter != untilOp; ++iter) {
        -:  800:            checkOperation(&*iter);
        -:  801:          }
        -:  802:
        -:  803:          // If the parent of `from` doesn't contain `to`, add the successors
        -:  804:          // to the list of blocks to check.
        -:  805:          if (untilOp->getBlock() != from->getBlock())
        -:  806:            for (Block *succ : from->getBlock()->getSuccessors())
        -:  807:              todoBlocks.push_back(succ);
        -:  808:        }
        -:  809:
        -:  810:        SmallPtrSet<Block *, 4> done;
        -:  811:        // Traverse the CFG until hitting `to`.
        -:  812:        while (!todoBlocks.empty()) {
        -:  813:          Block *blk = todoBlocks.pop_back_val();
        -:  814:          if (done.count(blk))
        -:  815:            continue;
        -:  816:          done.insert(blk);
        -:  817:          for (auto &op : *blk) {
        -:  818:            if (&op == untilOp)
        -:  819:              break;
        -:  820:            checkOperation(&op);
        -:  821:            if (&op == blk->getTerminator())
        -:  822:              for (Block *succ : blk->getSuccessors())
        -:  823:                todoBlocks.push_back(succ);
        -:  824:          }
        -:  825:        }
        -:  826:      };
    #####:  827:  recur(start, memOp);
call    0 never executed
    #####:  828:  return !hasSideEffect;
branch  0 never executed
branch  1 never executed
        -:  829:}
------------------
        -:  830:
        -:  831:/// Attempt to eliminate loadOp by replacing it with a value stored into memory
        -:  832:/// which the load is guaranteed to retrieve. This check involves three
        -:  833:/// components: 1) The store and load must be on the same location 2) The store
        -:  834:/// must dominate (and therefore must always occur prior to) the load 3) No
        -:  835:/// other operations will overwrite the memory loaded between the given load
        -:  836:/// and store.  If such a value exists, the replaced `loadOp` will be added to
        -:  837:/// `loadOpsToErase` and its memref will be added to `memrefsToErase`.
function _ZL18forwardStoreToLoadN4mlir21AffineReadOpInterfaceERN4llvm15SmallVectorImplIPNS_9OperationEEERNS1_15SmallPtrSetImplINS_5ValueEEERNS_13DominanceInfoE called 0 returned 0% blocks executed 0%
    #####:  838:static LogicalResult forwardStoreToLoad(
        -:  839:    AffineReadOpInterface loadOp, SmallVectorImpl<Operation *> &loadOpsToErase,
        -:  840:    SmallPtrSetImpl<Value> &memrefsToErase, DominanceInfo &domInfo) {
        -:  841:
        -:  842:  // The store op candidate for forwarding that satisfies all conditions
        -:  843:  // to replace the load, if any.
    #####:  844:  Operation *lastWriteStoreOp = nullptr;
        -:  845:
    #####:  846:  for (auto *user : loadOp.getMemRef().getUsers()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  847:    auto storeOp = dyn_cast<AffineWriteOpInterface>(user);
call    0 never executed
    #####:  848:    if (!storeOp)
branch  0 never executed
branch  1 never executed
    #####:  849:      continue;
    #####:  850:    MemRefAccess srcAccess(storeOp);
call    0 never executed
    #####:  851:    MemRefAccess destAccess(loadOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  852:
        -:  853:    // 1. Check if the store and the load have mathematically equivalent
        -:  854:    // affine access functions; this implies that they statically refer to the
        -:  855:    // same single memref element. As an example this filters out cases like:
        -:  856:    //     store %A[%i0 + 1]
        -:  857:    //     load %A[%i0]
        -:  858:    //     store %A[%M]
        -:  859:    //     load %A[%N]
        -:  860:    // Use the AffineValueMap difference based memref access equality checking.
    #####:  861:    if (srcAccess != destAccess)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  862:      continue;
branch  0 never executed
branch  1 never executed
        -:  863:
        -:  864:    // 2. The store has to dominate the load op to be candidate.
    #####:  865:    if (!domInfo.dominates(storeOp, loadOp))
branch  0 never executed
branch  1 never executed
    #####:  866:      continue;
        -:  867:
        -:  868:    // 3. Ensure there is no intermediate operation which could replace the
        -:  869:    // value in memory.
    #####:  870:    if (!mlir::hasNoInterveningEffect<MemoryEffects::Write>(storeOp, loadOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  871:      continue;
        -:  872:
        -:  873:    // We now have a candidate for forwarding.
    #####:  874:    assert(lastWriteStoreOp == nullptr &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  875:           "multiple simulataneous replacement stores");
    #####:  876:    lastWriteStoreOp = storeOp;
branch  0 never executed
branch  1 never executed
        -:  877:  }
        -:  878:
    #####:  879:  if (!lastWriteStoreOp)
branch  0 never executed
branch  1 never executed
    #####:  880:    return failure();
        -:  881:
        -:  882:  // Perform the actual store to load forwarding.
    #####:  883:  Value storeVal =
    #####:  884:      cast<AffineWriteOpInterface>(lastWriteStoreOp).getValueToStore();
call    0 never executed
call    1 never executed
        -:  885:  // Check if 2 values have the same shape. This is needed for affine vector
        -:  886:  // loads and stores.
    #####:  887:  if (storeVal.getType() != loadOp.getValue().getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  888:    return failure();
    #####:  889:  loadOp.getValue().replaceAllUsesWith(storeVal);
call    0 never executed
call    1 never executed
        -:  890:  // Record the memref for a later sweep to optimize away.
    #####:  891:  memrefsToErase.insert(loadOp.getMemRef());
call    0 never executed
call    1 never executed
        -:  892:  // Record this to erase later.
    #####:  893:  loadOpsToErase.push_back(loadOp);
call    0 never executed
    #####:  894:  return success();
        -:  895:}
        -:  896:
        -:  897:template bool mlir::hasNoInterveningEffect<mlir::MemoryEffects::Read,
        -:  898:                                           mlir::AffineReadOpInterface>(
        -:  899:    mlir::Operation *, mlir::AffineReadOpInterface);
        -:  900:
        -:  901:// This attempts to find stores which have no impact on the final result.
        -:  902:// A writing op writeA will be eliminated if there exists an op writeB if
        -:  903:// 1) writeA and writeB have mathematically equivalent affine access functions.
        -:  904:// 2) writeB postdominates writeA.
        -:  905:// 3) There is no potential read between writeA and writeB.
function _ZL15findUnusedStoreN4mlir22AffineWriteOpInterfaceERN4llvm15SmallVectorImplIPNS_9OperationEEERNS_17PostDominanceInfoE called 0 returned 0% blocks executed 0%
    #####:  906:static void findUnusedStore(AffineWriteOpInterface writeA,
        -:  907:                            SmallVectorImpl<Operation *> &opsToErase,
        -:  908:                            PostDominanceInfo &postDominanceInfo) {
        -:  909:
    #####:  910:  for (Operation *user : writeA.getMemRef().getUsers()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  911:    // Only consider writing operations.
    #####:  912:    auto writeB = dyn_cast<AffineWriteOpInterface>(user);
call    0 never executed
    #####:  913:    if (!writeB)
branch  0 never executed
branch  1 never executed
    #####:  914:      continue;
        -:  915:
        -:  916:    // The operations must be distinct.
    #####:  917:    if (writeB == writeA)
branch  0 never executed
branch  1 never executed
    #####:  918:      continue;
        -:  919:
        -:  920:    // Both operations must lie in the same region.
    #####:  921:    if (writeB->getParentRegion() != writeA->getParentRegion())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  922:      continue;
        -:  923:
        -:  924:    // Both operations must write to the same memory.
    #####:  925:    MemRefAccess srcAccess(writeB);
call    0 never executed
    #####:  926:    MemRefAccess destAccess(writeA);
call    0 never executed
        -:  927:
    #####:  928:    if (srcAccess != destAccess)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  929:      continue;
branch  0 never executed
branch  1 never executed
        -:  930:
        -:  931:    // writeB must postdominate writeA.
    #####:  932:    if (!postDominanceInfo.postDominates(writeB, writeA))
branch  0 never executed
branch  1 never executed
    #####:  933:      continue;
        -:  934:
        -:  935:    // There cannot be an operation which reads from memory between
        -:  936:    // the two writes.
    #####:  937:    if (!mlir::hasNoInterveningEffect<MemoryEffects::Read>(writeA, writeB))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  938:      continue;
        -:  939:
    #####:  940:    opsToErase.push_back(writeA);
call    0 never executed
    #####:  941:    break;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  942:  }
    #####:  943:}
        -:  944:
        -:  945:// The load to load forwarding / redundant load elimination is similar to the
        -:  946:// store to load forwarding.
        -:  947:// loadA will be be replaced with loadB if:
        -:  948:// 1) loadA and loadB have mathematically equivalent affine access functions.
        -:  949:// 2) loadB dominates loadA.
        -:  950:// 3) There is no write between loadA and loadB.
function _ZL7loadCSEN4mlir21AffineReadOpInterfaceERN4llvm15SmallVectorImplIPNS_9OperationEEERNS_13DominanceInfoE called 0 returned 0% blocks executed 0%
    #####:  951:static void loadCSE(AffineReadOpInterface loadA,
        -:  952:                    SmallVectorImpl<Operation *> &loadOpsToErase,
        -:  953:                    DominanceInfo &domInfo) {
    #####:  954:  SmallVector<AffineReadOpInterface, 4> loadCandidates;
call    0 never executed
    #####:  955:  for (auto *user : loadA.getMemRef().getUsers()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  956:    auto loadB = dyn_cast<AffineReadOpInterface>(user);
call    0 never executed
    #####:  957:    if (!loadB || loadB == loadA)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  958:      continue;
        -:  959:
    #####:  960:    MemRefAccess srcAccess(loadB);
call    0 never executed
    #####:  961:    MemRefAccess destAccess(loadA);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  962:
        -:  963:    // 1. The accesses have to be to the same location.
    #####:  964:    if (srcAccess != destAccess) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  965:      continue;
branch  0 never executed
branch  1 never executed
        -:  966:    }
        -:  967:
        -:  968:    // 2. The store has to dominate the load op to be candidate.
    #####:  969:    if (!domInfo.dominates(loadB, loadA))
branch  0 never executed
branch  1 never executed
    #####:  970:      continue;
        -:  971:
        -:  972:    // 3. There is no write between loadA and loadB.
    #####:  973:    if (!mlir::hasNoInterveningEffect<MemoryEffects::Write>(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  974:            loadB.getOperation(), loadA))
    #####:  975:      continue;
        -:  976:
        -:  977:    // Check if two values have the same shape. This is needed for affine vector
        -:  978:    // loads.
    #####:  979:    if (loadB.getValue().getType() != loadA.getValue().getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  980:      continue;
        -:  981:
    #####:  982:    loadCandidates.push_back(loadB);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  983:  }
        -:  984:
        -:  985:  // Of the legal load candidates, use the one that dominates all others
        -:  986:  // to minimize the subsequent need to loadCSE
    #####:  987:  Value loadB;
    #####:  988:  for (AffineReadOpInterface option : loadCandidates) {
branch  0 never executed
branch  1 never executed
    #####:  989:    if (llvm::all_of(loadCandidates, [&](AffineReadOpInterface depStore) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  990:          return depStore == option ||
branch  0 never executed
branch  1 never executed
    #####:  991:                 domInfo.dominates(option.getOperation(),
call    0 never executed
        -:  992:                                   depStore.getOperation());
        -:  993:        })) {
    #####:  994:      loadB = option.getValue();
call    0 never executed
    #####:  995:      break;
        -:  996:    }
        -:  997:  }
        -:  998:
    #####:  999:  if (loadB) {
branch  0 never executed
branch  1 never executed
    #####: 1000:    loadA.getValue().replaceAllUsesWith(loadB);
call    0 never executed
call    1 never executed
        -: 1001:    // Record this to erase later.
    #####: 1002:    loadOpsToErase.push_back(loadA);
call    0 never executed
        -: 1003:  }
    #####: 1004:}
        -: 1005:
        -: 1006:// The store to load forwarding and load CSE rely on three conditions:
        -: 1007://
        -: 1008:// 1) store/load providing a replacement value and load being replaced need to
        -: 1009:// have mathematically equivalent affine access functions (checked after full
        -: 1010:// composition of load/store operands); this implies that they access the same
        -: 1011:// single memref element for all iterations of the common surrounding loop,
        -: 1012://
        -: 1013:// 2) the store/load op should dominate the load op,
        -: 1014://
        -: 1015:// 3) no operation that may write to memory read by the load being replaced can
        -: 1016:// occur after executing the instruction (load or store) providing the
        -: 1017:// replacement value and before the load being replaced (thus potentially
        -: 1018:// allowing overwriting the memory read by the load).
        -: 1019://
        -: 1020:// The above conditions are simple to check, sufficient, and powerful for most
        -: 1021:// cases in practice - they are sufficient, but not necessary --- since they
        -: 1022:// don't reason about loops that are guaranteed to execute at least once or
        -: 1023:// multiple sources to forward from.
        -: 1024://
        -: 1025:// TODO: more forwarding can be done when support for
        -: 1026:// loop/conditional live-out SSA values is available.
        -: 1027:// TODO: do general dead store elimination for memref's. This pass
        -: 1028:// currently only eliminates the stores only if no other loads/uses (other
        -: 1029:// than dealloc) remain.
        -: 1030://
function _ZN4mlir19affineScalarReplaceENS_4func6FuncOpERNS_13DominanceInfoERNS_17PostDominanceInfoE called 0 returned 0% blocks executed 0%
    #####: 1031:void mlir::affineScalarReplace(func::FuncOp f, DominanceInfo &domInfo,
        -: 1032:                               PostDominanceInfo &postDomInfo) {
        -: 1033:  // Load op's whose results were replaced by those forwarded from stores.
    #####: 1034:  SmallVector<Operation *, 8> opsToErase;
call    0 never executed
        -: 1035:
        -: 1036:  // A list of memref's that are potentially dead / could be eliminated.
    #####: 1037:  SmallPtrSet<Value, 4> memrefsToErase;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1038:
        -: 1039:  // Walk all load's and perform store to load forwarding.
function _ZZN4mlir19affineScalarReplaceENS_4func6FuncOpERNS_13DominanceInfoERNS_17PostDominanceInfoEENKUlNS_21AffineReadOpInterfaceEE_clES6_ called 0 returned 0% blocks executed 0%
    #####: 1040:  f.walk([&](AffineReadOpInterface loadOp) {
call    0 never executed
    #####: 1041:    if (failed(
branch  0 never executed
branch  1 never executed
    #####: 1042:            forwardStoreToLoad(loadOp, opsToErase, memrefsToErase, domInfo))) {
call    0 never executed
    #####: 1043:      loadCSE(loadOp, opsToErase, domInfo);
call    0 never executed
        -: 1044:    }
    #####: 1045:  });
        -: 1046:
        -: 1047:  // Erase all load op's whose results were replaced with store fwd'ed ones.
    #####: 1048:  for (auto *op : opsToErase)
branch  0 never executed
branch  1 never executed
    #####: 1049:    op->erase();
call    0 never executed
    #####: 1050:  opsToErase.clear();
call    0 never executed
        -: 1051:
        -: 1052:  // Walk all store's and perform unused store elimination
    #####: 1053:  f.walk([&](AffineWriteOpInterface storeOp) {
call    0 never executed
    #####: 1054:    findUnusedStore(storeOp, opsToErase, postDomInfo);
call    0 never executed
        -: 1055:  });
        -: 1056:  // Erase all store op's which don't impact the program
    #####: 1057:  for (auto *op : opsToErase)
branch  0 never executed
branch  1 never executed
    #####: 1058:    op->erase();
call    0 never executed
        -: 1059:
        -: 1060:  // Check if the store fwd'ed memrefs are now left with only stores and
        -: 1061:  // deallocs and can thus be completely deleted. Note: the canonicalize pass
        -: 1062:  // should be able to do this as well, but we'll do it here since we collected
        -: 1063:  // these anyway.
    #####: 1064:  for (auto memref : memrefsToErase) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
        -: 1065:    // If the memref hasn't been locally alloc'ed, skip.
    #####: 1066:    Operation *defOp = memref.getDefiningOp();
call    0 never executed
    #####: 1067:    if (!defOp || !hasSingleEffect<MemoryEffects::Allocate>(defOp, memref))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1068:      // TODO: if the memref was returned by a 'call' operation, we
        -: 1069:      // could still erase it if the call had no side-effects.
    #####: 1070:      continue;
function _ZZN4mlir19affineScalarReplaceENS_4func6FuncOpERNS_13DominanceInfoERNS_17PostDominanceInfoEENKUlPNS_9OperationEE1_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1071:    if (llvm::any_of(memref.getUsers(), [&](Operation *ownerOp) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1072:          return !isa<AffineWriteOpInterface>(ownerOp) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1073:                 !hasSingleEffect<MemoryEffects::Free>(ownerOp, memref);
call    0 never executed
        -: 1074:        }))
    #####: 1075:      continue;
        -: 1076:
        -: 1077:    // Erase all stores, the dealloc, and the alloc on the memref.
    #####: 1078:    for (auto *user : llvm::make_early_inc_range(memref.getUsers()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1079:      user->erase();
call    0 never executed
    #####: 1080:    defOp->erase();
call    0 never executed
        -: 1081:  }
    #####: 1082:}
        -: 1083:
        -: 1084:// Perform the replacement in `op`.
function _ZN4mlir24replaceAllMemRefUsesWithENS_5ValueES0_PNS_9OperationEN4llvm8ArrayRefIS0_EENS_9AffineMapES5_S5_b called 0 returned 0% blocks executed 0%
    #####: 1085:LogicalResult mlir::replaceAllMemRefUsesWith(Value oldMemRef, Value newMemRef,
        -: 1086:                                             Operation *op,
        -: 1087:                                             ArrayRef<Value> extraIndices,
        -: 1088:                                             AffineMap indexRemap,
        -: 1089:                                             ArrayRef<Value> extraOperands,
        -: 1090:                                             ArrayRef<Value> symbolOperands,
        -: 1091:                                             bool allowNonDereferencingOps) {
    #####: 1092:  unsigned newMemRefRank = newMemRef.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
    #####: 1093:  (void)newMemRefRank; // unused in opt mode
    #####: 1094:  unsigned oldMemRefRank = oldMemRef.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
    #####: 1095:  (void)oldMemRefRank; // unused in opt mode
    #####: 1096:  if (indexRemap) {
branch  0 never executed
branch  1 never executed
    #####: 1097:    assert(indexRemap.getNumSymbols() == symbolOperands.size() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1098:           "symbolic operand count mismatch");
    #####: 1099:    assert(indexRemap.getNumInputs() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1100:           extraOperands.size() + oldMemRefRank + symbolOperands.size());
    #####: 1101:    assert(indexRemap.getNumResults() + extraIndices.size() == newMemRefRank);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1102:  } else {
    #####: 1103:    assert(oldMemRefRank + extraIndices.size() == newMemRefRank);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1104:  }
        -: 1105:
        -: 1106:  // Assert same elemental type.
    #####: 1107:  assert(oldMemRef.getType().cast<MemRefType>().getElementType() ==
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1108:         newMemRef.getType().cast<MemRefType>().getElementType());
        -: 1109:
    #####: 1110:  SmallVector<unsigned, 2> usePositions;
call    0 never executed
    #####: 1111:  for (const auto &opEntry : llvm::enumerate(op->getOperands())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1112:    if (opEntry.value() == oldMemRef)
branch  0 never executed
branch  1 never executed
    #####: 1113:      usePositions.push_back(opEntry.index());
call    0 never executed
        -: 1114:  }
        -: 1115:
        -: 1116:  // If memref doesn't appear, nothing to do.
    #####: 1117:  if (usePositions.empty())
branch  0 never executed
branch  1 never executed
    #####: 1118:    return success();
        -: 1119:
    #####: 1120:  if (usePositions.size() > 1) {
branch  0 never executed
branch  1 never executed
        -: 1121:    // TODO: extend it for this case when needed (rare).
    #####: 1122:    assert(false && "multiple dereferencing uses in a single op not supported");
call    0 never executed
        -: 1123:    return failure();
        -: 1124:  }
        -: 1125:
    #####: 1126:  unsigned memRefOperandPos = usePositions.front();
call    0 never executed
        -: 1127:
    #####: 1128:  OpBuilder builder(op);
call    0 never executed
        -: 1129:  // The following checks if op is dereferencing memref and performs the access
        -: 1130:  // index rewrites.
    #####: 1131:  auto affMapAccInterface = dyn_cast<AffineMapAccessInterface>(op);
call    0 never executed
    #####: 1132:  if (!affMapAccInterface) {
branch  0 never executed
branch  1 never executed
    #####: 1133:    if (!allowNonDereferencingOps) {
branch  0 never executed
branch  1 never executed
        -: 1134:      // Failure: memref used in a non-dereferencing context (potentially
        -: 1135:      // escapes); no replacement in these cases unless allowNonDereferencingOps
        -: 1136:      // is set.
    #####: 1137:      return failure();
        -: 1138:    }
    #####: 1139:    op->setOperand(memRefOperandPos, newMemRef);
call    0 never executed
    #####: 1140:    return success();
        -: 1141:  }
        -: 1142:  // Perform index rewrites for the dereferencing op and then replace the op
    #####: 1143:  NamedAttribute oldMapAttrPair =
    #####: 1144:      affMapAccInterface.getAffineMapAttrForMemRef(oldMemRef);
call    0 never executed
    #####: 1145:  AffineMap oldMap = oldMapAttrPair.getValue().cast<AffineMapAttr>().getValue();
call    0 never executed
call    1 never executed
    #####: 1146:  unsigned oldMapNumInputs = oldMap.getNumInputs();
call    0 never executed
    #####: 1147:  SmallVector<Value, 4> oldMapOperands(
    #####: 1148:      op->operand_begin() + memRefOperandPos + 1,
call    0 never executed
call    1 never executed
    #####: 1149:      op->operand_begin() + memRefOperandPos + 1 + oldMapNumInputs);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1150:
        -: 1151:  // Apply 'oldMemRefOperands = oldMap(oldMapOperands)'.
    #####: 1152:  SmallVector<Value, 4> oldMemRefOperands;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1153:  SmallVector<Value, 4> affineApplyOps;
branch  0 never executed
branch  1 never executed
    #####: 1154:  oldMemRefOperands.reserve(oldMemRefRank);
branch  0 never executed
branch  1 never executed
    #####: 1155:  if (oldMap != builder.getMultiDimIdentityMap(oldMap.getNumDims())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1156:    for (auto resultExpr : oldMap.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1157:      auto singleResMap = AffineMap::get(oldMap.getNumDims(),
    #####: 1158:                                         oldMap.getNumSymbols(), resultExpr);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1159:      auto afOp = builder.create<AffineApplyOp>(op->getLoc(), singleResMap,
    #####: 1160:                                                oldMapOperands);
call    0 never executed
    #####: 1161:      oldMemRefOperands.push_back(afOp);
call    0 never executed
    #####: 1162:      affineApplyOps.push_back(afOp);
call    0 never executed
        -: 1163:    }
        -: 1164:  } else {
    #####: 1165:    oldMemRefOperands.assign(oldMapOperands.begin(), oldMapOperands.end());
call    0 never executed
        -: 1166:  }
        -: 1167:
        -: 1168:  // Construct new indices as a remap of the old ones if a remapping has been
        -: 1169:  // provided. The indices of a memref come right after it, i.e.,
        -: 1170:  // at position memRefOperandPos + 1.
    #####: 1171:  SmallVector<Value, 4> remapOperands;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1172:  remapOperands.reserve(extraOperands.size() + oldMemRefRank +
branch  0 never executed
branch  1 never executed
    #####: 1173:                        symbolOperands.size());
branch  0 never executed
branch  1 never executed
    #####: 1174:  remapOperands.append(extraOperands.begin(), extraOperands.end());
call    0 never executed
    #####: 1175:  remapOperands.append(oldMemRefOperands.begin(), oldMemRefOperands.end());
call    0 never executed
    #####: 1176:  remapOperands.append(symbolOperands.begin(), symbolOperands.end());
call    0 never executed
        -: 1177:
    #####: 1178:  SmallVector<Value, 4> remapOutputs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1179:  remapOutputs.reserve(oldMemRefRank);
branch  0 never executed
branch  1 never executed
        -: 1180:
    #####: 1181:  if (indexRemap &&
branch  0 never executed
branch  1 never executed
    #####: 1182:      indexRemap != builder.getMultiDimIdentityMap(indexRemap.getNumDims())) {
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -: 1183:    // Remapped indices.
    #####: 1184:    for (auto resultExpr : indexRemap.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1185:      auto singleResMap = AffineMap::get(
    #####: 1186:          indexRemap.getNumDims(), indexRemap.getNumSymbols(), resultExpr);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1187:      auto afOp = builder.create<AffineApplyOp>(op->getLoc(), singleResMap,
    #####: 1188:                                                remapOperands);
call    0 never executed
    #####: 1189:      remapOutputs.push_back(afOp);
call    0 never executed
    #####: 1190:      affineApplyOps.push_back(afOp);
call    0 never executed
        -: 1191:    }
        -: 1192:  } else {
        -: 1193:    // No remapping specified.
    #####: 1194:    remapOutputs.assign(remapOperands.begin(), remapOperands.end());
call    0 never executed
        -: 1195:  }
        -: 1196:
    #####: 1197:  SmallVector<Value, 4> newMapOperands;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1198:  newMapOperands.reserve(newMemRefRank);
branch  0 never executed
branch  1 never executed
        -: 1199:
        -: 1200:  // Prepend 'extraIndices' in 'newMapOperands'.
    #####: 1201:  for (Value extraIndex : extraIndices) {
branch  0 never executed
branch  1 never executed
    #####: 1202:    assert(extraIndex.getDefiningOp()->getNumResults() == 1 &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1203:           "single result op's expected to generate these indices");
    #####: 1204:    assert((isValidDim(extraIndex) || isValidSymbol(extraIndex)) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1205:           "invalid memory op index");
    #####: 1206:    newMapOperands.push_back(extraIndex);
call    0 never executed
        -: 1207:  }
        -: 1208:
        -: 1209:  // Append 'remapOutputs' to 'newMapOperands'.
    #####: 1210:  newMapOperands.append(remapOutputs.begin(), remapOutputs.end());
call    0 never executed
        -: 1211:
        -: 1212:  // Create new fully composed AffineMap for new op to be created.
    #####: 1213:  assert(newMapOperands.size() == newMemRefRank);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1214:  auto newMap = builder.getMultiDimIdentityMap(newMemRefRank);
call    0 never executed
        -: 1215:  // TODO: Avoid creating/deleting temporary AffineApplyOps here.
    #####: 1216:  fullyComposeAffineMapAndOperands(&newMap, &newMapOperands);
call    0 never executed
    #####: 1217:  newMap = simplifyAffineMap(newMap);
call    0 never executed
    #####: 1218:  canonicalizeMapAndOperands(&newMap, &newMapOperands);
call    0 never executed
        -: 1219:  // Remove any affine.apply's that became dead as a result of composition.
    #####: 1220:  for (Value value : affineApplyOps)
branch  0 never executed
branch  1 never executed
    #####: 1221:    if (value.use_empty())
branch  0 never executed
branch  1 never executed
    #####: 1222:      value.getDefiningOp()->erase();
call    0 never executed
call    1 never executed
        -: 1223:
    #####: 1224:  OperationState state(op->getLoc(), op->getName());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1225:  // Construct the new operation using this memref.
    #####: 1226:  state.operands.reserve(op->getNumOperands() + extraIndices.size());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1227:  // Insert the non-memref operands.
    #####: 1228:  state.operands.append(op->operand_begin(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1229:                        op->operand_begin() + memRefOperandPos);
call    0 never executed
        -: 1230:  // Insert the new memref value.
    #####: 1231:  state.operands.push_back(newMemRef);
call    0 never executed
        -: 1232:
        -: 1233:  // Insert the new memref map operands.
    #####: 1234:  state.operands.append(newMapOperands.begin(), newMapOperands.end());
call    0 never executed
        -: 1235:
        -: 1236:  // Insert the remaining operands unmodified.
    #####: 1237:  state.operands.append(op->operand_begin() + memRefOperandPos + 1 +
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1238:                            oldMapNumInputs,
        -: 1239:                        op->operand_end());
        -: 1240:
        -: 1241:  // Result types don't change. Both memref's are of the same elemental type.
    #####: 1242:  state.types.reserve(op->getNumResults());
branch  0 never executed
branch  1 never executed
    #####: 1243:  for (auto result : op->getResults())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1244:    state.types.push_back(result.getType());
call    0 never executed
        -: 1245:
        -: 1246:  // Add attribute for 'newMap', other Attributes do not change.
    #####: 1247:  auto newMapAttr = AffineMapAttr::get(newMap);
call    0 never executed
    #####: 1248:  for (auto namedAttr : op->getAttrs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1249:    if (namedAttr.getName() == oldMapAttrPair.getName())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1250:      state.attributes.push_back({namedAttr.getName(), newMapAttr});
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1251:    else
    #####: 1252:      state.attributes.push_back(namedAttr);
call    0 never executed
        -: 1253:  }
        -: 1254:
        -: 1255:  // Create the new operation.
    #####: 1256:  auto *repOp = builder.create(state);
call    0 never executed
    #####: 1257:  op->replaceAllUsesWith(repOp);
branch  0 never executed
branch  1 never executed
    #####: 1258:  op->erase();
call    0 never executed
        -: 1259:
    #####: 1260:  return success();
call    0 never executed
        -: 1261:}
        -: 1262:
function _ZN4mlir24replaceAllMemRefUsesWithENS_5ValueES0_N4llvm8ArrayRefIS0_EENS_9AffineMapES3_S3_PNS_9OperationES6_bb called 0 returned 0% blocks executed 0%
    #####: 1263:LogicalResult mlir::replaceAllMemRefUsesWith(
        -: 1264:    Value oldMemRef, Value newMemRef, ArrayRef<Value> extraIndices,
        -: 1265:    AffineMap indexRemap, ArrayRef<Value> extraOperands,
        -: 1266:    ArrayRef<Value> symbolOperands, Operation *domOpFilter,
        -: 1267:    Operation *postDomOpFilter, bool allowNonDereferencingOps,
        -: 1268:    bool replaceInDeallocOp) {
    #####: 1269:  unsigned newMemRefRank = newMemRef.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
    #####: 1270:  (void)newMemRefRank; // unused in opt mode
    #####: 1271:  unsigned oldMemRefRank = oldMemRef.getType().cast<MemRefType>().getRank();
call    0 never executed
call    1 never executed
    #####: 1272:  (void)oldMemRefRank;
    #####: 1273:  if (indexRemap) {
branch  0 never executed
branch  1 never executed
    #####: 1274:    assert(indexRemap.getNumSymbols() == symbolOperands.size() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1275:           "symbol operand count mismatch");
    #####: 1276:    assert(indexRemap.getNumInputs() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1277:           extraOperands.size() + oldMemRefRank + symbolOperands.size());
    #####: 1278:    assert(indexRemap.getNumResults() + extraIndices.size() == newMemRefRank);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -: 1279:  } else {
    #####: 1280:    assert(oldMemRefRank + extraIndices.size() == newMemRefRank);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1281:  }
        -: 1282:
        -: 1283:  // Assert same elemental type.
    #####: 1284:  assert(oldMemRef.getType().cast<MemRefType>().getElementType() ==
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -: 1285:         newMemRef.getType().cast<MemRefType>().getElementType());
        -: 1286:
    #####: 1287:  std::unique_ptr<DominanceInfo> domInfo;
    #####: 1288:  std::unique_ptr<PostDominanceInfo> postDomInfo;
branch  0 never executed
branch  1 never executed
    #####: 1289:  if (domOpFilter)
branch  0 never executed
branch  1 never executed
    #####: 1290:    domInfo = std::make_unique<DominanceInfo>(
call    0 never executed
    #####: 1291:        domOpFilter->getParentOfType<func::FuncOp>());
call    0 never executed
        -: 1292:
    #####: 1293:  if (postDomOpFilter)
branch  0 never executed
branch  1 never executed
    #####: 1294:    postDomInfo = std::make_unique<PostDominanceInfo>(
call    0 never executed
    #####: 1295:        postDomOpFilter->getParentOfType<func::FuncOp>());
call    0 never executed
        -: 1296:
        -: 1297:  // Walk all uses of old memref; collect ops to perform replacement. We use a
        -: 1298:  // DenseSet since an operation could potentially have multiple uses of a
        -: 1299:  // memref (although rare), and the replacement later is going to erase ops.
    #####: 1300:  DenseSet<Operation *> opsToReplace;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1301:  for (auto *op : oldMemRef.getUsers()) {
branch  0 never executed
branch  1 never executed
        -: 1302:    // Skip this use if it's not dominated by domOpFilter.
    #####: 1303:    if (domOpFilter && !domInfo->dominates(domOpFilter, op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1304:      continue;
        -: 1305:
        -: 1306:    // Skip this use if it's not post-dominated by postDomOpFilter.
    #####: 1307:    if (postDomOpFilter && !postDomInfo->postDominates(postDomOpFilter, op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1308:      continue;
        -: 1309:
        -: 1310:    // Skip dealloc's - no replacement is necessary, and a memref replacement
        -: 1311:    // at other uses doesn't hurt these dealloc's.
    #####: 1312:    if (hasSingleEffect<MemoryEffects::Free>(op, oldMemRef) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1313:        !replaceInDeallocOp)
    #####: 1314:      continue;
        -: 1315:
        -: 1316:    // Check if the memref was used in a non-dereferencing context. It is fine
        -: 1317:    // for the memref to be used in a non-dereferencing way outside of the
        -: 1318:    // region where this replacement is happening.
    #####: 1319:    if (!isa<AffineMapAccessInterface>(*op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1320:      if (!allowNonDereferencingOps) {
branch  0 never executed
branch  1 never executed
    #####: 1321:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -: 1322:                   << "Memref replacement failed: non-deferencing memref op: \n"
        -: 1323:                   << *op << '\n');
    #####: 1324:        return failure();
        -: 1325:      }
        -: 1326:      // Non-dereferencing ops with the MemRefsNormalizable trait are
        -: 1327:      // supported for replacement.
    #####: 1328:      if (!op->hasTrait<OpTrait::MemRefsNormalizable>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1329:        LLVM_DEBUG(llvm::dbgs() << "Memref replacement failed: use without a "
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
        -: 1330:                                   "memrefs normalizable trait: \n"
        -: 1331:                                << *op << '\n');
    #####: 1332:        return failure();
        -: 1333:      }
        -: 1334:    }
        -: 1335:
        -: 1336:    // We'll first collect and then replace --- since replacement erases the op
        -: 1337:    // that has the use, and that op could be postDomFilter or domFilter itself!
    #####: 1338:    opsToReplace.insert(op);
call    0 never executed
        -: 1339:  }
        -: 1340:
    #####: 1341:  for (auto *op : opsToReplace) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####: 1342:    if (failed(replaceAllMemRefUsesWith(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1343:            oldMemRef, newMemRef, op, extraIndices, indexRemap, extraOperands,
        -: 1344:            symbolOperands, allowNonDereferencingOps)))
    #####: 1345:      llvm_unreachable("memref replacement guaranteed to succeed here");
call    0 never executed
        -: 1346:  }
        -: 1347:
    #####: 1348:  return success();
call    0 never executed
        -: 1349:}
        -: 1350:
        -: 1351:/// Given an operation, inserts one or more single result affine
        -: 1352:/// apply operations, results of which are exclusively used by this operation
        -: 1353:/// operation. The operands of these newly created affine apply ops are
        -: 1354:/// guaranteed to be loop iterators or terminal symbols of a function.
        -: 1355:///
        -: 1356:/// Before
        -: 1357:///
        -: 1358:/// affine.for %i = 0 to #map(%N)
        -: 1359:///   %idx = affine.apply (d0) -> (d0 mod 2) (%i)
        -: 1360:///   "send"(%idx, %A, ...)
        -: 1361:///   "compute"(%idx)
        -: 1362:///
        -: 1363:/// After
        -: 1364:///
        -: 1365:/// affine.for %i = 0 to #map(%N)
        -: 1366:///   %idx = affine.apply (d0) -> (d0 mod 2) (%i)
        -: 1367:///   "send"(%idx, %A, ...)
        -: 1368:///   %idx_ = affine.apply (d0) -> (d0 mod 2) (%i)
        -: 1369:///   "compute"(%idx_)
        -: 1370:///
        -: 1371:/// This allows applying different transformations on send and compute (for eg.
        -: 1372:/// different shifts/delays).
        -: 1373:///
        -: 1374:/// Returns nullptr either if none of opInst's operands were the result of an
        -: 1375:/// affine.apply and thus there was no affine computation slice to create, or if
        -: 1376:/// all the affine.apply op's supplying operands to this opInst did not have any
        -: 1377:/// uses besides this opInst; otherwise returns the list of affine.apply
        -: 1378:/// operations created in output argument `sliceOps`.
function _ZN4mlir28createAffineComputationSliceEPNS_9OperationEPN4llvm15SmallVectorImplINS_13AffineApplyOpEEE called 0 returned 0% blocks executed 0%
    #####: 1379:void mlir::createAffineComputationSlice(
        -: 1380:    Operation *opInst, SmallVectorImpl<AffineApplyOp> *sliceOps) {
        -: 1381:  // Collect all operands that are results of affine apply ops.
    #####: 1382:  SmallVector<Value, 4> subOperands;
branch  0 never executed
branch  1 never executed
    #####: 1383:  subOperands.reserve(opInst->getNumOperands());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1384:  for (auto operand : opInst->getOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1385:    if (isa_and_nonnull<AffineApplyOp>(operand.getDefiningOp()))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1386:      subOperands.push_back(operand);
call    0 never executed
        -: 1387:
        -: 1388:  // Gather sequence of AffineApplyOps reachable from 'subOperands'.
    #####: 1389:  SmallVector<Operation *, 4> affineApplyOps;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1390:  getReachableAffineApplyOps(subOperands, affineApplyOps);
call    0 never executed
        -: 1391:  // Skip transforming if there are no affine maps to compose.
    #####: 1392:  if (affineApplyOps.empty())
branch  0 never executed
branch  1 never executed
    #####: 1393:    return;
branch  0 never executed
branch  1 never executed
        -: 1394:
        -: 1395:  // Check if all uses of the affine apply op's lie only in this op op, in
        -: 1396:  // which case there would be nothing to do.
    #####: 1397:  bool localized = true;
    #####: 1398:  for (auto *op : affineApplyOps) {
branch  0 never executed
branch  1 never executed
    #####: 1399:    for (auto result : op->getResults()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1400:      for (auto *user : result.getUsers()) {
branch  0 never executed
branch  1 never executed
    #####: 1401:        if (user != opInst) {
branch  0 never executed
branch  1 never executed
        -: 1402:          localized = false;
        -: 1403:          break;
        -: 1404:        }
        -: 1405:      }
        -: 1406:    }
        -: 1407:  }
    #####: 1408:  if (localized)
branch  0 never executed
branch  1 never executed
        -: 1409:    return;
        -: 1410:
    #####: 1411:  OpBuilder builder(opInst);
call    0 never executed
    #####: 1412:  SmallVector<Value, 4> composedOpOperands(subOperands);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1413:  auto composedMap = builder.getMultiDimIdentityMap(composedOpOperands.size());
call    0 never executed
    #####: 1414:  fullyComposeAffineMapAndOperands(&composedMap, &composedOpOperands);
call    0 never executed
        -: 1415:
        -: 1416:  // Create an affine.apply for each of the map results.
    #####: 1417:  sliceOps->reserve(composedMap.getNumResults());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1418:  for (auto resultExpr : composedMap.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1419:    auto singleResMap = AffineMap::get(composedMap.getNumDims(),
    #####: 1420:                                       composedMap.getNumSymbols(), resultExpr);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1421:    sliceOps->push_back(builder.create<AffineApplyOp>(
call    0 never executed
call    1 never executed
        -: 1422:        opInst->getLoc(), singleResMap, composedOpOperands));
        -: 1423:  }
        -: 1424:
        -: 1425:  // Construct the new operands that include the results from the composed
        -: 1426:  // affine apply op above instead of existing ones (subOperands). So, they
        -: 1427:  // differ from opInst's operands only for those operands in 'subOperands', for
        -: 1428:  // which they will be replaced by the corresponding one from 'sliceOps'.
    #####: 1429:  SmallVector<Value, 4> newOperands(opInst->getOperands());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1430:  for (unsigned i = 0, e = newOperands.size(); i < e; i++) {
branch  0 never executed
branch  1 never executed
        -: 1431:    // Replace the subOperands from among the new operands.
    #####: 1432:    unsigned j, f;
    #####: 1433:    for (j = 0, f = subOperands.size(); j < f; j++) {
branch  0 never executed
branch  1 never executed
    #####: 1434:      if (newOperands[i] == subOperands[j])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1435:        break;
        -: 1436:    }
    #####: 1437:    if (j < subOperands.size()) {
branch  0 never executed
branch  1 never executed
    #####: 1438:      newOperands[i] = (*sliceOps)[j];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1439:    }
        -: 1440:  }
    #####: 1441:  for (unsigned idx = 0, e = newOperands.size(); idx < e; idx++) {
branch  0 never executed
branch  1 never executed
    #####: 1442:    opInst->setOperand(idx, newOperands[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1443:  }
        -: 1444:}
        -: 1445:
        -: 1446:/// Enum to set patterns of affine expr in tiled-layout map.
        -: 1447:/// TileFloorDiv: <dim expr> div <tile size>
        -: 1448:/// TileMod: <dim expr> mod <tile size>
        -: 1449:/// TileNone: None of the above
        -: 1450:/// Example:
        -: 1451:/// #tiled_2d_128x256 = affine_map<(d0, d1)
        -: 1452:///            -> (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)>
        -: 1453:/// "d0 div 128" and "d1 div 256" ==> TileFloorDiv
        -: 1454:/// "d0 mod 128" and "d1 mod 256" ==> TileMod
        -: 1455:enum TileExprPattern { TileFloorDiv, TileMod, TileNone };
        -: 1456:
        -: 1457:/// Check if `map` is a tiled layout. In the tiled layout, specific k dimensions
        -: 1458:/// being floordiv'ed by respective tile sizes appeare in a mod with the same
        -: 1459:/// tile sizes, and no other expression involves those k dimensions. This
        -: 1460:/// function stores a vector of tuples (`tileSizePos`) including AffineExpr for
        -: 1461:/// tile size, positions of corresponding `floordiv` and `mod`. If it is not a
        -: 1462:/// tiled layout, an empty vector is returned.
function _ZL14getTileSizePosN4mlir9AffineMapERN4llvm15SmallVectorImplISt5tupleIJNS_10AffineExprEjjEEEE called 0 returned 0% blocks executed 0%
    #####: 1463:static LogicalResult getTileSizePos(
        -: 1464:    AffineMap map,
        -: 1465:    SmallVectorImpl<std::tuple<AffineExpr, unsigned, unsigned>> &tileSizePos) {
        -: 1466:  // Create `floordivExprs` which is a vector of tuples including LHS and RHS of
        -: 1467:  // `floordiv` and its position in `map` output.
        -: 1468:  // Example: #tiled_2d_128x256 = affine_map<(d0, d1)
        -: 1469:  //                -> (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)>
        -: 1470:  // In this example, `floordivExprs` includes {d0, 128, 0} and {d1, 256, 1}.
    #####: 1471:  SmallVector<std::tuple<AffineExpr, AffineExpr, unsigned>, 4> floordivExprs;
call    0 never executed
    #####: 1472:  unsigned pos = 0;
    #####: 1473:  for (AffineExpr expr : map.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1474:    if (expr.getKind() == AffineExprKind::FloorDiv) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1475:      AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
call    0 never executed
    #####: 1476:      if (binaryExpr.getRHS().isa<AffineConstantExpr>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1477:        floordivExprs.emplace_back(
    #####: 1478:            std::make_tuple(binaryExpr.getLHS(), binaryExpr.getRHS(), pos));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1479:    }
    #####: 1480:    pos++;
        -: 1481:  }
        -: 1482:  // Not tiled layout if `floordivExprs` is empty.
    #####: 1483:  if (floordivExprs.empty()) {
branch  0 never executed
branch  1 never executed
    #####: 1484:    tileSizePos = SmallVector<std::tuple<AffineExpr, unsigned, unsigned>>{};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1485:    return success();
        -: 1486:  }
        -: 1487:
        -: 1488:  // Check if LHS of `floordiv` is used in LHS of `mod`. If not used, `map` is
        -: 1489:  // not tiled layout.
    #####: 1490:  for (std::tuple<AffineExpr, AffineExpr, unsigned> fexpr : floordivExprs) {
branch  0 never executed
branch  1 never executed
    #####: 1491:    AffineExpr floordivExprLHS = std::get<0>(fexpr);
call    0 never executed
    #####: 1492:    AffineExpr floordivExprRHS = std::get<1>(fexpr);
    #####: 1493:    unsigned floordivPos = std::get<2>(fexpr);
call    0 never executed
        -: 1494:
        -: 1495:    // Walk affinexpr of `map` output except `fexpr`, and check if LHS and RHS
        -: 1496:    // of `fexpr` are used in LHS and RHS of `mod`. If LHS of `fexpr` is used
        -: 1497:    // other expr, the map is not tiled layout. Example of non tiled layout:
        -: 1498:    //   affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2 floordiv 256)>
        -: 1499:    //   affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2 mod 128)>
        -: 1500:    //   affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2 mod 256, d2 mod
        -: 1501:    //   256)>
    #####: 1502:    bool found = false;
    #####: 1503:    pos = 0;
    #####: 1504:    for (AffineExpr expr : map.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1505:      bool notTiled = false;
    #####: 1506:      if (pos != floordivPos) {
branch  0 never executed
branch  1 never executed
function _ZZL14getTileSizePosN4mlir9AffineMapERN4llvm15SmallVectorImplISt5tupleIJNS_10AffineExprEjjEEEEENKUlS4_E_clES4_ called 0 returned 0% blocks executed 0%
    #####: 1507:        expr.walk([&](AffineExpr e) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1508:          if (e == floordivExprLHS) {
branch  0 never executed
branch  1 never executed
    #####: 1509:            if (expr.getKind() == AffineExprKind::Mod) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1510:              AffineBinaryOpExpr binaryExpr = expr.cast<AffineBinaryOpExpr>();
call    0 never executed
        -: 1511:              // If LHS and RHS of `mod` are the same with those of floordiv.
    #####: 1512:              if (floordivExprLHS == binaryExpr.getLHS() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1513:                  floordivExprRHS == binaryExpr.getRHS()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1514:                // Save tile size (RHS of `mod`), and position of `floordiv` and
        -: 1515:                // `mod` if same expr with `mod` is not found yet.
    #####: 1516:                if (!found) {
branch  0 never executed
branch  1 never executed
    #####: 1517:                  tileSizePos.emplace_back(
    #####: 1518:                      std::make_tuple(binaryExpr.getRHS(), floordivPos, pos));
call    0 never executed
call    1 never executed
    #####: 1519:                  found = true;
        -: 1520:                } else {
        -: 1521:                  // Non tiled layout: Have multilpe `mod` with the same LHS.
        -: 1522:                  // eg. affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2
        -: 1523:                  // mod 256, d2 mod 256)>
    #####: 1524:                  notTiled = true;
        -: 1525:                }
        -: 1526:              } else {
        -: 1527:                // Non tiled layout: RHS of `mod` is different from `floordiv`.
        -: 1528:                // eg. affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2
        -: 1529:                // mod 128)>
    #####: 1530:                notTiled = true;
        -: 1531:              }
        -: 1532:            } else {
        -: 1533:              // Non tiled layout: LHS is the same, but not `mod`.
        -: 1534:              // eg. affine_map<(d0, d1, d2) -> (d0, d1, d2 floordiv 256, d2
        -: 1535:              // floordiv 256)>
    #####: 1536:              notTiled = true;
        -: 1537:            }
        -: 1538:          }
    #####: 1539:        });
        -: 1540:      }
    #####: 1541:      if (notTiled) {
branch  0 never executed
branch  1 never executed
    #####: 1542:        tileSizePos = SmallVector<std::tuple<AffineExpr, unsigned, unsigned>>{};
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1543:        return success();
        -: 1544:      }
    #####: 1545:      pos++;
        -: 1546:    }
        -: 1547:  }
    #####: 1548:  return success();
branch  0 never executed
branch  1 never executed
        -: 1549:}
        -: 1550:
        -: 1551:/// Check if `dim` dimension of memrefType with `layoutMap` becomes dynamic
        -: 1552:/// after normalization. Dimensions that include dynamic dimensions in the map
        -: 1553:/// output will become dynamic dimensions. Return true if `dim` is dynamic
        -: 1554:/// dimension.
        -: 1555:///
        -: 1556:/// Example:
        -: 1557:/// #map0 = affine_map<(d0, d1) -> (d0, d1 floordiv 32, d1 mod 32)>
        -: 1558:///
        -: 1559:/// If d1 is dynamic dimension, 2nd and 3rd dimension of map output are dynamic.
        -: 1560:/// memref<4x?xf32, #map0>  ==>  memref<4x?x?xf32>
        -: 1561:static bool
function _ZL28isNormalizedMemRefDynamicDimjN4mlir9AffineMapERN4llvm15SmallVectorImplIjEEPNS_11MLIRContextE called 0 returned 0% blocks executed 0%
    #####: 1562:isNormalizedMemRefDynamicDim(unsigned dim, AffineMap layoutMap,
        -: 1563:                             SmallVectorImpl<unsigned> &inMemrefTypeDynDims,
        -: 1564:                             MLIRContext *context) {
    #####: 1565:  bool isDynamicDim = false;
    #####: 1566:  AffineExpr expr = layoutMap.getResults()[dim];
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1567:  // Check if affine expr of the dimension includes dynamic dimension of input
        -: 1568:  // memrefType.
function _ZZL28isNormalizedMemRefDynamicDimjN4mlir9AffineMapERN4llvm15SmallVectorImplIjEEPNS_11MLIRContextEENKUlNS_10AffineExprEE_clES7_ called 0 returned 0% blocks executed 0%
    #####: 1569:  expr.walk([&inMemrefTypeDynDims, &isDynamicDim, &context](AffineExpr e) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1570:    if (e.isa<AffineDimExpr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1571:      for (unsigned dm : inMemrefTypeDynDims) {
branch  0 never executed
branch  1 never executed
    #####: 1572:        if (e == getAffineDimExpr(dm, context)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1573:          isDynamicDim = true;
        -: 1574:        }
        -: 1575:      }
        -: 1576:    }
    #####: 1577:  });
    #####: 1578:  return isDynamicDim;
        -: 1579:}
        -: 1580:
        -: 1581:/// Create affine expr to calculate dimension size for a tiled-layout map.
function _ZL31createDimSizeExprForTiledLayoutN4mlir10AffineExprE15TileExprPattern called 0 returned 0% blocks executed 0%
    #####: 1582:static AffineExpr createDimSizeExprForTiledLayout(AffineExpr oldMapOutput,
        -: 1583:                                                  TileExprPattern pat) {
        -: 1584:  // Create map output for the patterns.
        -: 1585:  // "floordiv <tile size>" ==> "ceildiv <tile size>"
        -: 1586:  // "mod <tile size>" ==> "<tile size>"
    #####: 1587:  AffineExpr newMapOutput;
    #####: 1588:  AffineBinaryOpExpr binaryExpr = nullptr;
call    0 never executed
    #####: 1589:  switch (pat) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1590:  case TileExprPattern::TileMod:
    #####: 1591:    binaryExpr = oldMapOutput.cast<AffineBinaryOpExpr>();
call    0 never executed
    #####: 1592:    newMapOutput = binaryExpr.getRHS();
call    0 never executed
    #####: 1593:    break;
    #####: 1594:  case TileExprPattern::TileFloorDiv:
    #####: 1595:    binaryExpr = oldMapOutput.cast<AffineBinaryOpExpr>();
call    0 never executed
    #####: 1596:    newMapOutput = getAffineBinaryOpExpr(
    #####: 1597:        AffineExprKind::CeilDiv, binaryExpr.getLHS(), binaryExpr.getRHS());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1598:    break;
    #####: 1599:  default:
    #####: 1600:    newMapOutput = oldMapOutput;
        -: 1601:  }
    #####: 1602:  return newMapOutput;
        -: 1603:}
        -: 1604:
        -: 1605:/// Create new maps to calculate each dimension size of `newMemRefType`, and
        -: 1606:/// create `newDynamicSizes` from them by using AffineApplyOp.
        -: 1607:///
        -: 1608:/// Steps for normalizing dynamic memrefs for a tiled layout map
        -: 1609:/// Example:
        -: 1610:///    #map0 = affine_map<(d0, d1) -> (d0, d1 floordiv 32, d1 mod 32)>
        -: 1611:///    %0 = dim %arg0, %c1 :memref<4x?xf32>
        -: 1612:///    %1 = alloc(%0) : memref<4x?xf32, #map0>
        -: 1613:///
        -: 1614:/// (Before this function)
        -: 1615:/// 1. Check if `map`(#map0) is a tiled layout using `getTileSizePos()`. Only
        -: 1616:/// single layout map is supported.
        -: 1617:///
        -: 1618:/// 2. Create normalized memrefType using `isNormalizedMemRefDynamicDim()`. It
        -: 1619:/// is memref<4x?x?xf32> in the above example.
        -: 1620:///
        -: 1621:/// (In this function)
        -: 1622:/// 3. Create new maps to calculate each dimension of the normalized memrefType
        -: 1623:/// using `createDimSizeExprForTiledLayout()`. In the tiled layout, the
        -: 1624:/// dimension size can be calculated by replacing "floordiv <tile size>" with
        -: 1625:/// "ceildiv <tile size>" and "mod <tile size>" with "<tile size>".
        -: 1626:/// - New map in the above example
        -: 1627:///   #map0 = affine_map<(d0, d1) -> (d0)>
        -: 1628:///   #map1 = affine_map<(d0, d1) -> (d1 ceildiv 32)>
        -: 1629:///   #map2 = affine_map<(d0, d1) -> (32)>
        -: 1630:///
        -: 1631:/// 4. Create AffineApplyOp to apply the new maps. The output of AffineApplyOp
        -: 1632:/// is used in dynamicSizes of new AllocOp.
        -: 1633:///   %0 = dim %arg0, %c1 : memref<4x?xf32>
        -: 1634:///   %c4 = arith.constant 4 : index
        -: 1635:///   %1 = affine.apply #map1(%c4, %0)
        -: 1636:///   %2 = affine.apply #map2(%c4, %0)
function _ZL21createNewDynamicSizesN4mlir10MemRefTypeES0_NS_9AffineMapEPNS_6memref7AllocOpENS_9OpBuilderERN4llvm15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1637:static void createNewDynamicSizes(MemRefType oldMemRefType,
        -: 1638:                                  MemRefType newMemRefType, AffineMap map,
        -: 1639:                                  memref::AllocOp *allocOp, OpBuilder b,
        -: 1640:                                  SmallVectorImpl<Value> &newDynamicSizes) {
        -: 1641:  // Create new input for AffineApplyOp.
    #####: 1642:  SmallVector<Value, 4> inAffineApply;
call    0 never executed
    #####: 1643:  ArrayRef<int64_t> oldMemRefShape = oldMemRefType.getShape();
call    0 never executed
    #####: 1644:  unsigned dynIdx = 0;
    #####: 1645:  for (unsigned d = 0; d < oldMemRefType.getRank(); ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1646:    if (oldMemRefShape[d] < 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1647:      // Use dynamicSizes of allocOp for dynamic dimension.
    #####: 1648:      inAffineApply.emplace_back(allocOp->getDynamicSizes()[dynIdx]);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1649:      dynIdx++;
        -: 1650:    } else {
        -: 1651:      // Create ConstantOp for static dimension.
    #####: 1652:      Attribute constantAttr =
    #####: 1653:          b.getIntegerAttr(b.getIndexType(), oldMemRefShape[d]);
call    0 never executed
call    1 never executed
    #####: 1654:      inAffineApply.emplace_back(
    #####: 1655:          b.create<arith::ConstantOp>(allocOp->getLoc(), constantAttr));
call    0 never executed
call    1 never executed
        -: 1656:    }
        -: 1657:  }
        -: 1658:
        -: 1659:  // Create new map to calculate each dimension size of new memref for each
        -: 1660:  // original map output. Only for dynamic dimesion of `newMemRefType`.
    #####: 1661:  unsigned newDimIdx = 0;
    #####: 1662:  ArrayRef<int64_t> newMemRefShape = newMemRefType.getShape();
call    0 never executed
    #####: 1663:  SmallVector<std::tuple<AffineExpr, unsigned, unsigned>> tileSizePos;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1664:  (void)getTileSizePos(map, tileSizePos);
call    0 never executed
    #####: 1665:  for (AffineExpr expr : map.getResults()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1666:    if (newMemRefShape[newDimIdx] < 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1667:      // Create new maps to calculate each dimension size of new memref.
    #####: 1668:      enum TileExprPattern pat = TileExprPattern::TileNone;
    #####: 1669:      for (auto pos : tileSizePos) {
branch  0 never executed
branch  1 never executed
    #####: 1670:        if (newDimIdx == std::get<1>(pos))
branch  0 never executed
branch  1 never executed
        -: 1671:          pat = TileExprPattern::TileFloorDiv;
    #####: 1672:        else if (newDimIdx == std::get<2>(pos))
branch  0 never executed
branch  1 never executed
    #####: 1673:          pat = TileExprPattern::TileMod;
        -: 1674:      }
    #####: 1675:      AffineExpr newMapOutput = createDimSizeExprForTiledLayout(expr, pat);
call    0 never executed
    #####: 1676:      AffineMap newMap =
    #####: 1677:          AffineMap::get(map.getNumInputs(), map.getNumSymbols(), newMapOutput);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1678:      Value affineApp =
    #####: 1679:          b.create<AffineApplyOp>(allocOp->getLoc(), newMap, inAffineApply);
call    0 never executed
call    1 never executed
    #####: 1680:      newDynamicSizes.emplace_back(affineApp);
call    0 never executed
        -: 1681:    }
    #####: 1682:    newDimIdx++;
        -: 1683:  }
    #####: 1684:}
        -: 1685:
        -: 1686:// TODO: Currently works for static memrefs with a single layout map.
function _ZN4mlir15normalizeMemRefEPNS_6memref7AllocOpE called 0 returned 0% blocks executed 0%
    #####: 1687:LogicalResult mlir::normalizeMemRef(memref::AllocOp *allocOp) {
    #####: 1688:  MemRefType memrefType = allocOp->getType();
call    0 never executed
    #####: 1689:  OpBuilder b(*allocOp);
call    0 never executed
        -: 1690:
        -: 1691:  // Fetch a new memref type after normalizing the old memref to have an
        -: 1692:  // identity map layout.
    #####: 1693:  MemRefType newMemRefType =
    #####: 1694:      normalizeMemRefType(memrefType, allocOp->getSymbolOperands().size());
call    0 never executed
call    1 never executed
    #####: 1695:  if (newMemRefType == memrefType)
branch  0 never executed
branch  1 never executed
        -: 1696:    // Either memrefType already had an identity map or the map couldn't be
        -: 1697:    // transformed to an identity map.
    #####: 1698:    return failure();
        -: 1699:
    #####: 1700:  Value oldMemRef = allocOp->getResult();
call    0 never executed
        -: 1701:
    #####: 1702:  SmallVector<Value, 4> symbolOperands(allocOp->getSymbolOperands());
call    0 never executed
call    1 never executed
    #####: 1703:  AffineMap layoutMap = memrefType.getLayout().getAffineMap();
call    0 never executed
call    1 never executed
    #####: 1704:  memref::AllocOp newAlloc;
call    0 never executed
        -: 1705:  // Check if `layoutMap` is a tiled layout. Only single layout map is
        -: 1706:  // supported for normalizing dynamic memrefs.
    #####: 1707:  SmallVector<std::tuple<AffineExpr, unsigned, unsigned>> tileSizePos;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1708:  (void)getTileSizePos(layoutMap, tileSizePos);
call    0 never executed
    #####: 1709:  if (newMemRefType.getNumDynamicDims() > 0 && !tileSizePos.empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1710:    MemRefType oldMemRefType = oldMemRef.getType().cast<MemRefType>();
call    0 never executed
    #####: 1711:    SmallVector<Value, 4> newDynamicSizes;
call    0 never executed
    #####: 1712:    createNewDynamicSizes(oldMemRefType, newMemRefType, layoutMap, allocOp, b,
call    0 never executed
        -: 1713:                          newDynamicSizes);
        -: 1714:    // Add the new dynamic sizes in new AllocOp.
    #####: 1715:    newAlloc =
        -: 1716:        b.create<memref::AllocOp>(allocOp->getLoc(), newMemRefType,
    #####: 1717:                                  newDynamicSizes, allocOp->getAlignmentAttr());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1718:  } else {
    #####: 1719:    newAlloc = b.create<memref::AllocOp>(allocOp->getLoc(), newMemRefType,
    #####: 1720:                                         allocOp->getAlignmentAttr());
call    0 never executed
call    1 never executed
        -: 1721:  }
        -: 1722:  // Replace all uses of the old memref.
    #####: 1723:  if (failed(replaceAllMemRefUsesWith(oldMemRef, /*newMemRef=*/newAlloc,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1724:                                      /*extraIndices=*/{},
        -: 1725:                                      /*indexRemap=*/layoutMap,
        -: 1726:                                      /*extraOperands=*/{},
        -: 1727:                                      /*symbolOperands=*/symbolOperands,
        -: 1728:                                      /*domOpFilter=*/nullptr,
        -: 1729:                                      /*postDomOpFilter=*/nullptr,
        -: 1730:                                      /*allowNonDereferencingOps=*/true))) {
        -: 1731:    // If it failed (due to escapes for example), bail out.
    #####: 1732:    newAlloc.erase();
call    0 never executed
    #####: 1733:    return failure();
        -: 1734:  }
        -: 1735:  // Replace any uses of the original alloc op and erase it. All remaining uses
        -: 1736:  // have to be dealloc's; RAMUW above would've failed otherwise.
    #####: 1737:  assert(llvm::all_of(oldMemRef.getUsers(), [&](Operation *op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 1738:    return hasSingleEffect<MemoryEffects::Free>(op, oldMemRef);
        -: 1739:  }));
    #####: 1740:  oldMemRef.replaceAllUsesWith(newAlloc);
call    0 never executed
    #####: 1741:  allocOp->erase();
call    0 never executed
    #####: 1742:  return success();
branch  0 never executed
branch  1 never executed
        -: 1743:}
        -: 1744:
function _ZN4mlir19normalizeMemRefTypeENS_10MemRefTypeEj called 0 returned 0% blocks executed 0%
    #####: 1745:MemRefType mlir::normalizeMemRefType(MemRefType memrefType,
        -: 1746:                                     unsigned numSymbolicOperands) {
    #####: 1747:  unsigned rank = memrefType.getRank();
call    0 never executed
    #####: 1748:  if (rank == 0)
branch  0 never executed
branch  1 never executed
    #####: 1749:    return memrefType;
        -: 1750:
    #####: 1751:  if (memrefType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1752:    // Either no maps is associated with this memref or this memref has
        -: 1753:    // a trivial (identity) map.
    #####: 1754:    return memrefType;
        -: 1755:  }
    #####: 1756:  AffineMap layoutMap = memrefType.getLayout().getAffineMap();
call    0 never executed
call    1 never executed
        -: 1757:
        -: 1758:  // We don't do any checks for one-to-one'ness; we assume that it is
        -: 1759:  // one-to-one.
        -: 1760:
        -: 1761:  // Normalize only static memrefs and dynamic memrefs with a tiled-layout map
        -: 1762:  // for now.
        -: 1763:  // TODO: Normalize the other types of dynamic memrefs.
    #####: 1764:  SmallVector<std::tuple<AffineExpr, unsigned, unsigned>> tileSizePos;
call    0 never executed
    #####: 1765:  (void)getTileSizePos(layoutMap, tileSizePos);
call    0 never executed
    #####: 1766:  if (memrefType.getNumDynamicDims() > 0 && tileSizePos.empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1767:    return memrefType;
        -: 1768:
        -: 1769:  // We have a single map that is not an identity map. Create a new memref
        -: 1770:  // with the right shape and an identity layout map.
    #####: 1771:  ArrayRef<int64_t> shape = memrefType.getShape();
call    0 never executed
        -: 1772:  // FlatAffineValueConstraint may later on use symbolicOperands.
    #####: 1773:  FlatAffineValueConstraints fac(rank, numSymbolicOperands);
call    0 never executed
    #####: 1774:  SmallVector<unsigned, 4> memrefTypeDynDims;
call    0 never executed
    #####: 1775:  for (unsigned d = 0; d < rank; ++d) {
branch  0 never executed
branch  1 never executed
        -: 1776:    // Use constraint system only in static dimensions.
    #####: 1777:    if (shape[d] > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1778:      fac.addBound(IntegerPolyhedron::LB, d, 0);
call    0 never executed
    #####: 1779:      fac.addBound(IntegerPolyhedron::UB, d, shape[d] - 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1780:    } else {
    #####: 1781:      memrefTypeDynDims.emplace_back(d);
call    0 never executed
        -: 1782:    }
        -: 1783:  }
        -: 1784:  // We compose this map with the original index (logical) space to derive
        -: 1785:  // the upper bounds for the new index space.
    #####: 1786:  unsigned newRank = layoutMap.getNumResults();
call    0 never executed
    #####: 1787:  if (failed(fac.composeMatchingMap(layoutMap)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1788:    return memrefType;
        -: 1789:  // TODO: Handle semi-affine maps.
        -: 1790:  // Project out the old data dimensions.
    #####: 1791:  fac.projectOut(newRank, fac.getNumVars() - newRank - fac.getNumLocalVars());
call    0 never executed
    #####: 1792:  SmallVector<int64_t, 4> newShape(newRank);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1793:  MLIRContext *context = memrefType.getContext();
    #####: 1794:  for (unsigned d = 0; d < newRank; ++d) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1795:    // Check if this dimension is dynamic.
    #####: 1796:    bool isDynDim =
    #####: 1797:        isNormalizedMemRefDynamicDim(d, layoutMap, memrefTypeDynDims, context);
call    0 never executed
    #####: 1798:    if (isDynDim) {
branch  0 never executed
branch  1 never executed
    #####: 1799:      newShape[d] = ShapedType::kDynamicSize;
branch  0 never executed
branch  1 never executed
        -: 1800:    } else {
        -: 1801:      // The lower bound for the shape is always zero.
    #####: 1802:      Optional<int64_t> ubConst =
    #####: 1803:          fac.getConstantBound64(IntegerPolyhedron::UB, d);
call    0 never executed
        -: 1804:      // For a static memref and an affine map with no symbols, this is
        -: 1805:      // always bounded. However, when we have symbols, we may not be able to
        -: 1806:      // obtain a constant upper bound. Also, mapping to a negative space is
        -: 1807:      // invalid for normalization.
    #####: 1808:      if (!ubConst.has_value() || ubConst.value() < 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1809:        LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -: 1810:                   << "can't normalize map due to unknown/invalid upper bound");
    #####: 1811:        return memrefType;
        -: 1812:      }
        -: 1813:      // If dimension of new memrefType is dynamic, the value is -1.
    #####: 1814:      newShape[d] = ubConst.value() + 1;
branch  0 never executed
branch  1 never executed
        -: 1815:    }
        -: 1816:  }
        -: 1817:
        -: 1818:  // Create the new memref type after trivializing the old layout map.
    #####: 1819:  MemRefType newMemRefType =
    #####: 1820:      MemRefType::Builder(memrefType)
call    0 never executed
call    1 never executed
    #####: 1821:          .setShape(newShape)
call    0 never executed
        -: 1822:          .setLayout(AffineMapAttr::get(
    #####: 1823:              AffineMap::getMultiDimIdentityMap(newRank, context)));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1824:  return newMemRefType;
        -: 1825:}
        -: 1826:
function _ZN4mlir9getDivModERNS_9OpBuilderENS_8LocationENS_5ValueES3_ called 0 returned 0% blocks executed 0%
    #####: 1827:DivModValue mlir::getDivMod(OpBuilder &b, Location loc, Value lhs, Value rhs) {
    #####: 1828:  DivModValue result;
    #####: 1829:  AffineExpr d0, d1;
    #####: 1830:  bindDims(b.getContext(), d0, d1);
call    0 never executed
    #####: 1831:  result.quotient =
    #####: 1832:      makeComposedAffineApply(b, loc, d0.floorDiv(d1), {lhs, rhs});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1833:  result.remainder = makeComposedAffineApply(b, loc, d0 % d1, {lhs, rhs});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1834:  return result;
        -: 1835:}
        -: 1836:
        -: 1837:/// Create IR that computes the product of all elements in the set.
function _ZL15getIndexProductRN4mlir9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####: 1838:static FailureOr<OpFoldResult> getIndexProduct(OpBuilder &b, Location loc,
        -: 1839:                                               ArrayRef<Value> set) {
    #####: 1840:  if (set.empty())
branch  0 never executed
branch  1 never executed
    #####: 1841:    return failure();
    #####: 1842:  OpFoldResult result = set[0];
call    0 never executed
    #####: 1843:  AffineExpr s0, s1;
    #####: 1844:  bindSymbols(b.getContext(), s0, s1);
call    0 never executed
    #####: 1845:  for (unsigned i = 1, e = set.size(); i < e; i++)
branch  0 never executed
branch  1 never executed
    #####: 1846:    result = makeComposedFoldedAffineApply(b, loc, s0 * s1, {result, set[i]});
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1847:  return result;
        -: 1848:}
        -: 1849:
function _ZN4mlir16delinearizeIndexERNS_9OpBuilderENS_8LocationENS_5ValueEN4llvm8ArrayRefIS3_EE called 0 returned 0% blocks executed 0%
    #####: 1850:FailureOr<SmallVector<Value>> mlir::delinearizeIndex(OpBuilder &b, Location loc,
        -: 1851:                                                     Value linearIndex,
        -: 1852:                                                     ArrayRef<Value> basis) {
    #####: 1853:  unsigned numDims = basis.size();
        -: 1854:
    #####: 1855:  SmallVector<Value> divisors;
    #####: 1856:  for (unsigned i = 1; i < numDims; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1857:    ArrayRef<Value> slice = basis.drop_front(i);
call    0 never executed
    #####: 1858:    FailureOr<OpFoldResult> prod = getIndexProduct(b, loc, slice);
call    0 never executed
    #####: 1859:    if (failed(prod))
branch  0 never executed
branch  1 never executed
    #####: 1860:      return failure();
    #####: 1861:    divisors.push_back(getValueOrCreateConstantIndexOp(b, loc, *prod));
call    0 never executed
call    1 never executed
        -: 1862:  }
        -: 1863:
    #####: 1864:  SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1865:  results.reserve(divisors.size() + 1);
branch  0 never executed
branch  1 never executed
    #####: 1866:  Value residual = linearIndex;
    #####: 1867:  for (Value divisor : divisors) {
branch  0 never executed
branch  1 never executed
    #####: 1868:    DivModValue divMod = getDivMod(b, loc, residual, divisor);
call    0 never executed
    #####: 1869:    results.push_back(divMod.quotient);
call    0 never executed
    #####: 1870:    residual = divMod.remainder;
        -: 1871:  }
    #####: 1872:  results.push_back(residual);
call    0 never executed
    #####: 1873:  return results;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1874:}
