        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Linalg/Utils/Utils.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Linalg/Utils/CMakeFiles/obj.MLIRLinalgUtils.dir/Utils.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Linalg/Utils/CMakeFiles/obj.MLIRLinalgUtils.dir/Utils.cpp.gcda
        -:    0:Runs:128628
        -:    1://===- Utils.cpp - Utilities to support the Linalg dialect ----------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements utilities for the Linalg dialect.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Linalg/Utils/Utils.h"
        -:   14:
        -:   15:#include "mlir/Analysis/SliceAnalysis.h"
        -:   16:#include "mlir/Dialect/Affine/Analysis/AffineStructures.h"
        -:   17:#include "mlir/Dialect/Affine/IR/AffineOps.h"
        -:   18:#include "mlir/Dialect/Affine/IR/AffineValueMap.h"
        -:   19:#include "mlir/Dialect/Affine/LoopUtils.h"
        -:   20:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   21:#include "mlir/Dialect/Arith/Utils/Utils.h"
        -:   22:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   23:#include "mlir/Dialect/Linalg/IR/Linalg.h"
        -:   24:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   25:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   26:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   27:#include "mlir/Dialect/Tensor/Utils/Utils.h"
        -:   28:#include "mlir/Dialect/Utils/StaticValueUtils.h"
        -:   29:#include "mlir/IR/AffineExpr.h"
        -:   30:#include "mlir/IR/AffineExprVisitor.h"
        -:   31:#include "mlir/IR/AffineMap.h"
        -:   32:#include "mlir/IR/Matchers.h"
        -:   33:#include "mlir/IR/OpImplementation.h"
        -:   34:#include "mlir/Pass/Pass.h"
        -:   35:#include "llvm/ADT/TypeSwitch.h"
        -:   36:#include "llvm/Support/Debug.h"
        -:   37:
        -:   38:#define DEBUG_TYPE "linalg-utils"
        -:   39:
        -:   40:using namespace mlir;
        -:   41:using namespace presburger;
        -:   42:using namespace mlir::linalg;
        -:   43:using namespace mlir::scf;
        -:   44:
function _ZL6isZeroN4mlir12OpFoldResultE called 0 returned 0% blocks executed 0%
    #####:   45:static bool isZero(OpFoldResult v) {
    #####:   46:  if (!v)
branch  0 never executed
branch  1 never executed
        -:   47:    return false;
    #####:   48:  if (auto attr = v.dyn_cast<Attribute>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   49:    IntegerAttr intAttr = attr.dyn_cast<IntegerAttr>();
call    0 never executed
    #####:   50:    return intAttr && intAttr.getValue().isZero();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   51:  }
    #####:   52:  if (auto cst = v.get<Value>().getDefiningOp<arith::ConstantIndexOp>())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   53:    return cst.value() == 0;
call    0 never executed
    #####:   54:  return false;
        -:   55:}
        -:   56:
        -:   57:namespace {
        -:   58:
        -:   59:// Helper visitor to determine whether an AffineExpr is tiled.
        -:   60:// This is achieved by traversing every AffineDimExpr with position `pos` and
        -:   61:// checking whether the corresponding `tileSizes[pos]` is non-zero.
        -:   62:// This also enforces only positive coefficients occur in multiplications.
        -:   63://
        -:   64:// Example:
        -:   65://   `d0 + 2 * d1 + d3` is tiled by [0, 0, 0, 2] but not by [0, 0, 2, 0]
        -:   66://
        -:   67:struct TileCheck : public AffineExprVisitor<TileCheck> {
    #####:   68:  TileCheck(ArrayRef<OpFoldResult> tileSizes) : tileSizes(tileSizes) {}
        -:   69:
function _ZN12_GLOBAL__N_19TileCheck12visitDimExprEN4mlir13AffineDimExprE called 0 returned 0% blocks executed 0%
    #####:   70:  void visitDimExpr(AffineDimExpr expr) {
    #####:   71:    isTiled |= !isZero(tileSizes[expr.getPosition()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:   72:  }
function _ZN12_GLOBAL__N_19TileCheck23visitAffineBinaryOpExprEN4mlir18AffineBinaryOpExprE called 0 returned 0% blocks executed 0%
    #####:   73:  void visitAffineBinaryOpExpr(AffineBinaryOpExpr expr) {
    #####:   74:    visit(expr.getLHS());
call    0 never executed
call    1 never executed
    #####:   75:    visit(expr.getRHS());
call    0 never executed
call    1 never executed
    #####:   76:    if (expr.getKind() == mlir::AffineExprKind::Mul)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:      assert(expr.getRHS().cast<AffineConstantExpr>().getValue() > 0 &&
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   78:             "nonpositive multiplying coefficient");
    #####:   79:  }
        -:   80:  bool isTiled = false;
        -:   81:  ArrayRef<OpFoldResult> tileSizes;
        -:   82:};
        -:   83:
        -:   84:} // namespace
        -:   85:
    #####:   86:static bool isTiled(AffineExpr expr, ArrayRef<OpFoldResult> tileSizes) {
    #####:   87:  if (!expr)
branch  0 never executed
branch  1 never executed
        -:   88:    return false;
    #####:   89:  TileCheck t(tileSizes);
    #####:   90:  t.visit(expr);
call    0 never executed
    #####:   91:  return t.isTiled;
        -:   92:}
        -:   93:
        -:   94:// Checks whether the `map  varies with respect to a non-zero `tileSize`.
function _ZL7isTiledN4mlir9AffineMapEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####:   95:static bool isTiled(AffineMap map, ArrayRef<OpFoldResult> tileSizes) {
    #####:   96:  if (!map)
branch  0 never executed
branch  1 never executed
        -:   97:    return false;
    #####:   98:  for (unsigned r = 0; r < map.getNumResults(); ++r)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:    if (isTiled(map.getResult(r), tileSizes))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  100:      return true;
        -:  101:  return false;
        -:  102:}
        -:  103:
        -:  104:Optional<RegionMatcher::BinaryOpKind>
function _ZN4mlir6linalg13RegionMatcher21matchAsScalarBinaryOpENS0_9GenericOpE called 0 returned 0% blocks executed 0%
    #####:  105:RegionMatcher::matchAsScalarBinaryOp(GenericOp op) {
    #####:  106:  auto &region = op.getRegion();
call    0 never executed
    #####:  107:  if (!llvm::hasSingleElement(region))
branch  0 never executed
branch  1 never executed
    #####:  108:    return llvm::None;
        -:  109:
    #####:  110:  Block &block = region.front();
call    0 never executed
    #####:  111:  if (block.getNumArguments() != 2 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  112:      !block.getArgument(0).getType().isSignlessIntOrFloat() ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  113:      !block.getArgument(1).getType().isSignlessIntOrFloat())
call    0 never executed
    #####:  114:    return llvm::None;
        -:  115:
    #####:  116:  auto &ops = block.getOperations();
branch  0 never executed
branch  1 never executed
    #####:  117:  if (!llvm::hasSingleElement(block.without_terminator()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  118:    return llvm::None;
        -:  119:
    #####:  120:  using mlir::matchers::m_Val;
    #####:  121:  auto a = m_Val(block.getArgument(0));
call    0 never executed
    #####:  122:  auto b = m_Val(block.getArgument(1));
        -:  123:
    #####:  124:  auto addPattern = m_Op<linalg::YieldOp>(m_Op<arith::AddIOp>(a, b));
call    0 never executed
    #####:  125:  if (addPattern.match(&ops.back()))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  126:    return BinaryOpKind::IAdd;
        -:  127:
    #####:  128:  return llvm::None;
        -:  129:}
        -:  130:
        -:  131:/// Explicit instantiation of loop nest generator for different loop types.
        -:  132:template struct mlir::linalg::GenerateLoopNest<scf::ForOp>;
        -:  133:template struct mlir::linalg::GenerateLoopNest<scf::ParallelOp>;
        -:  134:template struct mlir::linalg::GenerateLoopNest<AffineForOp>;
        -:  135:
        -:  136:/// Given a list of subview ranges, extract individual values for lower, upper
        -:  137:/// bounds and steps and put them into the corresponding vectors.
function _ZL12unpackRangesRN4mlir9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEERNS3_15SmallVectorImplINS_5ValueEEESA_SA_ called 0 returned 0% blocks executed 0%
    #####:  138:static void unpackRanges(OpBuilder &builder, Location loc,
        -:  139:                         ArrayRef<Range> ranges, SmallVectorImpl<Value> &lbs,
        -:  140:                         SmallVectorImpl<Value> &ubs,
        -:  141:                         SmallVectorImpl<Value> &steps) {
    #####:  142:  for (Range range : ranges) {
branch  0 never executed
branch  1 never executed
    #####:  143:    lbs.emplace_back(
    #####:  144:        getValueOrCreateConstantIndexOp(builder, loc, range.offset));
call    0 never executed
call    1 never executed
    #####:  145:    ubs.emplace_back(getValueOrCreateConstantIndexOp(builder, loc, range.size));
call    0 never executed
call    1 never executed
    #####:  146:    steps.emplace_back(
    #####:  147:        getValueOrCreateConstantIndexOp(builder, loc, range.stride));
call    0 never executed
call    1 never executed
        -:  148:  }
    #####:  149:}
        -:  150:
        -:  151:namespace mlir {
        -:  152:namespace linalg {
        -:  153:
function _ZN4mlir6linalg35allIndexingsAreProjectedPermutationENS0_8LinalgOpE called 0 returned 0% blocks executed 0%
    #####:  154:bool allIndexingsAreProjectedPermutation(LinalgOp op) {
    #####:  155:  return llvm::all_of(op.getIndexingMapsArray(), [](AffineMap m) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  156:    return m.isProjectedPermutation(/*allowZeroInResults=*/true);
    #####:  157:  });
        -:  158:}
        -:  159:
function _ZN4mlir6linalg26hasOnlyScalarElementwiseOpERNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  160:bool hasOnlyScalarElementwiseOp(Region &r) {
    #####:  161:  if (!llvm::hasSingleElement(r))
branch  0 never executed
branch  1 never executed
        -:  162:    return false;
    #####:  163:  for (Operation &op : r.front()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  164:    if (!(isa<arith::ConstantOp, func::ConstantOp, tensor::ExtractOp,
branch  0 never executed
branch  1 never executed
    #####:  165:              linalg::YieldOp, linalg::IndexOp>(op) ||
call    0 never executed
    #####:  166:          OpTrait::hasElementwiseMappableTraits(&op)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  167:        llvm::any_of(op.getResultTypes(),
call    0 never executed
        -:  168:                     [](Type type) { return !type.isIntOrIndexOrFloat(); }))
    #####:  169:      return false;
        -:  170:  }
        -:  171:  return true;
        -:  172:}
        -:  173:
function _ZN4mlir6linalg13isElementwiseENS0_8LinalgOpE called 0 returned 0% blocks executed 0%
    #####:  174:bool isElementwise(LinalgOp op) {
    #####:  175:  if (op.getNumLoops() != op.getNumParallelLoops())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  176:    return false;
        -:  177:
    #####:  178:  if (!allIndexingsAreProjectedPermutation(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  179:    return false;
        -:  180:
        -:  181:  // TODO: relax the restrictions on indexing map.
    #####:  182:  for (OpOperand *opOperand : op.getDpsInitOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  183:    if (!op.getMatchingIndexingMap(opOperand).isPermutation())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  184:      return false;
branch  0 never executed
branch  1 never executed
        -:  185:  }
    #####:  186:  return hasOnlyScalarElementwiseOp(op->getRegion(0));
call    0 never executed
call    1 never executed
        -:  187:}
        -:  188:
function _ZN4mlir6linalg18isParallelIteratorEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  189:bool isParallelIterator(StringRef iteratorType) {
    #####:  190:  return iteratorType == getParallelIteratorTypeName();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  191:}
        -:  192:
function _ZN4mlir6linalg19isReductionIteratorEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  193:bool isReductionIterator(StringRef iteratorType) {
    #####:  194:  return iteratorType == getReductionIteratorTypeName();
branch  0 never executed
branch  1 never executed
        -:  195:}
        -:  196:
        -:  197:/// Helper function that creates a memref::DimOp or tensor::DimOp depending on
        -:  198:/// the type of `source`.
function _ZN4mlir6linalg17createOrFoldDimOpERNS_9OpBuilderENS_8LocationENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####:  199:Value createOrFoldDimOp(OpBuilder &b, Location loc, Value source, int64_t dim) {
    #####:  200:  if (source.getType().isa<UnrankedMemRefType, MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  201:    return b.createOrFold<memref::DimOp>(loc, source, dim);
call    0 never executed
    #####:  202:  if (source.getType().isa<UnrankedTensorType, RankedTensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  203:    return b.createOrFold<tensor::DimOp>(loc, source, dim);
call    0 never executed
    #####:  204:  llvm_unreachable("Expected MemRefType or TensorType");
call    0 never executed
        -:  205:}
        -:  206:
function _ZN4mlir6linalg17createFoldedDimOpERNS_9OpBuilderENS_8LocationENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####:  207:OpFoldResult createFoldedDimOp(OpBuilder &b, Location loc, Value source,
        -:  208:                               int64_t dim) {
    #####:  209:  auto shapedType = source.getType().cast<ShapedType>();
call    0 never executed
    #####:  210:  if (!shapedType.hasRank() || shapedType.isDynamicDim(dim))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  211:    return createOrFoldDimOp(b, loc, source, dim);
call    0 never executed
call    1 never executed
    #####:  212:  return b.getIndexAttr(shapedType.getDimSize(dim));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  213:}
        -:  214:
        -:  215:/// Given an operation, retrieves the value of each dynamic dimension through
        -:  216:/// constructing the necessary DimOp operators.
function _ZN4mlir6linalg14getDynOperandsENS_8LocationENS_5ValueERNS_9OpBuilderE called 0 returned 0% blocks executed 0%
    #####:  217:SmallVector<Value, 4> getDynOperands(Location loc, Value val, OpBuilder &b) {
    #####:  218:  SmallVector<Value, 4> dynOperands;
call    0 never executed
    #####:  219:  auto shapedType = val.getType().cast<ShapedType>();
call    0 never executed
    #####:  220:  for (const auto &dim : llvm::enumerate(shapedType.getShape())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  221:    if (dim.value() == ShapedType::kDynamicSize)
branch  0 never executed
branch  1 never executed
    #####:  222:      dynOperands.push_back(createOrFoldDimOp(b, loc, val, dim.index()));
call    0 never executed
call    1 never executed
        -:  223:  }
    #####:  224:  return dynOperands;
        -:  225:}
        -:  226:
function _ZN4mlir6linalg21getUpperBoundForIndexENS_5ValueERNS_9AffineMapERN4llvm15SmallVectorImplIS1_EEb called 0 returned 0% blocks executed 0%
    #####:  227:void getUpperBoundForIndex(Value value, AffineMap &boundMap,
        -:  228:                           SmallVectorImpl<Value> &boundOperands,
        -:  229:                           bool constantRequired) {
        -:  230:  // Initialize `boundMap` and `boundOperands` to the identity returning
        -:  231:  // `value`. This combination is the default result of the method if no
        -:  232:  // simplification is possible.
    #####:  233:  assert(value.getType().isIndex() && "expect value to have index type");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  234:  boundMap = AffineMap::getMultiDimIdentityMap(1, value.getContext());
call    0 never executed
call    1 never executed
    #####:  235:  boundOperands.assign({value});
call    0 never executed
    #####:  236:  canonicalizeMapAndOperands(&boundMap, &boundOperands);
call    0 never executed
        -:  237:
        -:  238:  // Continue only if there is an affine index computation to simplify.
    #####:  239:  Operation *definingOp = value.getDefiningOp();
call    0 never executed
    #####:  240:  if (!definingOp || !isa<AffineApplyOp, AffineMinOp>(definingOp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  241:    return;
        -:  242:
        -:  243:  // Get the backward slice containing the affine index computation.
    #####:  244:  SetVector<Operation *> backwardSlice;
call    0 never executed
call    1 never executed
    #####:  245:  getBackwardSlice(definingOp, &backwardSlice, [](Operation *op) {
call    0 never executed
    #####:  246:    return isa<AffineApplyOp, AffineMinOp>(op);
call    0 never executed
        -:  247:  });
    #####:  248:  backwardSlice.insert(definingOp);
call    0 never executed
        -:  249:
        -:  250:  // Setup a system of affine constraints that describe the index computation.
    #####:  251:  FlatAffineValueConstraints constraints;
call    0 never executed
        -:  252:
        -:  253:  // Helper to find or create an identifier for the given value.
function _ZZN4mlir6linalg21getUpperBoundForIndexENS_5ValueERNS_9AffineMapERN4llvm15SmallVectorImplIS1_EEbENKUlS1_E0_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  254:  auto findOrCreateId = [&](Value value) {
    #####:  255:    if (!constraints.containsVar(value)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  256:      constraints.appendDimVar(value);
call    0 never executed
call    1 never executed
    #####:  257:      return true;
        -:  258:    }
    #####:  259:    unsigned pos;
    #####:  260:    constraints.findVar(value, &pos);
call    0 never executed
    #####:  261:    return pos < constraints.getNumDimVars();
    #####:  262:  };
        -:  263:  // Helper to get the position for the given value.
function _ZZN4mlir6linalg21getUpperBoundForIndexENS_5ValueERNS_9AffineMapERN4llvm15SmallVectorImplIS1_EEbENKUlS1_E1_clES1_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  264:  auto getPosition = [&](Value value) {
    #####:  265:    unsigned pos;
    #####:  266:    bool exists = constraints.findVar(value, &pos);
call    0 never executed
    #####:  267:    (void)exists;
    #####:  268:    assert(exists && "expect to find the identifier");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  269:    return pos;
    #####:  270:  };
        -:  271:
        -:  272:  // Add the affine operations in `backwardSlice` to the constraints.
    #####:  273:  for (Operation *op : llvm::reverse(backwardSlice)) {
branch  0 never executed
branch  1 never executed
        -:  274:    // Add an identifier for all op results and operands.
    #####:  275:    if (!(llvm::all_of(op->getResults(), findOrCreateId) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  276:          llvm::all_of(op->getOperands(), findOrCreateId)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  277:      return;
        -:  278:
        -:  279:    // Add AffineApplyOps to the constraints.
    #####:  280:    if (auto applyOp = dyn_cast<AffineApplyOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  281:      AffineMap map = constraints.computeAlignedMap(applyOp.getAffineMap(),
call    0 never executed
    #####:  282:                                                    applyOp.getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  283:      if (failed(constraints.addBound(IntegerPolyhedron::EQ,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  284:                                      getPosition(applyOp.getResult()), map)))
    #####:  285:        return;
    #####:  286:      continue;
        -:  287:    }
        -:  288:    // Add AffineMinOps to the constraints.
    #####:  289:    auto minOp = cast<AffineMinOp>(op);
call    0 never executed
    #####:  290:    AffineMap map = constraints.computeAlignedMap(minOp.getAffineMap(),
call    0 never executed
    #####:  291:                                                  minOp.getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  292:    if (failed(constraints.addBound(IntegerPolyhedron::UB,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  293:                                    getPosition(minOp.getResult()), map,
        -:  294:                                    /*isClosedBound=*/true)))
        -:  295:      return;
        -:  296:  }
        -:  297:
        -:  298:  // Obtain an upper bound for the affine index computation by projecting out
        -:  299:  // all temporary results and expressing the upper bound for `value` in terms
        -:  300:  // of the terminals of the index computation.
    #####:  301:  unsigned pos = getPosition(value);
call    0 never executed
    #####:  302:  if (constantRequired) {
branch  0 never executed
branch  1 never executed
    #####:  303:    auto ubConst = constraints.getConstantBound64(
    #####:  304:        FlatAffineValueConstraints::BoundType::UB, pos);
call    0 never executed
    #####:  305:    if (!ubConst)
branch  0 never executed
branch  1 never executed
        -:  306:      return;
        -:  307:
    #####:  308:    boundMap = AffineMap::getConstantMap(*ubConst, value.getContext());
call    0 never executed
call    1 never executed
    #####:  309:    return;
call    0 never executed
        -:  310:  }
        -:  311:
    #####:  312:  SmallVector<AffineMap> lowerBounds(1), upperBounds(1);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  313:  constraints.getSliceBounds(pos, 1, value.getContext(), &lowerBounds,
call    0 never executed
call    1 never executed
        -:  314:                             &upperBounds,
        -:  315:                             /*getClosedUB=*/true);
        -:  316:  // Verify `upperBounds[0]` is valid and has at least one result.
    #####:  317:  if (!upperBounds[0] || upperBounds[0].getNumResults() == 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  318:    return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  319:
        -:  320:  // Set `boundMap` and `boundOperands` to the computed upper bound.
    #####:  321:  boundMap = upperBounds[0];
branch  0 never executed
branch  1 never executed
    #####:  322:  constraints.getAllValues(&boundOperands);
call    0 never executed
    #####:  323:  erase_value(boundOperands, value);
call    0 never executed
    #####:  324:  canonicalizeMapAndOperands(&boundMap, &boundOperands);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  325:}
        -:  326:
function _ZN4mlir6linalg29getConstantUpperBoundForIndexENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  327:FailureOr<int64_t> getConstantUpperBoundForIndex(Value value) {
        -:  328:  // Compute an upper bound for `value`.
    #####:  329:  AffineMap boundMap;
    #####:  330:  SmallVector<Value> boundOperands;
call    0 never executed
    #####:  331:  getUpperBoundForIndex(value, boundMap, boundOperands,
call    0 never executed
        -:  332:                        /*constantRequired=*/true);
        -:  333:
        -:  334:  // Search the results of `boundMap` for constant upper bounds.
    #####:  335:  SmallVector<int64_t> constantBounds;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  336:  for (AffineExpr result : boundMap.getResults())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  337:    if (auto constExpr = result.dyn_cast<AffineConstantExpr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  338:      constantBounds.push_back(constExpr.getValue());
call    0 never executed
call    1 never executed
        -:  339:
        -:  340:  // Return the minimal upper bound or failure if none is found.
    #####:  341:  if (constantBounds.empty())
branch  0 never executed
branch  1 never executed
    #####:  342:    return failure();
    #####:  343:  return *std::min_element(constantBounds.begin(), constantBounds.end());
branch  0 never executed
branch  1 never executed
        -:  344:}
        -:  345:
function _ZN4mlir6linalg21makeComposedPadHighOpERNS_9OpBuilderENS_8LocationENS_16RankedTensorTypeENS_5ValueES5_b called 0 returned 0% blocks executed 0%
    #####:  346:Value makeComposedPadHighOp(OpBuilder &b, Location loc, RankedTensorType type,
        -:  347:                            Value source, Value pad, bool nofold) {
        -:  348:  // Exit if `source` is not defined by an ExtractSliceOp.
    #####:  349:  auto sliceOp = source.getDefiningOp<tensor::ExtractSliceOp>();
call    0 never executed
    #####:  350:  if (!sliceOp)
branch  0 never executed
branch  1 never executed
    #####:  351:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  352:
        -:  353:  // Search the `source` use-def chain for padded LinalgOps.
    #####:  354:  Value current = sliceOp.getSource();
call    0 never executed
    #####:  355:  while (current) {
branch  0 never executed
branch  1 never executed
    #####:  356:    auto linalgOp = current.getDefiningOp<LinalgOp>();
call    0 never executed
    #####:  357:    if (!linalgOp)
branch  0 never executed
branch  1 never executed
        -:  358:      break;
    #####:  359:    OpResult opResult = current.cast<OpResult>();
call    0 never executed
    #####:  360:    current = linalgOp.getDpsInitOperand(opResult.getResultNumber())->get();
call    0 never executed
call    1 never executed
        -:  361:  }
    #####:  362:  auto padOp = current ? current.getDefiningOp<tensor::PadOp>() : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  363:
        -:  364:  // Exit if the search fails to match a tensor::PadOp at the end of the matched
        -:  365:  // LinalgOp sequence.
    #####:  366:  if (!padOp)
branch  0 never executed
branch  1 never executed
    #####:  367:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  368:
        -:  369:  // Exit if the padded result type does not match.
    #####:  370:  if (sliceOp.getSource().getType() != type)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  371:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  372:
        -:  373:  // Exit if the LinalgOps are not high padded.
    #####:  374:  if (llvm::any_of(padOp.getMixedLowPad(), [](OpFoldResult ofr) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  375:        return getConstantIntValue(ofr) != static_cast<int64_t>(0);
        -:  376:      }))
    #####:  377:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  378:
        -:  379:  // Exit if `padOpSliceOp`, which defines the slice used by
        -:  380:  // `padOp`, is rank-reducing.
    #####:  381:  auto padOpSliceOp = padOp.getSource().getDefiningOp<tensor::ExtractSliceOp>();
call    0 never executed
call    1 never executed
    #####:  382:  if (!padOpSliceOp ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  383:      sliceOp.getMixedSizes().size() != padOpSliceOp.getMixedSizes().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  384:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  385:
        -:  386:  // Exit if the sizes of the dynamic sizes of `sliceOp` do not match the size
        -:  387:  // of the slice padded by `padOp`.
    #####:  388:  if (llvm::any_of(
call    0 never executed
    #####:  389:          llvm::zip(sliceOp.getMixedSizes(), padOpSliceOp.getMixedSizes()),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  390:          [](std::tuple<OpFoldResult, OpFoldResult> it) {
        -:  391:            return !isEqualConstantIntOrValue(std::get<0>(it), std::get<1>(it));
        -:  392:          }))
    #####:  393:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  394:
        -:  395:  // Exit if the padding values do not match.
    #####:  396:  Attribute padOpPadAttr, padAttr;
    #####:  397:  Value padOpPad = padOp.getConstantPaddingValue();
call    0 never executed
    #####:  398:  if (!padOpPad || !matchPattern(padOpPad, m_Constant(&padOpPadAttr)) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  399:      !matchPattern(pad, m_Constant(&padAttr)) || padOpPadAttr != padAttr)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  400:    return tensor::createPadHighOp(type, source, pad, nofold, loc, b);
call    0 never executed
        -:  401:
        -:  402:  // Return the padded result if the padding values and sizes match.
    #####:  403:  return sliceOp.getSource();
call    0 never executed
        -:  404:}
        -:  405:
function _ZN4mlir6linalg15makeTransposeOpERNS_9OpBuilderENS_8LocationENS_5ValueES4_N4llvm8ArrayRefIlEE called 0 returned 0% blocks executed 0%
    #####:  406:GenericOp makeTransposeOp(OpBuilder &b, Location loc, Value inputTensor,
        -:  407:                          Value outputTensor,
        -:  408:                          ArrayRef<int64_t> transposeVector) {
    #####:  409:  auto resultTensorType = outputTensor.getType().cast<RankedTensorType>();
call    0 never executed
    #####:  410:  Type elementType = resultTensorType.getElementType();
call    0 never executed
        -:  411:
    #####:  412:  assert(isPermutation(transposeVector) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  413:         "expect transpose vector to be a permutation");
    #####:  414:  assert(transposeVector.size() ==
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  415:             static_cast<size_t>(resultTensorType.getRank()) &&
        -:  416:         "expect transpose vector size to match result tensor rank");
        -:  417:
        -:  418:  // Compute the transpose and the indentity indexing maps.
    #####:  419:  SmallVector<AffineMap> indexingMaps = {
        -:  420:      inversePermutation(AffineMap::getPermutationMap(
    #####:  421:          SmallVector<unsigned>(transposeVector.begin(), transposeVector.end()),
call    0 never executed
call    1 never executed
    #####:  422:          b.getContext())),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  423:      AffineMap::getMultiDimIdentityMap(transposeVector.size(),
call    0 never executed
    #####:  424:                                        b.getContext())};
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  425:  SmallVector<llvm::StringRef> iteratorTypes(transposeVector.size(),
call    0 never executed
    #####:  426:                                             getParallelIteratorTypeName());
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  427:
        -:  428:  // Create a GenericOp to transpose `inputTensor` into `outputTensor`.
    #####:  429:  auto transposeOp = b.create<GenericOp>(
        -:  430:      loc, resultTensorType, inputTensor, outputTensor,
    #####:  431:      b.getAffineMapArrayAttr(indexingMaps), b.getStrArrayAttr(iteratorTypes),
call    0 never executed
    #####:  432:      /*doc=*/nullptr,
    #####:  433:      /*library_call=*/nullptr);
call    0 never executed
call    1 never executed
    #####:  434:  Region &body = transposeOp.getRegion();
call    0 never executed
    #####:  435:  body.push_back(new Block());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  436:  body.front().addArguments({elementType, elementType}, {loc, loc});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  437:
        -:  438:  // Create the body of the transpose operation.
    #####:  439:  OpBuilder::InsertionGuard g(b);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  440:  b.setInsertionPointToEnd(&body.front());
call    0 never executed
call    1 never executed
    #####:  441:  b.create<YieldOp>(loc, transposeOp.getRegion().front().getArgument(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  442:  return transposeOp;
branch  0 never executed
branch  1 never executed
        -:  443:}
        -:  444:
function _ZN4mlir6linalg16makeMemRefCopyOpERNS_9OpBuilderENS_8LocationENS_5ValueES4_ called 0 returned 0% blocks executed 0%
    #####:  445:GenericOp makeMemRefCopyOp(OpBuilder &b, Location loc, Value from, Value to) {
    #####:  446:  auto memrefTypeTo = to.getType().cast<MemRefType>();
call    0 never executed
        -:  447:#ifndef NDEBUG
    #####:  448:  auto memrefTypeFrom = from.getType().cast<MemRefType>();
call    0 never executed
    #####:  449:  assert(memrefTypeFrom.getRank() == memrefTypeTo.getRank() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  450:         "`from` and `to` memref must have the same rank");
        -:  451:#endif // NDEBUG
        -:  452:
    #####:  453:  AffineMap id =
    #####:  454:      AffineMap::getMultiDimIdentityMap(memrefTypeTo.getRank(), b.getContext());
call    0 never executed
call    1 never executed
    #####:  455:  SmallVector<StringRef> iteratorTypes(memrefTypeTo.getRank(),
call    0 never executed
    #####:  456:                                       getParallelIteratorTypeName());
call    0 never executed
call    1 never executed
    #####:  457:  return b.create<linalg::GenericOp>(
        -:  458:      loc,
        -:  459:      /*inputs=*/from,
        -:  460:      /*outputs=*/to,
    #####:  461:      /*indexingMaps=*/llvm::makeArrayRef({id, id}),
call    0 never executed
        -:  462:      /*iteratorTypes=*/iteratorTypes,
    #####:  463:      [](OpBuilder &b, Location loc, ValueRange args) {
    #####:  464:        b.create<linalg::YieldOp>(loc, args.front());
call    0 never executed
call    1 never executed
    #####:  465:      });
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  466:}
        -:  467:
        -:  468:/// Specialization to build an scf "for" nest.
        -:  469:template <>
function _ZN4mlir6linalg16GenerateLoopNestINS_3scf5ForOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS9_INS8_9StringRefEEENS8_12function_refIFSt6vectorINS_5ValueESaISH_EES6_S7_NS_10ValueRangeESK_EEENS9_INS0_8ProcInfoEEE called 0 returned 0% blocks executed 0%
    #####:  470:void GenerateLoopNest<scf::ForOp>::doit(
        -:  471:    OpBuilder &b, Location loc, ArrayRef<Range> loopRanges, LinalgOp linalgOp,
        -:  472:    ArrayRef<StringRef> iteratorTypes,
        -:  473:    function_ref<scf::ValueVector(OpBuilder &, Location, ValueRange,
        -:  474:                                  ValueRange)>
        -:  475:        bodyBuilderFn,
        -:  476:    ArrayRef<linalg::ProcInfo> procInfo) {
    #####:  477:  assert((procInfo.empty() || (procInfo.size() == loopRanges.size())) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  478:         "expected as many entries for proc info as number of loops, even if "
        -:  479:         "they are null entries");
    #####:  480:  SmallVector<Value> iterArgInitValues = linalgOp.hasBufferSemantics()
call    0 never executed
        -:  481:                                             ? SmallVector<Value>{}
    #####:  482:                                             : linalgOp.getDpsInitOperands();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  483:
    #####:  484:  SmallVector<Value, 4> lbs, ubs, steps;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  485:  unpackRanges(b, loc, loopRanges, lbs, ubs, steps);
call    0 never executed
    #####:  486:  LoopNest loopNest = mlir::scf::buildLoopNest(
        -:  487:      b, loc, lbs, ubs, steps, iterArgInitValues,
function _ZZN4mlir6linalg16GenerateLoopNestINS_3scf5ForOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS9_INS8_9StringRefEEENS8_12function_refIFSt6vectorINS_5ValueESaISH_EES6_S7_NS_10ValueRangeESK_EEENS9_INS0_8ProcInfoEEEENKUlS6_S7_SK_SK_E_clES6_S7_SK_SK_ called 0 returned 0% blocks executed 0%
    #####:  488:      [&](OpBuilder &b, Location loc, ValueRange ivs, ValueRange iterArgs) {
    #####:  489:        assert(iterArgs.size() == iterArgInitValues.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  490:               "expect the number of output tensors and iter args to match");
    #####:  491:        SmallVector<Value> operandValuesToUse = linalgOp->getOperands();
call    0 never executed
call    1 never executed
    #####:  492:        if (!iterArgs.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  493:          operandValuesToUse = linalgOp.getDpsInputOperands();
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  494:          operandValuesToUse.append(iterArgs.begin(), iterArgs.end());
call    0 never executed
        -:  495:        }
    #####:  496:        return bodyBuilderFn(b, loc, ivs, operandValuesToUse);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  497:      });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  498:
    #####:  499:  if (loopNest.loops.empty() || procInfo.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  500:    return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  501:
        -:  502:  // Filter out scf.for loops that were created out of parallel dimensions.
    #####:  503:  for (const auto &loop : llvm::enumerate(loopNest.loops)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  504:    if (procInfo[loop.index()].distributionMethod ==
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  505:        DistributionMethod::Cyclic) {
    #####:  506:      mapLoopToProcessorIds(loop.value(), procInfo[loop.index()].procId,
    #####:  507:                            procInfo[loop.index()].nprocs);
call    0 never executed
        -:  508:    }
        -:  509:  }
        -:  510:}
        -:  511:
        -:  512:/// Specialization to build affine "for" nest.
        -:  513:template <>
function _ZN4mlir6linalg16GenerateLoopNestINS_11AffineForOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS8_INS7_9StringRefEEENS7_12function_refIFSt6vectorINS_5ValueESaISG_EES5_S6_NS_10ValueRangeESJ_EEENS8_INS0_8ProcInfoEEE called 0 returned 0% blocks executed 0%
    #####:  514:void GenerateLoopNest<AffineForOp>::doit(
        -:  515:    OpBuilder &b, Location loc, ArrayRef<Range> loopRanges, LinalgOp linalgOp,
        -:  516:    ArrayRef<StringRef> iteratorTypes,
        -:  517:    function_ref<scf::ValueVector(OpBuilder &, Location, ValueRange,
        -:  518:                                  ValueRange)>
        -:  519:        bodyBuilderFn,
        -:  520:    ArrayRef<linalg::ProcInfo> /*procInfo*/) {
    #####:  521:  SmallVector<Value> iterArgInitValues = linalgOp.hasBufferSemantics()
call    0 never executed
        -:  522:                                             ? SmallVector<Value>{}
    #####:  523:                                             : linalgOp.getDpsInitOperands();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  524:  assert(iterArgInitValues.empty() && "unexpected AffineForOp init values");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  525:  SmallVector<Value, 4> lbs, ubs, steps;
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  526:  unpackRanges(b, loc, loopRanges, lbs, ubs, steps);
call    0 never executed
        -:  527:
        -:  528:  // Affine loops require constant steps.
    #####:  529:  SmallVector<int64_t, 4> constantSteps;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  530:  constantSteps.reserve(steps.size());
branch  0 never executed
branch  1 never executed
    #####:  531:  for (Value v : steps) {
branch  0 never executed
branch  1 never executed
    #####:  532:    auto op = v.getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
    #####:  533:    assert(op && "Affine loops require constant steps");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  534:    constantSteps.push_back(op.value());
call    0 never executed
call    1 never executed
        -:  535:  }
        -:  536:
    #####:  537:  mlir::buildAffineLoopNest(b, loc, lbs, ubs, constantSteps,
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
function _ZZN4mlir6linalg16GenerateLoopNestINS_11AffineForOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS8_INS7_9StringRefEEENS7_12function_refIFSt6vectorINS_5ValueESaISG_EES5_S6_NS_10ValueRangeESJ_EEENS8_INS0_8ProcInfoEEEENKUlS5_S6_SJ_E_clES5_S6_SJ_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  538:                            [&](OpBuilder &b, Location loc, ValueRange ivs) {
    #####:  539:                              bodyBuilderFn(b, loc, ivs,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  540:                                            linalgOp->getOperands());
call    0 never executed
    #####:  541:                            });
    #####:  542:}
        -:  543:
        -:  544:/// Update the `lb`, `ub` and `step` to get per processor `lb`, `ub` and `step`.
function _ZN4mlir6linalg33updateBoundsForCyclicDistributionERNS_9OpBuilderENS_8LocationENS_5ValueES4_RS4_S5_S5_ called 0 returned 0% blocks executed 0%
    #####:  545:void updateBoundsForCyclicDistribution(OpBuilder &b, Location loc, Value procId,
        -:  546:                                       Value nprocs, Value &lb, Value &ub,
        -:  547:                                       Value &step) {
    #####:  548:  AffineExpr d0, d1;
    #####:  549:  bindDims(b.getContext(), d0, d1);
call    0 never executed
    #####:  550:  AffineExpr s0 = getAffineSymbolExpr(0, b.getContext());
call    0 never executed
    #####:  551:  lb = makeComposedAffineApply(b, loc, d0 + d1 * s0, {lb, procId, step});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  552:  step = makeComposedAffineApply(b, loc, d0 * s0, {nprocs, step});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  553:}
        -:  554:
        -:  555:/// Generates a loop nest consisting of scf.parallel and scf.for, depending
        -:  556:/// on the `iteratorTypes.` Consecutive parallel loops create a single
        -:  557:/// scf.parallel operation; each sequential loop creates a new scf.for
        -:  558:/// operation. The body of the innermost loop is populated by
        -:  559:/// `bodyBuilderFn` that accepts a range of induction variables for all
        -:  560:/// loops. `ivStorage` is used to store the partial list of induction
        -:  561:/// variables.
        -:  562:// TODO: this function can be made iterative instead. However, it
        -:  563:// will have at most as many recursive calls as nested loops, which rarely
        -:  564:// exceeds 10.
function _ZN4mlir6linalgL24generateParallelLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm8ArrayRefINS5_9StringRefEEENS6_INS0_8ProcInfoEEENS5_12function_refIFvS2_S3_S4_EEERNS5_15SmallVectorImplINS_5ValueEEE called 0 returned 0% blocks executed 0%
    #####:  565:static void generateParallelLoopNest(
        -:  566:    OpBuilder &b, Location loc, ValueRange lbs, ValueRange ubs,
        -:  567:    ValueRange steps, ArrayRef<StringRef> iteratorTypes,
        -:  568:    ArrayRef<linalg::ProcInfo> procInfo,
        -:  569:    function_ref<void(OpBuilder &, Location, ValueRange)> bodyBuilderFn,
        -:  570:    SmallVectorImpl<Value> &ivStorage) {
    #####:  571:  assert(lbs.size() == ubs.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  572:  assert(lbs.size() == steps.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  573:  assert(lbs.size() == iteratorTypes.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  574:  assert(procInfo.empty() || (lbs.size() == procInfo.size()));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  575:
        -:  576:  // If there are no (more) loops to be generated, generate the body and be
        -:  577:  // done with it.
    #####:  578:  if (iteratorTypes.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  579:    bodyBuilderFn(b, loc, ivStorage);
call    0 never executed
call    1 never executed
    #####:  580:    return;
        -:  581:  }
        -:  582:
        -:  583:  // If there are no outer parallel loops, generate one sequential loop and
        -:  584:  // recurse.
    #####:  585:  if (!isParallelIterator(iteratorTypes.front())) {
branch  0 never executed
branch  1 never executed
    #####:  586:    LoopNest singleLoop = buildLoopNest(
        -:  587:        b, loc, lbs.take_front(), ubs.take_front(), steps.take_front(),
function _ZZN4mlir6linalgL24generateParallelLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm8ArrayRefINS5_9StringRefEEENS6_INS0_8ProcInfoEEENS5_12function_refIFvS2_S3_S4_EEERNS5_15SmallVectorImplINS_5ValueEEEENKUlS2_S3_S4_E_clES2_S3_S4_ called 0 returned 0% blocks executed 0%
    #####:  588:        [&](OpBuilder &b, Location loc, ValueRange ivs) {
    #####:  589:          ivStorage.append(ivs.begin(), ivs.end());
call    0 never executed
    #####:  590:          generateParallelLoopNest(
call    0 never executed
    #####:  591:              b, loc, lbs.drop_front(), ubs.drop_front(), steps.drop_front(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  592:              iteratorTypes.drop_front(),
call    0 never executed
    #####:  593:              procInfo.empty() ? procInfo : procInfo.drop_front(),
call    0 never executed
    #####:  594:              bodyBuilderFn, ivStorage);
branch  0 never executed
branch  1 never executed
    #####:  595:        });
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  596:    return;
branch  0 never executed
branch  1 never executed
        -:  597:  }
        -:  598:
    #####:  599:  unsigned nLoops = iteratorTypes.size();
branch  0 never executed
branch  1 never executed
    #####:  600:  unsigned numProcessed = 0;
    #####:  601:  DistributionMethod distributionMethod = DistributionMethod::None;
    #####:  602:  if (procInfo.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  603:    numProcessed = nLoops - iteratorTypes.drop_while(isParallelIterator).size();
call    0 never executed
        -:  604:  } else {
    #####:  605:    distributionMethod = procInfo.front().distributionMethod;
call    0 never executed
    #####:  606:    numProcessed =
    #####:  607:        nLoops - procInfo
    #####:  608:                     .drop_while([&](linalg::ProcInfo p) {
        -:  609:                       return p.distributionMethod == distributionMethod;
    #####:  610:                     })
call    0 never executed
    #####:  611:                     .size();
        -:  612:  }
        -:  613:
    #####:  614:  auto remainderProcInfo =
    #####:  615:      procInfo.empty() ? procInfo : procInfo.drop_front(numProcessed);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  616:  switch (distributionMethod) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  617:  case DistributionMethod::None: {
        -:  618:    // Generate a single parallel loop-nest operation for all outermost
        -:  619:    // parallel loops and recurse.
    #####:  620:    b.create<scf::ParallelOp>(
    #####:  621:        loc, lbs.take_front(numProcessed), ubs.take_front(numProcessed),
call    0 never executed
call    1 never executed
    #####:  622:        steps.take_front(numProcessed),
function _ZZN4mlir6linalgL24generateParallelLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm8ArrayRefINS5_9StringRefEEENS6_INS0_8ProcInfoEEENS5_12function_refIFvS2_S3_S4_EEERNS5_15SmallVectorImplINS_5ValueEEEENKUlS2_S3_S4_E1_clES2_S3_S4_ called 0 returned 0% blocks executed 0%
    #####:  623:        [&](OpBuilder &nestedBuilder, Location nestedLoc, ValueRange localIvs) {
    #####:  624:          ivStorage.append(localIvs.begin(), localIvs.end());
call    0 never executed
    #####:  625:          generateParallelLoopNest(
call    0 never executed
    #####:  626:              nestedBuilder, nestedLoc, lbs.drop_front(numProcessed),
call    0 never executed
    #####:  627:              ubs.drop_front(numProcessed), steps.drop_front(numProcessed),
call    0 never executed
call    1 never executed
    #####:  628:              iteratorTypes.drop_front(numProcessed), remainderProcInfo,
    #####:  629:              bodyBuilderFn, ivStorage);
call    0 never executed
    #####:  630:        });
call    0 never executed
call    1 never executed
    #####:  631:    return;
        -:  632:  }
    #####:  633:  case DistributionMethod::Cyclic: {
        -:  634:    // Generate a single parallel loop-nest operation for all outermost
        -:  635:    // parallel loops and recurse.
    #####:  636:    b.create<scf::ParallelOp>(
    #####:  637:        loc, lbs.take_front(numProcessed), ubs.take_front(numProcessed),
call    0 never executed
call    1 never executed
    #####:  638:        steps.take_front(numProcessed),
function _ZZN4mlir6linalgL24generateParallelLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm8ArrayRefINS5_9StringRefEEENS6_INS0_8ProcInfoEEENS5_12function_refIFvS2_S3_S4_EEERNS5_15SmallVectorImplINS_5ValueEEEENKUlS2_S3_S4_E2_clES2_S3_S4_ called 0 returned 0% blocks executed 0%
    #####:  639:        [&](OpBuilder &nestedBuilder, Location nestedLoc, ValueRange localIvs) {
    #####:  640:          ivStorage.append(localIvs.begin(), localIvs.end());
call    0 never executed
    #####:  641:          generateParallelLoopNest(
call    0 never executed
    #####:  642:              nestedBuilder, nestedLoc, lbs.drop_front(numProcessed),
call    0 never executed
    #####:  643:              ubs.drop_front(numProcessed), steps.drop_front(numProcessed),
call    0 never executed
call    1 never executed
    #####:  644:              iteratorTypes.drop_front(numProcessed), remainderProcInfo,
    #####:  645:              bodyBuilderFn, ivStorage);
call    0 never executed
    #####:  646:        });
call    0 never executed
call    1 never executed
    #####:  647:    return;
        -:  648:  }
    #####:  649:  case DistributionMethod::CyclicNumProcsGeNumIters: {
        -:  650:    // Check (for the processed loops) that the iteration is in-bounds.
    #####:  651:    ArithBuilder ab(b, loc);
call    0 never executed
    #####:  652:    Value cond = ab.slt(lbs[0], ubs[0]);
call    0 never executed
call    1 never executed
    #####:  653:    for (unsigned i = 1; i < numProcessed; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  654:      cond = ab._and(cond, ab.slt(lbs[i], ubs[i]));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  655:    ivStorage.append(lbs.begin(), std::next(lbs.begin(), numProcessed));
branch  0 never executed
branch  1 never executed
call    2 never executed
function _ZZN4mlir6linalgL24generateParallelLoopNestERNS_9OpBuilderENS_8LocationENS_10ValueRangeES4_S4_N4llvm8ArrayRefINS5_9StringRefEEENS6_INS0_8ProcInfoEEENS5_12function_refIFvS2_S3_S4_EEERNS5_15SmallVectorImplINS_5ValueEEEENKUlS2_S3_E3_clES2_S3_ called 0 returned 0% blocks executed 0%
    #####:  656:    b.create<scf::IfOp>(loc, cond, [&](OpBuilder &b, Location loc) {
    #####:  657:      generateParallelLoopNest(b, loc, lbs.drop_front(numProcessed),
call    0 never executed
call    1 never executed
    #####:  658:                               ubs.drop_front(numProcessed),
call    0 never executed
    #####:  659:                               steps.drop_front(numProcessed),
call    0 never executed
    #####:  660:                               iteratorTypes.drop_front(numProcessed),
    #####:  661:                               remainderProcInfo, bodyBuilderFn, ivStorage);
call    0 never executed
    #####:  662:      b.create<scf::YieldOp>(loc, ValueRange{});
call    0 never executed
call    1 never executed
    #####:  663:    });
call    0 never executed
    #####:  664:    return;
        -:  665:  }
    #####:  666:  case DistributionMethod::CyclicNumProcsEqNumIters:
        -:  667:    // No check/loops needed here. Set the `%iv` to be the `%lb` and proceed
        -:  668:    // with inner loop generation.
    #####:  669:    ivStorage.append(lbs.begin(), std::next(lbs.begin(), numProcessed));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  670:    generateParallelLoopNest(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  671:        b, loc, lbs.drop_front(numProcessed), ubs.drop_front(numProcessed),
        -:  672:        steps.drop_front(numProcessed), iteratorTypes.drop_front(numProcessed),
        -:  673:        remainderProcInfo, bodyBuilderFn, ivStorage);
    #####:  674:    return;
call    0 never executed
        -:  675:  }
        -:  676:}
        -:  677:
        -:  678:/// Specialization for generating a mix of parallel and sequential scf loops.
        -:  679:template <>
function _ZN4mlir6linalg16GenerateLoopNestINS_3scf10ParallelOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS9_INS8_9StringRefEEENS8_12function_refIFSt6vectorINS_5ValueESaISH_EES6_S7_NS_10ValueRangeESK_EEENS9_INS0_8ProcInfoEEE called 0 returned 0% blocks executed 0%
    #####:  680:void GenerateLoopNest<scf::ParallelOp>::doit(
        -:  681:    OpBuilder &b, Location loc, ArrayRef<Range> loopRanges, LinalgOp linalgOp,
        -:  682:    ArrayRef<StringRef> iteratorTypes,
        -:  683:    function_ref<scf::ValueVector(OpBuilder &, Location, ValueRange,
        -:  684:                                  ValueRange)>
        -:  685:        bodyBuilderFn,
        -:  686:    ArrayRef<linalg::ProcInfo> procInfo) {
    #####:  687:  SmallVector<Value> iterArgInitValues = linalgOp.hasBufferSemantics()
call    0 never executed
        -:  688:                                             ? SmallVector<Value>{}
    #####:  689:                                             : linalgOp.getDpsInitOperands();
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  690:  assert(iterArgInitValues.empty() && "unexpected ParallelOp init values");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  691:  // This function may be passed more iterator types than ranges.
    #####:  692:  assert(iteratorTypes.size() >= loopRanges.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  693:         "expected iterator type for all ranges");
    #####:  694:  assert((procInfo.empty() || (procInfo.size() == loopRanges.size())) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  695:         "expected proc information for all loops when present");
    #####:  696:  iteratorTypes = iteratorTypes.take_front(loopRanges.size());
branch  0 never executed
branch  1 never executed
    #####:  697:  SmallVector<Value, 8> lbsStorage, ubsStorage, stepsStorage, ivs;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  698:  unsigned numLoops = iteratorTypes.size();
branch  0 never executed
branch  1 never executed
    #####:  699:  ivs.reserve(numLoops);
branch  0 never executed
branch  1 never executed
    #####:  700:  lbsStorage.reserve(numLoops);
branch  0 never executed
branch  1 never executed
    #####:  701:  ubsStorage.reserve(numLoops);
branch  0 never executed
branch  1 never executed
    #####:  702:  stepsStorage.reserve(numLoops);
branch  0 never executed
branch  1 never executed
        -:  703:
        -:  704:  // Get the loop lb, ub, and step.
    #####:  705:  unpackRanges(b, loc, loopRanges, lbsStorage, ubsStorage, stepsStorage);
call    0 never executed
        -:  706:
        -:  707:  // Modify the lb, ub, and step based on the distribution options.
    #####:  708:  for (const auto &it : llvm::enumerate(procInfo)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  709:    if (it.value().distributionMethod != linalg::DistributionMethod::None) {
branch  0 never executed
branch  1 never executed
    #####:  710:      updateBoundsForCyclicDistribution(
call    0 never executed
    #####:  711:          b, loc, it.value().procId, it.value().nprocs, lbsStorage[it.index()],
call    0 never executed
    #####:  712:          ubsStorage[it.index()], stepsStorage[it.index()]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  713:    }
        -:  714:  }
    #####:  715:  ValueRange lbs(lbsStorage), ubs(ubsStorage), steps(stepsStorage);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  716:  generateParallelLoopNest(
call    0 never executed
        -:  717:      b, loc, lbs, ubs, steps, iteratorTypes, procInfo,
function _ZZN4mlir6linalg16GenerateLoopNestINS_3scf10ParallelOpEE4doitERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_5RangeEEENS0_8LinalgOpENS9_INS8_9StringRefEEENS8_12function_refIFSt6vectorINS_5ValueESaISH_EES6_S7_NS_10ValueRangeESK_EEENS9_INS0_8ProcInfoEEEENKUlS6_S7_SK_E_clES6_S7_SK_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  718:      [&](OpBuilder &b, Location loc, ValueRange ivs) {
    #####:  719:        bodyBuilderFn(b, loc, ivs, linalgOp->getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  720:      },
        -:  721:      ivs);
        -:  722:
    #####:  723:  assert(ivs.size() == iteratorTypes.size() && "did not generate enough loops");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  724:}
        -:  725:
function _ZN4mlir6linalgL21materializeTiledShapeERNS_9OpBuilderENS_8LocationENS_5ValueERKNS0_15SliceParametersE called 0 returned 0% blocks executed 0%
    #####:  726:static Value materializeTiledShape(OpBuilder &builder, Location loc,
        -:  727:                                   Value valueToTile,
        -:  728:                                   const SliceParameters &sliceParams) {
    #####:  729:  auto shapedType = valueToTile.getType().dyn_cast<ShapedType>();
call    0 never executed
    #####:  730:  auto *sliceOp = TypeSwitch<ShapedType, Operation *>(shapedType)
call    0 never executed
    #####:  731:                      .Case([&](MemRefType) {
    #####:  732:                        return builder.create<memref::SubViewOp>(
    #####:  733:                            loc, valueToTile, sliceParams.offsets,
    #####:  734:                            sliceParams.sizes, sliceParams.strides);
call    0 never executed
    #####:  735:                      })
call    0 never executed
    #####:  736:                      .Case([&](RankedTensorType) {
    #####:  737:                        return builder.create<tensor::ExtractSliceOp>(
    #####:  738:                            loc, valueToTile, sliceParams.offsets,
    #####:  739:                            sliceParams.sizes, sliceParams.strides);
call    0 never executed
    #####:  740:                      })
call    0 never executed
function _ZZN4mlir6linalgL21materializeTiledShapeERNS_9OpBuilderENS_8LocationENS_5ValueERKNS0_15SliceParametersEENKUlNS_10ShapedTypeEE1_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  741:                      .Default([](ShapedType) -> Operation * {
branch  0 never executed
branch  1 never executed
    #####:  742:                        llvm_unreachable("Unexpected shaped type");
        -:  743:                      });
    #####:  744:  return sliceOp->getResult(0);
        -:  745:}
        -:  746:
function _ZN4mlir6linalg14makeTiledShapeERNS_9OpBuilderENS_8LocationENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEENS_9AffineMapES8_S8_S8_b called 0 returned 0% blocks executed 0%
    #####:  747:Value makeTiledShape(OpBuilder &builder, Location loc, Value valueToTile,
        -:  748:                     ArrayRef<OpFoldResult> tileSizes, AffineMap map,
        -:  749:                     ArrayRef<OpFoldResult> lbs, ArrayRef<OpFoldResult> ubs,
        -:  750:                     ArrayRef<OpFoldResult> subShapeSizes,
        -:  751:                     bool omitPartialTileCheck) {
    #####:  752:  SliceParameters sliceParams =
        -:  753:      computeSliceParameters(builder, loc, valueToTile, tileSizes, map, lbs,
    #####:  754:                             ubs, subShapeSizes, omitPartialTileCheck);
call    0 never executed
call    1 never executed
    #####:  755:  return materializeTiledShape(builder, loc, valueToTile, sliceParams);
call    0 never executed
        -:  756:}
        -:  757:
        -:  758:SliceParameters
function _ZN4mlir6linalg22computeSliceParametersERNS_9OpBuilderENS_8LocationENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEENS_9AffineMapES8_S8_S8_b called 0 returned 0% blocks executed 0%
    #####:  759:computeSliceParameters(OpBuilder &builder, Location loc, Value valueToTile,
        -:  760:                       ArrayRef<OpFoldResult> tileSizes, AffineMap map,
        -:  761:                       ArrayRef<OpFoldResult> lbs, ArrayRef<OpFoldResult> ubs,
        -:  762:                       ArrayRef<OpFoldResult> subShapeSizes,
        -:  763:                       bool omitPartialTileCheck) {
    #####:  764:  auto shapedType = valueToTile.getType().dyn_cast<ShapedType>();
call    0 never executed
    #####:  765:  assert(shapedType && "only shaped types can be tiled");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  766:  ArrayRef<int64_t> shape = shapedType.getShape();
call    0 never executed
    #####:  767:  int64_t rank = shapedType.getRank();
call    0 never executed
        -:  768:
        -:  769:  // Compute offsets/sizes/strides for the tile.
    #####:  770:  SliceParameters sliceParams;
branch  0 never executed
branch  1 never executed
    #####:  771:  sliceParams.offsets.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  772:  sliceParams.sizes.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  773:  sliceParams.strides.reserve(rank);
branch  0 never executed
branch  1 never executed
    #####:  774:  for (unsigned r = 0; r < rank; ++r) {
branch  0 never executed
branch  1 never executed
    #####:  775:    LLVM_DEBUG(llvm::dbgs() << "computeSliceParameters: for dim#" << r);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  776:    if (!isTiled(map.getSubMap({r}), tileSizes)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  777:      sliceParams.offsets.push_back(builder.getIndexAttr(0));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  778:      OpFoldResult dim = createFoldedDimOp(builder, loc, valueToTile, r);
call    0 never executed
    #####:  779:      sliceParams.sizes.push_back(dim);
call    0 never executed
    #####:  780:      sliceParams.strides.push_back(builder.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  781:      LLVM_DEBUG(llvm::dbgs() << ": not tiled: use size: " << dim << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:  782:      continue;
        -:  783:    }
    #####:  784:    LLVM_DEBUG(llvm::dbgs() << ": tiled: figure out subsize...\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  785:
        -:  786:    // Tiling creates a new slice at the proper index, the slice step is 1
        -:  787:    // (i.e. the op does not subsample, stepping occurs in the loop).
    #####:  788:    auto m = map.getSubMap({r});
call    0 never executed
    #####:  789:    LLVM_DEBUG(llvm::dbgs() << "computeSliceParameters: submap: " << m << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:  790:    IRRewriter rewriter(builder);
call    0 never executed
    #####:  791:    OpFoldResult offset = makeComposedFoldedAffineApply(rewriter, loc, m, lbs);
call    0 never executed
    #####:  792:    sliceParams.offsets.push_back(offset);
call    0 never executed
    #####:  793:    OpFoldResult closedIntSize =
    #####:  794:        makeComposedFoldedAffineApply(rewriter, loc, m, subShapeSizes);
call    0 never executed
        -:  795:    // Resulting size needs to be made half open interval again.
    #####:  796:    AffineExpr s0 = getAffineSymbolExpr(0, builder.getContext());
call    0 never executed
    #####:  797:    OpFoldResult size =
call    0 never executed
    #####:  798:        makeComposedFoldedAffineApply(rewriter, loc, s0 + 1, closedIntSize);
call    0 never executed
call    1 never executed
    #####:  799:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  800:               << "computeSliceParameters: raw size: " << size << "\n");
    #####:  801:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  802:               << "computeSliceParameters: new offset: " << offset << "\n");
    #####:  803:    sliceParams.strides.push_back(builder.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  804:
    #####:  805:    if (omitPartialTileCheck) {
branch  0 never executed
branch  1 never executed
        -:  806:      // We statically know that the partial/boundary tile condition is
        -:  807:      // unnecessary.
    #####:  808:      LLVM_DEBUG(llvm::dbgs() << "makeTiledShape: new size: " << size << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:  809:      sliceParams.sizes.push_back(size);
call    0 never executed
    #####:  810:      continue;
call    0 never executed
        -:  811:    }
        -:  812:
        -:  813:    // The size of the subview / extract_slice should be trimmed to avoid
        -:  814:    // out-of-bounds accesses, unless:
        -:  815:    // a. We statically know the subshape size divides the shape size evenly.
        -:  816:    // b. The subshape size is 1. According to the way the loops are set up,
        -:  817:    //    tensors with "0" dimensions would never be constructed.
    #####:  818:    int64_t shapeSize = shape[r];
branch  0 never executed
branch  1 never executed
    #####:  819:    Optional<int64_t> sizeCst = getConstantIntValue(size);
call    0 never executed
    #####:  820:    auto hasTileSizeOne = sizeCst && *sizeCst == 1;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  821:    auto dividesEvenly = sizeCst && !ShapedType::isDynamic(shapeSize) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  822:                         ((shapeSize % *sizeCst) == 0);
branch  0 never executed
branch  1 never executed
    #####:  823:    if (!hasTileSizeOne && !dividesEvenly) {
branch  0 never executed
branch  1 never executed
    #####:  824:      LLVM_DEBUG(llvm::dbgs() << "makeTiledShape: shapeSize=" << shapeSize
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
        -:  825:                              << ", size: " << size
        -:  826:                              << ": make sure in bound with affine.min\n");
        -:  827:
    #####:  828:      AffineExpr dim0, dim1, dim2;
    #####:  829:      bindDims(builder.getContext(), dim0, dim1, dim2);
call    0 never executed
        -:  830:
        -:  831:      // Get the dimension size for this dimension. We need to first calculate
        -:  832:      // the max index and then plus one. This is important because for
        -:  833:      // convolution ops, we have its input window dimension's affine map of the
        -:  834:      // form `(d0 * s0 + d1)`, where `d0`/`d1 is an output/filter window
        -:  835:      // dimension and `s0` is stride. Directly use the dimension size of
        -:  836:      // output/filer window dimensions will cause incorrect calculation.
    #####:  837:      AffineMap minusOneMap =
    #####:  838:          AffineMap::inferFromExprList({ArrayRef<AffineExpr>{dim0 - 1}})
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  839:              .front();
branch  0 never executed
branch  1 never executed
    #####:  840:      AffineMap plusOneMap =
    #####:  841:          AffineMap::inferFromExprList({ArrayRef<AffineExpr>{dim0 + 1}})
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  842:              .front();
branch  0 never executed
branch  1 never executed
    #####:  843:      SmallVector<OpFoldResult> maxIndices =
function _ZZN4mlir6linalg22computeSliceParametersERNS_9OpBuilderENS_8LocationENS_5ValueEN4llvm8ArrayRefINS_12OpFoldResultEEENS_9AffineMapES8_S8_S8_bENKUlS7_E_clES7_ called 0 returned 0% blocks executed 0%
    #####:  844:          llvm::to_vector(llvm::map_range(ubs, [&](OpFoldResult ub) {
    #####:  845:            return makeComposedFoldedAffineApply(rewriter, loc, minusOneMap,
    #####:  846:                                                 {ub});
call    0 never executed
    #####:  847:          }));
call    0 never executed
    #####:  848:      OpFoldResult maxIndex =
call    0 never executed
    #####:  849:          makeComposedFoldedAffineApply(rewriter, loc, m, maxIndices);
call    0 never executed
    #####:  850:      OpFoldResult d =
    #####:  851:          makeComposedFoldedAffineApply(rewriter, loc, plusOneMap, {maxIndex});
call    0 never executed
        -:  852:
        -:  853:      // Compute min(dim - offset, size) to avoid out-of-bounds accesses.
    #####:  854:      AffineMap minMap = AffineMap::inferFromExprList(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  855:                             {ArrayRef<AffineExpr>{dim1 - dim2, dim0}})
call    0 never executed
    #####:  856:                             .front();
branch  0 never executed
branch  1 never executed
    #####:  857:      size =
    #####:  858:          makeComposedFoldedAffineMin(rewriter, loc, minMap, {size, d, offset});
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  859:    }
    #####:  860:    LLVM_DEBUG(llvm::dbgs() << "makeTiledShape: new size: " << size << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:  861:    sliceParams.sizes.push_back(size);
call    0 never executed
call    1 never executed
        -:  862:  }
    #####:  863:  return sliceParams;
        -:  864:}
        -:  865:
function _ZN4mlir6linalg18computeTileOffsetsERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_12OpFoldResultEEES7_ called 0 returned 0% blocks executed 0%
    #####:  866:SmallVector<OpFoldResult> computeTileOffsets(OpBuilder &b, Location loc,
        -:  867:                                             ArrayRef<OpFoldResult> ivs,
        -:  868:                                             ArrayRef<OpFoldResult> tileSizes) {
    #####:  869:  SmallVector<OpFoldResult> offsets;
    #####:  870:  for (unsigned idx = 0, idxIvs = 0, e = tileSizes.size(); idx < e; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  871:    LLVM_DEBUG(llvm::dbgs() << "makeTiledShapes: for loop#" << idx << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
    #####:  872:    bool isTiled = !isZero(tileSizes[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  873:    offsets.push_back(isTiled ? ivs[idxIvs++] : b.getIndexAttr(0));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  874:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  875:               << "computeTileOffsets: " << offsets.back() << "\n");
        -:  876:  }
    #####:  877:  return offsets;
        -:  878:}
        -:  879:
function _ZN4mlir6linalg16computeTileSizesERNS_9OpBuilderENS_8LocationEN4llvm8ArrayRefINS_12OpFoldResultEEES7_ called 0 returned 0% blocks executed 0%
    #####:  880:SmallVector<OpFoldResult> computeTileSizes(OpBuilder &b, Location loc,
        -:  881:                                           ArrayRef<OpFoldResult> tileSizes,
        -:  882:                                           ArrayRef<OpFoldResult> sizeBounds) {
    #####:  883:  SmallVector<OpFoldResult> sizes;
    #####:  884:  for (unsigned idx = 0, e = tileSizes.size(); idx < e; ++idx) {
branch  0 never executed
branch  1 never executed
    #####:  885:    bool isTiled = !isZero(tileSizes[idx]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    // Before composing, we need to make range a closed interval.
    #####:  887:    OpFoldResult size = isTiled ? tileSizes[idx] : sizeBounds[idx];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  888:    AffineExpr d0 = getAffineDimExpr(0, b.getContext());
call    0 never executed
    #####:  889:    IRRewriter rewriter(b);
call    0 never executed
    #####:  890:    sizes.push_back(makeComposedFoldedAffineApply(rewriter, loc, d0 - 1, size));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  891:    LLVM_DEBUG(llvm::dbgs() << "computeTileSizes: " << sizes.back() << "\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  892:  }
    #####:  893:  return sizes;
        -:  894:}
        -:  895:
function _ZN4mlir6linalg20getTensorOutputTypesENS0_8LinalgOpENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  896:SmallVector<Type> getTensorOutputTypes(LinalgOp op, ValueRange operands) {
    #####:  897:  if (op.hasBufferSemantics())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:    return {};
    #####:  899:  return llvm::to_vector(
function _ZZN4mlir6linalg20getTensorOutputTypesENS0_8LinalgOpENS_10ValueRangeEENKUlPNS_9OpOperandEE_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  900:      llvm::map_range(op.getDpsInitOperands(), [&](OpOperand *opOperand) {
call    0 never executed
    #####:  901:        return operands[opOperand->getOperandNumber()].getType();
call    0 never executed
call    1 never executed
    #####:  902:      }));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:}
        -:  904:
function _ZN4mlir6linalg16insertSlicesBackERNS_9OpBuilderENS_8LocationENS0_8LinalgOpENS_10ValueRangeES5_ called 0 returned 0% blocks executed 0%
    #####:  905:SmallVector<Value> insertSlicesBack(OpBuilder &builder, Location loc,
        -:  906:                                    LinalgOp op, ValueRange operands,
        -:  907:                                    ValueRange results) {
    #####:  908:  if (op.hasBufferSemantics())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  909:    return {};
    #####:  910:  SmallVector<Value> tensorResults;
branch  0 never executed
branch  1 never executed
    #####:  911:  tensorResults.reserve(results.size());
branch  0 never executed
branch  1 never executed
        -:  912:  // Insert a insert_slice for each output tensor.
    #####:  913:  unsigned resultIdx = 0;
    #####:  914:  for (OpOperand *opOperand : op.getDpsInitOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  915:    // TODO: use an interface/adaptor to avoid leaking position in
        -:  916:    // `tiledOperands`.
    #####:  917:    Value outputTensor = operands[opOperand->getOperandNumber()];
call    0 never executed
call    1 never executed
    #####:  918:    if (auto sliceOp = outputTensor.getDefiningOp<tensor::ExtractSliceOp>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  919:      Value inserted = builder.create<tensor::InsertSliceOp>(
    #####:  920:          loc, sliceOp.getSource().getType(), results[resultIdx],
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  921:          sliceOp.getSource(), sliceOp.getOffsets(), sliceOp.getSizes(),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  922:          sliceOp.getStrides(), sliceOp.getStaticOffsets(),
call    0 never executed
call    1 never executed
    #####:  923:          sliceOp.getStaticSizes(), sliceOp.getStaticStrides());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  924:      tensorResults.push_back(inserted);
call    0 never executed
        -:  925:    } else {
    #####:  926:      tensorResults.push_back(results[resultIdx]);
call    0 never executed
call    1 never executed
        -:  927:    }
    #####:  928:    ++resultIdx;
        -:  929:  }
    #####:  930:  return tensorResults;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  931:}
        -:  932:
        -:  933:SmallVector<Optional<SliceParameters>>
function _ZN4mlir6linalg25computeAllSliceParametersERNS_9OpBuilderENS_8LocationENS0_8LinalgOpENS_10ValueRangeEN4llvm8ArrayRefINS_12OpFoldResultEEES9_S9_b called 0 returned 0% blocks executed 0%
    #####:  934:computeAllSliceParameters(OpBuilder &builder, Location loc, LinalgOp linalgOp,
        -:  935:                          ValueRange valuesToTile, ArrayRef<OpFoldResult> ivs,
        -:  936:                          ArrayRef<OpFoldResult> tileSizes,
        -:  937:                          ArrayRef<OpFoldResult> sizeBounds,
        -:  938:                          bool omitPartialTileCheck) {
    #####:  939:  assert(ivs.size() == static_cast<size_t>(llvm::count_if(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  940:                           llvm::make_range(tileSizes.begin(), tileSizes.end()),
        -:  941:                           [](OpFoldResult v) { return !isZero(v); })) &&
        -:  942:         "expected as many ivs as non-zero sizes");
        -:  943:
        -:  944:  // Construct (potentially temporary) mins and maxes on which to apply maps
        -:  945:  // that define tile subshapes.
    #####:  946:  SmallVector<OpFoldResult> lbs =
    #####:  947:      computeTileOffsets(builder, loc, ivs, tileSizes);
call    0 never executed
    #####:  948:  SmallVector<OpFoldResult> subShapeSizes =
    #####:  949:      computeTileSizes(builder, loc, tileSizes, sizeBounds);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  950:
    #####:  951:  assert(static_cast<int64_t>(valuesToTile.size()) ==
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  952:             linalgOp->getNumOperands() &&
        -:  953:         "expected one value to tile for every operand");
    #####:  954:  SmallVector<Optional<SliceParameters>> allSliceParams;
branch  0 never executed
branch  1 never executed
    #####:  955:  allSliceParams.reserve(valuesToTile.size());
branch  0 never executed
branch  1 never executed
    #####:  956:  for (OpOperand &opOperand : linalgOp->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  957:    Value shapedOp = valuesToTile[opOperand.getOperandNumber()];
call    0 never executed
call    1 never executed
    #####:  958:    LLVM_DEBUG(llvm::dbgs() << "makeTiledShapes: for operand " << shapedOp);
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
    #####:  959:    AffineMap map = linalgOp.getMatchingIndexingMap(&opOperand);
call    0 never executed
        -:  960:    // Use `opOperand` as is if it is not tiled and not an output tensor. Having
        -:  961:    // an extract/insert slice pair for all output tensors simplifies follow up
        -:  962:    // transformations such as padding and bufferization since the
        -:  963:    // extract/insert slice pairs make the accessed iteration argument
        -:  964:    // subdomains explicit.
        -:  965:
    #####:  966:    Type operandType = opOperand.get().getType();
call    0 never executed
    #####:  967:    if (!isTiled(map, tileSizes) && !(operandType.isa<RankedTensorType>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  968:                                      linalgOp.isDpsInit(&opOperand))) {
branch  0 never executed
branch  1 never executed
    #####:  969:      allSliceParams.push_back(llvm::None);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  970:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
        -:  971:                 << ": not tiled: use shape: " << operandType << "\n");
    #####:  972:      continue;
        -:  973:    }
    #####:  974:    LLVM_DEBUG(llvm::dbgs() << ": tiled: figure out subshape...\n");
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  975:
    #####:  976:    allSliceParams.push_back(computeSliceParameters(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  977:        builder, loc, shapedOp, tileSizes, map, lbs, sizeBounds, subShapeSizes,
        -:  978:        omitPartialTileCheck));
        -:  979:  }
        -:  980:
    #####:  981:  return allSliceParams;
branch  0 never executed
branch  1 never executed
        -:  982:}
        -:  983:
function _ZN4mlir6linalg15makeTiledShapesERNS_9OpBuilderENS_8LocationENS0_8LinalgOpENS_10ValueRangeEN4llvm8ArrayRefINS_12OpFoldResultEEES9_S9_b called 0 returned 0% blocks executed 0%
    #####:  984:SmallVector<Value> makeTiledShapes(OpBuilder &builder, Location loc,
        -:  985:                                   LinalgOp linalgOp, ValueRange valuesToTile,
        -:  986:                                   ArrayRef<OpFoldResult> ivs,
        -:  987:                                   ArrayRef<OpFoldResult> tileSizes,
        -:  988:                                   ArrayRef<OpFoldResult> sizeBounds,
        -:  989:                                   bool omitPartialTileCheck) {
    #####:  990:  SmallVector<Optional<SliceParameters>> allSliceParameter =
        -:  991:      computeAllSliceParameters(builder, loc, linalgOp, valuesToTile, ivs,
    #####:  992:                                tileSizes, sizeBounds, omitPartialTileCheck);
call    0 never executed
    #####:  993:  SmallVector<Value> tiledShapes;
    #####:  994:  for (auto item : llvm::zip(valuesToTile, allSliceParameter)) {
branch  0 never executed
branch  1 never executed
    #####:  995:    Value valueToTile = std::get<0>(item);
branch  0 never executed
branch  1 never executed
    #####:  996:    Optional<SliceParameters> sliceParams = std::get<1>(item);
branch  0 never executed
branch  1 never executed
    #####:  997:    tiledShapes.push_back(
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  998:        sliceParams.has_value()
branch  0 never executed
branch  1 never executed
    #####:  999:            ? materializeTiledShape(builder, loc, valueToTile, *sliceParams)
call    0 never executed
        -: 1000:            : valueToTile);
        -: 1001:  }
    #####: 1002:  return tiledShapes;
call    0 never executed
        -: 1003:}
        -: 1004:
function _ZN4mlir6linalg13offsetIndicesERNS_9OpBuilderENS0_8LinalgOpEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1005:void offsetIndices(OpBuilder &b, LinalgOp linalgOp,
        -: 1006:                   ArrayRef<OpFoldResult> offsets) {
    #####: 1007:  IRRewriter rewriter(b);
call    0 never executed
    #####: 1008:  offsetIndices(rewriter, linalgOp, offsets);
call    0 never executed
call    1 never executed
    #####: 1009:}
        -: 1010:
function _ZN4mlir6linalg13offsetIndicesERNS_12RewriterBaseENS0_8LinalgOpEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1011:void offsetIndices(RewriterBase &b, LinalgOp linalgOp,
        -: 1012:                   ArrayRef<OpFoldResult> offsets) {
    #####: 1013:  if (!linalgOp.hasIndexSemantics())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1014:    return;
        -: 1015:
    #####: 1016:  for (IndexOp indexOp : linalgOp.getBlock()->getOps<IndexOp>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####: 1017:    if (indexOp.getDim() >= offsets.size() || !offsets[indexOp.getDim()])
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1018:      continue;
    #####: 1019:    OpBuilder::InsertionGuard guard(b);
call    0 never executed
    #####: 1020:    b.setInsertionPointAfter(indexOp);
call    0 never executed
    #####: 1021:    AffineExpr index, offset;
    #####: 1022:    bindDims(b.getContext(), index, offset);
call    0 never executed
    #####: 1023:    OpFoldResult applied = makeComposedFoldedAffineApply(
        -: 1024:        b, indexOp.getLoc(), index + offset,
    #####: 1025:        {getAsOpFoldResult(indexOp.getResult()), offsets[indexOp.getDim()]});
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####: 1026:    Value materialized =
    #####: 1027:        getValueOrCreateConstantIndexOp(b, indexOp.getLoc(), applied);
call    0 never executed
    #####: 1028:    b.replaceOpWithIf(indexOp, materialized, [&](OpOperand &use) {
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1029:      return use.getOwner() != materialized.getDefiningOp();
call    0 never executed
        -: 1030:    });
        -: 1031:  }
        -: 1032:}
        -: 1033:
        -: 1034:/// Get the reassociation maps to fold the result of a extract_slice (or source
        -: 1035:/// of a insert_slice) operation with given offsets, and sizes to its
        -: 1036:/// rank-reduced version. This is only done for the cases where the size is 1
        -: 1037:/// and offset is 0. Strictly speaking the offset 0 is not required in general,
        -: 1038:/// but non-zero offsets are not handled by SPIR-V backend at this point (and
        -: 1039:/// potentially cannot be handled).
        -: 1040:Optional<SmallVector<ReassociationIndices>>
function _ZN4mlir6linalg37getReassociationMapForFoldingUnitDimsEN4llvm8ArrayRefINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1041:getReassociationMapForFoldingUnitDims(ArrayRef<OpFoldResult> mixedSizes) {
    #####: 1042:  SmallVector<ReassociationIndices> reassociation;
    #####: 1043:  ReassociationIndices curr;
call    0 never executed
    #####: 1044:  for (const auto &it : llvm::enumerate(mixedSizes)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1045:    auto dim = it.index();
call    0 never executed
    #####: 1046:    auto size = it.value();
call    0 never executed
    #####: 1047:    curr.push_back(dim);
call    0 never executed
    #####: 1048:    auto attr = size.dyn_cast<Attribute>();
call    0 never executed
    #####: 1049:    if (attr && attr.cast<IntegerAttr>().getInt() == 1)
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1050:      continue;
    #####: 1051:    reassociation.emplace_back(ReassociationIndices{});
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1052:    std::swap(reassociation.back(), curr);
call    0 never executed
call    1 never executed
        -: 1053:  }
        -: 1054:  // When the reassociations are not empty, then fold the remaining
        -: 1055:  // unit-dimensions into the last dimension.  If the reassociations so far is
        -: 1056:  // empty, then leave it emtpy. This will fold everything to a rank-0 tensor.
    #####: 1057:  if (!curr.empty() && !reassociation.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1058:    reassociation.back().append(curr.begin(), curr.end());
call    0 never executed
call    1 never executed
    #####: 1059:  return reassociation;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1060:}
        -: 1061:
        -: 1062:} // namespace linalg
        -: 1063:} // namespace mlir
