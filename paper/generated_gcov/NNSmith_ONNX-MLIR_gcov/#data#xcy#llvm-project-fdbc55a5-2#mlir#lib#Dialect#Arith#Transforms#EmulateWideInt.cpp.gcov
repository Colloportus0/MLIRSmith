        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Arith/Transforms/EmulateWideInt.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/Transforms/CMakeFiles/obj.MLIRArithTransforms.dir/EmulateWideInt.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/Transforms/CMakeFiles/obj.MLIRArithTransforms.dir/EmulateWideInt.cpp.gcda
        -:    0:Runs:128624
        -:    1://===- EmulateWideInt.cpp - Wide integer operation emulation ----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Arith/Transforms/Passes.h"
        -:   10:
        -:   11:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   12:#include "mlir/Dialect/Arith/Transforms/WideIntEmulationConverter.h"
        -:   13:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   14:#include "mlir/Dialect/Func/Transforms/FuncConversions.h"
        -:   15:#include "mlir/Dialect/Vector/IR/VectorOps.h"
        -:   16:#include "mlir/Transforms/DialectConversion.h"
        -:   17:#include "llvm/Support/FormatVariadic.h"
        -:   18:#include "llvm/Support/MathExtras.h"
        -:   19:#include <cassert>
        -:   20:
        -:   21:namespace mlir::arith {
        -:   22:#define GEN_PASS_DEF_ARITHEMULATEWIDEINT
        -:   23:#include "mlir/Dialect/Arith/Transforms/Passes.h.inc"
        -:   24:} // namespace mlir::arith
        -:   25:
        -:   26:using namespace mlir;
        -:   27:
        -:   28://===----------------------------------------------------------------------===//
        -:   29:// Common Helper Functions
        -:   30://===----------------------------------------------------------------------===//
        -:   31:
        -:   32:/// Returns N bottom and N top bits from `value`, where N = `newBitWidth`.
        -:   33:/// Treats `value` as a 2*N bits-wide integer.
        -:   34:/// The bottom bits are returned in the first pair element, while the top bits
        -:   35:/// in the second one.
function _ZL9getHalvesRKN4llvm5APIntEj called 0 returned 0% blocks executed 0%
    #####:   36:static std::pair<APInt, APInt> getHalves(const APInt &value,
        -:   37:                                         unsigned newBitWidth) {
    #####:   38:  APInt low = value.extractBits(newBitWidth, 0);
call    0 never executed
    #####:   39:  APInt high = value.extractBits(newBitWidth, newBitWidth);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   40:  return {std::move(low), std::move(high)};
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   41:}
        -:   42:
        -:   43:/// Returns the type with the last (innermost) dimention reduced to x1.
        -:   44:/// Scalarizes 1D vector inputs to match how we extract/insert vector values,
        -:   45:/// e.g.:
        -:   46:///   - vector<3x2xi16> --> vector<3x1xi16>
        -:   47:///   - vector<2xi16>   --> i16
function _ZL18reduceInnermostDimN4mlir10VectorTypeE called 0 returned 0% blocks executed 0%
    #####:   48:static Type reduceInnermostDim(VectorType type) {
    #####:   49:  if (type.getShape().size() == 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   50:    return type.getElementType();
call    0 never executed
        -:   51:
    #####:   52:  auto newShape = to_vector(type.getShape());
call    0 never executed
call    1 never executed
    #####:   53:  newShape.back() = 1;
call    0 never executed
    #####:   54:  return VectorType::get(newShape, type.getElementType());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   55:}
        -:   56:
        -:   57:/// Returns a constant of integer of vector type filled with (repeated) `value`.
function _ZL27createScalarOrSplatConstantRN4mlir25ConversionPatternRewriterENS_8LocationENS_4TypeERKN4llvm5APIntE called 0 returned 0% blocks executed 0%
    #####:   58:static Value createScalarOrSplatConstant(ConversionPatternRewriter &rewriter,
        -:   59:                                         Location loc, Type type,
        -:   60:                                         const APInt &value) {
    #####:   61:  Attribute attr;
    #####:   62:  if (auto intTy = type.dyn_cast<IntegerType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   63:    attr = rewriter.getIntegerAttr(type, value);
call    0 never executed
        -:   64:  } else {
    #####:   65:    auto vecTy = type.cast<VectorType>();
call    0 never executed
    #####:   66:    attr = SplatElementsAttr::get(vecTy, value);
call    0 never executed
call    1 never executed
        -:   67:  }
        -:   68:
    #####:   69:  return rewriter.create<arith::ConstantOp>(loc, attr);
call    0 never executed
        -:   70:}
        -:   71:
        -:   72:/// Returns a constant of integer of vector type filled with (repeated) `value`.
function _ZL27createScalarOrSplatConstantRN4mlir25ConversionPatternRewriterENS_8LocationENS_4TypeEl called 0 returned 0% blocks executed 0%
    #####:   73:static Value createScalarOrSplatConstant(ConversionPatternRewriter &rewriter,
        -:   74:                                         Location loc, Type type,
        -:   75:                                         int64_t value) {
    #####:   76:  unsigned elementBitWidth = 0;
    #####:   77:  if (auto intTy = type.dyn_cast<IntegerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    elementBitWidth = intTy.getWidth();
call    0 never executed
        -:   79:  else
    #####:   80:    elementBitWidth = type.cast<VectorType>().getElementTypeBitWidth();
call    0 never executed
call    1 never executed
        -:   81:
    #####:   82:  return createScalarOrSplatConstant(rewriter, loc, type,
    #####:   83:                                     APInt(elementBitWidth, value));
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:   84:}
        -:   85:
        -:   86:/// Extracts the `input` vector slice with elements at the last dimension offset
        -:   87:/// by `lastOffset`. Returns a value of vector type with the last dimension
        -:   88:/// reduced to x1 or fully scalarized, e.g.:
        -:   89:///   - vector<3x2xi16> --> vector<3x1xi16>
        -:   90:///   - vector<2xi16>   --> i16
function _ZL19extractLastDimSliceRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueEl called 0 returned 0% blocks executed 0%
    #####:   91:static Value extractLastDimSlice(ConversionPatternRewriter &rewriter,
        -:   92:                                 Location loc, Value input,
        -:   93:                                 int64_t lastOffset) {
    #####:   94:  ArrayRef<int64_t> shape = input.getType().cast<VectorType>().getShape();
call    0 never executed
call    1 never executed
    #####:   95:  assert(lastOffset < shape.back() && "Offset out of bounds");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   96:
        -:   97:  // Scalarize the result in case of 1D vectors.
    #####:   98:  if (shape.size() == 1)
branch  0 never executed
branch  1 never executed
    #####:   99:    return rewriter.create<vector::ExtractOp>(loc, input, lastOffset);
call    0 never executed
        -:  100:
    #####:  101:  SmallVector<int64_t> offsets(shape.size(), 0);
call    0 never executed
    #####:  102:  offsets.back() = lastOffset;
call    0 never executed
    #####:  103:  auto sizes = llvm::to_vector(shape);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  104:  sizes.back() = 1;
call    0 never executed
    #####:  105:  SmallVector<int64_t> strides(shape.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  106:
    #####:  107:  return rewriter.create<vector::ExtractStridedSliceOp>(loc, input, offsets,
branch  0 never executed
branch  1 never executed
    #####:  108:                                                        sizes, strides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  109:}
        -:  110:
        -:  111:/// Extracts two vector slices from the `input` whose type is `vector<...x2T>`,
        -:  112:/// with the first element at offset 0 and the second element at offset 1.
        -:  113:static std::pair<Value, Value>
function _ZL20extractLastDimHalvesRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  114:extractLastDimHalves(ConversionPatternRewriter &rewriter, Location loc,
        -:  115:                     Value input) {
    #####:  116:  return {extractLastDimSlice(rewriter, loc, input, 0),
call    0 never executed
    #####:  117:          extractLastDimSlice(rewriter, loc, input, 1)};
call    0 never executed
        -:  118:}
        -:  119:
        -:  120:// Performs a vector shape cast to drop the trailing x1 dimension. If the
        -:  121:// `input` is a scalar, this is a noop.
function _ZL17dropTrailingX1DimRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  122:static Value dropTrailingX1Dim(ConversionPatternRewriter &rewriter,
        -:  123:                               Location loc, Value input) {
    #####:  124:  auto vecTy = input.getType().dyn_cast<VectorType>();
call    0 never executed
    #####:  125:  if (!vecTy)
branch  0 never executed
branch  1 never executed
    #####:  126:    return input;
        -:  127:
        -:  128:  // Shape cast to drop the last x1 dimention.
    #####:  129:  ArrayRef<int64_t> shape = vecTy.getShape();
call    0 never executed
    #####:  130:  assert(shape.size() >= 2 && "Expected vector with at list two dims");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  131:  assert(shape.back() == 1 && "Expected the last vector dim to be x1");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  132:
    #####:  133:  auto newVecTy = VectorType::get(shape.drop_back(), vecTy.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  134:  return rewriter.create<vector::ShapeCastOp>(loc, newVecTy, input);
call    0 never executed
        -:  135:}
        -:  136:
        -:  137:/// Performs a vector shape cast to append an x1 dimension. If the
        -:  138:/// `input` is a scalar, this is a noop.
function _ZL11appendX1DimRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  139:static Value appendX1Dim(ConversionPatternRewriter &rewriter, Location loc,
        -:  140:                         Value input) {
    #####:  141:  auto vecTy = input.getType().dyn_cast<VectorType>();
call    0 never executed
    #####:  142:  if (!vecTy)
branch  0 never executed
branch  1 never executed
    #####:  143:    return input;
        -:  144:
        -:  145:  // Add a trailing x1 dim.
    #####:  146:  auto newShape = llvm::to_vector(vecTy.getShape());
call    0 never executed
call    1 never executed
    #####:  147:  newShape.push_back(1);
call    0 never executed
    #####:  148:  auto newTy = VectorType::get(newShape, vecTy.getElementType());
call    0 never executed
call    1 never executed
    #####:  149:  return rewriter.create<vector::ShapeCastOp>(loc, newTy, input);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  150:}
        -:  151:
        -:  152:/// Inserts the `source` vector slice into the `dest` vector at offset
        -:  153:/// `lastOffset` in the last dimension. `source` can be a scalar when `dest` is
        -:  154:/// a 1D vector.
function _ZL18insertLastDimSliceRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueES3_l called 0 returned 0% blocks executed 0%
    #####:  155:static Value insertLastDimSlice(ConversionPatternRewriter &rewriter,
        -:  156:                                Location loc, Value source, Value dest,
        -:  157:                                int64_t lastOffset) {
    #####:  158:  ArrayRef<int64_t> shape = dest.getType().cast<VectorType>().getShape();
call    0 never executed
call    1 never executed
    #####:  159:  assert(lastOffset < shape.back() && "Offset out of bounds");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  160:
        -:  161:  // Handle scalar source.
    #####:  162:  if (source.getType().isa<IntegerType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  163:    return rewriter.create<vector::InsertOp>(loc, source, dest, lastOffset);
call    0 never executed
        -:  164:
    #####:  165:  SmallVector<int64_t> offsets(shape.size(), 0);
call    0 never executed
    #####:  166:  offsets.back() = lastOffset;
call    0 never executed
    #####:  167:  SmallVector<int64_t> strides(shape.size(), 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  168:  return rewriter.create<vector::InsertStridedSliceOp>(loc, source, dest,
branch  0 never executed
branch  1 never executed
    #####:  169:                                                       offsets, strides);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  170:}
        -:  171:
        -:  172:/// Constructs a new vector of type `resultType` by creating a series of
        -:  173:/// insertions of `resultComponents`, each at the next offset of the last vector
        -:  174:/// dimension.
        -:  175:/// When all `resultComponents` are scalars, the result type is `vector<NxT>`;
        -:  176:/// when `resultComponents` are `vector<...x1xT>`s, the result type is
        -:  177:/// `vector<...xNxT>`, where `N` is the number of `resultComponenets`.
function _ZL21constructResultVectorRN4mlir25ConversionPatternRewriterENS_8LocationENS_10VectorTypeENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  178:static Value constructResultVector(ConversionPatternRewriter &rewriter,
        -:  179:                                   Location loc, VectorType resultType,
        -:  180:                                   ValueRange resultComponents) {
    #####:  181:  llvm::ArrayRef<int64_t> resultShape = resultType.getShape();
call    0 never executed
    #####:  182:  (void)resultShape;
    #####:  183:  assert(!resultShape.empty() && "Result expected to have dimentions");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  184:  assert(resultShape.back() == static_cast<int64_t>(resultComponents.size()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  185:         "Wrong number of result components");
        -:  186:
    #####:  187:  Value resultVec = createScalarOrSplatConstant(rewriter, loc, resultType, 0);
call    0 never executed
    #####:  188:  for (auto [i, component] : llvm::enumerate(resultComponents))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  189:    resultVec = insertLastDimSlice(rewriter, loc, component, resultVec, i);
call    0 never executed
        -:  190:
    #####:  191:  return resultVec;
        -:  192:}
        -:  193:
        -:  194:namespace {
        -:  195://===----------------------------------------------------------------------===//
        -:  196:// ConvertConstant
        -:  197://===----------------------------------------------------------------------===//
        -:  198:
        -:  199:struct ConvertConstant final : OpConversionPattern<arith::ConstantOp> {
        -:  200:  using OpConversionPattern::OpConversionPattern;
        -:  201:
        -:  202:  LogicalResult
function _ZNK12_GLOBAL__N_115ConvertConstant15matchAndRewriteEN4mlir5arith10ConstantOpENS2_17ConstantOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  203:  matchAndRewrite(arith::ConstantOp op, OpAdaptor,
        -:  204:                  ConversionPatternRewriter &rewriter) const override {
    #####:  205:    Type oldType = op.getType();
call    0 never executed
    #####:  206:    auto newType = getTypeConverter()->convertType(oldType).cast<VectorType>();
call    0 never executed
call    1 never executed
    #####:  207:    unsigned newBitWidth = newType.getElementTypeBitWidth();
call    0 never executed
    #####:  208:    Attribute oldValue = op.getValueAttr();
call    0 never executed
        -:  209:
    #####:  210:    if (auto intAttr = oldValue.dyn_cast<IntegerAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  211:      auto [low, high] = getHalves(intAttr.getValue(), newBitWidth);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  212:      auto newAttr = DenseElementsAttr::get(newType, {low, high});
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  213:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, newAttr);
call    0 never executed
    #####:  214:      return success();
call    0 never executed
        -:  215:    }
        -:  216:
    #####:  217:    if (auto splatAttr = oldValue.dyn_cast<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:      auto [low, high] =
call    0 never executed
    #####:  219:          getHalves(splatAttr.getSplatValue<APInt>(), newBitWidth);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
    #####:  220:      int64_t numSplatElems = splatAttr.getNumElements();
call    0 never executed
    #####:  221:      SmallVector<APInt> values;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  222:      values.reserve(numSplatElems * 2);
branch  0 never executed
branch  1 never executed
    #####:  223:      for (int64_t i = 0; i < numSplatElems; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  224:        values.push_back(low);
call    0 never executed
    #####:  225:        values.push_back(high);
call    0 never executed
        -:  226:      }
        -:  227:
    #####:  228:      auto attr = DenseElementsAttr::get(newType, values);
call    0 never executed
call    1 never executed
    #####:  229:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, attr);
call    0 never executed
    #####:  230:      return success();
call    0 never executed
        -:  231:    }
        -:  232:
    #####:  233:    if (auto elemsAttr = oldValue.dyn_cast<DenseElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  234:      int64_t numElems = elemsAttr.getNumElements();
call    0 never executed
    #####:  235:      SmallVector<APInt> values;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  236:      values.reserve(numElems * 2);
branch  0 never executed
branch  1 never executed
    #####:  237:      for (const APInt &origVal : elemsAttr.getValues<APInt>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  238:        auto [low, high] = getHalves(origVal, newBitWidth);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  239:        values.push_back(std::move(low));
call    0 never executed
    #####:  240:        values.push_back(std::move(high));
call    0 never executed
        -:  241:      }
        -:  242:
    #####:  243:      auto attr = DenseElementsAttr::get(newType, values);
call    0 never executed
call    1 never executed
    #####:  244:      rewriter.replaceOpWithNewOp<arith::ConstantOp>(op, attr);
call    0 never executed
    #####:  245:      return success();
call    0 never executed
        -:  246:    }
        -:  247:
    #####:  248:    return rewriter.notifyMatchFailure(op.getLoc(),
    #####:  249:                                       "unhandled constant attribute");
call    0 never executed
        -:  250:  }
        -:  251:};
        -:  252:
        -:  253://===----------------------------------------------------------------------===//
        -:  254:// ConvertAddI
        -:  255://===----------------------------------------------------------------------===//
        -:  256:
        -:  257:struct ConvertAddI final : OpConversionPattern<arith::AddIOp> {
        -:  258:  using OpConversionPattern::OpConversionPattern;
        -:  259:
        -:  260:  LogicalResult
function _ZNK12_GLOBAL__N_111ConvertAddI15matchAndRewriteEN4mlir5arith6AddIOpENS2_13AddIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  261:  matchAndRewrite(arith::AddIOp op, OpAdaptor adaptor,
        -:  262:                  ConversionPatternRewriter &rewriter) const override {
    #####:  263:    Location loc = op->getLoc();
call    0 never executed
    #####:  264:    auto newTy = getTypeConverter()
    #####:  265:                     ->convertType(op.getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  266:                     .dyn_cast_or_null<VectorType>();
    #####:  267:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  268:      return rewriter.notifyMatchFailure(
    #####:  269:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  270:
    #####:  271:    Type newElemTy = reduceInnermostDim(newTy);
call    0 never executed
        -:  272:
    #####:  273:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  274:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  275:    auto [rhsElem0, rhsElem1] =
call    0 never executed
    #####:  276:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  277:
    #####:  278:    auto lowSum = rewriter.create<arith::AddUICarryOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
    #####:  279:    Value carryVal =
    #####:  280:        rewriter.create<arith::ExtUIOp>(loc, newElemTy, lowSum.getCarry());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  281:
    #####:  282:    Value high0 = rewriter.create<arith::AddIOp>(loc, carryVal, lhsElem1);
call    0 never executed
call    1 never executed
    #####:  283:    Value high = rewriter.create<arith::AddIOp>(loc, high0, rhsElem1);
call    0 never executed
call    1 never executed
        -:  284:
    #####:  285:    Value resultVec =
    #####:  286:        constructResultVector(rewriter, loc, newTy, {lowSum.getSum(), high});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  287:    rewriter.replaceOp(op, resultVec);
call    0 never executed
call    1 never executed
    #####:  288:    return success();
        -:  289:  }
        -:  290:};
        -:  291:
        -:  292://===----------------------------------------------------------------------===//
        -:  293:// ConvertBitwiseBinary
        -:  294://===----------------------------------------------------------------------===//
        -:  295:
        -:  296:/// Conversion pattern template for bitwise binary ops, e.g., `arith.andi`.
        -:  297:template <typename BinaryOp>
        -:  298:struct ConvertBitwiseBinary final : OpConversionPattern<BinaryOp> {
        -:  299:  using OpConversionPattern<BinaryOp>::OpConversionPattern;
        -:  300:  using OpAdaptor = typename OpConversionPattern<BinaryOp>::OpAdaptor;
        -:  301:
        -:  302:  LogicalResult
    #####:  303:  matchAndRewrite(BinaryOp op, OpAdaptor adaptor,
        -:  304:                  ConversionPatternRewriter &rewriter) const override {
    #####:  305:    Location loc = op->getLoc();
    #####:  306:    auto newTy = this->getTypeConverter()
        -:  307:                     ->convertType(op.getType())
    #####:  308:                     .template dyn_cast_or_null<VectorType>();
    #####:  309:    if (!newTy)
        -:  310:      return rewriter.notifyMatchFailure(
    #####:  311:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
        -:  312:
    #####:  313:    auto [lhsElem0, lhsElem1] =
    #####:  314:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
    #####:  315:    auto [rhsElem0, rhsElem1] =
    #####:  316:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
        -:  317:
    #####:  318:    Value resElem0 = rewriter.create<BinaryOp>(loc, lhsElem0, rhsElem0);
    #####:  319:    Value resElem1 = rewriter.create<BinaryOp>(loc, lhsElem1, rhsElem1);
        -:  320:    Value resultVec =
    #####:  321:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
    #####:  322:    rewriter.replaceOp(op, resultVec);
    #####:  323:    return success();
        -:  324:  }
------------------
_ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith6AndIOpEE15matchAndRewriteES3_NS2_13AndIOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith6AndIOpEE15matchAndRewriteES3_NS2_13AndIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  303:  matchAndRewrite(BinaryOp op, OpAdaptor adaptor,
        -:  304:                  ConversionPatternRewriter &rewriter) const override {
    #####:  305:    Location loc = op->getLoc();
call    0 never executed
    #####:  306:    auto newTy = this->getTypeConverter()
        -:  307:                     ->convertType(op.getType())
    #####:  308:                     .template dyn_cast_or_null<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  309:    if (!newTy)
branch  0 never executed
branch  1 never executed
        -:  310:      return rewriter.notifyMatchFailure(
    #####:  311:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  312:
    #####:  313:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  314:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  315:    auto [rhsElem0, rhsElem1] =
call    0 never executed
    #####:  316:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  317:
    #####:  318:    Value resElem0 = rewriter.create<BinaryOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  319:    Value resElem1 = rewriter.create<BinaryOp>(loc, lhsElem1, rhsElem1);
call    0 never executed
call    1 never executed
        -:  320:    Value resultVec =
    #####:  321:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  322:    rewriter.replaceOp(op, resultVec);
call    0 never executed
    #####:  323:    return success();
        -:  324:  }
------------------
_ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith5OrIOpEE15matchAndRewriteES3_NS2_12OrIOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith5OrIOpEE15matchAndRewriteES3_NS2_12OrIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  303:  matchAndRewrite(BinaryOp op, OpAdaptor adaptor,
        -:  304:                  ConversionPatternRewriter &rewriter) const override {
    #####:  305:    Location loc = op->getLoc();
call    0 never executed
    #####:  306:    auto newTy = this->getTypeConverter()
        -:  307:                     ->convertType(op.getType())
    #####:  308:                     .template dyn_cast_or_null<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  309:    if (!newTy)
branch  0 never executed
branch  1 never executed
        -:  310:      return rewriter.notifyMatchFailure(
    #####:  311:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  312:
    #####:  313:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  314:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  315:    auto [rhsElem0, rhsElem1] =
call    0 never executed
    #####:  316:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  317:
    #####:  318:    Value resElem0 = rewriter.create<BinaryOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  319:    Value resElem1 = rewriter.create<BinaryOp>(loc, lhsElem1, rhsElem1);
call    0 never executed
call    1 never executed
        -:  320:    Value resultVec =
    #####:  321:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  322:    rewriter.replaceOp(op, resultVec);
call    0 never executed
    #####:  323:    return success();
        -:  324:  }
------------------
_ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith6XOrIOpEE15matchAndRewriteES3_NS2_13XOrIOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_120ConvertBitwiseBinaryIN4mlir5arith6XOrIOpEE15matchAndRewriteES3_NS2_13XOrIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  303:  matchAndRewrite(BinaryOp op, OpAdaptor adaptor,
        -:  304:                  ConversionPatternRewriter &rewriter) const override {
    #####:  305:    Location loc = op->getLoc();
call    0 never executed
    #####:  306:    auto newTy = this->getTypeConverter()
        -:  307:                     ->convertType(op.getType())
    #####:  308:                     .template dyn_cast_or_null<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  309:    if (!newTy)
branch  0 never executed
branch  1 never executed
        -:  310:      return rewriter.notifyMatchFailure(
    #####:  311:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  312:
    #####:  313:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  314:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  315:    auto [rhsElem0, rhsElem1] =
call    0 never executed
    #####:  316:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  317:
    #####:  318:    Value resElem0 = rewriter.create<BinaryOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  319:    Value resElem1 = rewriter.create<BinaryOp>(loc, lhsElem1, rhsElem1);
call    0 never executed
call    1 never executed
        -:  320:    Value resultVec =
    #####:  321:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  322:    rewriter.replaceOp(op, resultVec);
call    0 never executed
    #####:  323:    return success();
        -:  324:  }
------------------
        -:  325:};
        -:  326:
        -:  327://===----------------------------------------------------------------------===//
        -:  328:// ConvertMulI
        -:  329://===----------------------------------------------------------------------===//
        -:  330:
        -:  331:struct ConvertMulI final : OpConversionPattern<arith::MulIOp> {
        -:  332:  using OpConversionPattern::OpConversionPattern;
        -:  333:
        -:  334:  LogicalResult
function _ZNK12_GLOBAL__N_111ConvertMulI15matchAndRewriteEN4mlir5arith6MulIOpENS2_13MulIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  335:  matchAndRewrite(arith::MulIOp op, OpAdaptor adaptor,
        -:  336:                  ConversionPatternRewriter &rewriter) const override {
    #####:  337:    Location loc = op->getLoc();
call    0 never executed
    #####:  338:    auto newTy = getTypeConverter()
    #####:  339:                     ->convertType(op.getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  340:                     .dyn_cast_or_null<VectorType>();
    #####:  341:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  342:      return rewriter.notifyMatchFailure(
    #####:  343:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  344:
    #####:  345:    Type newElemTy = reduceInnermostDim(newTy);
call    0 never executed
    #####:  346:    unsigned newBitWidth = newTy.getElementTypeBitWidth();
call    0 never executed
    #####:  347:    unsigned digitBitWidth = newBitWidth / 2;
        -:  348:
    #####:  349:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  350:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  351:    auto [rhsElem0, rhsElem1] =
branch  0 never executed
branch  1 never executed
    #####:  352:        extractLastDimHalves(rewriter, loc, adaptor.getRhs());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  353:
        -:  354:    // Emulate multiplication by splitting each input element of type i2N into 4
        -:  355:    // digits of type iN and bit width i(N/2). This is so that the intermediate
        -:  356:    // multiplications and additions do not overflow. We extract these i(N/2)
        -:  357:    // digits from iN vector elements by masking (low digit) and shifting right
        -:  358:    // (high digit).
        -:  359:    //
        -:  360:    // The multiplication algorithm used is the standard (long) multiplication.
        -:  361:    // Multiplying two i2N integers produces (at most) a i4N result, but because
        -:  362:    // the calculation of top i2N is not necessary, we omit it.
        -:  363:    // In total, this implementations performs 10 intermediate multiplications
        -:  364:    // and 16 additions. The number of multiplications could be decreased by
        -:  365:    // switching to a more efficient algorithm like Karatsuba. This would,
        -:  366:    // however, require being able to perform (intermediate) wide additions and
        -:  367:    // subtractions, so it is not clear that such implementation would be more
        -:  368:    // efficient.
        -:  369:
    #####:  370:    APInt lowMaskVal(newBitWidth, 1);
branch  0 never executed
branch  1 never executed
    #####:  371:    lowMaskVal = lowMaskVal.shl(digitBitWidth) - 1;
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  372:    Value lowMask =
    #####:  373:        createScalarOrSplatConstant(rewriter, loc, newElemTy, lowMaskVal);
call    0 never executed
    #####:  374:    auto getLowDigit = [lowMask, newElemTy, loc, &rewriter](Value v) {
    #####:  375:      return rewriter.create<arith::AndIOp>(loc, newElemTy, v, lowMask);
    #####:  376:    };
        -:  377:
    #####:  378:    Value shiftVal =
    #####:  379:        createScalarOrSplatConstant(rewriter, loc, newElemTy, digitBitWidth);
call    0 never executed
    #####:  380:    auto getHighDigit = [shiftVal, loc, &rewriter](Value v) {
    #####:  381:      return rewriter.create<arith::ShRUIOp>(loc, v, shiftVal);
    #####:  382:    };
        -:  383:
    #####:  384:    Value zeroDigit = createScalarOrSplatConstant(rewriter, loc, newElemTy, 0);
call    0 never executed
    #####:  385:    std::array<Value, 4> resultDigits = {zeroDigit, zeroDigit, zeroDigit,
    #####:  386:                                         zeroDigit};
    #####:  387:    std::array<Value, 4> lhsDigits = {
call    0 never executed
    #####:  388:        getLowDigit(lhsElem0), getHighDigit(lhsElem0), getLowDigit(lhsElem1),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  389:        getHighDigit(lhsElem1)};
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  390:    std::array<Value, 4> rhsDigits = {
call    0 never executed
    #####:  391:        getLowDigit(rhsElem0), getHighDigit(rhsElem0), getLowDigit(rhsElem1),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  392:        getHighDigit(rhsElem1)};
call    0 never executed
call    1 never executed
call    2 never executed
        -:  393:
    #####:  394:    for (unsigned i = 0, e = lhsDigits.size(); i != e; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  395:      for (unsigned j = 0; i + j != e; ++j) {
branch  0 never executed
branch  1 never executed
    #####:  396:        Value mul =
    #####:  397:            rewriter.create<arith::MulIOp>(loc, lhsDigits[i], rhsDigits[j]);
call    0 never executed
call    1 never executed
    #####:  398:        Value current =
    #####:  399:            rewriter.createOrFold<arith::AddIOp>(loc, resultDigits[i + j], mul);
call    0 never executed
    #####:  400:        resultDigits[i + j] = getLowDigit(current);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  401:        if (i + j + 1 != e) {
branch  0 never executed
branch  1 never executed
    #####:  402:          Value carry = rewriter.createOrFold<arith::AddIOp>(
    #####:  403:              loc, resultDigits[i + j + 1], getHighDigit(current));
call    0 never executed
call    1 never executed
    #####:  404:          resultDigits[i + j + 1] = carry;
        -:  405:        }
        -:  406:      }
        -:  407:    }
        -:  408:
function _ZZNK12_GLOBAL__N_111ConvertMulI15matchAndRewriteEN4mlir5arith6MulIOpENS2_13MulIOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_5ValueES7_E1_clES7_S7_ called 0 returned 0% blocks executed 0%
    #####:  409:    auto combineDigits = [shiftVal, loc, &rewriter](Value low, Value high) {
    #####:  410:      Value highBits = rewriter.create<arith::ShLIOp>(loc, high, shiftVal);
call    0 never executed
call    1 never executed
    #####:  411:      return rewriter.create<arith::OrIOp>(loc, low, highBits);
call    0 never executed
    #####:  412:    };
    #####:  413:    Value resultElem0 = combineDigits(resultDigits[0], resultDigits[1]);
call    0 never executed
call    1 never executed
    #####:  414:    Value resultElem1 = combineDigits(resultDigits[2], resultDigits[3]);
call    0 never executed
call    1 never executed
    #####:  415:    Value resultVec =
    #####:  416:        constructResultVector(rewriter, loc, newTy, {resultElem0, resultElem1});
call    0 never executed
call    1 never executed
    #####:  417:    rewriter.replaceOp(op, resultVec);
call    0 never executed
call    1 never executed
    #####:  418:    return success();
branch  0 never executed
branch  1 never executed
        -:  419:  }
        -:  420:};
        -:  421:
        -:  422://===----------------------------------------------------------------------===//
        -:  423:// ConvertExtSI
        -:  424://===----------------------------------------------------------------------===//
        -:  425:
        -:  426:struct ConvertExtSI final : OpConversionPattern<arith::ExtSIOp> {
        -:  427:  using OpConversionPattern::OpConversionPattern;
        -:  428:
        -:  429:  LogicalResult
function _ZNK12_GLOBAL__N_112ConvertExtSI15matchAndRewriteEN4mlir5arith7ExtSIOpENS2_14ExtSIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  430:  matchAndRewrite(arith::ExtSIOp op, OpAdaptor adaptor,
        -:  431:                  ConversionPatternRewriter &rewriter) const override {
    #####:  432:    Location loc = op->getLoc();
call    0 never executed
    #####:  433:    auto newTy = getTypeConverter()
    #####:  434:                     ->convertType(op.getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  435:                     .dyn_cast_or_null<VectorType>();
    #####:  436:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  437:      return rewriter.notifyMatchFailure(
    #####:  438:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  439:
    #####:  440:    Type newResultComponentTy = reduceInnermostDim(newTy);
call    0 never executed
        -:  441:
        -:  442:    // Sign-extend the input value to determine the low half of the result.
        -:  443:    // Then, check if the low half is negative, and sign-extend the comparison
        -:  444:    // result to get the high half.
    #####:  445:    Value newOperand = appendX1Dim(rewriter, loc, adaptor.getIn());
call    0 never executed
call    1 never executed
    #####:  446:    Value extended = rewriter.createOrFold<arith::ExtSIOp>(
    #####:  447:        loc, newResultComponentTy, newOperand);
call    0 never executed
    #####:  448:    Value operandZeroCst =
    #####:  449:        createScalarOrSplatConstant(rewriter, loc, newResultComponentTy, 0);
call    0 never executed
    #####:  450:    Value signBit = rewriter.create<arith::CmpIOp>(
    #####:  451:        loc, arith::CmpIPredicate::slt, extended, operandZeroCst);
call    0 never executed
call    1 never executed
    #####:  452:    Value signValue =
    #####:  453:        rewriter.create<arith::ExtSIOp>(loc, newResultComponentTy, signBit);
call    0 never executed
call    1 never executed
        -:  454:
    #####:  455:    Value resultVec =
    #####:  456:        constructResultVector(rewriter, loc, newTy, {extended, signValue});
call    0 never executed
call    1 never executed
    #####:  457:    rewriter.replaceOp(op, resultVec);
call    0 never executed
call    1 never executed
    #####:  458:    return success();
        -:  459:  }
        -:  460:};
        -:  461:
        -:  462://===----------------------------------------------------------------------===//
        -:  463:// ConvertExtUI
        -:  464://===----------------------------------------------------------------------===//
        -:  465:
        -:  466:struct ConvertExtUI final : OpConversionPattern<arith::ExtUIOp> {
        -:  467:  using OpConversionPattern::OpConversionPattern;
        -:  468:
        -:  469:  LogicalResult
function _ZNK12_GLOBAL__N_112ConvertExtUI15matchAndRewriteEN4mlir5arith7ExtUIOpENS2_14ExtUIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  470:  matchAndRewrite(arith::ExtUIOp op, OpAdaptor adaptor,
        -:  471:                  ConversionPatternRewriter &rewriter) const override {
    #####:  472:    Location loc = op->getLoc();
call    0 never executed
    #####:  473:    auto newTy = getTypeConverter()
    #####:  474:                     ->convertType(op.getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  475:                     .dyn_cast_or_null<VectorType>();
    #####:  476:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  477:      return rewriter.notifyMatchFailure(
    #####:  478:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  479:
    #####:  480:    Type newResultComponentTy = reduceInnermostDim(newTy);
call    0 never executed
        -:  481:
        -:  482:    // Zero-extend the input value to determine the low half of the result.
        -:  483:    // The high half is always zero.
    #####:  484:    Value newOperand = appendX1Dim(rewriter, loc, adaptor.getIn());
call    0 never executed
call    1 never executed
    #####:  485:    Value extended = rewriter.createOrFold<arith::ExtUIOp>(
    #####:  486:        loc, newResultComponentTy, newOperand);
call    0 never executed
    #####:  487:    Value zeroCst = createScalarOrSplatConstant(rewriter, loc, newTy, 0);
call    0 never executed
    #####:  488:    Value newRes = insertLastDimSlice(rewriter, loc, extended, zeroCst, 0);
call    0 never executed
    #####:  489:    rewriter.replaceOp(op, newRes);
call    0 never executed
call    1 never executed
    #####:  490:    return success();
        -:  491:  }
        -:  492:};
        -:  493:
        -:  494://===----------------------------------------------------------------------===//
        -:  495:// ConvertShLI
        -:  496://===----------------------------------------------------------------------===//
        -:  497:
        -:  498:struct ConvertShLI final : OpConversionPattern<arith::ShLIOp> {
        -:  499:  using OpConversionPattern::OpConversionPattern;
        -:  500:
        -:  501:  LogicalResult
function _ZNK12_GLOBAL__N_111ConvertShLI15matchAndRewriteEN4mlir5arith6ShLIOpENS2_13ShLIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  502:  matchAndRewrite(arith::ShLIOp op, OpAdaptor adaptor,
        -:  503:                  ConversionPatternRewriter &rewriter) const override {
    #####:  504:    Location loc = op->getLoc();
call    0 never executed
        -:  505:
    #####:  506:    Type oldTy = op.getType();
call    0 never executed
    #####:  507:    auto newTy =
    #####:  508:        getTypeConverter()->convertType(oldTy).dyn_cast_or_null<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  509:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  510:      return rewriter.notifyMatchFailure(
    #####:  511:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  512:
    #####:  513:    Type newOperandTy = reduceInnermostDim(newTy);
call    0 never executed
        -:  514:    // `oldBitWidth` == `2 * newBitWidth`
    #####:  515:    unsigned newBitWidth = newTy.getElementTypeBitWidth();
call    0 never executed
        -:  516:
    #####:  517:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  518:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  519:    Value rhsElem0 = extractLastDimSlice(rewriter, loc, adaptor.getRhs(), 0);
call    0 never executed
call    1 never executed
        -:  520:
        -:  521:    // Assume that the shift amount is < 2 * newBitWidth. Calculate the low and
        -:  522:    // high halves of the results separately:
        -:  523:    //   1. low := LHS.low shli RHS
        -:  524:    //
        -:  525:    //   2. high := a or b or c, where:
        -:  526:    //     a) Bits from LHS.high, shifted by the RHS.
        -:  527:    //     b) Bits from LHS.low, shifted right. These come into play when
        -:  528:    //        RHS < newBitWidth, e.g.:
        -:  529:    //         [0000][llll] shli 3 --> [0lll][l000]
        -:  530:    //                                    ^
        -:  531:    //                                    |
        -:  532:    //                           [llll] shrui (4 - 3)
        -:  533:    //     c) Bits from LHS.low, shifted left. These matter when
        -:  534:    //        RHS > newBitWidth, e.g.:
        -:  535:    //         [0000][llll] shli 7 --> [l000][0000]
        -:  536:    //                                   ^
        -:  537:    //                                   |
        -:  538:    //                          [llll] shli (7 - 4)
        -:  539:    //
        -:  540:    // Because shifts by values >= newBitWidth are undefined, we ignore the high
        -:  541:    // half of RHS, and introduce 'bounds checks' to account for
        -:  542:    // RHS.low > newBitWidth.
        -:  543:    //
        -:  544:    // TODO: Explore possible optimizations.
    #####:  545:    Value zeroCst = createScalarOrSplatConstant(rewriter, loc, newOperandTy, 0);
call    0 never executed
    #####:  546:    Value elemBitWidth =
    #####:  547:        createScalarOrSplatConstant(rewriter, loc, newOperandTy, newBitWidth);
call    0 never executed
        -:  548:
    #####:  549:    Value illegalElemShift = rewriter.create<arith::CmpIOp>(
    #####:  550:        loc, arith::CmpIPredicate::uge, rhsElem0, elemBitWidth);
call    0 never executed
call    1 never executed
        -:  551:
    #####:  552:    Value shiftedElem0 =
    #####:  553:        rewriter.create<arith::ShLIOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  554:    Value resElem0 = rewriter.create<arith::SelectOp>(loc, illegalElemShift,
    #####:  555:                                                      zeroCst, shiftedElem0);
call    0 never executed
call    1 never executed
        -:  556:
    #####:  557:    Value cappedShiftAmount = rewriter.create<arith::SelectOp>(
    #####:  558:        loc, illegalElemShift, elemBitWidth, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  559:    Value rightShiftAmount =
    #####:  560:        rewriter.create<arith::SubIOp>(loc, elemBitWidth, cappedShiftAmount);
call    0 never executed
call    1 never executed
    #####:  561:    Value shiftedRight =
    #####:  562:        rewriter.create<arith::ShRUIOp>(loc, lhsElem0, rightShiftAmount);
call    0 never executed
call    1 never executed
    #####:  563:    Value overshotShiftAmount =
    #####:  564:        rewriter.create<arith::SubIOp>(loc, rhsElem0, elemBitWidth);
call    0 never executed
call    1 never executed
    #####:  565:    Value shiftedLeft =
    #####:  566:        rewriter.create<arith::ShLIOp>(loc, lhsElem0, overshotShiftAmount);
call    0 never executed
call    1 never executed
        -:  567:
    #####:  568:    Value shiftedElem1 =
    #####:  569:        rewriter.create<arith::ShLIOp>(loc, lhsElem1, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  570:    Value resElem1High = rewriter.create<arith::SelectOp>(
    #####:  571:        loc, illegalElemShift, zeroCst, shiftedElem1);
call    0 never executed
call    1 never executed
    #####:  572:    Value resElem1Low = rewriter.create<arith::SelectOp>(
    #####:  573:        loc, illegalElemShift, shiftedLeft, shiftedRight);
call    0 never executed
call    1 never executed
    #####:  574:    Value resElem1 =
    #####:  575:        rewriter.create<arith::OrIOp>(loc, resElem1Low, resElem1High);
call    0 never executed
call    1 never executed
        -:  576:
    #####:  577:    Value resultVec =
    #####:  578:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
call    0 never executed
call    1 never executed
    #####:  579:    rewriter.replaceOp(op, resultVec);
call    0 never executed
call    1 never executed
    #####:  580:    return success();
        -:  581:  }
        -:  582:};
        -:  583:
        -:  584://===----------------------------------------------------------------------===//
        -:  585:// ConvertShRUI
        -:  586://===----------------------------------------------------------------------===//
        -:  587:
        -:  588:struct ConvertShRUI final : OpConversionPattern<arith::ShRUIOp> {
        -:  589:  using OpConversionPattern::OpConversionPattern;
        -:  590:
        -:  591:  LogicalResult
function _ZNK12_GLOBAL__N_112ConvertShRUI15matchAndRewriteEN4mlir5arith7ShRUIOpENS2_14ShRUIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  592:  matchAndRewrite(arith::ShRUIOp op, OpAdaptor adaptor,
        -:  593:                  ConversionPatternRewriter &rewriter) const override {
    #####:  594:    Location loc = op->getLoc();
call    0 never executed
        -:  595:
    #####:  596:    Type oldTy = op.getType();
call    0 never executed
    #####:  597:    auto newTy =
    #####:  598:        getTypeConverter()->convertType(oldTy).dyn_cast_or_null<VectorType>();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  599:    if (!newTy)
branch  0 never executed
branch  1 never executed
    #####:  600:      return rewriter.notifyMatchFailure(
    #####:  601:          loc, llvm::formatv("unsupported type: {0}", op.getType()));
call    0 never executed
call    1 never executed
        -:  602:
    #####:  603:    Type newOperandTy = reduceInnermostDim(newTy);
call    0 never executed
        -:  604:    // `oldBitWidth` == `2 * newBitWidth`
    #####:  605:    unsigned newBitWidth = newTy.getElementTypeBitWidth();
call    0 never executed
        -:  606:
    #####:  607:    auto [lhsElem0, lhsElem1] =
call    0 never executed
    #####:  608:        extractLastDimHalves(rewriter, loc, adaptor.getLhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  609:    Value rhsElem0 = extractLastDimSlice(rewriter, loc, adaptor.getRhs(), 0);
call    0 never executed
call    1 never executed
        -:  610:
        -:  611:    // Assume that the shift amount is < 2 * newBitWidth. Calculate the low and
        -:  612:    // high halves of the results separately:
        -:  613:    //   1. low := a or b or c, where:
        -:  614:    //     a) Bits from LHS.low, shifted by the RHS.
        -:  615:    //     b) Bits from LHS.high, shifted left. These matter when
        -:  616:    //        RHS < newBitWidth, e.g.:
        -:  617:    //         [hhhh][0000] shrui 3 --> [000h][hhh0]
        -:  618:    //                                          ^
        -:  619:    //                                          |
        -:  620:    //                                 [hhhh] shli (4 - 1)
        -:  621:    //     c) Bits from LHS.high, shifted right. These come into play when
        -:  622:    //        RHS > newBitWidth, e.g.:
        -:  623:    //         [hhhh][0000] shrui 7 --> [0000][000h]
        -:  624:    //                                          ^
        -:  625:    //                                          |
        -:  626:    //                                 [hhhh] shrui (7 - 4)
        -:  627:    //
        -:  628:    //   2. high := LHS.high shrui RHS
        -:  629:    //
        -:  630:    // Because shifts by values >= newBitWidth are undefined, we ignore the high
        -:  631:    // half of RHS, and introduce 'bounds checks' to account for
        -:  632:    // RHS.low > newBitWidth.
        -:  633:    //
        -:  634:    // TODO: Explore possible optimizations.
    #####:  635:    Value zeroCst = createScalarOrSplatConstant(rewriter, loc, newOperandTy, 0);
call    0 never executed
    #####:  636:    Value elemBitWidth =
    #####:  637:        createScalarOrSplatConstant(rewriter, loc, newOperandTy, newBitWidth);
call    0 never executed
        -:  638:
    #####:  639:    Value illegalElemShift = rewriter.create<arith::CmpIOp>(
    #####:  640:        loc, arith::CmpIPredicate::uge, rhsElem0, elemBitWidth);
call    0 never executed
call    1 never executed
        -:  641:
    #####:  642:    Value shiftedElem0 =
    #####:  643:        rewriter.create<arith::ShRUIOp>(loc, lhsElem0, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  644:    Value resElem0Low = rewriter.create<arith::SelectOp>(loc, illegalElemShift,
    #####:  645:                                                         zeroCst, shiftedElem0);
call    0 never executed
call    1 never executed
    #####:  646:    Value shiftedElem1 =
    #####:  647:        rewriter.create<arith::ShRUIOp>(loc, lhsElem1, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  648:    Value resElem1 = rewriter.create<arith::SelectOp>(loc, illegalElemShift,
    #####:  649:                                                      zeroCst, shiftedElem1);
call    0 never executed
call    1 never executed
        -:  650:
    #####:  651:    Value cappedShiftAmount = rewriter.create<arith::SelectOp>(
    #####:  652:        loc, illegalElemShift, elemBitWidth, rhsElem0);
call    0 never executed
call    1 never executed
    #####:  653:    Value leftShiftAmount =
    #####:  654:        rewriter.create<arith::SubIOp>(loc, elemBitWidth, cappedShiftAmount);
call    0 never executed
call    1 never executed
    #####:  655:    Value shiftedLeft =
    #####:  656:        rewriter.create<arith::ShLIOp>(loc, lhsElem1, leftShiftAmount);
call    0 never executed
call    1 never executed
    #####:  657:    Value overshotShiftAmount =
    #####:  658:        rewriter.create<arith::SubIOp>(loc, rhsElem0, elemBitWidth);
call    0 never executed
call    1 never executed
    #####:  659:    Value shiftedRight =
    #####:  660:        rewriter.create<arith::ShRUIOp>(loc, lhsElem1, overshotShiftAmount);
call    0 never executed
call    1 never executed
        -:  661:
    #####:  662:    Value resElem0High = rewriter.create<arith::SelectOp>(
    #####:  663:        loc, illegalElemShift, shiftedRight, shiftedLeft);
call    0 never executed
call    1 never executed
    #####:  664:    Value resElem0 =
    #####:  665:        rewriter.create<arith::OrIOp>(loc, resElem0Low, resElem0High);
call    0 never executed
call    1 never executed
        -:  666:
    #####:  667:    Value resultVec =
    #####:  668:        constructResultVector(rewriter, loc, newTy, {resElem0, resElem1});
call    0 never executed
call    1 never executed
    #####:  669:    rewriter.replaceOp(op, resultVec);
call    0 never executed
call    1 never executed
    #####:  670:    return success();
        -:  671:  }
        -:  672:};
        -:  673:
        -:  674://===----------------------------------------------------------------------===//
        -:  675:// ConvertTruncI
        -:  676://===----------------------------------------------------------------------===//
        -:  677:
        -:  678:struct ConvertTruncI final : OpConversionPattern<arith::TruncIOp> {
        -:  679:  using OpConversionPattern::OpConversionPattern;
        -:  680:
        -:  681:  LogicalResult
function _ZNK12_GLOBAL__N_113ConvertTruncI15matchAndRewriteEN4mlir5arith8TruncIOpENS2_15TruncIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  682:  matchAndRewrite(arith::TruncIOp op, OpAdaptor adaptor,
        -:  683:                  ConversionPatternRewriter &rewriter) const override {
    #####:  684:    Location loc = op.getLoc();
call    0 never executed
        -:  685:    // Check if the result type is legal for this target. Currently, we do not
        -:  686:    // support truncation to types wider than supported by the target.
    #####:  687:    if (!getTypeConverter()->isLegal(op.getType()))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  688:      return rewriter.notifyMatchFailure(
    #####:  689:          loc, llvm::formatv("unsupported truncation result type: {0}",
call    0 never executed
    #####:  690:                             op.getType()));
call    0 never executed
call    1 never executed
        -:  691:
        -:  692:    // Discard the high half of the input. Truncate the low half, if necessary.
    #####:  693:    Value extracted = extractLastDimSlice(rewriter, loc, adaptor.getIn(), 0);
call    0 never executed
call    1 never executed
    #####:  694:    extracted = dropTrailingX1Dim(rewriter, loc, extracted);
call    0 never executed
    #####:  695:    Value truncated =
    #####:  696:        rewriter.createOrFold<arith::TruncIOp>(loc, op.getType(), extracted);
call    0 never executed
    #####:  697:    rewriter.replaceOp(op, truncated);
call    0 never executed
call    1 never executed
    #####:  698:    return success();
        -:  699:  }
        -:  700:};
        -:  701:
        -:  702://===----------------------------------------------------------------------===//
        -:  703:// ConvertVectorPrint
        -:  704://===----------------------------------------------------------------------===//
        -:  705:
        -:  706:struct ConvertVectorPrint final : OpConversionPattern<vector::PrintOp> {
        -:  707:  using OpConversionPattern::OpConversionPattern;
        -:  708:
        -:  709:  LogicalResult
function _ZNK12_GLOBAL__N_118ConvertVectorPrint15matchAndRewriteEN4mlir6vector7PrintOpENS2_14PrintOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  710:  matchAndRewrite(vector::PrintOp op, OpAdaptor adaptor,
        -:  711:                  ConversionPatternRewriter &rewriter) const override {
    #####:  712:    rewriter.replaceOpWithNewOp<vector::PrintOp>(op, adaptor.getSource());
call    0 never executed
call    1 never executed
    #####:  713:    return success();
        -:  714:  }
        -:  715:};
        -:  716:
        -:  717://===----------------------------------------------------------------------===//
        -:  718:// Pass Definition
        -:  719://===----------------------------------------------------------------------===//
        -:  720:
  129227*:  721:struct EmulateWideIntPass final
call    0 never executed
call    1 returned 100%
        -:  722:    : arith::impl::ArithEmulateWideIntBase<EmulateWideIntPass> {
    #####:  723:  using ArithEmulateWideIntBase::ArithEmulateWideIntBase;
call    0 never executed
        -:  724:
function _ZN12_GLOBAL__N_118EmulateWideIntPass14runOnOperationEv called 539 returned 100% blocks executed 88%
      539:  725:  void runOnOperation() override {
    1078*:  726:    if (!llvm::isPowerOf2_32(widestIntSupported) || widestIntSupported < 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    #####:  727:      signalPassFailure();
call    0 never executed
    #####:  728:      return;
        -:  729:    }
        -:  730:
      539:  731:    Operation *op = getOperation();
branch  0 taken 0%
branch  1 taken 100%
      539:  732:    MLIRContext *ctx = op->getContext();
call    0 returned 100%
        -:  733:
     1078:  734:    arith::WideIntEmulationConverter typeConverter(widestIntSupported);
call    0 returned 100%
     1078:  735:    ConversionTarget target(*ctx);
call    0 returned 100%
call    1 returned 100%
function _ZZN12_GLOBAL__N_118EmulateWideIntPass14runOnOperationEvENKUlPN4mlir9OperationEE_clES3_.isra.0 called 0 returned 0% blocks executed 0%
     539*:  736:    target.addDynamicallyLegalOp<func::FuncOp>([&typeConverter](Operation *op) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  737:      return typeConverter.isLegal(cast<func::FuncOp>(op).getFunctionType());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  738:    });
     539*:  739:    auto opLegalCallback = [&typeConverter](Operation *op) {
    #####:  740:      return typeConverter.isLegal(op);
call    0 never executed
      539:  741:    };
     1078:  742:    target.addDynamicallyLegalOp<func::CallOp, func::ReturnOp>(opLegalCallback);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      539:  743:    target
call    0 returned 100%
      539:  744:        .addDynamicallyLegalDialect<arith::ArithDialect, vector::VectorDialect>(
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  745:            opLegalCallback);
        -:  746:
     1078:  747:    RewritePatternSet patterns(ctx);
call    0 returned 100%
call    1 returned 100%
      539:  748:    arith::populateArithWideIntEmulationPatterns(typeConverter, patterns);
call    0 returned 100%
        -:  749:
      539:  750:    if (failed(applyPartialConversion(op, target, std::move(patterns))))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  751:      signalPassFailure();
call    0 never executed
        -:  752:  }
        -:  753:};
        -:  754:} // end anonymous namespace
        -:  755:
        -:  756://===----------------------------------------------------------------------===//
        -:  757:// Public Interface Definition
        -:  758://===----------------------------------------------------------------------===//
        -:  759:
function _ZN4mlir5arith25WideIntEmulationConverterC2Ej called 1078 returned 100% blocks executed 82%
     1078:  760:arith::WideIntEmulationConverter::WideIntEmulationConverter(
     1078:  761:    unsigned widestIntSupportedByTarget)
     1078:  762:    : maxIntWidth(widestIntSupportedByTarget) {
call    0 returned 100%
    1078*:  763:  assert(llvm::isPowerOf2_32(widestIntSupportedByTarget) &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        -:  764:         "Only power-of-two integers with are supported");
    1078*:  765:  assert(widestIntSupportedByTarget >= 2 && "Integer type too narrow");
branch  0 taken 0%
branch  1 taken 100%
call    2 never executed
        -:  766:
        -:  767:  // Allow unknown types.
    1078*:  768:  addConversion([](Type ty) -> Optional<Type> { return ty; });
call    0 never executed
call    1 returned 100%
        -:  769:
        -:  770:  // Scalar case.
function _ZZN4mlir5arith25WideIntEmulationConverterC4EjENKUlNS_11IntegerTypeEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    1078*:  771:  addConversion([this](IntegerType ty) -> Optional<Type> {
call    0 returned 100%
    #####:  772:    unsigned width = ty.getWidth();
call    0 never executed
    #####:  773:    if (width <= maxIntWidth)
branch  0 never executed
branch  1 never executed
    #####:  774:      return ty;
        -:  775:
        -:  776:    // i2N --> vector<2xiN>
    #####:  777:    if (width == 2 * maxIntWidth)
branch  0 never executed
branch  1 never executed
    #####:  778:      return VectorType::get(2, IntegerType::get(ty.getContext(), maxIntWidth));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  779:
    #####:  780:    return None;
        -:  781:  });
        -:  782:
        -:  783:  // Vector case.
function _ZZN4mlir5arith25WideIntEmulationConverterC4EjENKUlNS_10VectorTypeEE1_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    1078*:  784:  addConversion([this](VectorType ty) -> Optional<Type> {
call    0 returned 100%
    #####:  785:    auto intTy = ty.getElementType().dyn_cast<IntegerType>();
call    0 never executed
call    1 never executed
    #####:  786:    if (!intTy)
branch  0 never executed
branch  1 never executed
    #####:  787:      return ty;
        -:  788:
    #####:  789:    unsigned width = intTy.getWidth();
call    0 never executed
    #####:  790:    if (width <= maxIntWidth)
branch  0 never executed
branch  1 never executed
    #####:  791:      return ty;
        -:  792:
        -:  793:    // vector<...xi2N> --> vector<...x2xiN>
    #####:  794:    if (width == 2 * maxIntWidth) {
branch  0 never executed
branch  1 never executed
    #####:  795:      auto newShape = to_vector(ty.getShape());
call    0 never executed
call    1 never executed
    #####:  796:      newShape.push_back(2);
call    0 never executed
    #####:  797:      return VectorType::get(newShape,
branch  0 never executed
branch  1 never executed
    #####:  798:                             IntegerType::get(ty.getContext(), maxIntWidth));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  799:    }
        -:  800:
    #####:  801:    return None;
        -:  802:  });
        -:  803:
        -:  804:  // Function case.
function _ZZN4mlir5arith25WideIntEmulationConverterC4EjENKUlNS_12FunctionTypeEE2_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    1078*:  805:  addConversion([this](FunctionType ty) -> Optional<Type> {
call    0 returned 100%
        -:  806:    // Convert inputs and results, e.g.:
        -:  807:    //   (i2N, i2N) -> i2N --> (vector<2xiN>, vector<2xiN>) -> vector<2xiN>
    #####:  808:    SmallVector<Type> inputs;
call    0 never executed
    #####:  809:    if (failed(convertTypes(ty.getInputs(), inputs)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  810:      return None;
        -:  811:
    #####:  812:    SmallVector<Type> results;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  813:    if (failed(convertTypes(ty.getResults(), results)))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  814:      return None;
        -:  815:
    #####:  816:    return FunctionType::get(ty.getContext(), inputs, results);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  817:  });
     1078:  818:}
        -:  819:
function _ZN4mlir5arith37populateArithWideIntEmulationPatternsERNS0_25WideIntEmulationConverterERNS_17RewritePatternSetE called 1078 returned 100% blocks executed 100%
     1078:  820:void arith::populateArithWideIntEmulationPatterns(
        -:  821:    WideIntEmulationConverter &typeConverter, RewritePatternSet &patterns) {
        -:  822:  // Populate `func.*` conversion patterns.
     1078:  823:  populateFunctionOpInterfaceTypeConversionPattern<func::FuncOp>(patterns,
call    0 returned 100%
        -:  824:                                                                 typeConverter);
     1078:  825:  populateCallOpTypeConversionPattern(patterns, typeConverter);
call    0 returned 100%
     1078:  826:  populateReturnOpTypeConversionPattern(patterns, typeConverter);
call    0 returned 100%
        -:  827:
        -:  828:  // Populate `arith.*` conversion patterns.
     1078:  829:  patterns.add<
        -:  830:      // Misc ops.
        -:  831:      ConvertConstant, ConvertVectorPrint,
        -:  832:      // Binary ops.
        -:  833:      ConvertAddI, ConvertMulI, ConvertShLI, ConvertShRUI,
        -:  834:      // Bitwise binary ops.
        -:  835:      ConvertBitwiseBinary<arith::AndIOp>, ConvertBitwiseBinary<arith::OrIOp>,
        -:  836:      ConvertBitwiseBinary<arith::XOrIOp>,
        -:  837:      // Extension and truncation ops.
        -:  838:      ConvertExtSI, ConvertExtUI, ConvertTruncI>(typeConverter,
     1078:  839:                                                 patterns.getContext());
call    0 returned 100%
     1078:  840:}
