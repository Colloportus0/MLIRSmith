        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/IR/AffineMap.h
        -:    0:Graph:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/Parser.cpp.gcno
        -:    0:Data:../tools/mlir/lib/AsmParser/CMakeFiles/obj.MLIRAsmParser.dir/Parser.cpp.gcda
        -:    0:Runs:128655
        -:    1://===- AffineMap.h - MLIR Affine Map Class ----------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// Affine maps are mathematical functions which map a list of dimension
        -:   10:// identifiers and symbols, to multidimensional affine expressions.
        -:   11://
        -:   12://===----------------------------------------------------------------------===//
        -:   13:
        -:   14:#ifndef MLIR_IR_AFFINEMAP_H
        -:   15:#define MLIR_IR_AFFINEMAP_H
        -:   16:
        -:   17:#include "mlir/IR/AffineExpr.h"
        -:   18:#include "mlir/Support/LLVM.h"
        -:   19:#include "llvm/ADT/ArrayRef.h"
        -:   20:#include "llvm/ADT/DenseMapInfo.h"
        -:   21:#include "llvm/ADT/SmallBitVector.h"
        -:   22:
        -:   23:namespace llvm {
        -:   24:class SmallBitVector;
        -:   25:} // namespace llvm
        -:   26:
        -:   27:namespace mlir {
        -:   28:
        -:   29:namespace detail {
        -:   30:struct AffineMapStorage;
        -:   31:} // namespace detail
        -:   32:
        -:   33:class Attribute;
        -:   34:struct LogicalResult;
        -:   35:class MLIRContext;
        -:   36:
        -:   37:/// A multi-dimensional affine map
        -:   38:/// Affine map's are immutable like Type's, and they are uniqued.
        -:   39:/// Eg: (d0, d1) -> (d0/128, d0 mod 128, d1)
        -:   40:/// The names used (d0, d1) don't matter - it's the mathematical function that
        -:   41:/// is unique to this affine map.
        -:   42:class AffineMap {
        -:   43:public:
        -:   44:  using ImplType = detail::AffineMapStorage;
        -:   45:
        -:   46:  constexpr AffineMap() = default;
        -:   47:  explicit AffineMap(ImplType *map) : map(map) {}
        -:   48:
        -:   49:  /// Returns a zero result affine map with no dimensions or symbols: () -> ().
        -:   50:  static AffineMap get(MLIRContext *context);
        -:   51:
        -:   52:  /// Returns a zero result affine map with `dimCount` dimensions and
        -:   53:  /// `symbolCount` symbols, e.g.: `(...) -> ()`.
        -:   54:  static AffineMap get(unsigned dimCount, unsigned symbolCount,
        -:   55:                       MLIRContext *context);
        -:   56:
        -:   57:  /// Returns an affine map with `dimCount` dimensions and `symbolCount` mapping
        -:   58:  /// to a single output dimension
        -:   59:  static AffineMap get(unsigned dimCount, unsigned symbolCount,
        -:   60:                       AffineExpr result);
        -:   61:
        -:   62:  /// Returns an affine map with `dimCount` dimensions and `symbolCount` mapping
        -:   63:  /// to the given results.
        -:   64:  static AffineMap get(unsigned dimCount, unsigned symbolCount,
        -:   65:                       ArrayRef<AffineExpr> results, MLIRContext *context);
        -:   66:
        -:   67:  /// Returns a single constant result affine map.
        -:   68:  static AffineMap getConstantMap(int64_t val, MLIRContext *context);
        -:   69:
        -:   70:  /// Returns an AffineMap with 'numDims' identity result dim exprs.
        -:   71:  static AffineMap getMultiDimIdentityMap(unsigned numDims,
        -:   72:                                          MLIRContext *context);
        -:   73:
        -:   74:  /// Returns an identity affine map (d0, ..., dn) -> (dp, ..., dn) on the most
        -:   75:  /// minor dimensions.
        -:   76:  static AffineMap getMinorIdentityMap(unsigned dims, unsigned results,
        -:   77:                                       MLIRContext *context);
        -:   78:
        -:   79:  /// Returns an AffineMap representing a permutation.
        -:   80:  /// The permutation is expressed as a non-empty vector of integers.
        -:   81:  /// E.g. the permutation `(i,j,k) -> (j,k,i)` will be expressed with
        -:   82:  /// `permutation = [1,2,0]`. All values in `permutation` must be
        -:   83:  /// integers, in the range 0..`permutation.size()-1` without duplications
        -:   84:  /// (i.e. `[1,1,2]` is an invalid permutation).
        -:   85:  static AffineMap getPermutationMap(ArrayRef<unsigned> permutation,
        -:   86:                                     MLIRContext *context);
        -:   87:
        -:   88:  /// Returns a vector of AffineMaps; each with as many results as
        -:   89:  /// `exprs.size()`, as many dims as the largest dim in `exprs` and as many
        -:   90:  /// symbols as the largest symbol in `exprs`.
        -:   91:  static SmallVector<AffineMap, 4>
        -:   92:  inferFromExprList(ArrayRef<ArrayRef<AffineExpr>> exprsList);
        -:   93:  static SmallVector<AffineMap, 4>
        -:   94:  inferFromExprList(ArrayRef<SmallVector<AffineExpr, 4>> exprsList);
        -:   95:
        -:   96:  MLIRContext *getContext() const;
        -:   97:
    #####:   98:  explicit operator bool() const { return map != nullptr; }
branch  0 never executed
branch  1 never executed
        -:   99:  bool operator==(AffineMap other) const { return other.map == map; }
        -:  100:  bool operator!=(AffineMap other) const { return !(other.map == map); }
        -:  101:
        -:  102:  /// Returns true if this affine map is an identity affine map.
        -:  103:  /// An identity affine map corresponds to an identity affine function on the
        -:  104:  /// dimensional identifiers.
        -:  105:  bool isIdentity() const;
        -:  106:
        -:  107:  /// Returns true if this affine map is a minor identity, i.e. an identity
        -:  108:  /// affine map (d0, ..., dn) -> (dp, ..., dn) on the most minor dimensions.
        -:  109:  bool isMinorIdentity() const;
        -:  110:
        -:  111:  /// Returns true if this affine map is a minor identity up to broadcasted
        -:  112:  /// dimensions which are indicated by value 0 in the result. If
        -:  113:  /// `broadcastedDims` is not null, it will be populated with the indices of
        -:  114:  /// the broadcasted dimensions in the result array.
        -:  115:  /// Example: affine_map<(d0, d1, d2, d3, d4) -> (0, d2, 0, d4)>
        -:  116:  ///          (`broadcastedDims` will contain [0, 2])
        -:  117:  bool isMinorIdentityWithBroadcasting(
        -:  118:      SmallVectorImpl<unsigned> *broadcastedDims = nullptr) const;
        -:  119:
        -:  120:  /// Return true if this affine map can be converted to a minor identity with
        -:  121:  /// broadcast by doing a permute. Return a permutation (there may be
        -:  122:  /// several) to apply to get to a minor identity with broadcasts.
        -:  123:  /// Ex:
        -:  124:  ///  * (d0, d1, d2) -> (0, d1) maps to minor identity (d1, 0 = d2) with
        -:  125:  ///  perm = [1, 0] and broadcast d2
        -:  126:  ///  * (d0, d1, d2) -> (d0, 0) cannot be mapped to a minor identity by
        -:  127:  ///  permutation + broadcast
        -:  128:  ///  * (d0, d1, d2, d3) -> (0, d1, d3) maps to minor identity (d1, 0 = d2, d3)
        -:  129:  ///  with perm = [1, 0, 2] and broadcast d2
        -:  130:  ///  * (d0, d1) -> (d1, 0, 0, d0) maps to minor identity (d0, d1) with extra
        -:  131:  ///  leading broadcat dimensions. The map returned would be (0, 0, d0, d1)
        -:  132:  ///  with perm = [3, 0, 1, 2]
        -:  133:  bool isPermutationOfMinorIdentityWithBroadcasting(
        -:  134:      SmallVectorImpl<unsigned> &permutedDims) const;
        -:  135:
        -:  136:  /// Returns true if this affine map is an empty map, i.e., () -> ().
        -:  137:  bool isEmpty() const;
        -:  138:
        -:  139:  /// Returns true if this affine map is a single result constant function.
        -:  140:  bool isSingleConstant() const;
        -:  141:
        -:  142:  /// Returns true if this affine map has only constant results.
        -:  143:  bool isConstant() const;
        -:  144:
        -:  145:  /// Returns the constant result of this map. This methods asserts that the map
        -:  146:  /// has a single constant result.
        -:  147:  int64_t getSingleConstantResult() const;
        -:  148:
        -:  149:  /// Returns the constant results of this map. This method asserts that the map
        -:  150:  /// has all constant results.
        -:  151:  SmallVector<int64_t> getConstantResults() const;
        -:  152:
        -:  153:  // Prints affine map to 'os'.
        -:  154:  void print(raw_ostream &os) const;
        -:  155:  void dump() const;
        -:  156:
        -:  157:  unsigned getNumDims() const;
        -:  158:  unsigned getNumSymbols() const;
        -:  159:  unsigned getNumResults() const;
        -:  160:  unsigned getNumInputs() const;
        -:  161:
        -:  162:  ArrayRef<AffineExpr> getResults() const;
        -:  163:  AffineExpr getResult(unsigned idx) const;
        -:  164:
        -:  165:  /// Extracts the position of the dimensional expression at the given result,
        -:  166:  /// when the caller knows it is safe to do so.
        -:  167:  unsigned getDimPosition(unsigned idx) const;
        -:  168:
        -:  169:  /// Extracts the permuted position where given input index resides.
        -:  170:  /// Fails when called on a non-permutation.
        -:  171:  unsigned getPermutedPosition(unsigned input) const;
        -:  172:
        -:  173:  /// Return true if any affine expression involves AffineDimExpr `position`.
        -:  174:  bool isFunctionOfDim(unsigned position) const {
        -:  175:    return llvm::any_of(getResults(), [&](AffineExpr e) {
        -:  176:      return e.isFunctionOfDim(position);
        -:  177:    });
        -:  178:  }
        -:  179:
        -:  180:  /// Return true if any affine expression involves AffineSymbolExpr `position`.
        -:  181:  bool isFunctionOfSymbol(unsigned position) const {
        -:  182:    return llvm::any_of(getResults(), [&](AffineExpr e) {
        -:  183:      return e.isFunctionOfSymbol(position);
        -:  184:    });
        -:  185:  }
        -:  186:
        -:  187:  /// Walk all of the AffineExpr's in this mapping. Each node in an expression
        -:  188:  /// tree is visited in postorder.
        -:  189:  void walkExprs(llvm::function_ref<void(AffineExpr)> callback) const;
        -:  190:
        -:  191:  /// This method substitutes any uses of dimensions and symbols (e.g.
        -:  192:  /// dim#0 with dimReplacements[0]) in subexpressions and returns the modified
        -:  193:  /// expression mapping.  Because this can be used to eliminate dims and
        -:  194:  /// symbols, the client needs to specify the number of dims and symbols in
        -:  195:  /// the result.  The returned map always has the same number of results.
        -:  196:  AffineMap replaceDimsAndSymbols(ArrayRef<AffineExpr> dimReplacements,
        -:  197:                                  ArrayRef<AffineExpr> symReplacements,
        -:  198:                                  unsigned numResultDims,
        -:  199:                                  unsigned numResultSyms) const;
        -:  200:
        -:  201:  /// Sparse replace method. Apply AffineExpr::replace(`expr`, `replacement`) to
        -:  202:  /// each of the results and return a new AffineMap with the new results and
        -:  203:  /// with the specified number of dims and symbols.
        -:  204:  AffineMap replace(AffineExpr expr, AffineExpr replacement,
        -:  205:                    unsigned numResultDims, unsigned numResultSyms) const;
        -:  206:
        -:  207:  /// Sparse replace method. Apply AffineExpr::replace(`map`) to each of the
        -:  208:  /// results and return a new AffineMap with the new results and with inferred
        -:  209:  /// number of dims and symbols.
        -:  210:  AffineMap replace(const DenseMap<AffineExpr, AffineExpr> &map) const;
        -:  211:
        -:  212:  /// Sparse replace method. Apply AffineExpr::replace(`map`) to each of the
        -:  213:  /// results and return a new AffineMap with the new results and with the
        -:  214:  /// specified number of dims and symbols.
        -:  215:  AffineMap replace(const DenseMap<AffineExpr, AffineExpr> &map,
        -:  216:                    unsigned numResultDims, unsigned numResultSyms) const;
        -:  217:
        -:  218:  /// Replace dims[offset ... numDims)
        -:  219:  /// by dims[offset + shift ... shift + numDims).
        -:  220:  AffineMap shiftDims(unsigned shift, unsigned offset = 0) const {
        -:  221:    assert(offset <= getNumDims());
        -:  222:    return AffineMap::get(getNumDims() + shift, getNumSymbols(),
        -:  223:                          llvm::to_vector<4>(llvm::map_range(
        -:  224:                              getResults(),
        -:  225:                              [&](AffineExpr e) {
        -:  226:                                return e.shiftDims(getNumDims(), shift, offset);
        -:  227:                              })),
        -:  228:                          getContext());
        -:  229:  }
        -:  230:
        -:  231:  /// Replace symbols[offset ... numSymbols)
        -:  232:  /// by symbols[offset + shift ... shift + numSymbols).
        -:  233:  AffineMap shiftSymbols(unsigned shift, unsigned offset = 0) const {
        -:  234:    return AffineMap::get(getNumDims(), getNumSymbols() + shift,
        -:  235:                          llvm::to_vector<4>(llvm::map_range(
        -:  236:                              getResults(),
        -:  237:                              [&](AffineExpr e) {
        -:  238:                                return e.shiftSymbols(getNumSymbols(), shift,
        -:  239:                                                      offset);
        -:  240:                              })),
        -:  241:                          getContext());
        -:  242:  }
        -:  243:
        -:  244:  /// Returns a new AffineMap with the same number of dims and symbols and one
        -:  245:  /// less result at `pos`, dropped.
        -:  246:  AffineMap dropResult(int64_t pos) { return dropResults({pos}); }
        -:  247:
        -:  248:  // Returns a new AffineMap with the same number of dims and symbols, but all
        -:  249:  // positions in `positions` dropped from results.
        -:  250:  AffineMap dropResults(ArrayRef<int64_t> positions) {
        -:  251:    SmallVector<int64_t> reverse_sorted_positions = llvm::to_vector(positions);
        -:  252:    llvm::sort(reverse_sorted_positions, std::greater<int64_t>());
        -:  253:
        -:  254:    auto exprs = llvm::to_vector<4>(getResults());
        -:  255:    for (int64_t pos : reverse_sorted_positions)
        -:  256:      exprs.erase(exprs.begin() + pos);
        -:  257:    return AffineMap::get(getNumDims(), getNumSymbols(), exprs, getContext());
        -:  258:  }
        -:  259:
        -:  260:  /// Returns a new AffineMap with the same number of dims and symbols and an
        -:  261:  /// extra result inserted at `pos`.
        -:  262:  AffineMap insertResult(AffineExpr expr, unsigned pos) {
        -:  263:    auto exprs = llvm::to_vector<4>(getResults());
        -:  264:    exprs.insert(exprs.begin() + pos, expr);
        -:  265:    return AffineMap::get(getNumDims(), getNumSymbols(), exprs, getContext());
        -:  266:  }
        -:  267:
        -:  268:  /// Folds the results of the application of an affine map on the provided
        -:  269:  /// operands to a constant if possible.
        -:  270:  LogicalResult constantFold(ArrayRef<Attribute> operandConstants,
        -:  271:                             SmallVectorImpl<Attribute> &results) const;
        -:  272:
        -:  273:  /// Propagates the constant operands into this affine map. Operands are
        -:  274:  /// allowed to be null, at which point they are treated as non-constant. This
        -:  275:  /// does not change the number of symbols and dimensions. Returns a new map,
        -:  276:  /// which may be equal to the old map if no folding happened. If `results` is
        -:  277:  /// provided and if all expressions in the map were folded to constants,
        -:  278:  /// `results` will contain the values of these constants.
        -:  279:  AffineMap
        -:  280:  partialConstantFold(ArrayRef<Attribute> operandConstants,
        -:  281:                      SmallVectorImpl<int64_t> *results = nullptr) const;
        -:  282:
        -:  283:  /// Returns the AffineMap resulting from composing `this` with `map`.
        -:  284:  /// The resulting AffineMap has as many AffineDimExpr as `map` and as many
        -:  285:  /// AffineSymbolExpr as the concatenation of `this` and `map` (in which case
        -:  286:  /// the symbols of `this` map come first).
        -:  287:  ///
        -:  288:  /// Prerequisites:
        -:  289:  /// The maps are composable, i.e. that the number of AffineDimExpr of `this`
        -:  290:  /// matches the number of results of `map`.
        -:  291:  ///
        -:  292:  /// Example:
        -:  293:  ///   map1: `(d0, d1)[s0, s1] -> (d0 + 1 + s1, d1 - 1 - s0)`
        -:  294:  ///   map2: `(d0)[s0] -> (d0 + s0, d0 - s0)`
        -:  295:  ///   map1.compose(map2):
        -:  296:  ///     `(d0)[s0, s1, s2] -> (d0 + s1 + s2 + 1, d0 - s0 - s2 - 1)`
        -:  297:  AffineMap compose(AffineMap map) const;
        -:  298:
        -:  299:  /// Applies composition by the dims of `this` to the integer `values` and
        -:  300:  /// returns the resulting values. `this` must be symbol-less.
        -:  301:  SmallVector<int64_t, 4> compose(ArrayRef<int64_t> values) const;
        -:  302:
        -:  303:  /// Returns true if the AffineMap represents a subset (i.e. a projection) of a
        -:  304:  /// symbol-less permutation map. `allowZeroInResults` allows projected
        -:  305:  /// permutation maps with constant zero result expressions.
        -:  306:  /// TODO: Remove `allowZeroInResults` when constant zero result expressions
        -:  307:  /// are broadly supported.
        -:  308:  bool isProjectedPermutation(bool allowZeroInResults = false) const;
        -:  309:
        -:  310:  /// Returns true if the AffineMap represents a symbol-less permutation map.
        -:  311:  bool isPermutation() const;
        -:  312:
        -:  313:  /// Returns the map consisting of the `resultPos` subset.
        -:  314:  AffineMap getSubMap(ArrayRef<unsigned> resultPos) const;
        -:  315:
        -:  316:  /// Returns the map consisting of `length` expressions starting from `start`.
        -:  317:  AffineMap getSliceMap(unsigned start, unsigned length) const;
        -:  318:
        -:  319:  /// Returns the map consisting of the most major `numResults` results.
        -:  320:  /// Returns the null AffineMap if `numResults` == 0.
        -:  321:  /// Returns `*this` if `numResults` >= `this->getNumResults()`.
        -:  322:  AffineMap getMajorSubMap(unsigned numResults) const;
        -:  323:
        -:  324:  /// Returns the map consisting of the most minor `numResults` results.
        -:  325:  /// Returns the null AffineMap if `numResults` == 0.
        -:  326:  /// Returns `*this` if `numResults` >= `this->getNumResults()`.
        -:  327:  AffineMap getMinorSubMap(unsigned numResults) const;
        -:  328:
        -:  329:  /// Get the largest known divisor of all map expressions.
        -:  330:  /// For eg: for (d0, d1) -> (8*d0 + 4, 4*d1 + 2), the result is 2.
        -:  331:  /// In the case of maps with no expressions or all zero constant expressions,
        -:  332:  /// the largest known divisor is trivially the max uint64_t value.
        -:  333:  uint64_t getLargestKnownDivisorOfMapExprs();
        -:  334:
        -:  335:  friend ::llvm::hash_code hash_value(AffineMap arg);
        -:  336:
        -:  337:  /// Methods supporting C API.
        -:  338:  const void *getAsOpaquePointer() const {
        -:  339:    return static_cast<const void *>(map);
        -:  340:  }
        -:  341:  static AffineMap getFromOpaquePointer(const void *pointer) {
        -:  342:    return AffineMap(reinterpret_cast<ImplType *>(const_cast<void *>(pointer)));
        -:  343:  }
        -:  344:
        -:  345:private:
        -:  346:  ImplType *map{nullptr};
        -:  347:
        -:  348:  static AffineMap getImpl(unsigned dimCount, unsigned symbolCount,
        -:  349:                           ArrayRef<AffineExpr> results, MLIRContext *context);
        -:  350:};
        -:  351:
        -:  352:// Make AffineExpr hashable.
        -:  353:inline ::llvm::hash_code hash_value(AffineMap arg) {
        -:  354:  return ::llvm::hash_value(arg.map);
        -:  355:}
        -:  356:
        -:  357:/// A mutable affine map. Its affine expressions are however unique.
        -:  358:struct MutableAffineMap {
        -:  359:public:
        -:  360:  MutableAffineMap() = default;
        -:  361:  MutableAffineMap(AffineMap map);
        -:  362:
        -:  363:  ArrayRef<AffineExpr> getResults() const { return results; }
        -:  364:  AffineExpr getResult(unsigned idx) const { return results[idx]; }
        -:  365:  void setResult(unsigned idx, AffineExpr result) { results[idx] = result; }
        -:  366:  unsigned getNumResults() const { return results.size(); }
        -:  367:  unsigned getNumDims() const { return numDims; }
        -:  368:  void setNumDims(unsigned d) { numDims = d; }
        -:  369:  unsigned getNumSymbols() const { return numSymbols; }
        -:  370:  void setNumSymbols(unsigned d) { numSymbols = d; }
        -:  371:  MLIRContext *getContext() const { return context; }
        -:  372:
        -:  373:  /// Returns true if the idx'th result expression is a multiple of factor.
        -:  374:  bool isMultipleOf(unsigned idx, int64_t factor) const;
        -:  375:
        -:  376:  /// Resets this MutableAffineMap with 'map'.
        -:  377:  void reset(AffineMap map);
        -:  378:
        -:  379:  /// Simplify the (result) expressions in this map using analysis (used by
        -:  380:  //-simplify-affine-expr pass).
        -:  381:  void simplify();
        -:  382:  /// Get the AffineMap corresponding to this MutableAffineMap. Note that an
        -:  383:  /// AffineMap will be uniqued and stored in context, while a mutable one
        -:  384:  /// isn't.
        -:  385:  AffineMap getAffineMap() const;
        -:  386:
        -:  387:private:
        -:  388:  // Same meaning as AffineMap's fields.
        -:  389:  SmallVector<AffineExpr, 8> results;
        -:  390:  unsigned numDims = 0;
        -:  391:  unsigned numSymbols = 0;
        -:  392:  /// A pointer to the IR's context to store all newly created
        -:  393:  /// AffineExprStorage's.
        -:  394:  MLIRContext *context = nullptr;
        -:  395:};
        -:  396:
        -:  397:/// Simplifies an affine map by simplifying its underlying AffineExpr results.
        -:  398:AffineMap simplifyAffineMap(AffineMap map);
        -:  399:
        -:  400:/// Drop the dims that are not used.
        -:  401:AffineMap compressUnusedDims(AffineMap map);
        -:  402:
        -:  403:/// Drop the dims that are not used by any of the individual maps in `maps`.
        -:  404:/// Asserts that all maps in `maps` are normalized to the same number of
        -:  405:/// dims and symbols.
        -:  406:SmallVector<AffineMap> compressUnusedDims(ArrayRef<AffineMap> maps);
        -:  407:
        -:  408:/// Drop the dims that are not listed in `unusedDims`.
        -:  409:AffineMap compressDims(AffineMap map, const llvm::SmallBitVector &unusedDims);
        -:  410:
        -:  411:/// Drop the symbols that are not used.
        -:  412:AffineMap compressUnusedSymbols(AffineMap map);
        -:  413:
        -:  414:/// Drop the symbols that are not used by any of the individual maps in `maps`.
        -:  415:/// Asserts that all maps in `maps` are normalized to the same number of
        -:  416:/// dims and symbols.
        -:  417:SmallVector<AffineMap> compressUnusedSymbols(ArrayRef<AffineMap> maps);
        -:  418:
        -:  419:/// Drop the symbols that are not listed in `unusedSymbols`.
        -:  420:AffineMap compressSymbols(AffineMap map,
        -:  421:                          const llvm::SmallBitVector &unusedSymbols);
        -:  422:
        -:  423:/// Returns a map with the same dimension and symbol count as `map`, but whose
        -:  424:/// results are the unique affine expressions of `map`.
        -:  425:AffineMap removeDuplicateExprs(AffineMap map);
        -:  426:
        -:  427:/// Returns a map of codomain to domain dimensions such that the first codomain
        -:  428:/// dimension for a particular domain dimension is selected.
        -:  429:/// Returns an empty map if the input map is empty.
        -:  430:/// Returns null map (not empty map) if `map` is not invertible (i.e. `map` does
        -:  431:/// not contain a subset that is a permutation of full domain rank).
        -:  432:///
        -:  433:/// Prerequisites:
        -:  434:///   1. `map` has no symbols.
        -:  435:///
        -:  436:/// Example 1:
        -:  437:///
        -:  438:/// ```mlir
        -:  439:///    (d0, d1, d2) -> (d1, d1, d0, d2, d1, d2, d1, d0)
        -:  440:///                      0       2   3
        -:  441:/// ```
        -:  442:///
        -:  443:/// returns:
        -:  444:///
        -:  445:/// ```mlir
        -:  446:///    (d0, d1, d2, d3, d4, d5, d6, d7) -> (d2, d0, d3)
        -:  447:/// ```
        -:  448:///
        -:  449:/// Example 2:
        -:  450:///
        -:  451:/// ```mlir
        -:  452:///    (d0, d1, d2) -> (d1, d0 + d1, d0, d2, d1, d2, d1, d0)
        -:  453:///                      0            2   3
        -:  454:/// ```
        -:  455:///
        -:  456:/// returns:
        -:  457:///
        -:  458:/// ```mlir
        -:  459:///    (d0, d1, d2, d3, d4, d5, d6, d7) -> (d2, d0, d3)
        -:  460:/// ```
        -:  461:AffineMap inversePermutation(AffineMap map);
        -:  462:
        -:  463:/// Return the reverse map of a projected permutation where the projected
        -:  464:/// dimensions are transformed into 0s.
        -:  465:///
        -:  466:/// Prerequisites: `map` must be a projected permuation.
        -:  467:///
        -:  468:/// Example 1:
        -:  469:///
        -:  470:/// ```mlir
        -:  471:///    affine_map<(d0, d1, d2, d3) -> (d2, d0)>
        -:  472:/// ```
        -:  473:///
        -:  474:/// returns:
        -:  475:///
        -:  476:/// ```mlir
        -:  477:///    affine_map<(d0, d1) -> (d1, 0, d0, 0)>
        -:  478:/// ```
        -:  479:///
        -:  480:/// Example 2:
        -:  481:///
        -:  482:/// ```mlir
        -:  483:///    affine_map<(d0, d1, d2, d3) -> (d0, d3)>
        -:  484:/// ```
        -:  485:///
        -:  486:/// returns:
        -:  487:///
        -:  488:/// ```mlir
        -:  489:///    affine_map<(d0, d1) -> (d0, 0, 0, d1)>
        -:  490:/// ```
        -:  491:///
        -:  492:/// Example 3:
        -:  493:///
        -:  494:/// ```mlir
        -:  495:///    affine_map<(d0, d1, d2, d3) -> (d2)>
        -:  496:/// ```
        -:  497:///
        -:  498:/// returns:
        -:  499:///
        -:  500:/// ```mlir
        -:  501:///    affine_map<(d0) -> (0, 0, d0, 0)>
        -:  502:/// ```
        -:  503:/// Example 4:
        -:  504:///
        -:  505:/// ```mlir
        -:  506:///    affine_map<(d0, d1, d2) -> (d0, 0)>
        -:  507:/// ```
        -:  508:///
        -:  509:/// returns:
        -:  510:///
        -:  511:/// ```mlir
        -:  512:///    affine_map<(d0, d1) -> (d0, 0, 0)>
        -:  513:/// ```
        -:  514:AffineMap inverseAndBroadcastProjectedPermutation(AffineMap map);
        -:  515:
        -:  516:/// Concatenates a list of `maps` into a single AffineMap, stepping over
        -:  517:/// potentially empty maps. Assumes each of the underlying map has 0 symbols.
        -:  518:/// The resulting map has a number of dims equal to the max of `maps`' dims and
        -:  519:/// the concatenated results as its results.
        -:  520:/// Returns an empty map if all input `maps` are empty.
        -:  521:///
        -:  522:/// Example:
        -:  523:/// When applied to the following list of 3 affine maps,
        -:  524:///
        -:  525:/// ```mlir
        -:  526:///    {
        -:  527:///      (i, j, k) -> (i, k),
        -:  528:///      (i, j, k) -> (k, j),
        -:  529:///      (i, j, k) -> (i, j)
        -:  530:///    }
        -:  531:/// ```
        -:  532:///
        -:  533:/// Returns the map:
        -:  534:///
        -:  535:/// ```mlir
        -:  536:///     (i, j, k) -> (i, k, k, j, i, j)
        -:  537:/// ```
        -:  538:AffineMap concatAffineMaps(ArrayRef<AffineMap> maps);
        -:  539:
        -:  540:/// Returns the map that results from projecting out the dimensions specified in
        -:  541:/// `projectedDimensions`. The projected dimensions are set to 0.
        -:  542:///
        -:  543:/// Example:
        -:  544:/// 1) map                  : affine_map<(d0, d1, d2) -> (d0, d1)>
        -:  545:///    projected_dimensions : {2}
        -:  546:///    result               : affine_map<(d0, d1) -> (d0, d1)>
        -:  547:///
        -:  548:/// 2) map                  : affine_map<(d0, d1) -> (d0 + d1)>
        -:  549:///    projected_dimensions : {1}
        -:  550:///    result               : affine_map<(d0) -> (d0)>
        -:  551:///
        -:  552:/// 3) map                  : affine_map<(d0, d1, d2) -> (d0, d1)>
        -:  553:///    projected_dimensions : {1}
        -:  554:///    result               : affine_map<(d0, d1) -> (d0, 0)>
        -:  555:///
        -:  556:/// This function also compresses unused symbols away.
        -:  557:AffineMap getProjectedMap(AffineMap map,
        -:  558:                          const llvm::SmallBitVector &projectedDimensions);
        -:  559:
        -:  560:/// Apply a permutation from `map` to `source` and return the result.
        -:  561:template <typename T>
        -:  562:SmallVector<T> applyPermutationMap(AffineMap map, llvm::ArrayRef<T> source) {
        -:  563:  assert(map.isProjectedPermutation());
        -:  564:  assert(map.getNumInputs() == source.size());
        -:  565:  SmallVector<T> result;
        -:  566:  result.reserve(map.getNumResults());
        -:  567:  for (AffineExpr expr : map.getResults()) {
        -:  568:    if (auto dimExpr = expr.dyn_cast<AffineDimExpr>()) {
        -:  569:      result.push_back(source[dimExpr.getPosition()]);
        -:  570:    } else if (auto constExpr = expr.dyn_cast<AffineConstantExpr>()) {
        -:  571:      assert(constExpr.getValue() == 0 &&
        -:  572:             "Unexpected constant in projected permutation map");
        -:  573:      result.push_back(0);
        -:  574:    } else {
        -:  575:      llvm_unreachable("Unexpected result in projected permutation map");
        -:  576:    }
        -:  577:  }
        -:  578:  return result;
        -:  579:}
        -:  580:
        -:  581:/// Calculates maxmimum dimension and symbol positions from the expressions
        -:  582:/// in `exprsLists` and stores them in `maxDim` and `maxSym` respectively.
        -:  583:template <typename AffineExprContainer>
        -:  584:static void getMaxDimAndSymbol(ArrayRef<AffineExprContainer> exprsList,
        -:  585:                               int64_t &maxDim, int64_t &maxSym) {
        -:  586:  for (const auto &exprs : exprsList) {
        -:  587:    for (auto expr : exprs) {
        -:  588:      expr.walk([&maxDim, &maxSym](AffineExpr e) {
        -:  589:        if (auto d = e.dyn_cast<AffineDimExpr>())
        -:  590:          maxDim = std::max(maxDim, static_cast<int64_t>(d.getPosition()));
        -:  591:        if (auto s = e.dyn_cast<AffineSymbolExpr>())
        -:  592:          maxSym = std::max(maxSym, static_cast<int64_t>(s.getPosition()));
        -:  593:      });
        -:  594:    }
        -:  595:  }
        -:  596:}
        -:  597:
        -:  598:inline raw_ostream &operator<<(raw_ostream &os, AffineMap map) {
        -:  599:  map.print(os);
        -:  600:  return os;
        -:  601:}
        -:  602:
        -:  603:// Return a bitvector where each bit set indicates a dimension that is not used
        -:  604:// by any of the maps in the input array `maps`.
        -:  605:llvm::SmallBitVector getUnusedDimsBitVector(ArrayRef<AffineMap> maps);
        -:  606:
        -:  607:} // namespace mlir
        -:  608:
        -:  609:namespace llvm {
        -:  610:
        -:  611:// AffineExpr hash just like pointers
        -:  612:template <>
        -:  613:struct DenseMapInfo<mlir::AffineMap> {
        -:  614:  static mlir::AffineMap getEmptyKey() {
        -:  615:    auto *pointer = llvm::DenseMapInfo<void *>::getEmptyKey();
        -:  616:    return mlir::AffineMap(static_cast<mlir::AffineMap::ImplType *>(pointer));
        -:  617:  }
        -:  618:  static mlir::AffineMap getTombstoneKey() {
        -:  619:    auto *pointer = llvm::DenseMapInfo<void *>::getTombstoneKey();
        -:  620:    return mlir::AffineMap(static_cast<mlir::AffineMap::ImplType *>(pointer));
        -:  621:  }
        -:  622:  static unsigned getHashValue(mlir::AffineMap val) {
        -:  623:    return mlir::hash_value(val);
        -:  624:  }
        -:  625:  static bool isEqual(mlir::AffineMap LHS, mlir::AffineMap RHS) {
        -:  626:    return LHS == RHS;
        -:  627:  }
        -:  628:};
        -:  629:
        -:  630:} // namespace llvm
        -:  631:
        -:  632:#endif // MLIR_IR_AFFINEMAP_H
