        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/MemRefToLLVM/CMakeFiles/obj.MLIRMemRefToLLVM.dir/MemRefToLLVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/MemRefToLLVM/CMakeFiles/obj.MLIRMemRefToLLVM.dir/MemRefToLLVM.cpp.gcda
        -:    0:Runs:128636
        -:    1://===- MemRefToLLVM.cpp - MemRef to LLVM dialect conversion ---------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/MemRefToLLVM/MemRefToLLVM.h"
        -:   10:
        -:   11:#include "mlir/Analysis/DataLayoutAnalysis.h"
        -:   12:#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
        -:   13:#include "mlir/Conversion/LLVMCommon/Pattern.h"
        -:   14:#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
        -:   15:#include "mlir/Conversion/MemRefToLLVM/AllocLikeConversion.h"
        -:   16:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   17:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   18:#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
        -:   19:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   20:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   21:#include "mlir/IR/AffineMap.h"
        -:   22:#include "mlir/IR/BlockAndValueMapping.h"
        -:   23:#include "mlir/Pass/Pass.h"
        -:   24:#include "llvm/ADT/SmallBitVector.h"
        -:   25:
        -:   26:namespace mlir {
        -:   27:#define GEN_PASS_DEF_MEMREFTOLLVMCONVERSIONPASS
        -:   28:#include "mlir/Conversion/Passes.h.inc"
        -:   29:} // namespace mlir
        -:   30:
        -:   31:using namespace mlir;
        -:   32:
        -:   33:namespace {
        -:   34:
function _ZN12_GLOBAL__N_122isStaticStrideOrOffsetEl called 0 returned 0% blocks executed 0%
    #####:   35:bool isStaticStrideOrOffset(int64_t strideOrOffset) {
    #####:   36:  return !ShapedType::isDynamicStrideOrOffset(strideOrOffset);
        -:   37:}
        -:   38:
function _ZN12_GLOBAL__N_19getFreeFnEPN4mlir17LLVMTypeConverterENS0_8ModuleOpE called 0 returned 0% blocks executed 0%
    #####:   39:LLVM::LLVMFuncOp getFreeFn(LLVMTypeConverter *typeConverter, ModuleOp module) {
    #####:   40:  bool useGenericFn = typeConverter->getOptions().useGenericFunctions;
branch  0 never executed
branch  1 never executed
        -:   41:
    #####:   42:  if (useGenericFn)
branch  0 never executed
branch  1 never executed
    #####:   43:    return LLVM::lookupOrCreateGenericFreeFn(module);
call    0 never executed
        -:   44:
    #####:   45:  return LLVM::lookupOrCreateFreeFn(module);
call    0 never executed
        -:   46:}
        -:   47:
        -:   48:struct AllocOpLowering : public AllocLikeOpLLVMLowering {
     3126:   49:  AllocOpLowering(LLVMTypeConverter &converter)
     3126:   50:      : AllocLikeOpLLVMLowering(memref::AllocOp::getOperationName(),
     3126:   51:                                converter) {}
call    0 returned 100%
function _ZNK12_GLOBAL__N_115AllocOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueEPNS1_9OperationE called 0 returned 0% blocks executed 0%
    #####:   52:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:   53:                                          Location loc, Value sizeBytes,
        -:   54:                                          Operation *op) const override {
    #####:   55:    return allocateBufferManuallyAlign(
        -:   56:        rewriter, loc, sizeBytes, op,
    #####:   57:        getAlignment(rewriter, loc, cast<memref::AllocOp>(op)));
call    0 never executed
call    1 never executed
call    2 never executed
        -:   58:  }
        -:   59:};
        -:   60:
        -:   61:struct AlignedAllocOpLowering : public AllocLikeOpLLVMLowering {
function _ZN12_GLOBAL__N_122AlignedAllocOpLoweringC2ERN4mlir17LLVMTypeConverterE called 0 returned 0% blocks executed 0%
    #####:   62:  AlignedAllocOpLowering(LLVMTypeConverter &converter)
    #####:   63:      : AllocLikeOpLLVMLowering(memref::AllocOp::getOperationName(),
    #####:   64:                                converter) {}
call    0 never executed
call    1 never executed
function _ZNK12_GLOBAL__N_122AlignedAllocOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueEPNS1_9OperationE called 0 returned 0% blocks executed 0%
    #####:   65:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:   66:                                          Location loc, Value sizeBytes,
        -:   67:                                          Operation *op) const override {
    #####:   68:    Value ptr = allocateBufferAutoAlign(
        -:   69:        rewriter, loc, sizeBytes, op, &defaultLayout,
        -:   70:        alignedAllocationGetAlignment(rewriter, loc, cast<memref::AllocOp>(op),
    #####:   71:                                      &defaultLayout));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   72:    return std::make_tuple(ptr, ptr);
        -:   73:  }
        -:   74:
        -:   75:private:
        -:   76:  /// Default layout to use in absence of the corresponding analysis.
        -:   77:  DataLayout defaultLayout;
        -:   78:};
        -:   79:
        -:   80:struct AllocaOpLowering : public AllocLikeOpLLVMLowering {
     3126:   81:  AllocaOpLowering(LLVMTypeConverter &converter)
     3126:   82:      : AllocLikeOpLLVMLowering(memref::AllocaOp::getOperationName(),
     3126:   83:                                converter) {}
call    0 returned 100%
        -:   84:
        -:   85:  /// Allocates the underlying buffer using the right call. `allocatedBytePtr`
        -:   86:  /// is set to null for stack allocations. `accessAlignment` is set if
        -:   87:  /// alignment is needed post allocation (for eg. in conjunction with malloc).
function _ZNK12_GLOBAL__N_116AllocaOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueEPNS1_9OperationE called 0 returned 0% blocks executed 0%
    #####:   88:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:   89:                                          Location loc, Value sizeBytes,
        -:   90:                                          Operation *op) const override {
        -:   91:
        -:   92:    // With alloca, one gets a pointer to the element type right away.
        -:   93:    // For stack allocations.
    #####:   94:    auto allocaOp = cast<memref::AllocaOp>(op);
call    0 never executed
    #####:   95:    auto elementPtrType = this->getElementPtrType(allocaOp.getType());
call    0 never executed
call    1 never executed
        -:   96:
    #####:   97:    auto allocatedElementPtr = rewriter.create<LLVM::AllocaOp>(
    #####:   98:        loc, elementPtrType, sizeBytes, allocaOp.getAlignment().value_or(0));
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:   99:
    #####:  100:    return std::make_tuple(allocatedElementPtr, allocatedElementPtr);
        -:  101:  }
        -:  102:};
        -:  103:
        -:  104:/// The base class for lowering realloc op, to support the implementation of
        -:  105:/// realloc via allocation methods that may or may not support alignment.
        -:  106:/// A derived class should provide an implementation of allocateBuffer using
        -:  107:/// the underline allocation methods.
        -:  108:struct ReallocOpLoweringBase : public AllocationOpLLVMLowering {
        -:  109:  using OpAdaptor = typename memref::ReallocOp::Adaptor;
        -:  110:
    3126*:  111:  ReallocOpLoweringBase(LLVMTypeConverter &converter)
    6252*:  112:      : AllocationOpLLVMLowering(memref::ReallocOp::getOperationName(),
    3126*:  113:                                 converter) {}
        -:  114:
        -:  115:  /// Allocates the new buffer. Returns the allocated pointer and the
        -:  116:  /// aligned pointer.
        -:  117:  virtual std::tuple<Value, Value>
        -:  118:  allocateBuffer(ConversionPatternRewriter &rewriter, Location loc,
        -:  119:                 Value sizeBytes, memref::ReallocOp op) const = 0;
        -:  120:
        -:  121:  LogicalResult
function _ZNK12_GLOBAL__N_121ReallocOpLoweringBase15matchAndRewriteEPN4mlir9OperationEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  122:  matchAndRewrite(Operation *op, ArrayRef<Value> operands,
        -:  123:                  ConversionPatternRewriter &rewriter) const final {
    #####:  124:    return matchAndRewrite(cast<memref::ReallocOp>(op),
call    0 never executed
        -:  125:                           OpAdaptor(operands, op->getAttrDictionary()),
    #####:  126:                           rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  127:  }
        -:  128:
        -:  129:  // A `realloc` is converted as follows:
        -:  130:  //   If new_size > old_size
        -:  131:  //     1. allocates a new buffer
        -:  132:  //     2. copies the content of the old buffer to the new buffer
        -:  133:  //     3. release the old buffer
        -:  134:  //     3. updates the buffer pointers in the memref descriptor
        -:  135:  //   Update the size in the memref descriptor
        -:  136:  // Alignment request is handled by allocating `alignment` more bytes than
        -:  137:  // requested and shifting the aligned pointer relative to the allocated
        -:  138:  // memory.
function _ZNK12_GLOBAL__N_121ReallocOpLoweringBase15matchAndRewriteEN4mlir6memref9ReallocOpENS2_16ReallocOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  139:  LogicalResult matchAndRewrite(memref::ReallocOp op, OpAdaptor adaptor,
        -:  140:                                ConversionPatternRewriter &rewriter) const {
    #####:  141:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  142:    Location loc = op.getLoc();
call    0 never executed
        -:  143:
    #####:  144:    auto computeNumElements =
function _ZZNK12_GLOBAL__N_121ReallocOpLoweringBase15matchAndRewriteEN4mlir6memref9ReallocOpENS2_16ReallocOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_10MemRefTypeEN4llvm12function_refIFNS1_5ValueEvEEEE_clES7_SC_ called 0 returned 0% blocks executed 0%
    #####:  145:        [&](MemRefType type, function_ref<Value()> getDynamicSize) -> Value {
        -:  146:      // Compute number of elements.
    #####:  147:      int64_t size = type.getShape()[0];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  148:      Value numElements = ((size == ShapedType::kDynamicSize)
    #####:  149:                               ? getDynamicSize()
call    0 never executed
    #####:  150:                               : createIndexConstant(rewriter, loc, size));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  151:      Type indexType = getIndexType();
call    0 never executed
    #####:  152:      if (numElements.getType() != indexType)
branch  0 never executed
branch  1 never executed
    #####:  153:        numElements = typeConverter->materializeTargetConversion(
call    0 never executed
    #####:  154:            rewriter, loc, indexType, numElements);
call    0 never executed
    #####:  155:      return numElements;
    #####:  156:    };
        -:  157:
    #####:  158:    MemRefDescriptor desc(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####:  159:    Value oldDesc = desc;
call    0 never executed
        -:  160:
        -:  161:    // Split the block right before the current op into two blocks.
    #####:  162:    Block *currentBlock = rewriter.getInsertionBlock();
call    0 never executed
    #####:  163:    Block *block =
    #####:  164:        rewriter.splitBlock(currentBlock, rewriter.getInsertionPoint());
call    0 never executed
        -:  165:    // Add a block argument by creating an empty block with the argument type
        -:  166:    // and then merging the block into the empty block.
    #####:  167:    Block *endBlock = rewriter.createBlock(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
    #####:  168:        block->getParent(), Region::iterator(block), oldDesc.getType(), loc);
call    0 never executed
    #####:  169:    rewriter.mergeBlocks(block, endBlock, {});
call    0 never executed
call    1 never executed
        -:  170:    // Add a new block for the true branch of the conditional statement we will
        -:  171:    // add.
    #####:  172:    Block *trueBlock = rewriter.createBlock(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  173:        currentBlock->getParent(), std::next(Region::iterator(currentBlock)));
        -:  174:
    #####:  175:    rewriter.setInsertionPointToEnd(currentBlock);
call    0 never executed
    #####:  176:    Value src = op.getSource();
call    0 never executed
    #####:  177:    auto srcType = src.getType().dyn_cast<MemRefType>();
call    0 never executed
    #####:  178:    Value srcNumElements = computeNumElements(
    #####:  179:        srcType, [&]() -> Value { return desc.size(rewriter, loc, 0); });
call    0 never executed
call    1 never executed
    #####:  180:    auto dstType = op.getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####:  181:    Value dstNumElements = computeNumElements(
    #####:  182:        dstType, [&]() -> Value { return op.getDynamicResultSize(); });
call    0 never executed
call    1 never executed
    #####:  183:    Value cond = rewriter.create<LLVM::ICmpOp>(
    #####:  184:        loc, IntegerType::get(rewriter.getContext(), 1),
    #####:  185:        LLVM::ICmpPredicate::ugt, dstNumElements, srcNumElements);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  186:    rewriter.create<LLVM::CondBrOp>(loc, cond, trueBlock, ArrayRef<Value>(),
    #####:  187:                                    endBlock, ValueRange{oldDesc});
call    0 never executed
call    1 never executed
        -:  188:
    #####:  189:    rewriter.setInsertionPointToStart(trueBlock);
call    0 never executed
    #####:  190:    Value sizeInBytes = getSizeInBytes(loc, dstType.getElementType(), rewriter);
call    0 never executed
call    1 never executed
        -:  191:    // Compute total byte size.
    #####:  192:    auto dstByteSize =
    #####:  193:        rewriter.create<LLVM::MulOp>(loc, dstNumElements, sizeInBytes);
call    0 never executed
        -:  194:    // Since the src and dst memref are guarantee to have the same
        -:  195:    // element type by the verifier, it is safe here to reuse the
        -:  196:    // type size computed from dst memref.
    #####:  197:    auto srcByteSize =
    #####:  198:        rewriter.create<LLVM::MulOp>(loc, srcNumElements, sizeInBytes);
call    0 never executed
        -:  199:    // Allocate a new buffer.
    #####:  200:    auto [dstRawPtr, dstAlignedPtr] =
call    0 never executed
    #####:  201:        allocateBuffer(rewriter, loc, dstByteSize, op);
call    0 never executed
call    1 never executed
        -:  202:    // Copy the data from the old buffer to the new buffer.
    #####:  203:    Value srcAlignedPtr = desc.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  204:    Value isVolatile =
    #####:  205:        rewriter.create<LLVM::ConstantOp>(loc, rewriter.getBoolAttr(false));
call    0 never executed
call    1 never executed
call    2 never executed
function _ZZNK12_GLOBAL__N_121ReallocOpLoweringBase15matchAndRewriteEN4mlir6memref9ReallocOpENS2_16ReallocOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_5ValueEE2_clES7_ called 0 returned 0% blocks executed 0%
    #####:  206:    auto toVoidPtr = [&](Value ptr) -> Value {
    #####:  207:      return rewriter.create<LLVM::BitcastOp>(loc, getVoidPtrType(), ptr);
call    0 never executed
call    1 never executed
    #####:  208:    };
    #####:  209:    rewriter.create<LLVM::MemcpyOp>(loc, toVoidPtr(dstAlignedPtr),
call    0 never executed
    #####:  210:                                    toVoidPtr(srcAlignedPtr), srcByteSize,
call    0 never executed
    #####:  211:                                    isVolatile);
call    0 never executed
        -:  212:    // Deallocate the old buffer.
    #####:  213:    LLVM::LLVMFuncOp freeFunc =
    #####:  214:        getFreeFn(getTypeConverter(), op->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  215:    rewriter.create<LLVM::CallOp>(loc, freeFunc,
    #####:  216:                                  toVoidPtr(desc.allocatedPtr(rewriter, loc)));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  217:    // Replace the old buffer addresses in the MemRefDescriptor with the new
        -:  218:    // buffer addresses.
    #####:  219:    desc.setAllocatedPtr(rewriter, loc, dstRawPtr);
call    0 never executed
    #####:  220:    desc.setAlignedPtr(rewriter, loc, dstAlignedPtr);
call    0 never executed
    #####:  221:    rewriter.create<LLVM::BrOp>(loc, Value(desc), endBlock);
call    0 never executed
        -:  222:
    #####:  223:    rewriter.setInsertionPoint(op);
call    0 never executed
        -:  224:    // Update the memref size.
    #####:  225:    MemRefDescriptor newDesc(endBlock->getArgument(0));
call    0 never executed
    #####:  226:    newDesc.setSize(rewriter, loc, 0, dstNumElements);
call    0 never executed
    #####:  227:    rewriter.replaceOp(op, {newDesc});
call    0 never executed
call    1 never executed
    #####:  228:    return success();
branch  0 never executed
branch  1 never executed
        -:  229:  }
        -:  230:
        -:  231:private:
        -:  232:  using ConvertToLLVMPattern::matchAndRewrite;
        -:  233:};
        -:  234:
        -:  235:struct ReallocOpLowering : public ReallocOpLoweringBase {
     3126:  236:  ReallocOpLowering(LLVMTypeConverter &converter)
     3126:  237:      : ReallocOpLoweringBase(converter) {}
call    0 returned 100%
function _ZNK12_GLOBAL__N_117ReallocOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueENS1_6memref9ReallocOpE called 0 returned 0% blocks executed 0%
    #####:  238:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:  239:                                          Location loc, Value sizeBytes,
        -:  240:                                          memref::ReallocOp op) const override {
    #####:  241:    return allocateBufferManuallyAlign(rewriter, loc, sizeBytes, op,
    #####:  242:                                       getAlignment(rewriter, loc, op));
call    0 never executed
call    1 never executed
        -:  243:  }
        -:  244:};
        -:  245:
        -:  246:struct AlignedReallocOpLowering : public ReallocOpLoweringBase {
function _ZN12_GLOBAL__N_124AlignedReallocOpLoweringC2ERN4mlir17LLVMTypeConverterE called 0 returned 0% blocks executed 0%
    #####:  247:  AlignedReallocOpLowering(LLVMTypeConverter &converter)
    #####:  248:      : ReallocOpLoweringBase(converter) {}
call    0 never executed
call    1 never executed
function _ZNK12_GLOBAL__N_124AlignedReallocOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueENS1_6memref9ReallocOpE called 0 returned 0% blocks executed 0%
    #####:  249:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:  250:                                          Location loc, Value sizeBytes,
        -:  251:                                          memref::ReallocOp op) const override {
    #####:  252:    Value ptr = allocateBufferAutoAlign(
        -:  253:        rewriter, loc, sizeBytes, op, &defaultLayout,
    #####:  254:        alignedAllocationGetAlignment(rewriter, loc, op, &defaultLayout));
call    0 never executed
call    1 never executed
    #####:  255:    return std::make_tuple(ptr, ptr);
        -:  256:  }
        -:  257:
        -:  258:private:
        -:  259:  /// Default layout to use in absence of the corresponding analysis.
        -:  260:  DataLayout defaultLayout;
        -:  261:};
        -:  262:
        -:  263:struct AllocaScopeOpLowering
        -:  264:    : public ConvertOpToLLVMPattern<memref::AllocaScopeOp> {
     3126:  265:  using ConvertOpToLLVMPattern<memref::AllocaScopeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  266:
        -:  267:  LogicalResult
function _ZNK12_GLOBAL__N_121AllocaScopeOpLowering15matchAndRewriteEN4mlir6memref13AllocaScopeOpENS2_20AllocaScopeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  268:  matchAndRewrite(memref::AllocaScopeOp allocaScopeOp, OpAdaptor adaptor,
        -:  269:                  ConversionPatternRewriter &rewriter) const override {
    #####:  270:    OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  271:    Location loc = allocaScopeOp.getLoc();
call    0 never executed
        -:  272:
        -:  273:    // Split the current block before the AllocaScopeOp to create the inlining
        -:  274:    // point.
    #####:  275:    auto *currentBlock = rewriter.getInsertionBlock();
    #####:  276:    auto *remainingOpsBlock =
    #####:  277:        rewriter.splitBlock(currentBlock, rewriter.getInsertionPoint());
call    0 never executed
    #####:  278:    Block *continueBlock;
    #####:  279:    if (allocaScopeOp.getNumResults() == 0) {
branch  0 never executed
branch  1 never executed
    #####:  280:      continueBlock = remainingOpsBlock;
        -:  281:    } else {
    #####:  282:      continueBlock = rewriter.createBlock(
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  283:          remainingOpsBlock, allocaScopeOp.getResultTypes(),
    #####:  284:          SmallVector<Location>(allocaScopeOp->getNumResults(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  285:                                allocaScopeOp.getLoc()));
call    0 never executed
    #####:  286:      rewriter.create<LLVM::BrOp>(loc, ValueRange(), remainingOpsBlock);
call    0 never executed
call    1 never executed
        -:  287:    }
        -:  288:
        -:  289:    // Inline body region.
    #####:  290:    Block *beforeBody = &allocaScopeOp.getBodyRegion().front();
call    0 never executed
call    1 never executed
    #####:  291:    Block *afterBody = &allocaScopeOp.getBodyRegion().back();
call    0 never executed
call    1 never executed
    #####:  292:    rewriter.inlineRegionBefore(allocaScopeOp.getBodyRegion(), continueBlock);
call    0 never executed
call    1 never executed
        -:  293:
        -:  294:    // Save stack and then branch into the body of the region.
    #####:  295:    rewriter.setInsertionPointToEnd(currentBlock);
call    0 never executed
    #####:  296:    auto stackSaveOp =
    #####:  297:        rewriter.create<LLVM::StackSaveOp>(loc, getVoidPtrType());
call    0 never executed
call    1 never executed
    #####:  298:    rewriter.create<LLVM::BrOp>(loc, ValueRange(), beforeBody);
call    0 never executed
call    1 never executed
        -:  299:
        -:  300:    // Replace the alloca_scope return with a branch that jumps out of the body.
        -:  301:    // Stack restore before leaving the body region.
    #####:  302:    rewriter.setInsertionPointToEnd(afterBody);
call    0 never executed
    #####:  303:    auto returnOp =
    #####:  304:        cast<memref::AllocaScopeReturnOp>(afterBody->getTerminator());
call    0 never executed
call    1 never executed
    #####:  305:    auto branchOp = rewriter.replaceOpWithNewOp<LLVM::BrOp>(
    #####:  306:        returnOp, returnOp.getResults(), continueBlock);
call    0 never executed
call    1 never executed
        -:  307:
        -:  308:    // Insert stack restore before jumping out the body of the region.
    #####:  309:    rewriter.setInsertionPoint(branchOp);
call    0 never executed
    #####:  310:    rewriter.create<LLVM::StackRestoreOp>(loc, stackSaveOp);
call    0 never executed
        -:  311:
        -:  312:    // Replace the op with values return from the body region.
    #####:  313:    rewriter.replaceOp(allocaScopeOp, continueBlock->getArguments());
call    0 never executed
call    1 never executed
        -:  314:
    #####:  315:    return success();
branch  0 never executed
branch  1 never executed
        -:  316:  }
        -:  317:};
        -:  318:
        -:  319:struct AssumeAlignmentOpLowering
        -:  320:    : public ConvertOpToLLVMPattern<memref::AssumeAlignmentOp> {
        -:  321:  using ConvertOpToLLVMPattern<
     3126:  322:      memref::AssumeAlignmentOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  323:
        -:  324:  LogicalResult
function _ZNK12_GLOBAL__N_125AssumeAlignmentOpLowering15matchAndRewriteEN4mlir6memref17AssumeAlignmentOpENS2_24AssumeAlignmentOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  325:  matchAndRewrite(memref::AssumeAlignmentOp op, OpAdaptor adaptor,
        -:  326:                  ConversionPatternRewriter &rewriter) const override {
    #####:  327:    Value memref = adaptor.getMemref();
call    0 never executed
    #####:  328:    unsigned alignment = op.getAlignment();
call    0 never executed
    #####:  329:    auto loc = op.getLoc();
call    0 never executed
        -:  330:
    #####:  331:    MemRefDescriptor memRefDescriptor(memref);
call    0 never executed
    #####:  332:    Value ptr = memRefDescriptor.alignedPtr(rewriter, memref.getLoc());
call    0 never executed
call    1 never executed
        -:  333:
        -:  334:    // Emit llvm.assume(memref.alignedPtr & (alignment - 1) == 0). Notice that
        -:  335:    // the asserted memref.alignedPtr isn't used anywhere else, as the real
        -:  336:    // users like load/store/views always re-extract memref.alignedPtr as they
        -:  337:    // get lowered.
        -:  338:    //
        -:  339:    // This relies on LLVM's CSE optimization (potentially after SROA), since
        -:  340:    // after CSE all memref.alignedPtr instances get de-duplicated into the same
        -:  341:    // pointer SSA value.
    #####:  342:    auto intPtrType =
    #####:  343:        getIntPtrType(memRefDescriptor.getElementPtrType().getAddressSpace());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  344:    Value zero = createIndexAttrConstant(rewriter, loc, intPtrType, 0);
call    0 never executed
    #####:  345:    Value mask =
    #####:  346:        createIndexAttrConstant(rewriter, loc, intPtrType, alignment - 1);
call    0 never executed
    #####:  347:    Value ptrValue = rewriter.create<LLVM::PtrToIntOp>(loc, intPtrType, ptr);
call    0 never executed
call    1 never executed
    #####:  348:    rewriter.create<LLVM::AssumeOp>(
    #####:  349:        loc, rewriter.create<LLVM::ICmpOp>(
    #####:  350:                 loc, LLVM::ICmpPredicate::eq,
    #####:  351:                 rewriter.create<LLVM::AndOp>(loc, ptrValue, mask), zero));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  352:
    #####:  353:    rewriter.eraseOp(op);
call    0 never executed
    #####:  354:    return success();
        -:  355:  }
        -:  356:};
        -:  357:
        -:  358:// A `dealloc` is converted into a call to `free` on the underlying data buffer.
        -:  359:// The memref descriptor being an SSA value, there is no need to clean it up
        -:  360:// in any way.
        -:  361:struct DeallocOpLowering : public ConvertOpToLLVMPattern<memref::DeallocOp> {
        -:  362:  using ConvertOpToLLVMPattern<memref::DeallocOp>::ConvertOpToLLVMPattern;
        -:  363:
function _ZN12_GLOBAL__N_117DeallocOpLoweringC2ERN4mlir17LLVMTypeConverterE called 3126 returned 100% blocks executed 100%
     3126:  364:  explicit DeallocOpLowering(LLVMTypeConverter &converter)
     3126:  365:      : ConvertOpToLLVMPattern<memref::DeallocOp>(converter) {}
call    0 returned 100%
call    1 returned 100%
        -:  366:
        -:  367:  LogicalResult
function _ZNK12_GLOBAL__N_117DeallocOpLowering15matchAndRewriteEN4mlir6memref9DeallocOpENS2_16DeallocOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  368:  matchAndRewrite(memref::DeallocOp op, OpAdaptor adaptor,
        -:  369:                  ConversionPatternRewriter &rewriter) const override {
        -:  370:    // Insert the `free` declaration if it is not already present.
    #####:  371:    LLVM::LLVMFuncOp freeFunc =
    #####:  372:        getFreeFn(getTypeConverter(), op->getParentOfType<ModuleOp>());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  373:    MemRefDescriptor memref(adaptor.getMemref());
call    0 never executed
call    1 never executed
    #####:  374:    Value casted = rewriter.create<LLVM::BitcastOp>(
    #####:  375:        op.getLoc(), getVoidPtrType(),
call    0 never executed
    #####:  376:        memref.allocatedPtr(rewriter, op.getLoc()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  377:    rewriter.replaceOpWithNewOp<LLVM::CallOp>(op, freeFunc, casted);
call    0 never executed
    #####:  378:    return success();
        -:  379:  }
        -:  380:};
        -:  381:
        -:  382:// A `dim` is converted to a constant for static sizes and to an access to the
        -:  383:// size stored in the memref descriptor for dynamic sizes.
        -:  384:struct DimOpLowering : public ConvertOpToLLVMPattern<memref::DimOp> {
     3126:  385:  using ConvertOpToLLVMPattern<memref::DimOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  386:
        -:  387:  LogicalResult
function _ZNK12_GLOBAL__N_113DimOpLowering15matchAndRewriteEN4mlir6memref5DimOpENS2_12DimOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  388:  matchAndRewrite(memref::DimOp dimOp, OpAdaptor adaptor,
        -:  389:                  ConversionPatternRewriter &rewriter) const override {
    #####:  390:    Type operandType = dimOp.getSource().getType();
call    0 never executed
call    1 never executed
    #####:  391:    if (operandType.isa<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  392:      rewriter.replaceOp(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  393:          dimOp, {extractSizeOfUnrankedMemRef(
    #####:  394:                     operandType, dimOp, adaptor.getOperands(), rewriter)});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  395:
    #####:  396:      return success();
        -:  397:    }
    #####:  398:    if (operandType.isa<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  399:      rewriter.replaceOp(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  400:          dimOp, {extractSizeOfRankedMemRef(operandType, dimOp,
    #####:  401:                                            adaptor.getOperands(), rewriter)});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  402:      return success();
        -:  403:    }
    #####:  404:    llvm_unreachable("expected MemRefType or UnrankedMemRefType");
call    0 never executed
        -:  405:  }
        -:  406:
        -:  407:private:
function _ZNK12_GLOBAL__N_113DimOpLowering27extractSizeOfUnrankedMemRefEN4mlir4TypeENS1_6memref5DimOpENS3_12DimOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  408:  Value extractSizeOfUnrankedMemRef(Type operandType, memref::DimOp dimOp,
        -:  409:                                    OpAdaptor adaptor,
        -:  410:                                    ConversionPatternRewriter &rewriter) const {
    #####:  411:    Location loc = dimOp.getLoc();
call    0 never executed
        -:  412:
    #####:  413:    auto unrankedMemRefType = operandType.cast<UnrankedMemRefType>();
call    0 never executed
    #####:  414:    auto scalarMemRefType =
    #####:  415:        MemRefType::get({}, unrankedMemRefType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  416:    unsigned addressSpace = unrankedMemRefType.getMemorySpaceAsInt();
call    0 never executed
        -:  417:
        -:  418:    // Extract pointer to the underlying ranked descriptor and bitcast it to a
        -:  419:    // memref<element_type> descriptor pointer to minimize the number of GEP
        -:  420:    // operations.
    #####:  421:    UnrankedMemRefDescriptor unrankedDesc(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####:  422:    Value underlyingRankedDesc = unrankedDesc.memRefDescPtr(rewriter, loc);
call    0 never executed
    #####:  423:    Value scalarMemRefDescPtr = rewriter.create<LLVM::BitcastOp>(
        -:  424:        loc,
    #####:  425:        LLVM::LLVMPointerType::get(typeConverter->convertType(scalarMemRefType),
    #####:  426:                                   addressSpace),
call    0 never executed
call    1 never executed
    #####:  427:        underlyingRankedDesc);
call    0 never executed
call    1 never executed
        -:  428:
        -:  429:    // Get pointer to offset field of memref<element_type> descriptor.
    #####:  430:    Type indexPtrTy = LLVM::LLVMPointerType::get(
    #####:  431:        getTypeConverter()->getIndexType(), addressSpace);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  432:    Value offsetPtr = rewriter.create<LLVM::GEPOp>(
    #####:  433:        loc, indexPtrTy, scalarMemRefDescPtr, ArrayRef<LLVM::GEPArg>{0, 2});
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  434:
        -:  435:    // The size value that we have to extract can be obtained using GEPop with
        -:  436:    // `dimOp.index() + 1` index argument.
    #####:  437:    Value idxPlusOne = rewriter.create<LLVM::AddOp>(
    #####:  438:        loc, createIndexConstant(rewriter, loc, 1), adaptor.getIndex());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  439:    Value sizePtr =
    #####:  440:        rewriter.create<LLVM::GEPOp>(loc, indexPtrTy, offsetPtr, idxPlusOne);
call    0 never executed
call    1 never executed
    #####:  441:    return rewriter.create<LLVM::LoadOp>(loc, sizePtr);
call    0 never executed
        -:  442:  }
        -:  443:
        -:  444:  Optional<int64_t> getConstantDimIndex(memref::DimOp dimOp) const {
        -:  445:    if (Optional<int64_t> idx = dimOp.getConstantIndex())
        -:  446:      return idx;
        -:  447:
        -:  448:    if (auto constantOp = dimOp.getIndex().getDefiningOp<LLVM::ConstantOp>())
        -:  449:      return constantOp.getValue()
        -:  450:          .cast<IntegerAttr>()
        -:  451:          .getValue()
        -:  452:          .getSExtValue();
        -:  453:
        -:  454:    return llvm::None;
        -:  455:  }
        -:  456:
function _ZNK12_GLOBAL__N_113DimOpLowering25extractSizeOfRankedMemRefEN4mlir4TypeENS1_6memref5DimOpENS3_12DimOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  457:  Value extractSizeOfRankedMemRef(Type operandType, memref::DimOp dimOp,
        -:  458:                                  OpAdaptor adaptor,
        -:  459:                                  ConversionPatternRewriter &rewriter) const {
    #####:  460:    Location loc = dimOp.getLoc();
call    0 never executed
        -:  461:
        -:  462:    // Take advantage if index is constant.
    #####:  463:    MemRefType memRefType = operandType.cast<MemRefType>();
call    0 never executed
    #####:  464:    if (Optional<int64_t> index = getConstantDimIndex(dimOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  465:      int64_t i = *index;
call    0 never executed
    #####:  466:      if (memRefType.isDynamicDim(i)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  467:        // extract dynamic size from the memref descriptor.
    #####:  468:        MemRefDescriptor descriptor(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####:  469:        return descriptor.size(rewriter, loc, i);
call    0 never executed
        -:  470:      }
        -:  471:      // Use constant for static size.
    #####:  472:      int64_t dimSize = memRefType.getDimSize(i);
call    0 never executed
    #####:  473:      return createIndexConstant(rewriter, loc, dimSize);
call    0 never executed
        -:  474:    }
    #####:  475:    Value index = adaptor.getIndex();
call    0 never executed
    #####:  476:    int64_t rank = memRefType.getRank();
call    0 never executed
    #####:  477:    MemRefDescriptor memrefDescriptor(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####:  478:    return memrefDescriptor.size(rewriter, loc, index, rank);
call    0 never executed
        -:  479:  }
        -:  480:};
        -:  481:
        -:  482:/// Common base for load and store operations on MemRefs. Restricts the match
        -:  483:/// to supported MemRef types. Provides functionality to emit code accessing a
        -:  484:/// specific element of the underlying data buffer.
        -:  485:template <typename Derived>
        -:  486:struct LoadStoreOpLowering : public ConvertOpToLLVMPattern<Derived> {
    15630:  487:  using ConvertOpToLLVMPattern<Derived>::ConvertOpToLLVMPattern;
        -:  488:  using ConvertOpToLLVMPattern<Derived>::isConvertibleAndHasIdentityMaps;
        -:  489:  using Base = LoadStoreOpLowering<Derived>;
        -:  490:
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
        -:  494:  }
------------------
_ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref18GenericAtomicRMWOpEE5matchES3_:
function _ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref18GenericAtomicRMWOpEE5matchES3_ called 0 returned 0% blocks executed 0%
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
call    0 never executed
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:  }
------------------
_ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref6LoadOpEE5matchES3_:
function _ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref6LoadOpEE5matchES3_ called 0 returned 0% blocks executed 0%
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
call    0 never executed
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:  }
------------------
_ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref7StoreOpEE5matchES3_:
function _ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref7StoreOpEE5matchES3_ called 0 returned 0% blocks executed 0%
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
call    0 never executed
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:  }
------------------
_ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref10PrefetchOpEE5matchES3_:
function _ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref10PrefetchOpEE5matchES3_ called 0 returned 0% blocks executed 0%
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
call    0 never executed
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:  }
------------------
_ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref11AtomicRMWOpEE5matchES3_:
function _ZNK12_GLOBAL__N_119LoadStoreOpLoweringIN4mlir6memref11AtomicRMWOpEE5matchES3_ called 0 returned 0% blocks executed 0%
    #####:  491:  LogicalResult match(Derived op) const override {
    #####:  492:    MemRefType type = op.getMemRefType();
call    0 never executed
    #####:  493:    return isConvertibleAndHasIdentityMaps(type) ? success() : failure();
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:  }
------------------
        -:  495:};
        -:  496:
        -:  497:/// Wrap a llvm.cmpxchg operation in a while loop so that the operation can be
        -:  498:/// retried until it succeeds in atomically storing a new value into memory.
        -:  499:///
        -:  500:///      +---------------------------------+
        -:  501:///      |   <code before the AtomicRMWOp> |
        -:  502:///      |   <compute initial %loaded>     |
        -:  503:///      |   cf.br loop(%loaded)              |
        -:  504:///      +---------------------------------+
        -:  505:///             |
        -:  506:///  -------|   |
        -:  507:///  |      v   v
        -:  508:///  |   +--------------------------------+
        -:  509:///  |   | loop(%loaded):                 |
        -:  510:///  |   |   <body contents>              |
        -:  511:///  |   |   %pair = cmpxchg              |
        -:  512:///  |   |   %ok = %pair[0]               |
        -:  513:///  |   |   %new = %pair[1]              |
        -:  514:///  |   |   cf.cond_br %ok, end, loop(%new) |
        -:  515:///  |   +--------------------------------+
        -:  516:///  |          |        |
        -:  517:///  |-----------        |
        -:  518:///                      v
        -:  519:///      +--------------------------------+
        -:  520:///      | end:                           |
        -:  521:///      |   <code after the AtomicRMWOp> |
        -:  522:///      +--------------------------------+
        -:  523:///
        -:  524:struct GenericAtomicRMWOpLowering
        -:  525:    : public LoadStoreOpLowering<memref::GenericAtomicRMWOp> {
     3126:  526:  using Base::Base;
call    0 returned 100%
        -:  527:
        -:  528:  LogicalResult
function _ZNK12_GLOBAL__N_126GenericAtomicRMWOpLowering15matchAndRewriteEN4mlir6memref18GenericAtomicRMWOpENS2_25GenericAtomicRMWOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  529:  matchAndRewrite(memref::GenericAtomicRMWOp atomicOp, OpAdaptor adaptor,
        -:  530:                  ConversionPatternRewriter &rewriter) const override {
    #####:  531:    auto loc = atomicOp.getLoc();
call    0 never executed
    #####:  532:    Type valueType = typeConverter->convertType(atomicOp.getResult().getType());
call    0 never executed
call    1 never executed
        -:  533:
        -:  534:    // Split the block into initial, loop, and ending parts.
    #####:  535:    auto *initBlock = rewriter.getInsertionBlock();
call    0 never executed
    #####:  536:    auto *loopBlock = rewriter.createBlock(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
        -:  537:        initBlock->getParent(), std::next(Region::iterator(initBlock)),
    #####:  538:        valueType, loc);
    #####:  539:    auto *endBlock = rewriter.createBlock(
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  540:        loopBlock->getParent(), std::next(Region::iterator(loopBlock)));
        -:  541:
        -:  542:    // Operations range to be moved to `endBlock`.
    #####:  543:    auto opsToMoveStart = atomicOp->getIterator();
call    0 never executed
    #####:  544:    auto opsToMoveEnd = initBlock->back().getIterator();
call    0 never executed
call    1 never executed
        -:  545:
        -:  546:    // Compute the loaded value and branch to the loop block.
    #####:  547:    rewriter.setInsertionPointToEnd(initBlock);
call    0 never executed
    #####:  548:    auto memRefType = atomicOp.getMemref().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  549:    auto dataPtr = getStridedElementPtr(loc, memRefType, adaptor.getMemref(),
    #####:  550:                                        adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  551:    Value init = rewriter.create<LLVM::LoadOp>(loc, dataPtr);
call    0 never executed
call    1 never executed
    #####:  552:    rewriter.create<LLVM::BrOp>(loc, init, loopBlock);
call    0 never executed
        -:  553:
        -:  554:    // Prepare the body of the loop block.
    #####:  555:    rewriter.setInsertionPointToStart(loopBlock);
call    0 never executed
        -:  556:
        -:  557:    // Clone the GenericAtomicRMWOp region and extract the result.
    #####:  558:    auto loopArgument = loopBlock->getArgument(0);
call    0 never executed
    #####:  559:    BlockAndValueMapping mapping;
call    0 never executed
call    1 never executed
    #####:  560:    mapping.map(atomicOp.getCurrentValue(), loopArgument);
call    0 never executed
call    1 never executed
    #####:  561:    Block &entryBlock = atomicOp.body().front();
call    0 never executed
call    1 never executed
    #####:  562:    for (auto &nestedOp : entryBlock.without_terminator()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  563:      Operation *clone = rewriter.clone(nestedOp, mapping);
call    0 never executed
    #####:  564:      mapping.map(nestedOp.getResults(), clone->getResults());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  565:    }
    #####:  566:    Value result = mapping.lookup(entryBlock.getTerminator()->getOperand(0));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  567:
        -:  568:    // Prepare the epilog of the loop block.
        -:  569:    // Append the cmpxchg op to the end of the loop block.
    #####:  570:    auto successOrdering = LLVM::AtomicOrdering::acq_rel;
    #####:  571:    auto failureOrdering = LLVM::AtomicOrdering::monotonic;
    #####:  572:    auto boolType = IntegerType::get(rewriter.getContext(), 1);
call    0 never executed
    #####:  573:    auto pairType = LLVM::LLVMStructType::getLiteral(rewriter.getContext(),
    #####:  574:                                                     {valueType, boolType});
call    0 never executed
    #####:  575:    auto cmpxchg = rewriter.create<LLVM::AtomicCmpXchgOp>(
        -:  576:        loc, pairType, dataPtr, loopArgument, result, successOrdering,
    #####:  577:        failureOrdering);
call    0 never executed
        -:  578:    // Extract the %new_loaded and %ok values from the pair.
    #####:  579:    Value newLoaded = rewriter.create<LLVM::ExtractValueOp>(loc, cmpxchg, 0);
call    0 never executed
call    1 never executed
    #####:  580:    Value ok = rewriter.create<LLVM::ExtractValueOp>(loc, cmpxchg, 1);
call    0 never executed
call    1 never executed
        -:  581:
        -:  582:    // Conditionally branch to the end or back to the loop depending on %ok.
    #####:  583:    rewriter.create<LLVM::CondBrOp>(loc, ok, endBlock, ArrayRef<Value>(),
call    0 never executed
    #####:  584:                                    loopBlock, newLoaded);
call    0 never executed
        -:  585:
    #####:  586:    rewriter.setInsertionPointToEnd(endBlock);
    #####:  587:    moveOpsRange(atomicOp.getResult(), newLoaded, std::next(opsToMoveStart),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  588:                 std::next(opsToMoveEnd), rewriter);
        -:  589:
        -:  590:    // The 'result' of the atomic_rmw op is the newly loaded value.
    #####:  591:    rewriter.replaceOp(atomicOp, {newLoaded});
call    0 never executed
call    1 never executed
        -:  592:
    #####:  593:    return success();
call    0 never executed
        -:  594:  }
        -:  595:
        -:  596:private:
        -:  597:  // Clones a segment of ops [start, end) and erases the original.
        -:  598:  void moveOpsRange(ValueRange oldResult, ValueRange newResult,
        -:  599:                    Block::iterator start, Block::iterator end,
        -:  600:                    ConversionPatternRewriter &rewriter) const {
        -:  601:    BlockAndValueMapping mapping;
        -:  602:    mapping.map(oldResult, newResult);
        -:  603:    SmallVector<Operation *, 2> opsToErase;
        -:  604:    for (auto it = start; it != end; ++it) {
        -:  605:      rewriter.clone(*it, mapping);
        -:  606:      opsToErase.push_back(&*it);
        -:  607:    }
        -:  608:    for (auto *it : opsToErase)
        -:  609:      rewriter.eraseOp(it);
        -:  610:  }
        -:  611:};
        -:  612:
        -:  613:/// Returns the LLVM type of the global variable given the memref type `type`.
function _ZN12_GLOBAL__N_1L29convertGlobalMemrefTypeToLLVMEN4mlir10MemRefTypeERNS0_17LLVMTypeConverterE called 0 returned 0% blocks executed 0%
    #####:  614:static Type convertGlobalMemrefTypeToLLVM(MemRefType type,
        -:  615:                                          LLVMTypeConverter &typeConverter) {
        -:  616:  // LLVM type for a global memref will be a multi-dimension array. For
        -:  617:  // declarations or uninitialized global memrefs, we can potentially flatten
        -:  618:  // this to a 1D array. However, for memref.global's with an initial value,
        -:  619:  // we do not intend to flatten the ElementsAttribute when going from std ->
        -:  620:  // LLVM dialect, so the LLVM type needs to me a multi-dimension array.
    #####:  621:  Type elementType = typeConverter.convertType(type.getElementType());
call    0 never executed
call    1 never executed
    #####:  622:  Type arrayTy = elementType;
        -:  623:  // Shape has the outermost dim at index 0, so need to walk it backwards
    #####:  624:  for (int64_t dim : llvm::reverse(type.getShape()))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  625:    arrayTy = LLVM::LLVMArrayType::get(arrayTy, dim);
call    0 never executed
    #####:  626:  return arrayTy;
        -:  627:}
        -:  628:
        -:  629:/// GlobalMemrefOp is lowered to a LLVM Global Variable.
        -:  630:struct GlobalMemrefOpLowering
        -:  631:    : public ConvertOpToLLVMPattern<memref::GlobalOp> {
     3126:  632:  using ConvertOpToLLVMPattern<memref::GlobalOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  633:
        -:  634:  LogicalResult
function _ZNK12_GLOBAL__N_122GlobalMemrefOpLowering15matchAndRewriteEN4mlir6memref8GlobalOpENS2_15GlobalOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  635:  matchAndRewrite(memref::GlobalOp global, OpAdaptor adaptor,
        -:  636:                  ConversionPatternRewriter &rewriter) const override {
    #####:  637:    MemRefType type = global.getType();
call    0 never executed
    #####:  638:    if (!isConvertibleAndHasIdentityMaps(type))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  639:      return failure();
        -:  640:
    #####:  641:    Type arrayTy = convertGlobalMemrefTypeToLLVM(type, *getTypeConverter());
call    0 never executed
call    1 never executed
        -:  642:
    #####:  643:    LLVM::Linkage linkage =
call    0 never executed
    #####:  644:        global.isPublic() ? LLVM::Linkage::External : LLVM::Linkage::Private;
branch  0 never executed
branch  1 never executed
        -:  645:
    #####:  646:    Attribute initialValue = nullptr;
call    0 never executed
    #####:  647:    if (!global.isExternal() && !global.isUninitialized()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  648:      auto elementsAttr = global.getInitialValue()->cast<ElementsAttr>();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  649:      initialValue = elementsAttr;
        -:  650:
        -:  651:      // For scalar memrefs, the global variable created is of the element type,
        -:  652:      // so unpack the elements attribute to extract the value.
    #####:  653:      if (type.getRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  654:        initialValue = elementsAttr.getSplatValue<Attribute>();
call    0 never executed
        -:  655:    }
        -:  656:
    #####:  657:    uint64_t alignment = global.getAlignment().value_or(0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  658:
    #####:  659:    auto newGlobal = rewriter.replaceOpWithNewOp<LLVM::GlobalOp>(
    #####:  660:        global, arrayTy, global.getConstant(), linkage, global.getSymName(),
call    0 never executed
    #####:  661:        initialValue, alignment, type.getMemorySpaceAsInt());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  662:    if (!global.isExternal() && global.isUninitialized()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  663:      Block *blk = new Block();
call    0 never executed
call    1 never executed
    #####:  664:      newGlobal.getInitializerRegion().push_back(blk);
call    0 never executed
call    1 never executed
    #####:  665:      rewriter.setInsertionPointToStart(blk);
call    0 never executed
    #####:  666:      Value undef[] = {
    #####:  667:          rewriter.create<LLVM::UndefOp>(global.getLoc(), arrayTy)};
call    0 never executed
call    1 never executed
    #####:  668:      rewriter.create<LLVM::ReturnOp>(global.getLoc(), undef);
call    0 never executed
        -:  669:    }
    #####:  670:    return success();
        -:  671:  }
        -:  672:};
        -:  673:
        -:  674:/// GetGlobalMemrefOp is lowered into a Memref descriptor with the pointer to
        -:  675:/// the first element stashed into the descriptor. This reuses
        -:  676:/// `AllocLikeOpLowering` to reuse the Memref descriptor construction.
        -:  677:struct GetGlobalMemrefOpLowering : public AllocLikeOpLLVMLowering {
     3126:  678:  GetGlobalMemrefOpLowering(LLVMTypeConverter &converter)
     3126:  679:      : AllocLikeOpLLVMLowering(memref::GetGlobalOp::getOperationName(),
     3126:  680:                                converter) {}
call    0 returned 100%
        -:  681:
        -:  682:  /// Buffer "allocation" for memref.get_global op is getting the address of
        -:  683:  /// the global variable referenced.
function _ZNK12_GLOBAL__N_125GetGlobalMemrefOpLowering14allocateBufferERN4mlir25ConversionPatternRewriterENS1_8LocationENS1_5ValueEPNS1_9OperationE called 0 returned 0% blocks executed 0%
    #####:  684:  std::tuple<Value, Value> allocateBuffer(ConversionPatternRewriter &rewriter,
        -:  685:                                          Location loc, Value sizeBytes,
        -:  686:                                          Operation *op) const override {
    #####:  687:    auto getGlobalOp = cast<memref::GetGlobalOp>(op);
call    0 never executed
    #####:  688:    MemRefType type = getGlobalOp.getResult().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  689:    unsigned memSpace = type.getMemorySpaceAsInt();
call    0 never executed
        -:  690:
    #####:  691:    Type arrayTy = convertGlobalMemrefTypeToLLVM(type, *getTypeConverter());
call    0 never executed
call    1 never executed
    #####:  692:    auto addressOf = rewriter.create<LLVM::AddressOfOp>(
    #####:  693:        loc, LLVM::LLVMPointerType::get(arrayTy, memSpace),
call    0 never executed
    #####:  694:        getGlobalOp.getName());
call    0 never executed
call    1 never executed
        -:  695:
        -:  696:    // Get the address of the first element in the array by creating a GEP with
        -:  697:    // the address of the GV as the base, and (rank + 1) number of 0 indices.
    #####:  698:    Type elementType = typeConverter->convertType(type.getElementType());
call    0 never executed
call    1 never executed
    #####:  699:    Type elementPtrType = LLVM::LLVMPointerType::get(elementType, memSpace);
call    0 never executed
        -:  700:
    #####:  701:    auto gep = rewriter.create<LLVM::GEPOp>(
        -:  702:        loc, elementPtrType, addressOf,
    #####:  703:        SmallVector<LLVM::GEPArg>(type.getRank() + 1, 0));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:  704:
        -:  705:    // We do not expect the memref obtained using `memref.get_global` to be
        -:  706:    // ever deallocated. Set the allocated pointer to be known bad value to
        -:  707:    // help debug if that ever happens.
    #####:  708:    auto intPtrType = getIntPtrType(memSpace);
call    0 never executed
    #####:  709:    Value deadBeefConst =
    #####:  710:        createIndexAttrConstant(rewriter, op->getLoc(), intPtrType, 0xdeadbeef);
call    0 never executed
    #####:  711:    auto deadBeefPtr =
    #####:  712:        rewriter.create<LLVM::IntToPtrOp>(loc, elementPtrType, deadBeefConst);
call    0 never executed
        -:  713:
        -:  714:    // Both allocated and aligned pointers are same. We could potentially stash
        -:  715:    // a nullptr for the allocated pointer since we do not expect any dealloc.
    #####:  716:    return std::make_tuple(deadBeefPtr, gep);
        -:  717:  }
        -:  718:};
        -:  719:
        -:  720:// Load operation is lowered to obtaining a pointer to the indexed element
        -:  721:// and loading it.
        -:  722:struct LoadOpLowering : public LoadStoreOpLowering<memref::LoadOp> {
     3126:  723:  using Base::Base;
call    0 returned 100%
        -:  724:
        -:  725:  LogicalResult
function _ZNK12_GLOBAL__N_114LoadOpLowering15matchAndRewriteEN4mlir6memref6LoadOpENS2_13LoadOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  726:  matchAndRewrite(memref::LoadOp loadOp, OpAdaptor adaptor,
        -:  727:                  ConversionPatternRewriter &rewriter) const override {
    #####:  728:    auto type = loadOp.getMemRefType();
call    0 never executed
        -:  729:
    #####:  730:    Value dataPtr =
        -:  731:        getStridedElementPtr(loadOp.getLoc(), type, adaptor.getMemref(),
    #####:  732:                             adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  733:    rewriter.replaceOpWithNewOp<LLVM::LoadOp>(loadOp, dataPtr);
call    0 never executed
    #####:  734:    return success();
        -:  735:  }
        -:  736:};
        -:  737:
        -:  738:// Store operation is lowered to obtaining a pointer to the indexed element,
        -:  739:// and storing the given value to it.
        -:  740:struct StoreOpLowering : public LoadStoreOpLowering<memref::StoreOp> {
     3126:  741:  using Base::Base;
call    0 returned 100%
        -:  742:
        -:  743:  LogicalResult
function _ZNK12_GLOBAL__N_115StoreOpLowering15matchAndRewriteEN4mlir6memref7StoreOpENS2_14StoreOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  744:  matchAndRewrite(memref::StoreOp op, OpAdaptor adaptor,
        -:  745:                  ConversionPatternRewriter &rewriter) const override {
    #####:  746:    auto type = op.getMemRefType();
call    0 never executed
        -:  747:
    #####:  748:    Value dataPtr = getStridedElementPtr(op.getLoc(), type, adaptor.getMemref(),
    #####:  749:                                         adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  750:    rewriter.replaceOpWithNewOp<LLVM::StoreOp>(op, adaptor.getValue(), dataPtr);
call    0 never executed
call    1 never executed
    #####:  751:    return success();
        -:  752:  }
        -:  753:};
        -:  754:
        -:  755:// The prefetch operation is lowered in a way similar to the load operation
        -:  756:// except that the llvm.prefetch operation is used for replacement.
        -:  757:struct PrefetchOpLowering : public LoadStoreOpLowering<memref::PrefetchOp> {
     3126:  758:  using Base::Base;
call    0 returned 100%
        -:  759:
        -:  760:  LogicalResult
function _ZNK12_GLOBAL__N_118PrefetchOpLowering15matchAndRewriteEN4mlir6memref10PrefetchOpENS2_17PrefetchOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  761:  matchAndRewrite(memref::PrefetchOp prefetchOp, OpAdaptor adaptor,
        -:  762:                  ConversionPatternRewriter &rewriter) const override {
    #####:  763:    auto type = prefetchOp.getMemRefType();
call    0 never executed
    #####:  764:    auto loc = prefetchOp.getLoc();
call    0 never executed
        -:  765:
    #####:  766:    Value dataPtr = getStridedElementPtr(loc, type, adaptor.getMemref(),
    #####:  767:                                         adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  768:
        -:  769:    // Replace with llvm.prefetch.
    #####:  770:    auto llvmI32Type = typeConverter->convertType(rewriter.getIntegerType(32));
call    0 never executed
call    1 never executed
    #####:  771:    auto isWrite = rewriter.create<LLVM::ConstantOp>(loc, llvmI32Type,
    #####:  772:                                                     prefetchOp.getIsWrite());
call    0 never executed
call    1 never executed
    #####:  773:    auto localityHint = rewriter.create<LLVM::ConstantOp>(
    #####:  774:        loc, llvmI32Type, prefetchOp.getLocalityHint());
call    0 never executed
call    1 never executed
    #####:  775:    auto isData = rewriter.create<LLVM::ConstantOp>(
    #####:  776:        loc, llvmI32Type, prefetchOp.getIsDataCache());
call    0 never executed
call    1 never executed
        -:  777:
    #####:  778:    rewriter.replaceOpWithNewOp<LLVM::Prefetch>(prefetchOp, dataPtr, isWrite,
    #####:  779:                                                localityHint, isData);
call    0 never executed
    #####:  780:    return success();
        -:  781:  }
        -:  782:};
        -:  783:
        -:  784:struct RankOpLowering : public ConvertOpToLLVMPattern<memref::RankOp> {
     3126:  785:  using ConvertOpToLLVMPattern<memref::RankOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  786:
        -:  787:  LogicalResult
function _ZNK12_GLOBAL__N_114RankOpLowering15matchAndRewriteEN4mlir6memref6RankOpENS2_13RankOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  788:  matchAndRewrite(memref::RankOp op, OpAdaptor adaptor,
        -:  789:                  ConversionPatternRewriter &rewriter) const override {
    #####:  790:    Location loc = op.getLoc();
call    0 never executed
    #####:  791:    Type operandType = op.getMemref().getType();
call    0 never executed
call    1 never executed
    #####:  792:    if (auto unrankedMemRefType = operandType.dyn_cast<UnrankedMemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:      UnrankedMemRefDescriptor desc(adaptor.getMemref());
call    0 never executed
call    1 never executed
    #####:  794:      rewriter.replaceOp(op, {desc.rank(rewriter, loc)});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  795:      return success();
        -:  796:    }
    #####:  797:    if (auto rankedMemRefType = operandType.dyn_cast<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  798:      rewriter.replaceOp(
call    0 never executed
call    1 never executed
    #####:  799:          op, {createIndexConstant(rewriter, loc, rankedMemRefType.getRank())});
call    0 never executed
call    1 never executed
    #####:  800:      return success();
        -:  801:    }
    #####:  802:    return failure();
        -:  803:  }
        -:  804:};
        -:  805:
        -:  806:struct MemRefCastOpLowering : public ConvertOpToLLVMPattern<memref::CastOp> {
     3126:  807:  using ConvertOpToLLVMPattern<memref::CastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  808:
function _ZNK12_GLOBAL__N_120MemRefCastOpLowering5matchEN4mlir6memref6CastOpE called 0 returned 0% blocks executed 0%
    #####:  809:  LogicalResult match(memref::CastOp memRefCastOp) const override {
    #####:  810:    Type srcType = memRefCastOp.getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  811:    Type dstType = memRefCastOp.getType();
call    0 never executed
        -:  812:
        -:  813:    // memref::CastOp reduce to bitcast in the ranked MemRef case and can be
        -:  814:    // used for type erasure. For now they must preserve underlying element type
        -:  815:    // and require source and result type to have the same rank. Therefore,
        -:  816:    // perform a sanity check that the underlying structs are the same. Once op
        -:  817:    // semantics are relaxed we can revisit.
    #####:  818:    if (srcType.isa<MemRefType>() && dstType.isa<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  819:      return success(typeConverter->convertType(srcType) ==
call    0 never executed
    #####:  820:                     typeConverter->convertType(dstType));
call    0 never executed
        -:  821:
        -:  822:    // At least one of the operands is unranked type
    #####:  823:    assert(srcType.isa<UnrankedMemRefType>() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:  824:           dstType.isa<UnrankedMemRefType>());
        -:  825:
        -:  826:    // Unranked to unranked cast is disallowed
    #####:  827:    return !(srcType.isa<UnrankedMemRefType>() &&
branch  0 never executed
branch  1 never executed
    #####:  828:             dstType.isa<UnrankedMemRefType>())
branch  0 never executed
branch  1 never executed
    #####:  829:               ? success()
branch  0 never executed
branch  1 never executed
    #####:  830:               : failure();
        -:  831:  }
        -:  832:
function _ZNK12_GLOBAL__N_120MemRefCastOpLowering7rewriteEN4mlir6memref6CastOpENS2_13CastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  833:  void rewrite(memref::CastOp memRefCastOp, OpAdaptor adaptor,
        -:  834:               ConversionPatternRewriter &rewriter) const override {
    #####:  835:    auto srcType = memRefCastOp.getOperand().getType();
call    0 never executed
call    1 never executed
    #####:  836:    auto dstType = memRefCastOp.getType();
call    0 never executed
    #####:  837:    auto targetStructType = typeConverter->convertType(memRefCastOp.getType());
call    0 never executed
    #####:  838:    auto loc = memRefCastOp.getLoc();
call    0 never executed
        -:  839:
        -:  840:    // For ranked/ranked case, just keep the original descriptor.
    #####:  841:    if (srcType.isa<MemRefType>() && dstType.isa<MemRefType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  842:      return rewriter.replaceOp(memRefCastOp, {adaptor.getSource()});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  843:
    #####:  844:    if (srcType.isa<MemRefType>() && dstType.isa<UnrankedMemRefType>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  845:      // Casting ranked to unranked memref type
        -:  846:      // Set the rank in the destination from the memref type
        -:  847:      // Allocate space on the stack and copy the src memref descriptor
        -:  848:      // Set the ptr in the destination to the stack space
    #####:  849:      auto srcMemRefType = srcType.cast<MemRefType>();
call    0 never executed
    #####:  850:      int64_t rank = srcMemRefType.getRank();
call    0 never executed
        -:  851:      // ptr = AllocaOp sizeof(MemRefDescriptor)
    #####:  852:      auto ptr = getTypeConverter()->promoteOneMemRefDescriptor(
    #####:  853:          loc, adaptor.getSource(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  854:      // voidptr = BitCastOp srcType* to void*
    #####:  855:      auto voidPtr =
    #####:  856:          rewriter.create<LLVM::BitcastOp>(loc, getVoidPtrType(), ptr)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  857:              .getResult();
        -:  858:      // rank = ConstantOp srcRank
    #####:  859:      auto rankVal = rewriter.create<LLVM::ConstantOp>(
    #####:  860:          loc, getIndexType(), rewriter.getIndexAttr(rank));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  861:      // undef = UndefOp
    #####:  862:      UnrankedMemRefDescriptor memRefDesc =
    #####:  863:          UnrankedMemRefDescriptor::undef(rewriter, loc, targetStructType);
call    0 never executed
        -:  864:      // d1 = InsertValueOp undef, rank, 0
    #####:  865:      memRefDesc.setRank(rewriter, loc, rankVal);
call    0 never executed
        -:  866:      // d2 = InsertValueOp d1, voidptr, 1
    #####:  867:      memRefDesc.setMemRefDescPtr(rewriter, loc, voidPtr);
call    0 never executed
    #####:  868:      rewriter.replaceOp(memRefCastOp, (Value)memRefDesc);
call    0 never executed
call    1 never executed
        -:  869:
    #####:  870:    } else if (srcType.isa<UnrankedMemRefType>() && dstType.isa<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  871:      // Casting from unranked type to ranked.
        -:  872:      // The operation is assumed to be doing a correct cast. If the destination
        -:  873:      // type mismatches the unranked the type, it is undefined behavior.
    #####:  874:      UnrankedMemRefDescriptor memRefDesc(adaptor.getSource());
call    0 never executed
call    1 never executed
        -:  875:      // ptr = ExtractValueOp src, 1
    #####:  876:      auto ptr = memRefDesc.memRefDescPtr(rewriter, loc);
call    0 never executed
        -:  877:      // castPtr = BitCastOp i8* to structTy*
    #####:  878:      auto castPtr =
        -:  879:          rewriter
    #####:  880:              .create<LLVM::BitcastOp>(
    #####:  881:                  loc, LLVM::LLVMPointerType::get(targetStructType), ptr)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  882:              .getResult();
        -:  883:      // struct = LoadOp castPtr
    #####:  884:      auto loadOp = rewriter.create<LLVM::LoadOp>(loc, castPtr);
call    0 never executed
    #####:  885:      rewriter.replaceOp(memRefCastOp, loadOp.getResult());
call    0 never executed
call    1 never executed
        -:  886:    } else {
    #####:  887:      llvm_unreachable("Unsupported unranked memref to unranked memref cast");
call    0 never executed
        -:  888:    }
        -:  889:  }
        -:  890:};
        -:  891:
        -:  892:/// Pattern to lower a `memref.copy` to llvm.
        -:  893:///
        -:  894:/// For memrefs with identity layouts, the copy is lowered to the llvm
        -:  895:/// `memcpy` intrinsic. For non-identity layouts, the copy is lowered to a call
        -:  896:/// to the generic `MemrefCopyFn`.
        -:  897:struct MemRefCopyOpLowering : public ConvertOpToLLVMPattern<memref::CopyOp> {
     3126:  898:  using ConvertOpToLLVMPattern<memref::CopyOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  899:
        -:  900:  LogicalResult
function _ZNK12_GLOBAL__N_120MemRefCopyOpLowering23lowerToMemCopyIntrinsicEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  901:  lowerToMemCopyIntrinsic(memref::CopyOp op, OpAdaptor adaptor,
        -:  902:                          ConversionPatternRewriter &rewriter) const {
    #####:  903:    auto loc = op.getLoc();
call    0 never executed
    #####:  904:    auto srcType = op.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
        -:  905:
    #####:  906:    MemRefDescriptor srcDesc(adaptor.getSource());
call    0 never executed
call    1 never executed
        -:  907:
        -:  908:    // Compute number of elements.
    #####:  909:    Value numElements = rewriter.create<LLVM::ConstantOp>(
    #####:  910:        loc, getIndexType(), rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  911:    for (int pos = 0; pos < srcType.getRank(); ++pos) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  912:      auto size = srcDesc.size(rewriter, loc, pos);
call    0 never executed
    #####:  913:      numElements = rewriter.create<LLVM::MulOp>(loc, numElements, size);
call    0 never executed
        -:  914:    }
        -:  915:
        -:  916:    // Get element size.
    #####:  917:    auto sizeInBytes = getSizeInBytes(loc, srcType.getElementType(), rewriter);
call    0 never executed
call    1 never executed
        -:  918:    // Compute total.
    #####:  919:    Value totalSize =
    #####:  920:        rewriter.create<LLVM::MulOp>(loc, numElements, sizeInBytes);
call    0 never executed
call    1 never executed
        -:  921:
    #####:  922:    Value srcBasePtr = srcDesc.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  923:    Value srcOffset = srcDesc.offset(rewriter, loc);
call    0 never executed
    #####:  924:    Value srcPtr = rewriter.create<LLVM::GEPOp>(loc, srcBasePtr.getType(),
call    0 never executed
    #####:  925:                                                srcBasePtr, srcOffset);
call    0 never executed
call    1 never executed
    #####:  926:    MemRefDescriptor targetDesc(adaptor.getTarget());
call    0 never executed
call    1 never executed
    #####:  927:    Value targetBasePtr = targetDesc.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  928:    Value targetOffset = targetDesc.offset(rewriter, loc);
call    0 never executed
    #####:  929:    Value targetPtr = rewriter.create<LLVM::GEPOp>(loc, targetBasePtr.getType(),
call    0 never executed
    #####:  930:                                                   targetBasePtr, targetOffset);
call    0 never executed
call    1 never executed
    #####:  931:    Value isVolatile =
    #####:  932:        rewriter.create<LLVM::ConstantOp>(loc, rewriter.getBoolAttr(false));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  933:    rewriter.create<LLVM::MemcpyOp>(loc, targetPtr, srcPtr, totalSize,
    #####:  934:                                    isVolatile);
call    0 never executed
    #####:  935:    rewriter.eraseOp(op);
call    0 never executed
        -:  936:
    #####:  937:    return success();
        -:  938:  }
        -:  939:
        -:  940:  LogicalResult
function _ZNK12_GLOBAL__N_120MemRefCopyOpLowering26lowerToMemCopyFunctionCallEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  941:  lowerToMemCopyFunctionCall(memref::CopyOp op, OpAdaptor adaptor,
        -:  942:                             ConversionPatternRewriter &rewriter) const {
    #####:  943:    auto loc = op.getLoc();
call    0 never executed
    #####:  944:    auto srcType = op.getSource().getType().cast<BaseMemRefType>();
call    0 never executed
call    1 never executed
    #####:  945:    auto targetType = op.getTarget().getType().cast<BaseMemRefType>();
call    0 never executed
call    1 never executed
        -:  946:
        -:  947:    // First make sure we have an unranked memref descriptor representation.
function _ZZNK12_GLOBAL__N_120MemRefCopyOpLowering26lowerToMemCopyFunctionCallEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_5ValueENS1_14BaseMemRefTypeEE_clES7_S8_ called 0 returned 0% blocks executed 0%
    #####:  948:    auto makeUnranked = [&, this](Value ranked, BaseMemRefType type) {
    #####:  949:      auto rank = rewriter.create<LLVM::ConstantOp>(loc, getIndexType(),
    #####:  950:                                                    type.getRank());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  951:      auto *typeConverter = getTypeConverter();
call    0 never executed
    #####:  952:      auto ptr =
    #####:  953:          typeConverter->promoteOneMemRefDescriptor(loc, ranked, rewriter);
call    0 never executed
    #####:  954:      auto voidPtr =
    #####:  955:          rewriter.create<LLVM::BitcastOp>(loc, getVoidPtrType(), ptr)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  956:              .getResult();
    #####:  957:      auto unrankedType =
    #####:  958:          UnrankedMemRefType::get(type.getElementType(), type.getMemorySpace());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  959:      return UnrankedMemRefDescriptor::pack(rewriter, loc, *typeConverter,
call    0 never executed
        -:  960:                                            unrankedType,
    #####:  961:                                            ValueRange{rank, voidPtr});
call    0 never executed
call    1 never executed
    #####:  962:    };
        -:  963:
        -:  964:    // Save stack position before promoting descriptors
    #####:  965:    auto stackSaveOp =
    #####:  966:        rewriter.create<LLVM::StackSaveOp>(loc, getVoidPtrType());
call    0 never executed
call    1 never executed
        -:  967:
    #####:  968:    Value unrankedSource = srcType.hasRank()
call    0 never executed
    #####:  969:                               ? makeUnranked(adaptor.getSource(), srcType)
call    0 never executed
call    1 never executed
    #####:  970:                               : adaptor.getSource();
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  971:    Value unrankedTarget = targetType.hasRank()
call    0 never executed
    #####:  972:                               ? makeUnranked(adaptor.getTarget(), targetType)
call    0 never executed
call    1 never executed
    #####:  973:                               : adaptor.getTarget();
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  974:
        -:  975:    // Now promote the unranked descriptors to the stack.
    #####:  976:    auto one = rewriter.create<LLVM::ConstantOp>(loc, getIndexType(),
call    0 never executed
    #####:  977:                                                 rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
function _ZZNK12_GLOBAL__N_120MemRefCopyOpLowering26lowerToMemCopyFunctionCallEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_5ValueEE0_clES7_ called 0 returned 0% blocks executed 0%
    #####:  978:    auto promote = [&](Value desc) {
    #####:  979:      auto ptrType = LLVM::LLVMPointerType::get(desc.getType());
call    0 never executed
    #####:  980:      auto allocated =
    #####:  981:          rewriter.create<LLVM::AllocaOp>(loc, ptrType, ValueRange{one});
call    0 never executed
call    1 never executed
    #####:  982:      rewriter.create<LLVM::StoreOp>(loc, desc, allocated);
call    0 never executed
    #####:  983:      return allocated;
    #####:  984:    };
        -:  985:
    #####:  986:    auto sourcePtr = promote(unrankedSource);
call    0 never executed
    #####:  987:    auto targetPtr = promote(unrankedTarget);
call    0 never executed
        -:  988:
    #####:  989:    unsigned typeSize =
    #####:  990:        mlir::DataLayout::closest(op).getTypeSize(srcType.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  991:    auto elemSize = rewriter.create<LLVM::ConstantOp>(
    #####:  992:        loc, getIndexType(), rewriter.getIndexAttr(typeSize));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  993:    auto copyFn = LLVM::lookupOrCreateMemRefCopyFn(
call    0 never executed
    #####:  994:        op->getParentOfType<ModuleOp>(), getIndexType(), sourcePtr.getType());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  995:    rewriter.create<LLVM::CallOp>(loc, copyFn,
    #####:  996:                                  ValueRange{elemSize, sourcePtr, targetPtr});
call    0 never executed
call    1 never executed
        -:  997:
        -:  998:    // Restore stack used for descriptors
    #####:  999:    rewriter.create<LLVM::StackRestoreOp>(loc, stackSaveOp);
call    0 never executed
        -: 1000:
    #####: 1001:    rewriter.eraseOp(op);
call    0 never executed
        -: 1002:
    #####: 1003:    return success();
        -: 1004:  }
        -: 1005:
        -: 1006:  LogicalResult
function _ZNK12_GLOBAL__N_120MemRefCopyOpLowering15matchAndRewriteEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1007:  matchAndRewrite(memref::CopyOp op, OpAdaptor adaptor,
        -: 1008:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1009:    auto srcType = op.getSource().getType().cast<BaseMemRefType>();
call    0 never executed
call    1 never executed
    #####: 1010:    auto targetType = op.getTarget().getType().cast<BaseMemRefType>();
call    0 never executed
call    1 never executed
        -: 1011:
function _ZZNK12_GLOBAL__N_120MemRefCopyOpLowering15matchAndRewriteEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_10MemRefTypeEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1012:    auto isStaticShapeAndContiguousRowMajor = [](MemRefType type) {
    #####: 1013:      if (!type.hasStaticShape())
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1014:        return false;
        -: 1015:
    #####: 1016:      SmallVector<int64_t> strides;
call    0 never executed
    #####: 1017:      int64_t offset;
    #####: 1018:      if (failed(getStridesAndOffset(type, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1019:        return false;
        -: 1020:
    #####: 1021:      int64_t runningStride = 1;
    #####: 1022:      for (unsigned i = strides.size(); i > 0; --i) {
branch  0 never executed
branch  1 never executed
    #####: 1023:        if (strides[i - 1] != runningStride)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1024:          return false;
    #####: 1025:        runningStride *= type.getDimSize(i - 1);
call    0 never executed
        -: 1026:      }
        -: 1027:      return true;
        -: 1028:    };
        -: 1029:
function _ZZNK12_GLOBAL__N_120MemRefCopyOpLowering15matchAndRewriteEN4mlir6memref6CopyOpENS2_13CopyOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_14BaseMemRefTypeEE0_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1030:    auto isContiguousMemrefType = [&](BaseMemRefType type) {
    #####: 1031:      auto memrefType = type.dyn_cast<mlir::MemRefType>();
call    0 never executed
        -: 1032:      // We can use memcpy for memrefs if they have an identity layout or are
        -: 1033:      // contiguous with an arbitrary offset. Ignore empty memrefs, which is a
        -: 1034:      // special case handled by memrefCopy.
    #####: 1035:      return memrefType &&
branch  0 never executed
branch  1 never executed
    #####: 1036:             (memrefType.getLayout().isIdentity() ||
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1037:              (memrefType.hasStaticShape() && memrefType.getNumElements() > 0 &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1038:               isStaticShapeAndContiguousRowMajor(memrefType)));
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1039:    };
        -: 1040:
    #####: 1041:    if (isContiguousMemrefType(srcType) && isContiguousMemrefType(targetType))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1042:      return lowerToMemCopyIntrinsic(op, adaptor, rewriter);
call    0 never executed
        -: 1043:
    #####: 1044:    return lowerToMemCopyFunctionCall(op, adaptor, rewriter);
call    0 never executed
        -: 1045:  }
        -: 1046:};
        -: 1047:
        -: 1048:/// Extracts allocated, aligned pointers and offset from a ranked or unranked
        -: 1049:/// memref type. In unranked case, the fields are extracted from the underlying
        -: 1050:/// ranked descriptor.
function _ZN12_GLOBAL__N_1L24extractPointersAndOffsetEN4mlir8LocationERNS0_25ConversionPatternRewriterERNS0_17LLVMTypeConverterENS0_5ValueES6_PS6_S7_S7_ called 0 returned 0% blocks executed 0%
    #####: 1051:static void extractPointersAndOffset(Location loc,
        -: 1052:                                     ConversionPatternRewriter &rewriter,
        -: 1053:                                     LLVMTypeConverter &typeConverter,
        -: 1054:                                     Value originalOperand,
        -: 1055:                                     Value convertedOperand,
        -: 1056:                                     Value *allocatedPtr, Value *alignedPtr,
        -: 1057:                                     Value *offset = nullptr) {
    #####: 1058:  Type operandType = originalOperand.getType();
call    0 never executed
    #####: 1059:  if (operandType.isa<MemRefType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1060:    MemRefDescriptor desc(convertedOperand);
call    0 never executed
    #####: 1061:    *allocatedPtr = desc.allocatedPtr(rewriter, loc);
call    0 never executed
    #####: 1062:    *alignedPtr = desc.alignedPtr(rewriter, loc);
call    0 never executed
    #####: 1063:    if (offset != nullptr)
branch  0 never executed
branch  1 never executed
    #####: 1064:      *offset = desc.offset(rewriter, loc);
call    0 never executed
    #####: 1065:    return;
        -: 1066:  }
        -: 1067:
    #####: 1068:  unsigned memorySpace =
call    0 never executed
    #####: 1069:      operandType.cast<UnrankedMemRefType>().getMemorySpaceAsInt();
call    0 never executed
    #####: 1070:  Type elementType = operandType.cast<UnrankedMemRefType>().getElementType();
call    0 never executed
call    1 never executed
    #####: 1071:  Type llvmElementType = typeConverter.convertType(elementType);
call    0 never executed
    #####: 1072:  Type elementPtrPtrType = LLVM::LLVMPointerType::get(
    #####: 1073:      LLVM::LLVMPointerType::get(llvmElementType, memorySpace));
call    0 never executed
call    1 never executed
        -: 1074:
        -: 1075:  // Extract pointer to the underlying ranked memref descriptor and cast it to
        -: 1076:  // ElemType**.
    #####: 1077:  UnrankedMemRefDescriptor unrankedDesc(convertedOperand);
call    0 never executed
    #####: 1078:  Value underlyingDescPtr = unrankedDesc.memRefDescPtr(rewriter, loc);
call    0 never executed
        -: 1079:
    #####: 1080:  *allocatedPtr = UnrankedMemRefDescriptor::allocatedPtr(
    #####: 1081:      rewriter, loc, underlyingDescPtr, elementPtrPtrType);
call    0 never executed
    #####: 1082:  *alignedPtr = UnrankedMemRefDescriptor::alignedPtr(
    #####: 1083:      rewriter, loc, typeConverter, underlyingDescPtr, elementPtrPtrType);
call    0 never executed
    #####: 1084:  if (offset != nullptr) {
branch  0 never executed
branch  1 never executed
    #####: 1085:    *offset = UnrankedMemRefDescriptor::offset(
    #####: 1086:        rewriter, loc, typeConverter, underlyingDescPtr, elementPtrPtrType);
call    0 never executed
        -: 1087:  }
        -: 1088:}
        -: 1089:
        -: 1090:struct MemRefReinterpretCastOpLowering
        -: 1091:    : public ConvertOpToLLVMPattern<memref::ReinterpretCastOp> {
        -: 1092:  using ConvertOpToLLVMPattern<
     3126: 1093:      memref::ReinterpretCastOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1094:
        -: 1095:  LogicalResult
function _ZNK12_GLOBAL__N_131MemRefReinterpretCastOpLowering15matchAndRewriteEN4mlir6memref17ReinterpretCastOpENS2_24ReinterpretCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1096:  matchAndRewrite(memref::ReinterpretCastOp castOp, OpAdaptor adaptor,
        -: 1097:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1098:    Type srcType = castOp.getSource().getType();
call    0 never executed
call    1 never executed
        -: 1099:
    #####: 1100:    Value descriptor;
    #####: 1101:    if (failed(convertSourceMemRefToDescriptor(rewriter, srcType, castOp,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1102:                                               adaptor, &descriptor)))
    #####: 1103:      return failure();
    #####: 1104:    rewriter.replaceOp(castOp, {descriptor});
call    0 never executed
call    1 never executed
    #####: 1105:    return success();
        -: 1106:  }
        -: 1107:
        -: 1108:private:
        -: 1109:  LogicalResult convertSourceMemRefToDescriptor(
        -: 1110:      ConversionPatternRewriter &rewriter, Type srcType,
        -: 1111:      memref::ReinterpretCastOp castOp,
        -: 1112:      memref::ReinterpretCastOp::Adaptor adaptor, Value *descriptor) const {
        -: 1113:    MemRefType targetMemRefType =
        -: 1114:        castOp.getResult().getType().cast<MemRefType>();
        -: 1115:    auto llvmTargetDescriptorTy = typeConverter->convertType(targetMemRefType)
        -: 1116:                                      .dyn_cast_or_null<LLVM::LLVMStructType>();
        -: 1117:    if (!llvmTargetDescriptorTy)
        -: 1118:      return failure();
        -: 1119:
        -: 1120:    // Create descriptor.
        -: 1121:    Location loc = castOp.getLoc();
        -: 1122:    auto desc = MemRefDescriptor::undef(rewriter, loc, llvmTargetDescriptorTy);
        -: 1123:
        -: 1124:    // Set allocated and aligned pointers.
        -: 1125:    Value allocatedPtr, alignedPtr;
        -: 1126:    extractPointersAndOffset(loc, rewriter, *getTypeConverter(),
        -: 1127:                             castOp.getSource(), adaptor.getSource(),
        -: 1128:                             &allocatedPtr, &alignedPtr);
        -: 1129:    desc.setAllocatedPtr(rewriter, loc, allocatedPtr);
        -: 1130:    desc.setAlignedPtr(rewriter, loc, alignedPtr);
        -: 1131:
        -: 1132:    // Set offset.
        -: 1133:    if (castOp.isDynamicOffset(0))
        -: 1134:      desc.setOffset(rewriter, loc, adaptor.getOffsets()[0]);
        -: 1135:    else
        -: 1136:      desc.setConstantOffset(rewriter, loc, castOp.getStaticOffset(0));
        -: 1137:
        -: 1138:    // Set sizes and strides.
        -: 1139:    unsigned dynSizeId = 0;
        -: 1140:    unsigned dynStrideId = 0;
        -: 1141:    for (unsigned i = 0, e = targetMemRefType.getRank(); i < e; ++i) {
        -: 1142:      if (castOp.isDynamicSize(i))
        -: 1143:        desc.setSize(rewriter, loc, i, adaptor.getSizes()[dynSizeId++]);
        -: 1144:      else
        -: 1145:        desc.setConstantSize(rewriter, loc, i, castOp.getStaticSize(i));
        -: 1146:
        -: 1147:      if (castOp.isDynamicStride(i))
        -: 1148:        desc.setStride(rewriter, loc, i, adaptor.getStrides()[dynStrideId++]);
        -: 1149:      else
        -: 1150:        desc.setConstantStride(rewriter, loc, i, castOp.getStaticStride(i));
        -: 1151:    }
        -: 1152:    *descriptor = desc;
        -: 1153:    return success();
        -: 1154:  }
        -: 1155:};
        -: 1156:
        -: 1157:struct MemRefReshapeOpLowering
        -: 1158:    : public ConvertOpToLLVMPattern<memref::ReshapeOp> {
     3126: 1159:  using ConvertOpToLLVMPattern<memref::ReshapeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1160:
        -: 1161:  LogicalResult
function _ZNK12_GLOBAL__N_123MemRefReshapeOpLowering15matchAndRewriteEN4mlir6memref9ReshapeOpENS2_16ReshapeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1162:  matchAndRewrite(memref::ReshapeOp reshapeOp, OpAdaptor adaptor,
        -: 1163:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1164:    Type srcType = reshapeOp.getSource().getType();
call    0 never executed
call    1 never executed
        -: 1165:
    #####: 1166:    Value descriptor;
    #####: 1167:    if (failed(convertSourceMemRefToDescriptor(rewriter, srcType, reshapeOp,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1168:                                               adaptor, &descriptor)))
    #####: 1169:      return failure();
    #####: 1170:    rewriter.replaceOp(reshapeOp, {descriptor});
call    0 never executed
call    1 never executed
    #####: 1171:    return success();
        -: 1172:  }
        -: 1173:
        -: 1174:private:
        -: 1175:  LogicalResult
        -: 1176:  convertSourceMemRefToDescriptor(ConversionPatternRewriter &rewriter,
        -: 1177:                                  Type srcType, memref::ReshapeOp reshapeOp,
        -: 1178:                                  memref::ReshapeOp::Adaptor adaptor,
        -: 1179:                                  Value *descriptor) const {
        -: 1180:    auto shapeMemRefType = reshapeOp.getShape().getType().cast<MemRefType>();
        -: 1181:    if (shapeMemRefType.hasStaticShape()) {
        -: 1182:      MemRefType targetMemRefType =
        -: 1183:          reshapeOp.getResult().getType().cast<MemRefType>();
        -: 1184:      auto llvmTargetDescriptorTy =
        -: 1185:          typeConverter->convertType(targetMemRefType)
        -: 1186:              .dyn_cast_or_null<LLVM::LLVMStructType>();
        -: 1187:      if (!llvmTargetDescriptorTy)
        -: 1188:        return failure();
        -: 1189:
        -: 1190:      // Create descriptor.
        -: 1191:      Location loc = reshapeOp.getLoc();
        -: 1192:      auto desc =
        -: 1193:          MemRefDescriptor::undef(rewriter, loc, llvmTargetDescriptorTy);
        -: 1194:
        -: 1195:      // Set allocated and aligned pointers.
        -: 1196:      Value allocatedPtr, alignedPtr;
        -: 1197:      extractPointersAndOffset(loc, rewriter, *getTypeConverter(),
        -: 1198:                               reshapeOp.getSource(), adaptor.getSource(),
        -: 1199:                               &allocatedPtr, &alignedPtr);
        -: 1200:      desc.setAllocatedPtr(rewriter, loc, allocatedPtr);
        -: 1201:      desc.setAlignedPtr(rewriter, loc, alignedPtr);
        -: 1202:
        -: 1203:      // Extract the offset and strides from the type.
        -: 1204:      int64_t offset;
        -: 1205:      SmallVector<int64_t> strides;
        -: 1206:      if (failed(getStridesAndOffset(targetMemRefType, strides, offset)))
        -: 1207:        return rewriter.notifyMatchFailure(
        -: 1208:            reshapeOp, "failed to get stride and offset exprs");
        -: 1209:
        -: 1210:      if (!isStaticStrideOrOffset(offset))
        -: 1211:        return rewriter.notifyMatchFailure(reshapeOp,
        -: 1212:                                           "dynamic offset is unsupported");
        -: 1213:
        -: 1214:      desc.setConstantOffset(rewriter, loc, offset);
        -: 1215:
        -: 1216:      assert(targetMemRefType.getLayout().isIdentity() &&
        -: 1217:             "Identity layout map is a precondition of a valid reshape op");
        -: 1218:
        -: 1219:      Value stride = nullptr;
        -: 1220:      int64_t targetRank = targetMemRefType.getRank();
        -: 1221:      for (auto i : llvm::reverse(llvm::seq<int64_t>(0, targetRank))) {
        -: 1222:        if (!ShapedType::isDynamicStrideOrOffset(strides[i])) {
        -: 1223:          // If the stride for this dimension is dynamic, then use the product
        -: 1224:          // of the sizes of the inner dimensions.
        -: 1225:          stride = createIndexConstant(rewriter, loc, strides[i]);
        -: 1226:        } else if (!stride) {
        -: 1227:          // `stride` is null only in the first iteration of the loop.  However,
        -: 1228:          // since the target memref has an identity layout, we can safely set
        -: 1229:          // the innermost stride to 1.
        -: 1230:          stride = createIndexConstant(rewriter, loc, 1);
        -: 1231:        }
        -: 1232:
        -: 1233:        Value dimSize;
        -: 1234:        int64_t size = targetMemRefType.getDimSize(i);
        -: 1235:        // If the size of this dimension is dynamic, then load it at runtime
        -: 1236:        // from the shape operand.
        -: 1237:        if (!ShapedType::isDynamic(size)) {
        -: 1238:          dimSize = createIndexConstant(rewriter, loc, size);
        -: 1239:        } else {
        -: 1240:          Value shapeOp = reshapeOp.getShape();
        -: 1241:          Value index = createIndexConstant(rewriter, loc, i);
        -: 1242:          dimSize = rewriter.create<memref::LoadOp>(loc, shapeOp, index);
        -: 1243:          Type indexType = getIndexType();
        -: 1244:          if (dimSize.getType() != indexType)
        -: 1245:            dimSize = typeConverter->materializeTargetConversion(
        -: 1246:                rewriter, loc, indexType, dimSize);
        -: 1247:          assert(dimSize && "Invalid memref element type");
        -: 1248:        }
        -: 1249:
        -: 1250:        desc.setSize(rewriter, loc, i, dimSize);
        -: 1251:        desc.setStride(rewriter, loc, i, stride);
        -: 1252:
        -: 1253:        // Prepare the stride value for the next dimension.
        -: 1254:        stride = rewriter.create<LLVM::MulOp>(loc, stride, dimSize);
        -: 1255:      }
        -: 1256:
        -: 1257:      *descriptor = desc;
        -: 1258:      return success();
        -: 1259:    }
        -: 1260:
        -: 1261:    // The shape is a rank-1 tensor with unknown length.
        -: 1262:    Location loc = reshapeOp.getLoc();
        -: 1263:    MemRefDescriptor shapeDesc(adaptor.getShape());
        -: 1264:    Value resultRank = shapeDesc.size(rewriter, loc, 0);
        -: 1265:
        -: 1266:    // Extract address space and element type.
        -: 1267:    auto targetType =
        -: 1268:        reshapeOp.getResult().getType().cast<UnrankedMemRefType>();
        -: 1269:    unsigned addressSpace = targetType.getMemorySpaceAsInt();
        -: 1270:    Type elementType = targetType.getElementType();
        -: 1271:
        -: 1272:    // Create the unranked memref descriptor that holds the ranked one. The
        -: 1273:    // inner descriptor is allocated on stack.
        -: 1274:    auto targetDesc = UnrankedMemRefDescriptor::undef(
        -: 1275:        rewriter, loc, typeConverter->convertType(targetType));
        -: 1276:    targetDesc.setRank(rewriter, loc, resultRank);
        -: 1277:    SmallVector<Value, 4> sizes;
        -: 1278:    UnrankedMemRefDescriptor::computeSizes(rewriter, loc, *getTypeConverter(),
        -: 1279:                                           targetDesc, sizes);
        -: 1280:    Value underlyingDescPtr = rewriter.create<LLVM::AllocaOp>(
        -: 1281:        loc, getVoidPtrType(), sizes.front(), llvm::None);
        -: 1282:    targetDesc.setMemRefDescPtr(rewriter, loc, underlyingDescPtr);
        -: 1283:
        -: 1284:    // Extract pointers and offset from the source memref.
        -: 1285:    Value allocatedPtr, alignedPtr, offset;
        -: 1286:    extractPointersAndOffset(loc, rewriter, *getTypeConverter(),
        -: 1287:                             reshapeOp.getSource(), adaptor.getSource(),
        -: 1288:                             &allocatedPtr, &alignedPtr, &offset);
        -: 1289:
        -: 1290:    // Set pointers and offset.
        -: 1291:    Type llvmElementType = typeConverter->convertType(elementType);
        -: 1292:    auto elementPtrPtrType = LLVM::LLVMPointerType::get(
        -: 1293:        LLVM::LLVMPointerType::get(llvmElementType, addressSpace));
        -: 1294:    UnrankedMemRefDescriptor::setAllocatedPtr(rewriter, loc, underlyingDescPtr,
        -: 1295:                                              elementPtrPtrType, allocatedPtr);
        -: 1296:    UnrankedMemRefDescriptor::setAlignedPtr(rewriter, loc, *getTypeConverter(),
        -: 1297:                                            underlyingDescPtr,
        -: 1298:                                            elementPtrPtrType, alignedPtr);
        -: 1299:    UnrankedMemRefDescriptor::setOffset(rewriter, loc, *getTypeConverter(),
        -: 1300:                                        underlyingDescPtr, elementPtrPtrType,
        -: 1301:                                        offset);
        -: 1302:
        -: 1303:    // Use the offset pointer as base for further addressing. Copy over the new
        -: 1304:    // shape and compute strides. For this, we create a loop from rank-1 to 0.
        -: 1305:    Value targetSizesBase = UnrankedMemRefDescriptor::sizeBasePtr(
        -: 1306:        rewriter, loc, *getTypeConverter(), underlyingDescPtr,
        -: 1307:        elementPtrPtrType);
        -: 1308:    Value targetStridesBase = UnrankedMemRefDescriptor::strideBasePtr(
        -: 1309:        rewriter, loc, *getTypeConverter(), targetSizesBase, resultRank);
        -: 1310:    Value shapeOperandPtr = shapeDesc.alignedPtr(rewriter, loc);
        -: 1311:    Value oneIndex = createIndexConstant(rewriter, loc, 1);
        -: 1312:    Value resultRankMinusOne =
        -: 1313:        rewriter.create<LLVM::SubOp>(loc, resultRank, oneIndex);
        -: 1314:
        -: 1315:    Block *initBlock = rewriter.getInsertionBlock();
        -: 1316:    Type indexType = getTypeConverter()->getIndexType();
        -: 1317:    Block::iterator remainingOpsIt = std::next(rewriter.getInsertionPoint());
        -: 1318:
        -: 1319:    Block *condBlock = rewriter.createBlock(initBlock->getParent(), {},
        -: 1320:                                            {indexType, indexType}, {loc, loc});
        -: 1321:
        -: 1322:    // Move the remaining initBlock ops to condBlock.
        -: 1323:    Block *remainingBlock = rewriter.splitBlock(initBlock, remainingOpsIt);
        -: 1324:    rewriter.mergeBlocks(remainingBlock, condBlock, ValueRange());
        -: 1325:
        -: 1326:    rewriter.setInsertionPointToEnd(initBlock);
        -: 1327:    rewriter.create<LLVM::BrOp>(loc, ValueRange({resultRankMinusOne, oneIndex}),
        -: 1328:                                condBlock);
        -: 1329:    rewriter.setInsertionPointToStart(condBlock);
        -: 1330:    Value indexArg = condBlock->getArgument(0);
        -: 1331:    Value strideArg = condBlock->getArgument(1);
        -: 1332:
        -: 1333:    Value zeroIndex = createIndexConstant(rewriter, loc, 0);
        -: 1334:    Value pred = rewriter.create<LLVM::ICmpOp>(
        -: 1335:        loc, IntegerType::get(rewriter.getContext(), 1),
        -: 1336:        LLVM::ICmpPredicate::sge, indexArg, zeroIndex);
        -: 1337:
        -: 1338:    Block *bodyBlock =
        -: 1339:        rewriter.splitBlock(condBlock, rewriter.getInsertionPoint());
        -: 1340:    rewriter.setInsertionPointToStart(bodyBlock);
        -: 1341:
        -: 1342:    // Copy size from shape to descriptor.
        -: 1343:    Type llvmIndexPtrType = LLVM::LLVMPointerType::get(indexType);
        -: 1344:    Value sizeLoadGep = rewriter.create<LLVM::GEPOp>(loc, llvmIndexPtrType,
        -: 1345:                                                     shapeOperandPtr, indexArg);
        -: 1346:    Value size = rewriter.create<LLVM::LoadOp>(loc, sizeLoadGep);
        -: 1347:    UnrankedMemRefDescriptor::setSize(rewriter, loc, *getTypeConverter(),
        -: 1348:                                      targetSizesBase, indexArg, size);
        -: 1349:
        -: 1350:    // Write stride value and compute next one.
        -: 1351:    UnrankedMemRefDescriptor::setStride(rewriter, loc, *getTypeConverter(),
        -: 1352:                                        targetStridesBase, indexArg, strideArg);
        -: 1353:    Value nextStride = rewriter.create<LLVM::MulOp>(loc, strideArg, size);
        -: 1354:
        -: 1355:    // Decrement loop counter and branch back.
        -: 1356:    Value decrement = rewriter.create<LLVM::SubOp>(loc, indexArg, oneIndex);
        -: 1357:    rewriter.create<LLVM::BrOp>(loc, ValueRange({decrement, nextStride}),
        -: 1358:                                condBlock);
        -: 1359:
        -: 1360:    Block *remainder =
        -: 1361:        rewriter.splitBlock(bodyBlock, rewriter.getInsertionPoint());
        -: 1362:
        -: 1363:    // Hook up the cond exit to the remainder.
        -: 1364:    rewriter.setInsertionPointToEnd(condBlock);
        -: 1365:    rewriter.create<LLVM::CondBrOp>(loc, pred, bodyBlock, llvm::None, remainder,
        -: 1366:                                    llvm::None);
        -: 1367:
        -: 1368:    // Reset position to beginning of new remainder block.
        -: 1369:    rewriter.setInsertionPointToStart(remainder);
        -: 1370:
        -: 1371:    *descriptor = targetDesc;
        -: 1372:    return success();
        -: 1373:  }
        -: 1374:};
        -: 1375:
        -: 1376:/// Helper function to convert a vector of `OpFoldResult`s into a vector of
        -: 1377:/// `Value`s.
function _ZN12_GLOBAL__N_1L11getAsValuesERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS0_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1378:static SmallVector<Value> getAsValues(OpBuilder &b, Location loc,
        -: 1379:                                      Type &llvmIndexType,
        -: 1380:                                      ArrayRef<OpFoldResult> valueOrAttrVec) {
    #####: 1381:  return llvm::to_vector<4>(
branch  0 never executed
branch  1 never executed
function _ZZN12_GLOBAL__N_1L11getAsValuesERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS0_12OpFoldResultEEEENKUlS8_E_clES8_ called 0 returned 0% blocks executed 0%
    #####: 1382:      llvm::map_range(valueOrAttrVec, [&](OpFoldResult value) -> Value {
    #####: 1383:        if (auto attr = value.dyn_cast<Attribute>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1384:          return b.create<LLVM::ConstantOp>(loc, llvmIndexType, attr);
call    0 never executed
    #####: 1385:        return value.get<Value>();
call    0 never executed
    #####: 1386:      }));
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1387:}
        -: 1388:
        -: 1389:/// Compute a map that for a given dimension of the expanded type gives the
        -: 1390:/// dimension in the collapsed type it maps to. Essentially its the inverse of
        -: 1391:/// the `reassocation` maps.
        -: 1392:static DenseMap<int64_t, int64_t>
function _ZN12_GLOBAL__N_1L31getExpandedDimToCollapsedDimMapEN4llvm8ArrayRefINS0_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1393:getExpandedDimToCollapsedDimMap(ArrayRef<ReassociationIndices> reassociation) {
    #####: 1394:  llvm::DenseMap<int64_t, int64_t> expandedDimToCollapsedDim;
call    0 never executed
    #####: 1395:  for (auto &en : enumerate(reassociation)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1396:    for (auto dim : en.value())
branch  0 never executed
branch  1 never executed
    #####: 1397:      expandedDimToCollapsedDim[dim] = en.index();
call    0 never executed
        -: 1398:  }
    #####: 1399:  return expandedDimToCollapsedDim;
        -: 1400:}
        -: 1401:
        -: 1402:static OpFoldResult
function _ZN12_GLOBAL__N_1L24getExpandedOutputDimSizeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeElN4llvm8ArrayRefIlEERNS0_16MemRefDescriptorES8_NS7_INS6_11SmallVectorIlLj2EEEEERNS6_8DenseMapIllNS6_12DenseMapInfoIlvEENS6_6detail12DenseMapPairIllEEEE called 0 returned 0% blocks executed 0%
    #####: 1403:getExpandedOutputDimSize(OpBuilder &b, Location loc, Type &llvmIndexType,
        -: 1404:                         int64_t outDimIndex, ArrayRef<int64_t> outStaticShape,
        -: 1405:                         MemRefDescriptor &inDesc,
        -: 1406:                         ArrayRef<int64_t> inStaticShape,
        -: 1407:                         ArrayRef<ReassociationIndices> reassocation,
        -: 1408:                         DenseMap<int64_t, int64_t> &outDimToInDimMap) {
    #####: 1409:  int64_t outDimSize = outStaticShape[outDimIndex];
branch  0 never executed
branch  1 never executed
    #####: 1410:  if (!ShapedType::isDynamic(outDimSize))
branch  0 never executed
branch  1 never executed
    #####: 1411:    return b.getIndexAttr(outDimSize);
call    0 never executed
call    1 never executed
        -: 1412:
        -: 1413:  // Calculate the multiplication of all the out dim sizes except the
        -: 1414:  // current dim.
    #####: 1415:  int64_t inDimIndex = outDimToInDimMap[outDimIndex];
call    0 never executed
    #####: 1416:  int64_t otherDimSizesMul = 1;
    #####: 1417:  for (auto otherDimIndex : reassocation[inDimIndex]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1418:    if (otherDimIndex == static_cast<unsigned>(outDimIndex))
branch  0 never executed
branch  1 never executed
    #####: 1419:      continue;
    #####: 1420:    int64_t otherDimSize = outStaticShape[otherDimIndex];
branch  0 never executed
branch  1 never executed
    #####: 1421:    assert(!ShapedType::isDynamic(otherDimSize) &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1422:           "single dimension cannot be expanded into multiple dynamic "
        -: 1423:           "dimensions");
    #####: 1424:    otherDimSizesMul *= otherDimSize;
        -: 1425:  }
        -: 1426:
        -: 1427:  // outDimSize = inDimSize / otherOutDimSizesMul
    #####: 1428:  int64_t inDimSize = inStaticShape[inDimIndex];
branch  0 never executed
branch  1 never executed
    #####: 1429:  Value inDimSizeDynamic =
branch  0 never executed
branch  1 never executed
    #####: 1430:      ShapedType::isDynamic(inDimSize)
    #####: 1431:          ? inDesc.size(b, loc, inDimIndex)
call    0 never executed
    #####: 1432:          : b.create<LLVM::ConstantOp>(loc, llvmIndexType,
    #####: 1433:                                       b.getIndexAttr(inDimSize));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1434:  Value outDimSizeDynamic = b.create<LLVM::SDivOp>(
        -: 1435:      loc, inDimSizeDynamic,
    #####: 1436:      b.create<LLVM::ConstantOp>(loc, llvmIndexType,
    #####: 1437:                                 b.getIndexAttr(otherDimSizesMul)));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1438:  return outDimSizeDynamic;
call    0 never executed
        -: 1439:}
        -: 1440:
function _ZN12_GLOBAL__N_1L25getCollapsedOutputDimSizeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEllN4llvm8ArrayRefIlEERNS0_16MemRefDescriptorENS7_INS6_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1441:static OpFoldResult getCollapsedOutputDimSize(
        -: 1442:    OpBuilder &b, Location loc, Type &llvmIndexType, int64_t outDimIndex,
        -: 1443:    int64_t outDimSize, ArrayRef<int64_t> inStaticShape,
        -: 1444:    MemRefDescriptor &inDesc, ArrayRef<ReassociationIndices> reassocation) {
    #####: 1445:  if (!ShapedType::isDynamic(outDimSize))
branch  0 never executed
branch  1 never executed
    #####: 1446:    return b.getIndexAttr(outDimSize);
call    0 never executed
call    1 never executed
        -: 1447:
    #####: 1448:  Value c1 = b.create<LLVM::ConstantOp>(loc, llvmIndexType, b.getIndexAttr(1));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1449:  Value outDimSizeDynamic = c1;
    #####: 1450:  for (auto inDimIndex : reassocation[outDimIndex]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1451:    int64_t inDimSize = inStaticShape[inDimIndex];
branch  0 never executed
branch  1 never executed
    #####: 1452:    Value inDimSizeDynamic =
branch  0 never executed
branch  1 never executed
    #####: 1453:        ShapedType::isDynamic(inDimSize)
    #####: 1454:            ? inDesc.size(b, loc, inDimIndex)
call    0 never executed
    #####: 1455:            : b.create<LLVM::ConstantOp>(loc, llvmIndexType,
    #####: 1456:                                         b.getIndexAttr(inDimSize));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1457:    outDimSizeDynamic =
    #####: 1458:        b.create<LLVM::MulOp>(loc, outDimSizeDynamic, inDimSizeDynamic);
call    0 never executed
        -: 1459:  }
    #####: 1460:  return outDimSizeDynamic;
call    0 never executed
        -: 1461:}
        -: 1462:
        -: 1463:static SmallVector<OpFoldResult, 4>
function _ZN12_GLOBAL__N_1L23getCollapsedOutputShapeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS6_11SmallVectorIlLj2EEEEENS7_IlEERNS0_16MemRefDescriptorESB_ called 0 returned 0% blocks executed 0%
    #####: 1464:getCollapsedOutputShape(OpBuilder &b, Location loc, Type &llvmIndexType,
        -: 1465:                        ArrayRef<ReassociationIndices> reassociation,
        -: 1466:                        ArrayRef<int64_t> inStaticShape,
        -: 1467:                        MemRefDescriptor &inDesc,
        -: 1468:                        ArrayRef<int64_t> outStaticShape) {
    #####: 1469:  return llvm::to_vector<4>(llvm::map_range(
function _ZZN12_GLOBAL__N_1L23getCollapsedOutputShapeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS6_11SmallVectorIlLj2EEEEENS7_IlEERNS0_16MemRefDescriptorESB_ENKUllE_clEl called 0 returned 0% blocks executed 0%
    #####: 1470:      llvm::seq<int64_t>(0, outStaticShape.size()), [&](int64_t outDimIndex) {
    #####: 1471:        return getCollapsedOutputDimSize(b, loc, llvmIndexType, outDimIndex,
    #####: 1472:                                         outStaticShape[outDimIndex],
    #####: 1473:                                         inStaticShape, inDesc, reassociation);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1474:      }));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1475:}
        -: 1476:
        -: 1477:static SmallVector<OpFoldResult, 4>
function _ZN12_GLOBAL__N_1L22getExpandedOutputShapeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS6_11SmallVectorIlLj2EEEEENS7_IlEERNS0_16MemRefDescriptorESB_ called 0 returned 0% blocks executed 0%
    #####: 1478:getExpandedOutputShape(OpBuilder &b, Location loc, Type &llvmIndexType,
        -: 1479:                       ArrayRef<ReassociationIndices> reassociation,
        -: 1480:                       ArrayRef<int64_t> inStaticShape,
        -: 1481:                       MemRefDescriptor &inDesc,
        -: 1482:                       ArrayRef<int64_t> outStaticShape) {
    #####: 1483:  DenseMap<int64_t, int64_t> outDimToInDimMap =
    #####: 1484:      getExpandedDimToCollapsedDimMap(reassociation);
call    0 never executed
    #####: 1485:  return llvm::to_vector<4>(llvm::map_range(
function _ZZN12_GLOBAL__N_1L22getExpandedOutputShapeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS6_11SmallVectorIlLj2EEEEENS7_IlEERNS0_16MemRefDescriptorESB_ENKUllE_clEl called 0 returned 0% blocks executed 0%
    #####: 1486:      llvm::seq<int64_t>(0, outStaticShape.size()), [&](int64_t outDimIndex) {
call    0 never executed
    #####: 1487:        return getExpandedOutputDimSize(b, loc, llvmIndexType, outDimIndex,
    #####: 1488:                                        outStaticShape, inDesc, inStaticShape,
    #####: 1489:                                        reassociation, outDimToInDimMap);
call    0 never executed
    #####: 1490:      }));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1491:}
        -: 1492:
        -: 1493:static SmallVector<Value>
function _ZN12_GLOBAL__N_1L21getDynamicOutputShapeERN4mlir9OpBuilderENS0_8LocationERNS0_4TypeEN4llvm8ArrayRefINS6_11SmallVectorIlLj2EEEEENS7_IlEERNS0_16MemRefDescriptorESB_ called 0 returned 0% blocks executed 0%
    #####: 1494:getDynamicOutputShape(OpBuilder &b, Location loc, Type &llvmIndexType,
        -: 1495:                      ArrayRef<ReassociationIndices> reassociation,
        -: 1496:                      ArrayRef<int64_t> inStaticShape, MemRefDescriptor &inDesc,
        -: 1497:                      ArrayRef<int64_t> outStaticShape) {
    #####: 1498:  return outStaticShape.size() < inStaticShape.size()
branch  0 never executed
branch  1 never executed
        -: 1499:             ? getAsValues(b, loc, llvmIndexType,
    #####: 1500:                           getCollapsedOutputShape(b, loc, llvmIndexType,
call    0 never executed
        -: 1501:                                                   reassociation, inStaticShape,
        -: 1502:                                                   inDesc, outStaticShape))
        -: 1503:             : getAsValues(b, loc, llvmIndexType,
    #####: 1504:                           getExpandedOutputShape(b, loc, llvmIndexType,
call    0 never executed
        -: 1505:                                                  reassociation, inStaticShape,
    #####: 1506:                                                  inDesc, outStaticShape));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1507:}
        -: 1508:
        -: 1509:static void fillInStridesForExpandedMemDescriptor(
        -: 1510:    OpBuilder &b, Location loc, MemRefType srcType, MemRefDescriptor &srcDesc,
        -: 1511:    MemRefDescriptor &dstDesc, ArrayRef<ReassociationIndices> reassociation) {
        -: 1512:  // See comments for computeExpandedLayoutMap for details on how the strides
        -: 1513:  // are calculated.
        -: 1514:  for (auto &en : llvm::enumerate(reassociation)) {
        -: 1515:    auto currentStrideToExpand = srcDesc.stride(b, loc, en.index());
        -: 1516:    for (auto dstIndex : llvm::reverse(en.value())) {
        -: 1517:      dstDesc.setStride(b, loc, dstIndex, currentStrideToExpand);
        -: 1518:      Value size = dstDesc.size(b, loc, dstIndex);
        -: 1519:      currentStrideToExpand =
        -: 1520:          b.create<LLVM::MulOp>(loc, size, currentStrideToExpand);
        -: 1521:    }
        -: 1522:  }
        -: 1523:}
        -: 1524:
function _ZN12_GLOBAL__N_1L38fillInStridesForCollapsedMemDescriptorERN4mlir25ConversionPatternRewriterENS0_8LocationEPNS0_9OperationEPNS0_13TypeConverterENS0_10MemRefTypeERNS0_16MemRefDescriptorESA_N4llvm8ArrayRefINSB_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1525:static void fillInStridesForCollapsedMemDescriptor(
        -: 1526:    ConversionPatternRewriter &rewriter, Location loc, Operation *op,
        -: 1527:    TypeConverter *typeConverter, MemRefType srcType, MemRefDescriptor &srcDesc,
        -: 1528:    MemRefDescriptor &dstDesc, ArrayRef<ReassociationIndices> reassociation) {
    #####: 1529:  auto llvmIndexType = typeConverter->convertType(rewriter.getIndexType());
call    0 never executed
call    1 never executed
        -: 1530:  // See comments for computeCollapsedLayoutMap for details on how the strides
        -: 1531:  // are calculated.
    #####: 1532:  auto srcShape = srcType.getShape();
call    0 never executed
    #####: 1533:  for (auto &en : llvm::enumerate(reassociation)) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1534:    rewriter.setInsertionPoint(op);
call    0 never executed
    #####: 1535:    auto dstIndex = en.index();
    #####: 1536:    ArrayRef<int64_t> ref = llvm::makeArrayRef(en.value());
    #####: 1537:    while (srcShape[ref.back()] == 1 && ref.size() > 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1538:      ref = ref.drop_back();
call    0 never executed
    #####: 1539:    if (!ShapedType::isDynamic(srcShape[ref.back()]) || ref.size() == 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1540:      dstDesc.setStride(rewriter, loc, dstIndex,
call    0 never executed
call    1 never executed
        -: 1541:                        srcDesc.stride(rewriter, loc, ref.back()));
        -: 1542:    } else {
        -: 1543:      // Iterate over the source strides in reverse order. Skip over the
        -: 1544:      // dimensions whose size is 1.
        -: 1545:      // TODO: we should take the minimum stride in the reassociation group
        -: 1546:      // instead of just the first where the dimension is not 1.
        -: 1547:      //
        -: 1548:      // +------------------------------------------------------+
        -: 1549:      // | curEntry:                                            |
        -: 1550:      // |   %srcStride = strides[srcIndex]                     |
        -: 1551:      // |   %neOne = cmp sizes[srcIndex],1                     +--+
        -: 1552:      // |   cf.cond_br %neOne, continue(%srcStride), nextEntry |  |
        -: 1553:      // +-------------------------+----------------------------+  |
        -: 1554:      //                           |                               |
        -: 1555:      //                           v                               |
        -: 1556:      //            +-----------------------------+                |
        -: 1557:      //            | nextEntry:                  |                |
        -: 1558:      //            |   ...                       +---+            |
        -: 1559:      //            +--------------+--------------+   |            |
        -: 1560:      //                           |                  |            |
        -: 1561:      //                           v                  |            |
        -: 1562:      //            +-----------------------------+   |            |
        -: 1563:      //            | nextEntry:                  |   |            |
        -: 1564:      //            |   ...                       |   |            |
        -: 1565:      //            +--------------+--------------+   |   +--------+
        -: 1566:      //                           |                  |   |
        -: 1567:      //                           v                  v   v
        -: 1568:      //   +--------------------------------------------------+
        -: 1569:      //   | continue(%newStride):                            |
        -: 1570:      //   |   %newMemRefDes = setStride(%newStride,dstIndex) |
        -: 1571:      //   +--------------------------------------------------+
    #####: 1572:      OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####: 1573:      Block *initBlock = rewriter.getInsertionBlock();
    #####: 1574:      Block *continueBlock =
    #####: 1575:          rewriter.splitBlock(initBlock, rewriter.getInsertionPoint());
call    0 never executed
    #####: 1576:      continueBlock->insertArgument(unsigned(0), srcDesc.getIndexType(), loc);
call    0 never executed
    #####: 1577:      rewriter.setInsertionPointToStart(continueBlock);
call    0 never executed
    #####: 1578:      dstDesc.setStride(rewriter, loc, dstIndex, continueBlock->getArgument(0));
call    0 never executed
        -: 1579:
    #####: 1580:      Block *curEntryBlock = initBlock;
    #####: 1581:      Block *nextEntryBlock;
    #####: 1582:      for (auto srcIndex : llvm::reverse(ref)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1583:        if (srcShape[srcIndex] == 1 && srcIndex != ref.front())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1584:          continue;
    #####: 1585:        rewriter.setInsertionPointToEnd(curEntryBlock);
call    0 never executed
    #####: 1586:        Value srcStride = srcDesc.stride(rewriter, loc, srcIndex);
call    0 never executed
    #####: 1587:        if (srcIndex == ref.front()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1588:          rewriter.create<LLVM::BrOp>(loc, srcStride, continueBlock);
call    0 never executed
    #####: 1589:          break;
        -: 1590:        }
    #####: 1591:        Value one = rewriter.create<LLVM::ConstantOp>(loc, llvmIndexType,
    #####: 1592:                                                      rewriter.getIndexAttr(1));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1593:        Value predNeOne = rewriter.create<LLVM::ICmpOp>(
    #####: 1594:            loc, LLVM::ICmpPredicate::ne, srcDesc.size(rewriter, loc, srcIndex),
call    0 never executed
    #####: 1595:            one);
call    0 never executed
call    1 never executed
    #####: 1596:        {
    #####: 1597:          OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####: 1598:          nextEntryBlock = rewriter.createBlock(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -: 1599:              initBlock->getParent(), Region::iterator(continueBlock), {});
        -: 1600:        }
    #####: 1601:        rewriter.create<LLVM::CondBrOp>(loc, predNeOne, continueBlock,
    #####: 1602:                                        srcStride, nextEntryBlock, llvm::None);
call    0 never executed
    #####: 1603:        curEntryBlock = nextEntryBlock;
        -: 1604:      }
        -: 1605:    }
        -: 1606:  }
    #####: 1607:}
        -: 1608:
function _ZN12_GLOBAL__N_1L36fillInDynamicStridesForMemDescriptorERN4mlir25ConversionPatternRewriterENS0_8LocationEPNS0_9OperationEPNS0_13TypeConverterENS0_10MemRefTypeES8_RNS0_16MemRefDescriptorESA_N4llvm8ArrayRefINSB_11SmallVectorIlLj2EEEEE called 0 returned 0% blocks executed 0%
    #####: 1609:static void fillInDynamicStridesForMemDescriptor(
        -: 1610:    ConversionPatternRewriter &b, Location loc, Operation *op,
        -: 1611:    TypeConverter *typeConverter, MemRefType srcType, MemRefType dstType,
        -: 1612:    MemRefDescriptor &srcDesc, MemRefDescriptor &dstDesc,
        -: 1613:    ArrayRef<ReassociationIndices> reassociation) {
    #####: 1614:  if (srcType.getRank() > dstType.getRank())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1615:    fillInStridesForCollapsedMemDescriptor(b, loc, op, typeConverter, srcType,
call    0 never executed
        -: 1616:                                           srcDesc, dstDesc, reassociation);
        -: 1617:  else
    #####: 1618:    fillInStridesForExpandedMemDescriptor(b, loc, srcType, srcDesc, dstDesc,
call    0 never executed
        -: 1619:                                          reassociation);
    #####: 1620:}
        -: 1621:
        -: 1622:// ReshapeOp creates a new view descriptor of the proper rank.
        -: 1623:// For now, the only conversion supported is for target MemRef with static sizes
        -: 1624:// and strides.
        -: 1625:template <typename ReshapeOp>
        -: 1626:class ReassociatingReshapeOpConversion
        -: 1627:    : public ConvertOpToLLVMPattern<ReshapeOp> {
        -: 1628:public:
     6252: 1629:  using ConvertOpToLLVMPattern<ReshapeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
call    1 returned 100%
        -: 1630:  using ReshapeOpAdaptor = typename ReshapeOp::Adaptor;
        -: 1631:
        -: 1632:  LogicalResult
    #####: 1633:  matchAndRewrite(ReshapeOp reshapeOp, typename ReshapeOp::Adaptor adaptor,
        -: 1634:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1635:    MemRefType dstType = reshapeOp.getResultType();
    #####: 1636:    MemRefType srcType = reshapeOp.getSrcType();
        -: 1637:
        -: 1638:    int64_t offset;
    #####: 1639:    SmallVector<int64_t, 4> strides;
    #####: 1640:    if (failed(getStridesAndOffset(dstType, strides, offset))) {
        -: 1641:      return rewriter.notifyMatchFailure(
    #####: 1642:          reshapeOp, "failed to get stride and offset exprs");
        -: 1643:    }
        -: 1644:
    #####: 1645:    MemRefDescriptor srcDesc(adaptor.getSrc());
    #####: 1646:    Location loc = reshapeOp->getLoc();
    #####: 1647:    auto dstDesc = MemRefDescriptor::undef(
    #####: 1648:        rewriter, loc, this->typeConverter->convertType(dstType));
    #####: 1649:    dstDesc.setAllocatedPtr(rewriter, loc, srcDesc.allocatedPtr(rewriter, loc));
    #####: 1650:    dstDesc.setAlignedPtr(rewriter, loc, srcDesc.alignedPtr(rewriter, loc));
    #####: 1651:    dstDesc.setOffset(rewriter, loc, srcDesc.offset(rewriter, loc));
        -: 1652:
    #####: 1653:    ArrayRef<int64_t> srcStaticShape = srcType.getShape();
    #####: 1654:    ArrayRef<int64_t> dstStaticShape = dstType.getShape();
    #####: 1655:    Type llvmIndexType =
    #####: 1656:        this->typeConverter->convertType(rewriter.getIndexType());
    #####: 1657:    SmallVector<Value> dstShape = getDynamicOutputShape(
        -: 1658:        rewriter, loc, llvmIndexType, reshapeOp.getReassociationIndices(),
        -: 1659:        srcStaticShape, srcDesc, dstStaticShape);
    #####: 1660:    for (auto &en : llvm::enumerate(dstShape))
    #####: 1661:      dstDesc.setSize(rewriter, loc, en.index(), en.value());
        -: 1662:
    #####: 1663:    if (llvm::all_of(strides, isStaticStrideOrOffset)) {
    #####: 1664:      for (auto &en : llvm::enumerate(strides))
    #####: 1665:        dstDesc.setConstantStride(rewriter, loc, en.index(), en.value());
    #####: 1666:    } else if (srcType.getLayout().isIdentity() &&
    #####: 1667:               dstType.getLayout().isIdentity()) {
    #####: 1668:      Value c1 = rewriter.create<LLVM::ConstantOp>(loc, llvmIndexType,
    #####: 1669:                                                   rewriter.getIndexAttr(1));
    #####: 1670:      Value stride = c1;
    #####: 1671:      for (auto dimIndex :
    #####: 1672:           llvm::reverse(llvm::seq<int64_t>(0, dstShape.size()))) {
    #####: 1673:        dstDesc.setStride(rewriter, loc, dimIndex, stride);
    #####: 1674:        stride = rewriter.create<LLVM::MulOp>(loc, dstShape[dimIndex], stride);
        -: 1675:      }
        -: 1676:    } else {
        -: 1677:      // There could be mixed static/dynamic strides. For simplicity, we
        -: 1678:      // recompute all strides if there is at least one dynamic stride.
    #####: 1679:      fillInDynamicStridesForMemDescriptor(
    #####: 1680:          rewriter, loc, reshapeOp, this->typeConverter, srcType, dstType,
        -: 1681:          srcDesc, dstDesc, reshapeOp.getReassociationIndices());
        -: 1682:    }
    #####: 1683:    rewriter.replaceOp(reshapeOp, {dstDesc});
    #####: 1684:    return success();
        -: 1685:  }
------------------
_ZNK12_GLOBAL__N_132ReassociatingReshapeOpConversionIN4mlir6memref13ExpandShapeOpEE15matchAndRewriteES3_NS2_20ExpandShapeOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132ReassociatingReshapeOpConversionIN4mlir6memref13ExpandShapeOpEE15matchAndRewriteES3_NS2_20ExpandShapeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1633:  matchAndRewrite(ReshapeOp reshapeOp, typename ReshapeOp::Adaptor adaptor,
        -: 1634:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1635:    MemRefType dstType = reshapeOp.getResultType();
call    0 never executed
    #####: 1636:    MemRefType srcType = reshapeOp.getSrcType();
call    0 never executed
call    1 never executed
        -: 1637:
        -: 1638:    int64_t offset;
    #####: 1639:    SmallVector<int64_t, 4> strides;
    #####: 1640:    if (failed(getStridesAndOffset(dstType, strides, offset))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1641:      return rewriter.notifyMatchFailure(
    #####: 1642:          reshapeOp, "failed to get stride and offset exprs");
call    0 never executed
        -: 1643:    }
        -: 1644:
    #####: 1645:    MemRefDescriptor srcDesc(adaptor.getSrc());
call    0 never executed
call    1 never executed
    #####: 1646:    Location loc = reshapeOp->getLoc();
call    0 never executed
    #####: 1647:    auto dstDesc = MemRefDescriptor::undef(
call    0 never executed
    #####: 1648:        rewriter, loc, this->typeConverter->convertType(dstType));
call    0 never executed
    #####: 1649:    dstDesc.setAllocatedPtr(rewriter, loc, srcDesc.allocatedPtr(rewriter, loc));
call    0 never executed
call    1 never executed
    #####: 1650:    dstDesc.setAlignedPtr(rewriter, loc, srcDesc.alignedPtr(rewriter, loc));
call    0 never executed
call    1 never executed
    #####: 1651:    dstDesc.setOffset(rewriter, loc, srcDesc.offset(rewriter, loc));
call    0 never executed
call    1 never executed
        -: 1652:
    #####: 1653:    ArrayRef<int64_t> srcStaticShape = srcType.getShape();
call    0 never executed
    #####: 1654:    ArrayRef<int64_t> dstStaticShape = dstType.getShape();
call    0 never executed
    #####: 1655:    Type llvmIndexType =
call    0 never executed
    #####: 1656:        this->typeConverter->convertType(rewriter.getIndexType());
call    0 never executed
    #####: 1657:    SmallVector<Value> dstShape = getDynamicOutputShape(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1658:        rewriter, loc, llvmIndexType, reshapeOp.getReassociationIndices(),
        -: 1659:        srcStaticShape, srcDesc, dstStaticShape);
    #####: 1660:    for (auto &en : llvm::enumerate(dstShape))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1661:      dstDesc.setSize(rewriter, loc, en.index(), en.value());
call    0 never executed
        -: 1662:
    #####: 1663:    if (llvm::all_of(strides, isStaticStrideOrOffset)) {
branch  0 never executed
branch  1 never executed
    #####: 1664:      for (auto &en : llvm::enumerate(strides))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1665:        dstDesc.setConstantStride(rewriter, loc, en.index(), en.value());
call    0 never executed
    #####: 1666:    } else if (srcType.getLayout().isIdentity() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1667:               dstType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
    #####: 1668:      Value c1 = rewriter.create<LLVM::ConstantOp>(loc, llvmIndexType,
call    0 never executed
call    1 never executed
    #####: 1669:                                                   rewriter.getIndexAttr(1));
call    0 never executed
    #####: 1670:      Value stride = c1;
    #####: 1671:      for (auto dimIndex :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1672:           llvm::reverse(llvm::seq<int64_t>(0, dstShape.size()))) {
call    0 never executed
call    1 never executed
    #####: 1673:        dstDesc.setStride(rewriter, loc, dimIndex, stride);
call    0 never executed
    #####: 1674:        stride = rewriter.create<LLVM::MulOp>(loc, dstShape[dimIndex], stride);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1675:      }
        -: 1676:    } else {
        -: 1677:      // There could be mixed static/dynamic strides. For simplicity, we
        -: 1678:      // recompute all strides if there is at least one dynamic stride.
    #####: 1679:      fillInDynamicStridesForMemDescriptor(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1680:          rewriter, loc, reshapeOp, this->typeConverter, srcType, dstType,
call    0 never executed
        -: 1681:          srcDesc, dstDesc, reshapeOp.getReassociationIndices());
        -: 1682:    }
    #####: 1683:    rewriter.replaceOp(reshapeOp, {dstDesc});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1684:    return success();
branch  0 never executed
branch  1 never executed
        -: 1685:  }
------------------
_ZNK12_GLOBAL__N_132ReassociatingReshapeOpConversionIN4mlir6memref15CollapseShapeOpEE15matchAndRewriteES3_NS2_22CollapseShapeOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_132ReassociatingReshapeOpConversionIN4mlir6memref15CollapseShapeOpEE15matchAndRewriteES3_NS2_22CollapseShapeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1633:  matchAndRewrite(ReshapeOp reshapeOp, typename ReshapeOp::Adaptor adaptor,
        -: 1634:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1635:    MemRefType dstType = reshapeOp.getResultType();
call    0 never executed
    #####: 1636:    MemRefType srcType = reshapeOp.getSrcType();
call    0 never executed
call    1 never executed
        -: 1637:
        -: 1638:    int64_t offset;
    #####: 1639:    SmallVector<int64_t, 4> strides;
    #####: 1640:    if (failed(getStridesAndOffset(dstType, strides, offset))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1641:      return rewriter.notifyMatchFailure(
    #####: 1642:          reshapeOp, "failed to get stride and offset exprs");
call    0 never executed
        -: 1643:    }
        -: 1644:
    #####: 1645:    MemRefDescriptor srcDesc(adaptor.getSrc());
call    0 never executed
call    1 never executed
    #####: 1646:    Location loc = reshapeOp->getLoc();
call    0 never executed
    #####: 1647:    auto dstDesc = MemRefDescriptor::undef(
call    0 never executed
    #####: 1648:        rewriter, loc, this->typeConverter->convertType(dstType));
call    0 never executed
    #####: 1649:    dstDesc.setAllocatedPtr(rewriter, loc, srcDesc.allocatedPtr(rewriter, loc));
call    0 never executed
call    1 never executed
    #####: 1650:    dstDesc.setAlignedPtr(rewriter, loc, srcDesc.alignedPtr(rewriter, loc));
call    0 never executed
call    1 never executed
    #####: 1651:    dstDesc.setOffset(rewriter, loc, srcDesc.offset(rewriter, loc));
call    0 never executed
call    1 never executed
        -: 1652:
    #####: 1653:    ArrayRef<int64_t> srcStaticShape = srcType.getShape();
call    0 never executed
    #####: 1654:    ArrayRef<int64_t> dstStaticShape = dstType.getShape();
call    0 never executed
    #####: 1655:    Type llvmIndexType =
call    0 never executed
    #####: 1656:        this->typeConverter->convertType(rewriter.getIndexType());
call    0 never executed
    #####: 1657:    SmallVector<Value> dstShape = getDynamicOutputShape(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1658:        rewriter, loc, llvmIndexType, reshapeOp.getReassociationIndices(),
        -: 1659:        srcStaticShape, srcDesc, dstStaticShape);
    #####: 1660:    for (auto &en : llvm::enumerate(dstShape))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1661:      dstDesc.setSize(rewriter, loc, en.index(), en.value());
call    0 never executed
        -: 1662:
    #####: 1663:    if (llvm::all_of(strides, isStaticStrideOrOffset)) {
branch  0 never executed
branch  1 never executed
    #####: 1664:      for (auto &en : llvm::enumerate(strides))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1665:        dstDesc.setConstantStride(rewriter, loc, en.index(), en.value());
call    0 never executed
    #####: 1666:    } else if (srcType.getLayout().isIdentity() &&
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1667:               dstType.getLayout().isIdentity()) {
call    0 never executed
call    1 never executed
    #####: 1668:      Value c1 = rewriter.create<LLVM::ConstantOp>(loc, llvmIndexType,
call    0 never executed
call    1 never executed
    #####: 1669:                                                   rewriter.getIndexAttr(1));
call    0 never executed
    #####: 1670:      Value stride = c1;
    #####: 1671:      for (auto dimIndex :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1672:           llvm::reverse(llvm::seq<int64_t>(0, dstShape.size()))) {
call    0 never executed
call    1 never executed
    #####: 1673:        dstDesc.setStride(rewriter, loc, dimIndex, stride);
call    0 never executed
    #####: 1674:        stride = rewriter.create<LLVM::MulOp>(loc, dstShape[dimIndex], stride);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -: 1675:      }
        -: 1676:    } else {
        -: 1677:      // There could be mixed static/dynamic strides. For simplicity, we
        -: 1678:      // recompute all strides if there is at least one dynamic stride.
    #####: 1679:      fillInDynamicStridesForMemDescriptor(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1680:          rewriter, loc, reshapeOp, this->typeConverter, srcType, dstType,
call    0 never executed
        -: 1681:          srcDesc, dstDesc, reshapeOp.getReassociationIndices());
        -: 1682:    }
    #####: 1683:    rewriter.replaceOp(reshapeOp, {dstDesc});
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1684:    return success();
branch  0 never executed
branch  1 never executed
        -: 1685:  }
------------------
        -: 1686:};
        -: 1687:
        -: 1688:/// Conversion pattern that transforms a subview op into:
        -: 1689:///   1. An `llvm.mlir.undef` operation to create a memref descriptor
        -: 1690:///   2. Updates to the descriptor to introduce the data ptr, offset, size
        -: 1691:///      and stride.
        -: 1692:/// The subview op is replaced by the descriptor.
        -: 1693:struct SubViewOpLowering : public ConvertOpToLLVMPattern<memref::SubViewOp> {
     3126: 1694:  using ConvertOpToLLVMPattern<memref::SubViewOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1695:
        -: 1696:  LogicalResult
function _ZNK12_GLOBAL__N_117SubViewOpLowering15matchAndRewriteEN4mlir6memref9SubViewOpENS2_16SubViewOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1697:  matchAndRewrite(memref::SubViewOp subViewOp, OpAdaptor adaptor,
        -: 1698:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1699:    auto loc = subViewOp.getLoc();
call    0 never executed
        -: 1700:
    #####: 1701:    auto sourceMemRefType = subViewOp.getSource().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1702:    auto sourceElementTy =
    #####: 1703:        typeConverter->convertType(sourceMemRefType.getElementType());
call    0 never executed
call    1 never executed
        -: 1704:
    #####: 1705:    auto viewMemRefType = subViewOp.getType();
call    0 never executed
    #####: 1706:    auto inferredType =
    #####: 1707:        memref::SubViewOp::inferResultType(
        -: 1708:            subViewOp.getSourceType(),
    #####: 1709:            extractFromI64ArrayAttr(subViewOp.getStaticOffsets()),
call    0 never executed
call    1 never executed
    #####: 1710:            extractFromI64ArrayAttr(subViewOp.getStaticSizes()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1711:            extractFromI64ArrayAttr(subViewOp.getStaticStrides()))
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 1712:            .cast<MemRefType>();
branch  0 never executed
branch  1 never executed
    #####: 1713:    auto targetElementTy =
    #####: 1714:        typeConverter->convertType(viewMemRefType.getElementType());
call    0 never executed
call    1 never executed
    #####: 1715:    auto targetDescTy = typeConverter->convertType(viewMemRefType);
call    0 never executed
    #####: 1716:    if (!sourceElementTy || !targetDescTy || !targetElementTy ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 1717:        !LLVM::isCompatibleType(sourceElementTy) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1718:        !LLVM::isCompatibleType(targetElementTy) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1719:        !LLVM::isCompatibleType(targetDescTy))
call    0 never executed
    #####: 1720:      return failure();
        -: 1721:
        -: 1722:    // Extract the offset and strides from the type.
    #####: 1723:    int64_t offset;
    #####: 1724:    SmallVector<int64_t, 4> strides;
call    0 never executed
    #####: 1725:    auto successStrides = getStridesAndOffset(inferredType, strides, offset);
call    0 never executed
    #####: 1726:    if (failed(successStrides))
branch  0 never executed
branch  1 never executed
    #####: 1727:      return failure();
        -: 1728:
        -: 1729:    // Create the descriptor.
    #####: 1730:    if (!LLVM::isCompatibleType(adaptor.getOperands().front().getType()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1731:      return failure();
    #####: 1732:    MemRefDescriptor sourceMemRef(adaptor.getOperands().front());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1733:    auto targetMemRef = MemRefDescriptor::undef(rewriter, loc, targetDescTy);
call    0 never executed
        -: 1734:
        -: 1735:    // Copy the buffer pointer from the old descriptor to the new one.
    #####: 1736:    Value extracted = sourceMemRef.allocatedPtr(rewriter, loc);
call    0 never executed
    #####: 1737:    Value bitcastPtr = rewriter.create<LLVM::BitcastOp>(
        -: 1738:        loc,
    #####: 1739:        LLVM::LLVMPointerType::get(targetElementTy,
    #####: 1740:                                   viewMemRefType.getMemorySpaceAsInt()),
call    0 never executed
call    1 never executed
    #####: 1741:        extracted);
call    0 never executed
call    1 never executed
    #####: 1742:    targetMemRef.setAllocatedPtr(rewriter, loc, bitcastPtr);
call    0 never executed
        -: 1743:
        -: 1744:    // Copy the aligned pointer from the old descriptor to the new one.
    #####: 1745:    extracted = sourceMemRef.alignedPtr(rewriter, loc);
call    0 never executed
    #####: 1746:    bitcastPtr = rewriter.create<LLVM::BitcastOp>(
        -: 1747:        loc,
    #####: 1748:        LLVM::LLVMPointerType::get(targetElementTy,
    #####: 1749:                                   viewMemRefType.getMemorySpaceAsInt()),
call    0 never executed
call    1 never executed
    #####: 1750:        extracted);
call    0 never executed
call    1 never executed
    #####: 1751:    targetMemRef.setAlignedPtr(rewriter, loc, bitcastPtr);
call    0 never executed
        -: 1752:
    #####: 1753:    size_t inferredShapeRank = inferredType.getRank();
call    0 never executed
    #####: 1754:    size_t resultShapeRank = viewMemRefType.getRank();
call    0 never executed
        -: 1755:
        -: 1756:    // Extract strides needed to compute offset.
    #####: 1757:    SmallVector<Value, 4> strideValues;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1758:    strideValues.reserve(inferredShapeRank);
branch  0 never executed
branch  1 never executed
    #####: 1759:    for (unsigned i = 0; i < inferredShapeRank; ++i)
branch  0 never executed
branch  1 never executed
    #####: 1760:      strideValues.push_back(sourceMemRef.stride(rewriter, loc, i));
call    0 never executed
call    1 never executed
        -: 1761:
        -: 1762:    // Offset.
    #####: 1763:    auto llvmIndexType = typeConverter->convertType(rewriter.getIndexType());
call    0 never executed
call    1 never executed
    #####: 1764:    if (!ShapedType::isDynamicStrideOrOffset(offset)) {
branch  0 never executed
branch  1 never executed
    #####: 1765:      targetMemRef.setConstantOffset(rewriter, loc, offset);
call    0 never executed
        -: 1766:    } else {
    #####: 1767:      Value baseOffset = sourceMemRef.offset(rewriter, loc);
call    0 never executed
        -: 1768:      // `inferredShapeRank` may be larger than the number of offset operands
        -: 1769:      // because of trailing semantics. In this case, the offset is guaranteed
        -: 1770:      // to be interpreted as 0 and we can just skip the extra dimensions.
    #####: 1771:      for (unsigned i = 0, e = std::min(inferredShapeRank,
    #####: 1772:                                        subViewOp.getMixedOffsets().size());
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1773:           i < e; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1774:        Value offset =
        -: 1775:            // TODO: need OpFoldResult ODS adaptor to clean this up.
    #####: 1776:            subViewOp.isDynamicOffset(i)
call    0 never executed
    #####: 1777:                ? adaptor.getOperands()[subViewOp.getIndexOfDynamicOffset(i)]
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1778:                : rewriter.create<LLVM::ConstantOp>(
        -: 1779:                      loc, llvmIndexType,
    #####: 1780:                      rewriter.getI64IntegerAttr(subViewOp.getStaticOffset(i)));
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1781:        Value mul = rewriter.create<LLVM::MulOp>(loc, offset, strideValues[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####: 1782:        baseOffset = rewriter.create<LLVM::AddOp>(loc, baseOffset, mul);
call    0 never executed
        -: 1783:      }
    #####: 1784:      targetMemRef.setOffset(rewriter, loc, baseOffset);
call    0 never executed
        -: 1785:    }
        -: 1786:
        -: 1787:    // Update sizes and strides.
    #####: 1788:    SmallVector<OpFoldResult> mixedSizes = subViewOp.getMixedSizes();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1789:    SmallVector<OpFoldResult> mixedStrides = subViewOp.getMixedStrides();
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1790:    assert(mixedSizes.size() == mixedStrides.size() &&
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1791:           "expected sizes and strides of equal length");
    #####: 1792:    llvm::SmallBitVector unusedDims = subViewOp.getDroppedDims();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1793:    for (int i = inferredShapeRank - 1, j = resultShapeRank - 1;
    #####: 1794:         i >= 0 && j >= 0; --i) {
branch  0 never executed
branch  1 never executed
    #####: 1795:      if (unusedDims.test(i))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1796:        continue;
        -: 1797:
        -: 1798:      // `i` may overflow subViewOp.getMixedSizes because of trailing semantics.
        -: 1799:      // In this case, the size is guaranteed to be interpreted as Dim and the
        -: 1800:      // stride as 1.
    #####: 1801:      Value size, stride;
    #####: 1802:      if (static_cast<unsigned>(i) >= mixedSizes.size()) {
branch  0 never executed
branch  1 never executed
        -: 1803:        // If the static size is available, use it directly. This is similar to
        -: 1804:        // the folding of dim(constant-op) but removes the need for dim to be
        -: 1805:        // aware of LLVM constants and for this pass to be aware of std
        -: 1806:        // constants.
    #####: 1807:        int64_t staticSize =
    #####: 1808:            subViewOp.getSource().getType().cast<MemRefType>().getShape()[i];
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1809:        if (staticSize != ShapedType::kDynamicSize) {
branch  0 never executed
branch  1 never executed
    #####: 1810:          size = rewriter.create<LLVM::ConstantOp>(
    #####: 1811:              loc, llvmIndexType, rewriter.getI64IntegerAttr(staticSize));
call    0 never executed
call    1 never executed
        -: 1812:        } else {
    #####: 1813:          Value pos = rewriter.create<LLVM::ConstantOp>(
    #####: 1814:              loc, llvmIndexType, rewriter.getI64IntegerAttr(i));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1815:          Value dim =
    #####: 1816:              rewriter.create<memref::DimOp>(loc, subViewOp.getSource(), pos);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1817:          auto cast = rewriter.create<UnrealizedConversionCastOp>(
    #####: 1818:              loc, llvmIndexType, dim);
call    0 never executed
    #####: 1819:          size = cast.getResult(0);
        -: 1820:        }
    #####: 1821:        stride = rewriter.create<LLVM::ConstantOp>(
    #####: 1822:            loc, llvmIndexType, rewriter.getI64IntegerAttr(1));
call    0 never executed
call    1 never executed
        -: 1823:      } else {
        -: 1824:        // TODO: need OpFoldResult ODS adaptor to clean this up.
    #####: 1825:        size =
branch  0 never executed
branch  1 never executed
    #####: 1826:            subViewOp.isDynamicSize(i)
call    0 never executed
    #####: 1827:                ? adaptor.getOperands()[subViewOp.getIndexOfDynamicSize(i)]
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1828:                : rewriter.create<LLVM::ConstantOp>(
        -: 1829:                      loc, llvmIndexType,
    #####: 1830:                      rewriter.getI64IntegerAttr(subViewOp.getStaticSize(i)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1831:        if (!ShapedType::isDynamicStrideOrOffset(strides[i])) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1832:          stride = rewriter.create<LLVM::ConstantOp>(
    #####: 1833:              loc, llvmIndexType, rewriter.getI64IntegerAttr(strides[i]));
call    0 never executed
call    1 never executed
        -: 1834:        } else {
    #####: 1835:          stride =
branch  0 never executed
branch  1 never executed
    #####: 1836:              subViewOp.isDynamicStride(i)
call    0 never executed
    #####: 1837:                  ? adaptor.getOperands()[subViewOp.getIndexOfDynamicStride(i)]
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1838:                  : rewriter.create<LLVM::ConstantOp>(
        -: 1839:                        loc, llvmIndexType,
    #####: 1840:                        rewriter.getI64IntegerAttr(
    #####: 1841:                            subViewOp.getStaticStride(i)));
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1842:          stride = rewriter.create<LLVM::MulOp>(loc, stride, strideValues[i]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1843:        }
        -: 1844:      }
    #####: 1845:      targetMemRef.setSize(rewriter, loc, j, size);
call    0 never executed
    #####: 1846:      targetMemRef.setStride(rewriter, loc, j, stride);
call    0 never executed
    #####: 1847:      j--;
        -: 1848:    }
        -: 1849:
    #####: 1850:    rewriter.replaceOp(subViewOp, {targetMemRef});
call    0 never executed
call    1 never executed
    #####: 1851:    return success();
call    0 never executed
        -: 1852:  }
        -: 1853:};
        -: 1854:
        -: 1855:/// Conversion pattern that transforms a transpose op into:
        -: 1856:///   1. A function entry `alloca` operation to allocate a ViewDescriptor.
        -: 1857:///   2. A load of the ViewDescriptor from the pointer allocated in 1.
        -: 1858:///   3. Updates to the ViewDescriptor to introduce the data ptr, offset, size
        -: 1859:///      and stride. Size and stride are permutations of the original values.
        -: 1860:///   4. A store of the resulting ViewDescriptor to the alloca'ed pointer.
        -: 1861:/// The transpose op is replaced by the alloca'ed pointer.
        -: 1862:class TransposeOpLowering : public ConvertOpToLLVMPattern<memref::TransposeOp> {
        -: 1863:public:
     3126: 1864:  using ConvertOpToLLVMPattern<memref::TransposeOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1865:
        -: 1866:  LogicalResult
function _ZNK12_GLOBAL__N_119TransposeOpLowering15matchAndRewriteEN4mlir6memref11TransposeOpENS2_18TransposeOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1867:  matchAndRewrite(memref::TransposeOp transposeOp, OpAdaptor adaptor,
        -: 1868:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1869:    auto loc = transposeOp.getLoc();
call    0 never executed
    #####: 1870:    MemRefDescriptor viewMemRef(adaptor.getIn());
call    0 never executed
call    1 never executed
        -: 1871:
        -: 1872:    // No permutation, early exit.
    #####: 1873:    if (transposeOp.getPermutation().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1874:      return rewriter.replaceOp(transposeOp, {viewMemRef}), success();
call    0 never executed
call    1 never executed
        -: 1875:
    #####: 1876:    auto targetMemRef = MemRefDescriptor::undef(
    #####: 1877:        rewriter, loc, typeConverter->convertType(transposeOp.getShapedType()));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1878:
        -: 1879:    // Copy the base and aligned pointers from the old descriptor to the new
        -: 1880:    // one.
    #####: 1881:    targetMemRef.setAllocatedPtr(rewriter, loc,
call    0 never executed
call    1 never executed
        -: 1882:                                 viewMemRef.allocatedPtr(rewriter, loc));
    #####: 1883:    targetMemRef.setAlignedPtr(rewriter, loc,
call    0 never executed
call    1 never executed
        -: 1884:                               viewMemRef.alignedPtr(rewriter, loc));
        -: 1885:
        -: 1886:    // Copy the offset pointer from the old descriptor to the new one.
    #####: 1887:    targetMemRef.setOffset(rewriter, loc, viewMemRef.offset(rewriter, loc));
call    0 never executed
call    1 never executed
        -: 1888:
        -: 1889:    // Iterate over the dimensions and apply size/stride permutation.
    #####: 1890:    for (const auto &en :
    #####: 1891:         llvm::enumerate(transposeOp.getPermutation().getResults())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1892:      int sourcePos = en.index();
call    0 never executed
    #####: 1893:      int targetPos = en.value().cast<AffineDimExpr>().getPosition();
call    0 never executed
call    1 never executed
    #####: 1894:      targetMemRef.setSize(rewriter, loc, targetPos,
call    0 never executed
call    1 never executed
        -: 1895:                           viewMemRef.size(rewriter, loc, sourcePos));
    #####: 1896:      targetMemRef.setStride(rewriter, loc, targetPos,
call    0 never executed
call    1 never executed
        -: 1897:                             viewMemRef.stride(rewriter, loc, sourcePos));
        -: 1898:    }
        -: 1899:
    #####: 1900:    rewriter.replaceOp(transposeOp, {targetMemRef});
call    0 never executed
call    1 never executed
    #####: 1901:    return success();
        -: 1902:  }
        -: 1903:};
        -: 1904:
        -: 1905:/// Conversion pattern that transforms an op into:
        -: 1906:///   1. An `llvm.mlir.undef` operation to create a memref descriptor
        -: 1907:///   2. Updates to the descriptor to introduce the data ptr, offset, size
        -: 1908:///      and stride.
        -: 1909:/// The view op is replaced by the descriptor.
        -: 1910:struct ViewOpLowering : public ConvertOpToLLVMPattern<memref::ViewOp> {
     3126: 1911:  using ConvertOpToLLVMPattern<memref::ViewOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 1912:
        -: 1913:  // Build and return the value for the idx^th shape dimension, either by
        -: 1914:  // returning the constant shape dimension or counting the proper dynamic size.
function _ZNK12_GLOBAL__N_114ViewOpLowering7getSizeERN4mlir25ConversionPatternRewriterENS1_8LocationEN4llvm8ArrayRefIlEENS1_10ValueRangeEj called 0 returned 0% blocks executed 0%
    #####: 1915:  Value getSize(ConversionPatternRewriter &rewriter, Location loc,
        -: 1916:                ArrayRef<int64_t> shape, ValueRange dynamicSizes,
        -: 1917:                unsigned idx) const {
    #####: 1918:    assert(idx < shape.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1919:    if (!ShapedType::isDynamic(shape[idx]))
branch  0 never executed
branch  1 never executed
    #####: 1920:      return createIndexConstant(rewriter, loc, shape[idx]);
call    0 never executed
        -: 1921:    // Count the number of dynamic dims in range [0, idx]
    #####: 1922:    unsigned nDynamic =
    #####: 1923:        llvm::count_if(shape.take_front(idx), ShapedType::isDynamic);
call    0 never executed
    #####: 1924:    return dynamicSizes[nDynamic];
call    0 never executed
        -: 1925:  }
        -: 1926:
        -: 1927:  // Build and return the idx^th stride, either by returning the constant stride
        -: 1928:  // or by computing the dynamic stride from the current `runningStride` and
        -: 1929:  // `nextSize`. The caller should keep a running stride and update it with the
        -: 1930:  // result returned by this function.
function _ZNK12_GLOBAL__N_114ViewOpLowering9getStrideERN4mlir25ConversionPatternRewriterENS1_8LocationEN4llvm8ArrayRefIlEENS1_5ValueES8_j called 0 returned 0% blocks executed 0%
    #####: 1931:  Value getStride(ConversionPatternRewriter &rewriter, Location loc,
        -: 1932:                  ArrayRef<int64_t> strides, Value nextSize,
        -: 1933:                  Value runningStride, unsigned idx) const {
    #####: 1934:    assert(idx < strides.size());
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1935:    if (!ShapedType::isDynamicStrideOrOffset(strides[idx]))
branch  0 never executed
branch  1 never executed
    #####: 1936:      return createIndexConstant(rewriter, loc, strides[idx]);
call    0 never executed
    #####: 1937:    if (nextSize)
branch  0 never executed
branch  1 never executed
    #####: 1938:      return runningStride
    #####: 1939:                 ? rewriter.create<LLVM::MulOp>(loc, runningStride, nextSize)
call    0 never executed
    #####: 1940:                 : nextSize;
branch  0 never executed
branch  1 never executed
    #####: 1941:    assert(!runningStride);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1942:    return createIndexConstant(rewriter, loc, 1);
call    0 never executed
        -: 1943:  }
        -: 1944:
        -: 1945:  LogicalResult
function _ZNK12_GLOBAL__N_114ViewOpLowering15matchAndRewriteEN4mlir6memref6ViewOpENS2_13ViewOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1946:  matchAndRewrite(memref::ViewOp viewOp, OpAdaptor adaptor,
        -: 1947:                  ConversionPatternRewriter &rewriter) const override {
    #####: 1948:    auto loc = viewOp.getLoc();
call    0 never executed
        -: 1949:
    #####: 1950:    auto viewMemRefType = viewOp.getType();
call    0 never executed
    #####: 1951:    auto targetElementTy =
    #####: 1952:        typeConverter->convertType(viewMemRefType.getElementType());
call    0 never executed
call    1 never executed
    #####: 1953:    auto targetDescTy = typeConverter->convertType(viewMemRefType);
call    0 never executed
    #####: 1954:    if (!targetDescTy || !targetElementTy ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1955:        !LLVM::isCompatibleType(targetElementTy) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1956:        !LLVM::isCompatibleType(targetDescTy))
call    0 never executed
    #####: 1957:      return viewOp.emitWarning("Target descriptor type not converted to LLVM"),
    #####: 1958:             failure();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1959:
    #####: 1960:    int64_t offset;
    #####: 1961:    SmallVector<int64_t, 4> strides;
call    0 never executed
    #####: 1962:    auto successStrides = getStridesAndOffset(viewMemRefType, strides, offset);
call    0 never executed
    #####: 1963:    if (failed(successStrides))
branch  0 never executed
branch  1 never executed
    #####: 1964:      return viewOp.emitWarning("cannot cast to non-strided shape"), failure();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1965:    assert(offset == 0 && "expected offset to be 0");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1966:
        -: 1967:    // Target memref must be contiguous in memory (innermost stride is 1), or
        -: 1968:    // empty (special case when at least one of the memref dimensions is 0).
    #####: 1969:    if (!strides.empty() && (strides.back() != 1 && strides.back() != 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1970:      return viewOp.emitWarning("cannot cast to non-contiguous shape"),
    #####: 1971:             failure();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1972:
        -: 1973:    // Create the descriptor.
    #####: 1974:    MemRefDescriptor sourceMemRef(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####: 1975:    auto targetMemRef = MemRefDescriptor::undef(rewriter, loc, targetDescTy);
call    0 never executed
        -: 1976:
        -: 1977:    // Field 1: Copy the allocated pointer, used for malloc/free.
    #####: 1978:    Value allocatedPtr = sourceMemRef.allocatedPtr(rewriter, loc);
call    0 never executed
    #####: 1979:    auto srcMemRefType = viewOp.getSource().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1980:    Value bitcastPtr = rewriter.create<LLVM::BitcastOp>(
        -: 1981:        loc,
    #####: 1982:        LLVM::LLVMPointerType::get(targetElementTy,
    #####: 1983:                                   srcMemRefType.getMemorySpaceAsInt()),
call    0 never executed
call    1 never executed
    #####: 1984:        allocatedPtr);
call    0 never executed
call    1 never executed
    #####: 1985:    targetMemRef.setAllocatedPtr(rewriter, loc, bitcastPtr);
call    0 never executed
        -: 1986:
        -: 1987:    // Field 2: Copy the actual aligned pointer to payload.
    #####: 1988:    Value alignedPtr = sourceMemRef.alignedPtr(rewriter, loc);
call    0 never executed
    #####: 1989:    alignedPtr = rewriter.create<LLVM::GEPOp>(
    #####: 1990:        loc, alignedPtr.getType(), alignedPtr, adaptor.getByteShift());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1991:    bitcastPtr = rewriter.create<LLVM::BitcastOp>(
        -: 1992:        loc,
    #####: 1993:        LLVM::LLVMPointerType::get(targetElementTy,
    #####: 1994:                                   srcMemRefType.getMemorySpaceAsInt()),
call    0 never executed
call    1 never executed
    #####: 1995:        alignedPtr);
call    0 never executed
call    1 never executed
    #####: 1996:    targetMemRef.setAlignedPtr(rewriter, loc, bitcastPtr);
call    0 never executed
        -: 1997:
        -: 1998:    // Field 3: The offset in the resulting type must be 0. This is because of
        -: 1999:    // the type change: an offset on srcType* may not be expressible as an
        -: 2000:    // offset on dstType*.
    #####: 2001:    targetMemRef.setOffset(rewriter, loc,
call    0 never executed
call    1 never executed
        -: 2002:                           createIndexConstant(rewriter, loc, offset));
        -: 2003:
        -: 2004:    // Early exit for 0-D corner case.
    #####: 2005:    if (viewMemRefType.getRank() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2006:      return rewriter.replaceOp(viewOp, {targetMemRef}), success();
call    0 never executed
call    1 never executed
        -: 2007:
        -: 2008:    // Fields 4 and 5: Update sizes and strides.
    #####: 2009:    Value stride = nullptr, nextSize = nullptr;
    #####: 2010:    for (int i = viewMemRefType.getRank() - 1; i >= 0; --i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2011:      // Update size.
    #####: 2012:      Value size = getSize(rewriter, loc, viewMemRefType.getShape(),
    #####: 2013:                           adaptor.getSizes(), i);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2014:      targetMemRef.setSize(rewriter, loc, i, size);
call    0 never executed
        -: 2015:      // Update stride.
    #####: 2016:      stride = getStride(rewriter, loc, strides, nextSize, stride, i);
call    0 never executed
    #####: 2017:      targetMemRef.setStride(rewriter, loc, i, stride);
call    0 never executed
    #####: 2018:      nextSize = size;
        -: 2019:    }
        -: 2020:
    #####: 2021:    rewriter.replaceOp(viewOp, {targetMemRef});
call    0 never executed
call    1 never executed
    #####: 2022:    return success();
branch  0 never executed
branch  1 never executed
        -: 2023:  }
        -: 2024:};
        -: 2025:
        -: 2026://===----------------------------------------------------------------------===//
        -: 2027:// AtomicRMWOpLowering
        -: 2028://===----------------------------------------------------------------------===//
        -: 2029:
        -: 2030:/// Try to match the kind of a memref.atomic_rmw to determine whether to use a
        -: 2031:/// lowering to llvm.atomicrmw or fallback to llvm.cmpxchg.
        -: 2032:static Optional<LLVM::AtomicBinOp>
function _ZN12_GLOBAL__N_1L19matchSimpleAtomicOpEN4mlir6memref11AtomicRMWOpE called 0 returned 0% blocks executed 0%
    #####: 2033:matchSimpleAtomicOp(memref::AtomicRMWOp atomicOp) {
    #####: 2034:  switch (atomicOp.getKind()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
    #####: 2035:  case arith::AtomicRMWKind::addf:
    #####: 2036:    return LLVM::AtomicBinOp::fadd;
    #####: 2037:  case arith::AtomicRMWKind::addi:
    #####: 2038:    return LLVM::AtomicBinOp::add;
    #####: 2039:  case arith::AtomicRMWKind::assign:
    #####: 2040:    return LLVM::AtomicBinOp::xchg;
    #####: 2041:  case arith::AtomicRMWKind::maxs:
    #####: 2042:    return LLVM::AtomicBinOp::max;
    #####: 2043:  case arith::AtomicRMWKind::maxu:
    #####: 2044:    return LLVM::AtomicBinOp::umax;
    #####: 2045:  case arith::AtomicRMWKind::mins:
    #####: 2046:    return LLVM::AtomicBinOp::min;
    #####: 2047:  case arith::AtomicRMWKind::minu:
    #####: 2048:    return LLVM::AtomicBinOp::umin;
    #####: 2049:  case arith::AtomicRMWKind::ori:
    #####: 2050:    return LLVM::AtomicBinOp::_or;
    #####: 2051:  case arith::AtomicRMWKind::andi:
    #####: 2052:    return LLVM::AtomicBinOp::_and;
    #####: 2053:  default:
    #####: 2054:    return llvm::None;
        -: 2055:  }
        -: 2056:  llvm_unreachable("Invalid AtomicRMWKind");
        -: 2057:}
        -: 2058:
        -: 2059:struct AtomicRMWOpLowering : public LoadStoreOpLowering<memref::AtomicRMWOp> {
     3126: 2060:  using Base::Base;
call    0 returned 100%
        -: 2061:
        -: 2062:  LogicalResult
function _ZNK12_GLOBAL__N_119AtomicRMWOpLowering15matchAndRewriteEN4mlir6memref11AtomicRMWOpENS2_18AtomicRMWOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2063:  matchAndRewrite(memref::AtomicRMWOp atomicOp, OpAdaptor adaptor,
        -: 2064:                  ConversionPatternRewriter &rewriter) const override {
    #####: 2065:    if (failed(match(atomicOp)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2066:      return failure();
    #####: 2067:    auto maybeKind = matchSimpleAtomicOp(atomicOp);
call    0 never executed
    #####: 2068:    if (!maybeKind)
branch  0 never executed
branch  1 never executed
    #####: 2069:      return failure();
    #####: 2070:    auto resultType = adaptor.getValue().getType();
call    0 never executed
call    1 never executed
    #####: 2071:    auto memRefType = atomicOp.getMemRefType();
call    0 never executed
    #####: 2072:    auto dataPtr =
        -: 2073:        getStridedElementPtr(atomicOp.getLoc(), memRefType, adaptor.getMemref(),
    #####: 2074:                             adaptor.getIndices(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2075:    rewriter.replaceOpWithNewOp<LLVM::AtomicRMWOp>(
    #####: 2076:        atomicOp, resultType, *maybeKind, dataPtr, adaptor.getValue(),
branch  0 never executed
branch  1 never executed
    #####: 2077:        LLVM::AtomicOrdering::acq_rel);
call    0 never executed
call    1 never executed
    #####: 2078:    return success();
        -: 2079:  }
        -: 2080:};
        -: 2081:
        -: 2082:/// Unpack the pointer returned by a memref.extract_aligned_pointer_as_index.
        -: 2083:class ConvertExtractAlignedPointerAsIndex
        -: 2084:    : public ConvertOpToLLVMPattern<memref::ExtractAlignedPointerAsIndexOp> {
        -: 2085:public:
        -: 2086:  using ConvertOpToLLVMPattern<
     3126: 2087:      memref::ExtractAlignedPointerAsIndexOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 2088:
        -: 2089:  LogicalResult
function _ZNK12_GLOBAL__N_135ConvertExtractAlignedPointerAsIndex15matchAndRewriteEN4mlir6memref30ExtractAlignedPointerAsIndexOpENS2_37ExtractAlignedPointerAsIndexOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2090:  matchAndRewrite(memref::ExtractAlignedPointerAsIndexOp extractOp,
        -: 2091:                  OpAdaptor adaptor,
        -: 2092:                  ConversionPatternRewriter &rewriter) const override {
    #####: 2093:    MemRefDescriptor desc(adaptor.getSource());
call    0 never executed
call    1 never executed
    #####: 2094:    rewriter.replaceOpWithNewOp<LLVM::PtrToIntOp>(
    #####: 2095:        extractOp, getTypeConverter()->getIndexType(),
call    0 never executed
call    1 never executed
    #####: 2096:        desc.alignedPtr(rewriter, extractOp->getLoc()));
call    0 never executed
call    1 never executed
    #####: 2097:    return success();
        -: 2098:  }
        -: 2099:};
        -: 2100:
        -: 2101:/// Materialize the MemRef descriptor represented by the results of
        -: 2102:/// ExtractStridedMetadataOp.
        -: 2103:class ExtractStridedMetadataOpLowering
        -: 2104:    : public ConvertOpToLLVMPattern<memref::ExtractStridedMetadataOp> {
        -: 2105:public:
        -: 2106:  using ConvertOpToLLVMPattern<
     3126: 2107:      memref::ExtractStridedMetadataOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -: 2108:
        -: 2109:  LogicalResult
function _ZNK12_GLOBAL__N_132ExtractStridedMetadataOpLowering15matchAndRewriteEN4mlir6memref24ExtractStridedMetadataOpENS2_31ExtractStridedMetadataOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 2110:  matchAndRewrite(memref::ExtractStridedMetadataOp extractStridedMetadataOp,
        -: 2111:                  OpAdaptor adaptor,
        -: 2112:                  ConversionPatternRewriter &rewriter) const override {
        -: 2113:
    #####: 2114:    if (!LLVM::isCompatibleType(adaptor.getOperands().front().getType()))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2115:      return failure();
        -: 2116:
        -: 2117:    // Create the descriptor.
    #####: 2118:    MemRefDescriptor sourceMemRef(adaptor.getOperands().front());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 2119:    Location loc = extractStridedMetadataOp.getLoc();
call    0 never executed
    #####: 2120:    Value source = extractStridedMetadataOp.getSource();
call    0 never executed
        -: 2121:
    #####: 2122:    auto sourceMemRefType = source.getType().cast<MemRefType>();
call    0 never executed
    #####: 2123:    int64_t rank = sourceMemRefType.getRank();
call    0 never executed
    #####: 2124:    SmallVector<Value> results;
branch  0 never executed
branch  1 never executed
    #####: 2125:    results.reserve(2 + rank * 2);
branch  0 never executed
branch  1 never executed
        -: 2126:
        -: 2127:    // Base buffer.
    #####: 2128:    results.push_back(sourceMemRef.allocatedPtr(rewriter, loc));
call    0 never executed
call    1 never executed
        -: 2129:
        -: 2130:    // Offset.
    #####: 2131:    results.push_back(sourceMemRef.offset(rewriter, loc));
call    0 never executed
        -: 2132:
        -: 2133:    // Sizes.
    #####: 2134:    for (unsigned i = 0; i < rank; ++i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2135:      results.push_back(sourceMemRef.size(rewriter, loc, i));
call    0 never executed
call    1 never executed
        -: 2136:    // Strides.
    #####: 2137:    for (unsigned i = 0; i < rank; ++i)
branch  0 never executed
branch  1 never executed
    #####: 2138:      results.push_back(sourceMemRef.stride(rewriter, loc, i));
call    0 never executed
call    1 never executed
        -: 2139:
    #####: 2140:    rewriter.replaceOp(extractStridedMetadataOp, results);
call    0 never executed
call    1 never executed
    #####: 2141:    return success();
branch  0 never executed
branch  1 never executed
        -: 2142:  }
        -: 2143:};
        -: 2144:
        -: 2145:} // namespace
        -: 2146:
function _ZN4mlir38populateMemRefToLLVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 3126 returned 100% blocks executed 83%
     3126: 2147:void mlir::populateMemRefToLLVMConversionPatterns(LLVMTypeConverter &converter,
        -: 2148:                                                  RewritePatternSet &patterns) {
        -: 2149:  // clang-format off
     3126: 2150:  patterns.add<
        -: 2151:      AllocaOpLowering,
        -: 2152:      AllocaScopeOpLowering,
        -: 2153:      AtomicRMWOpLowering,
        -: 2154:      AssumeAlignmentOpLowering,
        -: 2155:      ConvertExtractAlignedPointerAsIndex,
        -: 2156:      DimOpLowering,
        -: 2157:      ExtractStridedMetadataOpLowering,
        -: 2158:      GenericAtomicRMWOpLowering,
        -: 2159:      GlobalMemrefOpLowering,
        -: 2160:      GetGlobalMemrefOpLowering,
        -: 2161:      LoadOpLowering,
        -: 2162:      MemRefCastOpLowering,
        -: 2163:      MemRefCopyOpLowering,
        -: 2164:      MemRefReinterpretCastOpLowering,
        -: 2165:      MemRefReshapeOpLowering,
        -: 2166:      PrefetchOpLowering,
        -: 2167:      RankOpLowering,
        -: 2168:      ReassociatingReshapeOpConversion<memref::ExpandShapeOp>,
        -: 2169:      ReassociatingReshapeOpConversion<memref::CollapseShapeOp>,
        -: 2170:      StoreOpLowering,
        -: 2171:      SubViewOpLowering,
        -: 2172:      TransposeOpLowering,
     3126: 2173:      ViewOpLowering>(converter);
call    0 returned 100%
        -: 2174:  // clang-format on
     3126: 2175:  auto allocLowering = converter.getOptions().allocLowering;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     3126: 2176:  if (allocLowering == LowerToLLVMOptions::AllocLowering::AlignedAlloc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2177:    patterns.add<AlignedAllocOpLowering, AlignedReallocOpLowering,
    #####: 2178:                 DeallocOpLowering>(converter);
call    0 never executed
     3126: 2179:  else if (allocLowering == LowerToLLVMOptions::AllocLowering::Malloc)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3126: 2180:    patterns.add<AllocOpLowering, ReallocOpLowering, DeallocOpLowering>(
     3126: 2181:        converter);
call    0 returned 100%
     3126: 2182:}
        -: 2183:
        -: 2184:namespace {
  129865*: 2185:struct MemRefToLLVMConversionPass
call    0 never executed
call    1 returned 100%
        -: 2186:    : public impl::MemRefToLLVMConversionPassBase<MemRefToLLVMConversionPass> {
    #####: 2187:  using MemRefToLLVMConversionPassBase::MemRefToLLVMConversionPassBase;
call    0 never executed
        -: 2188:
function _ZN12_GLOBAL__N_126MemRefToLLVMConversionPass14runOnOperationEv called 1030 returned 100% blocks executed 93%
     1030: 2189:  void runOnOperation() override {
     1030: 2190:    Operation *op = getOperation();
call    0 returned 100%
call    1 returned 100%
     1030: 2191:    const auto &dataLayoutAnalysis = getAnalysis<DataLayoutAnalysis>();
call    0 returned 100%
     1030: 2192:    LowerToLLVMOptions options(&getContext(),
call    0 returned 100%
     2060: 2193:                               dataLayoutAnalysis.getAtOrAbove(op));
call    0 returned 100%
call    1 returned 100%
     2060: 2194:    options.allocLowering =
     1030: 2195:        (useAlignedAlloc ? LowerToLLVMOptions::AllocLowering::AlignedAlloc
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1030: 2196:                         : LowerToLLVMOptions::AllocLowering::Malloc);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2197:
     1030: 2198:    options.useGenericFunctions = useGenericFunctions;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2199:
     1030: 2200:    if (indexBitwidth != kDeriveIndexBitwidthFromDataLayout)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2201:      options.overrideIndexBitwidth(indexBitwidth);
        -: 2202:
     1030: 2203:    LLVMTypeConverter typeConverter(&getContext(), options,
call    0 returned 100%
     2060: 2204:                                    &dataLayoutAnalysis);
call    0 returned 100%
call    1 returned 100%
     2060: 2205:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1030: 2206:    populateMemRefToLLVMConversionPatterns(typeConverter, patterns);
call    0 returned 100%
     2060: 2207:    LLVMConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1030: 2208:    target.addLegalOp<func::FuncOp>();
call    0 returned 100%
     1030: 2209:    if (failed(applyPartialConversion(op, target, std::move(patterns))))
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####: 2210:      signalPassFailure();
call    0 never executed
     1030: 2211:  }
        -: 2212:};
        -: 2213:} // namespace
