        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Linalg/Transforms/Detensorize.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Linalg/Transforms/CMakeFiles/obj.MLIRLinalgTransforms.dir/Detensorize.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Linalg/Transforms/CMakeFiles/obj.MLIRLinalgTransforms.dir/Detensorize.cpp.gcda
        -:    0:Runs:128628
        -:    1://===- Detensorize.cpp - Linalg transformations as patterns ----------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Linalg/Passes.h"
        -:   10:
        -:   11:#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
        -:   12:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   13:#include "mlir/Dialect/Func/Transforms/FuncConversions.h"
        -:   14:#include "mlir/Dialect/Linalg/IR/Linalg.h"
        -:   15:#include "mlir/Dialect/Tensor/IR/Tensor.h"
        -:   16:#include "mlir/IR/OpDefinition.h"
        -:   17:#include "mlir/Transforms/DialectConversion.h"
        -:   18:#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
        -:   19:#include <iterator>
        -:   20:#include <memory>
        -:   21:#include <utility>
        -:   22:
        -:   23:namespace mlir {
        -:   24:#define GEN_PASS_DEF_LINALGDETENSORIZE
        -:   25:#include "mlir/Dialect/Linalg/Passes.h.inc"
        -:   26:} // namespace mlir
        -:   27:
        -:   28:using namespace mlir;
        -:   29:using namespace mlir::linalg;
        -:   30:
function _ZL29sourceMaterializationCallbackRN4mlir9OpBuilderENS_4TypeENS_10ValueRangeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:   31:static Value sourceMaterializationCallback(OpBuilder &builder, Type type,
        -:   32:                                           ValueRange inputs, Location loc) {
    #####:   33:  assert(inputs.size() == 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   34:  auto inputType = inputs[0].getType();
call    0 never executed
call    1 never executed
    #####:   35:  if (inputType.isa<TensorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   36:    return nullptr;
        -:   37:
        -:   38:  // A detensored value is converted back by creating a new tensor from its
        -:   39:  // element(s).
    #####:   40:  return builder.create<tensor::FromElementsOp>(
    #####:   41:      loc, RankedTensorType::get({}, inputType), inputs[0]);
call    0 never executed
call    1 never executed
call    2 never executed
        -:   42:}
        -:   43:
        -:   44:namespace {
        -:   45:/// Defines the criteria a TensorType must follow in order to be considered
        -:   46:/// "detensorable".
        -:   47:///
        -:   48:/// NOTE: For now, only 0-D tensors are supported.
        -:   49:///
        -:   50:/// Returns true if tensorType can be detensored.
function _ZN12_GLOBAL__N_115canBeDetensoredEN4mlir10TensorTypeE called 0 returned 0% blocks executed 0%
    #####:   51:bool canBeDetensored(TensorType tensorType) {
    #####:   52:  return tensorType.hasRank() && tensorType.getRank() == 0;
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:   53:}
        -:   54:
function _ZN12_GLOBAL__N_118shouldBeDetensoredEPN4mlir9OperationENS0_13TypeConverterE called 0 returned 0% blocks executed 0%
    #####:   55:bool shouldBeDetensored(Operation *op, TypeConverter typeConverter) {
    #####:   56:  GenericOp genericOp = dyn_cast_or_null<GenericOp>(op);
branch  0 never executed
branch  1 never executed
    #####:   57:  return genericOp &&
branch  0 never executed
branch  1 never executed
    #####:   58:         llvm::all_of(genericOp->getOpOperands(), [&](OpOperand &opOperand) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   59:           return !typeConverter.isLegal(opOperand.get().getType());
    #####:   60:         });
branch  0 never executed
branch  1 never executed
        -:   61:}
        -:   62:
        -:   63:/// A conversion patttern for detensoring `linalg.generic` ops.
        -:   64:class DetensorizeGenericOp : public OpConversionPattern<GenericOp> {
        -:   65:public:
        -:   66:  using OpConversionPattern::OpConversionPattern;
        -:   67:  LogicalResult
function _ZNK12_GLOBAL__N_120DetensorizeGenericOp15matchAndRewriteEN4mlir6linalg9GenericOpENS2_16GenericOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   68:  matchAndRewrite(GenericOp op, OpAdaptor adaptor,
        -:   69:                  ConversionPatternRewriter &rewriter) const override {
    #####:   70:    Block *originalBlock = op->getBlock();
call    0 never executed
        -:   71:
        -:   72:    // Gather some information about the op before inling its region.
    #####:   73:    Block *opEntryBlock = &*op.getRegion().begin();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   74:    YieldOp yieldOp = dyn_cast<YieldOp>(op.getRegion().back().getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   75:
        -:   76:    // Split the op's region before the op. This way, we have a clear insertion
        -:   77:    // point in which the op can be inlined.
    #####:   78:    Block *newBlock = rewriter.splitBlock(originalBlock, Block::iterator(op));
call    0 never executed
call    1 never executed
    #####:   79:    rewriter.inlineRegionBefore(op.getRegion(), newBlock);
call    0 never executed
call    1 never executed
        -:   80:    // Now that op's region is inlined, the operands of its YieldOp are mapped
        -:   81:    // to the materialized target values. Therefore, we can replace the op's
        -:   82:    // uses with those of its YielOp's operands.
    #####:   83:    rewriter.replaceOp(op, yieldOp->getOperands());
call    0 never executed
call    1 never executed
call    2 never executed
        -:   84:
        -:   85:    // No need for these intermediate blocks, merge them into 1.
    #####:   86:    rewriter.mergeBlocks(opEntryBlock, originalBlock, adaptor.getOperands());
call    0 never executed
call    1 never executed
    #####:   87:    rewriter.mergeBlocks(newBlock, originalBlock, {});
call    0 never executed
call    1 never executed
        -:   88:
    #####:   89:    rewriter.eraseOp(&*Block::iterator(yieldOp));
call    0 never executed
call    1 never executed
call    2 never executed
        -:   90:
    #####:   91:    return success();
        -:   92:  }
        -:   93:};
        -:   94:
        -:   95:/// A conversion pattern for detensoring internal (non-entry) blocks within a
        -:   96:/// function.
        -:   97:struct FunctionNonEntryBlockConversion
        -:   98:    : public OpInterfaceConversionPattern<FunctionOpInterface> {
function _ZN12_GLOBAL__N_131FunctionNonEntryBlockConversionC2EPN4mlir11MLIRContextERNS1_13TypeConverterEN4llvm8DenseSetINS1_13BlockArgumentENS6_12DenseMapInfoIS8_vEEEE called 0 returned 0% blocks executed 0%
    #####:   99:  FunctionNonEntryBlockConversion(MLIRContext *ctx, TypeConverter &converter,
        -:  100:                                  DenseSet<BlockArgument> blockArgsToDetensor)
    #####:  101:      : OpInterfaceConversionPattern(converter, ctx),
    #####:  102:        blockArgsToDetensor(std::move(blockArgsToDetensor)) {}
call    0 never executed
call    1 never executed
        -:  103:
        -:  104:  LogicalResult
function _ZNK12_GLOBAL__N_131FunctionNonEntryBlockConversion15matchAndRewriteEN4mlir19FunctionOpInterfaceEN4llvm8ArrayRefINS1_5ValueEEERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  105:  matchAndRewrite(FunctionOpInterface op, ArrayRef<Value> operands,
        -:  106:                  ConversionPatternRewriter &rewriter) const override {
    #####:  107:    rewriter.startRootUpdate(op);
call    0 never executed
    #####:  108:    Region &region = op.getFunctionBody();
call    0 never executed
    #####:  109:    SmallVector<TypeConverter::SignatureConversion, 2> conversions;
        -:  110:
    #####:  111:    for (Block &block : llvm::drop_begin(region, 1)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  112:      conversions.emplace_back(block.getNumArguments());
call    0 never executed
    #####:  113:      TypeConverter::SignatureConversion &back = conversions.back();
call    0 never executed
        -:  114:
    #####:  115:      for (BlockArgument blockArgument : block.getArguments()) {
branch  0 never executed
branch  1 never executed
    #####:  116:        int idx = blockArgument.getArgNumber();
call    0 never executed
        -:  117:
    #####:  118:        if (blockArgsToDetensor.count(blockArgument))
call    0 never executed
    #####:  119:          back.addInputs(idx, {getTypeConverter()->convertType(
call    0 never executed
    #####:  120:                                  block.getArgumentTypes()[idx])});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  121:        else
    #####:  122:          back.addInputs(idx, {block.getArgumentTypes()[idx]});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  123:      }
        -:  124:    }
        -:  125:
    #####:  126:    if (failed(rewriter.convertNonEntryRegionTypes(&region, *typeConverter,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  127:                                                   conversions))) {
    #####:  128:      rewriter.cancelRootUpdate(op);
call    0 never executed
    #####:  129:      return failure();
        -:  130:    }
        -:  131:
    #####:  132:    rewriter.finalizeRootUpdate(op);
call    0 never executed
    #####:  133:    return success();
call    0 never executed
        -:  134:  }
        -:  135:
        -:  136:private:
        -:  137:  const DenseSet<BlockArgument> blockArgsToDetensor;
        -:  138:};
        -:  139:
    #####:  140:class DetensorizeTypeConverter : public TypeConverter {
        -:  141:public:
function _ZN12_GLOBAL__N_124DetensorizeTypeConverterC2Ev called 0 returned 0% blocks executed 0%
    #####:  142:  DetensorizeTypeConverter() {
call    0 never executed
    #####:  143:    addConversion([](Type type) { return type; });
call    0 never executed
call    1 never executed
        -:  144:
        -:  145:    // A TensorType that can be detensored, is converted to the underlying
        -:  146:    // element type.
function _ZZN12_GLOBAL__N_124DetensorizeTypeConverterC4EvENKUlN4mlir10TensorTypeEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  147:    addConversion([](TensorType tensorType) -> Type {
call    0 never executed
    #####:  148:      if (canBeDetensored(tensorType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  149:        return tensorType.getElementType();
call    0 never executed
        -:  150:
    #####:  151:      return tensorType;
        -:  152:    });
        -:  153:
        -:  154:    // A tensor value is detensoried by extracting its element(s).
function _ZZN12_GLOBAL__N_124DetensorizeTypeConverterC4EvENKUlRN4mlir9OpBuilderENS1_4TypeENS1_10ValueRangeENS1_8LocationEE1_clES3_S4_S5_S6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  155:    addTargetMaterialization([](OpBuilder &builder, Type type,
call    0 never executed
        -:  156:                                ValueRange inputs, Location loc) -> Value {
    #####:  157:      return builder.create<tensor::ExtractOp>(loc, inputs[0], ValueRange{});
call    0 never executed
call    1 never executed
call    2 never executed
        -:  158:    });
        -:  159:
    #####:  160:    addSourceMaterialization(sourceMaterializationCallback);
call    0 never executed
    #####:  161:    addArgumentMaterialization(sourceMaterializationCallback);
call    0 never executed
    #####:  162:  }
        -:  163:};
        -:  164:
        -:  165:/// @see LinalgDetensorize in Linalg/Passes.td for more details.
    #####:  166:struct LinalgDetensorize
call    0 never executed
        -:  167:    : public impl::LinalgDetensorizeBase<LinalgDetensorize> {
   128628:  168:  LinalgDetensorize() = default;
call    0 returned 100%
        -:  169:
        -:  170:  class CostModel {
        -:  171:  public:
    #####:  172:    virtual ~CostModel() = default;
        -:  173:
        -:  174:    /// A cost model algorithm computes the following outputs:
        -:  175:    ///
        -:  176:    /// - opsToDetensor: the list of linalg ops that should be
        -:  177:    /// detensored.
        -:  178:    ///
        -:  179:    /// - blockArgsToDetensor: since the operands and results of detensored
        -:  180:    /// linalg ops can cross the BB boundary (e.g. a linalg op's input can come
        -:  181:    /// from a BB argument and a linalg op's output can be passed to successor
        -:  182:    /// BBs), we need to maintain the sub-set of arguments that should be
        -:  183:    /// detensored (i.e. converted by typeConverter) for each affected BB.
        -:  184:    ///
        -:  185:    /// Example:
        -:  186:    ///
        -:  187:    /// For the following snippet:
        -:  188:    /// ...
        -:  189:    /// ^bb1(%6: tensor<i32>, %9: tensor<i32>):
        -:  190:    ///   %7 = tensor.empty() : tensor<i32>
        -:  191:    ///   %8 = linalg.generic #attrs
        -:  192:    ///     ins(%6, %6 : tensor<i32>, tensor<i32>)
        -:  193:    ///     outs(%7 : tensor<i32>) {
        -:  194:    ///     ^bb0(%arg0: i32, %arg1: i32, %arg2: i32):
        -:  195:    ///       %9 = arith.addi %arg0, %arg1 : i32
        -:  196:    ///       linalg.yield %9 : i32
        -:  197:    ///   } -> tensor<i32>
        -:  198:    ///   %10 = "some.op"(%9)
        -:  199:    ///   br ^bb2(%8 : tensor<i32>)
        -:  200:    /// ...
        -:  201:    ///
        -:  202:    /// if the cost model decides that the linalg.generic op should be
        -:  203:    /// detensored, then:
        -:  204:    /// - opsToDetensor should be = {linalg.generic{add}}.
        -:  205:    /// - blockArgsToDetensor should be = {bb1 -> {0}, bb2 -> {0}}.
        -:  206:    virtual void compute(FunctionOpInterface func,
        -:  207:                         DetensorizeTypeConverter typeConverter,
        -:  208:                         DenseSet<Operation *> &opsToDetensor,
        -:  209:                         DenseSet<BlockArgument> &blockArgsToDetensor) = 0;
        -:  210:
        -:  211:    /// From the blockArgsToDetensor set computed by a CostModel
        -:  212:    /// implementation, this method computes the corresponding branch op
        -:  213:    /// detensoring. The result is a map from a branch op to a subset of indices
        -:  214:    /// of its operands. The indices specify which of the branch op's operands
        -:  215:    /// should be detensored.
        -:  216:    ///
        -:  217:    /// For the previous example, this method would compute: {bb2 -> {0}}.
function _ZN12_GLOBAL__N_117LinalgDetensorize9CostModel26computeBranchOpDetensoringERKN4llvm8DenseSetIN4mlir13BlockArgumentENS2_12DenseMapInfoIS5_vEEEE called 0 returned 0% blocks executed 0%
    #####:  218:    static DenseMap<Operation *, DenseSet<int>> computeBranchOpDetensoring(
        -:  219:        const DenseSet<BlockArgument> &blockArgsToDetensor) {
    #####:  220:      DenseMap<Operation *, DenseSet<int>> detensorableBranchOps;
call    0 never executed
        -:  221:
    #####:  222:      for (auto blockArgumentElem : blockArgsToDetensor) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  223:        Block *block = blockArgumentElem.getOwner();
        -:  224:
    #####:  225:        for (PredecessorIterator pred = block->pred_begin();
branch  0 never executed
branch  1 never executed
    #####:  226:             pred != block->pred_end(); ++pred) {
branch  0 never executed
branch  1 never executed
    #####:  227:          BranchOpInterface terminator =
call    0 never executed
    #####:  228:              dyn_cast<BranchOpInterface>((*pred)->getTerminator());
call    0 never executed
call    1 never executed
    #####:  229:          auto blockOperands =
    #####:  230:              terminator.getSuccessorOperands(pred.getSuccessorIndex());
call    0 never executed
call    1 never executed
        -:  231:
    #####:  232:          if (blockOperands.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  233:              blockOperands.isOperandProduced(blockArgumentElem.getArgNumber()))
branch  0 never executed
branch  1 never executed
    #####:  234:            continue;
branch  0 never executed
branch  1 never executed
        -:  235:
    #####:  236:          detensorableBranchOps[terminator].insert(
call    0 never executed
    #####:  237:              blockOperands.getOperandIndex(blockArgumentElem.getArgNumber()));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  238:        }
        -:  239:      }
        -:  240:
    #####:  241:      return detensorableBranchOps;
        -:  242:    }
        -:  243:  };
        -:  244:
        -:  245:  /// Detensorize linalg ops involved in control-flow within a function.
        -:  246:  ///
        -:  247:  /// This model starts from BranchOps and CondBranchOps within a function. For
        -:  248:  /// each such branch, the model then walks the use-def chain for the branch's
        -:  249:  /// condition backwards in order to understand where the condition's value
        -:  250:  /// comes from. If the condition value is (indirectly) computed by a linalg op
        -:  251:  /// that can be detensored, the model then continues walking the use-def chain
        -:  252:  /// in order to understand where the linalg op's operands come from. This
        -:  253:  /// leads to discovering a "detensoring component". A detensoring component is
        -:  254:  /// the set of operations + block arguments that are involved in control-flow
        -:  255:  /// AND can be detensored.
    #####:  256:  class ControlFlowDetectionModel : public CostModel {
        -:  257:  public:
function _ZN12_GLOBAL__N_117LinalgDetensorize25ControlFlowDetectionModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEE called 0 returned 0% blocks executed 0%
    #####:  258:    void compute(FunctionOpInterface func,
        -:  259:                 DetensorizeTypeConverter typeConverter,
        -:  260:                 DenseSet<Operation *> &opsToDetensor,
        -:  261:                 DenseSet<BlockArgument> &blockArgsToDetensor) override {
    #####:  262:      SmallVector<Value> workList;
call    0 never executed
        -:  263:
function _ZZN12_GLOBAL__N_117LinalgDetensorize25ControlFlowDetectionModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEEENKUlNS2_2cf12CondBranchOpEE_clESI_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  264:      func->walk([&](cf::CondBranchOp condBr) {
call    0 never executed
    #####:  265:        llvm::append_range(workList, condBr.getOperands());
call    0 never executed
call    1 never executed
    #####:  266:      });
        -:  267:
function _ZZN12_GLOBAL__N_117LinalgDetensorize25ControlFlowDetectionModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEEENKUlNS2_2cf8BranchOpEE0_clESI_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  268:      func->walk([&](cf::BranchOp br) {
call    0 never executed
    #####:  269:        llvm::append_range(workList, br.getOperands());
call    0 never executed
call    1 never executed
    #####:  270:      });
        -:  271:
    #####:  272:      DenseSet<Value> visitedValues;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  273:      DenseSet<Operation *> visitedOps;
call    0 never executed
call    1 never executed
        -:  274:
        -:  275:      // For a (to-be-detesored) value, check if it "escapes" the block by being
        -:  276:      // passed to terminator. If it does, then workList is updated with the
        -:  277:      // corresponding argument to the successor block.
    #####:  278:      auto updateWorkListWithSuccessorArguments =
function _ZZN12_GLOBAL__N_117LinalgDetensorize25ControlFlowDetectionModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEEENKUlNS2_5ValueENS2_17BranchOpInterfaceEE1_clESH_SI_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  279:          [&](Value value, BranchOpInterface terminator) {
    #####:  280:            if (!terminator)
branch  0 never executed
branch  1 never executed
        -:  281:              return;
        -:  282:
    #####:  283:            for (auto operandIdx :
    #####:  284:                 llvm::seq<unsigned>(0, terminator->getOperands().size())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  285:              Value operand = terminator->getOperand(operandIdx);
call    0 never executed
        -:  286:
    #####:  287:              if (operand == value) {
branch  0 never executed
branch  1 never executed
    #####:  288:                auto succBlockArg =
    #####:  289:                    terminator.getSuccessorBlockArgument(operandIdx);
call    0 never executed
        -:  290:
    #####:  291:                if (succBlockArg && !blockArgsToDetensor.count(*succBlockArg))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  292:                  workList.push_back(*succBlockArg);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  293:              }
        -:  294:            }
    #####:  295:          };
        -:  296:
    #####:  297:      while (!workList.empty()) {
branch  0 never executed
branch  1 never executed
    #####:  298:        Value currentItem = workList.pop_back_val();
call    0 never executed
        -:  299:
    #####:  300:        if (!visitedValues.insert(currentItem).second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  301:          continue;
        -:  302:
        -:  303:        // 1   - Look forward:
        -:  304:        // 1.1 - If currentItem escapes to one or more successors, add
        -:  305:        // the corresponding successor arguments to workList.
    #####:  306:        updateWorkListWithSuccessorArguments(
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  307:            currentItem, dyn_cast<BranchOpInterface>(
        -:  308:                             currentItem.getParentBlock()->getTerminator()));
        -:  309:
        -:  310:        // 1.2 - For each user of currentItem, add the defined values to
        -:  311:        // workList. This way, the user ops can be inspected later if they are
        -:  312:        // detensorable and if so, their operands will be added to workList to
        -:  313:        // potentially discover other parts of the detensorable component.
    #####:  314:        for (auto *user : currentItem.getUsers())
branch  0 never executed
branch  1 never executed
    #####:  315:          llvm::append_range(workList, user->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  316:
        -:  317:        // 2   - Look backward:
        -:  318:        // 2.1 - The current item is defined by a block argument. If the owner
        -:  319:        // block is a non-entry one, then:
        -:  320:        //       * Add the argument to blockArgsToDetensor.
        -:  321:        //       * Walk the use-def chain backwards to add each predecessor's
        -:  322:        //       terminator-operands corresponding to currentItem to workList.
    #####:  323:        if (currentItem.dyn_cast<BlockArgument>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  324:          BlockArgument currentItemBlockArgument =
call    0 never executed
    #####:  325:              currentItem.cast<BlockArgument>();
    #####:  326:          Block *ownerBlock = currentItemBlockArgument.getOwner();
call    0 never executed
        -:  327:
        -:  328:          // Function arguments are not detensored/converted.
    #####:  329:          if (&*ownerBlock->getParent()->begin() == ownerBlock)
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  330:            continue;
        -:  331:
        -:  332:          // This inner-block argument is involved in control-flow, it should be
        -:  333:          // detensored.
    #####:  334:          blockArgsToDetensor.insert(currentItemBlockArgument);
call    0 never executed
        -:  335:
    #####:  336:          for (PredecessorIterator pred = ownerBlock->pred_begin();
branch  0 never executed
branch  1 never executed
    #####:  337:               pred != ownerBlock->pred_end(); ++pred) {
branch  0 never executed
branch  1 never executed
    #####:  338:            BranchOpInterface predTerminator =
call    0 never executed
    #####:  339:                dyn_cast<BranchOpInterface>((*pred)->getTerminator());
call    0 never executed
call    1 never executed
        -:  340:
        -:  341:            // TODO: For now, we give up if any of the control-flow components
        -:  342:            // in a function is not detensorable. Fix that.
    #####:  343:            if (!predTerminator) {
branch  0 never executed
branch  1 never executed
    #####:  344:              opsToDetensor.clear();
call    0 never executed
    #####:  345:              blockArgsToDetensor.clear();
call    0 never executed
    #####:  346:              return;
call    0 never executed
        -:  347:            }
        -:  348:
    #####:  349:            auto ownerBlockOperands =
    #####:  350:                predTerminator.getSuccessorOperands(pred.getSuccessorIndex());
call    0 never executed
call    1 never executed
        -:  351:
    #####:  352:            if (ownerBlockOperands.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  353:                ownerBlockOperands.isOperandProduced(
branch  0 never executed
branch  1 never executed
        -:  354:                    currentItemBlockArgument.getArgNumber()))
    #####:  355:              continue;
branch  0 never executed
branch  1 never executed
        -:  356:
        -:  357:            // For each predecessor, add the value it passes to that argument to
        -:  358:            // workList to find out how it's computed.
    #####:  359:            workList.push_back(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  360:                ownerBlockOperands[currentItemBlockArgument.getArgNumber()]);
        -:  361:          }
        -:  362:
    #####:  363:          continue;
        -:  364:        }
        -:  365:
    #####:  366:        Operation *currentItemDefiningOp = currentItem.getDefiningOp();
call    0 never executed
        -:  367:
    #####:  368:        if (!visitedOps.insert(currentItemDefiningOp).second)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  369:          continue;
        -:  370:
        -:  371:        // 2.2 - The current item is computed by a GenericOp. If the op should
        -:  372:        // be detensored, then:
        -:  373:        //       * Add it to opsToDetensor.
        -:  374:        //       * Add its operands to workList to discover other parts of the
        -:  375:        //       potentially detensorable component.
    #####:  376:        if (auto genericOp = dyn_cast<GenericOp>(currentItemDefiningOp)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  377:          // The op was encountered already, no need to inspect it again.
    #####:  378:          if (opsToDetensor.count(genericOp))
call    0 never executed
    #####:  379:            continue;
        -:  380:
        -:  381:          // The op should not be detensored, give up on it but continue with
        -:  382:          // discovering the rest of the control-flow component.
    #####:  383:          if (!shouldBeDetensored(genericOp, typeConverter)) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  384:            continue;
        -:  385:          }
        -:  386:
    #####:  387:          opsToDetensor.insert(genericOp);
call    0 never executed
    #####:  388:          llvm::append_range(workList, genericOp.getInputs());
call    0 never executed
call    1 never executed
    #####:  389:          continue;
        -:  390:        }
        -:  391:
        -:  392:        // 2.3 - The current item is the result of a FromElementsOp, it will be
        -:  393:        // trivially detensored later as part of canonicalization patterns
        -:  394:        // applied at the end of detensoring.
        -:  395:        //
        -:  396:        // Note: No need to check whether the result type of this op is
        -:  397:        // detensorable since if it wasn't we wouldn't reach that point in the
        -:  398:        // work list.
    #####:  399:        if (isa<tensor::FromElementsOp>(currentItemDefiningOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  400:          continue;
        -:  401:
        -:  402:        // 2.4 - The current item is the result of a scalar op, add all its
        -:  403:        // operands to the work list.
    #####:  404:        if (llvm::all_of(
    #####:  405:                currentItemDefiningOp->getResultTypes(),
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  406:                [&](Type resultType) { return resultType.isIntOrFloat(); }))
    #####:  407:          llvm::append_range(workList, currentItemDefiningOp->getOperands());
call    0 never executed
call    1 never executed
        -:  408:      }
        -:  409:
        -:  410:      // Since the cost model gives up on some ops (see the details of step 2.2
        -:  411:      // above), block arguments that correspond to the values produced by those
        -:  412:      // ops should not be detensored as well.
        -:  413:
    #####:  414:      DenseSet<BlockArgument> blockArgsToRemove;
call    0 never executed
call    1 never executed
        -:  415:
    #####:  416:      for (auto &blockArg : blockArgsToDetensor) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  417:        Block *block = blockArg.getParentBlock();
call    0 never executed
        -:  418:
        -:  419:        // For the potentially detensorable block argument, find the
        -:  420:        // correpsonding operands in predecessor blocks.
    #####:  421:        for (PredecessorIterator pred = block->pred_begin();
branch  0 never executed
branch  1 never executed
    #####:  422:             pred != block->pred_end(); ++pred) {
branch  0 never executed
branch  1 never executed
    #####:  423:          BranchOpInterface terminator =
call    0 never executed
    #####:  424:              dyn_cast<BranchOpInterface>((*pred)->getTerminator());
call    0 never executed
call    1 never executed
    #####:  425:          auto blockOperands =
    #####:  426:              terminator.getSuccessorOperands(pred.getSuccessorIndex());
call    0 never executed
call    1 never executed
        -:  427:
    #####:  428:          if (blockOperands.empty() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  429:              blockOperands.isOperandProduced(blockArg.getArgNumber()))
branch  0 never executed
branch  1 never executed
    #####:  430:            continue;
branch  0 never executed
branch  1 never executed
        -:  431:
    #####:  432:          Operation *definingOp =
call    0 never executed
    #####:  433:              blockOperands[blockArg.getArgNumber()].getDefiningOp();
call    0 never executed
call    1 never executed
        -:  434:
        -:  435:          // If the operand is defined by a GenericOp that will not be
        -:  436:          // detensored, then do not detensor the corresponding block argument.
    #####:  437:          if (isa_and_nonnull<GenericOp>(definingOp) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  438:              opsToDetensor.count(definingOp) == 0) {
call    0 never executed
    #####:  439:            blockArgsToRemove.insert(blockArg);
call    0 never executed
    #####:  440:            break;
branch  0 never executed
branch  1 never executed
        -:  441:          }
        -:  442:        }
        -:  443:      }
        -:  444:
    #####:  445:      for (auto &blockArg : blockArgsToRemove) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  446:        blockArgsToDetensor.erase(blockArg);
call    0 never executed
call    1 never executed
        -:  447:      }
        -:  448:    }
        -:  449:  };
        -:  450:
        -:  451:  /// Detensorize everything that can detensored.
    #####:  452:  class AggressiveDetensoringModel : public CostModel {
        -:  453:  public:
function _ZN12_GLOBAL__N_117LinalgDetensorize26AggressiveDetensoringModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEE called 0 returned 0% blocks executed 0%
    #####:  454:    void compute(FunctionOpInterface func,
        -:  455:                 DetensorizeTypeConverter typeConverter,
        -:  456:                 DenseSet<Operation *> &opsToDetensor,
        -:  457:                 DenseSet<BlockArgument> &blockArgsToDetensor) override {
function _ZZN12_GLOBAL__N_117LinalgDetensorize26AggressiveDetensoringModel7computeEN4mlir19FunctionOpInterfaceENS_24DetensorizeTypeConverterERN4llvm8DenseSetIPNS2_9OperationENS5_12DenseMapInfoIS8_vEEEERNS6_INS2_13BlockArgumentENS9_ISD_vEEEEENKUlNS2_6linalg9GenericOpEE_clESI_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  458:      func->walk([&](GenericOp genericOp) {
call    0 never executed
    #####:  459:        if (shouldBeDetensored(genericOp, typeConverter))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  460:          opsToDetensor.insert(genericOp);
call    0 never executed
    #####:  461:      });
        -:  462:
    #####:  463:      for (Block &block : llvm::drop_begin(func.getFunctionBody(), 1))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  464:        for (BlockArgument blockArgument : block.getArguments())
branch  0 never executed
branch  1 never executed
    #####:  465:          blockArgsToDetensor.insert(blockArgument);
call    0 never executed
    #####:  466:    }
        -:  467:  };
        -:  468:
function _ZN12_GLOBAL__N_117LinalgDetensorize14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  469:  void runOnOperation() override {
    #####:  470:    MLIRContext *context = &getContext();
call    0 never executed
    #####:  471:    DetensorizeTypeConverter typeConverter;
call    0 never executed
    #####:  472:    RewritePatternSet patterns(context);
call    0 never executed
call    1 never executed
    #####:  473:    ConversionTarget target(*context);
call    0 never executed
call    1 never executed
    #####:  474:    DenseSet<Operation *> opsToDetensor;
call    0 never executed
call    1 never executed
    #####:  475:    DenseMap<Operation *, DenseSet<int>> detensorableBranchOps;
call    0 never executed
call    1 never executed
    #####:  476:    DenseSet<BlockArgument> blockArgsToDetensor;
call    0 never executed
call    1 never executed
    #####:  477:    FunctionOpInterface funcOp = cast<FunctionOpInterface>(getOperation());
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  478:
    #####:  479:    if (aggressiveMode.getValue()) {
branch  0 never executed
branch  1 never executed
    #####:  480:      AggressiveDetensoringModel costModel;
    #####:  481:      costModel.compute(funcOp, typeConverter, opsToDetensor,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  482:                        blockArgsToDetensor);
        -:  483:    } else {
    #####:  484:      ControlFlowDetectionModel costModel;
    #####:  485:      costModel.compute(funcOp, typeConverter, opsToDetensor,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  486:                        blockArgsToDetensor);
        -:  487:    }
        -:  488:
    #####:  489:    detensorableBranchOps =
    #####:  490:        CostModel::computeBranchOpDetensoring(blockArgsToDetensor);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  491:
    #####:  492:    target.addDynamicallyLegalOp<GenericOp>(
call    0 never executed
    #####:  493:        [&](GenericOp op) { return !opsToDetensor.count(op); });
call    0 never executed
        -:  494:
function _ZZN12_GLOBAL__N_117LinalgDetensorize14runOnOperationEvENKUlPN4mlir9OperationEE0_clES3_ called 0 returned 0% blocks executed 0%
    #####:  495:    target.markUnknownOpDynamicallyLegal([&](Operation *op) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  496:      // A function is legal if all of its non-entry blocks are legal. We
        -:  497:      // don't legalize the entry block (i.e. the function's signature)
        -:  498:      // since detensoring can't happen along external calling convention
        -:  499:      // boundaries, which we conservatively approximate as all function
        -:  500:      // signatures.
    #####:  501:      if (auto funcOp = dyn_cast<FunctionOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  502:        Region &body = funcOp.getFunctionBody();
call    0 never executed
    #####:  503:        return llvm::all_of(llvm::drop_begin(body, 1), [&](Block &block) {
call    0 never executed
    #####:  504:          return !llvm::any_of(
call    0 never executed
function _ZZZZN12_GLOBAL__N_117LinalgDetensorize14runOnOperationEvENKUlPN4mlir9OperationEE0_clES3_ENKUlRNS1_5BlockEE_clES6_ENKUlNS1_13BlockArgumentEE_clES8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  505:              blockArgsToDetensor, [&](BlockArgument blockArgument) {
    #####:  506:                return blockArgument.getOwner() == &block &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  507:                       !typeConverter.isLegal(blockArgument.getType());
call    0 never executed
        -:  508:              });
        -:  509:        });
        -:  510:      }
        -:  511:
    #####:  512:      if (isNotBranchOpInterfaceOrReturnLikeOp(op) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  513:          isLegalForReturnOpTypeConversionPattern(op, typeConverter,
call    0 never executed
        -:  514:                                                  /*returnOpAlwaysLegal*/ true))
    #####:  515:        return true;
        -:  516:
    #####:  517:      if (auto branchOp = dyn_cast<BranchOpInterface>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  518:        if (!detensorableBranchOps.count(branchOp))
call    0 never executed
    #####:  519:          return true;
        -:  520:
    #####:  521:        for (auto operandIdx : detensorableBranchOps[branchOp])
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
    #####:  522:          if (!typeConverter.isLegal(
branch  0 never executed
branch  1 never executed
    #####:  523:                  branchOp->getOperand(operandIdx).getType()))
call    0 never executed
call    1 never executed
    #####:  524:            return false;
        -:  525:
    #####:  526:        return true;
        -:  527:      }
        -:  528:
    #####:  529:      return false;
        -:  530:    });
        -:  531:
    #####:  532:    patterns.add<DetensorizeGenericOp>(typeConverter, context);
call    0 never executed
    #####:  533:    patterns.add<FunctionNonEntryBlockConversion>(context, typeConverter,
    #####:  534:                                                  blockArgsToDetensor);
call    0 never executed
        -:  535:    // Since non-entry block arguments get detensorized, we also need to
        -:  536:    // update the control flow inside the function to reflect the correct
        -:  537:    // types.
function _ZZN12_GLOBAL__N_117LinalgDetensorize14runOnOperationEvENKUlN4mlir17BranchOpInterfaceEiE1_clES2_i.isra.0 called 0 returned 0% blocks executed 0%
    #####:  538:    auto shouldConvertBranchOperand = [&](BranchOpInterface branchOp,
        -:  539:                                          int operandIdx) -> bool {
    #####:  540:      return detensorableBranchOps.count(branchOp) &&
call    0 never executed
    #####:  541:             detensorableBranchOps[branchOp].count(operandIdx);
call    0 never executed
call    1 never executed
    #####:  542:    };
        -:  543:
    #####:  544:    populateBranchOpInterfaceTypeConversionPattern(patterns, typeConverter,
call    0 never executed
        -:  545:                                                   shouldConvertBranchOperand);
        -:  546:
    #####:  547:    if (failed(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  548:            applyFullConversion(getOperation(), target, std::move(patterns))))
call    0 never executed
    #####:  549:      signalPassFailure();
call    0 never executed
        -:  550:
    #####:  551:    RewritePatternSet canonPatterns(context);
call    0 never executed
call    1 never executed
    #####:  552:    tensor::FromElementsOp::getCanonicalizationPatterns(canonPatterns, context);
call    0 never executed
    #####:  553:    if (failed(applyPatternsAndFoldGreedily(getOperation(),
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  554:                                            std::move(canonPatterns))))
call    0 never executed
    #####:  555:      signalPassFailure();
call    0 never executed
    #####:  556:  }
        -:  557:};
        -:  558:} // namespace
        -:  559:
function _ZN4mlir27createLinalgDetensorizePassEv called 128628 returned 100% blocks executed 100%
   128628:  560:std::unique_ptr<Pass> mlir::createLinalgDetensorizePass() {
   128628:  561:  return std::make_unique<LinalgDetensorize>();
call    0 returned 100%
        -:  562:}
