        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/Support/Mutex.h
        -:    0:Graph:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMDialect.dir/IR/LLVMDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMDialect.dir/IR/LLVMDialect.cpp.gcda
        -:    0:Runs:128628
        -:    1://===- llvm/Support/Mutex.h - Mutex Operating System Concept -----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file declares the llvm::sys::Mutex class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_SUPPORT_MUTEX_H
        -:   14:#define LLVM_SUPPORT_MUTEX_H
        -:   15:
        -:   16:#include "llvm/Support/Threading.h"
        -:   17:#include <cassert>
        -:   18:#include <mutex>
        -:   19:
        -:   20:namespace llvm
        -:   21:{
        -:   22:  namespace sys
        -:   23:  {
        -:   24:    /// SmartMutex - A mutex with a compile time constant parameter that
        -:   25:    /// indicates whether this mutex should become a no-op when we're not
        -:   26:    /// running in multithreaded mode.
        -:   27:    template<bool mt_only>
   103683:   28:    class SmartMutex {
call    0 returned 100%
        -:   29:      std::recursive_mutex impl;
        -:   30:      unsigned acquired = 0;
        -:   31:
        -:   32:    public:
        -:   33:      bool lock() {
        -:   34:        if (!mt_only || llvm_is_multithreaded()) {
        -:   35:          impl.lock();
        -:   36:          return true;
        -:   37:        }
        -:   38:        // Single-threaded debugging code.  This would be racy in
        -:   39:        // multithreaded mode, but provides not basic checks in single
        -:   40:        // threaded mode.
        -:   41:        ++acquired;
        -:   42:        return true;
        -:   43:      }
        -:   44:
        -:   45:      bool unlock() {
        -:   46:        if (!mt_only || llvm_is_multithreaded()) {
        -:   47:          impl.unlock();
        -:   48:          return true;
        -:   49:        }
        -:   50:        // Single-threaded debugging code.  This would be racy in
        -:   51:        // multithreaded mode, but provides not basic checks in single
        -:   52:        // threaded mode.
        -:   53:        assert(acquired && "Lock not acquired before release!");
        -:   54:        --acquired;
        -:   55:        return true;
        -:   56:      }
        -:   57:
        -:   58:      bool try_lock() {
        -:   59:        if (!mt_only || llvm_is_multithreaded())
        -:   60:          return impl.try_lock();
        -:   61:        return true;
        -:   62:      }
        -:   63:    };
        -:   64:
        -:   65:    /// Mutex - A standard, always enforced mutex.
        -:   66:    typedef SmartMutex<false> Mutex;
        -:   67:
        -:   68:    template <bool mt_only>
        -:   69:    using SmartScopedLock = std::lock_guard<SmartMutex<mt_only>>;
        -:   70:
        -:   71:    typedef SmartScopedLock<false> ScopedLock;
        -:   72:  }
        -:   73:}
        -:   74:
        -:   75:#endif
