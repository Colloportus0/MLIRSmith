        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/SCF/Transforms/LoopPipelining.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/SCF/Transforms/CMakeFiles/obj.MLIRSCFTransforms.dir/LoopPipelining.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/SCF/Transforms/CMakeFiles/obj.MLIRSCFTransforms.dir/LoopPipelining.cpp.gcda
        -:    0:Runs:128629
        -:    1://===- LoopPipelining.cpp - Code to perform loop software pipelining-------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements loop software pipelining
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   14:#include "mlir/Dialect/SCF/IR/SCF.h"
        -:   15:#include "mlir/Dialect/SCF/Transforms/Patterns.h"
        -:   16:#include "mlir/Dialect/SCF/Transforms/Transforms.h"
        -:   17:#include "mlir/Dialect/SCF/Utils/Utils.h"
        -:   18:#include "mlir/IR/BlockAndValueMapping.h"
        -:   19:#include "mlir/IR/PatternMatch.h"
        -:   20:#include "mlir/Support/MathExtras.h"
        -:   21:#include "mlir/Transforms/RegionUtils.h"
        -:   22:#include "llvm/ADT/MapVector.h"
        -:   23:
        -:   24:using namespace mlir;
        -:   25:using namespace mlir::scf;
        -:   26:
        -:   27:namespace {
        -:   28:
        -:   29:/// Helper to keep internal information during pipelining transformation.
        -:   30:struct LoopPipelinerInternal {
        -:   31:  /// Coarse liverange information for ops used across stages.
    #####:   32:  struct LiverangeInfo {
call    0 never executed
        -:   33:    unsigned lastUseStage = 0;
        -:   34:    unsigned defStage = 0;
        -:   35:  };
        -:   36:
        -:   37:protected:
        -:   38:  ForOp forOp;
        -:   39:  unsigned maxStage = 0;
        -:   40:  DenseMap<Operation *, unsigned> stages;
        -:   41:  std::vector<Operation *> opOrder;
        -:   42:  int64_t ub;
        -:   43:  int64_t lb;
        -:   44:  int64_t step;
        -:   45:  PipeliningOption::AnnotationlFnType annotateFn = nullptr;
        -:   46:  bool peelEpilogue;
        -:   47:  PipeliningOption::PredicateOpFn predicateFn = nullptr;
        -:   48:
        -:   49:  // When peeling the kernel we generate several version of each value for
        -:   50:  // different stage of the prologue. This map tracks the mapping between
        -:   51:  // original Values in the loop and the different versions
        -:   52:  // peeled from the loop.
        -:   53:  DenseMap<Value, llvm::SmallVector<Value>> valueMapping;
        -:   54:
        -:   55:  /// Assign a value to `valueMapping`, this means `val` represents the version
        -:   56:  /// `idx` of `key` in the epilogue.
        -:   57:  void setValueMapping(Value key, Value el, int64_t idx);
        -:   58:
        -:   59:public:
        -:   60:  /// Initalize the information for the given `op`, return true if it
        -:   61:  /// satisfies the pre-condition to apply pipelining.
        -:   62:  bool initializeLoopInfo(ForOp op, const PipeliningOption &options);
        -:   63:  /// Emits the prologue, this creates `maxStage - 1` part which will contain
        -:   64:  /// operations from stages [0; i], where i is the part index.
        -:   65:  void emitPrologue(PatternRewriter &rewriter);
        -:   66:  /// Gather liverange information for Values that are used in a different stage
        -:   67:  /// than its definition.
        -:   68:  llvm::MapVector<Value, LiverangeInfo> analyzeCrossStageValues();
        -:   69:  scf::ForOp createKernelLoop(
        -:   70:      const llvm::MapVector<Value, LiverangeInfo> &crossStageValues,
        -:   71:      PatternRewriter &rewriter,
        -:   72:      llvm::DenseMap<std::pair<Value, unsigned>, unsigned> &loopArgMap);
        -:   73:  /// Emits the pipelined kernel. This clones loop operations following user
        -:   74:  /// order and remaps operands defined in a different stage as their use.
        -:   75:  void createKernel(
        -:   76:      scf::ForOp newForOp,
        -:   77:      const llvm::MapVector<Value, LiverangeInfo> &crossStageValues,
        -:   78:      const llvm::DenseMap<std::pair<Value, unsigned>, unsigned> &loopArgMap,
        -:   79:      PatternRewriter &rewriter);
        -:   80:  /// Emits the epilogue, this creates `maxStage - 1` part which will contain
        -:   81:  /// operations from stages [i; maxStage], where i is the part index.
        -:   82:  llvm::SmallVector<Value> emitEpilogue(PatternRewriter &rewriter);
        -:   83:};
        -:   84:
function _ZN12_GLOBAL__N_121LoopPipelinerInternal18initializeLoopInfoEN4mlir3scf5ForOpERKNS2_16PipeliningOptionE called 0 returned 0% blocks executed 0%
    #####:   85:bool LoopPipelinerInternal::initializeLoopInfo(
        -:   86:    ForOp op, const PipeliningOption &options) {
    #####:   87:  forOp = op;
    #####:   88:  auto upperBoundCst =
    #####:   89:      forOp.getUpperBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:   90:  auto lowerBoundCst =
    #####:   91:      forOp.getLowerBound().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:   92:  auto stepCst = forOp.getStep().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####:   93:  if (!upperBoundCst || !lowerBoundCst || !stepCst)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   94:    return false;
    #####:   95:  ub = upperBoundCst.value();
call    0 never executed
    #####:   96:  lb = lowerBoundCst.value();
call    0 never executed
    #####:   97:  step = stepCst.value();
call    0 never executed
    #####:   98:  peelEpilogue = options.peelEpilogue;
    #####:   99:  predicateFn = options.predicateFn;
call    0 never executed
    #####:  100:  if (!peelEpilogue && predicateFn == nullptr)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  101:    return false;
    #####:  102:  int64_t numIteration = ceilDiv(ub - lb, step);
call    0 never executed
    #####:  103:  std::vector<std::pair<Operation *, unsigned>> schedule;
branch  0 never executed
branch  1 never executed
    #####:  104:  options.getScheduleFn(forOp, schedule);
branch  0 never executed
branch  1 never executed
    #####:  105:  if (schedule.empty())
branch  0 never executed
branch  1 never executed
        -:  106:    return false;
        -:  107:
    #####:  108:  opOrder.reserve(schedule.size());
call    0 never executed
    #####:  109:  for (auto &opSchedule : schedule) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  110:    maxStage = std::max(maxStage, opSchedule.second);
branch  0 never executed
branch  1 never executed
    #####:  111:    stages[opSchedule.first] = opSchedule.second;
call    0 never executed
    #####:  112:    opOrder.push_back(opSchedule.first);
call    0 never executed
        -:  113:  }
    #####:  114:  if (numIteration <= maxStage)
branch  0 never executed
branch  1 never executed
        -:  115:    return false;
        -:  116:
        -:  117:  // All operations need to have a stage.
    #####:  118:  for (Operation &op : forOp.getBody()->without_terminator()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  119:    if (stages.find(&op) == stages.end()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  120:      op.emitOpError("not assigned a pipeline stage");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  121:      return false;
        -:  122:    }
        -:  123:  }
        -:  124:
        -:  125:  // Currently, we do not support assigning stages to ops in nested regions. The
        -:  126:  // block of all operations assigned a stage should be the single `scf.for`
        -:  127:  // body block.
    #####:  128:  for (const auto &[op, stageNum] : stages) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  129:    (void)stageNum;
    #####:  130:    if (op == forOp.getBody()->getTerminator()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  131:      op->emitError("terminator should not be assigned a stage");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  132:      return false;
        -:  133:    }
    #####:  134:    if (op->getBlock() != forOp.getBody()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  135:      op->emitOpError("the owning Block of all operations assigned a stage "
call    0 never executed
call    1 never executed
call    2 never executed
        -:  136:                      "should be the loop body block");
    #####:  137:      return false;
        -:  138:    }
        -:  139:  }
        -:  140:
        -:  141:  // Only support loop carried dependency with a distance of 1. This means the
        -:  142:  // source of all the scf.yield operands needs to be defined by operations in
        -:  143:  // the loop.
    #####:  144:  if (llvm::any_of(forOp.getBody()->getTerminator()->getOperands(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
function _ZZN12_GLOBAL__N_121LoopPipelinerInternal18initializeLoopInfoEN4mlir3scf5ForOpERKNS2_16PipeliningOptionEENKUlNS1_5ValueEE_clES7_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  145:                   [this](Value operand) {
    #####:  146:                     Operation *def = operand.getDefiningOp();
call    0 never executed
    #####:  147:                     return !def || stages.find(def) == stages.end();
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  148:                   }))
        -:  149:    return false;
    #####:  150:  annotateFn = options.annotateFn;
    #####:  151:  return true;
call    0 never executed
        -:  152:}
        -:  153:
        -:  154:/// Clone `op` and call `callback` on the cloned op's oeprands as well as any
        -:  155:/// operands of nested ops that:
        -:  156:/// 1) aren't defined within the new op or
        -:  157:/// 2) are block arguments.
        -:  158:static Operation *
function _ZN12_GLOBAL__N_1L22cloneAndUpdateOperandsERN4mlir12RewriterBaseEPNS0_9OperationEN4llvm12function_refIFvPNS0_9OpOperandEEEE called 0 returned 0% blocks executed 0%
    #####:  159:cloneAndUpdateOperands(RewriterBase &rewriter, Operation *op,
        -:  160:                       function_ref<void(OpOperand *newOperand)> callback) {
    #####:  161:  Operation *clone = rewriter.clone(*op);
call    0 never executed
    #####:  162:  for (OpOperand &operand : clone->getOpOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  163:    callback(&operand);
call    0 never executed
function _ZZN12_GLOBAL__N_1L22cloneAndUpdateOperandsERN4mlir12RewriterBaseEPNS0_9OperationEN4llvm12function_refIFvPNS0_9OpOperandEEEEENKUlS4_E_clES4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  164:  clone->walk([&](Operation *nested) {
call    0 never executed
    #####:  165:    for (OpOperand &operand : nested->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  166:      Operation *def = operand.get().getDefiningOp();
call    0 never executed
    #####:  167:      if ((def && !clone->isAncestor(def)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  168:          operand.get().isa<BlockArgument>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  169:        callback(&operand);
call    0 never executed
        -:  170:    }
    #####:  171:  });
    #####:  172:  return clone;
        -:  173:}
        -:  174:
function _ZN12_GLOBAL__N_121LoopPipelinerInternal12emitPrologueERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  175:void LoopPipelinerInternal::emitPrologue(PatternRewriter &rewriter) {
        -:  176:  // Initialize the iteration argument to the loop initiale values.
    #####:  177:  for (BlockArgument &arg : forOp.getRegionIterArgs()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  178:    OpOperand &operand = forOp.getOpOperandForRegionIterArg(arg);
call    0 never executed
    #####:  179:    setValueMapping(arg, operand.get(), 0);
call    0 never executed
        -:  180:  }
    #####:  181:  auto yield = cast<scf::YieldOp>(forOp.getBody()->getTerminator());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  182:  for (int64_t i = 0; i < maxStage; i++) {
branch  0 never executed
branch  1 never executed
        -:  183:    // special handling for induction variable as the increment is implicit.
    #####:  184:    Value iv =
    #####:  185:        rewriter.create<arith::ConstantIndexOp>(forOp.getLoc(), lb + i * step);
call    0 never executed
call    1 never executed
    #####:  186:    setValueMapping(forOp.getInductionVar(), iv, i);
call    0 never executed
call    1 never executed
    #####:  187:    for (Operation *op : opOrder) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  188:      if (stages[op] > i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  189:        continue;
    #####:  190:      Operation *newOp =
function _ZZN12_GLOBAL__N_121LoopPipelinerInternal12emitPrologueERN4mlir15PatternRewriterEENKUlPNS1_9OpOperandEE_clES5_ called 0 returned 0% blocks executed 0%
    #####:  191:          cloneAndUpdateOperands(rewriter, op, [&](OpOperand *newOperand) {
call    0 never executed
    #####:  192:            auto it = valueMapping.find(newOperand->get());
call    0 never executed
    #####:  193:            if (it != valueMapping.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  194:              Value replacement = it->second[i - stages[op]];
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  195:              newOperand->set(replacement);
branch  0 never executed
branch  1 never executed
        -:  196:            }
    #####:  197:          });
    #####:  198:      if (annotateFn)
branch  0 never executed
branch  1 never executed
    #####:  199:        annotateFn(newOp, PipeliningOption::PipelinerPart::Prologue, i);
call    0 never executed
    #####:  200:      for (unsigned destId : llvm::seq(unsigned(0), op->getNumResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  201:        setValueMapping(op->getResult(destId), newOp->getResult(destId),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  202:                        i - stages[op]);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  203:        // If the value is a loop carried dependency update the loop argument
        -:  204:        // mapping.
    #####:  205:        for (OpOperand &operand : yield->getOpOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  206:          if (operand.get() != op->getResult(destId))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  207:            continue;
    #####:  208:          setValueMapping(forOp.getRegionIterArgs()[operand.getOperandNumber()],
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  209:                          newOp->getResult(destId), i - stages[op] + 1);
call    0 never executed
call    1 never executed
        -:  210:        }
        -:  211:      }
        -:  212:    }
        -:  213:  }
    #####:  214:}
        -:  215:
        -:  216:llvm::MapVector<Value, LoopPipelinerInternal::LiverangeInfo>
function _ZN12_GLOBAL__N_121LoopPipelinerInternal23analyzeCrossStageValuesEv called 0 returned 0% blocks executed 0%
    #####:  217:LoopPipelinerInternal::analyzeCrossStageValues() {
    #####:  218:  llvm::MapVector<Value, LoopPipelinerInternal::LiverangeInfo> crossStageValues;
call    0 never executed
    #####:  219:  for (Operation *op : opOrder) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  220:    unsigned stage = stages[op];
call    0 never executed
        -:  221:
function _ZZN12_GLOBAL__N_121LoopPipelinerInternal23analyzeCrossStageValuesEvENKUlRN4mlir9OpOperandEE_clES3_ called 0 returned 0% blocks executed 0%
    #####:  222:    auto analyzeOperand = [&](OpOperand &operand) {
    #####:  223:      Operation *def = operand.get().getDefiningOp();
call    0 never executed
    #####:  224:      if (!def)
branch  0 never executed
branch  1 never executed
    #####:  225:        return;
    #####:  226:      auto defStage = stages.find(def);
call    0 never executed
    #####:  227:      if (defStage == stages.end() || defStage->second == stage)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  228:        return;
    #####:  229:      assert(stage > defStage->second);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  230:      LiverangeInfo &info = crossStageValues[operand.get()];
call    0 never executed
    #####:  231:      info.defStage = defStage->second;
call    0 never executed
    #####:  232:      info.lastUseStage = std::max(info.lastUseStage, stage);
branch  0 never executed
branch  1 never executed
    #####:  233:    };
        -:  234:
    #####:  235:    for (OpOperand &operand : op->getOpOperands())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  236:      analyzeOperand(operand);
call    0 never executed
    #####:  237:    visitUsedValuesDefinedAbove(op->getRegions(), [&](OpOperand *operand) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  238:      analyzeOperand(*operand);
call    0 never executed
        -:  239:    });
        -:  240:  }
    #####:  241:  return crossStageValues;
        -:  242:}
        -:  243:
function _ZN12_GLOBAL__N_121LoopPipelinerInternal16createKernelLoopERKN4llvm9MapVectorIN4mlir5ValueENS0_13LiverangeInfoENS1_8DenseMapIS4_jNS1_12DenseMapInfoIS4_vEENS1_6detail12DenseMapPairIS4_jEEEESt6vectorISt4pairIS4_S5_ESaISF_EEEERNS3_15PatternRewriterERNS6_ISE_IS4_jEjNS7_ISN_vEENSA_ISN_jEEEE called 0 returned 0% blocks executed 0%
    #####:  244:scf::ForOp LoopPipelinerInternal::createKernelLoop(
        -:  245:    const llvm::MapVector<Value, LoopPipelinerInternal::LiverangeInfo>
        -:  246:        &crossStageValues,
        -:  247:    PatternRewriter &rewriter,
        -:  248:    llvm::DenseMap<std::pair<Value, unsigned>, unsigned> &loopArgMap) {
        -:  249:  // Creates the list of initial values associated to values used across
        -:  250:  // stages. The initial values come from the prologue created above.
        -:  251:  // Keep track of the kernel argument associated to each version of the
        -:  252:  // values passed to the kernel.
    #####:  253:  llvm::SmallVector<Value> newLoopArg;
call    0 never executed
        -:  254:  // For existing loop argument initialize them with the right version from the
        -:  255:  // prologue.
    #####:  256:  for (const auto &retVal :
    #####:  257:       llvm::enumerate(forOp.getBody()->getTerminator()->getOperands())) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
    #####:  258:    Operation *def = retVal.value().getDefiningOp();
call    0 never executed
    #####:  259:    assert(def && "Only support loop carried dependencies of distance 1");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  260:    unsigned defStage = stages[def];
call    0 never executed
    #####:  261:    Value valueVersion = valueMapping[forOp.getRegionIterArgs()[retVal.index()]]
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  262:                                     [maxStage - defStage];
branch  0 never executed
branch  1 never executed
    #####:  263:    assert(valueVersion);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  264:    newLoopArg.push_back(valueVersion);
call    0 never executed
        -:  265:  }
    #####:  266:  for (auto escape : crossStageValues) {
branch  0 never executed
branch  1 never executed
    #####:  267:    LiverangeInfo &info = escape.second;
    #####:  268:    Value value = escape.first;
    #####:  269:    for (unsigned stageIdx = 0; stageIdx < info.lastUseStage - info.defStage;
branch  0 never executed
branch  1 never executed
        -:  270:         stageIdx++) {
    #####:  271:      Value valueVersion =
    #####:  272:          valueMapping[value][maxStage - info.lastUseStage + stageIdx];
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  273:      assert(valueVersion);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  274:      newLoopArg.push_back(valueVersion);
call    0 never executed
    #####:  275:      loopArgMap[std::make_pair(value, info.lastUseStage - info.defStage -
    #####:  276:                                           stageIdx)] = newLoopArg.size() - 1;
call    0 never executed
        -:  277:    }
        -:  278:  }
        -:  279:
        -:  280:  // Create the new kernel loop. When we peel the epilgue we need to peel
        -:  281:  // `numStages - 1` iterations. Then we adjust the upper bound to remove those
        -:  282:  // iterations.
    #####:  283:  Value newUb = forOp.getUpperBound();
call    0 never executed
    #####:  284:  if (peelEpilogue)
branch  0 never executed
branch  1 never executed
    #####:  285:    newUb = rewriter.create<arith::ConstantIndexOp>(forOp.getLoc(),
    #####:  286:                                                    ub - maxStage * step);
call    0 never executed
    #####:  287:  auto newForOp =
    #####:  288:      rewriter.create<scf::ForOp>(forOp.getLoc(), forOp.getLowerBound(), newUb,
call    0 never executed
    #####:  289:                                  forOp.getStep(), newLoopArg);
call    0 never executed
call    1 never executed
        -:  290:  // When there are no iter args, the loop body terminator will be created.
        -:  291:  // Since we always create it below, remove the terminator if it was created.
    #####:  292:  if (!newForOp.getBody()->empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  293:    rewriter.eraseOp(newForOp.getBody()->getTerminator());
call    0 never executed
call    1 never executed
    #####:  294:  return newForOp;
branch  0 never executed
branch  1 never executed
        -:  295:}
        -:  296:
        -:  297:/// Replace any use of `target` with `replacement` in `op`'s operands or within
        -:  298:/// `op`'s nested regions.
function _ZN12_GLOBAL__N_1L11replaceInOpEPN4mlir9OperationENS0_5ValueES3_ called 0 returned 0% blocks executed 0%
    #####:  299:static void replaceInOp(Operation *op, Value target, Value replacement) {
    #####:  300:  for (auto &use : llvm::make_early_inc_range(target.getUses())) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  301:    if (op->isAncestor(use.getOwner()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  302:      use.set(replacement);
branch  0 never executed
branch  1 never executed
        -:  303:  }
    #####:  304:}
        -:  305:
        -:  306:/// Given a cloned op in the new kernel body, updates induction variable uses.
        -:  307:/// We replace it with a version incremented based on the stage where it is
        -:  308:/// used.
function _ZN12_GLOBAL__N_1L27updateInductionVariableUsesERN4mlir12RewriterBaseENS0_8LocationEPNS0_9OperationENS0_5ValueEjjj called 0 returned 0% blocks executed 0%
    #####:  309:static void updateInductionVariableUses(RewriterBase &rewriter, Location loc,
        -:  310:                                        Operation *newOp, Value newForIv,
        -:  311:                                        unsigned maxStage, unsigned useStage,
        -:  312:                                        unsigned step) {
    #####:  313:  rewriter.setInsertionPoint(newOp);
call    0 never executed
    #####:  314:  Value offset = rewriter.create<arith::ConstantIndexOp>(
    #####:  315:      loc, (maxStage - useStage) * step);
call    0 never executed
call    1 never executed
    #####:  316:  Value iv = rewriter.create<arith::AddIOp>(loc, newForIv, offset);
call    0 never executed
call    1 never executed
    #####:  317:  replaceInOp(newOp, newForIv, iv);
call    0 never executed
    #####:  318:  rewriter.setInsertionPointAfter(newOp);
call    0 never executed
    #####:  319:}
        -:  320:
        -:  321:/// If the value is a loop carried value coming from stage N + 1 remap, it will
        -:  322:/// become a direct use.
        -:  323:static void updateIterArgUses(RewriterBase &rewriter, BlockAndValueMapping &bvm,
        -:  324:                              Operation *newOp, ForOp oldForOp, ForOp newForOp,
        -:  325:                              unsigned useStage,
        -:  326:                              const DenseMap<Operation *, unsigned> &stages) {
        -:  327:
        -:  328:  for (unsigned i = 0; i < oldForOp.getNumRegionIterArgs(); i++) {
        -:  329:    Value yieldedVal = oldForOp.getBody()->getTerminator()->getOperand(i);
        -:  330:    Operation *dep = yieldedVal.getDefiningOp();
        -:  331:    if (!dep)
        -:  332:      continue;
        -:  333:    auto stageDep = stages.find(dep);
        -:  334:    if (stageDep == stages.end() || stageDep->second == useStage)
        -:  335:      continue;
        -:  336:    if (stageDep->second != useStage + 1)
        -:  337:      continue;
        -:  338:    Value replacement = bvm.lookup(yieldedVal);
        -:  339:    replaceInOp(newOp, newForOp.getRegionIterArg(i), replacement);
        -:  340:  }
        -:  341:}
        -:  342:
        -:  343:/// For operands defined in a previous stage we need to remap it to use the
        -:  344:/// correct region argument. We look for the right version of the Value based
        -:  345:/// on the stage where it is used.
        -:  346:static void updateCrossStageUses(
        -:  347:    RewriterBase &rewriter, Operation *newOp, BlockAndValueMapping &bvm,
        -:  348:    ForOp newForOp, unsigned useStage,
        -:  349:    const DenseMap<Operation *, unsigned> &stages,
        -:  350:    const llvm::DenseMap<std::pair<Value, unsigned>, unsigned> &loopArgMap) {
        -:  351:  // Because we automatically cloned the sub-regions, there's no simple way
        -:  352:  // to walk the nested regions in pairs of (oldOps, newOps), so we just
        -:  353:  // traverse the set of remapped loop arguments, filter which ones are
        -:  354:  // relevant, and replace any uses.
        -:  355:  for (auto [remapPair, newIterIdx] : loopArgMap) {
        -:  356:    auto [crossArgValue, stageIdx] = remapPair;
        -:  357:    Operation *def = crossArgValue.getDefiningOp();
        -:  358:    assert(def);
        -:  359:    unsigned stageDef = stages.lookup(def);
        -:  360:    if (useStage <= stageDef || useStage - stageDef != stageIdx)
        -:  361:      continue;
        -:  362:
        -:  363:    // Use "lookupOrDefault" for the target value because some operations
        -:  364:    // are remapped, while in other cases the original will be present.
        -:  365:    Value target = bvm.lookupOrDefault(crossArgValue);
        -:  366:    Value replacement = newForOp.getRegionIterArg(newIterIdx);
        -:  367:
        -:  368:    // Replace uses in the new op's operands and any nested uses.
        -:  369:    replaceInOp(newOp, target, replacement);
        -:  370:  }
        -:  371:}
        -:  372:
function _ZN12_GLOBAL__N_121LoopPipelinerInternal12createKernelEN4mlir3scf5ForOpERKN4llvm9MapVectorINS1_5ValueENS0_13LiverangeInfoENS4_8DenseMapIS6_jNS4_12DenseMapInfoIS6_vEENS4_6detail12DenseMapPairIS6_jEEEESt6vectorISt4pairIS6_S7_ESaISH_EEEERKNS8_ISG_IS6_jEjNS9_ISN_vEENSC_ISN_jEEEERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  373:void LoopPipelinerInternal::createKernel(
        -:  374:    scf::ForOp newForOp,
        -:  375:    const llvm::MapVector<Value, LoopPipelinerInternal::LiverangeInfo>
        -:  376:        &crossStageValues,
        -:  377:    const llvm::DenseMap<std::pair<Value, unsigned>, unsigned> &loopArgMap,
        -:  378:    PatternRewriter &rewriter) {
    #####:  379:  valueMapping.clear();
call    0 never executed
        -:  380:
        -:  381:  // Create the kernel, we clone instruction based on the order given by
        -:  382:  // user and remap operands coming from a previous stages.
    #####:  383:  rewriter.setInsertionPoint(newForOp.getBody(), newForOp.getBody()->begin());
call    0 never executed
call    1 never executed
    #####:  384:  BlockAndValueMapping mapping;
call    0 never executed
    #####:  385:  mapping.map(forOp.getInductionVar(), newForOp.getInductionVar());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  386:  for (const auto &arg : llvm::enumerate(forOp.getRegionIterArgs())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  387:    mapping.map(arg.value(), newForOp.getRegionIterArgs()[arg.index()]);
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:  388:  }
    #####:  389:  SmallVector<Value> predicates(maxStage + 1, nullptr);
call    0 never executed
call    1 never executed
    #####:  390:  if (!peelEpilogue) {
branch  0 never executed
branch  1 never executed
        -:  391:    // Create a predicate for each stage except the last stage.
    #####:  392:    for (unsigned i = 0; i < maxStage; i++) {
branch  0 never executed
branch  1 never executed
    #####:  393:      Value c = rewriter.create<arith::ConstantIndexOp>(
    #####:  394:          newForOp.getLoc(), ub - (maxStage - i) * step);
call    0 never executed
call    1 never executed
    #####:  395:      Value pred = rewriter.create<arith::CmpIOp>(
    #####:  396:          newForOp.getLoc(), arith::CmpIPredicate::slt,
    #####:  397:          newForOp.getInductionVar(), c);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  398:      predicates[i] = pred;
branch  0 never executed
branch  1 never executed
        -:  399:    }
        -:  400:  }
    #####:  401:  for (Operation *op : opOrder) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  402:    int64_t useStage = stages[op];
call    0 never executed
    #####:  403:    auto *newOp = rewriter.clone(*op, mapping);
call    0 never executed
        -:  404:
        -:  405:    // Within the kernel body, update uses of the induction variable, uses of
        -:  406:    // the original iter args, and uses of cross stage values.
    #####:  407:    updateInductionVariableUses(rewriter, forOp.getLoc(), newOp,
call    0 never executed
        -:  408:                                newForOp.getInductionVar(), maxStage,
    #####:  409:                                stages[op], step);
call    0 never executed
call    1 never executed
    #####:  410:    updateIterArgUses(rewriter, mapping, newOp, forOp, newForOp, useStage,
    #####:  411:                      stages);
call    0 never executed
    #####:  412:    updateCrossStageUses(rewriter, newOp, mapping, newForOp, useStage, stages,
call    0 never executed
        -:  413:                         loopArgMap);
        -:  414:
    #####:  415:    if (predicates[useStage]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  416:      newOp = predicateFn(newOp, predicates[useStage], rewriter);
branch  0 never executed
branch  1 never executed
        -:  417:      // Remap the results to the new predicated one.
    #####:  418:      for (auto values : llvm::zip(op->getResults(), newOp->getResults()))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  419:        mapping.map(std::get<0>(values), std::get<1>(values));
call    0 never executed
        -:  420:    }
    #####:  421:    rewriter.setInsertionPointAfter(newOp);
call    0 never executed
    #####:  422:    if (annotateFn)
branch  0 never executed
branch  1 never executed
    #####:  423:      annotateFn(newOp, PipeliningOption::PipelinerPart::Kernel, 0);
call    0 never executed
        -:  424:  }
        -:  425:
        -:  426:  // Collect the Values that need to be returned by the forOp. For each
        -:  427:  // value we need to have `LastUseStage - DefStage` number of versions
        -:  428:  // returned.
        -:  429:  // We create a mapping between original values and the associated loop
        -:  430:  // returned values that will be needed by the epilogue.
    #####:  431:  llvm::SmallVector<Value> yieldOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  432:  for (Value retVal : forOp.getBody()->getTerminator()->getOperands()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  433:    yieldOperands.push_back(mapping.lookupOrDefault(retVal));
call    0 never executed
call    1 never executed
        -:  434:  }
    #####:  435:  for (auto &it : crossStageValues) {
branch  0 never executed
branch  1 never executed
    #####:  436:    int64_t version = maxStage - it.second.lastUseStage + 1;
    #####:  437:    unsigned numVersionReturned = it.second.lastUseStage - it.second.defStage;
        -:  438:    // add the original verstion to yield ops.
        -:  439:    // If there is a liverange spanning across more than 2 stages we need to add
        -:  440:    // extra arg.
    #####:  441:    for (unsigned i = 1; i < numVersionReturned; i++) {
branch  0 never executed
branch  1 never executed
    #####:  442:      setValueMapping(it.first, newForOp->getResult(yieldOperands.size()),
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  443:                      version++);
    #####:  444:      yieldOperands.push_back(
    #####:  445:          newForOp.getBody()->getArguments()[yieldOperands.size() + 1 +
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  446:                                             newForOp.getNumInductionVars()]);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  447:    }
    #####:  448:    setValueMapping(it.first, newForOp->getResult(yieldOperands.size()),
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  449:                    version++);
    #####:  450:    yieldOperands.push_back(mapping.lookupOrDefault(it.first));
call    0 never executed
call    1 never executed
        -:  451:  }
        -:  452:  // Map the yield operand to the forOp returned value.
    #####:  453:  for (const auto &retVal :
    #####:  454:       llvm::enumerate(forOp.getBody()->getTerminator()->getOperands())) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
    #####:  455:    Operation *def = retVal.value().getDefiningOp();
call    0 never executed
    #####:  456:    assert(def && "Only support loop carried dependencies of distance 1");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  457:    unsigned defStage = stages[def];
call    0 never executed
    #####:  458:    setValueMapping(forOp.getRegionIterArgs()[retVal.index()],
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  459:                    newForOp->getResult(retVal.index()),
call    0 never executed
call    1 never executed
    #####:  460:                    maxStage - defStage + 1);
branch  0 never executed
branch  1 never executed
        -:  461:  }
    #####:  462:  rewriter.create<scf::YieldOp>(forOp.getLoc(), yieldOperands);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  463:}
        -:  464:
        -:  465:llvm::SmallVector<Value>
function _ZN12_GLOBAL__N_121LoopPipelinerInternal12emitEpilogueERN4mlir15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  466:LoopPipelinerInternal::emitEpilogue(PatternRewriter &rewriter) {
    #####:  467:  llvm::SmallVector<Value> returnValues(forOp->getNumResults());
call    0 never executed
        -:  468:  // Emit different versions of the induction variable. They will be
        -:  469:  // removed by dead code if not used.
    #####:  470:  for (int64_t i = 0; i < maxStage; i++) {
branch  0 never executed
branch  1 never executed
    #####:  471:    Value newlastIter = rewriter.create<arith::ConstantIndexOp>(
    #####:  472:        forOp.getLoc(), lb + step * ((((ub - 1) - lb) / step) - i));
call    0 never executed
call    1 never executed
    #####:  473:    setValueMapping(forOp.getInductionVar(), newlastIter, maxStage - i);
call    0 never executed
call    1 never executed
        -:  474:  }
        -:  475:  // Emit `maxStage - 1` epilogue part that includes operations from stages
        -:  476:  // [i; maxStage].
    #####:  477:  for (int64_t i = 1; i <= maxStage; i++) {
branch  0 never executed
branch  1 never executed
    #####:  478:    for (Operation *op : opOrder) {
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  479:      if (stages[op] < i)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  480:        continue;
    #####:  481:      Operation *newOp =
function _ZZN12_GLOBAL__N_121LoopPipelinerInternal12emitEpilogueERN4mlir15PatternRewriterEENKUlPNS1_9OpOperandEE_clES5_ called 0 returned 0% blocks executed 0%
    #####:  482:          cloneAndUpdateOperands(rewriter, op, [&](OpOperand *newOperand) {
call    0 never executed
    #####:  483:            auto it = valueMapping.find(newOperand->get());
call    0 never executed
    #####:  484:            if (it != valueMapping.end()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  485:              Value replacement = it->second[maxStage - stages[op] + i];
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  486:              newOperand->set(replacement);
branch  0 never executed
branch  1 never executed
        -:  487:            }
    #####:  488:          });
    #####:  489:      if (annotateFn)
branch  0 never executed
branch  1 never executed
    #####:  490:        annotateFn(newOp, PipeliningOption::PipelinerPart::Epilogue, i - 1);
call    0 never executed
    #####:  491:      for (unsigned destId : llvm::seq(unsigned(0), op->getNumResults())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  492:        setValueMapping(op->getResult(destId), newOp->getResult(destId),
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  493:                        maxStage - stages[op] + i);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  494:        // If the value is a loop carried dependency update the loop argument
        -:  495:        // mapping and keep track of the last version to replace the original
        -:  496:        // forOp uses.
    #####:  497:        for (OpOperand &operand :
    #####:  498:             forOp.getBody()->getTerminator()->getOpOperands()) {
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  499:          if (operand.get() != op->getResult(destId))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  500:            continue;
    #####:  501:          unsigned version = maxStage - stages[op] + i + 1;
call    0 never executed
        -:  502:          // If the version is greater than maxStage it means it maps to the
        -:  503:          // original forOp returned value.
    #####:  504:          if (version > maxStage) {
branch  0 never executed
branch  1 never executed
    #####:  505:            returnValues[operand.getOperandNumber()] = newOp->getResult(destId);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  506:            continue;
        -:  507:          }
    #####:  508:          setValueMapping(forOp.getRegionIterArgs()[operand.getOperandNumber()],
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:  509:                          newOp->getResult(destId), version);
call    0 never executed
        -:  510:        }
        -:  511:      }
        -:  512:    }
        -:  513:  }
    #####:  514:  return returnValues;
        -:  515:}
        -:  516:
function _ZN12_GLOBAL__N_121LoopPipelinerInternal15setValueMappingEN4mlir5ValueES2_l called 0 returned 0% blocks executed 0%
    #####:  517:void LoopPipelinerInternal::setValueMapping(Value key, Value el, int64_t idx) {
    #####:  518:  auto it = valueMapping.find(key);
call    0 never executed
        -:  519:  // If the value is not in the map yet add a vector big enough to store all
        -:  520:  // versions.
    #####:  521:  if (it == valueMapping.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  522:    it =
        -:  523:        valueMapping
    #####:  524:            .insert(std::make_pair(key, llvm::SmallVector<Value>(maxStage + 1)))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  525:            .first;
    #####:  526:  it->second[idx] = el;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  527:}
        -:  528:
        -:  529:} // namespace
        -:  530:
function _ZNK4mlir3scf24ForLoopPipeliningPattern24returningMatchAndRewriteENS0_5ForOpERNS_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  531:FailureOr<ForOp> ForLoopPipeliningPattern::returningMatchAndRewrite(
        -:  532:    ForOp forOp, PatternRewriter &rewriter) const {
        -:  533:
    #####:  534:  LoopPipelinerInternal pipeliner;
call    0 never executed
call    1 never executed
    #####:  535:  if (!pipeliner.initializeLoopInfo(forOp, options))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  536:    return failure();
        -:  537:
        -:  538:  // 1. Emit prologue.
    #####:  539:  pipeliner.emitPrologue(rewriter);
call    0 never executed
        -:  540:
        -:  541:  // 2. Track values used across stages. When a value cross stages it will
        -:  542:  // need to be passed as loop iteration arguments.
        -:  543:  // We first collect the values that are used in a different stage than where
        -:  544:  // they are defined.
    #####:  545:  llvm::MapVector<Value, LoopPipelinerInternal::LiverangeInfo>
    #####:  546:      crossStageValues = pipeliner.analyzeCrossStageValues();
call    0 never executed
        -:  547:
        -:  548:  // Mapping between original loop values used cross stage and the block
        -:  549:  // arguments associated after pipelining. A Value may map to several
        -:  550:  // arguments if its liverange spans across more than 2 stages.
    #####:  551:  llvm::DenseMap<std::pair<Value, unsigned>, unsigned> loopArgMap;
call    0 never executed
call    1 never executed
        -:  552:  // 3. Create the new kernel loop and return the block arguments mapping.
    #####:  553:  ForOp newForOp =
    #####:  554:      pipeliner.createKernelLoop(crossStageValues, rewriter, loopArgMap);
call    0 never executed
        -:  555:  // Create the kernel block, order ops based on user choice and remap
        -:  556:  // operands.
    #####:  557:  pipeliner.createKernel(newForOp, crossStageValues, loopArgMap, rewriter);
call    0 never executed
        -:  558:
    #####:  559:  llvm::SmallVector<Value> returnValues =
    #####:  560:      newForOp.getResults().take_front(forOp->getNumResults());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  561:  if (options.peelEpilogue) {
branch  0 never executed
branch  1 never executed
        -:  562:    // 4. Emit the epilogue after the new forOp.
    #####:  563:    rewriter.setInsertionPointAfter(newForOp);
call    0 never executed
    #####:  564:    returnValues = pipeliner.emitEpilogue(rewriter);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  565:  }
        -:  566:  // 5. Erase the original loop and replace the uses with the epilogue output.
    #####:  567:  if (forOp->getNumResults() > 0)
branch  0 never executed
branch  1 never executed
    #####:  568:    rewriter.replaceOp(forOp, returnValues);
call    0 never executed
call    1 never executed
        -:  569:  else
    #####:  570:    rewriter.eraseOp(forOp);
call    0 never executed
        -:  571:
    #####:  572:  return newForOp;
branch  0 never executed
branch  1 never executed
        -:  573:}
        -:  574:
function _ZN4mlir3scf33populateSCFLoopPipeliningPatternsERNS_17RewritePatternSetERKNS0_16PipeliningOptionE called 0 returned 0% blocks executed 0%
    #####:  575:void mlir::scf::populateSCFLoopPipeliningPatterns(
        -:  576:    RewritePatternSet &patterns, const PipeliningOption &options) {
    #####:  577:  patterns.add<ForLoopPipeliningPattern>(options, patterns.getContext());
call    0 never executed
    #####:  578:}
