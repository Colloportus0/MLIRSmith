        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/Dialect/CommonFolders.h
        -:    0:Graph:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Arith/IR/CMakeFiles/obj.MLIRArithDialect.dir/ArithOps.cpp.gcda
        -:    0:Runs:128624
        -:    1://===- CommonFolders.h - Common Operation Folders----------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This header file declares various common operation folders. These folders
        -:   10:// are intended to be used by dialects to support common folding behavior
        -:   11:// without requiring each dialect to provide its own implementation.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef MLIR_DIALECT_COMMONFOLDERS_H
        -:   16:#define MLIR_DIALECT_COMMONFOLDERS_H
        -:   17:
        -:   18:#include "mlir/IR/BuiltinAttributes.h"
        -:   19:#include "mlir/IR/BuiltinTypes.h"
        -:   20:#include "llvm/ADT/ArrayRef.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:
        -:   23:namespace mlir {
        -:   24:/// Performs constant folding `calculate` with element-wise behavior on the two
        -:   25:/// attributes in `operands` and returns the result if possible.
        -:   26:template <
        -:   27:    class AttrElementT, class ElementValueT = typename AttrElementT::ValueType,
        -:   28:    class CalculationT =
        -:   29:        function_ref<Optional<ElementValueT>(ElementValueT, ElementValueT)>>
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
    #####:   33:  if (!operands[0] || !operands[1])
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
    #####:   39:    if (lhs.getType() != rhs.getType())
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
        -:   43:
    #####:   44:    if (!calRes)
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
    #####:   56:    if (lhs.getType() != rhs.getType())
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
    #####:   66:             operands[1].isa<ElementsAttr>()) {
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
    #####:   71:    if (lhs.getType() != rhs.getType())
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
    #####:   77:    elementResults.reserve(lhs.getNumElements());
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
    #####:   80:      if (!elementResult)
    #####:   81:        return {};
    #####:   82:      elementResults.push_back(*elementResult);
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SB_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
_ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_:
function _ZN4mlir28constFoldBinaryOpConditionalINS_11IntegerAttrEN4llvm5APIntEZNS_17constFoldBinaryOpIS1_S3_ZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES8_S9_RKT1_EUlS3_S3_E_EES8_S9_SF_ called 0 returned 0% blocks executed 0%
    #####:   30:Attribute constFoldBinaryOpConditional(ArrayRef<Attribute> operands,
        -:   31:                                       const CalculationT &calculate) {
    #####:   32:  assert(operands.size() == 2 && "binary op takes two operands");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   33:  if (!operands[0] || !operands[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   34:    return {};
        -:   35:
    #####:   36:  if (operands[0].isa<AttrElementT>() && operands[1].isa<AttrElementT>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   37:    auto lhs = operands[0].cast<AttrElementT>();
call    0 never executed
    #####:   38:    auto rhs = operands[1].cast<AttrElementT>();
call    0 never executed
    #####:   39:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   40:      return {};
        -:   41:
    #####:   42:    auto calRes = calculate(lhs.getValue(), rhs.getValue());
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   43:
    #####:   44:    if (!calRes)
branch  0 never executed
branch  1 never executed
    #####:   45:      return {};
        -:   46:
    #####:   47:    return AttrElementT::get(lhs.getType(), *calRes);
call    0 never executed
call    1 never executed
        -:   48:  }
        -:   49:
    #####:   50:  if (operands[0].isa<SplatElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   51:      operands[1].isa<SplatElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   52:    // Both operands are splats so we can avoid expanding the values out and
        -:   53:    // just fold based on the splat value.
    #####:   54:    auto lhs = operands[0].cast<SplatElementsAttr>();
call    0 never executed
    #####:   55:    auto rhs = operands[1].cast<SplatElementsAttr>();
call    0 never executed
    #####:   56:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   57:      return {};
        -:   58:
    #####:   59:    auto elementResult = calculate(lhs.getSplatValue<ElementValueT>(),
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -:   60:                                   rhs.getSplatValue<ElementValueT>());
    #####:   61:    if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   62:      return {};
        -:   63:
    #####:   64:    return DenseElementsAttr::get(lhs.getType(), *elementResult);
call    0 never executed
call    1 never executed
    #####:   65:  } else if (operands[0].isa<ElementsAttr>() &&
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   66:             operands[1].isa<ElementsAttr>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   67:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:   68:    // expanding the values.
    #####:   69:    auto lhs = operands[0].cast<ElementsAttr>();
call    0 never executed
    #####:   70:    auto rhs = operands[1].cast<ElementsAttr>();
call    0 never executed
    #####:   71:    if (lhs.getType() != rhs.getType())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   72:      return {};
        -:   73:
    #####:   74:    auto lhsIt = lhs.value_begin<ElementValueT>();
call    0 never executed
    #####:   75:    auto rhsIt = rhs.value_begin<ElementValueT>();
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:   76:    SmallVector<ElementValueT, 4> elementResults;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   77:    elementResults.reserve(lhs.getNumElements());
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   78:    for (size_t i = 0, e = lhs.getNumElements(); i < e; ++i, ++lhsIt, ++rhsIt) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:      auto elementResult = calculate(*lhsIt, *rhsIt);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:   80:      if (!elementResult)
branch  0 never executed
branch  1 never executed
    #####:   81:        return {};
call    0 never executed
    #####:   82:      elementResults.push_back(*elementResult);
call    0 never executed
call    1 never executed
        -:   83:    }
        -:   84:
    #####:   85:    return DenseElementsAttr::get(lhs.getType(), elementResults);
call    0 never executed
call    1 never executed
        -:   86:  }
    #####:   87:  return {};
        -:   88:}
------------------
        -:   89:
        -:   90:template <class AttrElementT,
        -:   91:          class ElementValueT = typename AttrElementT::ValueType,
        -:   92:          class CalculationT =
        -:   93:              function_ref<ElementValueT(ElementValueT, ElementValueT)>>
    #####:   94:Attribute constFoldBinaryOp(ArrayRef<Attribute> operands,
        -:   95:                            const CalculationT &calculate) {
    #####:   96:  return constFoldBinaryOpConditional<AttrElementT>(
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
branch 24 never executed
branch 25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
        -:   97:      operands,
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6XOrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6XOrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AddIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AddIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12AddUICarryOp4foldENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12AddUICarryOp4foldENS2_8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6SubIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6SubIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6MulIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6MulIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7DivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith11CeilDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith12FloorDivSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7RemSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AndIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6AndIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith5OrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith5OrIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlS3_RKS3_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
branch  0 never executed
branch  1 never executed
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MinFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MinFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MaxUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7MinUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith6ShLIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRUIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_11IntegerAttrEN4llvm5APIntEZNS_5arith7ShRSIOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6AddFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6AddFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6SubFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6SubFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MulFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MulFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6DivFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6DivFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6RemFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6RemFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
_ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MaxFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0:
function _ZZN4mlir17constFoldBinaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6MaxFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_SA_E_EES7_S8_RKT1_ENKUlS3_S3_E_clES3_S3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:   98:      [&](ElementValueT a, ElementValueT b) -> Optional<ElementValueT> {
------------------
    #####:   99:        return calculate(a, b);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
branch 27 never executed
branch 28 never executed
call   29 never executed
branch 30 never executed
branch 31 never executed
call   32 never executed
branch 33 never executed
branch 34 never executed
call   35 never executed
branch 36 never executed
branch 37 never executed
call   38 never executed
branch 39 never executed
branch 40 never executed
call   41 never executed
branch 42 never executed
branch 43 never executed
call   44 never executed
branch 45 never executed
branch 46 never executed
call   47 never executed
branch 48 never executed
branch 49 never executed
call   50 never executed
branch 51 never executed
branch 52 never executed
call   53 never executed
branch 54 never executed
branch 55 never executed
call   56 never executed
call   57 never executed
branch 58 never executed
branch 59 never executed
call   60 never executed
branch 61 never executed
branch 62 never executed
call   63 never executed
branch 64 never executed
branch 65 never executed
        -:  100:      });
        -:  101:}
        -:  102:
        -:  103:/// Performs constant folding `calculate` with element-wise behavior on the one
        -:  104:/// attributes in `operands` and returns the result if possible.
        -:  105:template <
        -:  106:    class AttrElementT, class ElementValueT = typename AttrElementT::ValueType,
        -:  107:    class CalculationT = function_ref<Optional<ElementValueT>(ElementValueT)>>
        -:  108:Attribute constFoldUnaryOpConditional(ArrayRef<Attribute> operands,
        -:  109:                                      const CalculationT &&calculate) {
        -:  110:  assert(operands.size() == 1 && "unary op takes one operands");
        -:  111:  if (!operands[0])
        -:  112:    return {};
        -:  113:
        -:  114:  if (operands[0].isa<AttrElementT>()) {
        -:  115:    auto op = operands[0].cast<AttrElementT>();
        -:  116:
        -:  117:    auto res = calculate(op.getValue());
        -:  118:    if (!res)
        -:  119:      return {};
        -:  120:    return AttrElementT::get(op.getType(), *res);
        -:  121:  }
        -:  122:  if (operands[0].isa<SplatElementsAttr>()) {
        -:  123:    // Both operands are splats so we can avoid expanding the values out and
        -:  124:    // just fold based on the splat value.
        -:  125:    auto op = operands[0].cast<SplatElementsAttr>();
        -:  126:
        -:  127:    auto elementResult = calculate(op.getSplatValue<ElementValueT>());
        -:  128:    if (!elementResult)
        -:  129:      return {};
        -:  130:    return DenseElementsAttr::get(op.getType(), *elementResult);
        -:  131:  } else if (operands[0].isa<ElementsAttr>()) {
        -:  132:    // Operands are ElementsAttr-derived; perform an element-wise fold by
        -:  133:    // expanding the values.
        -:  134:    auto op = operands[0].cast<ElementsAttr>();
        -:  135:
        -:  136:    auto opIt = op.value_begin<ElementValueT>();
        -:  137:    SmallVector<ElementValueT> elementResults;
        -:  138:    elementResults.reserve(op.getNumElements());
        -:  139:    for (size_t i = 0, e = op.getNumElements(); i < e; ++i, ++opIt) {
        -:  140:      auto elementResult = calculate(*opIt);
        -:  141:      if (!elementResult)
        -:  142:        return {};
        -:  143:      elementResults.push_back(*elementResult);
        -:  144:    }
        -:  145:    return DenseElementsAttr::get(op.getType(), elementResults);
        -:  146:  }
        -:  147:  return {};
        -:  148:}
        -:  149:
        -:  150:template <class AttrElementT,
        -:  151:          class ElementValueT = typename AttrElementT::ValueType,
        -:  152:          class CalculationT = function_ref<ElementValueT(ElementValueT)>>
    #####:  153:Attribute constFoldUnaryOp(ArrayRef<Attribute> operands,
        -:  154:                           const CalculationT &&calculate) {
    #####:  155:  return constFoldUnaryOpConditional<AttrElementT>(
call    0 never executed
        -:  156:      operands,
function _ZZN4mlir16constFoldUnaryOpINS_9FloatAttrEN4llvm7APFloatEZNS_5arith6NegFOp4foldENS2_8ArrayRefINS_9AttributeEEEEUlRKS3_E_EES7_S8_OKT1_ENKUlS3_E_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  157:      [&](ElementValueT a) -> Optional<ElementValueT> { return calculate(a); });
call    0 never executed
call    1 never executed
call    2 never executed
        -:  158:}
        -:  159:
        -:  160:template <
        -:  161:    class AttrElementT, class TargetAttrElementT,
        -:  162:    class ElementValueT = typename AttrElementT::ValueType,
        -:  163:    class TargetElementValueT = typename TargetAttrElementT::ValueType,
        -:  164:    class CalculationT = function_ref<TargetElementValueT(ElementValueT, bool)>>
    #####:  165:Attribute constFoldCastOp(ArrayRef<Attribute> operands, Type resType,
        -:  166:                          const CalculationT &calculate) {
    #####:  167:  assert(operands.size() == 1 && "Cast op takes one operand");
    #####:  168:  if (!operands[0])
    #####:  169:    return {};
        -:  170:
    #####:  171:  if (operands[0].isa<AttrElementT>()) {
    #####:  172:    auto op = operands[0].cast<AttrElementT>();
    #####:  173:    bool castStatus = true;
    #####:  174:    auto res = calculate(op.getValue(), castStatus);
    #####:  175:    if (!castStatus)
    #####:  176:      return {};
    #####:  177:    return TargetAttrElementT::get(resType, res);
        -:  178:  }
    #####:  179:  if (operands[0].isa<SplatElementsAttr>()) {
        -:  180:    // The operand is a splat so we can avoid expanding the values out and
        -:  181:    // just fold based on the splat value.
    #####:  182:    auto op = operands[0].cast<SplatElementsAttr>();
    #####:  183:    bool castStatus = true;
    #####:  184:    auto elementResult =
        -:  185:        calculate(op.getSplatValue<ElementValueT>(), castStatus);
    #####:  186:    if (!castStatus)
    #####:  187:      return {};
    #####:  188:    return DenseElementsAttr::get(resType, elementResult);
        -:  189:  }
    #####:  190:  if (operands[0].isa<ElementsAttr>()) {
        -:  191:    // Operand is ElementsAttr-derived; perform an element-wise fold by
        -:  192:    // expanding the value.
    #####:  193:    auto op = operands[0].cast<ElementsAttr>();
    #####:  194:    bool castStatus = true;
    #####:  195:    auto opIt = op.value_begin<ElementValueT>();
    #####:  196:    SmallVector<TargetElementValueT> elementResults;
    #####:  197:    elementResults.reserve(op.getNumElements());
    #####:  198:    for (size_t i = 0, e = op.getNumElements(); i < e; ++i, ++opIt) {
    #####:  199:      auto elt = calculate(*opIt, castStatus);
    #####:  200:      if (!castStatus)
    #####:  201:        return {};
    #####:  202:      elementResults.push_back(elt);
        -:  203:    }
        -:  204:
    #####:  205:    return DenseElementsAttr::get(resType, elementResults);
        -:  206:  }
    #####:  207:  return {};
        -:  208:}
        -:  209:
        -:  210:} // namespace mlir
        -:  211:
        -:  212:#endif // MLIR_DIALECT_COMMONFOLDERS_H
