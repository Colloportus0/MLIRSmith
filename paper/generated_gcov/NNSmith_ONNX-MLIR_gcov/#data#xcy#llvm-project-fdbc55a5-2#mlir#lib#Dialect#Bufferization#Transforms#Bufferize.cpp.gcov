        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/Bufferization/Transforms/Bufferize.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/Bufferization/Transforms/CMakeFiles/obj.MLIRBufferizationTransforms.dir/Bufferize.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/Bufferization/Transforms/CMakeFiles/obj.MLIRBufferizationTransforms.dir/Bufferize.cpp.gcda
        -:    0:Runs:128624
        -:    1://===- Bufferize.cpp - Bufferization utilities ----------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Dialect/Bufferization/Transforms/Passes.h"
        -:   10:
        -:   11:#include "mlir/Dialect/Bufferization/IR/BufferizableOpInterface.h"
        -:   12:#include "mlir/Dialect/Bufferization/IR/Bufferization.h"
        -:   13:#include "mlir/Dialect/Bufferization/Transforms/Bufferize.h"
        -:   14:#include "mlir/Dialect/Bufferization/Transforms/OneShotAnalysis.h"
        -:   15:#include "mlir/Dialect/Bufferization/Transforms/OneShotModuleBufferize.h"
        -:   16:#include "mlir/Dialect/Bufferization/Transforms/TensorCopyInsertion.h"
        -:   17:#include "mlir/Dialect/Func/IR/FuncOps.h"
        -:   18:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   19:#include "mlir/IR/Operation.h"
        -:   20:#include "mlir/Pass/PassManager.h"
        -:   21:#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
        -:   22:#include "mlir/Transforms/Passes.h"
        -:   23:
        -:   24:namespace mlir {
        -:   25:namespace bufferization {
        -:   26:#define GEN_PASS_DEF_FINALIZINGBUFFERIZE
        -:   27:#define GEN_PASS_DEF_BUFFERIZATIONBUFFERIZE
        -:   28:#define GEN_PASS_DEF_ONESHOTBUFFERIZE
        -:   29:#include "mlir/Dialect/Bufferization/Transforms/Passes.h.inc"
        -:   30:} // namespace bufferization
        -:   31:} // namespace mlir
        -:   32:
        -:   33:#define DEBUG_TYPE "bufferize"
        -:   34:
        -:   35:using namespace mlir;
        -:   36:using namespace mlir::bufferization;
        -:   37:
        -:   38://===----------------------------------------------------------------------===//
        -:   39:// BufferizeTypeConverter
        -:   40://===----------------------------------------------------------------------===//
        -:   41:
function _ZL19materializeToTensorRN4mlir9OpBuilderENS_10TensorTypeENS_10ValueRangeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:   42:static Value materializeToTensor(OpBuilder &builder, TensorType type,
        -:   43:                                 ValueRange inputs, Location loc) {
    #####:   44:  assert(inputs.size() == 1);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   45:  assert(inputs[0].getType().isa<BaseMemRefType>());
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####:   46:  return builder.create<bufferization::ToTensorOp>(loc, type, inputs[0]);
call    0 never executed
call    1 never executed
        -:   47:}
        -:   48:
        -:   49:/// Registers conversions into BufferizeTypeConverter
function _ZN4mlir13bufferization22BufferizeTypeConverterC2Ev called 1030 returned 100% blocks executed 100%
     1030:   50:BufferizeTypeConverter::BufferizeTypeConverter() {
call    0 returned 100%
        -:   51:  // Keep all types unchanged.
    1030*:   52:  addConversion([](Type type) { return type; });
call    0 never executed
call    1 returned 100%
        -:   53:  // Convert RankedTensorType to MemRefType.
function _ZZN4mlir13bufferization22BufferizeTypeConverterC4EvENKUlNS_16RankedTensorTypeEE0_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    1030*:   54:  addConversion([](RankedTensorType type) -> Type {
call    0 returned 100%
    #####:   55:    return MemRefType::get(type.getShape(), type.getElementType());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   56:  });
        -:   57:  // Convert UnrankedTensorType to UnrankedMemRefType.
function _ZZN4mlir13bufferization22BufferizeTypeConverterC4EvENKUlNS_18UnrankedTensorTypeEE1_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    1030*:   58:  addConversion([](UnrankedTensorType type) -> Type {
call    0 returned 100%
    #####:   59:    return UnrankedMemRefType::get(type.getElementType(), 0);
call    0 never executed
call    1 never executed
        -:   60:  });
     1030:   61:  addArgumentMaterialization(materializeToTensor);
call    0 returned 100%
     1030:   62:  addSourceMaterialization(materializeToTensor);
call    0 returned 100%
function _ZZN4mlir13bufferization22BufferizeTypeConverterC4EvENKUlRNS_9OpBuilderENS_14BaseMemRefTypeENS_10ValueRangeENS_8LocationEE2_clES3_S4_S5_S6_.isra.0 called 0 returned 0% blocks executed 0%
    1030*:   63:  addTargetMaterialization([](OpBuilder &builder, BaseMemRefType type,
call    0 returned 100%
        -:   64:                              ValueRange inputs, Location loc) -> Value {
    #####:   65:    assert(inputs.size() == 1 && "expected exactly one input");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   66:
    #####:   67:    if (auto inputType = inputs[0].getType().dyn_cast<MemRefType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   68:      // MemRef to MemRef cast.
    #####:   69:      assert(inputType != type && "expected different types");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   70:      // Unranked to ranked and ranked to unranked casts must be explicit.
    #####:   71:      auto rankedDestType = type.dyn_cast<MemRefType>();
call    0 never executed
    #####:   72:      if (!rankedDestType)
branch  0 never executed
branch  1 never executed
    #####:   73:        return nullptr;
    #####:   74:      FailureOr<Value> replacement =
    #####:   75:          castOrReallocMemRefValue(builder, inputs[0], rankedDestType);
call    0 never executed
call    1 never executed
    #####:   76:      if (failed(replacement))
branch  0 never executed
branch  1 never executed
    #####:   77:        return nullptr;
    #####:   78:      return *replacement;
        -:   79:    }
        -:   80:
    #####:   81:    if (inputs[0].getType().isa<TensorType>()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:   82:      // Tensor to MemRef cast.
    #####:   83:      return builder.create<bufferization::ToMemrefOp>(loc, type, inputs[0]);
call    0 never executed
call    1 never executed
        -:   84:    }
        -:   85:
    #####:   86:    llvm_unreachable("only tensor/memref input types supported");
call    0 never executed
        -:   87:  });
     1030:   88:}
        -:   89:
function _ZN4mlir13bufferization40populateBufferizeMaterializationLegalityERNS_16ConversionTargetE called 499 returned 100% blocks executed 100%
      499:   90:void mlir::bufferization::populateBufferizeMaterializationLegality(
        -:   91:    ConversionTarget &target) {
      499:   92:  target.addLegalOp<bufferization::ToTensorOp, bufferization::ToMemrefOp>();
call    0 returned 100%
      499:   93:}
        -:   94:
        -:   95:namespace {
        -:   96:// In a finalizing bufferize conversion, we know that all tensors have been
        -:   97:// converted to memrefs, thus, this op becomes an identity.
        -:   98:class BufferizeToTensorOp
        -:   99:    : public OpConversionPattern<bufferization::ToTensorOp> {
        -:  100:public:
        -:  101:  using OpConversionPattern::OpConversionPattern;
        -:  102:  LogicalResult
function _ZNK12_GLOBAL__N_119BufferizeToTensorOp15matchAndRewriteEN4mlir13bufferization10ToTensorOpENS2_17ToTensorOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  103:  matchAndRewrite(bufferization::ToTensorOp op, OpAdaptor adaptor,
        -:  104:                  ConversionPatternRewriter &rewriter) const override {
    #####:  105:    rewriter.replaceOp(op, adaptor.getMemref());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  106:    return success();
        -:  107:  }
        -:  108:};
        -:  109:} // namespace
        -:  110:
        -:  111:namespace {
        -:  112:// In a finalizing bufferize conversion, we know that all tensors have been
        -:  113:// converted to memrefs, thus, this op becomes an identity.
        -:  114:class BufferizeToMemrefOp
        -:  115:    : public OpConversionPattern<bufferization::ToMemrefOp> {
        -:  116:public:
        -:  117:  using OpConversionPattern::OpConversionPattern;
        -:  118:  LogicalResult
function _ZNK12_GLOBAL__N_119BufferizeToMemrefOp15matchAndRewriteEN4mlir13bufferization10ToMemrefOpENS2_17ToMemrefOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  119:  matchAndRewrite(bufferization::ToMemrefOp op, OpAdaptor adaptor,
        -:  120:                  ConversionPatternRewriter &rewriter) const override {
    #####:  121:    rewriter.replaceOp(op, adaptor.getTensor());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  122:    return success();
        -:  123:  }
        -:  124:};
        -:  125:} // namespace
        -:  126:
function _ZN4mlir13bufferization50populateEliminateBufferizeMaterializationsPatternsERNS0_22BufferizeTypeConverterERNS_17RewritePatternSetE called 0 returned 0% blocks executed 0%
    #####:  127:void mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns(
        -:  128:    BufferizeTypeConverter &typeConverter, RewritePatternSet &patterns) {
    #####:  129:  patterns.add<BufferizeToTensorOp, BufferizeToMemrefOp>(typeConverter,
    #####:  130:                                                         patterns.getContext());
call    0 never executed
    #####:  131:}
        -:  132:
        -:  133:namespace {
   203371:  134:struct FinalizingBufferizePass
call    0 returned 100%
call    1 returned 100%
        -:  135:    : public bufferization::impl::FinalizingBufferizeBase<
        -:  136:          FinalizingBufferizePass> {
        -:  137:  using FinalizingBufferizeBase<
        -:  138:      FinalizingBufferizePass>::FinalizingBufferizeBase;
        -:  139:
function _ZN12_GLOBAL__N_123FinalizingBufferizePass14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  140:  void runOnOperation() override {
    #####:  141:    auto func = getOperation();
call    0 never executed
    #####:  142:    auto *context = &getContext();
call    0 never executed
        -:  143:
    #####:  144:    BufferizeTypeConverter typeConverter;
call    0 never executed
    #####:  145:    RewritePatternSet patterns(context);
call    0 never executed
call    1 never executed
    #####:  146:    ConversionTarget target(*context);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  147:
    #####:  148:    populateEliminateBufferizeMaterializationsPatterns(typeConverter, patterns);
call    0 never executed
        -:  149:
        -:  150:    // If all result types are legal, and all block arguments are legal (ensured
        -:  151:    // by func conversion above), then all types in the program are legal.
        -:  152:    //
        -:  153:    // We also check that the operand types are legal to avoid creating invalid
        -:  154:    // IR. For example, this prevents
        -:  155:    // populateEliminateBufferizeMaterializationsPatterns from updating the
        -:  156:    // types of the operands to a return op without updating the enclosing
        -:  157:    // function.
    #####:  158:    target.markUnknownOpDynamicallyLegal(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  159:        [&](Operation *op) { return typeConverter.isLegal(op); });
call    0 never executed
        -:  160:
    #####:  161:    if (failed(applyFullConversion(func, target, std::move(patterns))))
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  162:      signalPassFailure();
call    0 never executed
    #####:  163:  }
        -:  164:};
        -:  165:
        -:  166:static BufferizationOptions::LayoutMapOption
function _ZN12_GLOBAL__N_1L20parseLayoutMapOptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 1010 returned 100% blocks executed 88%
     1010:  167:parseLayoutMapOption(const std::string &s) {
     1010:  168:  if (s == "fully-dynamic-layout-map")
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        -:  169:    return BufferizationOptions::LayoutMapOption::FullyDynamicLayoutMap;
      505:  170:  if (s == "identity-layout-map")
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  171:    return BufferizationOptions::LayoutMapOption::IdentityLayoutMap;
      505:  172:  if (s == "infer-layout-map")
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  173:    return BufferizationOptions::LayoutMapOption::InferLayoutMap;
    #####:  174:  llvm_unreachable("invalid layout map option");
call    0 never executed
        -:  175:}
        -:  176:
        -:  177:static OneShotBufferizationOptions::AnalysisHeuristic
function _ZN12_GLOBAL__N_1L20parseHeuristicOptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 505 returned 100% blocks executed 50%
      505:  178:parseHeuristicOption(const std::string &s) {
      505:  179:  if (s == "bottom-up")
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  180:    return OneShotBufferizationOptions::AnalysisHeuristic::BottomUp;
    #####:  181:  if (s == "top-down")
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  182:    return OneShotBufferizationOptions::AnalysisHeuristic::TopDown;
    #####:  183:  llvm_unreachable("invalid analysisheuristic option");
call    0 never executed
        -:  184:}
        -:  185:
        -:  186:struct OneShotBufferizePass
        -:  187:    : public bufferization::impl::OneShotBufferizeBase<OneShotBufferizePass> {
   129229:  188:  OneShotBufferizePass() = default;
call    0 returned 100%
        -:  189:
function _ZN12_GLOBAL__N_120OneShotBufferizePassC2ERKN4mlir13bufferization27OneShotBufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  190:  explicit OneShotBufferizePass(const OneShotBufferizationOptions &options)
    #####:  191:      : options(options) {}
call    0 never executed
call    1 never executed
        -:  192:
function _ZNK12_GLOBAL__N_120OneShotBufferizePass20getDependentDialectsERN4mlir15DialectRegistryE called 605 returned 100% blocks executed 100%
      605:  193:  void getDependentDialects(DialectRegistry &registry) const override {
      605:  194:    registry
call    0 returned 100%
      605:  195:        .insert<bufferization::BufferizationDialect, memref::MemRefDialect>();
      605:  196:    registerAllocationOpInterfaceExternalModels(registry);
call    0 returned 100%
      605:  197:  }
        -:  198:
function _ZN12_GLOBAL__N_120OneShotBufferizePass14runOnOperationEv called 505 returned 100% blocks executed 67%
      505:  199:  void runOnOperation() override {
     1010:  200:    OneShotBufferizationOptions opt;
call    0 returned 100%
      505:  201:    if (!options) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:      // Make new bufferization options if none were provided when creating the
        -:  203:      // pass.
      505:  204:      opt.allowReturnAllocs = allowReturnAllocs;
call    0 returned 100%
      505:  205:      opt.allowUnknownOps = allowUnknownOps;
      505:  206:      opt.analysisFuzzerSeed = analysisFuzzerSeed;
      505:  207:      opt.analysisHeuristic = parseHeuristicOption(analysisHeuristic);
call    0 returned 100%
      505:  208:      opt.copyBeforeWrite = copyBeforeWrite;
call    0 returned 100%
      505:  209:      opt.createDeallocs = createDeallocs;
     1010:  210:      opt.functionBoundaryTypeConversion =
      505:  211:          parseLayoutMapOption(functionBoundaryTypeConversion);
call    0 returned 100%
      505:  212:      if (mustInferMemorySpace)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  213:        opt.defaultMemorySpace = None;
      505:  214:      opt.printConflicts = printConflicts;
call    0 returned 100%
      505:  215:      opt.testAnalysisOnly = testAnalysisOnly;
      505:  216:      opt.bufferizeFunctionBoundaries = bufferizeFunctionBoundaries;
        -:  217:
        -:  218:      // Configure type converter.
      505:  219:      BufferizationOptions::LayoutMapOption unknownTypeConversionOption =
      505:  220:          parseLayoutMapOption(unknownTypeConversion);
call    0 returned 100%
function _ZZN12_GLOBAL__N_120OneShotBufferizePass14runOnOperationEvENKUlN4mlir5ValueEjRKNS1_13bufferization20BufferizationOptionsEE_clES2_jS6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  221:      opt.unknownTypeConverterFn = [=](Value value, unsigned memorySpace,
        -:  222:                                       const BufferizationOptions &options) {
    #####:  223:        auto tensorType = value.getType().cast<TensorType>();
call    0 never executed
    #####:  224:        if (unknownTypeConversionOption ==
branch  0 never executed
branch  1 never executed
        -:  225:            BufferizationOptions::LayoutMapOption::IdentityLayoutMap)
    #####:  226:          return bufferization::getMemRefTypeWithStaticIdentityLayout(
    #####:  227:              tensorType, memorySpace);
call    0 never executed
    #####:  228:        assert(
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  229:            unknownTypeConversionOption ==
        -:  230:                BufferizationOptions::LayoutMapOption::FullyDynamicLayoutMap &&
        -:  231:            "invalid layout map option");
    #####:  232:        return bufferization::getMemRefTypeWithFullyDynamicLayout(tensorType,
    #####:  233:                                                                  memorySpace);
call    0 never executed
      505:  234:      };
call    0 returned 100%
        -:  235:
        -:  236:      // Configure op filter.
function _ZZN12_GLOBAL__N_120OneShotBufferizePass14runOnOperationEvENKUlPN4mlir9OperationEE0_clES3_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  237:      OpFilter::Entry::FilterFn filterFn = [&](Operation *op) {
        -:  238:        // Filter may be specified via options.
    #####:  239:        if (this->dialectFilter.hasValue())
branch  0 never executed
branch  1 never executed
    #####:  240:          return llvm::is_contained(this->dialectFilter,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  241:                                    op->getDialect()->getNamespace());
call    0 never executed
        -:  242:        // No filter specified: All other ops are allowed.
        -:  243:        return true;
     1010:  244:      };
call    0 returned 100%
     1010:  245:      opt.opFilter.allowOperation(filterFn);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  246:    } else {
    #####:  247:      opt = *options;
call    0 never executed
        -:  248:    }
        -:  249:
      505:  250:    ModuleOp moduleOp = getOperation();
call    0 returned 100%
      505:  251:    if (opt.bufferizeFunctionBoundaries) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  252:      if (failed(runOneShotModuleBufferize(moduleOp, opt))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:        signalPassFailure();
    #####:  254:        return;
call    0 never executed
        -:  255:      }
        -:  256:    } else {
      505:  257:      if (failed(runOneShotBufferize(moduleOp, opt))) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  258:        signalPassFailure();
    #####:  259:        return;
call    0 never executed
        -:  260:      }
        -:  261:    }
        -:  262:
      505:  263:    if (opt.testAnalysisOnly)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  264:      return;
        -:  265:
     1010:  266:    OpPassManager cleanupPipeline("builtin.module");
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      505:  267:    cleanupPipeline.addPass(createCanonicalizerPass());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      505:  268:    cleanupPipeline.addPass(createCSEPass());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      505:  269:    cleanupPipeline.addPass(createLoopInvariantCodeMotionPass());
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      505:  270:    (void)runPipeline(cleanupPipeline, moduleOp);
call    0 returned 100%
        -:  271:  }
        -:  272:
        -:  273:private:
        -:  274:  llvm::Optional<OneShotBufferizationOptions> options;
        -:  275:};
        -:  276:} // namespace
        -:  277:
        -:  278:namespace {
   168373:  279:struct BufferizationBufferizePass
call    0 returned 100%
call    1 returned 100%
        -:  280:    : public bufferization::impl::BufferizationBufferizeBase<
        -:  281:          BufferizationBufferizePass> {
function _ZN12_GLOBAL__N_126BufferizationBufferizePass14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  282:  void runOnOperation() override {
    #####:  283:    BufferizationOptions options = getPartialBufferizationOptions();
call    0 never executed
call    1 never executed
    #####:  284:    options.opFilter.allowDialect<BufferizationDialect>();
call    0 never executed
        -:  285:
    #####:  286:    if (failed(bufferizeOp(getOperation(), options)))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  287:      signalPassFailure();
call    0 never executed
    #####:  288:  }
        -:  289:
function _ZNK12_GLOBAL__N_126BufferizationBufferizePass20getDependentDialectsERN4mlir15DialectRegistryE called 653 returned 100% blocks executed 100%
      653:  290:  void getDependentDialects(DialectRegistry &registry) const override {
      653:  291:    registry
call    0 returned 100%
      653:  292:        .insert<bufferization::BufferizationDialect, memref::MemRefDialect>();
      653:  293:  }
        -:  294:};
        -:  295:} // namespace
        -:  296:
function _ZN4mlir13bufferization32createBufferizationBufferizePassEv called 129277 returned 100% blocks executed 100%
   129277:  297:std::unique_ptr<Pass> mlir::bufferization::createBufferizationBufferizePass() {
   129277:  298:  return std::make_unique<BufferizationBufferizePass>();
call    0 returned 100%
        -:  299:}
        -:  300:
function _ZN4mlir13bufferization26createOneShotBufferizePassEv called 129229 returned 100% blocks executed 100%
   129229:  301:std::unique_ptr<Pass> mlir::bufferization::createOneShotBufferizePass() {
   129229:  302:  return std::make_unique<OneShotBufferizePass>();
call    0 returned 100%
        -:  303:}
        -:  304:
function _ZN4mlir13bufferization26createOneShotBufferizePassERKNS0_27OneShotBufferizationOptionsE called 0 returned 0% blocks executed 0%
    #####:  305:std::unique_ptr<Pass> mlir::bufferization::createOneShotBufferizePass(
        -:  306:    const OneShotBufferizationOptions &options) {
    #####:  307:  return std::make_unique<OneShotBufferizePass>(options);
call    0 never executed
        -:  308:}
        -:  309:
        -:  310:std::unique_ptr<OperationPass<func::FuncOp>>
function _ZN4mlir13bufferization29createFinalizingBufferizePassEv called 129859 returned 100% blocks executed 100%
   129859:  311:mlir::bufferization::createFinalizingBufferizePass() {
   129859:  312:  return std::make_unique<FinalizingBufferizePass>();
call    0 returned 100%
        -:  313:}
        -:  314:
        -:  315://===----------------------------------------------------------------------===//
        -:  316:// BufferizableOpInterface-based Bufferization
        -:  317://===----------------------------------------------------------------------===//
        -:  318:
function _ZL9isaTensorN4mlir4TypeE called 2383201 returned 100% blocks executed 100%
  2383201:  319:static bool isaTensor(Type t) { return t.isa<TensorType>(); }
call    0 returned 100%
        -:  320:
        -:  321:/// Return true if the given op has a tensor result or a tensor operand.
function _ZL18hasTensorSemanticsPN4mlir9OperationE called 1127244 returned 100% blocks executed 100%
  1127244:  322:static bool hasTensorSemantics(Operation *op) {
  1127244:  323:  if (auto funcOp = dyn_cast<FunctionOpInterface>(op)) {
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
    31136:  324:    bool hasTensorArg = any_of(funcOp.getArgumentTypes(), isaTensor);
call    0 returned 100%
call    1 returned 100%
    31136:  325:    bool hasTensorResult = any_of(funcOp.getResultTypes(), isaTensor);
call    0 returned 100%
call    1 returned 100%
    31136:  326:    return hasTensorArg || hasTensorResult;
        -:  327:  }
        -:  328:
  2192216:  329:  bool hasTensorResult = any_of(op->getResultTypes(), isaTensor);
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
call    2 returned 100%
  1096108:  330:  bool hasTensorOperand = any_of(op->getOperandTypes(), isaTensor);
call    0 returned 100%
call    1 returned 100%
  1096108:  331:  return hasTensorResult || hasTensorOperand;
        -:  332:}
        -:  333:
        -:  334:namespace {
        -:  335:/// A rewriter that keeps track of extra information during bufferization.
     1555:  336:class BufferizationRewriter : public IRRewriter {
call    0 returned 100%
        -:  337:public:
     1555:  338:  BufferizationRewriter(MLIRContext *ctx, DenseSet<Operation *> &erasedOps,
        -:  339:                        DenseSet<Operation *> &toMemrefOps,
        -:  340:                        SmallVector<Operation *> &worklist,
        -:  341:                        const BufferizationOptions &options,
        -:  342:                        const OpFilter *opFilter)
     1555:  343:      : IRRewriter(ctx), erasedOps(erasedOps), toMemrefOps(toMemrefOps),
     3110:  344:        worklist(worklist), analysisState(options), opFilter(opFilter) {}
        -:  345:
        -:  346:protected:
function _ZN12_GLOBAL__N_121BufferizationRewriter22notifyOperationRemovedEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  347:  void notifyOperationRemoved(Operation *op) override {
    #####:  348:    IRRewriter::notifyOperationRemoved(op);
call    0 never executed
    #####:  349:    erasedOps.insert(op);
call    0 never executed
        -:  350:    // Erase if present.
    #####:  351:    toMemrefOps.erase(op);
call    0 never executed
    #####:  352:  }
        -:  353:
function _ZN12_GLOBAL__N_121BufferizationRewriter23notifyOperationInsertedEPN4mlir9OperationE called 0 returned 0% blocks executed 0%
    #####:  354:  void notifyOperationInserted(Operation *op) override {
    #####:  355:    IRRewriter::notifyOperationInserted(op);
call    0 never executed
    #####:  356:    erasedOps.erase(op);
call    0 never executed
        -:  357:
        -:  358:    // Keep track of to_memref ops.
    #####:  359:    if (isa<ToMemrefOp>(op)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  360:      toMemrefOps.insert(op);
call    0 never executed
    #####:  361:      return;
        -:  362:    }
        -:  363:
        -:  364:    // Skip to_tensor ops.
    #####:  365:    if (isa<ToTensorOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  366:      return;
        -:  367:
        -:  368:    // Skip non-tensor ops.
    #####:  369:    if (!hasTensorSemantics(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  370:      return;
        -:  371:
        -:  372:    // Skip ops that are not allowed to be bufferized.
    #####:  373:    auto const &options = analysisState.getOptions();
call    0 never executed
    #####:  374:    if (!options.isOpAllowed(op) || (opFilter && !opFilter->isOpAllowed(op)))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  375:      return;
        -:  376:
        -:  377:    // Add op to worklist.
    #####:  378:    worklist.push_back(op);
call    0 never executed
        -:  379:  }
        -:  380:
        -:  381:private:
        -:  382:  /// A set of all erased ops.
        -:  383:  DenseSet<Operation *> &erasedOps;
        -:  384:
        -:  385:  /// A set of all to_memref ops.
        -:  386:  DenseSet<Operation *> &toMemrefOps;
        -:  387:
        -:  388:  /// The worklist of ops to be bufferized.
        -:  389:  SmallVector<Operation *> &worklist;
        -:  390:
        -:  391:  /// The analysis state. Used for debug assertions and access to the
        -:  392:  /// bufferization options.
        -:  393:  const AnalysisState analysisState;
        -:  394:
        -:  395:  /// An extra op filter for bufferization.
        -:  396:  const OpFilter *opFilter;
        -:  397:};
        -:  398:} // namespace
        -:  399:
function _ZN4mlir13bufferization11bufferizeOpEPNS_9OperationERKNS0_20BufferizationOptionsEbPKNS0_8OpFilterE called 1555 returned 100% blocks executed 27%
     1555:  400:LogicalResult bufferization::bufferizeOp(Operation *op,
        -:  401:                                         const BufferizationOptions &options,
        -:  402:                                         bool copyBeforeWrite,
        -:  403:                                         const OpFilter *opFilter) {
     1555:  404:  if (copyBeforeWrite) {
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
     1086:  405:    AnalysisState state(options);
call    0 returned 100%
      543:  406:    if (failed(insertTensorCopies(op, state)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  407:      return failure();
call    0 never executed
        -:  408:  }
        -:  409:
        -:  410:  // Keep track of to_memref ops.
     1555:  411:  DenseSet<Operation *> toMemrefOps;
call    0 returned 100%
    1555*:  412:  op->walk([&](ToMemrefOp toMemrefOp) { toMemrefOps.insert(toMemrefOp); });
call    0 never executed
call    1 returned 100%
        -:  413:
        -:  414:  // Gather all bufferizable ops in top-to-bottom order.
        -:  415:  //
        -:  416:  // We should ideally know the exact memref type of all operands when
        -:  417:  // bufferizing an op. (This is the case when bufferizing top-to-bottom.)
        -:  418:  // Otherwise, we have to use a memref type with a fully dynamic layout map to
        -:  419:  // avoid copies. We are currently missing patterns for layout maps to
        -:  420:  // canonicalize away (or canonicalize to more precise layouts).
        -:  421:  //
        -:  422:  // FuncOps must be bufferized before their bodies, so add them to the worklist
        -:  423:  // first.
     3110:  424:  SmallVector<Operation *> worklist;
call    0 returned 100%
call    1 returned 100%
function _ZZN4mlir13bufferization11bufferizeOpEPNS_9OperationERKNS0_20BufferizationOptionsEbPKNS0_8OpFilterEENKUlNS_4func6FuncOpEE0_clESA_.isra.0 called 0 returned 0% blocks executed 0%
    1555*:  425:  op->walk([&](func::FuncOp funcOp) {
call    0 returned 100%
    #####:  426:    if (hasTensorSemantics(funcOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  427:      worklist.push_back(funcOp);
call    0 never executed
    #####:  428:  });
function _ZZN4mlir13bufferization11bufferizeOpEPNS_9OperationERKNS0_20BufferizationOptionsEbPKNS0_8OpFilterEENKUlS2_E1_clES2_.isra.0 called 1127244 returned 100% blocks executed 57%
  1128799:  429:  op->walk<WalkOrder::PostOrder>([&](Operation *op) {
call    0 returned 100%
 1127244*:  430:    if (hasTensorSemantics(op) && !isa<func::FuncOp>(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  431:      worklist.push_back(op);
call    0 never executed
  1127244:  432:  });
        -:  433:
        -:  434:  // Keep track of all erased ops.
     3110:  435:  DenseSet<Operation *> erasedOps;
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  436:
        -:  437:  // Bufferize all ops.
     1555:  438:  BufferizationRewriter rewriter(op->getContext(), erasedOps, toMemrefOps,
call    0 returned 100%
     3110:  439:                                 worklist, options, opFilter);
call    0 returned 100%
call    1 returned 100%
    1555*:  440:  for (unsigned i = 0; i < worklist.size(); ++i) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  441:    Operation *nextOp = worklist[i];
branch  0 never executed
branch  1 never executed
        -:  442:    // Skip ops that were erased.
    #####:  443:    if (erasedOps.contains(nextOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  444:      continue;
        -:  445:    // Skip ops that are not bufferizable or not allowed.
    #####:  446:    auto bufferizableOp = options.dynCastBufferizableOp(nextOp);
call    0 never executed
    #####:  447:    if (!bufferizableOp)
branch  0 never executed
branch  1 never executed
    #####:  448:      continue;
    #####:  449:    if (opFilter && !opFilter->isOpAllowed(nextOp))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  450:      continue;
        -:  451:    // Skip ops that no longer have tensor semantics.
    #####:  452:    if (!hasTensorSemantics(nextOp))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  453:      continue;
        -:  454:    // Bufferize the op.
    #####:  455:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
        -:  456:               << "//===-------------------------------------------===//\n"
        -:  457:               << "IR after bufferizing: " << nextOp->getName() << "\n");
    #####:  458:    rewriter.setInsertionPoint(nextOp);
call    0 never executed
    #####:  459:    if (failed(bufferizableOp.bufferize(rewriter, options))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  460:      LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  461:                 << "failed to bufferize\n"
        -:  462:                 << "//===-------------------------------------------===//\n");
    #####:  463:      return nextOp->emitError("failed to bufferize op");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  464:    }
    #####:  465:    LLVM_DEBUG(llvm::dbgs()
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
        -:  466:               << *op
        -:  467:               << "\n//===-------------------------------------------===//\n");
        -:  468:  }
        -:  469:
        -:  470:  // Fold all to_memref(to_tensor(x)) pairs.
    1555*:  471:  for (Operation *op : toMemrefOps) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
    #####:  472:    rewriter.setInsertionPoint(op);
call    0 never executed
    #####:  473:    (void)bufferization::foldToMemrefToTensorPair(rewriter,
    #####:  474:                                                  cast<ToMemrefOp>(op));
call    0 never executed
call    1 never executed
        -:  475:  }
        -:  476:
        -:  477:  /// Check the result of bufferization. Return an error if an op was not
        -:  478:  /// bufferized, unless partial bufferization is allowed.
     1555:  479:  if (options.allowUnknownOps)
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
      543:  480:    return success();
        -:  481:
    1012*:  482:  for (Operation *op : worklist) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  483:    // Skip ops that are entirely gone.
    #####:  484:    if (erasedOps.contains(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  485:      continue;
        -:  486:    // Ops that no longer have tensor semantics (because they were updated
        -:  487:    // in-place) are allowed.
    #####:  488:    if (!hasTensorSemantics(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  489:      continue;
        -:  490:    // Continue ops that are not allowed.
    #####:  491:    if (!options.isOpAllowed(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  492:      continue;
    #####:  493:    if (opFilter && !opFilter->isOpAllowed(op))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  494:      continue;
        -:  495:    // Ops without any uses and no side effects will fold away.
    #####:  496:    if (op->getUses().empty() && MemoryEffectOpInterface::hasNoEffect(op))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  497:      continue;
        -:  498:    // ToTensorOps/ToMemrefOps are allowed in the output.
    #####:  499:    if (isa<ToTensorOp, ToMemrefOp>(op))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  500:      continue;
    #####:  501:    return op->emitError("op was not bufferized");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  502:  }
        -:  503:
     1555:  504:  return success();
call    0 returned 100%
        -:  505:}
        -:  506:
function _ZN4mlir13bufferization30getPartialBufferizationOptionsEv called 543 returned 100% blocks executed 100%
      543:  507:BufferizationOptions bufferization::getPartialBufferizationOptions() {
      543:  508:  BufferizationOptions options;
call    0 returned 100%
      543:  509:  options.allowUnknownOps = true;
      543:  510:  options.createDeallocs = false;
      543:  511:  options.enforceAliasingInvariants = false;
function _ZZN4mlir13bufferization30getPartialBufferizationOptionsEvENKUlNS_5ValueEjRKNS0_20BufferizationOptionsEE_clES1_jS4_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  512:  options.unknownTypeConverterFn = [](Value value, unsigned memorySpace,
        -:  513:                                      const BufferizationOptions &options) {
    #####:  514:    return getMemRefTypeWithStaticIdentityLayout(
    #####:  515:        value.getType().cast<TensorType>(), memorySpace);
call    0 never executed
call    1 never executed
      543:  516:  };
call    0 returned 100%
      543:  517:  options.opFilter.allowDialect<BufferizationDialect>();
call    0 returned 100%
      543:  518:  return options;
        -:  519:}
