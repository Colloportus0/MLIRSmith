        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Pass/Pass.cpp
        -:    0:Graph:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/Pass.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Pass/CMakeFiles/obj.MLIRPass.dir/Pass.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- Pass.cpp - Pass infrastructure implementation ----------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements common pass infrastructure.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Pass/Pass.h"
        -:   14:#include "PassDetail.h"
        -:   15:#include "mlir/IR/Diagnostics.h"
        -:   16:#include "mlir/IR/Dialect.h"
        -:   17:#include "mlir/IR/OpDefinition.h"
        -:   18:#include "mlir/IR/Threading.h"
        -:   19:#include "mlir/IR/Verifier.h"
        -:   20:#include "mlir/Support/FileUtilities.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/ScopeExit.h"
        -:   23:#include "llvm/Support/CommandLine.h"
        -:   24:#include "llvm/Support/CrashRecoveryContext.h"
        -:   25:#include "llvm/Support/Mutex.h"
        -:   26:#include "llvm/Support/Signals.h"
        -:   27:#include "llvm/Support/Threading.h"
        -:   28:#include "llvm/Support/ToolOutputFile.h"
        -:   29:
        -:   30:using namespace mlir;
        -:   31:using namespace mlir::detail;
        -:   32:
        -:   33://===----------------------------------------------------------------------===//
        -:   34:// Pass
        -:   35://===----------------------------------------------------------------------===//
        -:   36:
        -:   37:/// Out of line virtual method to ensure vtables and metadata are emitted to a
        -:   38:/// single .o file.
function _ZN4mlir4Pass6anchorEv called 0 returned 0% blocks executed 0%
    #####:   39:void Pass::anchor() {}
        -:   40:
        -:   41:/// Attempt to initialize the options of this pass from the given string.
function _ZN4mlir4Pass17initializeOptionsEN4llvm9StringRefE called 168771 returned 100% blocks executed 100%
   168771:   42:LogicalResult Pass::initializeOptions(StringRef options) {
   168771:   43:  return passOptions.parseFromString(options);
call    0 returned 100%
        -:   44:}
        -:   45:
        -:   46:/// Copy the option values from 'other', which is another instance of this
        -:   47:/// pass.
function _ZN4mlir4Pass20copyOptionValuesFromEPKS0_ called 0 returned 0% blocks executed 0%
 4099320*:   48:void Pass::copyOptionValuesFrom(const Pass *other) {
 4099320*:   49:  passOptions.copyOptionValuesFrom(other->passOptions);
call    0 never executed
call    1 returned 100%
    #####:   50:}
        -:   51:
        -:   52:/// Prints out the pass in the textual representation of pipelines. If this is
        -:   53:/// an adaptor pass, print its pass managers.
function _ZN4mlir4Pass22printAsTextualPipelineERN4llvm11raw_ostreamE called 4422 returned 100% blocks executed 100%
     4422:   54:void Pass::printAsTextualPipeline(raw_ostream &os) {
        -:   55:  // Special case for adaptors to print its pass managers.
     4422:   56:  if (auto *adaptor = dyn_cast<OpToOpPassAdaptor>(this)) {
call    0 returned 100%
branch  1 taken 27% (fallthrough)
branch  2 taken 73%
     1208:   57:    llvm::interleave(
call    0 returned 100%
     1208:   58:        adaptor->getPassManagers(),
call    0 returned 100%
    1208*:   59:        [&](OpPassManager &pm) { pm.printAsTextualPipeline(os); },
call    0 returned 100%
call    1 never executed
    #####:   60:        [&] { os << ","; });
call    0 never executed
     1208:   61:    return;
        -:   62:  }
        -:   63:  // Otherwise, print the pass argument followed by its options. If the pass
        -:   64:  // doesn't have an argument, print the name of the pass to give some indicator
        -:   65:  // of what pass was run.
     3214:   66:  StringRef argument = getArgument();
call    0 returned 100%
     3214:   67:  if (!argument.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3200:   68:    os << argument;
call    0 returned 100%
        -:   69:  else
       14:   70:    os << "unknown<" << getName() << ">";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     3214:   71:  passOptions.print(os);
call    0 returned 100%
        -:   72:}
        -:   73:
        -:   74://===----------------------------------------------------------------------===//
        -:   75:// OpPassManagerImpl
        -:   76://===----------------------------------------------------------------------===//
        -:   77:
        -:   78:namespace mlir {
        -:   79:namespace detail {
        -:   80:struct OpPassManagerImpl {
function _ZN4mlir6detail17OpPassManagerImplC2ENS_13OperationNameENS_13OpPassManager7NestingE called 99380 returned 100% blocks executed 80%
    99380:   81:  OpPassManagerImpl(OperationName opName, OpPassManager::Nesting nesting)
    99380:   82:      : name(opName.getStringRef().str()), opName(opName),
call    0 returned 100%
    99380:   83:        initializationGeneration(0), nesting(nesting) {}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
function _ZN4mlir6detail17OpPassManagerImplC2EN4llvm9StringRefENS_13OpPassManager7NestingE called 68331 returned 100% blocks executed 57%
    68331:   84:  OpPassManagerImpl(StringRef name, OpPassManager::Nesting nesting)
   68331*:   85:      : name(name == OpPassManager::getAnyOpAnchorName() ? "" : name.str()),
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   68331*:   86:        initializationGeneration(0), nesting(nesting) {}
call    0 never executed
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   87:  OpPassManagerImpl(OpPassManager::Nesting nesting)
    #####:   88:      : initializationGeneration(0), nesting(nesting) {}
function _ZN4mlir6detail17OpPassManagerImplC2ERKS1_ called 3311712 returned 100% blocks executed 80%
  3311712:   89:  OpPassManagerImpl(const OpPassManagerImpl &rhs)
  3311712:   90:      : name(rhs.name), opName(rhs.opName),
  3311712:   91:        initializationGeneration(rhs.initializationGeneration),
  3311712:   92:        nesting(rhs.nesting) {
call    0 returned 100%
  7411032:   93:    for (const std::unique_ptr<Pass> &pass : rhs.passes) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
call    2 returned 100%
  8198640:   94:      std::unique_ptr<Pass> newPass = pass->clone();
call    0 returned 100%
  4099320:   95:      newPass->threadingSibling = pass.get();
call    0 returned 100%
  4099320:   96:      passes.push_back(std::move(newPass));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   97:    }
  3311712:   98:  }
        -:   99:
        -:  100:  /// Merge the passes of this pass manager into the one provided.
        -:  101:  void mergeInto(OpPassManagerImpl &rhs);
        -:  102:
        -:  103:  /// Nest a new operation pass manager for the given operation kind under this
        -:  104:  /// pass manager.
function _ZN4mlir6detail17OpPassManagerImpl4nestENS_13OperationNameE called 0 returned 0% blocks executed 0%
    #####:  105:  OpPassManager &nest(OperationName nestedName) {
    #####:  106:    return nest(OpPassManager(nestedName, nesting));
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  107:  }
function _ZN4mlir6detail17OpPassManagerImpl4nestEN4llvm9StringRefE called 66680 returned 100% blocks executed 80%
    66680:  108:  OpPassManager &nest(StringRef nestedName) {
    66680:  109:    return nest(OpPassManager(nestedName, nesting));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  110:  }
function _ZN4mlir6detail17OpPassManagerImpl7nestAnyEv called 0 returned 0% blocks executed 0%
    #####:  111:  OpPassManager &nestAny() { return nest(OpPassManager(nesting)); }
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  112:
        -:  113:  /// Nest the given pass manager under this pass manager.
        -:  114:  OpPassManager &nest(OpPassManager &&nested);
        -:  115:
        -:  116:  /// Add the given pass to this pass manager. If this pass has a concrete
        -:  117:  /// operation type, it must be the same type as this pass manager.
        -:  118:  void addPass(std::unique_ptr<Pass> pass);
        -:  119:
        -:  120:  /// Clear the list of passes in this pass manager, other options are
        -:  121:  /// preserved.
        -:  122:  void clear();
        -:  123:
        -:  124:  /// Finalize the pass list in preparation for execution. This includes
        -:  125:  /// coalescing adjacent pass managers when possible, verifying scheduled
        -:  126:  /// passes, etc.
        -:  127:  LogicalResult finalizePassList(MLIRContext *ctx);
        -:  128:
        -:  129:  /// Return the operation name of this pass manager.
function _ZN4mlir6detail17OpPassManagerImpl9getOpNameERNS_11MLIRContextE called 378791 returned 100% blocks executed 88%
   378791:  130:  Optional<OperationName> getOpName(MLIRContext &context) {
   378791:  131:    if (!name.empty() && !opName)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
   109564:  132:      opName = OperationName(name, &context);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   378791:  133:    return opName;
        -:  134:  }
   529154:  135:  Optional<StringRef> getOpName() const {
  529154*:  136:    return name.empty() ? Optional<StringRef>() : Optional<StringRef>(name);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  137:  }
        -:  138:
        -:  139:  /// Return the name used to anchor this pass manager. This is either the name
        -:  140:  /// of an operation, or the result of `getAnyOpAnchorName()` in the case of an
        -:  141:  /// op-agnostic pass manager.
function _ZNK4mlir6detail17OpPassManagerImpl15getOpAnchorNameEv called 39370 returned 100% blocks executed 83%
    39370:  142:  StringRef getOpAnchorName() const {
    78740:  143:    return getOpName().value_or(OpPassManager::getAnyOpAnchorName());
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  144:  }
        -:  145:
        -:  146:  /// Indicate if the current pass manager can be scheduled on the given
        -:  147:  /// operation type.
        -:  148:  bool canScheduleOn(MLIRContext &context, OperationName opName);
        -:  149:
        -:  150:  /// The name of the operation that passes of this pass manager operate on.
        -:  151:  std::string name;
        -:  152:
        -:  153:  /// The cached OperationName (internalized in the context) for the name of the
        -:  154:  /// operation that passes of this pass manager operate on.
        -:  155:  Optional<OperationName> opName;
        -:  156:
        -:  157:  /// The set of passes to run as part of this pass manager.
        -:  158:  std::vector<std::unique_ptr<Pass>> passes;
        -:  159:
        -:  160:  /// The current initialization generation of this pass manager. This is used
        -:  161:  /// to indicate when a pass manager should be reinitialized.
        -:  162:  unsigned initializationGeneration;
        -:  163:
        -:  164:  /// Control the implicit nesting of passes that mismatch the name set for this
        -:  165:  /// OpPassManager.
        -:  166:  OpPassManager::Nesting nesting;
        -:  167:};
        -:  168:} // namespace detail
        -:  169:} // namespace mlir
        -:  170:
function _ZN4mlir6detail17OpPassManagerImpl9mergeIntoERS1_ called 12918 returned 100% blocks executed 79%
    12918:  171:void OpPassManagerImpl::mergeInto(OpPassManagerImpl &rhs) {
   12918*:  172:  assert(name == rhs.name && "merging unrelated pass managers");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    25847:  173:  for (auto &pass : passes)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
    12929:  174:    rhs.passes.push_back(std::move(pass));
call    0 returned 100%
    12918:  175:  passes.clear();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    12918:  176:}
        -:  177:
function _ZN4mlir6detail17OpPassManagerImpl4nestEONS_13OpPassManagerE called 66680 returned 100% blocks executed 67%
    66680:  178:OpPassManager &OpPassManagerImpl::nest(OpPassManager &&nested) {
    66680:  179:  auto *adaptor = new OpToOpPassAdaptor(std::move(nested));
call    0 returned 100%
call    1 returned 100%
    66680:  180:  addPass(std::unique_ptr<Pass>(adaptor));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    66680:  181:  return adaptor->getPassManagers().front();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  182:}
        -:  183:
function _ZN4mlir6detail17OpPassManagerImpl7addPassESt10unique_ptrINS_4PassESt14default_deleteIS3_EE called 313931 returned 100% blocks executed 38%
   313931:  184:void OpPassManagerImpl::addPass(std::unique_ptr<Pass> pass) {
        -:  185:  // If this pass runs on a different operation than this pass manager, then
        -:  186:  // implicitly nest a pass manager for this operation if enabled.
   313931:  187:  Optional<StringRef> pmOpName = getOpName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   313931:  188:  Optional<StringRef> passOpName = pass->getOpName();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   313931:  189:  if (pmOpName && passOpName && *pmOpName != *passOpName) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 54% (fallthrough)
branch  3 taken 46%
branch  4 taken 34% (fallthrough)
branch  5 taken 66%
    57419:  190:    if (nesting == OpPassManager::Nesting::Implicit)
branch  0 taken 100%
branch  1 taken 0%
    57419:  191:      return nest(*passOpName).addPass(std::move(pass));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  192:    llvm::report_fatal_error(llvm::Twine("Can't add pass '") + pass->getName() +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  193:                             "' restricted to '" + *passOpName +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  194:                             "' on a PassManager intended to run on '" +
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  195:                             getOpAnchorName() + "', did you intend to nest?");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  196:  }
        -:  197:
   256512:  198:  passes.emplace_back(std::move(pass));
call    0 returned 100%
        -:  199:}
        -:  200:
function _ZN4mlir6detail17OpPassManagerImpl5clearEv called 0 returned 0% blocks executed 0%
    #####:  201:void OpPassManagerImpl::clear() { passes.clear(); }
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  202:
function _ZN4mlir6detail17OpPassManagerImpl16finalizePassListEPNS_11MLIRContextE called 163957 returned 100% blocks executed 92%
   163957:  203:LogicalResult OpPassManagerImpl::finalizePassList(MLIRContext *ctx) {
function _ZZN4mlir6detail17OpPassManagerImpl16finalizePassListEPNS_11MLIRContextEENKUlPNS0_17OpToOpPassAdaptorEE_clES5_.isra.0 called 51289 returned 100% blocks executed 89%
   105051:  204:  auto finalizeAdaptor = [ctx](OpToOpPassAdaptor *adaptor) {
call    0 returned 100%
   105051:  205:    for (auto &pm : adaptor->getPassManagers())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    53762:  206:      if (failed(pm.getImpl().finalizePassList(ctx)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        return failure();
    51289:  208:    return success();
   163957:  209:  };
        -:  210:
        -:  211:  // Walk the pass list and merge adjacent adaptors.
   163957:  212:  OpToOpPassAdaptor *lastAdaptor = nullptr;
   430264:  213:  for (auto &pass : passes) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
call    2 returned 100%
        -:  214:    // Check to see if this pass is an adaptor.
   266307:  215:    if (auto *currentAdaptor = dyn_cast<OpToOpPassAdaptor>(pass.get())) {
call    0 returned 100%
branch  1 taken 25% (fallthrough)
branch  2 taken 75%
        -:  216:      // If it is the first adaptor in a possible chain, remember it and
        -:  217:      // continue.
    66680:  218:      if (!lastAdaptor) {
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
    51289:  219:        lastAdaptor = currentAdaptor;
    51289:  220:        continue;
        -:  221:      }
        -:  222:
        -:  223:      // Otherwise, try to merge into the existing adaptor and delete the
        -:  224:      // current one. If merging fails, just remember this as the last adaptor.
    15391:  225:      if (succeeded(currentAdaptor->tryMergeInto(ctx, *lastAdaptor)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   281698:  226:        pass.reset();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  227:      else
        -:  228:        lastAdaptor = currentAdaptor;
   199627:  229:    } else if (lastAdaptor) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:  230:      // If this pass isn't an adaptor, finalize it and forget the last adaptor.
    20233:  231:      if (failed(finalizeAdaptor(lastAdaptor)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  232:        return failure();
        -:  233:      lastAdaptor = nullptr;
        -:  234:    }
        -:  235:  }
        -:  236:
        -:  237:  // If there was an adaptor at the end of the manager, finalize it as well.
   163957:  238:  if (lastAdaptor && failed(finalizeAdaptor(lastAdaptor)))
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
    #####:  239:    return failure();
        -:  240:
        -:  241:  // Now that the adaptors have been merged, erase any empty slots corresponding
        -:  242:  // to the merged adaptors that were nulled-out in the loop above.
   163957:  243:  llvm::erase_if(passes, std::logical_not<std::unique_ptr<Pass>>());
call    0 returned 100%
        -:  244:
        -:  245:  // If this is a op-agnostic pass manager, there is nothing left to do.
   163957:  246:  Optional<OperationName> rawOpName = getOpName(*ctx);
call    0 returned 100%
   163957:  247:  if (!rawOpName)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  248:    return success();
        -:  249:
        -:  250:  // Otherwise, verify that all of the passes are valid for the current
        -:  251:  // operation anchor.
   163957:  252:  Optional<RegisteredOperationName> opName = rawOpName->getRegisteredInfo();
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
   398812:  253:  for (std::unique_ptr<Pass> &pass : passes) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
   239931:  254:    if (opName && !pass->canScheduleOn(*opName)) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
call    2 returned 100%
branch  3 taken 97% (fallthrough)
branch  4 taken 3%
    10152:  255:      return emitError(UnknownLoc::get(ctx))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
     5076:  256:             << "unable to schedule pass '" << pass->getName()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
    10152:  257:             << "' on a PassManager intended to run on '" << getOpAnchorName()
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
     5076:  258:             << "'!";
call    0 returned 100%
        -:  259:    }
        -:  260:  }
   158881:  261:  return success();
        -:  262:}
        -:  263:
function _ZN4mlir6detail17OpPassManagerImpl13canScheduleOnERNS_11MLIRContextENS_13OperationNameE called 114436 returned 100% blocks executed 36%
   114436:  264:bool OpPassManagerImpl::canScheduleOn(MLIRContext &context,
        -:  265:                                      OperationName opName) {
        -:  266:  // If this pass manager is op-specific, we simply check if the provided
        -:  267:  // operation name is the same as this one.
   114436:  268:  Optional<OperationName> pmOpName = getOpName(context);
call    0 returned 100%
   114436:  269:  if (pmOpName)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   114436:  270:    return pmOpName == opName;
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:  271:
        -:  272:  // Otherwise, this is an op-agnostic pass manager. Check that the operation
        -:  273:  // can be scheduled on all passes within the manager.
    #####:  274:  Optional<RegisteredOperationName> registeredInfo = opName.getRegisteredInfo();
branch  0 never executed
branch  1 never executed
    #####:  275:  if (!registeredInfo ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  276:      !registeredInfo->hasTrait<OpTrait::IsIsolatedFromAbove>())
call    0 never executed
    #####:  277:    return false;
function _ZZN4mlir6detail17OpPassManagerImpl13canScheduleOnERNS_11MLIRContextENS_13OperationNameEENKUlRKSt10unique_ptrINS_4PassESt14default_deleteIS6_EEE_clESB_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  278:  return llvm::all_of(passes, [&](const std::unique_ptr<Pass> &pass) {
call    0 never executed
    #####:  279:    return pass->canScheduleOn(*registeredInfo);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  280:  });
        -:  281:}
        -:  282:
        -:  283://===----------------------------------------------------------------------===//
        -:  284:// OpPassManager
        -:  285://===----------------------------------------------------------------------===//
        -:  286:
function _ZN4mlir13OpPassManagerC2ENS0_7NestingE called 0 returned 0% blocks executed 0%
    #####:  287:OpPassManager::OpPassManager(Nesting nesting)
    #####:  288:    : impl(new OpPassManagerImpl(nesting)) {}
call    0 never executed
function _ZN4mlir13OpPassManagerC2EN4llvm9StringRefENS0_7NestingE called 68331 returned 100% blocks executed 100%
    68331:  289:OpPassManager::OpPassManager(StringRef name, Nesting nesting)
    68331:  290:    : impl(new OpPassManagerImpl(name, nesting)) {}
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir13OpPassManagerC2ENS_13OperationNameENS0_7NestingE called 99380 returned 100% blocks executed 100%
    99380:  291:OpPassManager::OpPassManager(OperationName name, Nesting nesting)
    99380:  292:    : impl(new OpPassManagerImpl(name, nesting)) {}
call    0 returned 100%
call    1 returned 100%
function _ZN4mlir13OpPassManagerC2EOS0_ called 515 returned 100% blocks executed 100%
   71547*:  293:OpPassManager::OpPassManager(OpPassManager &&rhs) : impl(std::move(rhs.impl)) {}
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
function _ZN4mlir13OpPassManagerC2ERKS0_ called 0 returned 0% blocks executed 0%
 3311712*:  294:OpPassManager::OpPassManager(const OpPassManager &rhs) { *this = rhs; }
call    0 returned 100%
call    1 never executed
function _ZN4mlir13OpPassManageraSERKS0_ called 3311712 returned 100% blocks executed 80%
  3311712:  295:OpPassManager &OpPassManager::operator=(const OpPassManager &rhs) {
  6623424:  296:  impl = std::make_unique<OpPassManagerImpl>(*rhs.impl);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
  3311712:  297:  return *this;
        -:  298:}
        -:  299:
        -:  300:OpPassManager::~OpPassManager() = default;
        -:  301:
function _ZN4mlir13OpPassManager5beginEv called 74070 returned 100% blocks executed 100%
   322264:  302:OpPassManager::pass_iterator OpPassManager::begin() {
   248194:  303:  return MutableArrayRef<std::unique_ptr<Pass>>{impl->passes}.begin();
        -:  304:}
function _ZN4mlir13OpPassManager3endEv called 74070 returned 100% blocks executed 100%
   322264:  305:OpPassManager::pass_iterator OpPassManager::end() {
   248194:  306:  return MutableArrayRef<std::unique_ptr<Pass>>{impl->passes}.end();
        -:  307:}
        -:  308:
function _ZNK4mlir13OpPassManager5beginEv called 0 returned 0% blocks executed 0%
  166691*:  309:OpPassManager::const_pass_iterator OpPassManager::begin() const {
  166691*:  310:  return ArrayRef<std::unique_ptr<Pass>>{impl->passes}.begin();
        -:  311:}
function _ZNK4mlir13OpPassManager3endEv called 0 returned 0% blocks executed 0%
  166691*:  312:OpPassManager::const_pass_iterator OpPassManager::end() const {
  166691*:  313:  return ArrayRef<std::unique_ptr<Pass>>{impl->passes}.end();
        -:  314:}
        -:  315:
        -:  316:/// Nest a new operation pass manager for the given operation kind under this
        -:  317:/// pass manager.
function _ZN4mlir13OpPassManager4nestENS_13OperationNameE called 0 returned 0% blocks executed 0%
    #####:  318:OpPassManager &OpPassManager::nest(OperationName nestedName) {
    #####:  319:  return impl->nest(nestedName);
call    0 never executed
        -:  320:}
function _ZN4mlir13OpPassManager4nestEN4llvm9StringRefE called 9261 returned 100% blocks executed 100%
     9261:  321:OpPassManager &OpPassManager::nest(StringRef nestedName) {
     9261:  322:  return impl->nest(nestedName);
call    0 returned 100%
        -:  323:}
function _ZN4mlir13OpPassManager7nestAnyEv called 0 returned 0% blocks executed 0%
    #####:  324:OpPassManager &OpPassManager::nestAny() { return impl->nestAny(); }
call    0 never executed
        -:  325:
        -:  326:/// Add the given pass to this pass manager. If this pass has a concrete
        -:  327:/// operation type, it must be the same type as this pass manager.
function _ZN4mlir13OpPassManager7addPassESt10unique_ptrINS_4PassESt14default_deleteIS2_EE called 247251 returned 100% blocks executed 60%
   247251:  328:void OpPassManager::addPass(std::unique_ptr<Pass> pass) {
   247251:  329:  impl->addPass(std::move(pass));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
   247251:  330:}
        -:  331:
function _ZN4mlir13OpPassManager5clearEv called 0 returned 0% blocks executed 0%
    #####:  332:void OpPassManager::clear() { impl->clear(); }
branch  0 never executed
branch  1 never executed
        -:  333:
        -:  334:/// Returns the number of passes held by this manager.
function _ZNK4mlir13OpPassManager4sizeEv called 0 returned 0% blocks executed 0%
    #####:  335:size_t OpPassManager::size() const { return impl->passes.size(); }
        -:  336:
        -:  337:/// Returns the internal implementation instance.
function _ZN4mlir13OpPassManager7getImplEv called 0 returned 0% blocks executed 0%
   53762*:  338:OpPassManagerImpl &OpPassManager::getImpl() { return *impl; }
call    0 returned 100%
        -:  339:
        -:  340:/// Return the operation name that this pass manager operates on.
function _ZNK4mlir13OpPassManager9getOpNameEv called 168771 returned 100% blocks executed 75%
   175853:  341:Optional<StringRef> OpPassManager::getOpName() const {
   168771:  342:  return impl->getOpName();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  343:}
        -:  344:
        -:  345:/// Return the operation name that this pass manager operates on.
function _ZNK4mlir13OpPassManager9getOpNameERNS_11MLIRContextE called 0 returned 0% blocks executed 0%
  100398*:  346:Optional<OperationName> OpPassManager::getOpName(MLIRContext &context) const {
    #####:  347:  return impl->getOpName(context);
call    0 never executed
        -:  348:}
        -:  349:
function _ZNK4mlir13OpPassManager15getOpAnchorNameEv called 527 returned 100% blocks executed 100%
    34294:  350:StringRef OpPassManager::getOpAnchorName() const {
      527:  351:  return impl->getOpAnchorName();
call    0 returned 100%
        -:  352:}
        -:  353:
        -:  354:/// Prints out the passes of the pass manager as the textual representation
        -:  355:/// of pipelines.
function _ZNK4mlir13OpPassManager22printAsTextualPipelineERN4llvm11raw_ostreamE called 1875 returned 100% blocks executed 100%
     1875:  356:void OpPassManager::printAsTextualPipeline(raw_ostream &os) const {
     1875:  357:  os << getOpAnchorName() << "(";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     3750:  358:  llvm::interleave(
     1875:  359:      impl->passes,
call    0 returned 100%
     4422:  360:      [&](const std::unique_ptr<Pass> &pass) {
     4422:  361:        pass->printAsTextualPipeline(os);
call    0 returned 100%
call    1 returned 100%
        -:  362:      },
     2867:  363:      [&]() { os << ","; });
call    0 returned 100%
     1875:  364:  os << ")";
call    0 returned 100%
     1875:  365:}
        -:  366:
function _ZN4mlir13OpPassManager4dumpEv called 667 returned 100% blocks executed 100%
      667:  367:void OpPassManager::dump() {
      667:  368:  llvm::errs() << "Pass Manager with " << impl->passes.size() << " passes:\n";
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
      667:  369:  printAsTextualPipeline(llvm::errs());
call    0 returned 100%
call    1 returned 100%
      667:  370:  llvm::errs() << "\n";
call    0 returned 100%
call    1 returned 100%
      667:  371:}
        -:  372:
   166691:  373:static void registerDialectsForPipeline(const OpPassManager &pm,
        -:  374:                                        DialectRegistry &dialects) {
  421173*:  375:  for (const Pass &pass : pm.getPasses())
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
call    5 returned 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
  254482*:  376:    pass.getDependentDialects(dialects);
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:  377:}
        -:  378:
function _ZNK4mlir13OpPassManager20getDependentDialectsERNS_15DialectRegistryE called 631 returned 100% blocks executed 60%
   166691:  379:void OpPassManager::getDependentDialects(DialectRegistry &dialects) const {
      631:  380:  registerDialectsForPipeline(*this, dialects);
      631:  381:}
        -:  382:
function _ZN4mlir13OpPassManager10setNestingENS0_7NestingE called 0 returned 0% blocks executed 0%
    #####:  383:void OpPassManager::setNesting(Nesting nesting) { impl->nesting = nesting; }
        -:  384:
function _ZN4mlir13OpPassManager10getNestingEv called 168771 returned 100% blocks executed 100%
   168771:  385:OpPassManager::Nesting OpPassManager::getNesting() { return impl->nesting; }
        -:  386:
function _ZN4mlir13OpPassManager10initializeEPNS_11MLIRContextEj called 152867 returned 100% blocks executed 85%
   152867:  387:LogicalResult OpPassManager::initialize(MLIRContext *context,
        -:  388:                                        unsigned newInitGeneration) {
   152867:  389:  if (impl->initializationGeneration == newInitGeneration)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
     9795:  390:    return success();
   143072:  391:  impl->initializationGeneration = newInitGeneration;
   350264:  392:  for (Pass &pass : getPasses()) {
branch  0 taken 59% (fallthrough)
branch  1 taken 41%
call    2 returned 100%
        -:  393:    // If this pass isn't an adaptor, directly initialize it.
   207192:  394:    auto *adaptor = dyn_cast<OpToOpPassAdaptor>(&pass);
call    0 returned 100%
   207192:  395:    if (!adaptor) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
   161524:  396:      if (failed(pass.initialize(context)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  397:        return failure();
   161524:  398:      continue;
        -:  399:    }
        -:  400:
        -:  401:    // Otherwise, initialize each of the adaptors pass managers.
    93416:  402:    for (OpPassManager &adaptorPM : adaptor->getPassManagers())
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
    47748:  403:      if (failed(adaptorPM.initialize(context, newInitGeneration)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  404:        return failure();
        -:  405:  }
   143072:  406:  return success();
        -:  407:}
        -:  408:
        -:  409://===----------------------------------------------------------------------===//
        -:  410:// OpToOpPassAdaptor
        -:  411://===----------------------------------------------------------------------===//
        -:  412:
function _ZN4mlir6detail17OpToOpPassAdaptor3runEPNS_4PassEPNS_9OperationENS_15AnalysisManagerEbj called 153609 returned 100% blocks executed 67%
   153609:  413:LogicalResult OpToOpPassAdaptor::run(Pass *pass, Operation *op,
        -:  414:                                     AnalysisManager am, bool verifyPasses,
        -:  415:                                     unsigned parentInitGeneration) {
   153609:  416:  Optional<RegisteredOperationName> opInfo = op->getRegisteredInfo();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
   153609:  417:  if (!opInfo)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  418:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  419:           << "trying to schedule a pass on an unregistered operation";
call    0 never executed
   153609:  420:  if (!opInfo->hasTrait<OpTrait::IsIsolatedFromAbove>())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  421:    return op->emitOpError() << "trying to schedule a pass on an operation not "
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  422:                                "marked as 'IsolatedFromAbove'";
call    0 never executed
        -:  423:
        -:  424:  // Initialize the pass state with a callback for the pass to dynamically
        -:  425:  // execute a pipeline on the currently visited operation.
   153609:  426:  PassInstrumentor *pi = am.getPassInstrumentor();
call    0 returned 100%
   153609:  427:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
   153609:  428:                                                        pass};
function _ZZN4mlir6detail17OpToOpPassAdaptor3runEPNS_4PassEPNS_9OperationENS_15AnalysisManagerEbjENKUlRNS_13OpPassManagerES5_E_clES8_S5_ called 10815 returned 100% blocks executed 65%
   164424:  429:  auto dynamicPipelineCallback = [&](OpPassManager &pipeline,
        -:  430:                                     Operation *root) -> LogicalResult {
   10815*:  431:    if (!op->isAncestor(root))
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
    #####:  432:      return root->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  433:             << "Trying to schedule a dynamic pipeline on an "
        -:  434:                "operation that isn't "
    #####:  435:                "nested under the current operation the pass is processing";
call    0 never executed
   10815*:  436:    assert(
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  437:        pipeline.getImpl().canScheduleOn(*op->getContext(), root->getName()));
        -:  438:
        -:  439:    // Before running, finalize the passes held by the pipeline.
    10815:  440:    if (failed(pipeline.getImpl().finalizePassList(root->getContext())))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  441:      return failure();
        -:  442:
        -:  443:    // Initialize the user provided pipeline and execute the pipeline.
    10815:  444:    if (failed(pipeline.initialize(root->getContext(), parentInitGeneration)))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  445:      return failure();
    10815:  446:    AnalysisManager nestedAm = root == op ? am : am.nest(root);
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
call    2 returned 100%
    10815:  447:    return OpToOpPassAdaptor::runPipeline(pipeline, root, nestedAm,
    10815:  448:                                          verifyPasses, parentInitGeneration,
    10815:  449:                                          pi, &parentInfo);
call    0 returned 100%
   153609:  450:  };
   153609:  451:  pass->passState.emplace(op, am, dynamicPipelineCallback);
call    0 returned 100%
        -:  452:
        -:  453:  // Instrument before the pass has run.
   153609:  454:  if (pi)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     7411:  455:    pi->runBeforePass(pass, op);
call    0 returned 100%
        -:  456:
        -:  457:  // Invoke the virtual runOnOperation method.
   153609:  458:  if (auto *adaptor = dyn_cast<OpToOpPassAdaptor>(pass))
call    0 returned 100%
branch  1 taken 28% (fallthrough)
branch  2 taken 72%
    43483:  459:    adaptor->runOnOperation(verifyPasses);
call    0 returned 100%
        -:  460:  else
   110126:  461:    pass->runOnOperation();
call    0 returned 100%
   153609:  462:  bool passFailed = pass->passState->irAndPassFailed.getInt();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  463:
        -:  464:  // Invalidate any non preserved analyses.
   153609:  465:  am.invalidate(pass->passState->preservedAnalyses);
call    0 returned 100%
        -:  466:
        -:  467:  // When verifyPasses is specified, we run the verifier (unless the pass
        -:  468:  // failed).
   153609:  469:  if (!passFailed && verifyPasses) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
   151504:  470:    bool runVerifierNow = true;
        -:  471:
        -:  472:    // If the pass is an adaptor pass, we don't run the verifier recursively
        -:  473:    // because the nested operations should have already been verified after
        -:  474:    // nested passes had run.
   151504:  475:    bool runVerifierRecursively = !isa<OpToOpPassAdaptor>(pass);
call    0 returned 100%
        -:  476:
        -:  477:    // Reduce compile time by avoiding running the verifier if the pass didn't
        -:  478:    // change the IR since the last time the verifier was run:
        -:  479:    //
        -:  480:    //  1) If the pass said that it preserved all analyses then it can't have
        -:  481:    //     permuted the IR.
        -:  482:    //
        -:  483:    // We run these checks in EXPENSIVE_CHECKS mode out of caution.
        -:  484:#ifndef EXPENSIVE_CHECKS
   151504:  485:    runVerifierNow = !pass->passState->preservedAnalyses.isAll();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  486:#endif
   151504:  487:    if (runVerifierNow)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
   151494:  488:      passFailed = failed(verify(op, runVerifierRecursively));
call    0 returned 100%
        -:  489:  }
        -:  490:
        -:  491:  // Instrument after the pass has run.
   153609:  492:  if (pi) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     7411:  493:    if (passFailed)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
      113:  494:      pi->runAfterPassFailed(pass, op);
call    0 returned 100%
        -:  495:    else
     7298:  496:      pi->runAfterPass(pass, op);
call    0 returned 100%
        -:  497:  }
        -:  498:
        -:  499:  // Return if the pass signaled a failure.
   153609:  500:  return failure(passFailed);
        -:  501:}
        -:  502:
        -:  503:/// Run the given operation and analysis manager on a provided op pass manager.
function _ZN4mlir6detail17OpToOpPassAdaptor11runPipelineERNS_13OpPassManagerEPNS_9OperationENS_15AnalysisManagerEbjPNS_16PassInstrumentorEPKNS_19PassInstrumentation18PipelineParentInfoE called 105122 returned 100% blocks executed 95%
   105122:  504:LogicalResult OpToOpPassAdaptor::runPipeline(
        -:  505:    OpPassManager &pm, Operation *op, AnalysisManager am, bool verifyPasses,
        -:  506:    unsigned parentInitGeneration, PassInstrumentor *instrumentor,
        -:  507:    const PassInstrumentation::PipelineParentInfo *parentInfo) {
  105122*:  508:  assert((!instrumentor || parentInfo) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  509:         "expected parent info if instrumentor is provided");
   210244:  510:  auto scopeExit = llvm::make_scope_exit([&] {
        -:  511:    // Clear out any computed operation analyses. These analyses won't be used
        -:  512:    // any more in this pipeline, and this helps reduce the current working set
        -:  513:    // of memory. If preserving these analyses becomes important in the future
        -:  514:    // we can re-evaluate this.
   105122:  515:    am.clear();
call    0 returned 100%
   210244:  516:  });
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  517:
        -:  518:  // Run the pipeline over the provided operation.
   105122:  519:  if (instrumentor) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      509:  520:    instrumentor->runBeforePipeline(pm.getOpName(*op->getContext()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  521:                                    *parentInfo);
        -:  522:  }
        -:  523:
   256623:  524:  for (Pass &pass : pm.getPasses())
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
call    2 returned 100%
   153609:  525:    if (failed(run(&pass, op, am, verifyPasses, parentInitGeneration)))
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
     2108:  526:      return failure();
        -:  527:
   103014:  528:  if (instrumentor) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
      509:  529:    instrumentor->runAfterPipeline(pm.getOpName(*op->getContext()),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  530:                                   *parentInfo);
        -:  531:  }
   105122:  532:  return success();
call    0 returned 100%
        -:  533:}
        -:  534:
        -:  535:/// Find an operation pass manager with the given anchor name, or nullptr if one
        -:  536:/// does not exist.
        -:  537:static OpPassManager *
    15391:  538:findPassManagerWithAnchor(MutableArrayRef<OpPassManager> mgrs, StringRef name) {
    15391:  539:  auto *it = llvm::find_if(
call    0 returned 100%
function _ZZL25findPassManagerWithAnchorN4llvm15MutableArrayRefIN4mlir13OpPassManagerEEENS_9StringRefEENKUlRS2_E_clES5_.isra.0 called 15929 returned 100% blocks executed 83%
    15929:  540:      mgrs, [&](OpPassManager &mgr) { return mgr.getOpAnchorName() == name; });
call    0 returned 100%
branch  1 taken 81% (fallthrough)
branch  2 taken 19%
    15391:  541:  return it == mgrs.end() ? nullptr : &*it;
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -:  542:}
        -:  543:
        -:  544:/// Find an operation pass manager that can operate on an operation of the given
        -:  545:/// type, or nullptr if one does not exist.
    98780:  546:static OpPassManager *findPassManagerFor(MutableArrayRef<OpPassManager> mgrs,
        -:  547:                                         OperationName name,
        -:  548:                                         MLIRContext &context) {
    98780:  549:  auto *it = llvm::find_if(mgrs, [&](OpPassManager &mgr) {
call    0 returned 100%
call    1 returned 100%
        -:  550:    return mgr.getImpl().canScheduleOn(context, name);
        -:  551:  });
    98780:  552:  return it == mgrs.end() ? nullptr : &*it;
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  553:}
        -:  554:
function _ZN4mlir6detail17OpToOpPassAdaptorC2EONS_13OpPassManagerE called 66680 returned 100% blocks executed 100%
    66680:  555:OpToOpPassAdaptor::OpToOpPassAdaptor(OpPassManager &&mgr) {
call    0 returned 100%
call    1 returned 100%
    66680:  556:  mgrs.emplace_back(std::move(mgr));
call    0 returned 100%
    66680:  557:}
        -:  558:
function _ZNK4mlir6detail17OpToOpPassAdaptor20getDependentDialectsERNS_15DialectRegistryE called 66680 returned 100% blocks executed 100%
    66680:  559:void OpToOpPassAdaptor::getDependentDialects(DialectRegistry &dialects) const {
   133360:  560:  for (auto &pm : mgrs)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
   133360:  561:    pm.getDependentDialects(dialects);
    66680:  562:}
        -:  563:
function _ZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ called 15391 returned 100% blocks executed 74%
    15391:  564:LogicalResult OpToOpPassAdaptor::tryMergeInto(MLIRContext *ctx,
        -:  565:                                              OpToOpPassAdaptor &rhs) {
        -:  566:  // Functor used to check if a pass manager is generic, i.e. op-agnostic.
    15391:  567:  auto isGenericPM = [&](OpPassManager &pm) { return !pm.getOpName(); };
        -:  568:
        -:  569:  // Functor used to detect if the given generic pass manager will have a
        -:  570:  // potential schedule conflict with the given `otherPMs`.
   15391*:  571:  auto hasScheduleConflictWith = [&](OpPassManager &genericPM,
        -:  572:                                     MutableArrayRef<OpPassManager> otherPMs) {
function _ZZZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ENKUlRNS_13OpPassManagerEN4llvm15MutableArrayRefIS5_EEE0_clES6_S9_ENKUlS6_E_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  573:    return llvm::any_of(otherPMs, [&](OpPassManager &pm) {
call    0 never executed
call    1 never executed
        -:  574:      // If this is a non-generic pass manager, a conflict will arise if a
        -:  575:      // non-generic pass manager's operation name can be scheduled on the
        -:  576:      // generic passmanager.
    #####:  577:      if (Optional<OperationName> pmOpName = pm.getOpName(*ctx))
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  578:        return genericPM.getImpl().canScheduleOn(*ctx, *pmOpName);
call    0 never executed
        -:  579:      // Otherwise, this is a generic pass manager. We current can't determine
        -:  580:      // when generic pass managers can be merged, so conservatively assume they
        -:  581:      // conflict.
    #####:  582:      return true;
        -:  583:    });
    15391:  584:  };
        -:  585:
        -:  586:  // Check that if either adaptor has a generic pass manager, that pm is
        -:  587:  // compatible within any non-generic pass managers.
        -:  588:  //
        -:  589:  // Check the current adaptor.
    15391:  590:  auto *lhsGenericPMIt = llvm::find_if(mgrs, isGenericPM);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   15391*:  591:  if (lhsGenericPMIt != mgrs.end() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  592:      hasScheduleConflictWith(*lhsGenericPMIt, rhs.mgrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  593:    return failure();
        -:  594:  // Check the rhs adaptor.
    15391:  595:  auto *rhsGenericPMIt = llvm::find_if(rhs.mgrs, isGenericPM);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
   15391*:  596:  if (rhsGenericPMIt != rhs.mgrs.end() &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  597:      hasScheduleConflictWith(*rhsGenericPMIt, mgrs))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  598:    return failure();
        -:  599:
    30782:  600:  for (auto &pm : mgrs) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  601:    // If an existing pass manager exists, then merge the given pass manager
        -:  602:    // into it.
    15391:  603:    if (auto *existingPM =
call    0 returned 100%
    30782:  604:            findPassManagerWithAnchor(rhs.mgrs, pm.getOpAnchorName())) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    12918:  605:      pm.getImpl().mergeInto(existingPM->getImpl());
call    0 returned 100%
        -:  606:    } else {
        -:  607:      // Otherwise, add the given pass manager to the list.
     2473:  608:      rhs.mgrs.emplace_back(std::move(pm));
call    0 returned 100%
        -:  609:    }
        -:  610:  }
    15391:  611:  mgrs.clear();
call    0 returned 100%
        -:  612:
        -:  613:  // After coalescing, sort the pass managers within rhs by name.
function _ZZN4mlir6detail17OpToOpPassAdaptor12tryMergeIntoEPNS_11MLIRContextERS1_ENKUlPKNS_13OpPassManagerES7_E1_clES7_S7_.isra.0 called 3541 returned 100% blocks executed 69%
    18932:  614:  auto compareFn = [](const OpPassManager *lhs, const OpPassManager *rhs) {
        -:  615:    // Order op-specific pass managers first and op-agnostic pass managers last.
     7082:  616:    if (Optional<StringRef> lhsName = lhs->getOpName()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     7082:  617:      if (Optional<StringRef> rhsName = rhs->getOpName())
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     3541:  618:        return lhsName->compare(*rhsName);
    #####:  619:      return -1; // lhs(op-specific) < rhs(op-agnostic)
        -:  620:    }
    #####:  621:    return 1; // lhs(op-agnostic) > rhs(op-specific)
        -:  622:  };
    15391:  623:  llvm::array_pod_sort(rhs.mgrs.begin(), rhs.mgrs.end(), compareFn);
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
    15391:  624:  return success();
        -:  625:}
        -:  626:
        -:  627:/// Returns the adaptor pass name.
function _ZN4mlir6detail17OpToOpPassAdaptor14getAdaptorNameB5cxx11Ev called 496 returned 100% blocks executed 92%
      496:  628:std::string OpToOpPassAdaptor::getAdaptorName() {
      496:  629:  std::string name = "Pipeline Collection : [";
call    0 returned 100%
      992:  630:  llvm::raw_string_ostream os(name);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
function _ZZN4mlir6detail17OpToOpPassAdaptor14getAdaptorNameB5cxx11EvENKUlRNS_13OpPassManagerEE_clES3_.isra.0 called 572 returned 100% blocks executed 80%
     1068:  631:  llvm::interleaveComma(getPassManagers(), os, [&](OpPassManager &pm) {
call    0 returned 100%
     1144:  632:    os << '\'' << pm.getOpAnchorName() << '\'';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
      572:  633:  });
      496:  634:  os << ']';
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      496:  635:  return os.str();
call    0 returned 100%
call    1 returned 100%
        -:  636:}
        -:  637:
function _ZN4mlir6detail17OpToOpPassAdaptor14runOnOperationEv called 0 returned 0% blocks executed 0%
    #####:  638:void OpToOpPassAdaptor::runOnOperation() {
    #####:  639:  llvm_unreachable(
        -:  640:      "Unexpected call to Pass::runOnOperation() on OpToOpPassAdaptor");
        -:  641:}
        -:  642:
        -:  643:/// Run the held pipeline over all nested operations.
function _ZN4mlir6detail17OpToOpPassAdaptor14runOnOperationEb called 43483 returned 100% blocks executed 100%
    43483:  644:void OpToOpPassAdaptor::runOnOperation(bool verifyPasses) {
    43483:  645:  if (getContext().isMultithreadingEnabled())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
    43011:  646:    runOnOperationAsyncImpl(verifyPasses);
call    0 returned 100%
        -:  647:  else
      472:  648:    runOnOperationImpl(verifyPasses);
call    0 returned 100%
    43483:  649:}
        -:  650:
        -:  651:/// Run this pass adaptor synchronously.
function _ZN4mlir6detail17OpToOpPassAdaptor18runOnOperationImplEb called 472 returned 100% blocks executed 73%
      472:  652:void OpToOpPassAdaptor::runOnOperationImpl(bool verifyPasses) {
      472:  653:  auto am = getAnalysisManager();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      472:  654:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
      472:  655:                                                        this};
      472:  656:  auto *instrumentor = am.getPassInstrumentor();
call    0 returned 100%
     1416:  657:  for (auto &region : getOperation()->getRegions()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
      944:  658:    for (auto &block : region) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    12756:  659:      for (auto &op : block) {
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
call    2 returned 100%
   12284*:  660:        auto *mgr = findPassManagerFor(mgrs, op.getName(), *op.getContext());
call    0 returned 100%
call    1 returned 100%
   12284*:  661:        if (!mgr)
branch  0 never executed
branch  1 never executed
    12284:  662:          continue;
        -:  663:
        -:  664:        // Run the held pipeline over the current operation.
    #####:  665:        unsigned initGeneration = mgr->impl->initializationGeneration;
call    0 never executed
    #####:  666:        if (failed(runPipeline(*mgr, &op, am.nest(&op), verifyPasses,
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  667:                               initGeneration, instrumentor, &parentInfo)))
    #####:  668:          return signalPassFailure();
call    0 never executed
        -:  669:      }
        -:  670:    }
        -:  671:  }
        -:  672:}
        -:  673:
        -:  674:/// Utility functor that checks if the two ranges of pass managers have a size
        -:  675:/// mismatch.
function _ZL15hasSizeMismatchN4llvm8ArrayRefIN4mlir13OpPassManagerEEES3_ called 0 returned 0% blocks executed 0%
    #####:  676:static bool hasSizeMismatch(ArrayRef<OpPassManager> lhs,
        -:  677:                            ArrayRef<OpPassManager> rhs) {
    #####:  678:  return lhs.size() != rhs.size() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  679:         llvm::any_of(llvm::seq<size_t>(0, lhs.size()),
call    0 never executed
call    1 never executed
function _ZZL15hasSizeMismatchN4llvm8ArrayRefIN4mlir13OpPassManagerEEES3_ENKUlmE_clEm.isra.0 called 0 returned 0% blocks executed 0%
    #####:  680:                      [&](size_t i) { return lhs[i].size() != rhs[i].size(); });
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  681:}
        -:  682:
        -:  683:/// Run this pass adaptor synchronously.
function _ZN4mlir6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEb called 43011 returned 100% blocks executed 86%
    43011:  684:void OpToOpPassAdaptor::runOnOperationAsyncImpl(bool verifyPasses) {
    43011:  685:  AnalysisManager am = getAnalysisManager();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    43011:  686:  MLIRContext *context = &getContext();
call    0 returned 100%
        -:  687:
        -:  688:  // Create the async executors if they haven't been created, or if the main
        -:  689:  // pipeline has changed.
   43011*:  690:  if (asyncExecutors.empty() || hasSizeMismatch(asyncExecutors.front(), mgrs))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 never executed
branch  4 never executed
    43011:  691:    asyncExecutors.assign(context->getThreadPool().getThreadCount(), mgrs);
call    0 returned 100%
call    1 returned 100%
        -:  692:
        -:  693:  // This struct represents the information for a single operation to be
        -:  694:  // scheduled on a pass manager.
    43011:  695:  struct OpPMInfo {
       3*:  696:    OpPMInfo(unsigned passManagerIdx, Operation *op, AnalysisManager am)
       3*:  697:        : passManagerIdx(passManagerIdx), op(op), am(am) {}
        -:  698:
        -:  699:    /// The index of the pass manager to schedule the operation on.
        -:  700:    unsigned passManagerIdx;
        -:  701:    /// The operation to schedule.
        -:  702:    Operation *op;
        -:  703:    /// The analysis manager for the operation.
        -:  704:    AnalysisManager am;
        -:  705:  };
        -:  706:
        -:  707:  // Run a prepass over the operation to collect the nested operations to
        -:  708:  // execute over. This ensures that an analysis manager exists for each
        -:  709:  // operation, as well as providing a queue of operations to execute over.
    43011:  710:  std::vector<OpPMInfo> opInfos;
call    0 returned 100%
    86022:  711:  DenseMap<OperationName, Optional<unsigned>> knownOpPMIdx;
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
   129033:  712:  for (auto &region : getOperation()->getRegions()) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 50% (fallthrough)
branch  5 taken 50%
  1164245:  713:    for (Operation &op : region.getOps()) {
call    0 returned 100%
branch  1 taken 96% (fallthrough)
branch  2 taken 4%
call    3 returned 100%
        -:  714:      // Get the pass manager index for this operation type.
  1121234:  715:      auto pmIdxIt = knownOpPMIdx.try_emplace(op.getName(), llvm::None);
call    0 returned 100%
  1121234:  716:      if (pmIdxIt.second) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
   172992:  717:        if (auto *mgr = findPassManagerFor(mgrs, op.getName(), *context))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        3:  718:          pmIdxIt.first->second = std::distance(mgrs.begin(), mgr);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  719:      }
        -:  720:
        -:  721:      // If this operation can be scheduled, add it to the list.
  1121234:  722:      if (pmIdxIt.first->second)
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        3:  723:        opInfos.emplace_back(*pmIdxIt.first->second, &op, am.nest(&op));
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -:  724:    }
        -:  725:  }
        -:  726:
        -:  727:  // Get the current thread for this adaptor.
    43011:  728:  PassInstrumentation::PipelineParentInfo parentInfo = {llvm::get_threadid(),
call    0 returned 100%
    43011:  729:                                                        this};
    43011:  730:  auto *instrumentor = am.getPassInstrumentor();
call    0 returned 100%
        -:  731:
        -:  732:  // An atomic failure variable for the async executors.
    86022:  733:  std::vector<std::atomic<bool>> activePMs(asyncExecutors.size());
call    0 returned 100%
call    1 returned 100%
    43011:  734:  std::fill(activePMs.begin(), activePMs.end(), false);
function _ZZN4mlir6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbENKUlRZNS1_23runOnOperationAsyncImplEbE8OpPMInfoE_clES3_ called 3 returned 100% blocks executed 71%
    43014:  735:  auto processFn = [&](OpPMInfo &opInfo) {
        -:  736:    // Find an executor for this operation.
        9:  737:    auto it = llvm::find_if(activePMs, [](std::atomic<bool> &isActive) {
        -:  738:      bool expectedInactive = false;
        -:  739:      return isActive.compare_exchange_strong(expectedInactive, true);
        3:  740:    });
call    0 returned 100%
        3:  741:    unsigned pmIndex = it - activePMs.begin();
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  742:
        -:  743:    // Get the pass manager for this operation and execute it.
        3:  744:    OpPassManager &pm = asyncExecutors[pmIndex][opInfo.passManagerIdx];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        3:  745:    LogicalResult pipelineResult = runPipeline(
        3:  746:        pm, opInfo.op, opInfo.am, verifyPasses,
call    0 returned 100%
        3:  747:        pm.impl->initializationGeneration, instrumentor, &parentInfo);
call    0 returned 100%
        -:  748:
        -:  749:    // Reset the active bit for this pass manager.
        3:  750:    activePMs[pmIndex].store(false);
        3:  751:    return pipelineResult;
    43011:  752:  };
        -:  753:
        -:  754:  // Signal a failure if any of the executors failed.
    43011:  755:  if (failed(failableParallelForEach(context, opInfos, processFn)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  756:    signalPassFailure();
call    0 never executed
    43011:  757:}
        -:  758:
        -:  759://===----------------------------------------------------------------------===//
        -:  760:// PassManager
        -:  761://===----------------------------------------------------------------------===//
        -:  762:
function _ZN4mlir11PassManagerC2EPNS_11MLIRContextENS_13OpPassManager7NestingEN4llvm9StringRefE called 99380 returned 100% blocks executed 100%
    99380:  763:PassManager::PassManager(MLIRContext *ctx, Nesting nesting,
    99380:  764:                         StringRef operationName)
        -:  765:    : OpPassManager(OperationName(operationName, ctx), nesting), context(ctx),
    99380:  766:      initializationKey(DenseMapInfo<llvm::hash_code>::getTombstoneKey()),
    99380:  767:      passTiming(false), verifyPasses(true) {}
call    0 returned 100%
call    1 returned 100%
        -:  768:
        -:  769:PassManager::~PassManager() = default;
        -:  770:
function _ZN4mlir11PassManager14enableVerifierEb called 98868 returned 100% blocks executed 100%
    98868:  771:void PassManager::enableVerifier(bool enabled) { verifyPasses = enabled; }
        -:  772:
        -:  773:/// Run the passes within this manager on the provided operation.
function _ZN4mlir11PassManager3runEPNS_9OperationE called 99380 returned 100% blocks executed 90%
    99380:  774:LogicalResult PassManager::run(Operation *op) {
    99380:  775:  MLIRContext *context = getContext();
call    0 returned 100%
   99380*:  776:  assert(op->getName() == getOpName(*context) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
        -:  777:         "operation has a different name than the PassManager or is from a "
        -:  778:         "different context");
        -:  779:
        -:  780:  // Register all dialects for the current pipeline.
    99380:  781:  DialectRegistry dependentDialects;
call    0 returned 100%
    99380:  782:  getDependentDialects(dependentDialects);
    99380:  783:  context->appendDialectRegistry(dependentDialects);
call    0 returned 100%
   359794:  784:  for (StringRef name : dependentDialects.getDialectNames())
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
   260414:  785:    context->getOrLoadDialect(name);
call    0 returned 100%
        -:  786:
        -:  787:  // Before running, make sure to finalize the pipeline pass list.
    99380:  788:  if (failed(getImpl().finalizePassList(context)))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
     5076:  789:    return failure();
        -:  790:
        -:  791:  // Initialize all of the passes within the pass manager with a new generation.
    94304:  792:  llvm::hash_code newInitKey = context->getRegistryHash();
call    0 returned 100%
    94304:  793:  if (newInitKey != initializationKey) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    94304:  794:    if (failed(initialize(context, impl->initializationGeneration + 1)))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  795:      return failure();
    94304:  796:    initializationKey = newInitKey;
        -:  797:  }
        -:  798:
        -:  799:  // Construct a top level analysis manager for the pipeline.
   193661:  800:  ModuleAnalysisManager am(op, instrumentor.get());
call    0 returned 100%
call    1 returned 100%
        -:  801:
        -:  802:  // Notify the context that we start running a pipeline for book keeping.
    94304:  803:  context->enterMultiThreadedExecution();
call    0 returned 100%
        -:  804:
        -:  805:  // If reproducer generation is enabled, run the pass manager with crash
        -:  806:  // handling enabled.
    94304:  807:  LogicalResult result =
  188608*:  808:      crashReproGenerator ? runWithCrashRecovery(op, am) : runPasses(op, am);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  809:
        -:  810:  // Notify the context that the run is done.
    94304:  811:  context->exitMultiThreadedExecution();
call    0 returned 100%
        -:  812:
        -:  813:  // Dump all of the pass statistics if necessary.
    94304:  814:  if (passStatisticsMode)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
      567:  815:    dumpStatistics();
call    0 returned 96%
    94281:  816:  return result;
call    0 returned 100%
        -:  817:}
        -:  818:
        -:  819:/// Add the provided instrumentation to the pass manager.
function _ZN4mlir11PassManager18addInstrumentationESt10unique_ptrINS_19PassInstrumentationESt14default_deleteIS2_EE called 2498 returned 100% blocks executed 70%
     2498:  820:void PassManager::addInstrumentation(std::unique_ptr<PassInstrumentation> pi) {
     2498:  821:  if (!instrumentor)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     4966:  822:    instrumentor = std::make_unique<PassInstrumentor>();
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
        -:  823:
     2498:  824:  instrumentor->addInstrumentation(std::move(pi));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     2498:  825:}
        -:  826:
function _ZN4mlir11PassManager9runPassesEPNS_9OperationENS_15AnalysisManagerE called 0 returned 0% blocks executed 0%
   94304*:  827:LogicalResult PassManager::runPasses(Operation *op, AnalysisManager am) {
   94304*:  828:  return OpToOpPassAdaptor::runPipeline(*this, op, am, verifyPasses,
   94304*:  829:                                        impl->initializationGeneration);
call    0 never executed
call    1 returned 100%
        -:  830:}
        -:  831:
        -:  832://===----------------------------------------------------------------------===//
        -:  833:// AnalysisManager
        -:  834://===----------------------------------------------------------------------===//
        -:  835:
        -:  836:/// Get an analysis manager for the given operation, which must be a proper
        -:  837:/// descendant of the current operation represented by this analysis manager.
function _ZN4mlir15AnalysisManager4nestEPNS_9OperationE called 20623 returned 100% blocks executed 33%
    20623:  838:AnalysisManager AnalysisManager::nest(Operation *op) {
    20623:  839:  Operation *currentOp = impl->getOperation();
call    0 returned 100%
   20623*:  840:  assert(currentOp->isProperAncestor(op) &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  841:         "expected valid descendant operation");
        -:  842:
        -:  843:  // Check for the base case where the provided operation is immediately nested.
    41246:  844:  if (currentOp == op->getParentOp())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    20623:  845:    return nestImmediate(op);
call    0 returned 100%
        -:  846:
        -:  847:  // Otherwise, we need to collect all ancestors up to the current operation.
    #####:  848:  SmallVector<Operation *, 4> opAncestors;
    #####:  849:  do {
    #####:  850:    opAncestors.push_back(op);
call    0 never executed
    #####:  851:    op = op->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:  852:  } while (op != currentOp);
branch  0 never executed
branch  1 never executed
        -:  853:
    #####:  854:  AnalysisManager result = *this;
    #####:  855:  for (Operation *op : llvm::reverse(opAncestors))
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  856:    result = result.nestImmediate(op);
call    0 never executed
    #####:  857:  return result;
branch  0 never executed
branch  1 never executed
        -:  858:}
        -:  859:
        -:  860:/// Get an analysis manager for the given immediately nested child operation.
function _ZN4mlir15AnalysisManager13nestImmediateEPNS_9OperationE called 20623 returned 100% blocks executed 88%
    20623:  861:AnalysisManager AnalysisManager::nestImmediate(Operation *op) {
   41246*:  862:  assert(impl->getOperation() == op->getParentOp() &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  863:         "expected immediate child operation");
        -:  864:
    20623:  865:  auto it = impl->childAnalyses.find(op);
call    0 returned 100%
    20623:  866:  if (it == impl->childAnalyses.end())
call    0 returned 100%
call    1 returned 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
    20626:  867:    it = impl->childAnalyses
    20626:  868:             .try_emplace(op, std::make_unique<NestedAnalysisMap>(op, impl))
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  869:             .first;
    20623:  870:  return {it->second.get()};
call    0 returned 100%
        -:  871:}
        -:  872:
        -:  873:/// Invalidate any non preserved analyses.
function _ZN4mlir6detail17NestedAnalysisMap10invalidateERKNS0_17PreservedAnalysesE called 153609 returned 100% blocks executed 77%
   153609:  874:void detail::NestedAnalysisMap::invalidate(
        -:  875:    const detail::PreservedAnalyses &pa) {
        -:  876:  // If all analyses were preserved, then there is nothing to do here.
   153609:  877:  if (pa.isAll())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   152076:  878:    return;
        -:  879:
        -:  880:  // Invalidate the analyses for the current operation directly.
   153599:  881:  analyses.invalidate(pa);
call    0 returned 100%
        -:  882:
        -:  883:  // If no analyses were preserved, then just simply clear out the child
        -:  884:  // analysis results.
   153599:  885:  if (pa.isNone()) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
   152066:  886:    childAnalyses.clear();
   152066:  887:    return;
call    0 returned 100%
        -:  888:  }
        -:  889:
        -:  890:  // Otherwise, invalidate each child analysis map.
     3066:  891:  SmallVector<NestedAnalysisMap *, 8> mapsToInvalidate(1, this);
call    0 returned 100%
     3066:  892:  while (!mapsToInvalidate.empty()) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1533:  893:    auto *map = mapsToInvalidate.pop_back_val();
call    0 returned 100%
    3066*:  894:    for (auto &analysisPair : map->childAnalyses) {
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
call    6 never executed
    #####:  895:      analysisPair.second->invalidate(pa);
call    0 never executed
    #####:  896:      if (!analysisPair.second->childAnalyses.empty())
branch  0 never executed
branch  1 never executed
    #####:  897:        mapsToInvalidate.push_back(analysisPair.second.get());
call    0 never executed
        -:  898:    }
        -:  899:  }
        -:  900:}
        -:  901:
        -:  902://===----------------------------------------------------------------------===//
        -:  903:// PassInstrumentation
        -:  904://===----------------------------------------------------------------------===//
        -:  905:
        -:  906:PassInstrumentation::~PassInstrumentation() = default;
        -:  907:
function _ZN4mlir19PassInstrumentation17runBeforePipelineEN4llvm8OptionalINS_13OperationNameEEERKNS0_18PipelineParentInfoE called 361 returned 100% blocks executed 100%
      361:  908:void PassInstrumentation::runBeforePipeline(
      361:  909:    Optional<OperationName> name, const PipelineParentInfo &parentInfo) {}
        -:  910:
function _ZN4mlir19PassInstrumentation16runAfterPipelineEN4llvm8OptionalINS_13OperationNameEEERKNS0_18PipelineParentInfoE called 361 returned 100% blocks executed 100%
      361:  911:void PassInstrumentation::runAfterPipeline(
      361:  912:    Optional<OperationName> name, const PipelineParentInfo &parentInfo) {}
        -:  913:
        -:  914://===----------------------------------------------------------------------===//
        -:  915:// PassInstrumentor
        -:  916://===----------------------------------------------------------------------===//
        -:  917:
        -:  918:namespace mlir {
        -:  919:namespace detail {
     2468:  920:struct PassInstrumentorImpl {
        -:  921:  /// Mutex to keep instrumentation access thread-safe.
        -:  922:  llvm::sys::SmartMutex<true> mutex;
        -:  923:
        -:  924:  /// Set of registered instrumentations.
        -:  925:  std::vector<std::unique_ptr<PassInstrumentation>> instrumentations;
        -:  926:};
        -:  927:} // namespace detail
        -:  928:} // namespace mlir
        -:  929:
function _ZN4mlir16PassInstrumentorC2Ev called 2468 returned 100% blocks executed 100%
     2468:  930:PassInstrumentor::PassInstrumentor() : impl(new PassInstrumentorImpl()) {}
call    0 returned 100%
        -:  931:PassInstrumentor::~PassInstrumentor() = default;
        -:  932:
        -:  933:/// See PassInstrumentation::runBeforePipeline for details.
function _ZN4mlir16PassInstrumentor17runBeforePipelineEN4llvm8OptionalINS_13OperationNameEEERKNS_19PassInstrumentation18PipelineParentInfoE called 509 returned 100% blocks executed 100%
      509:  934:void PassInstrumentor::runBeforePipeline(
        -:  935:    Optional<OperationName> name,
        -:  936:    const PassInstrumentation::PipelineParentInfo &parentInfo) {
      509:  937:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     1018:  938:  for (auto &instr : impl->instrumentations)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
      509:  939:    instr->runBeforePipeline(name, parentInfo);
call    0 returned 100%
      509:  940:}
        -:  941:
        -:  942:/// See PassInstrumentation::runAfterPipeline for details.
function _ZN4mlir16PassInstrumentor16runAfterPipelineEN4llvm8OptionalINS_13OperationNameEEERKNS_19PassInstrumentation18PipelineParentInfoE called 509 returned 100% blocks executed 100%
      509:  943:void PassInstrumentor::runAfterPipeline(
        -:  944:    Optional<OperationName> name,
        -:  945:    const PassInstrumentation::PipelineParentInfo &parentInfo) {
      509:  946:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     1018:  947:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
      509:  948:    instr->runAfterPipeline(name, parentInfo);
call    0 returned 100%
      509:  949:}
        -:  950:
        -:  951:/// See PassInstrumentation::runBeforePass for details.
function _ZN4mlir16PassInstrumentor13runBeforePassEPNS_4PassEPNS_9OperationE called 7411 returned 100% blocks executed 100%
     7411:  952:void PassInstrumentor::runBeforePass(Pass *pass, Operation *op) {
     7411:  953:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
    14980:  954:  for (auto &instr : impl->instrumentations)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
call    2 returned 100%
     7569:  955:    instr->runBeforePass(pass, op);
call    0 returned 100%
     7411:  956:}
        -:  957:
        -:  958:/// See PassInstrumentation::runAfterPass for details.
function _ZN4mlir16PassInstrumentor12runAfterPassEPNS_4PassEPNS_9OperationE called 7298 returned 100% blocks executed 100%
     7298:  959:void PassInstrumentor::runAfterPass(Pass *pass, Operation *op) {
     7298:  960:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
    14750:  961:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
     7452:  962:    instr->runAfterPass(pass, op);
call    0 returned 100%
     7298:  963:}
        -:  964:
        -:  965:/// See PassInstrumentation::runAfterPassFailed for details.
function _ZN4mlir16PassInstrumentor18runAfterPassFailedEPNS_4PassEPNS_9OperationE called 113 returned 100% blocks executed 100%
      113:  966:void PassInstrumentor::runAfterPassFailed(Pass *pass, Operation *op) {
      113:  967:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
      230:  968:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
      117:  969:    instr->runAfterPassFailed(pass, op);
call    0 returned 100%
      113:  970:}
        -:  971:
        -:  972:/// See PassInstrumentation::runBeforeAnalysis for details.
function _ZN4mlir16PassInstrumentor17runBeforeAnalysisEN4llvm9StringRefENS_6TypeIDEPNS_9OperationE called 341 returned 100% blocks executed 100%
      341:  973:void PassInstrumentor::runBeforeAnalysis(StringRef name, TypeID id,
        -:  974:                                         Operation *op) {
      341:  975:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
      689:  976:  for (auto &instr : impl->instrumentations)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
call    2 returned 100%
      348:  977:    instr->runBeforeAnalysis(name, id, op);
call    0 returned 100%
      341:  978:}
        -:  979:
        -:  980:/// See PassInstrumentation::runAfterAnalysis for details.
function _ZN4mlir16PassInstrumentor16runAfterAnalysisEN4llvm9StringRefENS_6TypeIDEPNS_9OperationE called 341 returned 100% blocks executed 100%
      341:  981:void PassInstrumentor::runAfterAnalysis(StringRef name, TypeID id,
        -:  982:                                        Operation *op) {
      341:  983:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
      689:  984:  for (auto &instr : llvm::reverse(impl->instrumentations))
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
      348:  985:    instr->runAfterAnalysis(name, id, op);
call    0 returned 100%
      341:  986:}
        -:  987:
        -:  988:/// Add the given instrumentation to the collection.
function _ZN4mlir16PassInstrumentor18addInstrumentationESt10unique_ptrINS_19PassInstrumentationESt14default_deleteIS2_EE called 2498 returned 100% blocks executed 100%
     2498:  989:void PassInstrumentor::addInstrumentation(
        -:  990:    std::unique_ptr<PassInstrumentation> pi) {
     2498:  991:  llvm::sys::SmartScopedLock<true> instrumentationLock(impl->mutex);
call    0 returned 100%
     2498:  992:  impl->instrumentations.emplace_back(std::move(pi));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     2498:  993:}
