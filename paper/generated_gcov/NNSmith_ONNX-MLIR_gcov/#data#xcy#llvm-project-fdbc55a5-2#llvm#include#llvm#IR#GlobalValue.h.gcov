        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/llvm/include/llvm/IR/GlobalValue.h
        -:    0:Graph:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Target/LLVMIR/Dialect/LLVMIR/CMakeFiles/obj.MLIRLLVMToLLVMIRTranslation.dir/LLVMToLLVMIRTranslation.cpp.gcda
        -:    0:Runs:128646
        -:    1://===-- llvm/GlobalValue.h - Class to represent a global value --*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file is a common base class of all globally definable objects.  As such,
        -:   10:// it is subclassed by GlobalVariable, GlobalAlias and by Function.  This is
        -:   11:// used because you can do certain things with these global objects that you
        -:   12:// can't do to anything else.  For example, use the address of one as a
        -:   13:// constant.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_IR_GLOBALVALUE_H
        -:   18:#define LLVM_IR_GLOBALVALUE_H
        -:   19:
        -:   20:#include "llvm/ADT/StringRef.h"
        -:   21:#include "llvm/ADT/Twine.h"
        -:   22:#include "llvm/IR/Constant.h"
        -:   23:#include "llvm/IR/DerivedTypes.h"
        -:   24:#include "llvm/IR/Value.h"
        -:   25:#include "llvm/Support/Casting.h"
        -:   26:#include "llvm/Support/ErrorHandling.h"
        -:   27:#include "llvm/Support/MD5.h"
        -:   28:#include <cassert>
        -:   29:#include <cstdint>
        -:   30:#include <string>
        -:   31:
        -:   32:namespace llvm {
        -:   33:
        -:   34:class Comdat;
        -:   35:class ConstantRange;
        -:   36:class Error;
        -:   37:class GlobalObject;
        -:   38:class Module;
        -:   39:
        -:   40:namespace Intrinsic {
        -:   41:typedef unsigned ID;
        -:   42:} // end namespace Intrinsic
        -:   43:
        -:   44:class GlobalValue : public Constant {
        -:   45:public:
        -:   46:  /// An enumeration for the kinds of linkage for global values.
        -:   47:  enum LinkageTypes {
        -:   48:    ExternalLinkage = 0,///< Externally visible function
        -:   49:    AvailableExternallyLinkage, ///< Available for inspection, not emission.
        -:   50:    LinkOnceAnyLinkage, ///< Keep one copy of function when linking (inline)
        -:   51:    LinkOnceODRLinkage, ///< Same, but only replaced by something equivalent.
        -:   52:    WeakAnyLinkage,     ///< Keep one copy of named function when linking (weak)
        -:   53:    WeakODRLinkage,     ///< Same, but only replaced by something equivalent.
        -:   54:    AppendingLinkage,   ///< Special purpose, only applies to global arrays
        -:   55:    InternalLinkage,    ///< Rename collisions when linking (static functions).
        -:   56:    PrivateLinkage,     ///< Like Internal, but omit from symbol table.
        -:   57:    ExternalWeakLinkage,///< ExternalWeak linkage description.
        -:   58:    CommonLinkage       ///< Tentative definitions.
        -:   59:  };
        -:   60:
        -:   61:  /// An enumeration for the kinds of visibility of global values.
        -:   62:  enum VisibilityTypes {
        -:   63:    DefaultVisibility = 0,  ///< The GV is visible
        -:   64:    HiddenVisibility,       ///< The GV is hidden
        -:   65:    ProtectedVisibility     ///< The GV is protected
        -:   66:  };
        -:   67:
        -:   68:  /// Storage classes of global values for PE targets.
        -:   69:  enum DLLStorageClassTypes {
        -:   70:    DefaultStorageClass   = 0,
        -:   71:    DLLImportStorageClass = 1, ///< Function to be imported from DLL
        -:   72:    DLLExportStorageClass = 2  ///< Function to be accessible from DLL.
        -:   73:  };
        -:   74:
        -:   75:protected:
        -:   76:  GlobalValue(Type *Ty, ValueTy VTy, Use *Ops, unsigned NumOps,
        -:   77:              LinkageTypes Linkage, const Twine &Name, unsigned AddressSpace)
        -:   78:      : Constant(PointerType::get(Ty, AddressSpace), VTy, Ops, NumOps),
        -:   79:        ValueType(Ty), Visibility(DefaultVisibility),
        -:   80:        UnnamedAddrVal(unsigned(UnnamedAddr::None)),
        -:   81:        DllStorageClass(DefaultStorageClass), ThreadLocal(NotThreadLocal),
        -:   82:        HasLLVMReservedName(false), IsDSOLocal(false), HasPartition(false),
        -:   83:        HasSanitizerMetadata(false) {
        -:   84:    setLinkage(Linkage);
        -:   85:    setName(Name);
        -:   86:  }
        -:   87:
        -:   88:  Type *ValueType;
        -:   89:
        -:   90:  static const unsigned GlobalValueSubClassDataBits = 15;
        -:   91:
        -:   92:  // All bitfields use unsigned as the underlying type so that MSVC will pack
        -:   93:  // them.
        -:   94:  unsigned Linkage : 4;       // The linkage of this global
        -:   95:  unsigned Visibility : 2;    // The visibility style of this global
        -:   96:  unsigned UnnamedAddrVal : 2; // This value's address is not significant
        -:   97:  unsigned DllStorageClass : 2; // DLL storage class
        -:   98:
        -:   99:  unsigned ThreadLocal : 3; // Is this symbol "Thread Local", if so, what is
        -:  100:                            // the desired model?
        -:  101:
        -:  102:  /// True if the function's name starts with "llvm.".  This corresponds to the
        -:  103:  /// value of Function::isIntrinsic(), which may be true even if
        -:  104:  /// Function::intrinsicID() returns Intrinsic::not_intrinsic.
        -:  105:  unsigned HasLLVMReservedName : 1;
        -:  106:
        -:  107:  /// If true then there is a definition within the same linkage unit and that
        -:  108:  /// definition cannot be runtime preempted.
        -:  109:  unsigned IsDSOLocal : 1;
        -:  110:
        -:  111:  /// True if this symbol has a partition name assigned (see
        -:  112:  /// https://lld.llvm.org/Partitions.html).
        -:  113:  unsigned HasPartition : 1;
        -:  114:
        -:  115:  /// True if this symbol has sanitizer metadata available. Should only happen
        -:  116:  /// if sanitizers were enabled when building the translation unit which
        -:  117:  /// contains this GV.
        -:  118:  unsigned HasSanitizerMetadata : 1;
        -:  119:
        -:  120:private:
        -:  121:  // Give subclasses access to what otherwise would be wasted padding.
        -:  122:  // (15 + 4 + 2 + 2 + 2 + 3 + 1 + 1 + 1 + 1) == 32.
        -:  123:  unsigned SubClassData : GlobalValueSubClassDataBits;
        -:  124:
        -:  125:  friend class Constant;
        -:  126:
        -:  127:  void destroyConstantImpl();
        -:  128:  Value *handleOperandChangeImpl(Value *From, Value *To);
        -:  129:
        -:  130:  /// Returns true if the definition of this global may be replaced by a
        -:  131:  /// differently optimized variant of the same source level function at link
        -:  132:  /// time.
        -:  133:  bool mayBeDerefined() const {
        -:  134:    switch (getLinkage()) {
        -:  135:    case WeakODRLinkage:
        -:  136:    case LinkOnceODRLinkage:
        -:  137:    case AvailableExternallyLinkage:
        -:  138:      return true;
        -:  139:
        -:  140:    case WeakAnyLinkage:
        -:  141:    case LinkOnceAnyLinkage:
        -:  142:    case CommonLinkage:
        -:  143:    case ExternalWeakLinkage:
        -:  144:    case ExternalLinkage:
        -:  145:    case AppendingLinkage:
        -:  146:    case InternalLinkage:
        -:  147:    case PrivateLinkage:
        -:  148:      // Optimizations may assume builtin semantics for functions defined as
        -:  149:      // nobuiltin due to attributes at call-sites. To avoid applying IPO based
        -:  150:      // on nobuiltin semantics, treat such function definitions as maybe
        -:  151:      // derefined.
        -:  152:      return isInterposable() || isNobuiltinFnDef();
        -:  153:    }
        -:  154:
        -:  155:    llvm_unreachable("Fully covered switch above!");
        -:  156:  }
        -:  157:
        -:  158:  /// Returns true if the global is a function definition with the nobuiltin
        -:  159:  /// attribute.
        -:  160:  bool isNobuiltinFnDef() const;
        -:  161:
        -:  162:protected:
        -:  163:  /// The intrinsic ID for this subclass (which must be a Function).
        -:  164:  ///
        -:  165:  /// This member is defined by this class, but not used for anything.
        -:  166:  /// Subclasses can use it to store their intrinsic ID, if they have one.
        -:  167:  ///
        -:  168:  /// This is stored here to save space in Function on 64-bit hosts.
        -:  169:  Intrinsic::ID IntID = (Intrinsic::ID)0U;
        -:  170:
        -:  171:  unsigned getGlobalValueSubClassData() const {
        -:  172:    return SubClassData;
        -:  173:  }
        -:  174:  void setGlobalValueSubClassData(unsigned V) {
        -:  175:    assert(V < (1 << GlobalValueSubClassDataBits) && "It will not fit");
        -:  176:    SubClassData = V;
        -:  177:  }
        -:  178:
        -:  179:  Module *Parent = nullptr; // The containing module.
        -:  180:
        -:  181:  // Used by SymbolTableListTraits.
        -:  182:  void setParent(Module *parent) {
        -:  183:    Parent = parent;
        -:  184:  }
        -:  185:
        -:  186:  ~GlobalValue() {
        -:  187:    removeDeadConstantUsers();   // remove any dead constants using this.
        -:  188:  }
        -:  189:
        -:  190:public:
        -:  191:  enum ThreadLocalMode {
        -:  192:    NotThreadLocal = 0,
        -:  193:    GeneralDynamicTLSModel,
        -:  194:    LocalDynamicTLSModel,
        -:  195:    InitialExecTLSModel,
        -:  196:    LocalExecTLSModel
        -:  197:  };
        -:  198:
        -:  199:  GlobalValue(const GlobalValue &) = delete;
        -:  200:
        -:  201:  unsigned getAddressSpace() const;
        -:  202:
        -:  203:  enum class UnnamedAddr {
        -:  204:    None,
        -:  205:    Local,
        -:  206:    Global,
        -:  207:  };
        -:  208:
        -:  209:  bool hasGlobalUnnamedAddr() const {
        -:  210:    return getUnnamedAddr() == UnnamedAddr::Global;
        -:  211:  }
        -:  212:
        -:  213:  /// Returns true if this value's address is not significant in this module.
        -:  214:  /// This attribute is intended to be used only by the code generator and LTO
        -:  215:  /// to allow the linker to decide whether the global needs to be in the symbol
        -:  216:  /// table. It should probably not be used in optimizations, as the value may
        -:  217:  /// have uses outside the module; use hasGlobalUnnamedAddr() instead.
        -:  218:  bool hasAtLeastLocalUnnamedAddr() const {
        -:  219:    return getUnnamedAddr() != UnnamedAddr::None;
        -:  220:  }
        -:  221:
        -:  222:  UnnamedAddr getUnnamedAddr() const {
        -:  223:    return UnnamedAddr(UnnamedAddrVal);
        -:  224:  }
        -:  225:  void setUnnamedAddr(UnnamedAddr Val) { UnnamedAddrVal = unsigned(Val); }
        -:  226:
        -:  227:  static UnnamedAddr getMinUnnamedAddr(UnnamedAddr A, UnnamedAddr B) {
        -:  228:    if (A == UnnamedAddr::None || B == UnnamedAddr::None)
        -:  229:      return UnnamedAddr::None;
        -:  230:    if (A == UnnamedAddr::Local || B == UnnamedAddr::Local)
        -:  231:      return UnnamedAddr::Local;
        -:  232:    return UnnamedAddr::Global;
        -:  233:  }
        -:  234:
        -:  235:  bool hasComdat() const { return getComdat() != nullptr; }
        -:  236:  const Comdat *getComdat() const;
        -:  237:  Comdat *getComdat() {
        -:  238:    return const_cast<Comdat *>(
        -:  239:                           static_cast<const GlobalValue *>(this)->getComdat());
        -:  240:  }
        -:  241:
        -:  242:  VisibilityTypes getVisibility() const { return VisibilityTypes(Visibility); }
        -:  243:  bool hasDefaultVisibility() const { return Visibility == DefaultVisibility; }
        -:  244:  bool hasHiddenVisibility() const { return Visibility == HiddenVisibility; }
        -:  245:  bool hasProtectedVisibility() const {
        -:  246:    return Visibility == ProtectedVisibility;
        -:  247:  }
        -:  248:  void setVisibility(VisibilityTypes V) {
        -:  249:    assert((!hasLocalLinkage() || V == DefaultVisibility) &&
        -:  250:           "local linkage requires default visibility");
        -:  251:    Visibility = V;
        -:  252:    if (isImplicitDSOLocal())
        -:  253:      setDSOLocal(true);
        -:  254:  }
        -:  255:
        -:  256:  /// If the value is "Thread Local", its value isn't shared by the threads.
        -:  257:  bool isThreadLocal() const { return getThreadLocalMode() != NotThreadLocal; }
        -:  258:  void setThreadLocal(bool Val) {
        -:  259:    setThreadLocalMode(Val ? GeneralDynamicTLSModel : NotThreadLocal);
        -:  260:  }
        -:  261:  void setThreadLocalMode(ThreadLocalMode Val) {
        -:  262:    assert(Val == NotThreadLocal || getValueID() != Value::FunctionVal);
        -:  263:    ThreadLocal = Val;
        -:  264:  }
        -:  265:  ThreadLocalMode getThreadLocalMode() const {
        -:  266:    return static_cast<ThreadLocalMode>(ThreadLocal);
        -:  267:  }
        -:  268:
        -:  269:  DLLStorageClassTypes getDLLStorageClass() const {
        -:  270:    return DLLStorageClassTypes(DllStorageClass);
        -:  271:  }
        -:  272:  bool hasDLLImportStorageClass() const {
        -:  273:    return DllStorageClass == DLLImportStorageClass;
        -:  274:  }
        -:  275:  bool hasDLLExportStorageClass() const {
        -:  276:    return DllStorageClass == DLLExportStorageClass;
        -:  277:  }
        -:  278:  void setDLLStorageClass(DLLStorageClassTypes C) {
        -:  279:    assert((!hasLocalLinkage() || C == DefaultStorageClass) &&
        -:  280:           "local linkage requires DefaultStorageClass");
        -:  281:    DllStorageClass = C;
        -:  282:  }
        -:  283:
        -:  284:  bool hasSection() const { return !getSection().empty(); }
        -:  285:  StringRef getSection() const;
        -:  286:
        -:  287:  /// Global values are always pointers.
        -:  288:  PointerType *getType() const { return cast<PointerType>(User::getType()); }
        -:  289:
    #####:  290:  Type *getValueType() const { return ValueType; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
call   10 never executed
call   11 never executed
call   12 never executed
call   13 never executed
call   14 never executed
call   15 never executed
call   16 never executed
call   17 never executed
call   18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
call   22 never executed
call   23 never executed
call   24 never executed
call   25 never executed
call   26 never executed
call   27 never executed
call   28 never executed
call   29 never executed
call   30 never executed
call   31 never executed
call   32 never executed
call   33 never executed
call   34 never executed
call   35 never executed
call   36 never executed
call   37 never executed
call   38 never executed
call   39 never executed
call   40 never executed
call   41 never executed
call   42 never executed
call   43 never executed
call   44 never executed
call   45 never executed
call   46 never executed
call   47 never executed
call   48 never executed
call   49 never executed
call   50 never executed
call   51 never executed
call   52 never executed
call   53 never executed
call   54 never executed
call   55 never executed
call   56 never executed
call   57 never executed
call   58 never executed
call   59 never executed
call   60 never executed
call   61 never executed
call   62 never executed
call   63 never executed
call   64 never executed
call   65 never executed
call   66 never executed
call   67 never executed
call   68 never executed
call   69 never executed
call   70 never executed
call   71 never executed
call   72 never executed
call   73 never executed
call   74 never executed
call   75 never executed
call   76 never executed
call   77 never executed
call   78 never executed
call   79 never executed
call   80 never executed
call   81 never executed
call   82 never executed
call   83 never executed
call   84 never executed
call   85 never executed
call   86 never executed
call   87 never executed
call   88 never executed
call   89 never executed
call   90 never executed
call   91 never executed
call   92 never executed
call   93 never executed
call   94 never executed
call   95 never executed
call   96 never executed
call   97 never executed
call   98 never executed
call   99 never executed
call   100 never executed
call   101 never executed
call   102 never executed
call   103 never executed
call   104 never executed
call   105 never executed
call   106 never executed
call   107 never executed
call   108 never executed
call   109 never executed
call   110 never executed
call   111 never executed
call   112 never executed
call   113 never executed
call   114 never executed
call   115 never executed
call   116 never executed
call   117 never executed
call   118 never executed
call   119 never executed
call   120 never executed
call   121 never executed
call   122 never executed
call   123 never executed
call   124 never executed
call   125 never executed
call   126 never executed
call   127 never executed
call   128 never executed
call   129 never executed
call   130 never executed
call   131 never executed
call   132 never executed
call   133 never executed
call   134 never executed
call   135 never executed
call   136 never executed
call   137 never executed
call   138 never executed
        -:  291:
        -:  292:  bool isImplicitDSOLocal() const {
        -:  293:    return hasLocalLinkage() ||
        -:  294:           (!hasDefaultVisibility() && !hasExternalWeakLinkage());
        -:  295:  }
        -:  296:
        -:  297:  void setDSOLocal(bool Local) { IsDSOLocal = Local; }
        -:  298:
        -:  299:  bool isDSOLocal() const {
        -:  300:    return IsDSOLocal;
        -:  301:  }
        -:  302:
        -:  303:  bool hasPartition() const {
        -:  304:    return HasPartition;
        -:  305:  }
        -:  306:  StringRef getPartition() const;
        -:  307:  void setPartition(StringRef Part);
        -:  308:
        -:  309:  // ASan, HWASan and Memtag sanitizers have some instrumentation that applies
        -:  310:  // specifically to global variables.
        -:  311:  struct SanitizerMetadata {
        -:  312:    SanitizerMetadata()
        -:  313:        : NoAddress(false), NoHWAddress(false),
        -:  314:          Memtag(false), IsDynInit(false) {}
        -:  315:    // For ASan and HWASan, this instrumentation is implicitly applied to all
        -:  316:    // global variables when built with -fsanitize=*. What we need is a way to
        -:  317:    // persist the information that a certain global variable should *not* have
        -:  318:    // sanitizers applied, which occurs if:
        -:  319:    //   1. The global variable is in the sanitizer ignore list, or
        -:  320:    //   2. The global variable is created by the sanitizers itself for internal
        -:  321:    //      usage, or
        -:  322:    //   3. The global variable has __attribute__((no_sanitize("..."))) or
        -:  323:    //      __attribute__((disable_sanitizer_instrumentation)).
        -:  324:    //
        -:  325:    // This is important, a some IR passes like GlobalMerge can delete global
        -:  326:    // variables and replace them with new ones. If the old variables were
        -:  327:    // marked to be unsanitized, then the new ones should also be.
        -:  328:    unsigned NoAddress : 1;
        -:  329:    unsigned NoHWAddress : 1;
        -:  330:
        -:  331:    // Memtag sanitization works differently: sanitization is requested by clang
        -:  332:    // when `-fsanitize=memtag-globals` is provided, and the request can be
        -:  333:    // denied (and the attribute removed) by the AArch64 global tagging pass if
        -:  334:    // it can't be fulfilled (e.g. the global variable is a TLS variable).
        -:  335:    // Memtag sanitization has to interact with other parts of LLVM (like
        -:  336:    // supressing certain optimisations, emitting assembly directives, or
        -:  337:    // creating special relocation sections).
        -:  338:    //
        -:  339:    // Use `GlobalValue::isTagged()` to check whether tagging should be enabled
        -:  340:    // for a global variable.
        -:  341:    unsigned Memtag : 1;
        -:  342:
        -:  343:    // ASan-specific metadata. Is this global variable dynamically initialized
        -:  344:    // (from a C++ language perspective), and should therefore be checked for
        -:  345:    // ODR violations.
        -:  346:    unsigned IsDynInit : 1;
        -:  347:  };
        -:  348:
        -:  349:  bool hasSanitizerMetadata() const { return HasSanitizerMetadata; }
        -:  350:  const SanitizerMetadata &getSanitizerMetadata() const;
        -:  351:  // Note: Not byref as it's a POD and otherwise it's too easy to call
        -:  352:  // G.setSanitizerMetadata(G2.getSanitizerMetadata()), and the argument becomes
        -:  353:  // dangling when the backing storage allocates the metadata for `G`, as the
        -:  354:  // storage is shared between `G1` and `G2`.
        -:  355:  void setSanitizerMetadata(SanitizerMetadata Meta);
        -:  356:  void removeSanitizerMetadata();
        -:  357:
        -:  358:  bool isTagged() const {
        -:  359:    return hasSanitizerMetadata() && getSanitizerMetadata().Memtag;
        -:  360:  }
        -:  361:
        -:  362:  static LinkageTypes getLinkOnceLinkage(bool ODR) {
        -:  363:    return ODR ? LinkOnceODRLinkage : LinkOnceAnyLinkage;
        -:  364:  }
        -:  365:  static LinkageTypes getWeakLinkage(bool ODR) {
        -:  366:    return ODR ? WeakODRLinkage : WeakAnyLinkage;
        -:  367:  }
        -:  368:
        -:  369:  static bool isExternalLinkage(LinkageTypes Linkage) {
        -:  370:    return Linkage == ExternalLinkage;
        -:  371:  }
        -:  372:  static bool isAvailableExternallyLinkage(LinkageTypes Linkage) {
        -:  373:    return Linkage == AvailableExternallyLinkage;
        -:  374:  }
        -:  375:  static bool isLinkOnceAnyLinkage(LinkageTypes Linkage) {
        -:  376:    return Linkage == LinkOnceAnyLinkage;
        -:  377:  }
        -:  378:  static bool isLinkOnceODRLinkage(LinkageTypes Linkage) {
        -:  379:    return Linkage == LinkOnceODRLinkage;
        -:  380:  }
        -:  381:  static bool isLinkOnceLinkage(LinkageTypes Linkage) {
        -:  382:    return isLinkOnceAnyLinkage(Linkage) || isLinkOnceODRLinkage(Linkage);
        -:  383:  }
        -:  384:  static bool isWeakAnyLinkage(LinkageTypes Linkage) {
        -:  385:    return Linkage == WeakAnyLinkage;
        -:  386:  }
        -:  387:  static bool isWeakODRLinkage(LinkageTypes Linkage) {
        -:  388:    return Linkage == WeakODRLinkage;
        -:  389:  }
        -:  390:  static bool isWeakLinkage(LinkageTypes Linkage) {
        -:  391:    return isWeakAnyLinkage(Linkage) || isWeakODRLinkage(Linkage);
        -:  392:  }
        -:  393:  static bool isAppendingLinkage(LinkageTypes Linkage) {
        -:  394:    return Linkage == AppendingLinkage;
        -:  395:  }
        -:  396:  static bool isInternalLinkage(LinkageTypes Linkage) {
        -:  397:    return Linkage == InternalLinkage;
        -:  398:  }
        -:  399:  static bool isPrivateLinkage(LinkageTypes Linkage) {
        -:  400:    return Linkage == PrivateLinkage;
        -:  401:  }
        -:  402:  static bool isLocalLinkage(LinkageTypes Linkage) {
        -:  403:    return isInternalLinkage(Linkage) || isPrivateLinkage(Linkage);
        -:  404:  }
        -:  405:  static bool isExternalWeakLinkage(LinkageTypes Linkage) {
        -:  406:    return Linkage == ExternalWeakLinkage;
        -:  407:  }
        -:  408:  static bool isCommonLinkage(LinkageTypes Linkage) {
        -:  409:    return Linkage == CommonLinkage;
        -:  410:  }
        -:  411:  static bool isValidDeclarationLinkage(LinkageTypes Linkage) {
        -:  412:    return isExternalWeakLinkage(Linkage) || isExternalLinkage(Linkage);
        -:  413:  }
        -:  414:
        -:  415:  /// Whether the definition of this global may be replaced by something
        -:  416:  /// non-equivalent at link time. For example, if a function has weak linkage
        -:  417:  /// then the code defining it may be replaced by different code.
        -:  418:  static bool isInterposableLinkage(LinkageTypes Linkage) {
        -:  419:    switch (Linkage) {
        -:  420:    case WeakAnyLinkage:
        -:  421:    case LinkOnceAnyLinkage:
        -:  422:    case CommonLinkage:
        -:  423:    case ExternalWeakLinkage:
        -:  424:      return true;
        -:  425:
        -:  426:    case AvailableExternallyLinkage:
        -:  427:    case LinkOnceODRLinkage:
        -:  428:    case WeakODRLinkage:
        -:  429:    // The above three cannot be overridden but can be de-refined.
        -:  430:
        -:  431:    case ExternalLinkage:
        -:  432:    case AppendingLinkage:
        -:  433:    case InternalLinkage:
        -:  434:    case PrivateLinkage:
        -:  435:      return false;
        -:  436:    }
        -:  437:    llvm_unreachable("Fully covered switch above!");
        -:  438:  }
        -:  439:
        -:  440:  /// Whether the definition of this global may be discarded if it is not used
        -:  441:  /// in its compilation unit.
        -:  442:  static bool isDiscardableIfUnused(LinkageTypes Linkage) {
        -:  443:    return isLinkOnceLinkage(Linkage) || isLocalLinkage(Linkage) ||
        -:  444:           isAvailableExternallyLinkage(Linkage);
        -:  445:  }
        -:  446:
        -:  447:  /// Whether the definition of this global may be replaced at link time.  NB:
        -:  448:  /// Using this method outside of the code generators is almost always a
        -:  449:  /// mistake: when working at the IR level use isInterposable instead as it
        -:  450:  /// knows about ODR semantics.
        -:  451:  static bool isWeakForLinker(LinkageTypes Linkage)  {
        -:  452:    return Linkage == WeakAnyLinkage || Linkage == WeakODRLinkage ||
        -:  453:           Linkage == LinkOnceAnyLinkage || Linkage == LinkOnceODRLinkage ||
        -:  454:           Linkage == CommonLinkage || Linkage == ExternalWeakLinkage;
        -:  455:  }
        -:  456:
        -:  457:  /// Return true if the currently visible definition of this global (if any) is
        -:  458:  /// exactly the definition we will see at runtime.
        -:  459:  ///
        -:  460:  /// Non-exact linkage types inhibits most non-inlining IPO, since a
        -:  461:  /// differently optimized variant of the same function can have different
        -:  462:  /// observable or undefined behavior than in the variant currently visible.
        -:  463:  /// For instance, we could have started with
        -:  464:  ///
        -:  465:  ///   void foo(int *v) {
        -:  466:  ///     int t = 5 / v[0];
        -:  467:  ///     (void) t;
        -:  468:  ///   }
        -:  469:  ///
        -:  470:  /// and "refined" it to
        -:  471:  ///
        -:  472:  ///   void foo(int *v) { }
        -:  473:  ///
        -:  474:  /// However, we cannot infer readnone for `foo`, since that would justify
        -:  475:  /// DSE'ing a store to `v[0]` across a call to `foo`, which can cause
        -:  476:  /// undefined behavior if the linker replaces the actual call destination with
        -:  477:  /// the unoptimized `foo`.
        -:  478:  ///
        -:  479:  /// Inlining is okay across non-exact linkage types as long as they're not
        -:  480:  /// interposable (see \c isInterposable), since in such cases the currently
        -:  481:  /// visible variant is *a* correct implementation of the original source
        -:  482:  /// function; it just isn't the *only* correct implementation.
        -:  483:  bool isDefinitionExact() const {
        -:  484:    return !mayBeDerefined();
        -:  485:  }
        -:  486:
        -:  487:  /// Return true if this global has an exact defintion.
        -:  488:  bool hasExactDefinition() const {
        -:  489:    // While this computes exactly the same thing as
        -:  490:    // isStrongDefinitionForLinker, the intended uses are different.  This
        -:  491:    // function is intended to help decide if specific inter-procedural
        -:  492:    // transforms are correct, while isStrongDefinitionForLinker's intended use
        -:  493:    // is in low level code generation.
        -:  494:    return !isDeclaration() && isDefinitionExact();
        -:  495:  }
        -:  496:
        -:  497:  /// Return true if this global's definition can be substituted with an
        -:  498:  /// *arbitrary* definition at link time or load time. We cannot do any IPO or
        -:  499:  /// inlining across interposable call edges, since the callee can be
        -:  500:  /// replaced with something arbitrary.
        -:  501:  bool isInterposable() const;
        -:  502:  bool canBenefitFromLocalAlias() const;
        -:  503:
        -:  504:  bool hasExternalLinkage() const { return isExternalLinkage(getLinkage()); }
        -:  505:  bool hasAvailableExternallyLinkage() const {
        -:  506:    return isAvailableExternallyLinkage(getLinkage());
        -:  507:  }
        -:  508:  bool hasLinkOnceLinkage() const { return isLinkOnceLinkage(getLinkage()); }
        -:  509:  bool hasLinkOnceAnyLinkage() const {
        -:  510:    return isLinkOnceAnyLinkage(getLinkage());
        -:  511:  }
        -:  512:  bool hasLinkOnceODRLinkage() const {
        -:  513:    return isLinkOnceODRLinkage(getLinkage());
        -:  514:  }
        -:  515:  bool hasWeakLinkage() const { return isWeakLinkage(getLinkage()); }
        -:  516:  bool hasWeakAnyLinkage() const { return isWeakAnyLinkage(getLinkage()); }
        -:  517:  bool hasWeakODRLinkage() const { return isWeakODRLinkage(getLinkage()); }
        -:  518:  bool hasAppendingLinkage() const { return isAppendingLinkage(getLinkage()); }
        -:  519:  bool hasInternalLinkage() const { return isInternalLinkage(getLinkage()); }
        -:  520:  bool hasPrivateLinkage() const { return isPrivateLinkage(getLinkage()); }
        -:  521:  bool hasLocalLinkage() const { return isLocalLinkage(getLinkage()); }
        -:  522:  bool hasExternalWeakLinkage() const {
        -:  523:    return isExternalWeakLinkage(getLinkage());
        -:  524:  }
        -:  525:  bool hasCommonLinkage() const { return isCommonLinkage(getLinkage()); }
        -:  526:  bool hasValidDeclarationLinkage() const {
        -:  527:    return isValidDeclarationLinkage(getLinkage());
        -:  528:  }
        -:  529:
        -:  530:  void setLinkage(LinkageTypes LT) {
        -:  531:    if (isLocalLinkage(LT)) {
        -:  532:      Visibility = DefaultVisibility;
        -:  533:      DllStorageClass = DefaultStorageClass;
        -:  534:    }
        -:  535:    Linkage = LT;
        -:  536:    if (isImplicitDSOLocal())
        -:  537:      setDSOLocal(true);
        -:  538:  }
        -:  539:  LinkageTypes getLinkage() const { return LinkageTypes(Linkage); }
        -:  540:
        -:  541:  bool isDiscardableIfUnused() const {
        -:  542:    return isDiscardableIfUnused(getLinkage());
        -:  543:  }
        -:  544:
        -:  545:  bool isWeakForLinker() const { return isWeakForLinker(getLinkage()); }
        -:  546:
        -:  547:protected:
        -:  548:  /// Copy all additional attributes (those not needed to create a GlobalValue)
        -:  549:  /// from the GlobalValue Src to this one.
        -:  550:  void copyAttributesFrom(const GlobalValue *Src);
        -:  551:
        -:  552:public:
        -:  553:  /// If the given string begins with the GlobalValue name mangling escape
        -:  554:  /// character '\1', drop it.
        -:  555:  ///
        -:  556:  /// This function applies a specific mangling that is used in PGO profiles,
        -:  557:  /// among other things. If you're trying to get a symbol name for an
        -:  558:  /// arbitrary GlobalValue, this is not the function you're looking for; see
        -:  559:  /// Mangler.h.
        -:  560:  static StringRef dropLLVMManglingEscape(StringRef Name) {
        -:  561:    if (!Name.empty() && Name[0] == '\1')
        -:  562:      return Name.substr(1);
        -:  563:    return Name;
        -:  564:  }
        -:  565:
        -:  566:  /// Return the modified name for a global value suitable to be
        -:  567:  /// used as the key for a global lookup (e.g. profile or ThinLTO).
        -:  568:  /// The value's original name is \c Name and has linkage of type
        -:  569:  /// \c Linkage. The value is defined in module \c FileName.
        -:  570:  static std::string getGlobalIdentifier(StringRef Name,
        -:  571:                                         GlobalValue::LinkageTypes Linkage,
        -:  572:                                         StringRef FileName);
        -:  573:
        -:  574:  /// Return the modified name for this global value suitable to be
        -:  575:  /// used as the key for a global lookup (e.g. profile or ThinLTO).
        -:  576:  std::string getGlobalIdentifier() const;
        -:  577:
        -:  578:  /// Declare a type to represent a global unique identifier for a global value.
        -:  579:  /// This is a 64 bits hash that is used by PGO and ThinLTO to have a compact
        -:  580:  /// unique way to identify a symbol.
        -:  581:  using GUID = uint64_t;
        -:  582:
        -:  583:  /// Return a 64-bit global unique ID constructed from global value name
        -:  584:  /// (i.e. returned by getGlobalIdentifier()).
        -:  585:  static GUID getGUID(StringRef GlobalName) { return MD5Hash(GlobalName); }
        -:  586:
        -:  587:  /// Return a 64-bit global unique ID constructed from global value name
        -:  588:  /// (i.e. returned by getGlobalIdentifier()).
        -:  589:  GUID getGUID() const { return getGUID(getGlobalIdentifier()); }
        -:  590:
        -:  591:  /// @name Materialization
        -:  592:  /// Materialization is used to construct functions only as they're needed.
        -:  593:  /// This
        -:  594:  /// is useful to reduce memory usage in LLVM or parsing work done by the
        -:  595:  /// BitcodeReader to load the Module.
        -:  596:  /// @{
        -:  597:
        -:  598:  /// If this function's Module is being lazily streamed in functions from disk
        -:  599:  /// or some other source, this method can be used to check to see if the
        -:  600:  /// function has been read in yet or not.
        -:  601:  bool isMaterializable() const;
        -:  602:
        -:  603:  /// Make sure this GlobalValue is fully read.
        -:  604:  Error materialize();
        -:  605:
        -:  606:/// @}
        -:  607:
        -:  608:  /// Return true if the primary definition of this global value is outside of
        -:  609:  /// the current translation unit.
        -:  610:  bool isDeclaration() const;
        -:  611:
        -:  612:  bool isDeclarationForLinker() const {
        -:  613:    if (hasAvailableExternallyLinkage())
        -:  614:      return true;
        -:  615:
        -:  616:    return isDeclaration();
        -:  617:  }
        -:  618:
        -:  619:  /// Returns true if this global's definition will be the one chosen by the
        -:  620:  /// linker.
        -:  621:  ///
        -:  622:  /// NB! Ideally this should not be used at the IR level at all.  If you're
        -:  623:  /// interested in optimization constraints implied by the linker's ability to
        -:  624:  /// choose an implementation, prefer using \c hasExactDefinition.
        -:  625:  bool isStrongDefinitionForLinker() const {
        -:  626:    return !(isDeclarationForLinker() || isWeakForLinker());
        -:  627:  }
        -:  628:
        -:  629:  const GlobalObject *getAliaseeObject() const;
        -:  630:  GlobalObject *getAliaseeObject() {
        -:  631:    return const_cast<GlobalObject *>(
        -:  632:        static_cast<const GlobalValue *>(this)->getAliaseeObject());
        -:  633:  }
        -:  634:
        -:  635:  /// Returns whether this is a reference to an absolute symbol.
        -:  636:  bool isAbsoluteSymbolRef() const;
        -:  637:
        -:  638:  /// If this is an absolute symbol reference, returns the range of the symbol,
        -:  639:  /// otherwise returns None.
        -:  640:  Optional<ConstantRange> getAbsoluteSymbolRange() const;
        -:  641:
        -:  642:  /// This method unlinks 'this' from the containing module, but does not delete
        -:  643:  /// it.
        -:  644:  void removeFromParent();
        -:  645:
        -:  646:  /// This method unlinks 'this' from the containing module and deletes it.
        -:  647:  void eraseFromParent();
        -:  648:
        -:  649:  /// Get the module that this global value is contained inside of...
    #####:  650:  Module *getParent() { return Parent; }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  651:  const Module *getParent() const { return Parent; }
        -:  652:
        -:  653:  // Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  654:  static bool classof(const Value *V) {
        -:  655:    return V->getValueID() == Value::FunctionVal ||
        -:  656:           V->getValueID() == Value::GlobalVariableVal ||
        -:  657:           V->getValueID() == Value::GlobalAliasVal ||
        -:  658:           V->getValueID() == Value::GlobalIFuncVal;
        -:  659:  }
        -:  660:
        -:  661:  /// True if GV can be left out of the object symbol table. This is the case
        -:  662:  /// for linkonce_odr values whose address is not significant. While legal, it
        -:  663:  /// is not normally profitable to omit them from the .o symbol table. Using
        -:  664:  /// this analysis makes sense when the information can be passed down to the
        -:  665:  /// linker or we are in LTO.
        -:  666:  bool canBeOmittedFromSymbolTable() const;
        -:  667:};
        -:  668:
        -:  669:} // end namespace llvm
        -:  670:
        -:  671:#endif // LLVM_IR_GLOBALVALUE_H
