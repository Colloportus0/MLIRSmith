        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/AMDGPUToROCDL/AMDGPUToROCDL.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/AMDGPUToROCDL/CMakeFiles/obj.MLIRAMDGPUToROCDL.dir/AMDGPUToROCDL.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/AMDGPUToROCDL/CMakeFiles/obj.MLIRAMDGPUToROCDL.dir/AMDGPUToROCDL.cpp.gcda
        -:    0:Runs:128633
        -:    1://===- AMDGPUToROCDL.cpp - AMDGPU to ROCDL dialect conversion -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/AMDGPUToROCDL/AMDGPUToROCDL.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
        -:   12:#include "mlir/Conversion/LLVMCommon/Pattern.h"
        -:   13:#include "mlir/Dialect/AMDGPU/AMDGPUDialect.h"
        -:   14:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   15:#include "mlir/Dialect/LLVMIR/ROCDLDialect.h"
        -:   16:#include "mlir/Pass/Pass.h"
        -:   17:
        -:   18:#include "llvm/ADT/STLExtras.h"
        -:   19:
        -:   20:namespace mlir {
        -:   21:#define GEN_PASS_DEF_CONVERTAMDGPUTOROCDL
        -:   22:#include "mlir/Conversion/Passes.h.inc"
        -:   23:} // namespace mlir
        -:   24:
        -:   25:using namespace mlir;
        -:   26:using namespace mlir::amdgpu;
        -:   27:
function _ZL17createI32ConstantRN4mlir25ConversionPatternRewriterENS_8LocationEi called 0 returned 0% blocks executed 0%
    #####:   28:static Value createI32Constant(ConversionPatternRewriter &rewriter,
        -:   29:                               Location loc, int32_t value) {
    #####:   30:  Type llvmI32 = rewriter.getI32Type();
call    0 never executed
    #####:   31:  return rewriter.createOrFold<LLVM::ConstantOp>(loc, llvmI32, value);
call    0 never executed
        -:   32:}
        -:   33:
        -:   34:namespace {
        -:   35:/// Define lowering patterns for raw buffer ops
        -:   36:template <typename GpuOp, typename Intrinsic>
        -:   37:struct RawBufferOpLowering : public ConvertOpToLLVMPattern<GpuOp> {
     1596:   38:  RawBufferOpLowering(LLVMTypeConverter &converter, Chipset chipset)
     1596:   39:      : ConvertOpToLLVMPattern<GpuOp>(converter), chipset(chipset) {}
------------------
_ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu21RawBufferAtomicFaddOpENS1_5ROCDL21RawBufferAtomicFAddOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE:
function _ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu21RawBufferAtomicFaddOpENS1_5ROCDL21RawBufferAtomicFAddOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE called 532 returned 100% blocks executed 100%
      532:   38:  RawBufferOpLowering(LLVMTypeConverter &converter, Chipset chipset)
      532:   39:      : ConvertOpToLLVMPattern<GpuOp>(converter), chipset(chipset) {}
call    0 returned 100%
call    1 returned 100%
------------------
_ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu16RawBufferStoreOpENS1_5ROCDL16RawBufferStoreOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE:
function _ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu16RawBufferStoreOpENS1_5ROCDL16RawBufferStoreOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE called 532 returned 100% blocks executed 100%
      532:   38:  RawBufferOpLowering(LLVMTypeConverter &converter, Chipset chipset)
      532:   39:      : ConvertOpToLLVMPattern<GpuOp>(converter), chipset(chipset) {}
call    0 returned 100%
call    1 returned 100%
------------------
_ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu15RawBufferLoadOpENS1_5ROCDL15RawBufferLoadOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE:
function _ZN12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu15RawBufferLoadOpENS1_5ROCDL15RawBufferLoadOpEEC2ERNS1_17LLVMTypeConverterENS2_7ChipsetE called 532 returned 100% blocks executed 100%
      532:   38:  RawBufferOpLowering(LLVMTypeConverter &converter, Chipset chipset)
      532:   39:      : ConvertOpToLLVMPattern<GpuOp>(converter), chipset(chipset) {}
call    0 returned 100%
call    1 returned 100%
------------------
        -:   40:
        -:   41:  Chipset chipset;
        -:   42:  static constexpr uint32_t maxVectorOpWidth = 128;
        -:   43:
        -:   44:  LogicalResult
    #####:   45:  matchAndRewrite(GpuOp gpuOp, typename GpuOp::Adaptor adaptor,
        -:   46:                  ConversionPatternRewriter &rewriter) const override {
    #####:   47:    Location loc = gpuOp.getLoc();
    #####:   48:    Value memref = adaptor.getMemref();
    #####:   49:    Value unconvertedMemref = gpuOp.getMemref();
    #####:   50:    MemRefType memrefType = unconvertedMemref.getType().cast<MemRefType>();
        -:   51:
    #####:   52:    if (chipset.majorVersion < 9)
    #####:   53:      return gpuOp.emitOpError("Raw buffer ops require GCN or higher");
        -:   54:
    #####:   55:    Value storeData = adaptor.getODSOperands(0)[0];
    #####:   56:    if (storeData == memref) // no write component to this op
    #####:   57:      storeData = Value();
    #####:   58:    Type wantedDataType;
    #####:   59:    if (storeData)
    #####:   60:      wantedDataType = storeData.getType();
        -:   61:    else
    #####:   62:      wantedDataType = gpuOp.getODSResults(0)[0].getType();
        -:   63:
    #####:   64:    Type llvmWantedDataType = this->typeConverter->convertType(wantedDataType);
        -:   65:
    #####:   66:    Type i32 = rewriter.getI32Type();
    #####:   67:    Type llvmI32 = this->typeConverter->convertType(i32);
        -:   68:
    #####:   69:    int64_t elementByteWidth = memrefType.getElementTypeBitWidth() / 8;
    #####:   70:    Value byteWidthConst = createI32Constant(rewriter, loc, elementByteWidth);
        -:   71:
        -:   72:    // If we want to load a vector<NxT> with total size <= 32
        -:   73:    // bits, use a scalar load and bitcast it. Similarly, if bitsize(T) < 32
        -:   74:    // and the total load size is >= 32, use a vector load of N / (bitsize(T) /
        -:   75:    // 32) x i32 and bitcast.
    #####:   76:    Type llvmBufferValType = llvmWantedDataType;
    #####:   77:    if (auto dataVector = wantedDataType.dyn_cast<VectorType>()) {
    #####:   78:      uint32_t elemBits = dataVector.getElementTypeBitWidth();
    #####:   79:      uint32_t totalBits = elemBits * dataVector.getNumElements();
    #####:   80:      if (totalBits > maxVectorOpWidth)
        -:   81:        return gpuOp.emitOpError(
    #####:   82:            "Total width of loads or stores must be no more than " +
    #####:   83:            Twine(maxVectorOpWidth) + " bits, but we call for " +
    #####:   84:            Twine(totalBits) +
    #####:   85:            " bits. This should've been caught in validation");
    #####:   86:      if (elemBits < 32) {
    #####:   87:        if (totalBits > 32) {
    #####:   88:          if (totalBits % 32 != 0)
        -:   89:            return gpuOp.emitOpError("Load or store of more than 32-bits that "
    #####:   90:                                     "doesn't fit into words. Can't happen\n");
    #####:   91:          llvmBufferValType = this->typeConverter->convertType(
    #####:   92:              VectorType::get(totalBits / 32, i32));
        -:   93:        } else {
    #####:   94:          llvmBufferValType = this->typeConverter->convertType(
    #####:   95:              rewriter.getIntegerType(totalBits));
        -:   96:        }
        -:   97:      }
        -:   98:    }
        -:   99:
    #####:  100:    SmallVector<Value, 6> args;
    #####:  101:    if (storeData) {
    #####:  102:      if (llvmBufferValType != llvmWantedDataType) {
    #####:  103:        Value castForStore =
    #####:  104:            rewriter.create<LLVM::BitcastOp>(loc, llvmBufferValType, storeData);
    #####:  105:        args.push_back(castForStore);
        -:  106:      } else {
    #####:  107:        args.push_back(storeData);
        -:  108:      }
        -:  109:    }
        -:  110:
        -:  111:    // Construct buffer descriptor from memref, attributes
    #####:  112:    int64_t offset = 0;
    #####:  113:    SmallVector<int64_t, 5> strides;
    #####:  114:    if (failed(getStridesAndOffset(memrefType, strides, offset)))
    #####:  115:      return gpuOp.emitOpError("Can't lower non-stride-offset memrefs");
        -:  116:
        -:  117:    // Resource descriptor
        -:  118:    // bits 0-47: base address
        -:  119:    // bits 48-61: stride (0 for raw buffers)
        -:  120:    // bit 62: texture cache coherency (always 0)
        -:  121:    // bit 63: enable swizzles (always off for raw buffers)
        -:  122:    // bits 64-95 (word 2): Number of records, units of stride
        -:  123:    // bits 96-127 (word 3): See below
        -:  124:
    #####:  125:    Type llvm4xI32 = this->typeConverter->convertType(VectorType::get(4, i32));
    #####:  126:    MemRefDescriptor memrefDescriptor(memref);
    #####:  127:    Type llvmI64 = this->typeConverter->convertType(rewriter.getI64Type());
    #####:  128:    Value c32I64 = rewriter.create<LLVM::ConstantOp>(
    #####:  129:        loc, llvmI64, rewriter.getI64IntegerAttr(32));
        -:  130:
    #####:  131:    Value resource = rewriter.create<LLVM::UndefOp>(loc, llvm4xI32);
        -:  132:
    #####:  133:    Value ptr = memrefDescriptor.alignedPtr(rewriter, loc);
    #####:  134:    Value ptrAsInt = rewriter.create<LLVM::PtrToIntOp>(loc, llvmI64, ptr);
    #####:  135:    Value lowHalf = rewriter.create<LLVM::TruncOp>(loc, llvmI32, ptrAsInt);
    #####:  136:    resource = rewriter.create<LLVM::InsertElementOp>(
        -:  137:        loc, llvm4xI32, resource, lowHalf,
        -:  138:        this->createIndexConstant(rewriter, loc, 0));
        -:  139:
        -:  140:    // Bits 48-63 are used both for the stride of the buffer and (on gfx10) for
        -:  141:    // enabling swizzling. Prevent the high bits of pointers from accidentally
        -:  142:    // setting those flags.
    #####:  143:    Value highHalfShifted = rewriter.create<LLVM::TruncOp>(
    #####:  144:        loc, llvmI32, rewriter.create<LLVM::LShrOp>(loc, ptrAsInt, c32I64));
    #####:  145:    Value highHalfTruncated = rewriter.create<LLVM::AndOp>(
        -:  146:        loc, llvmI32, highHalfShifted,
    #####:  147:        createI32Constant(rewriter, loc, 0x0000ffff));
    #####:  148:    resource = rewriter.create<LLVM::InsertElementOp>(
        -:  149:        loc, llvm4xI32, resource, highHalfTruncated,
        -:  150:        this->createIndexConstant(rewriter, loc, 1));
        -:  151:
    #####:  152:    Value numRecords;
    #####:  153:    if (memrefType.hasStaticShape()) {
    #####:  154:      numRecords = createI32Constant(
        -:  155:          rewriter, loc,
    #####:  156:          static_cast<int32_t>(memrefType.getNumElements() * elementByteWidth));
        -:  157:    } else {
    #####:  158:      Value maxIndex;
    #####:  159:      for (uint32_t i = 0, e = memrefType.getRank(); i < e; ++i) {
    #####:  160:        Value size = memrefDescriptor.size(rewriter, loc, i);
    #####:  161:        Value stride = memrefDescriptor.stride(rewriter, loc, i);
    #####:  162:        stride = rewriter.create<LLVM::MulOp>(loc, stride, byteWidthConst);
    #####:  163:        Value maxThisDim = rewriter.create<LLVM::MulOp>(loc, size, stride);
    #####:  164:        maxIndex = maxIndex ? rewriter.create<LLVM::MaximumOp>(loc, maxIndex,
        -:  165:                                                               maxThisDim)
        -:  166:                            : maxThisDim;
        -:  167:      }
    #####:  168:      numRecords = rewriter.create<LLVM::TruncOp>(loc, llvmI32, maxIndex);
        -:  169:    }
    #####:  170:    resource = rewriter.create<LLVM::InsertElementOp>(
        -:  171:        loc, llvm4xI32, resource, numRecords,
        -:  172:        this->createIndexConstant(rewriter, loc, 2));
        -:  173:
        -:  174:    // Final word:
        -:  175:    // bits 0-11: dst sel, ignored by these intrinsics
        -:  176:    // bits 12-14: data format (ignored, must be nonzero, 7=float)
        -:  177:    // bits 15-18: data format (ignored, must be nonzero, 4=32bit)
        -:  178:    // bit 19: In nested heap (0 here)
        -:  179:    // bit 20: Behavior on unmap (0 means  "return 0 / ignore")
        -:  180:    // bits 21-22: Index stride for swizzles (N/A)
        -:  181:    // bit 23: Add thread ID (0)
        -:  182:    // bit 24: Reserved to 1 (RDNA) or 0 (CDNA)
        -:  183:    // bits 25-26: Reserved (0)
        -:  184:    // bit 27: Buffer is non-volatile (CDNA only)
        -:  185:    // bits 28-29: Out of bounds select (0 = structured, 1 = check index, 2 =
        -:  186:    //  none, 3 = either swizzles or testing against offset field) RDNA only
        -:  187:    // bits 30-31: Type (must be 0)
    #####:  188:    uint32_t word3 = (7 << 12) | (4 << 15);
    #####:  189:    if (chipset.majorVersion == 10) {
    #####:  190:      word3 |= (1 << 24);
    #####:  191:      uint32_t oob = adaptor.getBoundsCheck() ? 3 : 2;
    #####:  192:      word3 |= (oob << 28);
        -:  193:    }
    #####:  194:    Value word3Const = createI32Constant(rewriter, loc, word3);
    #####:  195:    resource = rewriter.create<LLVM::InsertElementOp>(
        -:  196:        loc, llvm4xI32, resource, word3Const,
        -:  197:        this->createIndexConstant(rewriter, loc, 3));
    #####:  198:    args.push_back(resource);
        -:  199:
        -:  200:    // Indexing (voffset)
    #####:  201:    Value voffset;
    #####:  202:    for (auto &pair : llvm::enumerate(adaptor.getIndices())) {
    #####:  203:      size_t i = pair.index();
    #####:  204:      Value index = pair.value();
    #####:  205:      Value strideOp;
    #####:  206:      if (ShapedType::isDynamicStrideOrOffset(strides[i])) {
    #####:  207:        strideOp = rewriter.create<LLVM::MulOp>(
    #####:  208:            loc, memrefDescriptor.stride(rewriter, loc, i), byteWidthConst);
        -:  209:      } else {
        -:  210:        strideOp =
    #####:  211:            createI32Constant(rewriter, loc, strides[i] * elementByteWidth);
        -:  212:      }
    #####:  213:      index = rewriter.create<LLVM::MulOp>(loc, index, strideOp);
    #####:  214:      voffset =
    #####:  215:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, index) : index;
        -:  216:    }
    #####:  217:    if (adaptor.getIndexOffset()) {
    #####:  218:      int32_t indexOffset = *gpuOp.getIndexOffset() * elementByteWidth;
    #####:  219:      Value extraOffsetConst = createI32Constant(rewriter, loc, indexOffset);
    #####:  220:      voffset =
    #####:  221:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, extraOffsetConst)
        -:  222:                  : extraOffsetConst;
        -:  223:    }
    #####:  224:    args.push_back(voffset);
        -:  225:
    #####:  226:    Value sgprOffset = adaptor.getSgprOffset();
    #####:  227:    if (!sgprOffset)
    #####:  228:      sgprOffset = createI32Constant(rewriter, loc, 0);
    #####:  229:    if (ShapedType::isDynamicStrideOrOffset(offset))
    #####:  230:      sgprOffset = rewriter.create<LLVM::AddOp>(
    #####:  231:          loc, memrefDescriptor.offset(rewriter, loc), sgprOffset);
    #####:  232:    else if (offset > 0)
    #####:  233:      sgprOffset = rewriter.create<LLVM::AddOp>(
    #####:  234:          loc, sgprOffset, createI32Constant(rewriter, loc, offset));
    #####:  235:    args.push_back(sgprOffset);
        -:  236:
        -:  237:    // bit 0: GLC = 0 (atomics drop value, less coherency)
        -:  238:    // bits 1-2: SLC, DLC = 0 (similarly)
        -:  239:    // bit 3: swizzled (0 for raw)
    #####:  240:    args.push_back(createI32Constant(rewriter, loc, 0));
        -:  241:
    #####:  242:    llvm::SmallVector<Type, 1> resultTypes(gpuOp->getNumResults(),
        -:  243:                                           llvmBufferValType);
    #####:  244:    Operation *lowered = rewriter.create<Intrinsic>(loc, resultTypes, args,
        -:  245:                                                    ArrayRef<NamedAttribute>());
    #####:  246:    if (lowered->getNumResults() == 1) {
    #####:  247:      Value replacement = lowered->getResult(0);
    #####:  248:      if (llvmBufferValType != llvmWantedDataType) {
    #####:  249:        replacement = rewriter.create<LLVM::BitcastOp>(loc, llvmWantedDataType,
        -:  250:                                                       replacement);
        -:  251:      }
    #####:  252:      rewriter.replaceOp(gpuOp, replacement);
        -:  253:    } else {
    #####:  254:      rewriter.eraseOp(gpuOp);
        -:  255:    }
    #####:  256:    return success();
        -:  257:  }
------------------
_ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu15RawBufferLoadOpENS1_5ROCDL15RawBufferLoadOpEE15matchAndRewriteES3_NS2_22RawBufferLoadOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu15RawBufferLoadOpENS1_5ROCDL15RawBufferLoadOpEE15matchAndRewriteES3_NS2_22RawBufferLoadOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   45:  matchAndRewrite(GpuOp gpuOp, typename GpuOp::Adaptor adaptor,
        -:   46:                  ConversionPatternRewriter &rewriter) const override {
    #####:   47:    Location loc = gpuOp.getLoc();
call    0 never executed
    #####:   48:    Value memref = adaptor.getMemref();
call    0 never executed
    #####:   49:    Value unconvertedMemref = gpuOp.getMemref();
call    0 never executed
    #####:   50:    MemRefType memrefType = unconvertedMemref.getType().cast<MemRefType>();
call    0 never executed
        -:   51:
    #####:   52:    if (chipset.majorVersion < 9)
branch  0 never executed
branch  1 never executed
    #####:   53:      return gpuOp.emitOpError("Raw buffer ops require GCN or higher");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   54:
    #####:   55:    Value storeData = adaptor.getODSOperands(0)[0];
call    0 never executed
call    1 never executed
    #####:   56:    if (storeData == memref) // no write component to this op
branch  0 never executed
branch  1 never executed
    #####:   57:      storeData = Value();
    #####:   58:    Type wantedDataType;
    #####:   59:    if (storeData)
branch  0 never executed
branch  1 never executed
    #####:   60:      wantedDataType = storeData.getType();
        -:   61:    else
    #####:   62:      wantedDataType = gpuOp.getODSResults(0)[0].getType();
call    0 never executed
call    1 never executed
        -:   63:
    #####:   64:    Type llvmWantedDataType = this->typeConverter->convertType(wantedDataType);
call    0 never executed
        -:   65:
    #####:   66:    Type i32 = rewriter.getI32Type();
call    0 never executed
    #####:   67:    Type llvmI32 = this->typeConverter->convertType(i32);
call    0 never executed
call    1 never executed
        -:   68:
    #####:   69:    int64_t elementByteWidth = memrefType.getElementTypeBitWidth() / 8;
    #####:   70:    Value byteWidthConst = createI32Constant(rewriter, loc, elementByteWidth);
call    0 never executed
        -:   71:
        -:   72:    // If we want to load a vector<NxT> with total size <= 32
        -:   73:    // bits, use a scalar load and bitcast it. Similarly, if bitsize(T) < 32
        -:   74:    // and the total load size is >= 32, use a vector load of N / (bitsize(T) /
        -:   75:    // 32) x i32 and bitcast.
    #####:   76:    Type llvmBufferValType = llvmWantedDataType;
call    0 never executed
    #####:   77:    if (auto dataVector = wantedDataType.dyn_cast<VectorType>()) {
branch  0 never executed
branch  1 never executed
    #####:   78:      uint32_t elemBits = dataVector.getElementTypeBitWidth();
    #####:   79:      uint32_t totalBits = elemBits * dataVector.getNumElements();
call    0 never executed
    #####:   80:      if (totalBits > maxVectorOpWidth)
branch  0 never executed
branch  1 never executed
        -:   81:        return gpuOp.emitOpError(
    #####:   82:            "Total width of loads or stores must be no more than " +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   83:            Twine(maxVectorOpWidth) + " bits, but we call for " +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   84:            Twine(totalBits) +
call    0 never executed
call    1 never executed
    #####:   85:            " bits. This should've been caught in validation");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   86:      if (elemBits < 32) {
branch  0 never executed
branch  1 never executed
    #####:   87:        if (totalBits > 32) {
branch  0 never executed
branch  1 never executed
    #####:   88:          if (totalBits % 32 != 0)
branch  0 never executed
branch  1 never executed
        -:   89:            return gpuOp.emitOpError("Load or store of more than 32-bits that "
    #####:   90:                                     "doesn't fit into words. Can't happen\n");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   91:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   92:              VectorType::get(totalBits / 32, i32));
call    0 never executed
        -:   93:        } else {
    #####:   94:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   95:              rewriter.getIntegerType(totalBits));
call    0 never executed
        -:   96:        }
        -:   97:      }
        -:   98:    }
        -:   99:
    #####:  100:    SmallVector<Value, 6> args;
    #####:  101:    if (storeData) {
branch  0 never executed
branch  1 never executed
    #####:  102:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  103:        Value castForStore =
    #####:  104:            rewriter.create<LLVM::BitcastOp>(loc, llvmBufferValType, storeData);
call    0 never executed
call    1 never executed
    #####:  105:        args.push_back(castForStore);
call    0 never executed
        -:  106:      } else {
    #####:  107:        args.push_back(storeData);
call    0 never executed
        -:  108:      }
        -:  109:    }
        -:  110:
        -:  111:    // Construct buffer descriptor from memref, attributes
    #####:  112:    int64_t offset = 0;
call    0 never executed
    #####:  113:    SmallVector<int64_t, 5> strides;
branch  0 never executed
branch  1 never executed
    #####:  114:    if (failed(getStridesAndOffset(memrefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  115:      return gpuOp.emitOpError("Can't lower non-stride-offset memrefs");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  116:
        -:  117:    // Resource descriptor
        -:  118:    // bits 0-47: base address
        -:  119:    // bits 48-61: stride (0 for raw buffers)
        -:  120:    // bit 62: texture cache coherency (always 0)
        -:  121:    // bit 63: enable swizzles (always off for raw buffers)
        -:  122:    // bits 64-95 (word 2): Number of records, units of stride
        -:  123:    // bits 96-127 (word 3): See below
        -:  124:
    #####:  125:    Type llvm4xI32 = this->typeConverter->convertType(VectorType::get(4, i32));
call    0 never executed
call    1 never executed
    #####:  126:    MemRefDescriptor memrefDescriptor(memref);
call    0 never executed
    #####:  127:    Type llvmI64 = this->typeConverter->convertType(rewriter.getI64Type());
call    0 never executed
call    1 never executed
    #####:  128:    Value c32I64 = rewriter.create<LLVM::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:  129:        loc, llvmI64, rewriter.getI64IntegerAttr(32));
call    0 never executed
        -:  130:
    #####:  131:    Value resource = rewriter.create<LLVM::UndefOp>(loc, llvm4xI32);
call    0 never executed
call    1 never executed
        -:  132:
    #####:  133:    Value ptr = memrefDescriptor.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  134:    Value ptrAsInt = rewriter.create<LLVM::PtrToIntOp>(loc, llvmI64, ptr);
call    0 never executed
call    1 never executed
    #####:  135:    Value lowHalf = rewriter.create<LLVM::TruncOp>(loc, llvmI32, ptrAsInt);
call    0 never executed
call    1 never executed
    #####:  136:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  137:        loc, llvm4xI32, resource, lowHalf,
        -:  138:        this->createIndexConstant(rewriter, loc, 0));
        -:  139:
        -:  140:    // Bits 48-63 are used both for the stride of the buffer and (on gfx10) for
        -:  141:    // enabling swizzling. Prevent the high bits of pointers from accidentally
        -:  142:    // setting those flags.
    #####:  143:    Value highHalfShifted = rewriter.create<LLVM::TruncOp>(
call    0 never executed
call    1 never executed
    #####:  144:        loc, llvmI32, rewriter.create<LLVM::LShrOp>(loc, ptrAsInt, c32I64));
call    0 never executed
    #####:  145:    Value highHalfTruncated = rewriter.create<LLVM::AndOp>(
call    0 never executed
call    1 never executed
        -:  146:        loc, llvmI32, highHalfShifted,
    #####:  147:        createI32Constant(rewriter, loc, 0x0000ffff));
call    0 never executed
    #####:  148:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  149:        loc, llvm4xI32, resource, highHalfTruncated,
        -:  150:        this->createIndexConstant(rewriter, loc, 1));
        -:  151:
    #####:  152:    Value numRecords;
    #####:  153:    if (memrefType.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  154:      numRecords = createI32Constant(
call    0 never executed
        -:  155:          rewriter, loc,
    #####:  156:          static_cast<int32_t>(memrefType.getNumElements() * elementByteWidth));
call    0 never executed
        -:  157:    } else {
    #####:  158:      Value maxIndex;
    #####:  159:      for (uint32_t i = 0, e = memrefType.getRank(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:        Value size = memrefDescriptor.size(rewriter, loc, i);
call    0 never executed
    #####:  161:        Value stride = memrefDescriptor.stride(rewriter, loc, i);
call    0 never executed
    #####:  162:        stride = rewriter.create<LLVM::MulOp>(loc, stride, byteWidthConst);
call    0 never executed
call    1 never executed
    #####:  163:        Value maxThisDim = rewriter.create<LLVM::MulOp>(loc, size, stride);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  164:        maxIndex = maxIndex ? rewriter.create<LLVM::MaximumOp>(loc, maxIndex,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  165:                                                               maxThisDim)
        -:  166:                            : maxThisDim;
        -:  167:      }
    #####:  168:      numRecords = rewriter.create<LLVM::TruncOp>(loc, llvmI32, maxIndex);
call    0 never executed
        -:  169:    }
    #####:  170:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  171:        loc, llvm4xI32, resource, numRecords,
        -:  172:        this->createIndexConstant(rewriter, loc, 2));
        -:  173:
        -:  174:    // Final word:
        -:  175:    // bits 0-11: dst sel, ignored by these intrinsics
        -:  176:    // bits 12-14: data format (ignored, must be nonzero, 7=float)
        -:  177:    // bits 15-18: data format (ignored, must be nonzero, 4=32bit)
        -:  178:    // bit 19: In nested heap (0 here)
        -:  179:    // bit 20: Behavior on unmap (0 means  "return 0 / ignore")
        -:  180:    // bits 21-22: Index stride for swizzles (N/A)
        -:  181:    // bit 23: Add thread ID (0)
        -:  182:    // bit 24: Reserved to 1 (RDNA) or 0 (CDNA)
        -:  183:    // bits 25-26: Reserved (0)
        -:  184:    // bit 27: Buffer is non-volatile (CDNA only)
        -:  185:    // bits 28-29: Out of bounds select (0 = structured, 1 = check index, 2 =
        -:  186:    //  none, 3 = either swizzles or testing against offset field) RDNA only
        -:  187:    // bits 30-31: Type (must be 0)
    #####:  188:    uint32_t word3 = (7 << 12) | (4 << 15);
    #####:  189:    if (chipset.majorVersion == 10) {
branch  0 never executed
branch  1 never executed
    #####:  190:      word3 |= (1 << 24);
    #####:  191:      uint32_t oob = adaptor.getBoundsCheck() ? 3 : 2;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  192:      word3 |= (oob << 28);
        -:  193:    }
    #####:  194:    Value word3Const = createI32Constant(rewriter, loc, word3);
call    0 never executed
    #####:  195:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  196:        loc, llvm4xI32, resource, word3Const,
        -:  197:        this->createIndexConstant(rewriter, loc, 3));
    #####:  198:    args.push_back(resource);
call    0 never executed
        -:  199:
        -:  200:    // Indexing (voffset)
    #####:  201:    Value voffset;
    #####:  202:    for (auto &pair : llvm::enumerate(adaptor.getIndices())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  203:      size_t i = pair.index();
call    0 never executed
    #####:  204:      Value index = pair.value();
    #####:  205:      Value strideOp;
branch  0 never executed
branch  1 never executed
    #####:  206:      if (ShapedType::isDynamicStrideOrOffset(strides[i])) {
branch  0 never executed
branch  1 never executed
    #####:  207:        strideOp = rewriter.create<LLVM::MulOp>(
call    0 never executed
    #####:  208:            loc, memrefDescriptor.stride(rewriter, loc, i), byteWidthConst);
call    0 never executed
        -:  209:      } else {
        -:  210:        strideOp =
    #####:  211:            createI32Constant(rewriter, loc, strides[i] * elementByteWidth);
call    0 never executed
        -:  212:      }
    #####:  213:      index = rewriter.create<LLVM::MulOp>(loc, index, strideOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  215:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, index) : index;
call    0 never executed
call    1 never executed
        -:  216:    }
    #####:  217:    if (adaptor.getIndexOffset()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:      int32_t indexOffset = *gpuOp.getIndexOffset() * elementByteWidth;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  219:      Value extraOffsetConst = createI32Constant(rewriter, loc, indexOffset);
call    0 never executed
    #####:  220:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  221:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, extraOffsetConst)
call    0 never executed
        -:  222:                  : extraOffsetConst;
        -:  223:    }
    #####:  224:    args.push_back(voffset);
call    0 never executed
        -:  225:
    #####:  226:    Value sgprOffset = adaptor.getSgprOffset();
call    0 never executed
    #####:  227:    if (!sgprOffset)
branch  0 never executed
branch  1 never executed
    #####:  228:      sgprOffset = createI32Constant(rewriter, loc, 0);
call    0 never executed
    #####:  229:    if (ShapedType::isDynamicStrideOrOffset(offset))
branch  0 never executed
branch  1 never executed
    #####:  230:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  231:          loc, memrefDescriptor.offset(rewriter, loc), sgprOffset);
call    0 never executed
    #####:  232:    else if (offset > 0)
branch  0 never executed
branch  1 never executed
    #####:  233:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  234:          loc, sgprOffset, createI32Constant(rewriter, loc, offset));
call    0 never executed
    #####:  235:    args.push_back(sgprOffset);
call    0 never executed
        -:  236:
        -:  237:    // bit 0: GLC = 0 (atomics drop value, less coherency)
        -:  238:    // bits 1-2: SLC, DLC = 0 (similarly)
        -:  239:    // bit 3: swizzled (0 for raw)
    #####:  240:    args.push_back(createI32Constant(rewriter, loc, 0));
call    0 never executed
call    1 never executed
        -:  241:
    #####:  242:    llvm::SmallVector<Type, 1> resultTypes(gpuOp->getNumResults(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  243:                                           llvmBufferValType);
    #####:  244:    Operation *lowered = rewriter.create<Intrinsic>(loc, resultTypes, args,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  245:                                                    ArrayRef<NamedAttribute>());
    #####:  246:    if (lowered->getNumResults() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  247:      Value replacement = lowered->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:  248:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  249:        replacement = rewriter.create<LLVM::BitcastOp>(loc, llvmWantedDataType,
call    0 never executed
        -:  250:                                                       replacement);
        -:  251:      }
    #####:  252:      rewriter.replaceOp(gpuOp, replacement);
call    0 never executed
        -:  253:    } else {
    #####:  254:      rewriter.eraseOp(gpuOp);
call    0 never executed
        -:  255:    }
    #####:  256:    return success();
branch  0 never executed
branch  1 never executed
        -:  257:  }
------------------
_ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu16RawBufferStoreOpENS1_5ROCDL16RawBufferStoreOpEE15matchAndRewriteES3_NS2_23RawBufferStoreOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu16RawBufferStoreOpENS1_5ROCDL16RawBufferStoreOpEE15matchAndRewriteES3_NS2_23RawBufferStoreOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   45:  matchAndRewrite(GpuOp gpuOp, typename GpuOp::Adaptor adaptor,
        -:   46:                  ConversionPatternRewriter &rewriter) const override {
    #####:   47:    Location loc = gpuOp.getLoc();
call    0 never executed
    #####:   48:    Value memref = adaptor.getMemref();
call    0 never executed
    #####:   49:    Value unconvertedMemref = gpuOp.getMemref();
call    0 never executed
    #####:   50:    MemRefType memrefType = unconvertedMemref.getType().cast<MemRefType>();
call    0 never executed
        -:   51:
    #####:   52:    if (chipset.majorVersion < 9)
branch  0 never executed
branch  1 never executed
    #####:   53:      return gpuOp.emitOpError("Raw buffer ops require GCN or higher");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   54:
    #####:   55:    Value storeData = adaptor.getODSOperands(0)[0];
call    0 never executed
call    1 never executed
    #####:   56:    if (storeData == memref) // no write component to this op
branch  0 never executed
branch  1 never executed
    #####:   57:      storeData = Value();
    #####:   58:    Type wantedDataType;
    #####:   59:    if (storeData)
branch  0 never executed
branch  1 never executed
    #####:   60:      wantedDataType = storeData.getType();
        -:   61:    else
    #####:   62:      wantedDataType = gpuOp.getODSResults(0)[0].getType();
call    0 never executed
call    1 never executed
        -:   63:
    #####:   64:    Type llvmWantedDataType = this->typeConverter->convertType(wantedDataType);
call    0 never executed
        -:   65:
    #####:   66:    Type i32 = rewriter.getI32Type();
call    0 never executed
    #####:   67:    Type llvmI32 = this->typeConverter->convertType(i32);
call    0 never executed
call    1 never executed
        -:   68:
    #####:   69:    int64_t elementByteWidth = memrefType.getElementTypeBitWidth() / 8;
    #####:   70:    Value byteWidthConst = createI32Constant(rewriter, loc, elementByteWidth);
call    0 never executed
        -:   71:
        -:   72:    // If we want to load a vector<NxT> with total size <= 32
        -:   73:    // bits, use a scalar load and bitcast it. Similarly, if bitsize(T) < 32
        -:   74:    // and the total load size is >= 32, use a vector load of N / (bitsize(T) /
        -:   75:    // 32) x i32 and bitcast.
    #####:   76:    Type llvmBufferValType = llvmWantedDataType;
call    0 never executed
    #####:   77:    if (auto dataVector = wantedDataType.dyn_cast<VectorType>()) {
branch  0 never executed
branch  1 never executed
    #####:   78:      uint32_t elemBits = dataVector.getElementTypeBitWidth();
    #####:   79:      uint32_t totalBits = elemBits * dataVector.getNumElements();
call    0 never executed
    #####:   80:      if (totalBits > maxVectorOpWidth)
branch  0 never executed
branch  1 never executed
        -:   81:        return gpuOp.emitOpError(
    #####:   82:            "Total width of loads or stores must be no more than " +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   83:            Twine(maxVectorOpWidth) + " bits, but we call for " +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   84:            Twine(totalBits) +
call    0 never executed
call    1 never executed
    #####:   85:            " bits. This should've been caught in validation");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   86:      if (elemBits < 32) {
branch  0 never executed
branch  1 never executed
    #####:   87:        if (totalBits > 32) {
branch  0 never executed
branch  1 never executed
    #####:   88:          if (totalBits % 32 != 0)
branch  0 never executed
branch  1 never executed
        -:   89:            return gpuOp.emitOpError("Load or store of more than 32-bits that "
    #####:   90:                                     "doesn't fit into words. Can't happen\n");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   91:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   92:              VectorType::get(totalBits / 32, i32));
call    0 never executed
        -:   93:        } else {
    #####:   94:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   95:              rewriter.getIntegerType(totalBits));
call    0 never executed
        -:   96:        }
        -:   97:      }
        -:   98:    }
        -:   99:
    #####:  100:    SmallVector<Value, 6> args;
    #####:  101:    if (storeData) {
branch  0 never executed
branch  1 never executed
    #####:  102:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  103:        Value castForStore =
    #####:  104:            rewriter.create<LLVM::BitcastOp>(loc, llvmBufferValType, storeData);
call    0 never executed
call    1 never executed
    #####:  105:        args.push_back(castForStore);
call    0 never executed
        -:  106:      } else {
    #####:  107:        args.push_back(storeData);
call    0 never executed
        -:  108:      }
        -:  109:    }
        -:  110:
        -:  111:    // Construct buffer descriptor from memref, attributes
    #####:  112:    int64_t offset = 0;
call    0 never executed
    #####:  113:    SmallVector<int64_t, 5> strides;
branch  0 never executed
branch  1 never executed
    #####:  114:    if (failed(getStridesAndOffset(memrefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  115:      return gpuOp.emitOpError("Can't lower non-stride-offset memrefs");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  116:
        -:  117:    // Resource descriptor
        -:  118:    // bits 0-47: base address
        -:  119:    // bits 48-61: stride (0 for raw buffers)
        -:  120:    // bit 62: texture cache coherency (always 0)
        -:  121:    // bit 63: enable swizzles (always off for raw buffers)
        -:  122:    // bits 64-95 (word 2): Number of records, units of stride
        -:  123:    // bits 96-127 (word 3): See below
        -:  124:
    #####:  125:    Type llvm4xI32 = this->typeConverter->convertType(VectorType::get(4, i32));
call    0 never executed
call    1 never executed
    #####:  126:    MemRefDescriptor memrefDescriptor(memref);
call    0 never executed
    #####:  127:    Type llvmI64 = this->typeConverter->convertType(rewriter.getI64Type());
call    0 never executed
call    1 never executed
    #####:  128:    Value c32I64 = rewriter.create<LLVM::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:  129:        loc, llvmI64, rewriter.getI64IntegerAttr(32));
call    0 never executed
        -:  130:
    #####:  131:    Value resource = rewriter.create<LLVM::UndefOp>(loc, llvm4xI32);
call    0 never executed
call    1 never executed
        -:  132:
    #####:  133:    Value ptr = memrefDescriptor.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  134:    Value ptrAsInt = rewriter.create<LLVM::PtrToIntOp>(loc, llvmI64, ptr);
call    0 never executed
call    1 never executed
    #####:  135:    Value lowHalf = rewriter.create<LLVM::TruncOp>(loc, llvmI32, ptrAsInt);
call    0 never executed
call    1 never executed
    #####:  136:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  137:        loc, llvm4xI32, resource, lowHalf,
        -:  138:        this->createIndexConstant(rewriter, loc, 0));
        -:  139:
        -:  140:    // Bits 48-63 are used both for the stride of the buffer and (on gfx10) for
        -:  141:    // enabling swizzling. Prevent the high bits of pointers from accidentally
        -:  142:    // setting those flags.
    #####:  143:    Value highHalfShifted = rewriter.create<LLVM::TruncOp>(
call    0 never executed
call    1 never executed
    #####:  144:        loc, llvmI32, rewriter.create<LLVM::LShrOp>(loc, ptrAsInt, c32I64));
call    0 never executed
    #####:  145:    Value highHalfTruncated = rewriter.create<LLVM::AndOp>(
call    0 never executed
call    1 never executed
        -:  146:        loc, llvmI32, highHalfShifted,
    #####:  147:        createI32Constant(rewriter, loc, 0x0000ffff));
call    0 never executed
    #####:  148:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  149:        loc, llvm4xI32, resource, highHalfTruncated,
        -:  150:        this->createIndexConstant(rewriter, loc, 1));
        -:  151:
    #####:  152:    Value numRecords;
    #####:  153:    if (memrefType.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  154:      numRecords = createI32Constant(
call    0 never executed
        -:  155:          rewriter, loc,
    #####:  156:          static_cast<int32_t>(memrefType.getNumElements() * elementByteWidth));
call    0 never executed
        -:  157:    } else {
    #####:  158:      Value maxIndex;
    #####:  159:      for (uint32_t i = 0, e = memrefType.getRank(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:        Value size = memrefDescriptor.size(rewriter, loc, i);
call    0 never executed
    #####:  161:        Value stride = memrefDescriptor.stride(rewriter, loc, i);
call    0 never executed
    #####:  162:        stride = rewriter.create<LLVM::MulOp>(loc, stride, byteWidthConst);
call    0 never executed
call    1 never executed
    #####:  163:        Value maxThisDim = rewriter.create<LLVM::MulOp>(loc, size, stride);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  164:        maxIndex = maxIndex ? rewriter.create<LLVM::MaximumOp>(loc, maxIndex,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  165:                                                               maxThisDim)
        -:  166:                            : maxThisDim;
        -:  167:      }
    #####:  168:      numRecords = rewriter.create<LLVM::TruncOp>(loc, llvmI32, maxIndex);
call    0 never executed
        -:  169:    }
    #####:  170:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  171:        loc, llvm4xI32, resource, numRecords,
        -:  172:        this->createIndexConstant(rewriter, loc, 2));
        -:  173:
        -:  174:    // Final word:
        -:  175:    // bits 0-11: dst sel, ignored by these intrinsics
        -:  176:    // bits 12-14: data format (ignored, must be nonzero, 7=float)
        -:  177:    // bits 15-18: data format (ignored, must be nonzero, 4=32bit)
        -:  178:    // bit 19: In nested heap (0 here)
        -:  179:    // bit 20: Behavior on unmap (0 means  "return 0 / ignore")
        -:  180:    // bits 21-22: Index stride for swizzles (N/A)
        -:  181:    // bit 23: Add thread ID (0)
        -:  182:    // bit 24: Reserved to 1 (RDNA) or 0 (CDNA)
        -:  183:    // bits 25-26: Reserved (0)
        -:  184:    // bit 27: Buffer is non-volatile (CDNA only)
        -:  185:    // bits 28-29: Out of bounds select (0 = structured, 1 = check index, 2 =
        -:  186:    //  none, 3 = either swizzles or testing against offset field) RDNA only
        -:  187:    // bits 30-31: Type (must be 0)
    #####:  188:    uint32_t word3 = (7 << 12) | (4 << 15);
    #####:  189:    if (chipset.majorVersion == 10) {
branch  0 never executed
branch  1 never executed
    #####:  190:      word3 |= (1 << 24);
    #####:  191:      uint32_t oob = adaptor.getBoundsCheck() ? 3 : 2;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  192:      word3 |= (oob << 28);
        -:  193:    }
    #####:  194:    Value word3Const = createI32Constant(rewriter, loc, word3);
call    0 never executed
    #####:  195:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  196:        loc, llvm4xI32, resource, word3Const,
        -:  197:        this->createIndexConstant(rewriter, loc, 3));
    #####:  198:    args.push_back(resource);
call    0 never executed
        -:  199:
        -:  200:    // Indexing (voffset)
    #####:  201:    Value voffset;
    #####:  202:    for (auto &pair : llvm::enumerate(adaptor.getIndices())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  203:      size_t i = pair.index();
call    0 never executed
    #####:  204:      Value index = pair.value();
    #####:  205:      Value strideOp;
branch  0 never executed
branch  1 never executed
    #####:  206:      if (ShapedType::isDynamicStrideOrOffset(strides[i])) {
branch  0 never executed
branch  1 never executed
    #####:  207:        strideOp = rewriter.create<LLVM::MulOp>(
call    0 never executed
    #####:  208:            loc, memrefDescriptor.stride(rewriter, loc, i), byteWidthConst);
call    0 never executed
        -:  209:      } else {
        -:  210:        strideOp =
    #####:  211:            createI32Constant(rewriter, loc, strides[i] * elementByteWidth);
call    0 never executed
        -:  212:      }
    #####:  213:      index = rewriter.create<LLVM::MulOp>(loc, index, strideOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  215:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, index) : index;
call    0 never executed
call    1 never executed
        -:  216:    }
    #####:  217:    if (adaptor.getIndexOffset()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:      int32_t indexOffset = *gpuOp.getIndexOffset() * elementByteWidth;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  219:      Value extraOffsetConst = createI32Constant(rewriter, loc, indexOffset);
call    0 never executed
    #####:  220:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  221:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, extraOffsetConst)
call    0 never executed
        -:  222:                  : extraOffsetConst;
        -:  223:    }
    #####:  224:    args.push_back(voffset);
call    0 never executed
        -:  225:
    #####:  226:    Value sgprOffset = adaptor.getSgprOffset();
call    0 never executed
    #####:  227:    if (!sgprOffset)
branch  0 never executed
branch  1 never executed
    #####:  228:      sgprOffset = createI32Constant(rewriter, loc, 0);
call    0 never executed
    #####:  229:    if (ShapedType::isDynamicStrideOrOffset(offset))
branch  0 never executed
branch  1 never executed
    #####:  230:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  231:          loc, memrefDescriptor.offset(rewriter, loc), sgprOffset);
call    0 never executed
    #####:  232:    else if (offset > 0)
branch  0 never executed
branch  1 never executed
    #####:  233:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  234:          loc, sgprOffset, createI32Constant(rewriter, loc, offset));
call    0 never executed
    #####:  235:    args.push_back(sgprOffset);
call    0 never executed
        -:  236:
        -:  237:    // bit 0: GLC = 0 (atomics drop value, less coherency)
        -:  238:    // bits 1-2: SLC, DLC = 0 (similarly)
        -:  239:    // bit 3: swizzled (0 for raw)
    #####:  240:    args.push_back(createI32Constant(rewriter, loc, 0));
call    0 never executed
call    1 never executed
        -:  241:
    #####:  242:    llvm::SmallVector<Type, 1> resultTypes(gpuOp->getNumResults(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  243:                                           llvmBufferValType);
    #####:  244:    Operation *lowered = rewriter.create<Intrinsic>(loc, resultTypes, args,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  245:                                                    ArrayRef<NamedAttribute>());
    #####:  246:    if (lowered->getNumResults() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  247:      Value replacement = lowered->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:  248:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  249:        replacement = rewriter.create<LLVM::BitcastOp>(loc, llvmWantedDataType,
call    0 never executed
        -:  250:                                                       replacement);
        -:  251:      }
    #####:  252:      rewriter.replaceOp(gpuOp, replacement);
call    0 never executed
        -:  253:    } else {
    #####:  254:      rewriter.eraseOp(gpuOp);
call    0 never executed
        -:  255:    }
    #####:  256:    return success();
branch  0 never executed
branch  1 never executed
        -:  257:  }
------------------
_ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu21RawBufferAtomicFaddOpENS1_5ROCDL21RawBufferAtomicFAddOpEE15matchAndRewriteES3_NS2_28RawBufferAtomicFaddOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_119RawBufferOpLoweringIN4mlir6amdgpu21RawBufferAtomicFaddOpENS1_5ROCDL21RawBufferAtomicFAddOpEE15matchAndRewriteES3_NS2_28RawBufferAtomicFaddOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:   45:  matchAndRewrite(GpuOp gpuOp, typename GpuOp::Adaptor adaptor,
        -:   46:                  ConversionPatternRewriter &rewriter) const override {
    #####:   47:    Location loc = gpuOp.getLoc();
call    0 never executed
    #####:   48:    Value memref = adaptor.getMemref();
call    0 never executed
    #####:   49:    Value unconvertedMemref = gpuOp.getMemref();
call    0 never executed
    #####:   50:    MemRefType memrefType = unconvertedMemref.getType().cast<MemRefType>();
call    0 never executed
        -:   51:
    #####:   52:    if (chipset.majorVersion < 9)
branch  0 never executed
branch  1 never executed
    #####:   53:      return gpuOp.emitOpError("Raw buffer ops require GCN or higher");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   54:
    #####:   55:    Value storeData = adaptor.getODSOperands(0)[0];
call    0 never executed
call    1 never executed
    #####:   56:    if (storeData == memref) // no write component to this op
branch  0 never executed
branch  1 never executed
    #####:   57:      storeData = Value();
    #####:   58:    Type wantedDataType;
    #####:   59:    if (storeData)
branch  0 never executed
branch  1 never executed
    #####:   60:      wantedDataType = storeData.getType();
        -:   61:    else
    #####:   62:      wantedDataType = gpuOp.getODSResults(0)[0].getType();
call    0 never executed
call    1 never executed
        -:   63:
    #####:   64:    Type llvmWantedDataType = this->typeConverter->convertType(wantedDataType);
call    0 never executed
        -:   65:
    #####:   66:    Type i32 = rewriter.getI32Type();
call    0 never executed
    #####:   67:    Type llvmI32 = this->typeConverter->convertType(i32);
call    0 never executed
call    1 never executed
        -:   68:
    #####:   69:    int64_t elementByteWidth = memrefType.getElementTypeBitWidth() / 8;
    #####:   70:    Value byteWidthConst = createI32Constant(rewriter, loc, elementByteWidth);
call    0 never executed
        -:   71:
        -:   72:    // If we want to load a vector<NxT> with total size <= 32
        -:   73:    // bits, use a scalar load and bitcast it. Similarly, if bitsize(T) < 32
        -:   74:    // and the total load size is >= 32, use a vector load of N / (bitsize(T) /
        -:   75:    // 32) x i32 and bitcast.
    #####:   76:    Type llvmBufferValType = llvmWantedDataType;
call    0 never executed
    #####:   77:    if (auto dataVector = wantedDataType.dyn_cast<VectorType>()) {
branch  0 never executed
branch  1 never executed
    #####:   78:      uint32_t elemBits = dataVector.getElementTypeBitWidth();
    #####:   79:      uint32_t totalBits = elemBits * dataVector.getNumElements();
call    0 never executed
    #####:   80:      if (totalBits > maxVectorOpWidth)
branch  0 never executed
branch  1 never executed
        -:   81:        return gpuOp.emitOpError(
    #####:   82:            "Total width of loads or stores must be no more than " +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   83:            Twine(maxVectorOpWidth) + " bits, but we call for " +
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   84:            Twine(totalBits) +
call    0 never executed
call    1 never executed
    #####:   85:            " bits. This should've been caught in validation");
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   86:      if (elemBits < 32) {
branch  0 never executed
branch  1 never executed
    #####:   87:        if (totalBits > 32) {
branch  0 never executed
branch  1 never executed
    #####:   88:          if (totalBits % 32 != 0)
branch  0 never executed
branch  1 never executed
        -:   89:            return gpuOp.emitOpError("Load or store of more than 32-bits that "
    #####:   90:                                     "doesn't fit into words. Can't happen\n");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   91:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   92:              VectorType::get(totalBits / 32, i32));
call    0 never executed
        -:   93:        } else {
    #####:   94:          llvmBufferValType = this->typeConverter->convertType(
call    0 never executed
    #####:   95:              rewriter.getIntegerType(totalBits));
call    0 never executed
        -:   96:        }
        -:   97:      }
        -:   98:    }
        -:   99:
    #####:  100:    SmallVector<Value, 6> args;
    #####:  101:    if (storeData) {
branch  0 never executed
branch  1 never executed
    #####:  102:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  103:        Value castForStore =
    #####:  104:            rewriter.create<LLVM::BitcastOp>(loc, llvmBufferValType, storeData);
call    0 never executed
call    1 never executed
    #####:  105:        args.push_back(castForStore);
call    0 never executed
        -:  106:      } else {
    #####:  107:        args.push_back(storeData);
call    0 never executed
        -:  108:      }
        -:  109:    }
        -:  110:
        -:  111:    // Construct buffer descriptor from memref, attributes
    #####:  112:    int64_t offset = 0;
call    0 never executed
    #####:  113:    SmallVector<int64_t, 5> strides;
branch  0 never executed
branch  1 never executed
    #####:  114:    if (failed(getStridesAndOffset(memrefType, strides, offset)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  115:      return gpuOp.emitOpError("Can't lower non-stride-offset memrefs");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  116:
        -:  117:    // Resource descriptor
        -:  118:    // bits 0-47: base address
        -:  119:    // bits 48-61: stride (0 for raw buffers)
        -:  120:    // bit 62: texture cache coherency (always 0)
        -:  121:    // bit 63: enable swizzles (always off for raw buffers)
        -:  122:    // bits 64-95 (word 2): Number of records, units of stride
        -:  123:    // bits 96-127 (word 3): See below
        -:  124:
    #####:  125:    Type llvm4xI32 = this->typeConverter->convertType(VectorType::get(4, i32));
call    0 never executed
call    1 never executed
    #####:  126:    MemRefDescriptor memrefDescriptor(memref);
call    0 never executed
    #####:  127:    Type llvmI64 = this->typeConverter->convertType(rewriter.getI64Type());
call    0 never executed
call    1 never executed
    #####:  128:    Value c32I64 = rewriter.create<LLVM::ConstantOp>(
call    0 never executed
call    1 never executed
    #####:  129:        loc, llvmI64, rewriter.getI64IntegerAttr(32));
call    0 never executed
        -:  130:
    #####:  131:    Value resource = rewriter.create<LLVM::UndefOp>(loc, llvm4xI32);
call    0 never executed
call    1 never executed
        -:  132:
    #####:  133:    Value ptr = memrefDescriptor.alignedPtr(rewriter, loc);
call    0 never executed
    #####:  134:    Value ptrAsInt = rewriter.create<LLVM::PtrToIntOp>(loc, llvmI64, ptr);
call    0 never executed
call    1 never executed
    #####:  135:    Value lowHalf = rewriter.create<LLVM::TruncOp>(loc, llvmI32, ptrAsInt);
call    0 never executed
call    1 never executed
    #####:  136:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  137:        loc, llvm4xI32, resource, lowHalf,
        -:  138:        this->createIndexConstant(rewriter, loc, 0));
        -:  139:
        -:  140:    // Bits 48-63 are used both for the stride of the buffer and (on gfx10) for
        -:  141:    // enabling swizzling. Prevent the high bits of pointers from accidentally
        -:  142:    // setting those flags.
    #####:  143:    Value highHalfShifted = rewriter.create<LLVM::TruncOp>(
call    0 never executed
call    1 never executed
    #####:  144:        loc, llvmI32, rewriter.create<LLVM::LShrOp>(loc, ptrAsInt, c32I64));
call    0 never executed
    #####:  145:    Value highHalfTruncated = rewriter.create<LLVM::AndOp>(
call    0 never executed
call    1 never executed
        -:  146:        loc, llvmI32, highHalfShifted,
    #####:  147:        createI32Constant(rewriter, loc, 0x0000ffff));
call    0 never executed
    #####:  148:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  149:        loc, llvm4xI32, resource, highHalfTruncated,
        -:  150:        this->createIndexConstant(rewriter, loc, 1));
        -:  151:
    #####:  152:    Value numRecords;
    #####:  153:    if (memrefType.hasStaticShape()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  154:      numRecords = createI32Constant(
call    0 never executed
        -:  155:          rewriter, loc,
    #####:  156:          static_cast<int32_t>(memrefType.getNumElements() * elementByteWidth));
call    0 never executed
        -:  157:    } else {
    #####:  158:      Value maxIndex;
    #####:  159:      for (uint32_t i = 0, e = memrefType.getRank(); i < e; ++i) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:        Value size = memrefDescriptor.size(rewriter, loc, i);
call    0 never executed
    #####:  161:        Value stride = memrefDescriptor.stride(rewriter, loc, i);
call    0 never executed
    #####:  162:        stride = rewriter.create<LLVM::MulOp>(loc, stride, byteWidthConst);
call    0 never executed
call    1 never executed
    #####:  163:        Value maxThisDim = rewriter.create<LLVM::MulOp>(loc, size, stride);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  164:        maxIndex = maxIndex ? rewriter.create<LLVM::MaximumOp>(loc, maxIndex,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  165:                                                               maxThisDim)
        -:  166:                            : maxThisDim;
        -:  167:      }
    #####:  168:      numRecords = rewriter.create<LLVM::TruncOp>(loc, llvmI32, maxIndex);
call    0 never executed
        -:  169:    }
    #####:  170:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  171:        loc, llvm4xI32, resource, numRecords,
        -:  172:        this->createIndexConstant(rewriter, loc, 2));
        -:  173:
        -:  174:    // Final word:
        -:  175:    // bits 0-11: dst sel, ignored by these intrinsics
        -:  176:    // bits 12-14: data format (ignored, must be nonzero, 7=float)
        -:  177:    // bits 15-18: data format (ignored, must be nonzero, 4=32bit)
        -:  178:    // bit 19: In nested heap (0 here)
        -:  179:    // bit 20: Behavior on unmap (0 means  "return 0 / ignore")
        -:  180:    // bits 21-22: Index stride for swizzles (N/A)
        -:  181:    // bit 23: Add thread ID (0)
        -:  182:    // bit 24: Reserved to 1 (RDNA) or 0 (CDNA)
        -:  183:    // bits 25-26: Reserved (0)
        -:  184:    // bit 27: Buffer is non-volatile (CDNA only)
        -:  185:    // bits 28-29: Out of bounds select (0 = structured, 1 = check index, 2 =
        -:  186:    //  none, 3 = either swizzles or testing against offset field) RDNA only
        -:  187:    // bits 30-31: Type (must be 0)
    #####:  188:    uint32_t word3 = (7 << 12) | (4 << 15);
    #####:  189:    if (chipset.majorVersion == 10) {
branch  0 never executed
branch  1 never executed
    #####:  190:      word3 |= (1 << 24);
    #####:  191:      uint32_t oob = adaptor.getBoundsCheck() ? 3 : 2;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  192:      word3 |= (oob << 28);
        -:  193:    }
    #####:  194:    Value word3Const = createI32Constant(rewriter, loc, word3);
call    0 never executed
    #####:  195:    resource = rewriter.create<LLVM::InsertElementOp>(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  196:        loc, llvm4xI32, resource, word3Const,
        -:  197:        this->createIndexConstant(rewriter, loc, 3));
    #####:  198:    args.push_back(resource);
call    0 never executed
        -:  199:
        -:  200:    // Indexing (voffset)
    #####:  201:    Value voffset;
    #####:  202:    for (auto &pair : llvm::enumerate(adaptor.getIndices())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  203:      size_t i = pair.index();
call    0 never executed
    #####:  204:      Value index = pair.value();
    #####:  205:      Value strideOp;
branch  0 never executed
branch  1 never executed
    #####:  206:      if (ShapedType::isDynamicStrideOrOffset(strides[i])) {
branch  0 never executed
branch  1 never executed
    #####:  207:        strideOp = rewriter.create<LLVM::MulOp>(
call    0 never executed
    #####:  208:            loc, memrefDescriptor.stride(rewriter, loc, i), byteWidthConst);
call    0 never executed
        -:  209:      } else {
        -:  210:        strideOp =
    #####:  211:            createI32Constant(rewriter, loc, strides[i] * elementByteWidth);
call    0 never executed
        -:  212:      }
    #####:  213:      index = rewriter.create<LLVM::MulOp>(loc, index, strideOp);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  214:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  215:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, index) : index;
call    0 never executed
call    1 never executed
        -:  216:    }
    #####:  217:    if (adaptor.getIndexOffset()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  218:      int32_t indexOffset = *gpuOp.getIndexOffset() * elementByteWidth;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  219:      Value extraOffsetConst = createI32Constant(rewriter, loc, indexOffset);
call    0 never executed
    #####:  220:      voffset =
branch  0 never executed
branch  1 never executed
    #####:  221:          voffset ? rewriter.create<LLVM::AddOp>(loc, voffset, extraOffsetConst)
call    0 never executed
        -:  222:                  : extraOffsetConst;
        -:  223:    }
    #####:  224:    args.push_back(voffset);
call    0 never executed
        -:  225:
    #####:  226:    Value sgprOffset = adaptor.getSgprOffset();
call    0 never executed
    #####:  227:    if (!sgprOffset)
branch  0 never executed
branch  1 never executed
    #####:  228:      sgprOffset = createI32Constant(rewriter, loc, 0);
call    0 never executed
    #####:  229:    if (ShapedType::isDynamicStrideOrOffset(offset))
branch  0 never executed
branch  1 never executed
    #####:  230:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  231:          loc, memrefDescriptor.offset(rewriter, loc), sgprOffset);
call    0 never executed
    #####:  232:    else if (offset > 0)
branch  0 never executed
branch  1 never executed
    #####:  233:      sgprOffset = rewriter.create<LLVM::AddOp>(
call    0 never executed
    #####:  234:          loc, sgprOffset, createI32Constant(rewriter, loc, offset));
call    0 never executed
    #####:  235:    args.push_back(sgprOffset);
call    0 never executed
        -:  236:
        -:  237:    // bit 0: GLC = 0 (atomics drop value, less coherency)
        -:  238:    // bits 1-2: SLC, DLC = 0 (similarly)
        -:  239:    // bit 3: swizzled (0 for raw)
    #####:  240:    args.push_back(createI32Constant(rewriter, loc, 0));
call    0 never executed
call    1 never executed
        -:  241:
    #####:  242:    llvm::SmallVector<Type, 1> resultTypes(gpuOp->getNumResults(),
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  243:                                           llvmBufferValType);
    #####:  244:    Operation *lowered = rewriter.create<Intrinsic>(loc, resultTypes, args,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  245:                                                    ArrayRef<NamedAttribute>());
    #####:  246:    if (lowered->getNumResults() == 1) {
branch  0 never executed
branch  1 never executed
    #####:  247:      Value replacement = lowered->getResult(0);
branch  0 never executed
branch  1 never executed
    #####:  248:      if (llvmBufferValType != llvmWantedDataType) {
branch  0 never executed
branch  1 never executed
    #####:  249:        replacement = rewriter.create<LLVM::BitcastOp>(loc, llvmWantedDataType,
call    0 never executed
        -:  250:                                                       replacement);
        -:  251:      }
    #####:  252:      rewriter.replaceOp(gpuOp, replacement);
call    0 never executed
        -:  253:    } else {
    #####:  254:      rewriter.eraseOp(gpuOp);
call    0 never executed
        -:  255:    }
    #####:  256:    return success();
branch  0 never executed
branch  1 never executed
        -:  257:  }
------------------
        -:  258:};
        -:  259:
        -:  260:struct LDSBarrierOpLowering : public ConvertOpToLLVMPattern<LDSBarrierOp> {
      532:  261:  using ConvertOpToLLVMPattern<LDSBarrierOp>::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  262:
        -:  263:  LogicalResult
function _ZNK12_GLOBAL__N_120LDSBarrierOpLowering15matchAndRewriteEN4mlir6amdgpu12LDSBarrierOpENS2_19LDSBarrierOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  264:  matchAndRewrite(LDSBarrierOp op, LDSBarrierOp::Adaptor adaptor,
        -:  265:                  ConversionPatternRewriter &rewriter) const override {
    #####:  266:    auto asmDialectAttr = LLVM::AsmDialectAttr::get(rewriter.getContext(),
    #####:  267:                                                    LLVM::AsmDialect::AD_ATT);
call    0 never executed
    #####:  268:    const char *asmStr = "s_waitcnt lgkmcnt(0)\ns_barrier";
    #####:  269:    const char *constraints = "";
    #####:  270:    rewriter.replaceOpWithNewOp<LLVM::InlineAsmOp>(
        -:  271:        op,
    #####:  272:        /*resultTypes=*/TypeRange(), /*operands=*/ValueRange(),
call    0 never executed
call    1 never executed
    #####:  273:        /*asm_string=*/asmStr, constraints, /*has_side_effects=*/true,
    #####:  274:        /*is_align_stack=*/false, /*asm_dialect=*/asmDialectAttr,
call    0 never executed
    #####:  275:        /*operand_attrs=*/ArrayAttr());
call    0 never executed
call    1 never executed
    #####:  276:    return success();
        -:  277:  }
        -:  278:};
        -:  279:} // namespace
        -:  280:
        -:  281:/// If `input` is a vector of bytes, concatentate those bytes in little-endian
        -:  282:/// order to form a single integer of size 8 * [vector length]. This works
        -:  283:/// around a wart in the AMDGPU intrinsics where operations that logically take
        -:  284:/// vectors of bytes instead integers. Since we do not want to expose this
        -:  285:/// implementation detail to MLIR, we correct for it here.
function _ZL18mfmaConcatIfNeededRN4mlir25ConversionPatternRewriterENS_8LocationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  286:static Value mfmaConcatIfNeeded(ConversionPatternRewriter &rewriter,
        -:  287:                                Location loc, Value input) {
    #####:  288:  Type inputType = input.getType();
call    0 never executed
    #####:  289:  if (auto vectorType = inputType.dyn_cast<VectorType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  290:    if (!vectorType.getElementType().isInteger(8))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  291:      return input;
    #####:  292:    int64_t numBytes = vectorType.getNumElements();
call    0 never executed
    #####:  293:    Type destType = rewriter.getIntegerType(numBytes * 8);
call    0 never executed
    #####:  294:    Value result = rewriter.createOrFold<LLVM::ConstantOp>(
    #####:  295:        loc, destType, rewriter.getIntegerAttr(destType, 0));
call    0 never executed
call    1 never executed
    #####:  296:    for (int64_t i = 0; i < numBytes; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  297:      Value idxConst = createI32Constant(rewriter, loc, i);
call    0 never executed
    #####:  298:      Value element =
    #####:  299:          rewriter.create<LLVM::ExtractElementOp>(loc, input, idxConst);
call    0 never executed
call    1 never executed
    #####:  300:      Value extended = rewriter.create<LLVM::ZExtOp>(loc, destType, element);
call    0 never executed
call    1 never executed
    #####:  301:      Value shiftConst = rewriter.createOrFold<LLVM::ConstantOp>(
    #####:  302:          loc, destType, rewriter.getIntegerAttr(destType, i * 8));
call    0 never executed
call    1 never executed
    #####:  303:      Value shifted = rewriter.create<LLVM::ShlOp>(loc, extended, shiftConst);
call    0 never executed
call    1 never executed
    #####:  304:      result = rewriter.create<LLVM::OrOp>(loc, result, shifted);
call    0 never executed
        -:  305:    }
    #####:  306:    return result;
        -:  307:  }
    #####:  308:  return input;
        -:  309:}
        -:  310:
        -:  311:/// Return the `rocdl` intrinsic corresponding to a MFMA operation `mfma`
        -:  312:/// if one exists. This includes checking to ensure the intrinsic is supported
        -:  313:/// on the architecture you are compiling for.
        -:  314:static Optional<StringRef> mfmaOpToIntrinsic(MFMAOp mfma, Chipset chipset) {
        -:  315:  uint32_t m = mfma.getM(), n = mfma.getN(), k = mfma.getK(),
        -:  316:           b = mfma.getBlocks();
        -:  317:  Type sourceElem = mfma.getSourceA().getType();
        -:  318:  if (auto sourceType = sourceElem.dyn_cast<VectorType>())
        -:  319:    sourceElem = sourceType.getElementType();
        -:  320:  Type destElem = mfma.getDestC().getType();
        -:  321:  if (auto destType = destElem.dyn_cast<VectorType>())
        -:  322:    destElem = destType.getElementType();
        -:  323:
        -:  324:  if (sourceElem.isF32() && destElem.isF32()) {
        -:  325:    if (mfma.getReducePrecision() && chipset.minorVersion >= 0x40) {
        -:  326:      if (m == 32 && n == 32 && k == 4 && b == 1)
        -:  327:        return ROCDL::mfma_f32_32x32x4_xf32::getOperationName();
        -:  328:      if (m == 16 && n == 16 && k == 8 && b == 1)
        -:  329:        return ROCDL::mfma_f32_16x16x8_xf32::getOperationName();
        -:  330:    }
        -:  331:    if (m == 32 && n == 32 && k == 1 && b == 2)
        -:  332:      return ROCDL::mfma_f32_32x32x1f32::getOperationName();
        -:  333:    if (m == 16 && n == 16 && k == 1 && b == 4)
        -:  334:      return ROCDL::mfma_f32_16x16x1f32::getOperationName();
        -:  335:    if (m == 4 && n == 4 && k == 1 && b == 16)
        -:  336:      return ROCDL::mfma_f32_4x4x1f32::getOperationName();
        -:  337:    if (m == 32 && n == 32 && k == 2 && b == 1)
        -:  338:      return ROCDL::mfma_f32_32x32x2f32::getOperationName();
        -:  339:    if (m == 16 && n == 16 && k == 4 && b == 1)
        -:  340:      return ROCDL::mfma_f32_16x16x4f32::getOperationName();
        -:  341:  }
        -:  342:
        -:  343:  if (sourceElem.isF16() && destElem.isF32()) {
        -:  344:    if (m == 32 && n == 32 && k == 4 && b == 2)
        -:  345:      return ROCDL::mfma_f32_32x32x4f16::getOperationName();
        -:  346:    if (m == 16 && n == 16 && k == 4 && b == 4)
        -:  347:      return ROCDL::mfma_f32_16x16x4f16::getOperationName();
        -:  348:    if (m == 4 && n == 4 && k == 4 && b == 16)
        -:  349:      return ROCDL::mfma_f32_4x4x4f16::getOperationName();
        -:  350:    if (m == 32 && n == 32 && k == 8 && b == 1)
        -:  351:      return ROCDL::mfma_f32_32x32x8f16::getOperationName();
        -:  352:    if (m == 16 && n == 16 && k == 16 && b == 1)
        -:  353:      return ROCDL::mfma_f32_16x16x16f16::getOperationName();
        -:  354:  }
        -:  355:
        -:  356:  if (sourceElem.isBF16() && destElem.isF32() && chipset.minorVersion >= 0x0a) {
        -:  357:    if (m == 32 && n == 32 && k == 4 && b == 2)
        -:  358:      return ROCDL::mfma_f32_32x32x4bf16_1k::getOperationName();
        -:  359:    if (m == 16 && n == 16 && k == 4 && b == 4)
        -:  360:      return ROCDL::mfma_f32_16x16x4bf16_1k::getOperationName();
        -:  361:    if (m == 4 && n == 4 && k == 4 && b == 16)
        -:  362:      return ROCDL::mfma_f32_4x4x4bf16_1k::getOperationName();
        -:  363:    if (m == 32 && n == 32 && k == 8 && b == 1)
        -:  364:      return ROCDL::mfma_f32_32x32x8bf16_1k::getOperationName();
        -:  365:    if (m == 16 && n == 16 && k == 16 && b == 1)
        -:  366:      return ROCDL::mfma_f32_16x16x16bf16_1k::getOperationName();
        -:  367:  }
        -:  368:
        -:  369:  if (sourceElem.isBF16() && destElem.isF32()) {
        -:  370:    if (m == 32 && n == 32 && k == 2 && b == 2)
        -:  371:      return ROCDL::mfma_f32_32x32x2bf16::getOperationName();
        -:  372:    if (m == 16 && n == 16 && k == 2 && b == 4)
        -:  373:      return ROCDL::mfma_f32_16x16x2bf16::getOperationName();
        -:  374:    if (m == 4 && n == 4 && k == 2 && b == 16)
        -:  375:      return ROCDL::mfma_f32_4x4x2bf16::getOperationName();
        -:  376:    if (m == 32 && n == 32 && k == 4 && b == 1)
        -:  377:      return ROCDL::mfma_f32_32x32x4bf16::getOperationName();
        -:  378:    if (m == 16 && n == 16 && k == 8 && b == 1)
        -:  379:      return ROCDL::mfma_f32_16x16x8bf16::getOperationName();
        -:  380:  }
        -:  381:
        -:  382:  if (sourceElem.isa<IntegerType>() && destElem.isInteger(32)) {
        -:  383:    if (m == 32 && n == 32 && k == 4 && b == 2)
        -:  384:      return ROCDL::mfma_i32_32x32x4i8::getOperationName();
        -:  385:    if (m == 16 && n == 16 && k == 4 && b == 4)
        -:  386:      return ROCDL::mfma_i32_16x16x4i8::getOperationName();
        -:  387:    if (m == 4 && n == 4 && k == 4 && b == 16)
        -:  388:      return ROCDL::mfma_i32_4x4x4i8::getOperationName();
        -:  389:    if (m == 32 && n == 32 && k == 8 && b == 1)
        -:  390:      return ROCDL::mfma_i32_32x32x8i8::getOperationName();
        -:  391:    if (m == 16 && n == 16 && k == 16 && b == 1)
        -:  392:      return ROCDL::mfma_i32_16x16x16i8::getOperationName();
        -:  393:    if (m == 32 && n == 32 && k == 16 && b == 1 && chipset.minorVersion >= 0x40)
        -:  394:      return ROCDL::mfma_i32_32x32x16_i8::getOperationName();
        -:  395:    if (m == 16 && n == 16 && k == 32 && b == 1 && chipset.minorVersion >= 0x40)
        -:  396:      return ROCDL::mfma_i32_16x16x32_i8::getOperationName();
        -:  397:  }
        -:  398:
        -:  399:  if (sourceElem.isF64() && destElem.isF64() && chipset.minorVersion >= 0x0a) {
        -:  400:    if (m == 16 && n == 16 && k == 4 && b == 1)
        -:  401:      return ROCDL::mfma_f64_16x16x4f64::getOperationName();
        -:  402:    if (m == 4 && n == 4 && k == 4 && b == 4)
        -:  403:      return ROCDL::mfma_f64_4x4x4f64::getOperationName();
        -:  404:  }
        -:  405:  return None;
        -:  406:}
        -:  407:
        -:  408:namespace {
        -:  409:struct MFMAOpLowering : public ConvertOpToLLVMPattern<MFMAOp> {
function _ZN12_GLOBAL__N_114MFMAOpLoweringC2ERN4mlir17LLVMTypeConverterENS1_6amdgpu7ChipsetE called 532 returned 100% blocks executed 100%
      532:  410:  MFMAOpLowering(LLVMTypeConverter &converter, Chipset chipset)
      532:  411:      : ConvertOpToLLVMPattern<MFMAOp>(converter), chipset(chipset) {}
call    0 returned 100%
call    1 returned 100%
        -:  412:
        -:  413:  Chipset chipset;
        -:  414:
        -:  415:  LogicalResult
function _ZNK12_GLOBAL__N_114MFMAOpLowering15matchAndRewriteEN4mlir6amdgpu6MFMAOpENS2_13MFMAOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  416:  matchAndRewrite(MFMAOp op, MFMAOpAdaptor adaptor,
        -:  417:                  ConversionPatternRewriter &rewriter) const override {
    #####:  418:    Location loc = op.getLoc();
call    0 never executed
    #####:  419:    Type outType = typeConverter->convertType(op.getDestD().getType());
call    0 never executed
call    1 never executed
        -:  420:
    #####:  421:    if (chipset.majorVersion != 9 || chipset.minorVersion < 0x08)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  422:      return op->emitOpError("MFMA only supported on gfx908+");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  423:    uint32_t getBlgpField = static_cast<uint32_t>(op.getBlgp());
call    0 never executed
    #####:  424:    if (op.getNegateA() || op.getNegateB() || op.getNegateC()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  425:      if (chipset.minorVersion < 0x40)
branch  0 never executed
branch  1 never executed
    #####:  426:        return op.emitOpError("negation unsupported on older than gfx840");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  427:      getBlgpField |=
    #####:  428:          op.getNegateA() | (op.getNegateB() << 1) | (op.getNegateC() << 2);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  429:    }
    #####:  430:    Optional<StringRef> maybeIntrinsic = mfmaOpToIntrinsic(op, chipset);
call    0 never executed
    #####:  431:    if (!maybeIntrinsic.has_value())
branch  0 never executed
branch  1 never executed
    #####:  432:      return op.emitOpError("no intrinsic matching MFMA size on given chipset");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  433:    OperationState loweredOp(loc, *maybeIntrinsic);
call    0 never executed
call    1 never executed
    #####:  434:    loweredOp.addTypes(outType);
call    0 never executed
    #####:  435:    loweredOp.addOperands(
call    0 never executed
call    1 never executed
    #####:  436:        {mfmaConcatIfNeeded(rewriter, loc, adaptor.getSourceA()),
call    0 never executed
call    1 never executed
    #####:  437:         mfmaConcatIfNeeded(rewriter, loc, adaptor.getSourceB()),
call    0 never executed
call    1 never executed
    #####:  438:         adaptor.getDestC(), createI32Constant(rewriter, loc, op.getCbsz()),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  439:         createI32Constant(rewriter, loc, op.getAbid()),
call    0 never executed
call    1 never executed
    #####:  440:         createI32Constant(rewriter, loc, getBlgpField)});
call    0 never executed
    #####:  441:    Operation *lowered = rewriter.create(loweredOp);
call    0 never executed
    #####:  442:    rewriter.replaceOp(op, lowered->getResults());
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  443:    return success();
call    0 never executed
        -:  444:  }
        -:  445:};
        -:  446:
    #####:  447:struct ConvertAMDGPUToROCDLPass
call    0 never executed
        -:  448:    : public impl::ConvertAMDGPUToROCDLBase<ConvertAMDGPUToROCDLPass> {
   129250:  449:  ConvertAMDGPUToROCDLPass() = default;
call    0 returned 100%
        -:  450:
function _ZN12_GLOBAL__N_124ConvertAMDGPUToROCDLPass14runOnOperationEv called 532 returned 100% blocks executed 61%
      532:  451:  void runOnOperation() override {
      532:  452:    MLIRContext *ctx = &getContext();
call    0 returned 100%
      532:  453:    FailureOr<Chipset> maybeChipset = Chipset::parse(chipset);
call    0 returned 100%
      532:  454:    if (failed(maybeChipset)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  455:      emitError(UnknownLoc::get(ctx), "Invalid chipset name: " + chipset);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
    #####:  456:      return signalPassFailure();
call    0 never executed
        -:  457:    }
        -:  458:
     1064:  459:    RewritePatternSet patterns(ctx);
call    0 returned 100%
     1064:  460:    LLVMTypeConverter converter(ctx);
call    0 returned 100%
call    1 returned 100%
      532:  461:    populateAMDGPUToROCDLConversionPatterns(converter, patterns, *maybeChipset);
call    0 returned 100%
     1064:  462:    LLVMConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      532:  463:    target.addIllegalDialect<::mlir::amdgpu::AMDGPUDialect>();
call    0 returned 100%
      532:  464:    target.addLegalDialect<::mlir::LLVM::LLVMDialect>();
call    0 returned 100%
      532:  465:    target.addLegalDialect<::mlir::ROCDL::ROCDLDialect>();
call    0 returned 100%
      532:  466:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      532:  467:                                      std::move(patterns))))
call    0 returned 100%
    #####:  468:      signalPassFailure();
call    0 never executed
        -:  469:  }
        -:  470:};
        -:  471:} // namespace
        -:  472:
function _ZN4mlir39populateAMDGPUToROCDLConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetENS_6amdgpu7ChipsetE called 532 returned 100% blocks executed 100%
      532:  473:void mlir::populateAMDGPUToROCDLConversionPatterns(LLVMTypeConverter &converter,
        -:  474:                                                   RewritePatternSet &patterns,
        -:  475:                                                   Chipset chipset) {
      532:  476:  patterns.add<LDSBarrierOpLowering>(converter);
call    0 returned 100%
      532:  477:  patterns.add<
        -:  478:      RawBufferOpLowering<RawBufferLoadOp, ROCDL::RawBufferLoadOp>,
        -:  479:      RawBufferOpLowering<RawBufferStoreOp, ROCDL::RawBufferStoreOp>,
        -:  480:      RawBufferOpLowering<RawBufferAtomicFaddOp, ROCDL::RawBufferAtomicFAddOp>,
      532:  481:      MFMAOpLowering>(converter, chipset);
call    0 returned 100%
      532:  482:}
        -:  483:
function _ZN4mlir30createConvertAMDGPUToROCDLPassEv called 129250 returned 100% blocks executed 100%
   129250:  484:std::unique_ptr<Pass> mlir::createConvertAMDGPUToROCDLPass() {
   129250:  485:  return std::make_unique<ConvertAMDGPUToROCDLPass>();
call    0 returned 100%
        -:  486:}
