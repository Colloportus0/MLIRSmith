        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/IR/SymbolTable.cpp
        -:    0:Graph:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/SymbolTable.cpp.gcno
        -:    0:Data:../tools/mlir/lib/IR/CMakeFiles/obj.MLIRIR.dir/SymbolTable.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- SymbolTable.cpp - MLIR Symbol Table Class --------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/IR/SymbolTable.h"
        -:   10:#include "mlir/IR/Builders.h"
        -:   11:#include "mlir/IR/OpImplementation.h"
        -:   12:#include "llvm/ADT/SetVector.h"
        -:   13:#include "llvm/ADT/SmallPtrSet.h"
        -:   14:#include "llvm/ADT/SmallString.h"
        -:   15:#include "llvm/ADT/StringSwitch.h"
        -:   16:
        -:   17:using namespace mlir;
        -:   18:
        -:   19:/// Return true if the given operation is unknown and may potentially define a
        -:   20:/// symbol table.
function _ZL31isPotentiallyUnknownSymbolTablePN4mlir9OperationE called 47514052 returned 100% blocks executed 83%
 47514052:   21:static bool isPotentiallyUnknownSymbolTable(Operation *op) {
 68662570:   22:  return op->getNumRegions() == 1 && !op->getDialect();
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   23:}
        -:   24:
        -:   25:/// Returns the string name of the given symbol, or null if this is not a
        -:   26:/// symbol.
 3836653*:   27:static StringAttr getNameIfSymbol(Operation *op) {
 3836653*:   28:  return op->getAttrOfType<StringAttr>(SymbolTable::getSymbolAttrName());
        -:   29:}
 9183444*:   30:static StringAttr getNameIfSymbol(Operation *op, StringAttr symbolAttrNameId) {
 9183444*:   31:  return op->getAttrOfType<StringAttr>(symbolAttrNameId);
        -:   32:}
        -:   33:
        -:   34:/// Computes the nested symbol reference attribute for the symbol 'symbolName'
        -:   35:/// that are usable within the symbol table operations from 'symbol' as far up
        -:   36:/// to the given operation 'within', where 'within' is an ancestor of 'symbol'.
        -:   37:/// Returns success if all references up to 'within' could be computed.
        -:   38:static LogicalResult
function _ZL25collectValidReferencesForPN4mlir9OperationENS_10StringAttrES1_RN4llvm15SmallVectorImplINS_13SymbolRefAttrEEE called 24092 returned 100% blocks executed 32%
    24092:   39:collectValidReferencesFor(Operation *symbol, StringAttr symbolName,
        -:   40:                          Operation *within,
        -:   41:                          SmallVectorImpl<SymbolRefAttr> &results) {
   24092*:   42:  assert(within->isAncestor(symbol) && "expected 'within' to be an ancestor");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
    24092:   43:  MLIRContext *ctx = symbol->getContext();
call    0 returned 100%
        -:   44:
    24092:   45:  auto leafRef = FlatSymbolRefAttr::get(symbolName);
call    0 returned 100%
    24092:   46:  results.push_back(leafRef);
call    0 returned 100%
        -:   47:
        -:   48:  // Early exit for when 'within' is the parent of 'symbol'.
    24092:   49:  Operation *symbolTableOp = symbol->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    24092:   50:  if (within == symbolTableOp)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    24092:   51:    return success();
        -:   52:
        -:   53:  // Collect references until 'symbolTableOp' reaches 'within'.
    #####:   54:  SmallVector<FlatSymbolRefAttr, 1> nestedRefs(1, leafRef);
call    0 never executed
    #####:   55:  StringAttr symbolNameId =
call    0 never executed
    #####:   56:      StringAttr::get(ctx, SymbolTable::getSymbolAttrName());
call    0 never executed
call    1 never executed
    #####:   57:  do {
        -:   58:    // Each parent of 'symbol' should define a symbol table.
    #####:   59:    if (!symbolTableOp->hasTrait<OpTrait::SymbolTable>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   60:      return failure();
        -:   61:    // Each parent of 'symbol' should also be a symbol.
    #####:   62:    StringAttr symbolTableName = getNameIfSymbol(symbolTableOp, symbolNameId);
call    0 never executed
    #####:   63:    if (!symbolTableName)
branch  0 never executed
branch  1 never executed
    #####:   64:      return failure();
    #####:   65:    results.push_back(SymbolRefAttr::get(symbolTableName, nestedRefs));
call    0 never executed
call    1 never executed
        -:   66:
    #####:   67:    symbolTableOp = symbolTableOp->getParentOp();
branch  0 never executed
branch  1 never executed
    #####:   68:    if (symbolTableOp == within)
branch  0 never executed
branch  1 never executed
        -:   69:      break;
    #####:   70:    nestedRefs.insert(nestedRefs.begin(),
call    0 never executed
    #####:   71:                      FlatSymbolRefAttr::get(symbolTableName));
call    0 never executed
        -:   72:  } while (true);
    #####:   73:  return success();
branch  0 never executed
branch  1 never executed
        -:   74:}
        -:   75:
        -:   76:/// Walk all of the operations within the given set of regions, without
        -:   77:/// traversing into any nested symbol tables. Stops walking if the result of the
        -:   78:/// callback is anything other than `WalkResult::advance`.
        -:   79:static Optional<WalkResult>
function _ZL15walkSymbolTableN4llvm15MutableArrayRefIN4mlir6RegionEEENS_12function_refIFNS_8OptionalINS1_10WalkResultEEEPNS1_9OperationEEEE called 528261 returned 100% blocks executed 100%
   528261:   80:walkSymbolTable(MutableArrayRef<Region> regions,
        -:   81:                function_ref<Optional<WalkResult>(Operation *)> callback) {
   528261:   82:  SmallVector<Region *, 1> worklist(llvm::make_pointer_range(regions));
call    0 returned 100%
 10250847:   83:  while (!worklist.empty()) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
299353845:   84:    for (Operation &op : worklist.pop_back_val()->getOps()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 97% (fallthrough)
branch  3 taken 3%
call    4 returned 100%
279898812:   85:      Optional<WalkResult> result = callback(&op);
call    0 returned 100%
279898812:   86:      if (result != WalkResult::advance())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     9861:   87:        return result;
        -:   88:
        -:   89:      // If this op defines a new symbol table scope, we can't traverse. Any
        -:   90:      // symbol references nested within 'op' are different semantically.
279888951:   91:      if (!op.hasTrait<OpTrait::SymbolTable>()) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 1%
365697208:   92:        for (Region &region : op.getRegions())
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
  9420894:   93:          worklist.push_back(&region);
call    0 returned 100%
        -:   94:      }
        -:   95:    }
        -:   96:  }
   518400:   97:  return WalkResult::advance();
        -:   98:}
        -:   99:
        -:  100:/// Walk all of the operations nested under, and including, the given operation,
        -:  101:/// without traversing into any nested symbol tables. Stops walking if the
        -:  102:/// result of the callback is anything other than `WalkResult::advance`.
        -:  103:static Optional<WalkResult>
function _ZL15walkSymbolTablePN4mlir9OperationEN4llvm12function_refIFNS2_8OptionalINS_10WalkResultEEES1_EEE called 0 returned 0% blocks executed 0%
    #####:  104:walkSymbolTable(Operation *op,
        -:  105:                function_ref<Optional<WalkResult>(Operation *)> callback) {
    #####:  106:  Optional<WalkResult> result = callback(op);
call    0 never executed
    #####:  107:  if (result != WalkResult::advance() || op->hasTrait<OpTrait::SymbolTable>())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  108:    return result;
    #####:  109:  return walkSymbolTable(op->getRegions(), callback);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  110:}
        -:  111:
        -:  112://===----------------------------------------------------------------------===//
        -:  113:// SymbolTable
        -:  114://===----------------------------------------------------------------------===//
        -:  115:
        -:  116:/// Build a symbol table with the symbols within the given operation.
function _ZN4mlir11SymbolTableC2EPNS_9OperationE called 342567 returned 100% blocks executed 81%
   342567:  117:SymbolTable::SymbolTable(Operation *symbolTableOp)
   342567:  118:    : symbolTableOp(symbolTableOp) {
call    0 returned 100%
  342567*:  119:  assert(symbolTableOp->hasTrait<OpTrait::SymbolTable>() &&
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  120:         "expected operation to have SymbolTable trait");
  342567*:  121:  assert(symbolTableOp->getNumRegions() == 1 &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  122:         "expected operation to have a single region");
  342567*:  123:  assert(llvm::hasSingleElement(symbolTableOp->getRegion(0)) &&
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 never executed
        -:  124:         "expected operation to have a single block");
        -:  125:
   342567:  126:  StringAttr symbolNameId = StringAttr::get(symbolTableOp->getContext(),
call    0 returned 100%
   342567:  127:                                            SymbolTable::getSymbolAttrName());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
  9248918:  128:  for (auto &op : symbolTableOp->getRegion(0).front()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
call    4 returned 100%
  8906351:  129:    StringAttr name = getNameIfSymbol(&op, symbolNameId);
call    0 returned 100%
 8906351*:  130:    if (!name)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  131:      continue;
        -:  132:
  8906351:  133:    auto inserted = symbolTable.insert({name, &op});
call    0 returned 100%
  8906351:  134:    (void)inserted;
 8906351*:  135:    assert(inserted.second &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  136:           "expected region to contain uniquely named symbol operations");
        -:  137:  }
   342567:  138:}
        -:  139:
        -:  140:/// Look up a symbol with the specified name, returning null if no such name
        -:  141:/// exists. Names never include the @ on them.
function _ZNK4mlir11SymbolTable6lookupEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####:  142:Operation *SymbolTable::lookup(StringRef name) const {
    #####:  143:  return lookup(StringAttr::get(symbolTableOp->getContext(), name));
call    0 never executed
call    1 never executed
call    2 never executed
        -:  144:}
function _ZNK4mlir11SymbolTable6lookupENS_10StringAttrE called 0 returned 0% blocks executed 0%
12946607*:  145:Operation *SymbolTable::lookup(StringAttr name) const {
    #####:  146:  return symbolTable.lookup(name);
call    0 never executed
call    1 never executed
        -:  147:}
        -:  148:
function _ZN4mlir11SymbolTable6removeEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  149:void SymbolTable::remove(Operation *op) {
    #####:  150:  StringAttr name = getNameIfSymbol(op);
call    0 never executed
    #####:  151:  assert(name && "expected valid 'name' attribute");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  152:  assert(op->getParentOp() == symbolTableOp &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  153:         "expected this operation to be inside of the operation with this "
        -:  154:         "SymbolTable");
        -:  155:
    #####:  156:  auto it = symbolTable.find(name);
call    0 never executed
    #####:  157:  if (it != symbolTable.end() && it->second == op)
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####:  158:    symbolTable.erase(it);
call    0 never executed
    #####:  159:}
        -:  160:
function _ZN4mlir11SymbolTable5eraseEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  161:void SymbolTable::erase(Operation *symbol) {
    #####:  162:  remove(symbol);
call    0 never executed
    #####:  163:  symbol->erase();
call    0 never executed
    #####:  164:}
        -:  165:
        -:  166:// TODO: Consider if this should be renamed to something like insertOrUpdate
        -:  167:/// Insert a new symbol into the table and associated operation if not already
        -:  168:/// there and rename it as necessary to avoid collisions. Return the name of
        -:  169:/// the symbol after insertion as attribute.
function _ZN4mlir11SymbolTable6insertEPNS_9OperationEN4llvm14ilist_iteratorINS3_12ilist_detail12node_optionsIS1_Lb1ELb0EvEELb0ELb0EEE called 1024 returned 100% blocks executed 53%
     1024:  170:StringAttr SymbolTable::insert(Operation *symbol, Block::iterator insertPt) {
        -:  171:  // The symbol cannot be the child of another op and must be the child of the
        -:  172:  // symbolTableOp after this.
        -:  173:  //
        -:  174:  // TODO: consider if SymbolTable's constructor should behave the same.
     2048:  175:  if (!symbol->getParentOp()) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  176:    auto &body = symbolTableOp->getRegion(0).front();
call    0 never executed
call    1 never executed
    #####:  177:    if (insertPt == Block::iterator()) {
branch  0 never executed
branch  1 never executed
    #####:  178:      insertPt = Block::iterator(body.end());
        -:  179:    } else {
    #####:  180:      assert((insertPt == body.end() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
        -:  181:              insertPt->getParentOp() == symbolTableOp) &&
        -:  182:             "expected insertPt to be in the associated module operation");
        -:  183:    }
        -:  184:    // Insert before the terminator, if any.
    #####:  185:    if (insertPt == Block::iterator(body.end()) && !body.empty() &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  186:        std::prev(body.end())->hasTrait<OpTrait::IsTerminator>())
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  187:      insertPt = std::prev(body.end());
branch  0 never executed
branch  1 never executed
        -:  188:
    #####:  189:    body.getOperations().insert(insertPt, symbol);
call    0 never executed
        -:  190:  }
    2048*:  191:  assert(symbol->getParentOp() == symbolTableOp &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  192:         "symbol is already inserted in another op");
        -:  193:
        -:  194:  // Add this symbol to the symbol table, uniquing the name if a conflict is
        -:  195:  // detected.
     1024:  196:  StringAttr name = getSymbolName(symbol);
call    0 returned 100%
     1024:  197:  if (symbolTable.insert({name, symbol}).second)
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
      512:  198:    return name;
        -:  199:  // If the symbol was already in the table, also return.
     1024:  200:  if (symbolTable.lookup(name) == symbol)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  201:    return name;
        -:  202:  // If a conflict was detected, then the symbol will not have been added to
        -:  203:  // the symbol table. Try suffixes until we get to a unique name that works.
      512:  204:  SmallString<128> nameBuffer(name.getValue());
call    0 returned 100%
call    1 returned 100%
      512:  205:  unsigned originalLength = nameBuffer.size();
call    0 returned 100%
        -:  206:
      512:  207:  MLIRContext *context = symbol->getContext();
call    0 returned 100%
        -:  208:
        -:  209:  // Iteratively try suffixes until we find one that isn't used.
      512:  210:  do {
      512:  211:    nameBuffer.resize(originalLength);
call    0 returned 100%
      512:  212:    nameBuffer += '_';
call    0 returned 100%
      512:  213:    nameBuffer += std::to_string(uniquingCounter++);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
      512:  214:  } while (!symbolTable.insert({StringAttr::get(context, nameBuffer), symbol})
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      512:  215:                .second);
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
      512:  216:  setSymbolName(symbol, nameBuffer);
call    0 returned 100%
      512:  217:  return getSymbolName(symbol);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  218:}
        -:  219:
        -:  220:/// Returns the name of the given symbol operation.
function _ZN4mlir11SymbolTable13getSymbolNameEPNS_9OperationE called 3836653 returned 100% blocks executed 75%
  3836653:  221:StringAttr SymbolTable::getSymbolName(Operation *symbol) {
  3836653:  222:  StringAttr name = getNameIfSymbol(symbol);
call    0 returned 100%
 3836653*:  223:  assert(name && "expected valid symbol name");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  3836653:  224:  return name;
        -:  225:}
        -:  226:
        -:  227:/// Sets the name of the given symbol operation.
function _ZN4mlir11SymbolTable13setSymbolNameEPNS_9OperationENS_10StringAttrE called 0 returned 0% blocks executed 0%
     512*:  228:void SymbolTable::setSymbolName(Operation *symbol, StringAttr name) {
     512*:  229:  symbol->setAttr(getSymbolAttrName(), name);
call    0 never executed
call    1 returned 100%
    #####:  230:}
        -:  231:
        -:  232:/// Returns the visibility of the given symbol operation.
function _ZN4mlir11SymbolTable19getSymbolVisibilityEPNS_9OperationE called 74823 returned 100% blocks executed 90%
    74823:  233:SymbolTable::Visibility SymbolTable::getSymbolVisibility(Operation *symbol) {
        -:  234:  // If the attribute doesn't exist, assume public.
    74823:  235:  StringAttr vis = symbol->getAttrOfType<StringAttr>(getVisibilityAttrName());
call    0 returned 100%
    74823:  236:  if (!vis)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  237:    return Visibility::Public;
        -:  238:
        -:  239:  // Otherwise, switch on the string value.
      454:  240:  return StringSwitch<Visibility>(vis.getValue())
call    0 returned 100%
call    1 returned 100%
      454:  241:      .Case("private", Visibility::Private)
call    0 returned 100%
call    1 returned 100%
      454:  242:      .Case("nested", Visibility::Nested)
call    0 returned 100%
call    1 returned 100%
      454:  243:      .Case("public", Visibility::Public);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  244:}
        -:  245:/// Sets the visibility of the given symbol operation.
function _ZN4mlir11SymbolTable19setSymbolVisibilityEPNS_9OperationENS0_10VisibilityE called 12662 returned 100% blocks executed 60%
    12662:  246:void SymbolTable::setSymbolVisibility(Operation *symbol, Visibility vis) {
    12662:  247:  MLIRContext *ctx = symbol->getContext();
call    0 returned 100%
        -:  248:
        -:  249:  // If the visibility is public, just drop the attribute as this is the
        -:  250:  // default.
    12662:  251:  if (vis == Visibility::Public) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  252:    symbol->removeAttr(StringAttr::get(ctx, getVisibilityAttrName()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  253:    return;
        -:  254:  }
        -:  255:
        -:  256:  // Otherwise, update the attribute.
   12662*:  257:  assert((vis == Visibility::Private || vis == Visibility::Nested) &&
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  258:         "unknown symbol visibility kind");
        -:  259:
    12662:  260:  StringRef visName = vis == Visibility::Private ? "private" : "nested";
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    12662:  261:  symbol->setAttr(getVisibilityAttrName(), StringAttr::get(ctx, visName));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  262:}
        -:  263:
        -:  264:/// Returns the nearest symbol table from a given operation `from`. Returns
        -:  265:/// nullptr if no valid parent symbol table could be found.
function _ZN4mlir11SymbolTable21getNearestSymbolTableEPNS_9OperationE called 10198671 returned 100% blocks executed 85%
 10198671:  266:Operation *SymbolTable::getNearestSymbolTable(Operation *from) {
10198671*:  267:  assert(from && "expected valid operation");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 10198671:  268:  if (isPotentiallyUnknownSymbolTable(from))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  269:    return nullptr;
        -:  270:
 30521162:  271:  while (!from->hasTrait<OpTrait::SymbolTable>()) {
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
20322491*:  272:    from = from->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  273:
        -:  274:    // Check that this is a valid op and isn't an unknown symbol table.
 20322491:  275:    if (!from || isPotentiallyUnknownSymbolTable(from))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
    #####:  276:      return nullptr;
        -:  277:  }
        -:  278:  return from;
        -:  279:}
        -:  280:
        -:  281:/// Walks all symbol table operations nested within, and including, `op`. For
        -:  282:/// each symbol table operation, the provided callback is invoked with the op
        -:  283:/// and a boolean signifying if the symbols within that symbol table can be
        -:  284:/// treated as if all uses are visible. `allSymUsesVisible` identifies whether
        -:  285:/// all of the symbol uses of symbols within `op` are visible.
function _ZN4mlir11SymbolTable16walkSymbolTablesEPNS_9OperationEbN4llvm12function_refIFvS2_bEEE called 2834426 returned 100% blocks executed 92%
  2834426:  286:void SymbolTable::walkSymbolTables(
        -:  287:    Operation *op, bool allSymUsesVisible,
        -:  288:    function_ref<void(Operation *, bool)> callback) {
  2834426:  289:  bool isSymbolTable = op->hasTrait<OpTrait::SymbolTable>();
call    0 returned 100%
  2834426:  290:  if (isSymbolTable) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     3622:  291:    SymbolOpInterface symbol = dyn_cast<SymbolOpInterface>(op);
call    0 returned 100%
     3652:  292:    allSymUsesVisible |= !symbol || symbol.isPrivate();
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  293:  } else {
        -:  294:    // Otherwise if 'op' is not a symbol table, any nested symbols are
        -:  295:    // guaranteed to be hidden.
        -:  296:    allSymUsesVisible = true;
        -:  297:  }
        -:  298:
  3710719:  299:  for (Region &region : op->getRegions())
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
branch  2 taken 3% (fallthrough)
branch  3 taken 97%
   410244:  300:    for (Block &block : region)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
  3143844:  301:      for (Operation &nestedOp : block)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
call    2 returned 100%
  2830834:  302:        walkSymbolTables(&nestedOp, allSymUsesVisible, callback);
call    0 returned 100%
        -:  303:
        -:  304:  // If 'op' had the symbol table trait, visit it after any nested symbol
        -:  305:  // tables.
  2834426:  306:  if (isSymbolTable)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
     3622:  307:    callback(op, allSymUsesVisible);
call    0 returned 100%
  2834426:  308:}
        -:  309:
        -:  310:/// Returns the operation registered with the given symbol name with the
        -:  311:/// regions of 'symbolTableOp'. 'symbolTableOp' is required to be an operation
        -:  312:/// with the 'OpTrait::SymbolTable' trait. Returns nullptr if no valid symbol
        -:  313:/// was found.
function _ZN4mlir11SymbolTable14lookupSymbolInEPNS_9OperationENS_10StringAttrE called 22829 returned 100% blocks executed 94%
    22829:  314:Operation *SymbolTable::lookupSymbolIn(Operation *symbolTableOp,
        -:  315:                                       StringAttr symbol) {
   22829*:  316:  assert(symbolTableOp->hasTrait<OpTrait::SymbolTable>());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    22829:  317:  Region &region = symbolTableOp->getRegion(0);
call    0 returned 100%
    22829:  318:  if (region.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  319:    return nullptr;
        -:  320:
        -:  321:  // Look for a symbol with the given name.
    22829:  322:  StringAttr symbolNameId = StringAttr::get(symbolTableOp->getContext(),
call    0 returned 100%
    22829:  323:                                            SymbolTable::getSymbolAttrName());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
   278139:  324:  for (auto &op : region.front())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
call    3 returned 100%
   277093:  325:    if (getNameIfSymbol(&op, symbolNameId) == symbol)
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
    21783:  326:      return &op;
        -:  327:  return nullptr;
        -:  328:}
function _ZN4mlir11SymbolTable14lookupSymbolInEPNS_9OperationENS_13SymbolRefAttrE called 20759 returned 100% blocks executed 86%
    20759:  329:Operation *SymbolTable::lookupSymbolIn(Operation *symbolTableOp,
        -:  330:                                       SymbolRefAttr symbol) {
    20759:  331:  SmallVector<Operation *, 4> resolvedSymbols;
call    0 returned 100%
    41518:  332:  if (failed(lookupSymbolIn(symbolTableOp, symbol, resolvedSymbols)))
        -:  333:    return nullptr;
    20759:  334:  return resolvedSymbols.back();
call    0 returned 100%
        -:  335:}
        -:  336:
        -:  337:/// Internal implementation of `lookupSymbolIn` that allows for specialized
        -:  338:/// implementations of the lookup function.
function _ZL18lookupSymbolInImplPN4mlir9OperationENS_13SymbolRefAttrERN4llvm15SmallVectorImplIS1_EENS3_12function_refIFS1_S1_NS_10StringAttrEEEE called 2937662 returned 100% blocks executed 32%
  2937662:  339:static LogicalResult lookupSymbolInImpl(
        -:  340:    Operation *symbolTableOp, SymbolRefAttr symbol,
        -:  341:    SmallVectorImpl<Operation *> &symbols,
        -:  342:    function_ref<Operation *(Operation *, StringAttr)> lookupSymbolFn) {
 2937662*:  343:  assert(symbolTableOp->hasTrait<OpTrait::SymbolTable>());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  344:
        -:  345:  // Lookup the root reference for this symbol.
  2937662:  346:  symbolTableOp = lookupSymbolFn(symbolTableOp, symbol.getRootReference());
call    0 returned 100%
call    1 returned 100%
  2937662:  347:  if (!symbolTableOp)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  348:    return failure();
  2937662:  349:  symbols.push_back(symbolTableOp);
call    0 returned 100%
        -:  350:
        -:  351:  // If there are no nested references, just return the root symbol directly.
  2937662:  352:  ArrayRef<FlatSymbolRefAttr> nestedRefs = symbol.getNestedReferences();
call    0 returned 100%
  2937662:  353:  if (nestedRefs.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2937662:  354:    return success();
        -:  355:
        -:  356:  // Verify that the root is also a symbol table.
    #####:  357:  if (!symbolTableOp->hasTrait<OpTrait::SymbolTable>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  358:    return failure();
        -:  359:
        -:  360:  // Otherwise, lookup each of the nested non-leaf references and ensure that
        -:  361:  // each corresponds to a valid symbol table.
    #####:  362:  for (FlatSymbolRefAttr ref : nestedRefs.drop_back()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  363:    symbolTableOp = lookupSymbolFn(symbolTableOp, ref.getAttr());
call    0 never executed
call    1 never executed
    #####:  364:    if (!symbolTableOp || !symbolTableOp->hasTrait<OpTrait::SymbolTable>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  365:      return failure();
    #####:  366:    symbols.push_back(symbolTableOp);
call    0 never executed
        -:  367:  }
    #####:  368:  symbols.push_back(lookupSymbolFn(symbolTableOp, symbol.getLeafReference()));
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  369:  return success(symbols.back());
call    0 never executed
        -:  370:}
        -:  371:
        -:  372:LogicalResult
function _ZN4mlir11SymbolTable14lookupSymbolInEPNS_9OperationENS_13SymbolRefAttrERN4llvm15SmallVectorImplIS2_EE called 0 returned 0% blocks executed 0%
   20759*:  373:SymbolTable::lookupSymbolIn(Operation *symbolTableOp, SymbolRefAttr symbol,
        -:  374:                            SmallVectorImpl<Operation *> &symbols) {
   41518*:  375:  auto lookupFn = [](Operation *symbolTableOp, StringAttr symbol) {
    20759:  376:    return lookupSymbolIn(symbolTableOp, symbol);
call    0 returned 100%
        -:  377:  };
   20759*:  378:  return lookupSymbolInImpl(symbolTableOp, symbol, symbols, lookupFn);
call    0 never executed
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  379:}
        -:  380:
        -:  381:/// Returns the operation registered with the given symbol name within the
        -:  382:/// closes parent operation with the 'OpTrait::SymbolTable' trait. Returns
        -:  383:/// nullptr if no valid symbol was found.
function _ZN4mlir11SymbolTable23lookupNearestSymbolFromEPNS_9OperationENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####:  384:Operation *SymbolTable::lookupNearestSymbolFrom(Operation *from,
        -:  385:                                                StringAttr symbol) {
    #####:  386:  Operation *symbolTableOp = getNearestSymbolTable(from);
call    0 never executed
    #####:  387:  return symbolTableOp ? lookupSymbolIn(symbolTableOp, symbol) : nullptr;
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  388:}
function _ZN4mlir11SymbolTable23lookupNearestSymbolFromEPNS_9OperationENS_13SymbolRefAttrE called 20759 returned 100% blocks executed 100%
    20759:  389:Operation *SymbolTable::lookupNearestSymbolFrom(Operation *from,
        -:  390:                                                SymbolRefAttr symbol) {
    20759:  391:  Operation *symbolTableOp = getNearestSymbolTable(from);
call    0 returned 100%
    20759:  392:  return symbolTableOp ? lookupSymbolIn(symbolTableOp, symbol) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  393:}
        -:  394:
function _ZN4mlirlsERN4llvm11raw_ostreamENS_11SymbolTable10VisibilityE called 0 returned 0% blocks executed 0%
    #####:  395:raw_ostream &mlir::operator<<(raw_ostream &os,
        -:  396:                              SymbolTable::Visibility visibility) {
    #####:  397:  switch (visibility) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  398:  case SymbolTable::Visibility::Public:
    #####:  399:    return os << "public";
call    0 never executed
    #####:  400:  case SymbolTable::Visibility::Private:
    #####:  401:    return os << "private";
call    0 never executed
    #####:  402:  case SymbolTable::Visibility::Nested:
    #####:  403:    return os << "nested";
call    0 never executed
        -:  404:  }
    #####:  405:  llvm_unreachable("Unexpected visibility");
call    0 never executed
        -:  406:}
        -:  407:
        -:  408://===----------------------------------------------------------------------===//
        -:  409:// SymbolTable Trait Types
        -:  410://===----------------------------------------------------------------------===//
        -:  411:
function _ZN4mlir6detail17verifySymbolTableEPNS_9OperationE called 436543 returned 100% blocks executed 75%
   436543:  412:LogicalResult detail::verifySymbolTable(Operation *op) {
   436543:  413:  if (op->getNumRegions() != 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  414:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  415:           << "Operations with a 'SymbolTable' must have exactly one region";
call    0 never executed
  436543*:  416:  if (!llvm::hasSingleElement(op->getRegion(0)))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    #####:  417:    return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  418:           << "Operations with a 'SymbolTable' must have exactly one block";
call    0 never executed
        -:  419:
        -:  420:  // Check that all symbols are uniquely named within child regions.
   436543:  421:  DenseMap<Attribute, Location> nameToOrigLoc;
call    0 returned 100%
   873083:  422:  for (auto &block : op->getRegion(0)) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
  9244434:  423:    for (auto &op : block) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
call    2 returned 100%
        -:  424:      // Check for a symbol name attribute.
  8807894:  425:      auto nameAttr =
call    0 returned 100%
  8807894:  426:          op.getAttrOfType<StringAttr>(mlir::SymbolTable::getSymbolAttrName());
call    0 returned 100%
  8807894:  427:      if (!nameAttr)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    98868:  428:        continue;
        -:  429:
        -:  430:      // Try to insert this symbol into the table.
  8709026:  431:      auto it = nameToOrigLoc.try_emplace(nameAttr, op.getLoc());
call    0 returned 100%
  8709026:  432:      if (!it.second)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        6:  433:        return op.emitError()
call    0 returned 100%
call    1 returned 100%
        3:  434:            .append("redefinition of symbol named '", nameAttr.getValue(), "'")
call    0 returned 100%
call    1 returned 100%
        6:  435:            .attachNote(it.first->second)
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        3:  436:            .append("see existing symbol definition here");
call    0 returned 100%
        -:  437:    }
        -:  438:  }
        -:  439:
        -:  440:  // Verify any nested symbol user operations.
   873083:  441:  SymbolTableCollection symbolTable;
call    0 returned 100%
call    1 returned 100%
function _ZZN4mlir6detail17verifySymbolTableEPNS_9OperationEENKUlS2_E_clES2_.isra.0 called 262970491 returned 100% blocks executed 100%
262970491:  442:  auto verifySymbolUserFn = [&](Operation *op) -> Optional<WalkResult> {
262970491:  443:    if (SymbolUserOpInterface user = dyn_cast<SymbolUserOpInterface>(op))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
 25486790:  444:      return WalkResult(user.verifySymbolUses(symbolTable));
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
250227096:  445:    return WalkResult::advance();
   436540:  446:  };
        -:  447:
   436540:  448:  Optional<WalkResult> result =
   873080:  449:      walkSymbolTable(op->getRegions(), verifySymbolUserFn);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
   436540:  450:  return success(result && !result->wasInterrupted());
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
        -:  451:}
        -:  452:
function _ZN4mlir6detail12verifySymbolEPNS_9OperationE called 8258222 returned 96% blocks executed 31%
  8258222:  453:LogicalResult detail::verifySymbol(Operation *op) {
        -:  454:  // Verify the name attribute.
  8258222:  455:  if (!op->getAttrOfType<StringAttr>(mlir::SymbolTable::getSymbolAttrName()))
call    0 returned 98%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  456:    return op->emitOpError() << "requires string attribute '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  457:                             << mlir::SymbolTable::getSymbolAttrName() << "'";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  458:
        -:  459:  // Verify the visibility attribute.
  8079859:  460:  if (Attribute vis = op->getAttr(mlir::SymbolTable::getVisibilityAttrName())) {
call    0 returned 98%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
    36159:  461:    StringAttr visStrAttr = vis.dyn_cast<StringAttr>();
call    0 returned 100%
    36262:  462:    if (!visStrAttr)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  463:      return op->emitOpError() << "requires visibility attribute '"
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  464:                               << mlir::SymbolTable::getVisibilityAttrName()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  465:                               << "' to be a string attribute, but got " << vis;
call    0 never executed
call    1 never executed
        -:  466:
    37651:  467:    if (!llvm::is_contained(ArrayRef<StringRef>{"public", "private", "nested"},
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    36262:  468:                            visStrAttr.getValue()))
call    0 returned 104%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  469:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  470:             << "visibility expected to be one of [\"public\", \"private\", "
    #####:  471:                "\"nested\"], but got "
call    0 never executed
    #####:  472:             << visStrAttr;
call    0 never executed
        -:  473:  }
  7933599:  474:  return success();
        -:  475:}
        -:  476:
        -:  477://===----------------------------------------------------------------------===//
        -:  478:// Symbol Use Lists
        -:  479://===----------------------------------------------------------------------===//
        -:  480:
        -:  481:/// Walk all of the symbol references within the given operation, invoking the
        -:  482:/// provided callback for each found use. The callbacks takes the use of the
        -:  483:/// symbol.
        -:  484:static WalkResult
function _ZL14walkSymbolRefsPN4mlir9OperationEN4llvm12function_refIFNS_10WalkResultENS_11SymbolTable9SymbolUseEEEE called 16992890 returned 100% blocks executed 100%
 16992890:  485:walkSymbolRefs(Operation *op,
        -:  486:               function_ref<WalkResult(SymbolTable::SymbolUse)> callback) {
        -:  487:  // Check to see if the operation has any attributes.
 16992890:  488:  DictionaryAttr attrDict = op->getAttrDictionary();
call    0 returned 100%
 16992890:  489:  if (attrDict.empty())
call    0 returned 100%
branch  1 taken 36% (fallthrough)
branch  2 taken 64%
  6172867:  490:    return WalkResult::advance();
        -:  491:
        -:  492:  // A worklist of a container attribute and the current index into the held
        -:  493:  // attribute list.
35690877*:  494:  struct WorklistItem {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
branch 11 taken 2% (fallthrough)
branch 12 taken 98%
branch 13 taken 0% (fallthrough)
branch 14 taken 100%
        -:  495:    SubElementAttrInterface container;
        -:  496:    SmallVector<Attribute> immediateSubElements;
        -:  497:
function _ZZL14walkSymbolRefsPN4mlir9OperationEN4llvm12function_refIFNS_10WalkResultENS_11SymbolTable9SymbolUseEEEEEN12WorklistItemC2ENS_23SubElementAttrInterfaceE called 11717017 returned 100% blocks executed 83%
 11717017:  498:    explicit WorklistItem(SubElementAttrInterface container) {
call    0 returned 100%
call    1 returned 100%
 23434034:  499:      SmallVector<Attribute> subElements;
 11717017:  500:      container.walkImmediateSubElements(
call    0 returned 100%
 14864819:  501:          [&](Attribute attr) { subElements.push_back(attr); }, [](Type) {});
call    0 returned 100%
 11717017:  502:      immediateSubElements = std::move(subElements);
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
 11717017:  503:    }
        -:  504:  };
        -:  505:
 10820023:  506:  SmallVector<WorklistItem, 1> attrWorklist(1, WorklistItem(attrDict));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 2% (fallthrough)
branch  4 taken 98%
 21640046:  507:  SmallVector<int, 1> curAccessChain(1, /*Value=*/-1);
call    0 returned 100%
call    1 returned 100%
        -:  508:
        -:  509:  // Process the symbol references within the given nested attribute range.
function _ZZL14walkSymbolRefsPN4mlir9OperationEN4llvm12function_refIFNS_10WalkResultENS_11SymbolTable9SymbolUseEEEEENKUlRiRZL14walkSymbolRefsS1_S8_E12WorklistItemE_clES9_SB_ called 12614011 returned 100% blocks executed 85%
 23434034:  510:  auto processAttrs = [&](int &index,
        -:  511:                          WorklistItem &worklistItem) -> WalkResult {
 41423698:  512:    for (Attribute attr :
 39179438:  513:         llvm::drop_begin(worklistItem.immediateSubElements, index)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 56% (fallthrough)
branch  3 taken 44%
        -:  514:      // Invoke the provided callback if we find a symbol use and check for a
        -:  515:      // requested interrupt.
 14858271:  516:      if (auto symbolRef = attr.dyn_cast<SymbolRefAttr>()) {
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
   916164:  517:        if (callback({op, symbolRef}).wasInterrupted())
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
   906855:  518:          return WalkResult::interrupt();
        -:  519:
        -:  520:        /// Check for a nested container attribute, these will also need to be
        -:  521:        /// walked.
 13942107:  522:      } else if (auto interface = attr.dyn_cast<SubElementAttrInterface>()) {
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
   896994:  523:        attrWorklist.emplace_back(interface);
call    0 returned 100%
   896994:  524:        curAccessChain.push_back(-1);
call    0 returned 100%
   896994:  525:        return WalkResult::advance();
        -:  526:      }
        -:  527:      // Make sure to keep the index counter in sync.
 13951416:  528:      ++index;
        -:  529:    }
        -:  530:
        -:  531:    // Pop this container attribute from the worklist.
 11707156:  532:    attrWorklist.pop_back();
call    0 returned 100%
 11707156:  533:    curAccessChain.pop_back();
call    0 returned 100%
 11707156:  534:    return WalkResult::advance();
 10820023:  535:  };
        -:  536:
 10820023:  537:  WalkResult result = WalkResult::advance();
 12614011:  538:  do {
 12614011:  539:    WorklistItem &item = attrWorklist.back();
call    0 returned 100%
 12614011:  540:    int &index = curAccessChain.back();
call    0 returned 100%
 12614011:  541:    ++index;
        -:  542:
        -:  543:    // Process the given attribute, which is guaranteed to be a container.
 12614011:  544:    result = processAttrs(index, item);
call    0 returned 100%
 12614011:  545:  } while (!attrWorklist.empty() && !result.wasInterrupted());
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
branch  2 taken 99%
branch  3 taken 1% (fallthrough)
 10820023:  546:  return result;
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -:  547:}
        -:  548:
        -:  549:/// Walk all of the uses, for any symbol, that are nested within the given
        -:  550:/// regions, invoking the provided callback for each. This does not traverse
        -:  551:/// into any nested symbol tables.
        -:  552:static Optional<WalkResult>
   91721*:  553:walkSymbolUses(MutableArrayRef<Region> regions,
        -:  554:               function_ref<WalkResult(SymbolTable::SymbolUse)> callback) {
function _ZZL14walkSymbolUsesN4llvm15MutableArrayRefIN4mlir6RegionEEENS_12function_refIFNS1_10WalkResultENS1_11SymbolTable9SymbolUseEEEEENKUlPNS1_9OperationEE_clESB_.isra.0 called 16928321 returned 100% blocks executed 86%
16928321*:  555:  return walkSymbolTable(regions, [&](Operation *op) -> Optional<WalkResult> {
        -:  556:    // Check that this isn't a potentially unknown symbol table.
 16928321:  557:    if (isPotentiallyUnknownSymbolTable(op))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  558:      return llvm::None;
        -:  559:
 16928321:  560:    return walkSymbolRefs(op, callback);
call    0 returned 100%
   27169*:  561:  });
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
call    4 returned 100%
call    5 never executed
call    6 never executed
call    7 never executed
call    8 returned 100%
        -:  562:}
        -:  563:/// Walk all of the uses, for any symbol, that are nested within the given
        -:  564:/// operation 'from', invoking the provided callback for each. This does not
        -:  565:/// traverse into any nested symbol tables.
        -:  566:static Optional<WalkResult>
function _ZL14walkSymbolUsesPN4mlir9OperationEN4llvm12function_refIFNS_10WalkResultENS_11SymbolTable9SymbolUseEEEE called 64569 returned 100% blocks executed 86%
    64569:  567:walkSymbolUses(Operation *from,
        -:  568:               function_ref<WalkResult(SymbolTable::SymbolUse)> callback) {
        -:  569:  // If this operation has regions, and it, as well as its dialect, isn't
        -:  570:  // registered then conservatively fail. The operation may define a
        -:  571:  // symbol table, so we can't opaquely know if we should traverse to find
        -:  572:  // nested uses.
    64569:  573:  if (isPotentiallyUnknownSymbolTable(from))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  574:    return llvm::None;
        -:  575:
        -:  576:  // Walk the uses on this operation.
    64569:  577:  if (walkSymbolRefs(from, callback).wasInterrupted())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  578:    return WalkResult::interrupt();
        -:  579:
        -:  580:  // Only recurse if this operation is not a symbol table. A symbol table
        -:  581:  // defines a new scope, so we can't walk the attributes from within the symbol
        -:  582:  // table op.
    64569:  583:  if (!from->hasTrait<OpTrait::SymbolTable>())
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
   129104:  584:    return walkSymbolUses(from->getRegions(), callback);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
       17:  585:  return WalkResult::advance();
        -:  586:}
        -:  587:
        -:  588:namespace {
        -:  589:/// This class represents a single symbol scope. A symbol scope represents the
        -:  590:/// set of operations nested within a symbol table that may reference symbols
        -:  591:/// within that table. A symbol scope does not contain the symbol table
        -:  592:/// operation itself, just its contained operations. A scope ends at leaf
        -:  593:/// operations or another symbol table operation.
        -:  594:struct SymbolScope {
        -:  595:  /// Walk the symbol uses within this scope, invoking the given callback.
        -:  596:  /// This variant is used when the callback type matches that expected by
        -:  597:  /// 'walkSymbolUses'.
        -:  598:  template <typename CallbackT,
        -:  599:            std::enable_if_t<!std::is_same<
        -:  600:                typename llvm::function_traits<CallbackT>::result_t,
        -:  601:                void>::value> * = nullptr>
   24092*:  602:  Optional<WalkResult> walk(CallbackT cback) {
   48184*:  603:    if (Region *region = limit.dyn_cast<Region *>())
   24092*:  604:      return walkSymbolUses(*region, cback);
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIPN4mlir9OperationENS4_6RegionEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNSA_9SymbolUseEE_LPv0EEENS9_INS4_10WalkResultEEESD_EUlSG_E_LSI_0EEESK_SD_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIPN4mlir9OperationENS4_6RegionEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNSA_9SymbolUseEE_LPv0EEENS9_INS4_10WalkResultEEESD_EUlSG_E_LSI_0EEESK_SD_ called 9861 returned 100% blocks executed 67%
     9861:  602:  Optional<WalkResult> walk(CallbackT cback) {
   19722*:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     9861:  604:      return walkSymbolUses(*region, cback);
call    0 returned 100%
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIN4mlir10StringAttrENS4_6RegionEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIN4mlir10StringAttrENS4_6RegionEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIPN4mlir9OperationES5_EN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIPN4mlir9OperationES5_EN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIN4mlir10StringAttrENS4_9OperationEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZNS0_4walkIZ17getSymbolUsesImplIN4mlir10StringAttrENS4_9OperationEEN4llvm8OptionalINS4_11SymbolTable8UseRangeEEET_PT0_EUlNS9_9SymbolUseEE_LPv0EEENS8_INS4_10WalkResultEEESC_EUlSF_E_LSH_0EEESJ_SC_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIPN4mlir9OperationENS3_6RegionEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES7_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIPN4mlir9OperationENS3_6RegionEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES7_ called 14231 returned 100% blocks executed 67%
    14231:  602:  Optional<WalkResult> walk(CallbackT cback) {
   28462*:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    14231:  604:      return walkSymbolUses(*region, cback);
call    0 returned 100%
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIN4mlir10StringAttrENS3_6RegionEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIN4mlir10StringAttrENS3_6RegionEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIPN4mlir9OperationES4_EbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIPN4mlir9OperationES4_EbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIN4mlir10StringAttrENS3_9OperationEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_:
function _ZN12_GLOBAL__N_111SymbolScope4walkIZ23symbolKnownUseEmptyImplIN4mlir10StringAttrENS3_9OperationEEbT_PT0_EUlNS3_11SymbolTable9SymbolUseEE_LPv0EEEN4llvm8OptionalINS3_10WalkResultEEES6_ called 0 returned 0% blocks executed 0%
    #####:  602:  Optional<WalkResult> walk(CallbackT cback) {
    #####:  603:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  604:      return walkSymbolUses(*region, cback);
call    0 never executed
    #####:  605:    return walkSymbolUses(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  606:  }
------------------
        -:  607:  /// This variant is used when the callback type matches a stripped down type:
        -:  608:  /// void(SymbolTable::SymbolUse use)
        -:  609:  template <typename CallbackT,
        -:  610:            std::enable_if_t<std::is_same<
        -:  611:                typename llvm::function_traits<CallbackT>::result_t,
        -:  612:                void>::value> * = nullptr>
    9861*:  613:  Optional<WalkResult> walk(CallbackT cback) {
  381015*:  614:    return walk([=](SymbolTable::SymbolUse use) {
  381015*:  615:      return cback(use), WalkResult::advance();
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
    9861*:  616:    });
        -:  617:  }
        -:  618:
        -:  619:  /// Walk all of the operations nested under the current scope without
        -:  620:  /// traversing into any nested symbol tables.
        -:  621:  template <typename CallbackT>
    #####:  622:  Optional<WalkResult> walkSymbolTable(CallbackT &&cback) {
    #####:  623:    if (Region *region = limit.dyn_cast<Region *>())
    #####:  624:      return ::walkSymbolTable(*region, cback);
    #####:  625:    return ::walkSymbolTable(limit.get<Operation *>(), cback);
        -:  626:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIPN4mlir9OperationENS3_6RegionEENS3_13LogicalResultET_NS3_10StringAttrEPT0_EUlS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS8_:
function _ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIPN4mlir9OperationENS3_6RegionEENS3_13LogicalResultET_NS3_10StringAttrEPT0_EUlS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS8_ called 0 returned 0% blocks executed 0%
    #####:  622:  Optional<WalkResult> walkSymbolTable(CallbackT &&cback) {
    #####:  623:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  624:      return ::walkSymbolTable(*region, cback);
call    0 never executed
    #####:  625:    return ::walkSymbolTable(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  626:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIN4mlir10StringAttrENS3_6RegionEENS3_13LogicalResultET_S4_PT0_EUlPNS3_9OperationEE_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_:
function _ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIN4mlir10StringAttrENS3_6RegionEENS3_13LogicalResultET_S4_PT0_EUlPNS3_9OperationEE_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_ called 0 returned 0% blocks executed 0%
    #####:  622:  Optional<WalkResult> walkSymbolTable(CallbackT &&cback) {
    #####:  623:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  624:      return ::walkSymbolTable(*region, cback);
call    0 never executed
    #####:  625:    return ::walkSymbolTable(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  626:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIPN4mlir9OperationES4_ENS3_13LogicalResultET_NS3_10StringAttrEPT0_EUlS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_:
function _ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIPN4mlir9OperationES4_ENS3_13LogicalResultET_NS3_10StringAttrEPT0_EUlS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_ called 0 returned 0% blocks executed 0%
    #####:  622:  Optional<WalkResult> walkSymbolTable(CallbackT &&cback) {
    #####:  623:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  624:      return ::walkSymbolTable(*region, cback);
call    0 never executed
    #####:  625:    return ::walkSymbolTable(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  626:  }
------------------
_ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIN4mlir10StringAttrENS3_9OperationEENS3_13LogicalResultET_S4_PT0_EUlPS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_:
function _ZN12_GLOBAL__N_111SymbolScope15walkSymbolTableIRZ24replaceAllSymbolUsesImplIN4mlir10StringAttrENS3_9OperationEENS3_13LogicalResultET_S4_PT0_EUlPS5_E_EEN4llvm8OptionalINS3_10WalkResultEEEOS7_ called 0 returned 0% blocks executed 0%
    #####:  622:  Optional<WalkResult> walkSymbolTable(CallbackT &&cback) {
    #####:  623:    if (Region *region = limit.dyn_cast<Region *>())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  624:      return ::walkSymbolTable(*region, cback);
call    0 never executed
    #####:  625:    return ::walkSymbolTable(limit.get<Operation *>(), cback);
call    0 never executed
call    1 never executed
        -:  626:  }
------------------
        -:  627:
        -:  628:  /// The representation of the symbol within this scope.
        -:  629:  SymbolRefAttr symbol;
        -:  630:
        -:  631:  /// The IR unit representing this scope.
        -:  632:  llvm::PointerUnion<Operation *, Region *> limit;
        -:  633:};
        -:  634:} // namespace
        -:  635:
        -:  636:/// Collect all of the symbol scopes from 'symbol' to (inclusive) 'limit'.
function _ZL19collectSymbolScopesPN4mlir9OperationES1_ called 24092 returned 100% blocks executed 58%
    24092:  637:static SmallVector<SymbolScope, 2> collectSymbolScopes(Operation *symbol,
        -:  638:                                                       Operation *limit) {
    24092:  639:  StringAttr symName = SymbolTable::getSymbolName(symbol);
call    0 returned 100%
   24092*:  640:  assert(!symbol->hasTrait<OpTrait::SymbolTable>() || symbol != limit);
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  641:
        -:  642:  // Compute the ancestors of 'limit'.
    24092:  643:  SetVector<Operation *, SmallVector<Operation *, 4>,
call    0 returned 100%
        -:  644:            SmallPtrSet<Operation *, 4>>
    48184:  645:      limitAncestors;
    24092:  646:  Operation *limitAncestor = limit;
    24092:  647:  do {
        -:  648:    // Check to see if 'symbol' is an ancestor of 'limit'.
    24092:  649:    if (limitAncestor == symbol) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  650:      // Check that the nearest symbol table is 'symbol's parent. SymbolRefAttr
        -:  651:      // doesn't support parent references.
    #####:  652:      if (SymbolTable::getNearestSymbolTable(limit->getParentOp()) ==
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  653:          symbol->getParentOp())
branch  0 never executed
branch  1 never executed
    #####:  654:        return {{SymbolRefAttr::get(symName), limit}};
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  655:      return {};
        -:  656:    }
        -:  657:
    24092:  658:    limitAncestors.insert(limitAncestor);
call    0 returned 100%
    24092:  659:  } while ((limitAncestor = limitAncestor->getParentOp()));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
        -:  660:
        -:  661:  // Try to find the first ancestor of 'symbol' that is an ancestor of 'limit'.
    24092:  662:  Operation *commonAncestor = symbol->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    24092:  663:  do {
    24092:  664:    if (limitAncestors.count(commonAncestor))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  665:      break;
    #####:  666:  } while ((commonAncestor = commonAncestor->getParentOp()));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
   24092*:  667:  assert(commonAncestor && "'limit' and 'symbol' have no common ancestor");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  668:
        -:  669:  // Compute the set of valid nested references for 'symbol' as far up to the
        -:  670:  // common ancestor as possible.
    48184:  671:  SmallVector<SymbolRefAttr, 2> references;
call    0 returned 100%
call    1 returned 100%
    24092:  672:  bool collectedAllReferences = succeeded(
call    0 returned 100%
        -:  673:      collectValidReferencesFor(symbol, symName, commonAncestor, references));
        -:  674:
        -:  675:  // Handle the case where the common ancestor is 'limit'.
    24092:  676:  if (commonAncestor == limit) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    48184:  677:    SmallVector<SymbolScope, 2> scopes;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  678:
        -:  679:    // Walk each of the ancestors of 'symbol', calling the compute function for
        -:  680:    // each one.
    24092:  681:    Operation *limitIt = symbol->getParentOp();
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    48184:  682:    for (size_t i = 0, e = references.size(); i != e;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    24092:  683:         ++i, limitIt = limitIt->getParentOp()) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   24092*:  684:      assert(limitIt->hasTrait<OpTrait::SymbolTable>());
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
    24092:  685:      scopes.push_back({references[i], &limitIt->getRegion(0)});
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
        -:  686:    }
    48184:  687:    return scopes;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  688:  }
        -:  689:
        -:  690:  // Otherwise, we just need the symbol reference for 'symbol' that will be
        -:  691:  // used within 'limit'. This is the last reference in the list we computed
        -:  692:  // above if we were able to collect all references.
    #####:  693:  if (!collectedAllReferences)
branch  0 never executed
branch  1 never executed
   24092*:  694:    return {};
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  695:  return {{references.back(), limit}};
call    0 never executed
call    1 never executed
call    2 never executed
        -:  696:}
function _ZL19collectSymbolScopesPN4mlir9OperationEPNS_6RegionE called 24092 returned 100% blocks executed 100%
    24092:  697:static SmallVector<SymbolScope, 2> collectSymbolScopes(Operation *symbol,
        -:  698:                                                       Region *limit) {
    24092:  699:  auto scopes = collectSymbolScopes(symbol, limit->getParentOp());
call    0 returned 100%
        -:  700:
        -:  701:  // If we collected some scopes to walk, make sure to constrain the one for
        -:  702:  // limit to the specific region requested.
    24092:  703:  if (!scopes.empty())
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    24092:  704:    scopes.back().limit = limit;
call    0 returned 100%
call    1 returned 100%
    24092:  705:  return scopes;
        -:  706:}
        -:  707:template <typename IRUnit>
    #####:  708:static SmallVector<SymbolScope, 1> collectSymbolScopes(StringAttr symbol,
        -:  709:                                                       IRUnit *limit) {
    #####:  710:  return {{SymbolRefAttr::get(symbol), limit}};
        -:  711:}
------------------
_Z19collectSymbolScopesIN4mlir6RegionEEN4llvm11SmallVectorIN12_GLOBAL__N_111SymbolScopeELj1EEENS0_10StringAttrEPT_:
function _Z19collectSymbolScopesIN4mlir6RegionEEN4llvm11SmallVectorIN12_GLOBAL__N_111SymbolScopeELj1EEENS0_10StringAttrEPT_ called 0 returned 0% blocks executed 0%
    #####:  708:static SmallVector<SymbolScope, 1> collectSymbolScopes(StringAttr symbol,
        -:  709:                                                       IRUnit *limit) {
    #####:  710:  return {{SymbolRefAttr::get(symbol), limit}};
call    0 never executed
call    1 never executed
call    2 never executed
        -:  711:}
------------------
_Z19collectSymbolScopesIN4mlir9OperationEEN4llvm11SmallVectorIN12_GLOBAL__N_111SymbolScopeELj1EEENS0_10StringAttrEPT_:
function _Z19collectSymbolScopesIN4mlir9OperationEEN4llvm11SmallVectorIN12_GLOBAL__N_111SymbolScopeELj1EEENS0_10StringAttrEPT_ called 0 returned 0% blocks executed 0%
    #####:  708:static SmallVector<SymbolScope, 1> collectSymbolScopes(StringAttr symbol,
        -:  709:                                                       IRUnit *limit) {
    #####:  710:  return {{SymbolRefAttr::get(symbol), limit}};
call    0 never executed
call    1 never executed
call    2 never executed
        -:  711:}
------------------
        -:  712:
        -:  713:/// Returns true if the given reference 'SubRef' is a sub reference of the
        -:  714:/// reference 'ref', i.e. 'ref' is a further qualified reference.
function _ZL19isReferencePrefixOfN4mlir13SymbolRefAttrES0_ called 700454 returned 100% blocks executed 26%
   700454:  715:static bool isReferencePrefixOf(SymbolRefAttr subRef, SymbolRefAttr ref) {
   700454:  716:  if (ref == subRef)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:  717:    return true;
        -:  718:
        -:  719:  // If the references are not pointer equal, check to see if `subRef` is a
        -:  720:  // prefix of `ref`.
  669834*:  721:  if (ref.isa<FlatSymbolRefAttr>() ||
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  722:      ref.getRootReference() != subRef.getRootReference())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
   669834:  723:    return false;
        -:  724:
    #####:  725:  auto refLeafs = ref.getNestedReferences();
call    0 never executed
    #####:  726:  auto subRefLeafs = subRef.getNestedReferences();
call    0 never executed
    #####:  727:  return subRefLeafs.size() < refLeafs.size() &&
branch  0 never executed
branch  1 never executed
    #####:  728:         subRefLeafs == refLeafs.take_front(subRefLeafs.size());
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  729:}
        -:  730:
        -:  731://===----------------------------------------------------------------------===//
        -:  732:// SymbolTable::getSymbolUses
        -:  733:
        -:  734:/// The implementation of SymbolTable::getSymbolUses below.
        -:  735:template <typename FromT>
    67646:  736:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(FromT from) {
   135292:  737:  std::vector<SymbolTable::SymbolUse> uses;
   283356:  738:  auto walkFn = [&](SymbolTable::SymbolUse symbolUse) {
   215710:  739:    uses.push_back(symbolUse);
call    0 returned 100%
call    1 returned 100%
        -:  740:    return WalkResult::advance();
        -:  741:  };
    67646:  742:  auto result = walkSymbolUses(from, walkFn);
   67646*:  743:  return result ? Optional<SymbolTable::UseRange>(std::move(uses)) : llvm::None;
        -:  744:}
------------------
_Z17getSymbolUsesImplIN4llvm15MutableArrayRefIN4mlir6RegionEEEENS0_8OptionalINS2_11SymbolTable8UseRangeEEET_:
function _Z17getSymbolUsesImplIN4llvm15MutableArrayRefIN4mlir6RegionEEEENS0_8OptionalINS2_11SymbolTable8UseRangeEEET_ called 3077 returned 100% blocks executed 62%
     3077:  736:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(FromT from) {
call    0 returned 100%
     6154:  737:  std::vector<SymbolTable::SymbolUse> uses;
     3077:  738:  auto walkFn = [&](SymbolTable::SymbolUse symbolUse) {
        -:  739:    uses.push_back(symbolUse);
        -:  740:    return WalkResult::advance();
        -:  741:  };
     3077:  742:  auto result = walkSymbolUses(from, walkFn);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
    3077*:  743:  return result ? Optional<SymbolTable::UseRange>(std::move(uses)) : llvm::None;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  744:}
------------------
_Z17getSymbolUsesImplIPN4mlir9OperationEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_:
function _Z17getSymbolUsesImplIPN4mlir9OperationEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_ called 64569 returned 100% blocks executed 62%
    64569:  736:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(FromT from) {
call    0 returned 100%
   129138:  737:  std::vector<SymbolTable::SymbolUse> uses;
    64569:  738:  auto walkFn = [&](SymbolTable::SymbolUse symbolUse) {
        -:  739:    uses.push_back(symbolUse);
        -:  740:    return WalkResult::advance();
        -:  741:  };
    64569:  742:  auto result = walkSymbolUses(from, walkFn);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
   64569*:  743:  return result ? Optional<SymbolTable::UseRange>(std::move(uses)) : llvm::None;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  744:}
------------------
        -:  745:
        -:  746:/// Get an iterator range for all of the uses, for any symbol, that are nested
        -:  747:/// within the given operation 'from'. This does not traverse into any nested
        -:  748:/// symbol tables, and will also only return uses on 'from' if it does not
        -:  749:/// also define a symbol table. This is because we treat the region as the
        -:  750:/// boundary of the symbol table, and not the op itself. This function returns
        -:  751:/// None if there are any unknown operations that may potentially be symbol
        -:  752:/// tables.
function _ZN4mlir11SymbolTable13getSymbolUsesEPNS_9OperationE called 51164 returned 100% blocks executed 100%
    64569:  753:auto SymbolTable::getSymbolUses(Operation *from) -> Optional<UseRange> {
    51164:  754:  return getSymbolUsesImpl(from);
call    0 returned 100%
        -:  755:}
function _ZN4mlir11SymbolTable13getSymbolUsesEPNS_6RegionE called 3077 returned 100% blocks executed 100%
     3077:  756:auto SymbolTable::getSymbolUses(Region *from) -> Optional<UseRange> {
     3077:  757:  return getSymbolUsesImpl(MutableArrayRef<Region>(*from));
call    0 returned 100%
        -:  758:}
        -:  759:
        -:  760://===----------------------------------------------------------------------===//
        -:  761:// SymbolTable::getSymbolUses
        -:  762:
        -:  763:/// The implementation of SymbolTable::getSymbolUses below.
        -:  764:template <typename SymbolT, typename IRUnitT>
    9861*:  765:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(SymbolT symbol,
        -:  766:                                                         IRUnitT *limit) {
   19722*:  767:  std::vector<SymbolTable::SymbolUse> uses;
   29583*:  768:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
  390876*:  769:    if (!scope.walk([&](SymbolTable::SymbolUse symbolUse) {
  381015*:  770:          if (isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef()))
call    0 returned 100%
branch  1 taken 5% (fallthrough)
branch  2 taken 95%
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
   20759*:  771:            uses.push_back(symbolUse);
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
        -:  772:        }))
    #####:  773:      return llvm::None;
        -:  774:  }
    9861*:  775:  return SymbolTable::UseRange(std::move(uses));
        -:  776:}
------------------
_Z17getSymbolUsesImplIPN4mlir9OperationENS0_6RegionEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_:
function _Z17getSymbolUsesImplIPN4mlir9OperationENS0_6RegionEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_ called 9861 returned 100% blocks executed 62%
     9861:  765:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(SymbolT symbol,
call    0 returned 100%
        -:  766:                                                         IRUnitT *limit) {
    19722:  767:  std::vector<SymbolTable::SymbolUse> uses;
    29583:  768:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
     9861:  769:    if (!scope.walk([&](SymbolTable::SymbolUse symbolUse) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  770:          if (isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef()))
        -:  771:            uses.push_back(symbolUse);
        -:  772:        }))
    #####:  773:      return llvm::None;
branch  0 never executed
branch  1 never executed
        -:  774:  }
     9861:  775:  return SymbolTable::UseRange(std::move(uses));
        -:  776:}
------------------
_Z17getSymbolUsesImplIN4mlir10StringAttrENS0_6RegionEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_:
function _Z17getSymbolUsesImplIN4mlir10StringAttrENS0_6RegionEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_ called 0 returned 0% blocks executed 0%
    #####:  765:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(SymbolT symbol,
call    0 never executed
        -:  766:                                                         IRUnitT *limit) {
    #####:  767:  std::vector<SymbolTable::SymbolUse> uses;
    #####:  768:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    if (!scope.walk([&](SymbolTable::SymbolUse symbolUse) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  770:          if (isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef()))
        -:  771:            uses.push_back(symbolUse);
        -:  772:        }))
    #####:  773:      return llvm::None;
branch  0 never executed
branch  1 never executed
        -:  774:  }
    #####:  775:  return SymbolTable::UseRange(std::move(uses));
        -:  776:}
------------------
_Z17getSymbolUsesImplIPN4mlir9OperationES1_EN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_:
function _Z17getSymbolUsesImplIPN4mlir9OperationES1_EN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_ called 0 returned 0% blocks executed 0%
    #####:  765:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(SymbolT symbol,
call    0 never executed
        -:  766:                                                         IRUnitT *limit) {
    #####:  767:  std::vector<SymbolTable::SymbolUse> uses;
    #####:  768:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    if (!scope.walk([&](SymbolTable::SymbolUse symbolUse) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  770:          if (isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef()))
        -:  771:            uses.push_back(symbolUse);
        -:  772:        }))
    #####:  773:      return llvm::None;
branch  0 never executed
branch  1 never executed
        -:  774:  }
    #####:  775:  return SymbolTable::UseRange(std::move(uses));
        -:  776:}
------------------
_Z17getSymbolUsesImplIN4mlir10StringAttrENS0_9OperationEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_:
function _Z17getSymbolUsesImplIN4mlir10StringAttrENS0_9OperationEEN4llvm8OptionalINS0_11SymbolTable8UseRangeEEET_PT0_ called 0 returned 0% blocks executed 0%
    #####:  765:static Optional<SymbolTable::UseRange> getSymbolUsesImpl(SymbolT symbol,
call    0 never executed
        -:  766:                                                         IRUnitT *limit) {
    #####:  767:  std::vector<SymbolTable::SymbolUse> uses;
    #####:  768:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  769:    if (!scope.walk([&](SymbolTable::SymbolUse symbolUse) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  770:          if (isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef()))
        -:  771:            uses.push_back(symbolUse);
        -:  772:        }))
    #####:  773:      return llvm::None;
branch  0 never executed
branch  1 never executed
        -:  774:  }
    #####:  775:  return SymbolTable::UseRange(std::move(uses));
        -:  776:}
------------------
        -:  777:
        -:  778:/// Get all of the uses of the given symbol that are nested within the given
        -:  779:/// operation 'from', invoking the provided callback for each. This does not
        -:  780:/// traverse into any nested symbol tables. This function returns None if there
        -:  781:/// are any unknown operations that may potentially be symbol tables.
function _ZN4mlir11SymbolTable13getSymbolUsesENS_10StringAttrEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  782:auto SymbolTable::getSymbolUses(StringAttr symbol, Operation *from)
        -:  783:    -> Optional<UseRange> {
    #####:  784:  return getSymbolUsesImpl(symbol, from);
call    0 never executed
        -:  785:}
function _ZN4mlir11SymbolTable13getSymbolUsesEPNS_9OperationES2_ called 0 returned 0% blocks executed 0%
    #####:  786:auto SymbolTable::getSymbolUses(Operation *symbol, Operation *from)
        -:  787:    -> Optional<UseRange> {
    #####:  788:  return getSymbolUsesImpl(symbol, from);
call    0 never executed
        -:  789:}
function _ZN4mlir11SymbolTable13getSymbolUsesENS_10StringAttrEPNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  790:auto SymbolTable::getSymbolUses(StringAttr symbol, Region *from)
        -:  791:    -> Optional<UseRange> {
    #####:  792:  return getSymbolUsesImpl(symbol, from);
call    0 never executed
        -:  793:}
function _ZN4mlir11SymbolTable13getSymbolUsesEPNS_9OperationEPNS_6RegionE called 9861 returned 100% blocks executed 100%
     9861:  794:auto SymbolTable::getSymbolUses(Operation *symbol, Region *from)
        -:  795:    -> Optional<UseRange> {
     9861:  796:  return getSymbolUsesImpl(symbol, from);
call    0 returned 100%
        -:  797:}
        -:  798:
        -:  799://===----------------------------------------------------------------------===//
        -:  800:// SymbolTable::symbolKnownUseEmpty
        -:  801:
        -:  802:/// The implementation of SymbolTable::symbolKnownUseEmpty below.
        -:  803:template <typename SymbolT, typename IRUnitT>
   14231*:  804:static bool symbolKnownUseEmptyImpl(SymbolT symbol, IRUnitT *limit) {
   18601*:  805:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
        -:  806:    // Walk all of the symbol uses looking for a reference to 'symbol'.
  319439*:  807:    if (scope.walk([&](SymbolTable::SymbolUse symbolUse) {
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
  319439*:  808:          return isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef())
call    0 returned 100%
call    1 never executed
call    2 never executed
call    3 never executed
        -:  809:                     ? WalkResult::interrupt()
  319439*:  810:                     : WalkResult::advance();
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
   28462*:  811:        }) != WalkResult::advance())
    9861*:  812:      return false;
        -:  813:  }
    4370*:  814:  return true;
        -:  815:}
------------------
_Z23symbolKnownUseEmptyImplIPN4mlir9OperationENS0_6RegionEEbT_PT0_:
function _Z23symbolKnownUseEmptyImplIPN4mlir9OperationENS0_6RegionEEbT_PT0_ called 14231 returned 100% blocks executed 81%
    14231:  804:static bool symbolKnownUseEmptyImpl(SymbolT symbol, IRUnitT *limit) {
    18601:  805:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 returned 100%
branch  1 taken 77% (fallthrough)
branch  2 taken 23%
call    3 returned 100%
        -:  806:    // Walk all of the symbol uses looking for a reference to 'symbol'.
        -:  807:    if (scope.walk([&](SymbolTable::SymbolUse symbolUse) {
        -:  808:          return isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef())
        -:  809:                     ? WalkResult::interrupt()
        -:  810:                     : WalkResult::advance();
   28462*:  811:        }) != WalkResult::advance())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
     9861:  812:      return false;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  813:  }
     4370:  814:  return true;
        -:  815:}
------------------
_Z23symbolKnownUseEmptyImplIN4mlir10StringAttrENS0_6RegionEEbT_PT0_:
function _Z23symbolKnownUseEmptyImplIN4mlir10StringAttrENS0_6RegionEEbT_PT0_ called 0 returned 0% blocks executed 0%
    #####:  804:static bool symbolKnownUseEmptyImpl(SymbolT symbol, IRUnitT *limit) {
    #####:  805:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  806:    // Walk all of the symbol uses looking for a reference to 'symbol'.
        -:  807:    if (scope.walk([&](SymbolTable::SymbolUse symbolUse) {
        -:  808:          return isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef())
        -:  809:                     ? WalkResult::interrupt()
        -:  810:                     : WalkResult::advance();
    #####:  811:        }) != WalkResult::advance())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  812:      return false;
branch  0 never executed
branch  1 never executed
        -:  813:  }
    #####:  814:  return true;
        -:  815:}
------------------
_Z23symbolKnownUseEmptyImplIPN4mlir9OperationES1_EbT_PT0_:
function _Z23symbolKnownUseEmptyImplIPN4mlir9OperationES1_EbT_PT0_ called 0 returned 0% blocks executed 0%
    #####:  804:static bool symbolKnownUseEmptyImpl(SymbolT symbol, IRUnitT *limit) {
    #####:  805:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  806:    // Walk all of the symbol uses looking for a reference to 'symbol'.
        -:  807:    if (scope.walk([&](SymbolTable::SymbolUse symbolUse) {
        -:  808:          return isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef())
        -:  809:                     ? WalkResult::interrupt()
        -:  810:                     : WalkResult::advance();
    #####:  811:        }) != WalkResult::advance())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  812:      return false;
branch  0 never executed
branch  1 never executed
        -:  813:  }
    #####:  814:  return true;
        -:  815:}
------------------
_Z23symbolKnownUseEmptyImplIN4mlir10StringAttrENS0_9OperationEEbT_PT0_:
function _Z23symbolKnownUseEmptyImplIN4mlir10StringAttrENS0_9OperationEEbT_PT0_ called 0 returned 0% blocks executed 0%
    #####:  804:static bool symbolKnownUseEmptyImpl(SymbolT symbol, IRUnitT *limit) {
    #####:  805:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
        -:  806:    // Walk all of the symbol uses looking for a reference to 'symbol'.
        -:  807:    if (scope.walk([&](SymbolTable::SymbolUse symbolUse) {
        -:  808:          return isReferencePrefixOf(scope.symbol, symbolUse.getSymbolRef())
        -:  809:                     ? WalkResult::interrupt()
        -:  810:                     : WalkResult::advance();
    #####:  811:        }) != WalkResult::advance())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  812:      return false;
branch  0 never executed
branch  1 never executed
        -:  813:  }
    #####:  814:  return true;
        -:  815:}
------------------
        -:  816:
        -:  817:/// Return if the given symbol is known to have no uses that are nested within
        -:  818:/// the given operation 'from'. This does not traverse into any nested symbol
        -:  819:/// tables. This function will also return false if there are any unknown
        -:  820:/// operations that may potentially be symbol tables.
function _ZN4mlir11SymbolTable19symbolKnownUseEmptyENS_10StringAttrEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  821:bool SymbolTable::symbolKnownUseEmpty(StringAttr symbol, Operation *from) {
    #####:  822:  return symbolKnownUseEmptyImpl(symbol, from);
call    0 never executed
        -:  823:}
function _ZN4mlir11SymbolTable19symbolKnownUseEmptyEPNS_9OperationES2_ called 0 returned 0% blocks executed 0%
    #####:  824:bool SymbolTable::symbolKnownUseEmpty(Operation *symbol, Operation *from) {
    #####:  825:  return symbolKnownUseEmptyImpl(symbol, from);
call    0 never executed
        -:  826:}
function _ZN4mlir11SymbolTable19symbolKnownUseEmptyENS_10StringAttrEPNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  827:bool SymbolTable::symbolKnownUseEmpty(StringAttr symbol, Region *from) {
    #####:  828:  return symbolKnownUseEmptyImpl(symbol, from);
call    0 never executed
        -:  829:}
function _ZN4mlir11SymbolTable19symbolKnownUseEmptyEPNS_9OperationEPNS_6RegionE called 14231 returned 100% blocks executed 100%
    14231:  830:bool SymbolTable::symbolKnownUseEmpty(Operation *symbol, Region *from) {
    14231:  831:  return symbolKnownUseEmptyImpl(symbol, from);
call    0 returned 100%
        -:  832:}
        -:  833:
        -:  834://===----------------------------------------------------------------------===//
        -:  835:// SymbolTable::replaceAllSymbolUses
        -:  836:
        -:  837:/// Generates a new symbol reference attribute with a new leaf reference.
function _ZL18generateNewRefAttrN4mlir13SymbolRefAttrENS_17FlatSymbolRefAttrE called 0 returned 0% blocks executed 0%
    #####:  838:static SymbolRefAttr generateNewRefAttr(SymbolRefAttr oldAttr,
        -:  839:                                        FlatSymbolRefAttr newLeafAttr) {
    #####:  840:  if (oldAttr.isa<FlatSymbolRefAttr>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  841:    return newLeafAttr;
    #####:  842:  auto nestedRefs = llvm::to_vector<2>(oldAttr.getNestedReferences());
call    0 never executed
call    1 never executed
    #####:  843:  nestedRefs.back() = newLeafAttr;
call    0 never executed
    #####:  844:  return SymbolRefAttr::get(oldAttr.getRootReference(), nestedRefs);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  845:}
        -:  846:
        -:  847:/// The implementation of SymbolTable::replaceAllSymbolUses below.
        -:  848:template <typename SymbolT, typename IRUnitT>
        -:  849:static LogicalResult
    #####:  850:replaceAllSymbolUsesImpl(SymbolT symbol, StringAttr newSymbol, IRUnitT *limit) {
        -:  851:  // Generate a new attribute to replace the given attribute.
    #####:  852:  FlatSymbolRefAttr newLeafAttr = FlatSymbolRefAttr::get(newSymbol);
    #####:  853:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
    #####:  854:    SymbolRefAttr oldAttr = scope.symbol;
    #####:  855:    SymbolRefAttr newAttr = generateNewRefAttr(scope.symbol, newLeafAttr);
        -:  856:
    #####:  857:    auto walkFn = [&](Operation *op) -> Optional<WalkResult> {
    #####:  858:      auto remapAttrFn =
    #####:  859:          [&](Attribute attr) -> std::pair<Attribute, WalkResult> {
        -:  860:        // Regardless of the match, don't walk nested SymbolRefAttrs, we don't
        -:  861:        // want to accidentally replace an inner reference.
    #####:  862:        if (attr == oldAttr)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  863:          return {newAttr, WalkResult::skip()};
        -:  864:        // Handle prefix matches.
    #####:  865:        if (SymbolRefAttr symRef = attr.dyn_cast<SymbolRefAttr>()) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  866:          if (isReferencePrefixOf(oldAttr, symRef)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
call    6 never executed
branch  7 never executed
branch  8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
    #####:  867:            auto oldNestedRefs = oldAttr.getNestedReferences();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  868:            auto nestedRefs = symRef.getNestedReferences();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  869:            if (oldNestedRefs.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  870:              return {SymbolRefAttr::get(newSymbol, nestedRefs),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  871:                      WalkResult::skip()};
        -:  872:
    #####:  873:            auto newNestedRefs = llvm::to_vector<4>(nestedRefs);
    #####:  874:            newNestedRefs[oldNestedRefs.size() - 1] = newLeafAttr;
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
branch  9 never executed
branch 10 never executed
call   11 never executed
        -:  875:            return {
    #####:  876:                SymbolRefAttr::get(symRef.getRootReference(), newNestedRefs),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
call    8 never executed
call    9 never executed
branch 10 never executed
branch 11 never executed
call   12 never executed
call   13 never executed
branch 14 never executed
branch 15 never executed
    #####:  877:                WalkResult::skip()};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  878:          }
    #####:  879:          return {attr, WalkResult::skip()};
        -:  880:        }
    #####:  881:        return {attr, WalkResult::advance()};
        -:  882:      };
        -:  883:      // Generate a new attribute dictionary by replacing references to the old
        -:  884:      // symbol.
    #####:  885:      auto newDict = op->getAttrDictionary().replaceSubElements(remapAttrFn);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  886:      if (!newDict)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  887:        return WalkResult::interrupt();
        -:  888:
    #####:  889:      op->setAttrs(newDict.template cast<DictionaryAttr>());
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  890:      return WalkResult::advance();
        -:  891:    };
    #####:  892:    if (!scope.walkSymbolTable(walkFn))
    #####:  893:      return failure();
        -:  894:  }
    #####:  895:  return success();
        -:  896:}
------------------
_Z24replaceAllSymbolUsesImplIPN4mlir9OperationENS0_6RegionEENS0_13LogicalResultET_NS0_10StringAttrEPT0_:
function _Z24replaceAllSymbolUsesImplIPN4mlir9OperationENS0_6RegionEENS0_13LogicalResultET_NS0_10StringAttrEPT0_ called 0 returned 0% blocks executed 0%
    #####:  850:replaceAllSymbolUsesImpl(SymbolT symbol, StringAttr newSymbol, IRUnitT *limit) {
call    0 never executed
        -:  851:  // Generate a new attribute to replace the given attribute.
    #####:  852:  FlatSymbolRefAttr newLeafAttr = FlatSymbolRefAttr::get(newSymbol);
    #####:  853:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:    SymbolRefAttr oldAttr = scope.symbol;
    #####:  855:    SymbolRefAttr newAttr = generateNewRefAttr(scope.symbol, newLeafAttr);
call    0 never executed
        -:  856:
    #####:  857:    auto walkFn = [&](Operation *op) -> Optional<WalkResult> {
        -:  858:      auto remapAttrFn =
        -:  859:          [&](Attribute attr) -> std::pair<Attribute, WalkResult> {
        -:  860:        // Regardless of the match, don't walk nested SymbolRefAttrs, we don't
        -:  861:        // want to accidentally replace an inner reference.
        -:  862:        if (attr == oldAttr)
        -:  863:          return {newAttr, WalkResult::skip()};
        -:  864:        // Handle prefix matches.
        -:  865:        if (SymbolRefAttr symRef = attr.dyn_cast<SymbolRefAttr>()) {
        -:  866:          if (isReferencePrefixOf(oldAttr, symRef)) {
        -:  867:            auto oldNestedRefs = oldAttr.getNestedReferences();
        -:  868:            auto nestedRefs = symRef.getNestedReferences();
        -:  869:            if (oldNestedRefs.empty())
        -:  870:              return {SymbolRefAttr::get(newSymbol, nestedRefs),
        -:  871:                      WalkResult::skip()};
        -:  872:
        -:  873:            auto newNestedRefs = llvm::to_vector<4>(nestedRefs);
        -:  874:            newNestedRefs[oldNestedRefs.size() - 1] = newLeafAttr;
        -:  875:            return {
        -:  876:                SymbolRefAttr::get(symRef.getRootReference(), newNestedRefs),
        -:  877:                WalkResult::skip()};
        -:  878:          }
        -:  879:          return {attr, WalkResult::skip()};
        -:  880:        }
        -:  881:        return {attr, WalkResult::advance()};
        -:  882:      };
        -:  883:      // Generate a new attribute dictionary by replacing references to the old
        -:  884:      // symbol.
        -:  885:      auto newDict = op->getAttrDictionary().replaceSubElements(remapAttrFn);
        -:  886:      if (!newDict)
        -:  887:        return WalkResult::interrupt();
        -:  888:
        -:  889:      op->setAttrs(newDict.template cast<DictionaryAttr>());
        -:  890:      return WalkResult::advance();
        -:  891:    };
    #####:  892:    if (!scope.walkSymbolTable(walkFn))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:      return failure();
branch  0 never executed
branch  1 never executed
        -:  894:  }
    #####:  895:  return success();
        -:  896:}
------------------
_Z24replaceAllSymbolUsesImplIN4mlir10StringAttrENS0_6RegionEENS0_13LogicalResultET_S1_PT0_:
function _Z24replaceAllSymbolUsesImplIN4mlir10StringAttrENS0_6RegionEENS0_13LogicalResultET_S1_PT0_ called 0 returned 0% blocks executed 0%
    #####:  850:replaceAllSymbolUsesImpl(SymbolT symbol, StringAttr newSymbol, IRUnitT *limit) {
call    0 never executed
        -:  851:  // Generate a new attribute to replace the given attribute.
    #####:  852:  FlatSymbolRefAttr newLeafAttr = FlatSymbolRefAttr::get(newSymbol);
    #####:  853:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:    SymbolRefAttr oldAttr = scope.symbol;
    #####:  855:    SymbolRefAttr newAttr = generateNewRefAttr(scope.symbol, newLeafAttr);
call    0 never executed
        -:  856:
    #####:  857:    auto walkFn = [&](Operation *op) -> Optional<WalkResult> {
        -:  858:      auto remapAttrFn =
        -:  859:          [&](Attribute attr) -> std::pair<Attribute, WalkResult> {
        -:  860:        // Regardless of the match, don't walk nested SymbolRefAttrs, we don't
        -:  861:        // want to accidentally replace an inner reference.
        -:  862:        if (attr == oldAttr)
        -:  863:          return {newAttr, WalkResult::skip()};
        -:  864:        // Handle prefix matches.
        -:  865:        if (SymbolRefAttr symRef = attr.dyn_cast<SymbolRefAttr>()) {
        -:  866:          if (isReferencePrefixOf(oldAttr, symRef)) {
        -:  867:            auto oldNestedRefs = oldAttr.getNestedReferences();
        -:  868:            auto nestedRefs = symRef.getNestedReferences();
        -:  869:            if (oldNestedRefs.empty())
        -:  870:              return {SymbolRefAttr::get(newSymbol, nestedRefs),
        -:  871:                      WalkResult::skip()};
        -:  872:
        -:  873:            auto newNestedRefs = llvm::to_vector<4>(nestedRefs);
        -:  874:            newNestedRefs[oldNestedRefs.size() - 1] = newLeafAttr;
        -:  875:            return {
        -:  876:                SymbolRefAttr::get(symRef.getRootReference(), newNestedRefs),
        -:  877:                WalkResult::skip()};
        -:  878:          }
        -:  879:          return {attr, WalkResult::skip()};
        -:  880:        }
        -:  881:        return {attr, WalkResult::advance()};
        -:  882:      };
        -:  883:      // Generate a new attribute dictionary by replacing references to the old
        -:  884:      // symbol.
        -:  885:      auto newDict = op->getAttrDictionary().replaceSubElements(remapAttrFn);
        -:  886:      if (!newDict)
        -:  887:        return WalkResult::interrupt();
        -:  888:
        -:  889:      op->setAttrs(newDict.template cast<DictionaryAttr>());
        -:  890:      return WalkResult::advance();
        -:  891:    };
    #####:  892:    if (!scope.walkSymbolTable(walkFn))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:      return failure();
branch  0 never executed
branch  1 never executed
        -:  894:  }
    #####:  895:  return success();
        -:  896:}
------------------
_Z24replaceAllSymbolUsesImplIPN4mlir9OperationES1_ENS0_13LogicalResultET_NS0_10StringAttrEPT0_:
function _Z24replaceAllSymbolUsesImplIPN4mlir9OperationES1_ENS0_13LogicalResultET_NS0_10StringAttrEPT0_ called 0 returned 0% blocks executed 0%
    #####:  850:replaceAllSymbolUsesImpl(SymbolT symbol, StringAttr newSymbol, IRUnitT *limit) {
call    0 never executed
        -:  851:  // Generate a new attribute to replace the given attribute.
    #####:  852:  FlatSymbolRefAttr newLeafAttr = FlatSymbolRefAttr::get(newSymbol);
    #####:  853:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:    SymbolRefAttr oldAttr = scope.symbol;
    #####:  855:    SymbolRefAttr newAttr = generateNewRefAttr(scope.symbol, newLeafAttr);
call    0 never executed
        -:  856:
    #####:  857:    auto walkFn = [&](Operation *op) -> Optional<WalkResult> {
        -:  858:      auto remapAttrFn =
        -:  859:          [&](Attribute attr) -> std::pair<Attribute, WalkResult> {
        -:  860:        // Regardless of the match, don't walk nested SymbolRefAttrs, we don't
        -:  861:        // want to accidentally replace an inner reference.
        -:  862:        if (attr == oldAttr)
        -:  863:          return {newAttr, WalkResult::skip()};
        -:  864:        // Handle prefix matches.
        -:  865:        if (SymbolRefAttr symRef = attr.dyn_cast<SymbolRefAttr>()) {
        -:  866:          if (isReferencePrefixOf(oldAttr, symRef)) {
        -:  867:            auto oldNestedRefs = oldAttr.getNestedReferences();
        -:  868:            auto nestedRefs = symRef.getNestedReferences();
        -:  869:            if (oldNestedRefs.empty())
        -:  870:              return {SymbolRefAttr::get(newSymbol, nestedRefs),
        -:  871:                      WalkResult::skip()};
        -:  872:
        -:  873:            auto newNestedRefs = llvm::to_vector<4>(nestedRefs);
        -:  874:            newNestedRefs[oldNestedRefs.size() - 1] = newLeafAttr;
        -:  875:            return {
        -:  876:                SymbolRefAttr::get(symRef.getRootReference(), newNestedRefs),
        -:  877:                WalkResult::skip()};
        -:  878:          }
        -:  879:          return {attr, WalkResult::skip()};
        -:  880:        }
        -:  881:        return {attr, WalkResult::advance()};
        -:  882:      };
        -:  883:      // Generate a new attribute dictionary by replacing references to the old
        -:  884:      // symbol.
        -:  885:      auto newDict = op->getAttrDictionary().replaceSubElements(remapAttrFn);
        -:  886:      if (!newDict)
        -:  887:        return WalkResult::interrupt();
        -:  888:
        -:  889:      op->setAttrs(newDict.template cast<DictionaryAttr>());
        -:  890:      return WalkResult::advance();
        -:  891:    };
    #####:  892:    if (!scope.walkSymbolTable(walkFn))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:      return failure();
branch  0 never executed
branch  1 never executed
        -:  894:  }
    #####:  895:  return success();
        -:  896:}
------------------
_Z24replaceAllSymbolUsesImplIN4mlir10StringAttrENS0_9OperationEENS0_13LogicalResultET_S1_PT0_:
function _Z24replaceAllSymbolUsesImplIN4mlir10StringAttrENS0_9OperationEENS0_13LogicalResultET_S1_PT0_ called 0 returned 0% blocks executed 0%
    #####:  850:replaceAllSymbolUsesImpl(SymbolT symbol, StringAttr newSymbol, IRUnitT *limit) {
call    0 never executed
        -:  851:  // Generate a new attribute to replace the given attribute.
    #####:  852:  FlatSymbolRefAttr newLeafAttr = FlatSymbolRefAttr::get(newSymbol);
    #####:  853:  for (SymbolScope &scope : collectSymbolScopes(symbol, limit)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  854:    SymbolRefAttr oldAttr = scope.symbol;
    #####:  855:    SymbolRefAttr newAttr = generateNewRefAttr(scope.symbol, newLeafAttr);
call    0 never executed
        -:  856:
    #####:  857:    auto walkFn = [&](Operation *op) -> Optional<WalkResult> {
        -:  858:      auto remapAttrFn =
        -:  859:          [&](Attribute attr) -> std::pair<Attribute, WalkResult> {
        -:  860:        // Regardless of the match, don't walk nested SymbolRefAttrs, we don't
        -:  861:        // want to accidentally replace an inner reference.
        -:  862:        if (attr == oldAttr)
        -:  863:          return {newAttr, WalkResult::skip()};
        -:  864:        // Handle prefix matches.
        -:  865:        if (SymbolRefAttr symRef = attr.dyn_cast<SymbolRefAttr>()) {
        -:  866:          if (isReferencePrefixOf(oldAttr, symRef)) {
        -:  867:            auto oldNestedRefs = oldAttr.getNestedReferences();
        -:  868:            auto nestedRefs = symRef.getNestedReferences();
        -:  869:            if (oldNestedRefs.empty())
        -:  870:              return {SymbolRefAttr::get(newSymbol, nestedRefs),
        -:  871:                      WalkResult::skip()};
        -:  872:
        -:  873:            auto newNestedRefs = llvm::to_vector<4>(nestedRefs);
        -:  874:            newNestedRefs[oldNestedRefs.size() - 1] = newLeafAttr;
        -:  875:            return {
        -:  876:                SymbolRefAttr::get(symRef.getRootReference(), newNestedRefs),
        -:  877:                WalkResult::skip()};
        -:  878:          }
        -:  879:          return {attr, WalkResult::skip()};
        -:  880:        }
        -:  881:        return {attr, WalkResult::advance()};
        -:  882:      };
        -:  883:      // Generate a new attribute dictionary by replacing references to the old
        -:  884:      // symbol.
        -:  885:      auto newDict = op->getAttrDictionary().replaceSubElements(remapAttrFn);
        -:  886:      if (!newDict)
        -:  887:        return WalkResult::interrupt();
        -:  888:
        -:  889:      op->setAttrs(newDict.template cast<DictionaryAttr>());
        -:  890:      return WalkResult::advance();
        -:  891:    };
    #####:  892:    if (!scope.walkSymbolTable(walkFn))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  893:      return failure();
branch  0 never executed
branch  1 never executed
        -:  894:  }
    #####:  895:  return success();
        -:  896:}
------------------
        -:  897:
        -:  898:/// Attempt to replace all uses of the given symbol 'oldSymbol' with the
        -:  899:/// provided symbol 'newSymbol' that are nested within the given operation
        -:  900:/// 'from'. This does not traverse into any nested symbol tables. If there are
        -:  901:/// any unknown operations that may potentially be symbol tables, no uses are
        -:  902:/// replaced and failure is returned.
function _ZN4mlir11SymbolTable20replaceAllSymbolUsesENS_10StringAttrES1_PNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  903:LogicalResult SymbolTable::replaceAllSymbolUses(StringAttr oldSymbol,
        -:  904:                                                StringAttr newSymbol,
        -:  905:                                                Operation *from) {
    #####:  906:  return replaceAllSymbolUsesImpl(oldSymbol, newSymbol, from);
call    0 never executed
        -:  907:}
function _ZN4mlir11SymbolTable20replaceAllSymbolUsesEPNS_9OperationENS_10StringAttrES2_ called 0 returned 0% blocks executed 0%
    #####:  908:LogicalResult SymbolTable::replaceAllSymbolUses(Operation *oldSymbol,
        -:  909:                                                StringAttr newSymbol,
        -:  910:                                                Operation *from) {
    #####:  911:  return replaceAllSymbolUsesImpl(oldSymbol, newSymbol, from);
call    0 never executed
        -:  912:}
function _ZN4mlir11SymbolTable20replaceAllSymbolUsesENS_10StringAttrES1_PNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  913:LogicalResult SymbolTable::replaceAllSymbolUses(StringAttr oldSymbol,
        -:  914:                                                StringAttr newSymbol,
        -:  915:                                                Region *from) {
    #####:  916:  return replaceAllSymbolUsesImpl(oldSymbol, newSymbol, from);
call    0 never executed
        -:  917:}
function _ZN4mlir11SymbolTable20replaceAllSymbolUsesEPNS_9OperationENS_10StringAttrEPNS_6RegionE called 0 returned 0% blocks executed 0%
    #####:  918:LogicalResult SymbolTable::replaceAllSymbolUses(Operation *oldSymbol,
        -:  919:                                                StringAttr newSymbol,
        -:  920:                                                Region *from) {
    #####:  921:  return replaceAllSymbolUsesImpl(oldSymbol, newSymbol, from);
call    0 never executed
        -:  922:}
        -:  923:
        -:  924://===----------------------------------------------------------------------===//
        -:  925:// SymbolTableCollection
        -:  926://===----------------------------------------------------------------------===//
        -:  927:
function _ZN4mlir21SymbolTableCollection14lookupSymbolInEPNS_9OperationENS_10StringAttrE called 12946607 returned 100% blocks executed 100%
 12946607:  928:Operation *SymbolTableCollection::lookupSymbolIn(Operation *symbolTableOp,
        -:  929:                                                 StringAttr symbol) {
 12946607:  930:  return getSymbolTable(symbolTableOp).lookup(symbol);
call    0 returned 100%
call    1 returned 100%
        -:  931:}
function _ZN4mlir21SymbolTableCollection14lookupSymbolInEPNS_9OperationENS_13SymbolRefAttrE called 2877901 returned 100% blocks executed 86%
  2877901:  932:Operation *SymbolTableCollection::lookupSymbolIn(Operation *symbolTableOp,
        -:  933:                                                 SymbolRefAttr name) {
  2877901:  934:  SmallVector<Operation *, 4> symbols;
call    0 returned 100%
  5755802:  935:  if (failed(lookupSymbolIn(symbolTableOp, name, symbols)))
        -:  936:    return nullptr;
  2877901:  937:  return symbols.back();
call    0 returned 100%
        -:  938:}
        -:  939:/// A variant of 'lookupSymbolIn' that returns all of the symbols referenced by
        -:  940:/// a given SymbolRefAttr. Returns failure if any of the nested references could
        -:  941:/// not be resolved.
        -:  942:LogicalResult
function _ZN4mlir21SymbolTableCollection14lookupSymbolInEPNS_9OperationENS_13SymbolRefAttrERN4llvm15SmallVectorImplIS2_EE called 19306 returned 100% blocks executed 100%
  2916903:  943:SymbolTableCollection::lookupSymbolIn(Operation *symbolTableOp,
        -:  944:                                      SymbolRefAttr name,
        -:  945:                                      SmallVectorImpl<Operation *> &symbols) {
  5833806:  946:  auto lookupFn = [this](Operation *symbolTableOp, StringAttr symbol) {
  2916903:  947:    return lookupSymbolIn(symbolTableOp, symbol);
call    0 returned 100%
  2916903:  948:  };
  2916903:  949:  return lookupSymbolInImpl(symbolTableOp, name, symbols, lookupFn);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  950:}
        -:  951:
        -:  952:/// Returns the operation registered with the given symbol name within the
        -:  953:/// closest parent operation of, or including, 'from' with the
        -:  954:/// 'OpTrait::SymbolTable' trait. Returns nullptr if no valid symbol was
        -:  955:/// found.
function _ZN4mlir21SymbolTableCollection23lookupNearestSymbolFromEPNS_9OperationENS_10StringAttrE called 10029704 returned 100% blocks executed 100%
 10029704:  956:Operation *SymbolTableCollection::lookupNearestSymbolFrom(Operation *from,
        -:  957:                                                          StringAttr symbol) {
 10029704:  958:  Operation *symbolTableOp = SymbolTable::getNearestSymbolTable(from);
call    0 returned 100%
 10029704:  959:  return symbolTableOp ? lookupSymbolIn(symbolTableOp, symbol) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  960:}
        -:  961:Operation *
function _ZN4mlir21SymbolTableCollection23lookupNearestSymbolFromEPNS_9OperationENS_13SymbolRefAttrE called 143459 returned 100% blocks executed 100%
   143459:  962:SymbolTableCollection::lookupNearestSymbolFrom(Operation *from,
        -:  963:                                               SymbolRefAttr symbol) {
   143459:  964:  Operation *symbolTableOp = SymbolTable::getNearestSymbolTable(from);
call    0 returned 100%
   143459:  965:  return symbolTableOp ? lookupSymbolIn(symbolTableOp, symbol) : nullptr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  966:}
        -:  967:
        -:  968:/// Lookup, or create, a symbol table for an operation.
function _ZN4mlir21SymbolTableCollection14getSymbolTableEPNS_9OperationE called 12946607 returned 100% blocks executed 89%
 12946607:  969:SymbolTable &SymbolTableCollection::getSymbolTable(Operation *op) {
 12946607:  970:  auto it = symbolTables.try_emplace(op, nullptr);
call    0 returned 100%
 12946607:  971:  if (it.second)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
 13285540:  972:    it.first->second = std::make_unique<SymbolTable>(op);
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 returned 100%
 12946607:  973:  return *it.first->second;
call    0 returned 100%
        -:  974:}
        -:  975:
        -:  976://===----------------------------------------------------------------------===//
        -:  977:// SymbolUserMap
        -:  978://===----------------------------------------------------------------------===//
        -:  979:
function _ZN4mlir13SymbolUserMapC2ERNS_21SymbolTableCollectionEPNS_9OperationE called 515 returned 100% blocks executed 80%
      515:  980:SymbolUserMap::SymbolUserMap(SymbolTableCollection &symbolTable,
      515:  981:                             Operation *symbolTableOp)
      515:  982:    : symbolTable(symbolTable) {
call    0 returned 100%
        -:  983:  // Walk each of the symbol tables looking for discardable callgraph nodes.
      515:  984:  SmallVector<Operation *> symbols;
call    0 returned 100%
function _ZZN4mlir13SymbolUserMapC4ERNS_21SymbolTableCollectionEPNS_9OperationEENKUlS4_bE_clES4_b called 517 returned 100% blocks executed 96%
     1032:  985:  auto walkFn = [&](Operation *symbolTableOp, bool allUsesVisible) {
    13922:  986:    for (Operation &nestedOp : symbolTableOp->getRegion(0).getOps()) {
call    0 returned 100%
call    1 returned 100%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
    26810:  987:      auto symbolUses = SymbolTable::getSymbolUses(&nestedOp);
call    0 returned 100%
call    1 returned 100%
   13405*:  988:      assert(symbolUses && "expected uses to be valid");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  989:
    33101:  990:      for (const SymbolTable::SymbolUse &use : *symbolUses) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
call    2 returned 100%
    19696:  991:        symbols.clear();
call    0 returned 100%
    19696:  992:        (void)symbolTable.lookupSymbolIn(symbolTableOp, use.getSymbolRef(),
    19696:  993:                                         symbols);
call    0 returned 100%
    39392:  994:        for (Operation *symbolOp : symbols)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
    19696:  995:          symbolToUsers[symbolOp].insert(use.getUser());
call    0 returned 100%
call    1 returned 100%
        -:  996:      }
        -:  997:    }
     1032:  998:  };
        -:  999:  // We just set `allSymUsesVisible` to false here because it isn't necessary
        -: 1000:  // for building the user map.
      515: 1001:  SymbolTable::walkSymbolTables(symbolTableOp, /*allSymUsesVisible=*/false,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1002:                                walkFn);
      515: 1003:}
        -: 1004:
function _ZN4mlir13SymbolUserMap18replaceAllUsesWithEPNS_9OperationENS_10StringAttrE called 0 returned 0% blocks executed 0%
    #####: 1005:void SymbolUserMap::replaceAllUsesWith(Operation *symbol,
        -: 1006:                                       StringAttr newSymbolName) {
    #####: 1007:  auto it = symbolToUsers.find(symbol);
call    0 never executed
    #####: 1008:  if (it == symbolToUsers.end())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1009:    return;
        -: 1010:
        -: 1011:  // Replace the uses within the users of `symbol`.
    #####: 1012:  for (Operation *user : it->second)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1013:    (void)SymbolTable::replaceAllSymbolUses(symbol, newSymbolName, user);
call    0 never executed
        -: 1014:
        -: 1015:  // Move the current users of `symbol` to the new symbol if it is in the
        -: 1016:  // symbol table.
    #####: 1017:  Operation *newSymbol =
    #####: 1018:      symbolTable.lookupSymbolIn(symbol->getParentOp(), newSymbolName);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1019:  if (newSymbol != symbol) {
branch  0 never executed
branch  1 never executed
        -: 1020:    // Transfer over the users to the new symbol.  The reference to the old one
        -: 1021:    // is fetched again as the iterator is invalidated during the insertion.
    #####: 1022:    auto newIt = symbolToUsers.try_emplace(newSymbol, SetVector<Operation *>{});
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1023:    auto oldIt = symbolToUsers.find(symbol);
call    0 never executed
    #####: 1024:    assert(oldIt != symbolToUsers.end() && "missing old users list");
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1025:    if (newIt.second)
branch  0 never executed
branch  1 never executed
    #####: 1026:      newIt.first->second = std::move(oldIt->second);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1027:    else
    #####: 1028:      newIt.first->second.set_union(oldIt->second);
call    0 never executed
call    1 never executed
    #####: 1029:    symbolToUsers.erase(oldIt);
call    0 never executed
        -: 1030:  }
        -: 1031:}
        -: 1032:
        -: 1033://===----------------------------------------------------------------------===//
        -: 1034:// Visibility parsing implementation.
        -: 1035://===----------------------------------------------------------------------===//
        -: 1036:
function _ZN4mlir4impl30parseOptionalVisibilityKeywordERNS_11OpAsmParserERNS_13NamedAttrListE called 0 returned 0% blocks executed 0%
    #####: 1037:ParseResult impl::parseOptionalVisibilityKeyword(OpAsmParser &parser,
        -: 1038:                                                 NamedAttrList &attrs) {
    #####: 1039:  StringRef visibility;
    #####: 1040:  if (parser.parseOptionalKeyword(&visibility, {"public", "private", "nested"}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1041:    return failure();
        -: 1042:
    #####: 1043:  StringAttr visibilityAttr = parser.getBuilder().getStringAttr(visibility);
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1044:  attrs.push_back(parser.getBuilder().getNamedAttr(
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1045:      SymbolTable::getVisibilityAttrName(), visibilityAttr));
    #####: 1046:  return success();
        -: 1047:}
        -: 1048:
        -: 1049://===----------------------------------------------------------------------===//
        -: 1050:// Symbol Interfaces
        -: 1051://===----------------------------------------------------------------------===//
        -: 1052:
        -: 1053:/// Include the generated symbol interfaces.
        -: 1054:#include "mlir/IR/SymbolInterfaces.cpp.inc"
