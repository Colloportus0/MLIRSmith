        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Dialect/GPU/IR/GPUDialect.cpp
        -:    0:Graph:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUOps.dir/IR/GPUDialect.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Dialect/GPU/CMakeFiles/obj.MLIRGPUOps.dir/IR/GPUDialect.cpp.gcda
        -:    0:Runs:128626
        -:    1://===- GPUDialect.cpp - MLIR Dialect for GPU Kernels implementation -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements the GPU kernel-related dialect and its operations.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#include "mlir/Dialect/GPU/IR/GPUDialect.h"
        -:   14:
        -:   15:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   16:#include "mlir/Dialect/MemRef/IR/MemRef.h"
        -:   17:#include "mlir/IR/Attributes.h"
        -:   18:#include "mlir/IR/Builders.h"
        -:   19:#include "mlir/IR/BuiltinOps.h"
        -:   20:#include "mlir/IR/BuiltinTypes.h"
        -:   21:#include "mlir/IR/DialectImplementation.h"
        -:   22:#include "mlir/IR/FunctionImplementation.h"
        -:   23:#include "mlir/IR/Matchers.h"
        -:   24:#include "mlir/IR/OpImplementation.h"
        -:   25:#include "mlir/IR/PatternMatch.h"
        -:   26:#include "mlir/IR/TypeUtilities.h"
        -:   27:#include "mlir/Interfaces/SideEffectInterfaces.h"
        -:   28:#include "mlir/Transforms/InliningUtils.h"
        -:   29:#include "llvm/ADT/TypeSwitch.h"
        -:   30:
        -:   31:using namespace mlir;
        -:   32:using namespace mlir::gpu;
        -:   33:
        -:   34:#include "mlir/Dialect/GPU/IR/GPUOpsDialect.cpp.inc"
        -:   35:
        -:   36://===----------------------------------------------------------------------===//
        -:   37:// MMAMatrixType
        -:   38://===----------------------------------------------------------------------===//
        -:   39:
function _ZN4mlir3gpu13MMAMatrixType3getEN4llvm8ArrayRefIlEENS_4TypeENS2_9StringRefE called 0 returned 0% blocks executed 0%
    #####:   40:MMAMatrixType MMAMatrixType::get(ArrayRef<int64_t> shape, Type elementType,
        -:   41:                                 StringRef operand) {
    #####:   42:  return Base::get(elementType.getContext(), shape, elementType, operand);
call    0 never executed
call    1 never executed
        -:   43:}
        -:   44:
        -:   45:MMAMatrixType
function _ZN4mlir3gpu13MMAMatrixType10getCheckedEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS2_8ArrayRefIlEENS_4TypeENS2_9StringRefE called 0 returned 0% blocks executed 0%
    #####:   46:MMAMatrixType::getChecked(function_ref<InFlightDiagnostic()> emitError,
        -:   47:                          ArrayRef<int64_t> shape, Type elementType,
        -:   48:                          StringRef operand) {
    #####:   49:  return Base::getChecked(emitError, elementType.getContext(), shape,
    #####:   50:                          elementType, operand);
call    0 never executed
call    1 never executed
call    2 never executed
        -:   51:}
        -:   52:
function _ZNK4mlir3gpu13MMAMatrixType10getNumDimsEv called 0 returned 0% blocks executed 0%
    #####:   53:unsigned MMAMatrixType::getNumDims() const { return getImpl()->numDims; }
        -:   54:
function _ZNK4mlir3gpu13MMAMatrixType8getShapeEv called 0 returned 0% blocks executed 0%
    #####:   55:ArrayRef<int64_t> MMAMatrixType::getShape() const {
    #####:   56:  return getImpl()->getShape();
branch  0 never executed
branch  1 never executed
        -:   57:}
        -:   58:
function _ZNK4mlir3gpu13MMAMatrixType14getElementTypeEv called 0 returned 0% blocks executed 0%
    #####:   59:Type MMAMatrixType::getElementType() const { return getImpl()->elementType; }
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
        -:   60:
function _ZNK4mlir3gpu13MMAMatrixType10getOperandEv called 0 returned 0% blocks executed 0%
    #####:   61:StringRef MMAMatrixType::getOperand() const { return getImpl()->getOperand(); }
        -:   62:
function _ZN4mlir3gpu13MMAMatrixType18isValidElementTypeENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:   63:bool MMAMatrixType::isValidElementType(Type elementType) {
    #####:   64:  return elementType.isF16() || elementType.isF32();
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
        -:   65:}
        -:   66:
        -:   67:LogicalResult
function _ZN4mlir3gpu13MMAMatrixType6verifyEN4llvm12function_refIFNS_18InFlightDiagnosticEvEEENS2_8ArrayRefIlEENS_4TypeENS2_9StringRefE called 0 returned 0% blocks executed 0%
    #####:   68:MMAMatrixType::verify(function_ref<InFlightDiagnostic()> emitError,
        -:   69:                      ArrayRef<int64_t> shape, Type elementType,
        -:   70:                      StringRef operand) {
    #####:   71:  if (!operand.equals("AOp") && !operand.equals("BOp") &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   72:      !operand.equals("COp"))
branch  0 never executed
branch  1 never executed
    #####:   73:    return emitError() << "operand expected to be one of AOp, BOp or COp";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   74:
    #####:   75:  if (shape.size() != 2)
branch  0 never executed
branch  1 never executed
    #####:   76:    return emitError() << "MMAMatrixType must have exactly two dimensions";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   77:
    #####:   78:  if (!MMAMatrixType::isValidElementType(elementType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   79:    return emitError() << "MMAMatrixType elements must be F16 or F32";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   80:
    #####:   81:  return success();
        -:   82:}
        -:   83:
        -:   84://===----------------------------------------------------------------------===//
        -:   85:// GPUDialect
        -:   86://===----------------------------------------------------------------------===//
        -:   87:
        -:   88:/// GPU memory space identifiers.
        -:   89:enum GPUMemorySpace {
        -:   90:  /// Generic memory space identifier.
        -:   91:  kGenericMemorySpace = 0,
        -:   92:
        -:   93:  /// Global memory space identifier.
        -:   94:  kGlobalMemorySpace = 1,
        -:   95:
        -:   96:  /// Shared memory space identifier.
        -:   97:  kSharedMemorySpace = 3
        -:   98:};
        -:   99:
function _ZN4mlir3gpu10GPUDialect8isKernelEPNS_9OperationE called 0 returned 0% blocks executed 0%
    #####:  100:bool GPUDialect::isKernel(Operation *op) {
    #####:  101:  UnitAttr isKernelAttr = op->getAttrOfType<UnitAttr>(getKernelFuncAttrName());
call    0 never executed
    #####:  102:  return static_cast<bool>(isKernelAttr);
        -:  103:}
        -:  104:
        -:  105:namespace {
        -:  106:/// This class defines the interface for handling inlining with gpu
        -:  107:/// operations.
        -:  108:struct GPUInlinerInterface : public DialectInlinerInterface {
        -:  109:  using DialectInlinerInterface::DialectInlinerInterface;
        -:  110:
        -:  111:  /// All gpu dialect ops can be inlined.
function _ZNK12_GLOBAL__N_119GPUInlinerInterface15isLegalToInlineEPN4mlir9OperationEPNS1_6RegionEbRNS1_20BlockAndValueMappingE called 0 returned 0% blocks executed 0%
    #####:  112:  bool isLegalToInline(Operation *, Region *, bool,
        -:  113:                       BlockAndValueMapping &) const final {
    #####:  114:    return true;
        -:  115:  }
        -:  116:};
        -:  117:} // namespace
        -:  118:
function _ZN4mlir3gpu10GPUDialect10initializeEv called 4149 returned 100% blocks executed 100%
     4149:  119:void GPUDialect::initialize() {
     4149:  120:  addTypes<AsyncTokenType>();
call    0 returned 100%
     4149:  121:  addTypes<MMAMatrixType>();
call    0 returned 100%
     4149:  122:  addOperations<
        -:  123:#define GET_OP_LIST
        -:  124:#include "mlir/Dialect/GPU/IR/GPUOps.cpp.inc"
     4149:  125:      >();
call    0 returned 100%
     4149:  126:  addAttributes<
        -:  127:#define GET_ATTRDEF_LIST
        -:  128:#include "mlir/Dialect/GPU/IR/GPUOpsAttributes.cpp.inc"
     4149:  129:      >();
call    0 returned 100%
     4149:  130:  addInterfaces<GPUInlinerInterface>();
call    0 returned 100%
     4149:  131:}
        -:  132:
function _ZNK4mlir3gpu10GPUDialect9parseTypeERNS_16DialectAsmParserE called 0 returned 0% blocks executed 0%
    #####:  133:Type GPUDialect::parseType(DialectAsmParser &parser) const {
        -:  134:  // Parse the main keyword for the type.
    #####:  135:  StringRef keyword;
    #####:  136:  if (parser.parseKeyword(&keyword))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  137:    return Type();
    #####:  138:  MLIRContext *context = getContext();
branch  0 never executed
branch  1 never executed
        -:  139:
        -:  140:  // Handle 'async token' types.
    #####:  141:  if (keyword == "async.token")
branch  0 never executed
branch  1 never executed
    #####:  142:    return AsyncTokenType::get(context);
call    0 never executed
        -:  143:
    #####:  144:  if (keyword == "mma_matrix") {
branch  0 never executed
branch  1 never executed
    #####:  145:    SMLoc beginLoc = parser.getNameLoc();
call    0 never executed
        -:  146:
        -:  147:    // Parse '<'.
    #####:  148:    if (parser.parseLess())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  149:      return nullptr;
        -:  150:
        -:  151:    // Parse the size and elementType.
    #####:  152:    SmallVector<int64_t> shape;
call    0 never executed
    #####:  153:    Type elementType;
    #####:  154:    if (parser.parseDimensionList(shape, /*allowDynamic=*/false) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  155:        parser.parseType(elementType))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  156:      return nullptr;
        -:  157:
        -:  158:    // Parse ','
    #####:  159:    if (parser.parseComma())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  160:      return nullptr;
        -:  161:
        -:  162:    // Parse operand.
    #####:  163:    std::string operand;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  164:    if (failed(parser.parseOptionalString(&operand)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  165:      return nullptr;
        -:  166:
        -:  167:    // Parse '>'.
    #####:  168:    if (parser.parseGreater())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  169:      return nullptr;
        -:  170:
    #####:  171:    return MMAMatrixType::getChecked(mlir::detail::getDefaultDiagnosticEmitFn(
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  172:                                         parser.getEncodedSourceLoc(beginLoc)),
call    0 never executed
    #####:  173:                                     shape, elementType, operand);
call    0 never executed
call    1 never executed
call    2 never executed
        -:  174:  }
        -:  175:
    #####:  176:  parser.emitError(parser.getNameLoc(), "unknown gpu type: " + keyword);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  177:  return Type();
        -:  178:}
        -:  179:
function _ZNK4mlir3gpu10GPUDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  180:void GPUDialect::printType(Type type, DialectAsmPrinter &os) const {
    #####:  181:  TypeSwitch<Type>(type)
call    0 never executed
function _ZZNK4mlir3gpu10GPUDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterEENKUlS2_E_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  182:      .Case<AsyncTokenType>([&](Type) { os << "async.token"; })
call    0 never executed
call    1 never executed
function _ZZNK4mlir3gpu10GPUDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterEENKUlNS0_13MMAMatrixTypeEE0_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  183:      .Case<MMAMatrixType>([&](MMAMatrixType fragTy) {
    #####:  184:        os << "mma_matrix<";
call    0 never executed
    #####:  185:        auto shape = fragTy.getShape();
    #####:  186:        for (auto dim = shape.begin(), e = shape.end() - 1; dim != e; ++dim)
branch  0 never executed
branch  1 never executed
    #####:  187:          os << *dim << 'x';
call    0 never executed
call    1 never executed
    #####:  188:        os << shape.back() << 'x' << fragTy.getElementType();
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  189:        os << ", \"" << fragTy.getOperand() << "\"" << '>';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  190:      })
call    0 never executed
function _ZZNK4mlir3gpu10GPUDialect9printTypeENS_4TypeERNS_17DialectAsmPrinterEENKUlS2_E1_clES2_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  191:      .Default([](Type) { llvm_unreachable("unexpected 'gpu' type kind"); });
branch  0 never executed
branch  1 never executed
    #####:  192:}
        -:  193:
function _ZN4mlir3gpu10GPUDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeE called 0 returned 0% blocks executed 0%
    #####:  194:LogicalResult GPUDialect::verifyOperationAttribute(Operation *op,
        -:  195:                                                   NamedAttribute attr) {
    #####:  196:  if (!attr.getValue().isa<UnitAttr>() ||
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  197:      attr.getName() != getContainerModuleAttrName())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  198:    return success();
        -:  199:
    #####:  200:  auto module = dyn_cast<ModuleOp>(op);
call    0 never executed
    #####:  201:  if (!module)
branch  0 never executed
branch  1 never executed
    #####:  202:    return op->emitError("expected '")
call    0 never executed
call    1 never executed
    #####:  203:           << getContainerModuleAttrName() << "' attribute to be attached to '"
call    0 never executed
call    1 never executed
    #####:  204:           << ModuleOp::getOperationName() << '\'';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  205:
function _ZZN4mlir3gpu10GPUDialect24verifyOperationAttributeEPNS_9OperationENS_14NamedAttributeEENKUlNS0_12LaunchFuncOpEE_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  206:  auto walkResult = module.walk([&module](LaunchFuncOp launchOp) -> WalkResult {
        -:  207:    // Ignore launches that are nested more or less deep than functions in the
        -:  208:    // module we are currently checking.
    #####:  209:    if (!launchOp->getParentOp() ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  210:        launchOp->getParentOp()->getParentOp() != module)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  211:      return success();
        -:  212:
        -:  213:    // Ignore launch ops with missing attributes here. The errors will be
        -:  214:    // reported by the verifiers of those ops.
    #####:  215:    if (!launchOp->getAttrOfType<SymbolRefAttr>(
branch  0 never executed
branch  1 never executed
    #####:  216:            LaunchFuncOp::getKernelAttrName(launchOp->getName())))
call    0 never executed
call    1 never executed
    #####:  217:      return success();
        -:  218:
        -:  219:    // Check that `launch_func` refers to a well-formed GPU kernel module.
    #####:  220:    StringAttr kernelModuleName = launchOp.getKernelModuleName();
call    0 never executed
    #####:  221:    auto kernelModule = module.lookupSymbol<GPUModuleOp>(kernelModuleName);
call    0 never executed
    #####:  222:    if (!kernelModule)
branch  0 never executed
branch  1 never executed
    #####:  223:      return launchOp.emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  224:             << "kernel module '" << kernelModuleName.getValue()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  225:             << "' is undefined";
call    0 never executed
        -:  226:
        -:  227:    // Check that `launch_func` refers to a well-formed kernel function.
    #####:  228:    Operation *kernelFunc = module.lookupSymbol(launchOp.getKernelAttr());
call    0 never executed
call    1 never executed
    #####:  229:    if (!kernelFunc)
branch  0 never executed
branch  1 never executed
    #####:  230:      return launchOp.emitOpError("kernel function '")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  231:             << launchOp.getKernel() << "' is undefined";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  232:    auto kernelConvertedFunction = dyn_cast<FunctionOpInterface>(kernelFunc);
call    0 never executed
    #####:  233:    if (!kernelConvertedFunction) {
branch  0 never executed
branch  1 never executed
    #####:  234:      InFlightDiagnostic diag = launchOp.emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  235:                                << "referenced kernel '" << launchOp.getKernel()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  236:                                << "' is not a function";
call    0 never executed
call    1 never executed
    #####:  237:      diag.attachNote(kernelFunc->getLoc()) << "see the kernel definition here";
call    0 never executed
call    1 never executed
    #####:  238:      return diag;
call    0 never executed
        -:  239:    }
        -:  240:
    #####:  241:    if (!kernelFunc->getAttrOfType<mlir::UnitAttr>(
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  242:            GPUDialect::getKernelFuncAttrName()))
call    0 never executed
    #####:  243:      return launchOp.emitOpError("kernel function is missing the '")
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  244:             << GPUDialect::getKernelFuncAttrName() << "' attribute";
call    0 never executed
call    1 never executed
call    2 never executed
        -:  245:
        -:  246:    // TODO: If the kernel isn't a GPU function (which happens during separate
        -:  247:    // compilation), do not check type correspondence as it would require the
        -:  248:    // verifier to be aware of the type conversion.
    #####:  249:    auto kernelGPUFunction = dyn_cast<gpu::GPUFuncOp>(kernelFunc);
call    0 never executed
    #####:  250:    if (!kernelGPUFunction)
branch  0 never executed
branch  1 never executed
    #####:  251:      return success();
        -:  252:
    #####:  253:    unsigned actualNumArguments = launchOp.getNumKernelOperands();
    #####:  254:    unsigned expectedNumArguments = kernelGPUFunction.getNumArguments();
call    0 never executed
    #####:  255:    if (expectedNumArguments != actualNumArguments)
branch  0 never executed
branch  1 never executed
    #####:  256:      return launchOp.emitOpError("got ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  257:             << actualNumArguments << " kernel operands but expected "
call    0 never executed
call    1 never executed
    #####:  258:             << expectedNumArguments;
call    0 never executed
        -:  259:
    #####:  260:    auto functionType = kernelGPUFunction.getFunctionType();
call    0 never executed
    #####:  261:    for (unsigned i = 0; i < expectedNumArguments; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  262:      if (launchOp.getKernelOperand(i).getType() != functionType.getInput(i)) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  263:        return launchOp.emitOpError("type of function argument ")
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  264:               << i << " does not match";
call    0 never executed
call    1 never executed
        -:  265:      }
        -:  266:    }
        -:  267:
    #####:  268:    return success();
    #####:  269:  });
call    0 never executed
        -:  270:
    #####:  271:  return walkResult.wasInterrupted() ? failure() : success();
branch  0 never executed
branch  1 never executed
        -:  272:}
        -:  273:
        -:  274:/// Parses an optional list of async operands with an optional leading keyword.
        -:  275:/// (`async`)? (`[` ssa-id-list `]`)?
        -:  276:///
        -:  277:/// This method is used by the tablegen assembly format for async ops as well.
function _ZL22parseAsyncDependenciesRN4mlir11OpAsmParserERNS_4TypeERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEE called 0 returned 0% blocks executed 0%
    #####:  278:static ParseResult parseAsyncDependencies(
        -:  279:    OpAsmParser &parser, Type &asyncTokenType,
        -:  280:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &asyncDependencies) {
    #####:  281:  auto loc = parser.getCurrentLocation();
call    0 never executed
    #####:  282:  if (succeeded(parser.parseOptionalKeyword("async"))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  283:    if (parser.getNumResults() == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  284:      return parser.emitError(loc, "needs to be named when marked 'async'");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  285:    asyncTokenType = parser.getBuilder().getType<AsyncTokenType>();
call    0 never executed
call    1 never executed
        -:  286:  }
    #####:  287:  return parser.parseOperandList(asyncDependencies,
    #####:  288:                                 OpAsmParser::Delimiter::OptionalSquare);
call    0 never executed
        -:  289:}
        -:  290:
        -:  291:/// Prints optional async dependencies with its leading keyword.
        -:  292:///   (`async`)? (`[` ssa-id-list `]`)?
        -:  293:// Used by the tablegen assembly format for several async ops.
        -:  294:static void printAsyncDependencies(OpAsmPrinter &printer, Operation *op,
        -:  295:                                   Type asyncTokenType,
        -:  296:                                   OperandRange asyncDependencies) {
        -:  297:  if (asyncTokenType)
        -:  298:    printer << "async";
        -:  299:  if (asyncDependencies.empty())
        -:  300:    return;
        -:  301:  if (asyncTokenType)
        -:  302:    printer << ' ';
        -:  303:  printer << '[';
        -:  304:  llvm::interleaveComma(asyncDependencies, printer);
        -:  305:  printer << ']';
        -:  306:}
        -:  307:
        -:  308://===----------------------------------------------------------------------===//
        -:  309:// AllReduceOp
        -:  310://===----------------------------------------------------------------------===//
        -:  311:
function _ZL21verifyReduceOpAndTypeN4mlir3gpu18AllReduceOperationENS_4TypeE called 0 returned 0% blocks executed 0%
    #####:  312:static bool verifyReduceOpAndType(gpu::AllReduceOperation opName,
        -:  313:                                  Type resType) {
    #####:  314:  if ((opName == gpu::AllReduceOperation::AND ||
    #####:  315:       opName == gpu::AllReduceOperation::OR ||
branch  0 never executed
branch  1 never executed
    #####:  316:       opName == gpu::AllReduceOperation::XOR) &&
branch  0 never executed
branch  1 never executed
    #####:  317:      !resType.isa<IntegerType>())
branch  0 never executed
branch  1 never executed
    #####:  318:    return false;
        -:  319:
        -:  320:  return true;
        -:  321:}
        -:  322:
function _ZN4mlir3gpu11AllReduceOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####:  323:LogicalResult gpu::AllReduceOp::verifyRegions() {
    #####:  324:  if (getBody().empty() != getOp().has_value())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  325:    return emitError("expected either an op attribute or a non-empty body");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  326:  if (!getBody().empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:    if (getBody().getNumArguments() != 2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  328:      return emitError("expected two region arguments");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  329:    for (auto argument : getBody().getArguments()) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  330:      if (argument.getType() != getType())
branch  0 never executed
branch  1 never executed
    #####:  331:        return emitError("incorrect region argument type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  332:    }
    #####:  333:    unsigned yieldCount = 0;
    #####:  334:    for (Block &block : getBody()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  335:      if (auto yield = dyn_cast<gpu::YieldOp>(block.getTerminator())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  336:        if (yield.getNumOperands() != 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  337:          return emitError("expected one gpu.yield operand");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  338:        if (yield.getOperand(0).getType() != getType())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  339:          return emitError("incorrect gpu.yield type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  340:        ++yieldCount;
        -:  341:      }
        -:  342:    }
    #####:  343:    if (yieldCount == 0)
branch  0 never executed
branch  1 never executed
    #####:  344:      return emitError("expected gpu.yield op in region");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  345:  } else {
    #####:  346:    gpu::AllReduceOperation opName = *getOp();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  347:    if (!verifyReduceOpAndType(opName, getType())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  348:      return emitError()
call    0 never executed
call    1 never executed
    #####:  349:             << '`' << gpu::stringifyAllReduceOperation(opName)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  350:             << "` accumulator is only compatible with Integer type";
call    0 never executed
        -:  351:    }
        -:  352:  }
    #####:  353:  return success();
        -:  354:}
        -:  355:
        -:  356:// TODO: Support optional custom attributes (without dialect prefix).
function _ZL23parseAllReduceOperationRN4mlir9AsmParserERNS_3gpu22AllReduceOperationAttrE called 0 returned 0% blocks executed 0%
    #####:  357:static ParseResult parseAllReduceOperation(AsmParser &parser,
        -:  358:                                           AllReduceOperationAttr &attr) {
    #####:  359:  StringRef enumStr;
    #####:  360:  if (!parser.parseOptionalKeyword(&enumStr)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  361:    Optional<AllReduceOperation> op = gpu::symbolizeAllReduceOperation(enumStr);
call    0 never executed
    #####:  362:    if (!op)
branch  0 never executed
branch  1 never executed
    #####:  363:      return parser.emitError(parser.getCurrentLocation(), "invalid op kind");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:  364:    attr = AllReduceOperationAttr::get(parser.getContext(), *op);
call    0 never executed
call    1 never executed
        -:  365:  }
    #####:  366:  return success();
        -:  367:}
        -:  368:
    #####:  369:static void printAllReduceOperation(AsmPrinter &printer, Operation *op,
        -:  370:                                    AllReduceOperationAttr attr) {
    #####:  371:  if (attr)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  372:    attr.print(printer);
call    0 never executed
call    1 never executed
        -:  373:}
        -:  374:
        -:  375://===----------------------------------------------------------------------===//
        -:  376:// SubgroupReduceOp
        -:  377://===----------------------------------------------------------------------===//
        -:  378:
function _ZN4mlir3gpu16SubgroupReduceOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  379:LogicalResult gpu::SubgroupReduceOp::verify() {
    #####:  380:  gpu::AllReduceOperation opName = getOp();
call    0 never executed
    #####:  381:  if (!verifyReduceOpAndType(opName, getType())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  382:    return emitError() << '`' << gpu::stringifyAllReduceOperation(opName)
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  383:                       << "` accumulator is only compatible with Integer type";
call    0 never executed
        -:  384:  }
    #####:  385:  return success();
        -:  386:}
        -:  387:
        -:  388://===----------------------------------------------------------------------===//
        -:  389:// AsyncOpInterface
        -:  390://===----------------------------------------------------------------------===//
        -:  391:
function _ZN4mlir3gpu18addAsyncDependencyEPNS_9OperationENS_5ValueE called 0 returned 0% blocks executed 0%
    #####:  392:void gpu::addAsyncDependency(Operation *op, Value token) {
    #####:  393:  op->insertOperands(0, {token});
call    0 never executed
call    1 never executed
    #####:  394:  if (!op->template hasTrait<OpTrait::AttrSizedOperandSegments>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  395:    return;
    #####:  396:  auto attrName =
call    0 never executed
    #####:  397:      OpTrait::AttrSizedOperandSegments<void>::getOperandSegmentSizeAttr();
    #####:  398:  auto sizeAttr = op->template getAttrOfType<DenseI32ArrayAttr>(attrName);
call    0 never executed
        -:  399:
        -:  400:  // Async dependencies is the only variadic operand.
    #####:  401:  if (!sizeAttr)
branch  0 never executed
branch  1 never executed
        -:  402:    return;
        -:  403:
    #####:  404:  SmallVector<int32_t, 8> sizes(sizeAttr.asArrayRef());
call    0 never executed
call    1 never executed
    #####:  405:  ++sizes.front();
branch  0 never executed
branch  1 never executed
    #####:  406:  op->setAttr(attrName, Builder(op->getContext()).getDenseI32ArrayAttr(sizes));
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  407:}
        -:  408:
        -:  409://===----------------------------------------------------------------------===//
        -:  410:// LaunchOp
        -:  411://===----------------------------------------------------------------------===//
        -:  412:
function _ZN4mlir3gpu8LaunchOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueES6_S6_S6_S6_S6_S6_NS_4TypeENS_10ValueRangeE called 0 returned 0% blocks executed 0%
    #####:  413:void LaunchOp::build(OpBuilder &builder, OperationState &result,
        -:  414:                     Value gridSizeX, Value gridSizeY, Value gridSizeZ,
        -:  415:                     Value getBlockSizeX, Value getBlockSizeY,
        -:  416:                     Value getBlockSizeZ, Value dynamicSharedMemorySize,
        -:  417:                     Type asyncTokenType, ValueRange asyncDependencies) {
    #####:  418:  result.addOperands(asyncDependencies);
call    0 never executed
    #####:  419:  if (asyncTokenType)
branch  0 never executed
branch  1 never executed
    #####:  420:    result.types.push_back(builder.getType<AsyncTokenType>());
call    0 never executed
call    1 never executed
        -:  421:
        -:  422:  // Add grid and block sizes as op operands, followed by the data operands.
    #####:  423:  result.addOperands({gridSizeX, gridSizeY, gridSizeZ, getBlockSizeX,
call    0 never executed
call    1 never executed
        -:  424:                      getBlockSizeY, getBlockSizeZ});
    #####:  425:  if (dynamicSharedMemorySize)
branch  0 never executed
branch  1 never executed
    #####:  426:    result.addOperands(dynamicSharedMemorySize);
call    0 never executed
call    1 never executed
        -:  427:
        -:  428:  // Create a kernel body region with kNumConfigRegionAttributes + N arguments,
        -:  429:  // where the first kNumConfigRegionAttributes arguments have `index` type and
        -:  430:  // the rest have the same types as the data operands.
    #####:  431:  Region *kernelRegion = result.addRegion();
call    0 never executed
    #####:  432:  Block *body = new Block();
call    0 never executed
call    1 never executed
    #####:  433:  for (unsigned i = 0; i < kNumConfigRegionAttributes; ++i)
branch  0 never executed
branch  1 never executed
    #####:  434:    body->addArgument(builder.getIndexType(), result.location);
call    0 never executed
call    1 never executed
    #####:  435:  kernelRegion->push_back(body);
call    0 never executed
    #####:  436:  SmallVector<int32_t, 8> segmentSizes(8, 1);
call    0 never executed
    #####:  437:  segmentSizes.front() = asyncDependencies.size();
branch  0 never executed
branch  1 never executed
    #####:  438:  segmentSizes.back() = dynamicSharedMemorySize ? 1 : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  439:  result.addAttribute(getOperandSegmentSizeAttr(),
call    0 never executed
    #####:  440:                      builder.getDenseI32ArrayAttr(segmentSizes));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  441:}
        -:  442:
function _ZN4mlir3gpu8LaunchOp11getBlockIdsEv called 0 returned 0% blocks executed 0%
    #####:  443:KernelDim3 LaunchOp::getBlockIds() {
    #####:  444:  assert(!getBody().empty() && "LaunchOp body must not be empty.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  445:  auto args = getBody().getArguments();
call    0 never executed
    #####:  446:  return KernelDim3{args[0], args[1], args[2]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  447:}
        -:  448:
function _ZN4mlir3gpu8LaunchOp12getThreadIdsEv called 0 returned 0% blocks executed 0%
    #####:  449:KernelDim3 LaunchOp::getThreadIds() {
    #####:  450:  assert(!getBody().empty() && "LaunchOp body must not be empty.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  451:  auto args = getBody().getArguments();
call    0 never executed
    #####:  452:  return KernelDim3{args[3], args[4], args[5]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  453:}
        -:  454:
function _ZN4mlir3gpu8LaunchOp11getGridSizeEv called 0 returned 0% blocks executed 0%
    #####:  455:KernelDim3 LaunchOp::getGridSize() {
    #####:  456:  assert(!getBody().empty() && "LaunchOp body must not be empty.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  457:  auto args = getBody().getArguments();
call    0 never executed
    #####:  458:  return KernelDim3{args[6], args[7], args[8]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  459:}
        -:  460:
function _ZN4mlir3gpu8LaunchOp12getBlockSizeEv called 0 returned 0% blocks executed 0%
    #####:  461:KernelDim3 LaunchOp::getBlockSize() {
    #####:  462:  assert(!getBody().empty() && "LaunchOp body must not be empty.");
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####:  463:  auto args = getBody().getArguments();
call    0 never executed
    #####:  464:  return KernelDim3{args[9], args[10], args[11]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  465:}
        -:  466:
function _ZN4mlir3gpu8LaunchOp24getGridSizeOperandValuesEv called 0 returned 0% blocks executed 0%
    #####:  467:KernelDim3 LaunchOp::getGridSizeOperandValues() {
    #####:  468:  auto operands = getOperands().drop_front(getAsyncDependencies().size());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  469:  return KernelDim3{operands[0], operands[1], operands[2]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  470:}
        -:  471:
function _ZN4mlir3gpu8LaunchOp25getBlockSizeOperandValuesEv called 0 returned 0% blocks executed 0%
    #####:  472:KernelDim3 LaunchOp::getBlockSizeOperandValues() {
    #####:  473:  auto operands = getOperands().drop_front(getAsyncDependencies().size());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  474:  return KernelDim3{operands[3], operands[4], operands[5]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  475:}
        -:  476:
function _ZN4mlir3gpu8LaunchOp13verifyRegionsEv called 0 returned 0% blocks executed 0%
    #####:  477:LogicalResult LaunchOp::verifyRegions() {
        -:  478:  // Kernel launch takes kNumConfigOperands leading operands for grid/block
        -:  479:  // sizes and transforms them into kNumConfigRegionAttributes region arguments
        -:  480:  // for block/thread identifiers and grid/block sizes.
    #####:  481:  if (!getBody().empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  482:    if (getBody().getNumArguments() !=
call    0 never executed
    #####:  483:        LaunchOp::kNumConfigOperands + getNumOperands() -
call    0 never executed
call    1 never executed
    #####:  484:            (getDynamicSharedMemorySize() ? 1 : 0) -
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  485:            getAsyncDependencies().size())
branch  0 never executed
branch  1 never executed
    #####:  486:      return emitOpError("unexpected number of region arguments");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  487:  }
        -:  488:
        -:  489:  // Block terminators without successors are expected to exit the kernel region
        -:  490:  // and must be `gpu.terminator`.
    #####:  491:  for (Block &block : getBody()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  492:    if (block.empty())
branch  0 never executed
branch  1 never executed
    #####:  493:      continue;
    #####:  494:    if (block.back().getNumSuccessors() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  495:      continue;
    #####:  496:    if (!isa<gpu::TerminatorOp>(&block.back())) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  497:      return block.back()
call    0 never executed
    #####:  498:          .emitError()
call    0 never executed
call    1 never executed
    #####:  499:          .append("expected '", gpu::TerminatorOp::getOperationName(),
call    0 never executed
    #####:  500:                  "' or a terminator with successors")
    #####:  501:          .attachNote(getLoc())
call    0 never executed
    #####:  502:          .append("in '", LaunchOp::getOperationName(), "' body region");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  503:    }
        -:  504:  }
        -:  505:
    #####:  506:  if (getNumResults() == 0 && getAsyncToken())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  507:    return emitOpError("needs to be named when async keyword is specified");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  508:
    #####:  509:  return success();
        -:  510:}
        -:  511:
        -:  512:// Pretty-print the kernel grid/block size assignment as
        -:  513://   (%iter-x, %iter-y, %iter-z) in
        -:  514://   (%size-x = %ssa-use, %size-y = %ssa-use, %size-z = %ssa-use)
        -:  515:// where %size-* and %iter-* will correspond to the body region arguments.
function _ZL19printSizeAssignmentRN4mlir12OpAsmPrinterENS_3gpu10KernelDim3ES3_S3_ called 0 returned 0% blocks executed 0%
    #####:  516:static void printSizeAssignment(OpAsmPrinter &p, KernelDim3 size,
        -:  517:                                KernelDim3 operands, KernelDim3 ids) {
    #####:  518:  p << '(' << ids.x << ", " << ids.y << ", " << ids.z << ") in (";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
call    6 never executed
    #####:  519:  p << size.x << " = " << operands.x << ", ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  520:  p << size.y << " = " << operands.y << ", ";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  521:  p << size.z << " = " << operands.z << ')';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  522:}
        -:  523:
function _ZN4mlir3gpu8LaunchOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  524:void LaunchOp::print(OpAsmPrinter &p) {
    #####:  525:  if (getAsyncToken()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  526:    p << " async";
call    0 never executed
    #####:  527:    if (!getAsyncDependencies().empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  528:      p << " [" << getAsyncDependencies() << ']';
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  529:  }
        -:  530:  // Print the launch configuration.
    #####:  531:  p << ' ' << getBlocksKeyword();
call    0 never executed
call    1 never executed
    #####:  532:  printSizeAssignment(p, getGridSize(), getGridSizeOperandValues(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  533:                      getBlockIds());
    #####:  534:  p << ' ' << getThreadsKeyword();
call    0 never executed
call    1 never executed
    #####:  535:  printSizeAssignment(p, getBlockSize(), getBlockSizeOperandValues(),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  536:                      getThreadIds());
    #####:  537:  if (getDynamicSharedMemorySize())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  538:    p << ' ' << getDynamicSharedMemorySizeKeyword() << ' '
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  539:      << getDynamicSharedMemorySize();
call    0 never executed
call    1 never executed
        -:  540:
    #####:  541:  p << ' ';
call    0 never executed
    #####:  542:  p.printRegion(getBody(), /*printEntryBlockArgs=*/false);
call    0 never executed
call    1 never executed
    #####:  543:  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{
call    0 never executed
    #####:  544:                              LaunchOp::getOperandSegmentSizeAttr()});
call    0 never executed
    #####:  545:}
        -:  546:
        -:  547:// Parse the size assignment blocks for blocks and threads.  These have the form
        -:  548://   (%region_arg, %region_arg, %region_arg) in
        -:  549://   (%region_arg = %operand, %region_arg = %operand, %region_arg = %operand)
        -:  550:// where %region_arg are percent-identifiers for the region arguments to be
        -:  551:// introduced further (SSA defs), and %operand are percent-identifiers for the
        -:  552:// SSA value uses.
        -:  553:static ParseResult
function _ZL19parseSizeAssignmentRN4mlir11OpAsmParserEN4llvm15MutableArrayRefINS0_17UnresolvedOperandEEES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  554:parseSizeAssignment(OpAsmParser &parser,
        -:  555:                    MutableArrayRef<OpAsmParser::UnresolvedOperand> sizes,
        -:  556:                    MutableArrayRef<OpAsmParser::UnresolvedOperand> regionSizes,
        -:  557:                    MutableArrayRef<OpAsmParser::UnresolvedOperand> indices) {
    #####:  558:  assert(indices.size() == 3 && "space for three indices expected");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  559:  SmallVector<OpAsmParser::UnresolvedOperand, 3> args;
call    0 never executed
    #####:  560:  if (parser.parseOperandList(args, OpAsmParser::Delimiter::Paren,
    #####:  561:                              /*allowResultNumber=*/false) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  562:      parser.parseKeyword("in") || parser.parseLParen())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
    #####:  563:    return failure();
    #####:  564:  std::move(args.begin(), args.end(), indices.begin());
branch  0 never executed
branch  1 never executed
        -:  565:
    #####:  566:  for (int i = 0; i < 3; ++i) {
branch  0 never executed
branch  1 never executed
    #####:  567:    if (i != 0 && parser.parseComma())
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  568:      return failure();
    #####:  569:    if (parser.parseOperand(regionSizes[i], /*allowResultNumber=*/false) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####:  570:        parser.parseEqual() || parser.parseOperand(sizes[i]))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
call    7 never executed
branch  8 never executed
branch  9 never executed
    #####:  571:      return failure();
        -:  572:  }
        -:  573:
    #####:  574:  return parser.parseRParen();
call    0 never executed
        -:  575:}
        -:  576:
        -:  577:/// Parses a Launch operation.
        -:  578:/// operation ::= `gpu.launch` (`async` `[` ssa-id-list `]`)?
        -:  579://        `blocks` `(` ssa-id-list `)` `in` ssa-reassignment
        -:  580:///       `threads` `(` ssa-id-list `)` `in` ssa-reassignment
        -:  581:///       region attr-dict?
        -:  582:/// ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`
function _ZN4mlir3gpu8LaunchOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  583:ParseResult LaunchOp::parse(OpAsmParser &parser, OperationState &result) {
        -:  584:  // Sizes of the grid and block.
    #####:  585:  SmallVector<OpAsmParser::UnresolvedOperand, LaunchOp::kNumConfigOperands>
    #####:  586:      sizes(LaunchOp::kNumConfigOperands);
call    0 never executed
    #####:  587:  MutableArrayRef<OpAsmParser::UnresolvedOperand> sizesRef(sizes);
call    0 never executed
        -:  588:
        -:  589:  // Actual (data) operands passed to the kernel.
    #####:  590:  SmallVector<OpAsmParser::UnresolvedOperand, 4> dataOperands;
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  591:
        -:  592:  // Region arguments to be created.
    #####:  593:  SmallVector<OpAsmParser::UnresolvedOperand, 16> regionArgs(
    #####:  594:      LaunchOp::kNumConfigRegionAttributes);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  595:  MutableArrayRef<OpAsmParser::UnresolvedOperand> regionArgsRef(regionArgs);
call    0 never executed
        -:  596:
        -:  597:  // Parse optional async dependencies.
    #####:  598:  SmallVector<OpAsmParser::UnresolvedOperand, 4> asyncDependencies;
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  599:  Type asyncTokenType;
    #####:  600:  if (failed(
    #####:  601:          parseAsyncDependencies(parser, asyncTokenType, asyncDependencies)) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  602:      parser.resolveOperands(asyncDependencies, asyncTokenType,
    #####:  603:                             result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  604:    return failure();
    #####:  605:  if (parser.getNumResults() > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  606:    result.types.push_back(asyncTokenType);
call    0 never executed
        -:  607:
        -:  608:  // Parse the size assignment segments: the first segment assigns grid sizes
        -:  609:  // and defines values for block identifiers; the second segment assigns block
        -:  610:  // sizes and defines values for thread identifiers.  In the region argument
        -:  611:  // list, identifiers precede sizes, and block-related values precede
        -:  612:  // thread-related values.
    #####:  613:  if (parser.parseKeyword(LaunchOp::getBlocksKeyword().data()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  614:      parseSizeAssignment(parser, sizesRef.take_front(3),
        -:  615:                          regionArgsRef.slice(6, 3),
    #####:  616:                          regionArgsRef.slice(0, 3)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####:  617:      parser.parseKeyword(LaunchOp::getThreadsKeyword().data()) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  618:      parseSizeAssignment(parser, sizesRef.drop_front(3),
        -:  619:                          regionArgsRef.slice(9, 3),
    #####:  620:                          regionArgsRef.slice(3, 3)) ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
call    5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  621:      parser.resolveOperands(sizes, parser.getBuilder().getIndexType(),
call    0 never executed
call    1 never executed
    #####:  622:                             result.operands))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  623:    return failure();
        -:  624:
    #####:  625:  OpAsmParser::UnresolvedOperand dynamicSharedMemorySize;
call    0 never executed
    #####:  626:  bool hasDynamicSharedMemorySize = false;
    #####:  627:  if (!parser.parseOptionalKeyword(
branch  0 never executed
branch  1 never executed
    #####:  628:          LaunchOp::getDynamicSharedMemorySizeKeyword())) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  629:    hasDynamicSharedMemorySize = true;
    #####:  630:    if (parser.parseOperand(dynamicSharedMemorySize) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  631:        parser.resolveOperand(dynamicSharedMemorySize,
    #####:  632:                              parser.getBuilder().getI32Type(),
call    0 never executed
    #####:  633:                              result.operands))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:  634:      return failure();
        -:  635:  }
        -:  636:
        -:  637:  // Introduce the body region and parse it. The region has
        -:  638:  // kNumConfigRegionAttributes arguments that correspond to
        -:  639:  // block/thread identifiers and grid/block sizes, all of the `index` type.
    #####:  640:  Type index = parser.getBuilder().getIndexType();
call    0 never executed
call    1 never executed
    #####:  641:  SmallVector<Type, LaunchOp::kNumConfigRegionAttributes> dataTypes(
call    0 never executed
    #####:  642:      LaunchOp::kNumConfigRegionAttributes, index);
branch  0 never executed
branch  1 never executed
        -:  643:
    #####:  644:  SmallVector<OpAsmParser::Argument> regionArguments;
branch  0 never executed
branch  1 never executed
    #####:  645:  for (auto ssaValueAndType : llvm::zip(regionArgs, dataTypes)) {
branch  0 never executed
branch  1 never executed
    #####:  646:    OpAsmParser::Argument arg;
call    0 never executed
    #####:  647:    arg.ssaName = std::get<0>(ssaValueAndType);
call    0 never executed
    #####:  648:    arg.type = std::get<1>(ssaValueAndType);
call    0 never executed
    #####:  649:    regionArguments.push_back(arg);
call    0 never executed
        -:  650:  }
        -:  651:
    #####:  652:  Region *body = result.addRegion();
call    0 never executed
    #####:  653:  if (parser.parseRegion(*body, regionArguments) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  654:      parser.parseOptionalAttrDict(result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  655:    return failure();
        -:  656:
    #####:  657:  SmallVector<int32_t, 8> segmentSizes(8, 1);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  658:  segmentSizes.front() = asyncDependencies.size();
branch  0 never executed
branch  1 never executed
    #####:  659:  segmentSizes.back() = hasDynamicSharedMemorySize ? 1 : 0;
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  660:  result.addAttribute(LaunchOp::getOperandSegmentSizeAttr(),
call    0 never executed
    #####:  661:                      parser.getBuilder().getDenseI32ArrayAttr(segmentSizes));
call    0 never executed
call    1 never executed
    #####:  662:  return success();
branch  0 never executed
branch  1 never executed
        -:  663:}
        -:  664:
        -:  665:/// Simplify the gpu.launch when the range of a thread or block ID is
        -:  666:/// trivially known to be one.
        -:  667:struct FoldLaunchArguments : public OpRewritePattern<LaunchOp> {
        -:  668:  using OpRewritePattern<LaunchOp>::OpRewritePattern;
function _ZNK19FoldLaunchArguments15matchAndRewriteEN4mlir3gpu8LaunchOpERNS0_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  669:  LogicalResult matchAndRewrite(LaunchOp op,
        -:  670:                                PatternRewriter &rewriter) const override {
        -:  671:    // If the range implies a single value for `id`, replace `id`'s uses by
        -:  672:    // zero.
    #####:  673:    Value zero;
    #####:  674:    bool simplified = false;
function _ZZNK19FoldLaunchArguments15matchAndRewriteEN4mlir3gpu8LaunchOpERNS0_15PatternRewriterEENKUlNS0_5ValueES5_E_clES5_S5_ called 0 returned 0% blocks executed 0%
    #####:  675:    auto constPropIdUses = [&](Value id, Value size) {
        -:  676:      // Check if size is trivially one.
    #####:  677:      if (!matchPattern(size, m_One()))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  678:        return;
    #####:  679:      if (!simplified) {
branch  0 never executed
branch  1 never executed
        -:  680:        // Create a zero value the first time.
    #####:  681:        OpBuilder::InsertionGuard guard(rewriter);
call    0 never executed
    #####:  682:        rewriter.setInsertionPointToStart(&op.getBody().front());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  683:        zero =
branch  0 never executed
branch  1 never executed
    #####:  684:            rewriter.create<arith::ConstantIndexOp>(op.getLoc(), /*value=*/0);
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  685:      }
    #####:  686:      id.replaceAllUsesWith(zero);
call    0 never executed
    #####:  687:      simplified = true;
    #####:  688:    };
    #####:  689:    constPropIdUses(op.getBlockIds().x, op.getGridSizeX());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  690:    constPropIdUses(op.getBlockIds().y, op.getGridSizeY());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  691:    constPropIdUses(op.getBlockIds().z, op.getGridSizeZ());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  692:    constPropIdUses(op.getThreadIds().x, op.getBlockSizeX());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  693:    constPropIdUses(op.getThreadIds().y, op.getBlockSizeY());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  694:    constPropIdUses(op.getThreadIds().z, op.getBlockSizeZ());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  695:
    #####:  696:    return success(simplified);
        -:  697:  }
        -:  698:};
        -:  699:
function _ZN4mlir3gpu8LaunchOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 173 returned 100% blocks executed 100%
      173:  700:void LaunchOp::getCanonicalizationPatterns(RewritePatternSet &rewrites,
        -:  701:                                           MLIRContext *context) {
      173:  702:  rewrites.add<FoldLaunchArguments>(context);
call    0 returned 100%
      173:  703:}
        -:  704:
        -:  705://===----------------------------------------------------------------------===//
        -:  706:// LaunchFuncOp
        -:  707://===----------------------------------------------------------------------===//
        -:  708:
function _ZN4mlir3gpu12LaunchFuncOp5buildERNS_9OpBuilderERNS_14OperationStateENS0_9GPUFuncOpENS0_10KernelDim3ES7_NS_5ValueENS_10ValueRangeENS_4TypeES9_ called 0 returned 0% blocks executed 0%
    #####:  709:void LaunchFuncOp::build(OpBuilder &builder, OperationState &result,
        -:  710:                         GPUFuncOp kernelFunc, KernelDim3 gridSize,
        -:  711:                         KernelDim3 getBlockSize, Value dynamicSharedMemorySize,
        -:  712:                         ValueRange kernelOperands, Type asyncTokenType,
        -:  713:                         ValueRange asyncDependencies) {
    #####:  714:  result.addOperands(asyncDependencies);
call    0 never executed
    #####:  715:  if (asyncTokenType)
branch  0 never executed
branch  1 never executed
    #####:  716:    result.types.push_back(builder.getType<AsyncTokenType>());
call    0 never executed
call    1 never executed
        -:  717:
        -:  718:  // Add grid and block sizes as op operands, followed by the data operands.
    #####:  719:  result.addOperands({gridSize.x, gridSize.y, gridSize.z, getBlockSize.x,
call    0 never executed
call    1 never executed
        -:  720:                      getBlockSize.y, getBlockSize.z});
    #####:  721:  if (dynamicSharedMemorySize)
branch  0 never executed
branch  1 never executed
    #####:  722:    result.addOperands(dynamicSharedMemorySize);
call    0 never executed
call    1 never executed
    #####:  723:  result.addOperands(kernelOperands);
call    0 never executed
    #####:  724:  auto kernelModule = kernelFunc->getParentOfType<GPUModuleOp>();
call    0 never executed
    #####:  725:  auto kernelSymbol =
call    0 never executed
        -:  726:      SymbolRefAttr::get(kernelModule.getNameAttr(),
    #####:  727:                         {SymbolRefAttr::get(kernelFunc.getNameAttr())});
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  728:  result.addAttribute(getKernelAttrName(result.name), kernelSymbol);
call    0 never executed
call    1 never executed
    #####:  729:  SmallVector<int32_t, 9> segmentSizes(9, 1);
call    0 never executed
    #####:  730:  segmentSizes.front() = asyncDependencies.size();
branch  0 never executed
branch  1 never executed
    #####:  731:  segmentSizes[segmentSizes.size() - 2] = dynamicSharedMemorySize ? 1 : 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  732:  segmentSizes.back() = static_cast<int32_t>(kernelOperands.size());
call    0 never executed
    #####:  733:  result.addAttribute(getOperandSegmentSizeAttr(),
call    0 never executed
    #####:  734:                      builder.getDenseI32ArrayAttr(segmentSizes));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  735:}
        -:  736:
function _ZN4mlir3gpu12LaunchFuncOp19getKernelModuleNameEv called 0 returned 0% blocks executed 0%
    #####:  737:StringAttr LaunchFuncOp::getKernelModuleName() {
    #####:  738:  return getKernel().getRootReference();
call    0 never executed
call    1 never executed
        -:  739:}
        -:  740:
function _ZN4mlir3gpu12LaunchFuncOp13getKernelNameEv called 0 returned 0% blocks executed 0%
    #####:  741:StringAttr LaunchFuncOp::getKernelName() {
    #####:  742:  return getKernel().getLeafReference();
call    0 never executed
call    1 never executed
        -:  743:}
        -:  744:
function _ZN4mlir3gpu12LaunchFuncOp20getNumKernelOperandsEv called 0 returned 0% blocks executed 0%
    #####:  745:unsigned LaunchFuncOp::getNumKernelOperands() {
    #####:  746:  return getKernelOperands().size();
call    0 never executed
call    1 never executed
call    2 never executed
        -:  747:}
        -:  748:
function _ZN4mlir3gpu12LaunchFuncOp16getKernelOperandEj called 0 returned 0% blocks executed 0%
    #####:  749:Value LaunchFuncOp::getKernelOperand(unsigned i) {
    #####:  750:  return getKernelOperands()[i];
call    0 never executed
call    1 never executed
        -:  751:}
        -:  752:
function _ZN4mlir3gpu12LaunchFuncOp24getGridSizeOperandValuesEv called 0 returned 0% blocks executed 0%
    #####:  753:KernelDim3 LaunchFuncOp::getGridSizeOperandValues() {
    #####:  754:  auto operands = getOperands().drop_front(getAsyncDependencies().size());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  755:  return KernelDim3{operands[0], operands[1], operands[2]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  756:}
        -:  757:
function _ZN4mlir3gpu12LaunchFuncOp25getBlockSizeOperandValuesEv called 0 returned 0% blocks executed 0%
    #####:  758:KernelDim3 LaunchFuncOp::getBlockSizeOperandValues() {
    #####:  759:  auto operands = getOperands().drop_front(getAsyncDependencies().size());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  760:  return KernelDim3{operands[3], operands[4], operands[5]};
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  761:}
        -:  762:
function _ZN4mlir3gpu12LaunchFuncOp6verifyEv called 0 returned 0% blocks executed 0%
    #####:  763:LogicalResult LaunchFuncOp::verify() {
    #####:  764:  auto module = (*this)->getParentOfType<ModuleOp>();
call    0 never executed
    #####:  765:  if (!module)
branch  0 never executed
branch  1 never executed
    #####:  766:    return emitOpError("expected to belong to a module");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  767:
    #####:  768:  if (!module->getAttrOfType<UnitAttr>(
branch  0 never executed
branch  1 never executed
    #####:  769:          GPUDialect::getContainerModuleAttrName()))
call    0 never executed
    #####:  770:    return emitOpError("expected the closest surrounding module to have the '" +
call    0 never executed
    #####:  771:                       GPUDialect::getContainerModuleAttrName() +
call    0 never executed
call    1 never executed
    #####:  772:                       "' attribute");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  773:
    #####:  774:  return success();
        -:  775:}
        -:  776:
function _ZL23parseLaunchFuncOperandsRN4mlir11OpAsmParserERN4llvm15SmallVectorImplINS0_17UnresolvedOperandEEERNS3_INS_4TypeEEE called 0 returned 0% blocks executed 0%
    #####:  777:static ParseResult parseLaunchFuncOperands(
        -:  778:    OpAsmParser &parser,
        -:  779:    SmallVectorImpl<OpAsmParser::UnresolvedOperand> &argNames,
        -:  780:    SmallVectorImpl<Type> &argTypes) {
    #####:  781:  if (parser.parseOptionalKeyword("args"))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  782:    return success();
        -:  783:
    #####:  784:  SmallVector<OpAsmParser::Argument> args;
call    0 never executed
    #####:  785:  if (parser.parseArgumentList(args, OpAsmParser::Delimiter::Paren,
branch  0 never executed
branch  1 never executed
    #####:  786:                               /*allowType=*/true))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  787:    return failure();
    #####:  788:  for (auto &arg : args) {
branch  0 never executed
branch  1 never executed
    #####:  789:    argNames.push_back(arg.ssaName);
call    0 never executed
    #####:  790:    argTypes.push_back(arg.type);
call    0 never executed
        -:  791:  }
    #####:  792:  return success();
        -:  793:}
        -:  794:
        -:  795:static void printLaunchFuncOperands(OpAsmPrinter &printer, Operation *,
        -:  796:                                    OperandRange operands, TypeRange types) {
        -:  797:  if (operands.empty())
        -:  798:    return;
        -:  799:  printer << "args(";
        -:  800:  llvm::interleaveComma(llvm::zip(operands, types), printer,
function _ZZL23printLaunchFuncOperandsRN4mlir12OpAsmPrinterEPNS_9OperationENS_12OperandRangeENS_9TypeRangeEENKUlRKT_E_clISt5tupleIJNS_5ValueENS_4TypeEEEEEDaS8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  801:                        [&](const auto &pair) {
    #####:  802:                          printer.printOperand(std::get<0>(pair));
call    0 never executed
call    1 never executed
    #####:  803:                          printer << " : ";
    #####:  804:                          printer.printType(std::get<1>(pair));
call    0 never executed
    #####:  805:                        });
        -:  806:  printer << ")";
        -:  807:}
        -:  808:
        -:  809://===----------------------------------------------------------------------===//
        -:  810:// ShuffleOp
        -:  811://===----------------------------------------------------------------------===//
        -:  812:
function _ZN4mlir3gpu9ShuffleOp5buildERNS_9OpBuilderERNS_14OperationStateENS_5ValueEiiNS0_11ShuffleModeE called 0 returned 0% blocks executed 0%
    #####:  813:void ShuffleOp::build(OpBuilder &builder, OperationState &result, Value value,
        -:  814:                      int32_t offset, int32_t width, ShuffleMode mode) {
    #####:  815:  build(builder, result, value,
call    0 never executed
    #####:  816:        builder.create<arith::ConstantOp>(result.location,
    #####:  817:                                          builder.getI32IntegerAttr(offset)),
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  818:        builder.create<arith::ConstantOp>(result.location,
    #####:  819:                                          builder.getI32IntegerAttr(width)),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  820:        mode);
    #####:  821:}
        -:  822:
        -:  823://===----------------------------------------------------------------------===//
        -:  824:// GPUFuncOp
        -:  825://===----------------------------------------------------------------------===//
        -:  826:
        -:  827:/// Adds a new block argument that corresponds to buffers located in
        -:  828:/// workgroup memory.
function _ZN4mlir3gpu9GPUFuncOp23addWorkgroupAttributionENS_4TypeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  829:BlockArgument GPUFuncOp::addWorkgroupAttribution(Type type, Location loc) {
    #####:  830:  auto attrName = getNumWorkgroupAttributionsAttrName();
call    0 never executed
    #####:  831:  auto attr = (*this)->getAttrOfType<IntegerAttr>(attrName);
call    0 never executed
    #####:  832:  (*this)->setAttr(attrName,
call    0 never executed
call    1 never executed
    #####:  833:                   IntegerAttr::get(attr.getType(), attr.getValue() + 1));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  834:  return getBody().insertArgument(
call    0 never executed
    #####:  835:      getFunctionType().getNumInputs() + attr.getInt(), type, loc);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  836:}
        -:  837:
        -:  838:/// Adds a new block argument that corresponds to buffers located in
        -:  839:/// private memory.
function _ZN4mlir3gpu9GPUFuncOp21addPrivateAttributionENS_4TypeENS_8LocationE called 0 returned 0% blocks executed 0%
    #####:  840:BlockArgument GPUFuncOp::addPrivateAttribution(Type type, Location loc) {
        -:  841:  // Buffers on the private memory always come after buffers on the workgroup
        -:  842:  // memory.
    #####:  843:  return getBody().addArgument(type, loc);
call    0 never executed
call    1 never executed
        -:  844:}
        -:  845:
function _ZN4mlir3gpu9GPUFuncOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm9StringRefENS_12FunctionTypeENS_9TypeRangeES9_NS6_8ArrayRefINS_14NamedAttributeEEE called 0 returned 0% blocks executed 0%
    #####:  846:void GPUFuncOp::build(OpBuilder &builder, OperationState &result,
        -:  847:                      StringRef name, FunctionType type,
        -:  848:                      TypeRange workgroupAttributions,
        -:  849:                      TypeRange privateAttributions,
        -:  850:                      ArrayRef<NamedAttribute> attrs) {
    #####:  851:  result.addAttribute(SymbolTable::getSymbolAttrName(),
call    0 never executed
    #####:  852:                      builder.getStringAttr(name));
call    0 never executed
call    1 never executed
    #####:  853:  result.addAttribute(getTypeAttrName(), TypeAttr::get(type));
call    0 never executed
call    1 never executed
    #####:  854:  result.addAttribute(getNumWorkgroupAttributionsAttrName(),
call    0 never executed
    #####:  855:                      builder.getI64IntegerAttr(workgroupAttributions.size()));
call    0 never executed
    #####:  856:  result.addAttributes(attrs);
call    0 never executed
    #####:  857:  Region *body = result.addRegion();
call    0 never executed
    #####:  858:  Block *entryBlock = new Block;
call    0 never executed
call    1 never executed
        -:  859:
        -:  860:  // TODO: Allow passing in proper locations here.
    #####:  861:  for (Type argTy : type.getInputs())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  862:    entryBlock->addArgument(argTy, result.location);
call    0 never executed
    #####:  863:  for (Type argTy : workgroupAttributions)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  864:    entryBlock->addArgument(argTy, result.location);
call    0 never executed
    #####:  865:  for (Type argTy : privateAttributions)
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  866:    entryBlock->addArgument(argTy, result.location);
call    0 never executed
        -:  867:
    #####:  868:  body->getBlocks().push_back(entryBlock);
call    0 never executed
    #####:  869:}
        -:  870:
        -:  871:/// Parses a GPU function memory attribution.
        -:  872:///
        -:  873:/// memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
        -:  874:///                        (`private` `(` ssa-id-and-type-list `)`)?
        -:  875:///
        -:  876:/// Note that this function parses only one of the two similar parts, with the
        -:  877:/// keyword provided as argument.
        -:  878:static ParseResult
function _ZL17parseAttributionsRN4mlir11OpAsmParserEN4llvm9StringRefERNS2_15SmallVectorImplINS0_8ArgumentEEE called 0 returned 0% blocks executed 0%
    #####:  879:parseAttributions(OpAsmParser &parser, StringRef keyword,
        -:  880:                  SmallVectorImpl<OpAsmParser::Argument> &args) {
        -:  881:  // If we could not parse the keyword, just assume empty list and succeed.
    #####:  882:  if (failed(parser.parseOptionalKeyword(keyword)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  883:    return success();
        -:  884:
    #####:  885:  return parser.parseArgumentList(args, OpAsmParser::Delimiter::Paren,
    #####:  886:                                  /*allowType=*/true);
call    0 never executed
        -:  887:}
        -:  888:
        -:  889:/// Parses a GPU function.
        -:  890:///
        -:  891:/// <operation> ::= `gpu.func` symbol-ref-id `(` argument-list `)`
        -:  892:///                 (`->` function-result-list)? memory-attribution `kernel`?
        -:  893:///                 function-attributes? region
function _ZN4mlir3gpu9GPUFuncOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####:  894:ParseResult GPUFuncOp::parse(OpAsmParser &parser, OperationState &result) {
    #####:  895:  SmallVector<OpAsmParser::Argument> entryArgs;
call    0 never executed
    #####:  896:  SmallVector<DictionaryAttr> resultAttrs;
branch  0 never executed
branch  1 never executed
    #####:  897:  SmallVector<Type> resultTypes;
branch  0 never executed
branch  1 never executed
    #####:  898:  bool isVariadic;
        -:  899:
        -:  900:  // Parse the function name.
    #####:  901:  StringAttr nameAttr;
    #####:  902:  if (parser.parseSymbolName(nameAttr, ::mlir::SymbolTable::getSymbolAttrName(),
branch  0 never executed
branch  1 never executed
    #####:  903:                             result.attributes))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  904:    return failure();
        -:  905:
    #####:  906:  auto signatureLocation = parser.getCurrentLocation();
call    0 never executed
    #####:  907:  if (failed(function_interface_impl::parseFunctionSignature(
branch  0 never executed
branch  1 never executed
        -:  908:          parser, /*allowVariadic=*/false, entryArgs, isVariadic, resultTypes,
    #####:  909:          resultAttrs)))
call    0 never executed
    #####:  910:    return failure();
        -:  911:
    #####:  912:  if (!entryArgs.empty() && entryArgs[0].ssaName.name.empty())
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  913:    return parser.emitError(signatureLocation)
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  914:           << "gpu.func requires named arguments";
call    0 never executed
call    1 never executed
        -:  915:
        -:  916:  // Construct the function type. More types will be added to the region, but
        -:  917:  // not to the function type.
    #####:  918:  Builder &builder = parser.getBuilder();
call    0 never executed
        -:  919:
    #####:  920:  SmallVector<Type> argTypes;
branch  0 never executed
branch  1 never executed
    #####:  921:  for (auto &arg : entryArgs)
branch  0 never executed
branch  1 never executed
    #####:  922:    argTypes.push_back(arg.type);
call    0 never executed
    #####:  923:  auto type = builder.getFunctionType(argTypes, resultTypes);
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  924:  result.addAttribute(GPUFuncOp::getTypeAttrName(), TypeAttr::get(type));
call    0 never executed
call    1 never executed
        -:  925:
    #####:  926:  function_interface_impl::addArgAndResultAttrs(builder, result, entryArgs,
call    0 never executed
        -:  927:                                                resultAttrs);
        -:  928:
        -:  929:  // Parse workgroup memory attributions.
    #####:  930:  if (failed(parseAttributions(parser, GPUFuncOp::getWorkgroupKeyword(),
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  931:                               entryArgs)))
call    0 never executed
    #####:  932:    return failure();
        -:  933:
        -:  934:  // Store the number of operands we just parsed as the number of workgroup
        -:  935:  // memory attributions.
    #####:  936:  unsigned numWorkgroupAttrs = entryArgs.size() - type.getNumInputs();
call    0 never executed
    #####:  937:  result.addAttribute(GPUFuncOp::getNumWorkgroupAttributionsAttrName(),
call    0 never executed
    #####:  938:                      builder.getI64IntegerAttr(numWorkgroupAttrs));
call    0 never executed
        -:  939:
        -:  940:  // Parse private memory attributions.
    #####:  941:  if (failed(
call    0 never executed
    #####:  942:          parseAttributions(parser, GPUFuncOp::getPrivateKeyword(), entryArgs)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  943:    return failure();
        -:  944:
        -:  945:  // Parse the kernel attribute if present.
    #####:  946:  if (succeeded(parser.parseOptionalKeyword(GPUFuncOp::getKernelKeyword())))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  947:    result.addAttribute(GPUDialect::getKernelFuncAttrName(),
call    0 never executed
    #####:  948:                        builder.getUnitAttr());
call    0 never executed
        -:  949:
        -:  950:  // Parse attributes.
    #####:  951:  if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  952:    return failure();
        -:  953:
        -:  954:  // Parse the region. If no argument names were provided, take all names
        -:  955:  // (including those of attributions) from the entry block.
    #####:  956:  auto *body = result.addRegion();
call    0 never executed
    #####:  957:  return parser.parseRegion(*body, entryArgs);
call    0 never executed
        -:  958:}
        -:  959:
function _ZL17printAttributionsRN4mlir12OpAsmPrinterEN4llvm9StringRefENS2_8ArrayRefINS_13BlockArgumentEEE called 0 returned 0% blocks executed 0%
    #####:  960:static void printAttributions(OpAsmPrinter &p, StringRef keyword,
        -:  961:                              ArrayRef<BlockArgument> values) {
    #####:  962:  if (values.empty())
branch  0 never executed
branch  1 never executed
        -:  963:    return;
        -:  964:
    #####:  965:  p << ' ' << keyword << '(';
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  966:  llvm::interleaveComma(
call    0 never executed
function _ZZL17printAttributionsRN4mlir12OpAsmPrinterEN4llvm9StringRefENS2_8ArrayRefINS_13BlockArgumentEEEENKUlS5_E_clES5_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  967:      values, p, [&p](BlockArgument v) { p << v << " : " << v.getType(); });
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  968:  p << ')';
call    0 never executed
        -:  969:}
        -:  970:
function _ZN4mlir3gpu9GPUFuncOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####:  971:void GPUFuncOp::print(OpAsmPrinter &p) {
    #####:  972:  p << ' ';
call    0 never executed
    #####:  973:  p.printSymbolName(getName());
call    0 never executed
call    1 never executed
        -:  974:
    #####:  975:  FunctionType type = getFunctionType();
call    0 never executed
    #####:  976:  function_interface_impl::printFunctionSignature(p, *this, type.getInputs(),
call    0 never executed
call    1 never executed
call    2 never executed
        -:  977:                                                  /*isVariadic=*/false,
        -:  978:                                                  type.getResults());
        -:  979:
    #####:  980:  printAttributions(p, getWorkgroupKeyword(), getWorkgroupAttributions());
call    0 never executed
call    1 never executed
    #####:  981:  printAttributions(p, getPrivateKeyword(), getPrivateAttributions());
call    0 never executed
call    1 never executed
    #####:  982:  if (isKernel())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  983:    p << ' ' << getKernelKeyword();
call    0 never executed
call    1 never executed
        -:  984:
    #####:  985:  function_interface_impl::printFunctionAttributes(
call    0 never executed
call    1 never executed
call    2 never executed
        -:  986:      p, *this, type.getNumInputs(), type.getNumResults(),
    #####:  987:      {getNumWorkgroupAttributionsAttrName(),
call    0 never executed
    #####:  988:       GPUDialect::getKernelFuncAttrName()});
call    0 never executed
    #####:  989:  p << ' ';
call    0 never executed
    #####:  990:  p.printRegion(getBody(), /*printEntryBlockArgs=*/false);
call    0 never executed
call    1 never executed
    #####:  991:}
        -:  992:
function _ZN4mlir3gpu9GPUFuncOp10verifyTypeEv called 0 returned 0% blocks executed 0%
    #####:  993:LogicalResult GPUFuncOp::verifyType() {
    #####:  994:  Type type = getFunctionTypeAttr().getValue();
call    0 never executed
call    1 never executed
    #####:  995:  if (!type.isa<FunctionType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  996:    return emitOpError("requires '" + getTypeAttrName() +
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  997:                       "' attribute of function type");
call    0 never executed
call    1 never executed
call    2 never executed
        -:  998:
    #####:  999:  if (isKernel() && getFunctionType().getNumResults() != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1000:    return emitOpError() << "expected void return type for kernel function";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1001:
    #####: 1002:  return success();
        -: 1003:}
        -: 1004:
function _ZL18verifyAttributionsPN4mlir9OperationEN4llvm8ArrayRefINS_13BlockArgumentEEEj called 0 returned 0% blocks executed 0%
    #####: 1005:static LogicalResult verifyAttributions(Operation *op,
        -: 1006:                                        ArrayRef<BlockArgument> attributions,
        -: 1007:                                        unsigned memorySpace) {
    #####: 1008:  for (Value v : attributions) {
branch  0 never executed
branch  1 never executed
    #####: 1009:    auto type = v.getType().dyn_cast<MemRefType>();
call    0 never executed
    #####: 1010:    if (!type)
branch  0 never executed
branch  1 never executed
    #####: 1011:      return op->emitOpError() << "expected memref type in attribution";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -: 1012:
    #####: 1013:    if (type.getMemorySpaceAsInt() != memorySpace) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1014:      return op->emitOpError()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1015:             << "expected memory space " << memorySpace << " in attribution";
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1016:    }
        -: 1017:  }
    #####: 1018:  return success();
        -: 1019:}
        -: 1020:
        -: 1021:/// Verifies the body of the function.
function _ZN4mlir3gpu9GPUFuncOp10verifyBodyEv called 0 returned 0% blocks executed 0%
    #####: 1022:LogicalResult GPUFuncOp::verifyBody() {
    #####: 1023:  if (empty())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1024:    return emitOpError() << "expected body with at least one block";
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1025:  unsigned numFuncArguments = getNumArguments();
call    0 never executed
    #####: 1026:  unsigned numWorkgroupAttributions = getNumWorkgroupAttributions();
call    0 never executed
    #####: 1027:  unsigned numBlockArguments = front().getNumArguments();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1028:  if (numBlockArguments < numFuncArguments + numWorkgroupAttributions)
branch  0 never executed
branch  1 never executed
    #####: 1029:    return emitOpError() << "expected at least "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1030:                         << numFuncArguments + numWorkgroupAttributions
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1031:                         << " arguments to body region";
call    0 never executed
        -: 1032:
    #####: 1033:  ArrayRef<Type> funcArgTypes = getFunctionType().getInputs();
call    0 never executed
call    1 never executed
    #####: 1034:  for (unsigned i = 0; i < numFuncArguments; ++i) {
branch  0 never executed
branch  1 never executed
    #####: 1035:    Type blockArgType = front().getArgument(i).getType();
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1036:    if (funcArgTypes[i] != blockArgType)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1037:      return emitOpError() << "expected body region argument #" << i
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
call    5 never executed
    #####: 1038:                           << " to be of type " << funcArgTypes[i] << ", got "
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1039:                           << blockArgType;
call    0 never executed
        -: 1040:  }
        -: 1041:
    #####: 1042:  if (failed(verifyAttributions(getOperation(), getWorkgroupAttributions(),
call    0 never executed
call    1 never executed
    #####: 1043:                                GPUDialect::getWorkgroupAddressSpace())) ||
branch  0 never executed
branch  1 never executed
    #####: 1044:      failed(verifyAttributions(getOperation(), getPrivateAttributions(),
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -: 1045:                                GPUDialect::getPrivateAddressSpace())))
    #####: 1046:    return failure();
        -: 1047:
    #####: 1048:  return success();
        -: 1049:}
        -: 1050:
        -: 1051://===----------------------------------------------------------------------===//
        -: 1052:// ReturnOp
        -: 1053://===----------------------------------------------------------------------===//
        -: 1054:
function _ZN4mlir3gpu8ReturnOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1055:LogicalResult gpu::ReturnOp::verify() {
    #####: 1056:  GPUFuncOp function = (*this)->getParentOfType<GPUFuncOp>();
call    0 never executed
        -: 1057:
    #####: 1058:  FunctionType funType = function.getFunctionType();
call    0 never executed
        -: 1059:
    #####: 1060:  if (funType.getNumResults() != operands().size())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1061:    return emitOpError()
call    0 never executed
call    1 never executed
    #####: 1062:        .append("expected ", funType.getNumResults(), " result operands")
call    0 never executed
call    1 never executed
    #####: 1063:        .attachNote(function.getLoc())
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1064:        .append("return type declared here");
call    0 never executed
        -: 1065:
    #####: 1066:  for (const auto &pair : llvm::enumerate(
call    0 never executed
    #####: 1067:           llvm::zip(function.getFunctionType().getResults(), operands()))) {
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 1068:    auto [type, operand] = pair.value();
branch  0 never executed
branch  1 never executed
    #####: 1069:    if (type != operand.getType())
branch  0 never executed
branch  1 never executed
    #####: 1070:      return emitOpError() << "unexpected type `" << operand.getType()
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####: 1071:                           << "' for operand #" << pair.index();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1072:  }
    #####: 1073:  return success();
        -: 1074:}
        -: 1075:
        -: 1076://===----------------------------------------------------------------------===//
        -: 1077:// GPUModuleOp
        -: 1078://===----------------------------------------------------------------------===//
        -: 1079:
function _ZN4mlir3gpu11GPUModuleOp5buildERNS_9OpBuilderERNS_14OperationStateEN4llvm9StringRefE called 0 returned 0% blocks executed 0%
    #####: 1080:void GPUModuleOp::build(OpBuilder &builder, OperationState &result,
        -: 1081:                        StringRef name) {
    #####: 1082:  ensureTerminator(*result.addRegion(), builder, result.location);
call    0 never executed
call    1 never executed
    #####: 1083:  result.attributes.push_back(builder.getNamedAttr(
call    0 never executed
call    1 never executed
    #####: 1084:      ::mlir::SymbolTable::getSymbolAttrName(), builder.getStringAttr(name)));
call    0 never executed
call    1 never executed
    #####: 1085:}
        -: 1086:
function _ZN4mlir3gpu11GPUModuleOp5parseERNS_11OpAsmParserERNS_14OperationStateE called 0 returned 0% blocks executed 0%
    #####: 1087:ParseResult GPUModuleOp::parse(OpAsmParser &parser, OperationState &result) {
    #####: 1088:  StringAttr nameAttr;
    #####: 1089:  if (parser.parseSymbolName(nameAttr, mlir::SymbolTable::getSymbolAttrName(),
    #####: 1090:                             result.attributes) ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -: 1091:      // If module attributes are present, parse them.
    #####: 1092:      parser.parseOptionalAttrDictWithKeyword(result.attributes))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1093:    return failure();
        -: 1094:
        -: 1095:  // Parse the module body.
    #####: 1096:  auto *body = result.addRegion();
call    0 never executed
    #####: 1097:  if (parser.parseRegion(*body, {}))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1098:    return failure();
        -: 1099:
        -: 1100:  // Ensure that this module has a valid terminator.
    #####: 1101:  GPUModuleOp::ensureTerminator(*body, parser.getBuilder(), result.location);
call    0 never executed
call    1 never executed
    #####: 1102:  return success();
        -: 1103:}
        -: 1104:
function _ZN4mlir3gpu11GPUModuleOp5printERNS_12OpAsmPrinterE called 0 returned 0% blocks executed 0%
    #####: 1105:void GPUModuleOp::print(OpAsmPrinter &p) {
    #####: 1106:  p << ' ';
call    0 never executed
    #####: 1107:  p.printSymbolName(getName());
call    0 never executed
call    1 never executed
    #####: 1108:  p.printOptionalAttrDictWithKeyword((*this)->getAttrs(),
call    0 never executed
    #####: 1109:                                     {mlir::SymbolTable::getSymbolAttrName()});
call    0 never executed
    #####: 1110:  p << ' ';
call    0 never executed
    #####: 1111:  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
call    0 never executed
    #####: 1112:                /*printBlockTerminators=*/false);
call    0 never executed
    #####: 1113:}
        -: 1114:
        -: 1115://===----------------------------------------------------------------------===//
        -: 1116:// GPUMemcpyOp
        -: 1117://===----------------------------------------------------------------------===//
        -: 1118:
function _ZN4mlir3gpu8MemcpyOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1119:LogicalResult MemcpyOp::verify() {
    #####: 1120:  auto srcType = getSrc().getType();
call    0 never executed
call    1 never executed
    #####: 1121:  auto dstType = getDst().getType();
call    0 never executed
call    1 never executed
        -: 1122:
    #####: 1123:  if (getElementTypeOrSelf(srcType) != getElementTypeOrSelf(dstType))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1124:    return emitOpError("arguments have incompatible element type");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1125:
    #####: 1126:  if (failed(verifyCompatibleShape(srcType, dstType)))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1127:    return emitOpError("arguments have incompatible shape");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1128:
    #####: 1129:  return success();
        -: 1130:}
        -: 1131:
        -: 1132:namespace {
        -: 1133:
        -: 1134:/// Erases a common case of copy ops where a destination value is used only by
        -: 1135:/// the copy op, alloc and dealloc ops.
        -: 1136:struct EraseTrivialCopyOp : public OpRewritePattern<MemcpyOp> {
        -: 1137:  using OpRewritePattern<MemcpyOp>::OpRewritePattern;
        -: 1138:
function _ZNK12_GLOBAL__N_118EraseTrivialCopyOp15matchAndRewriteEN4mlir3gpu8MemcpyOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1139:  LogicalResult matchAndRewrite(MemcpyOp op,
        -: 1140:                                PatternRewriter &rewriter) const override {
    #####: 1141:    Value dest = op.getDst();
call    0 never executed
    #####: 1142:    Operation *destDefOp = dest.getDefiningOp();
call    0 never executed
        -: 1143:    // `dest` must be defined by an op having Allocate memory effect in order to
        -: 1144:    // perform the folding.
    #####: 1145:    if (!destDefOp ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1146:        !hasSingleEffect<MemoryEffects::Allocate>(destDefOp, dest))
call    0 never executed
    #####: 1147:      return failure();
        -: 1148:    // We can erase `op` iff `dest` has no other use apart from its
        -: 1149:    // use by `op` and dealloc ops.
    #####: 1150:    if (llvm::any_of(dest.getUsers(), [op, dest](Operation *user) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1151:          return user != op &&
        -: 1152:                 !hasSingleEffect<MemoryEffects::Free>(user, dest);
        -: 1153:        }))
    #####: 1154:      return failure();
        -: 1155:    // We can perform the folding if and only if op has a single async
        -: 1156:    // dependency and produces an async token as result, or if it does not have
        -: 1157:    // any async dependency and does not produce any async token result.
    #####: 1158:    if (op.getAsyncDependencies().size() > 1 ||
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1159:        ((op.getAsyncDependencies().empty() && op.getAsyncToken()) ||
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
    #####: 1160:         (!op.getAsyncDependencies().empty() && !op.getAsyncToken())))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1161:      return failure();
    #####: 1162:    rewriter.replaceOp(op, op.getAsyncDependencies());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1163:    return success();
        -: 1164:  }
        -: 1165:};
        -: 1166:
        -: 1167:} // end anonymous namespace
        -: 1168:
function _ZN4mlir3gpu8MemcpyOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 173 returned 100% blocks executed 100%
      173: 1169:void MemcpyOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1170:                                           MLIRContext *context) {
      173: 1171:  results.add<EraseTrivialCopyOp>(context);
call    0 returned 100%
      173: 1172:}
        -: 1173:
        -: 1174://===----------------------------------------------------------------------===//
        -: 1175:// GPU_SubgroupMmaLoadMatrixOp
        -: 1176://===----------------------------------------------------------------------===//
        -: 1177:
        -: 1178:/// Return true if the last dimension of the MemRefType has unit stride. Also
        -: 1179:/// return true for memrefs with no strides.
function _ZL25isLastMemrefDimUnitStrideN4mlir10MemRefTypeE called 0 returned 0% blocks executed 0%
    #####: 1180:static bool isLastMemrefDimUnitStride(MemRefType type) {
    #####: 1181:  int64_t offset;
    #####: 1182:  SmallVector<int64_t> strides;
call    0 never executed
    #####: 1183:  if (failed(getStridesAndOffset(type, strides, offset))) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1184:    return false;
        -: 1185:  }
    #####: 1186:  return strides.back() == 1;
call    0 never executed
        -: 1187:}
        -: 1188:
function _ZN4mlir3gpu23SubgroupMmaLoadMatrixOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1189:LogicalResult SubgroupMmaLoadMatrixOp::verify() {
    #####: 1190:  auto srcType = getSrcMemref().getType();
call    0 never executed
call    1 never executed
    #####: 1191:  auto resType = getRes().getType();
call    0 never executed
call    1 never executed
    #####: 1192:  auto resMatrixType = resType.cast<gpu::MMAMatrixType>();
call    0 never executed
    #####: 1193:  auto operand = resMatrixType.getOperand();
call    0 never executed
    #####: 1194:  auto srcMemrefType = srcType.cast<MemRefType>();
call    0 never executed
        -: 1195:
    #####: 1196:  if (!isLastMemrefDimUnitStride(srcMemrefType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1197:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1198:        "expected source memref most minor dim must have unit stride");
call    0 never executed
        -: 1199:
    #####: 1200:  if (!operand.equals("AOp") && !operand.equals("BOp") &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1201:      !operand.equals("COp"))
branch  0 never executed
branch  1 never executed
    #####: 1202:    return emitError("only AOp, BOp and COp can be loaded");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1203:
    #####: 1204:  return success();
        -: 1205:}
        -: 1206:
        -: 1207://===----------------------------------------------------------------------===//
        -: 1208:// GPU_SubgroupMmaStoreMatrixOp
        -: 1209://===----------------------------------------------------------------------===//
        -: 1210:
function _ZN4mlir3gpu24SubgroupMmaStoreMatrixOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1211:LogicalResult SubgroupMmaStoreMatrixOp::verify() {
    #####: 1212:  auto srcType = getSrc().getType();
call    0 never executed
call    1 never executed
    #####: 1213:  auto dstType = getDstMemref().getType();
call    0 never executed
call    1 never executed
    #####: 1214:  auto srcMatrixType = srcType.cast<gpu::MMAMatrixType>();
call    0 never executed
    #####: 1215:  auto dstMemrefType = dstType.cast<MemRefType>();
call    0 never executed
        -: 1216:
    #####: 1217:  if (!isLastMemrefDimUnitStride(dstMemrefType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1218:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1219:        "expected destination memref most minor dim must have unit stride");
call    0 never executed
        -: 1220:
    #####: 1221:  if (!srcMatrixType.getOperand().equals("COp"))
branch  0 never executed
branch  1 never executed
    #####: 1222:    return emitError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1223:        "expected the operand matrix being stored to have 'COp' operand type");
call    0 never executed
        -: 1224:
    #####: 1225:  return success();
        -: 1226:}
        -: 1227:
        -: 1228://===----------------------------------------------------------------------===//
        -: 1229:// GPU_SubgroupMmaComputeOp
        -: 1230://===----------------------------------------------------------------------===//
        -: 1231:
function _ZN4mlir3gpu20SubgroupMmaComputeOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1232:LogicalResult SubgroupMmaComputeOp::verify() {
    #####: 1233:  enum OperandMap { A, B, C };
    #####: 1234:  SmallVector<MMAMatrixType, 3> opTypes;
call    0 never executed
    #####: 1235:  opTypes.push_back(getOpA().getType().cast<MMAMatrixType>());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1236:  opTypes.push_back(getOpB().getType().cast<MMAMatrixType>());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1237:  opTypes.push_back(getOpC().getType().cast<MMAMatrixType>());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1238:
    #####: 1239:  if (!opTypes[A].getOperand().equals("AOp") ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1240:      !opTypes[B].getOperand().equals("BOp") ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1241:      !opTypes[C].getOperand().equals("COp"))
branch  0 never executed
branch  1 never executed
    #####: 1242:    return emitError("operands must be in the order AOp, BOp, COp");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1243:
    #####: 1244:  ArrayRef<int64_t> aShape, bShape, cShape;
    #####: 1245:  aShape = opTypes[A].getShape();
branch  0 never executed
branch  1 never executed
    #####: 1246:  bShape = opTypes[B].getShape();
    #####: 1247:  cShape = opTypes[C].getShape();
        -: 1248:
    #####: 1249:  if (aShape[1] != bShape[0] || aShape[0] != cShape[0] ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1250:      bShape[1] != cShape[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1251:    return emitError("operand shapes do not satisfy matmul constraints");
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -: 1252:
    #####: 1253:  return success();
branch  0 never executed
branch  1 never executed
        -: 1254:}
        -: 1255:
function _ZN4mlir3gpu8MemcpyOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1256:LogicalResult MemcpyOp::fold(ArrayRef<Attribute> operands,
        -: 1257:                             SmallVectorImpl<::mlir::OpFoldResult> &results) {
    #####: 1258:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 1259:}
        -: 1260:
function _ZN4mlir3gpu8MemsetOp4foldEN4llvm8ArrayRefINS_9AttributeEEERNS2_15SmallVectorImplINS_12OpFoldResultEEE called 0 returned 0% blocks executed 0%
    #####: 1261:LogicalResult MemsetOp::fold(ArrayRef<Attribute> operands,
        -: 1262:                             SmallVectorImpl<::mlir::OpFoldResult> &results) {
    #####: 1263:  return memref::foldMemRefCast(*this);
call    0 never executed
        -: 1264:}
        -: 1265:
        -: 1266://===----------------------------------------------------------------------===//
        -: 1267:// GPU_WaitOp
        -: 1268://===----------------------------------------------------------------------===//
        -: 1269:
        -: 1270:namespace {
        -: 1271:
        -: 1272:/// Remove gpu.wait op use of gpu.wait op def without async dependencies.
        -: 1273:/// %t = gpu.wait async []       // No async dependencies.
        -: 1274:/// ...  gpu.wait ... [%t, ...]  // %t can be removed.
        -: 1275:struct EraseRedundantGpuWaitOpPairs : public OpRewritePattern<WaitOp> {
        -: 1276:public:
        -: 1277:  using OpRewritePattern::OpRewritePattern;
        -: 1278:
function _ZNK12_GLOBAL__N_128EraseRedundantGpuWaitOpPairs15matchAndRewriteEN4mlir3gpu6WaitOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1279:  LogicalResult matchAndRewrite(WaitOp op,
        -: 1280:                                PatternRewriter &rewriter) const final {
function _ZZNK12_GLOBAL__N_128EraseRedundantGpuWaitOpPairs15matchAndRewriteEN4mlir3gpu6WaitOpERNS1_15PatternRewriterEENKUlNS1_5ValueEE_clES6_.isra.0 called 0 returned 0% blocks executed 0%
    #####: 1281:    auto predicate = [](Value value) {
    #####: 1282:      auto waitOp = value.getDefiningOp<WaitOp>();
call    0 never executed
    #####: 1283:      return waitOp && waitOp->getNumOperands() == 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1284:    };
    #####: 1285:    if (llvm::none_of(op.getAsyncDependencies(), predicate))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1286:      return failure();
    #####: 1287:    SmallVector<Value> validOperands;
call    0 never executed
    #####: 1288:    for (Value operand : op->getOperands()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
    #####: 1289:      if (predicate(operand))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1290:        continue;
    #####: 1291:      validOperands.push_back(operand);
call    0 never executed
        -: 1292:    }
    #####: 1293:    op->setOperands(validOperands);
call    0 never executed
call    1 never executed
    #####: 1294:    return success();
branch  0 never executed
branch  1 never executed
        -: 1295:  }
        -: 1296:};
        -: 1297:
        -: 1298:/// Simplify trivial gpu.wait ops for the following patterns.
        -: 1299:/// 1. %t = gpu.wait async ... ops, where %t has no uses (regardless of async
        -: 1300:/// dependencies).
        -: 1301:/// 2. %t1 = gpu.wait async [%t0], in this case, we can replace uses of %t1 with
        -: 1302:/// %t0.
        -: 1303:/// 3. gpu.wait [] ops, i.e gpu.wait ops that neither have any async
        -: 1304:/// dependencies nor return any token.
        -: 1305:struct SimplifyGpuWaitOp : public OpRewritePattern<WaitOp> {
        -: 1306:public:
        -: 1307:  using OpRewritePattern::OpRewritePattern;
        -: 1308:
function _ZNK12_GLOBAL__N_117SimplifyGpuWaitOp15matchAndRewriteEN4mlir3gpu6WaitOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1309:  LogicalResult matchAndRewrite(WaitOp op,
        -: 1310:                                PatternRewriter &rewriter) const final {
        -: 1311:    // Erase gpu.wait ops that neither have any async dependencies nor return
        -: 1312:    // any async token.
    #####: 1313:    if (op.getAsyncDependencies().empty() && !op.getAsyncToken()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1314:      rewriter.eraseOp(op);
call    0 never executed
    #####: 1315:      return success();
        -: 1316:    }
        -: 1317:    // Replace uses of %t1 = gpu.wait async [%t0] ops with %t0 and erase the op.
    #####: 1318:    if (llvm::hasSingleElement(op.getAsyncDependencies()) &&
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1319:        op.getAsyncToken()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1320:      rewriter.replaceOp(op, op.getAsyncDependencies());
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1321:      return success();
        -: 1322:    }
        -: 1323:    // Erase %t = gpu.wait async ... ops, where %t has no uses.
    #####: 1324:    if (op.getAsyncToken() && op.getAsyncToken().use_empty()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1325:      rewriter.eraseOp(op);
call    0 never executed
    #####: 1326:      return success();
        -: 1327:    }
    #####: 1328:    return failure();
        -: 1329:  }
        -: 1330:};
        -: 1331:
        -: 1332:} // end anonymous namespace
        -: 1333:
function _ZN4mlir3gpu6WaitOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 173 returned 100% blocks executed 100%
      173: 1334:void WaitOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1335:                                         MLIRContext *context) {
      173: 1336:  results.add<EraseRedundantGpuWaitOpPairs, SimplifyGpuWaitOp>(context);
call    0 returned 100%
      173: 1337:}
        -: 1338:
        -: 1339://===----------------------------------------------------------------------===//
        -: 1340:// GPU_AllocOp
        -: 1341://===----------------------------------------------------------------------===//
        -: 1342:
function _ZN4mlir3gpu7AllocOp6verifyEv called 0 returned 0% blocks executed 0%
    #####: 1343:LogicalResult AllocOp::verify() {
    #####: 1344:  auto memRefType = getMemref().getType().cast<MemRefType>();
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1345:
    #####: 1346:  if (static_cast<int64_t>(getDynamicSizes().size()) !=
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1347:      memRefType.getNumDynamicDims())
call    0 never executed
    #####: 1348:    return emitOpError("dimension operand count does not equal memref "
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1349:                       "dynamic dimension count");
call    0 never executed
        -: 1350:
    #####: 1351:  unsigned numSymbols = 0;
    #####: 1352:  if (!memRefType.getLayout().isIdentity())
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1353:    numSymbols = memRefType.getLayout().getAffineMap().getNumSymbols();
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1354:  if (getSymbolOperands().size() != numSymbols) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1355:    return emitOpError(
call    0 never executed
call    1 never executed
call    2 never executed
    #####: 1356:        "symbol operand count does not equal memref symbol count");
call    0 never executed
        -: 1357:  }
        -: 1358:
    #####: 1359:  return success();
        -: 1360:}
        -: 1361:
        -: 1362:namespace {
        -: 1363:
        -: 1364:/// Folding of memref.dim(gpu.alloc(%size), %idx) -> %size similar to
        -: 1365:/// `memref::AllocOp`.
        -: 1366:struct SimplifyDimOfAllocOp : public OpRewritePattern<memref::DimOp> {
        -: 1367:  using OpRewritePattern<memref::DimOp>::OpRewritePattern;
        -: 1368:
function _ZNK12_GLOBAL__N_120SimplifyDimOfAllocOp15matchAndRewriteEN4mlir6memref5DimOpERNS1_15PatternRewriterE called 0 returned 0% blocks executed 0%
    #####: 1369:  LogicalResult matchAndRewrite(memref::DimOp dimOp,
        -: 1370:                                PatternRewriter &rewriter) const override {
    #####: 1371:    auto index = dimOp.getIndex().getDefiningOp<arith::ConstantIndexOp>();
call    0 never executed
call    1 never executed
    #####: 1372:    if (!index)
branch  0 never executed
branch  1 never executed
    #####: 1373:      return failure();
        -: 1374:
    #####: 1375:    auto memrefType = dimOp.getSource().getType().dyn_cast<MemRefType>();
call    0 never executed
call    1 never executed
    #####: 1376:    if (!memrefType || !memrefType.isDynamicDim(index.value()))
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1377:      return failure();
        -: 1378:
    #####: 1379:    auto alloc = dimOp.getSource().getDefiningOp<AllocOp>();
call    0 never executed
call    1 never executed
    #####: 1380:    if (!alloc)
branch  0 never executed
branch  1 never executed
    #####: 1381:      return failure();
        -: 1382:
    #####: 1383:    Value substituteOp = *(alloc.getDynamicSizes().begin() +
call    0 never executed
    #####: 1384:                           memrefType.getDynamicDimIndex(index.value()));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1385:    rewriter.replaceOp(dimOp, substituteOp);
call    0 never executed
call    1 never executed
    #####: 1386:    return success();
        -: 1387:  }
        -: 1388:};
        -: 1389:
        -: 1390:} // namespace
        -: 1391:
function _ZN4mlir3gpu7AllocOp27getCanonicalizationPatternsERNS_17RewritePatternSetEPNS_11MLIRContextE called 173 returned 100% blocks executed 100%
      173: 1392:void AllocOp::getCanonicalizationPatterns(RewritePatternSet &results,
        -: 1393:                                          MLIRContext *context) {
      173: 1394:  results.add<SimplifyDimOfAllocOp>(context);
call    0 returned 100%
      173: 1395:}
        -: 1396:
        -: 1397:#include "mlir/Dialect/GPU/IR/GPUOpInterfaces.cpp.inc"
        -: 1398:#include "mlir/Dialect/GPU/IR/GPUOpsEnums.cpp.inc"
        -: 1399:
        -: 1400:#define GET_ATTRDEF_CLASSES
        -: 1401:#include "mlir/Dialect/GPU/IR/GPUOpsAttributes.cpp.inc"
        -: 1402:
        -: 1403:#define GET_OP_CLASSES
        -: 1404:#include "mlir/Dialect/GPU/IR/GPUOps.cpp.inc"
