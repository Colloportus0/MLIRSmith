        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/include/mlir/Analysis/DataFlow/DenseAnalysis.h
        -:    0:Graph:../tools/mlir/lib/Analysis/CMakeFiles/obj.MLIRAnalysis.dir/DataFlow/DenseAnalysis.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Analysis/CMakeFiles/obj.MLIRAnalysis.dir/DataFlow/DenseAnalysis.cpp.gcda
        -:    0:Runs:128638
        -:    1://===- DenseAnalysis.h - Dense data-flow analysis -------------------------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file implements dense data-flow analysis using the data-flow analysis
        -:   10:// framework. The analysis is forward and conditional and uses the results of
        -:   11:// dead code analysis to prune dead code during the analysis.
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef MLIR_ANALYSIS_DENSEDATAFLOWANALYSIS_H
        -:   16:#define MLIR_ANALYSIS_DENSEDATAFLOWANALYSIS_H
        -:   17:
        -:   18:#include "mlir/Analysis/DataFlowFramework.h"
        -:   19:
        -:   20:namespace mlir {
        -:   21:
        -:   22:class RegionBranchOpInterface;
        -:   23:
        -:   24:namespace dataflow {
        -:   25:
        -:   26://===----------------------------------------------------------------------===//
        -:   27:// AbstractDenseLattice
        -:   28://===----------------------------------------------------------------------===//
        -:   29:
        -:   30:/// This class represents a dense lattice. A dense lattice is attached to
        -:   31:/// operations to represent the program state after their execution or to blocks
        -:   32:/// to represent the program state at the beginning of the block. A dense
        -:   33:/// lattice is propagated through the IR by dense data-flow analysis.
        -:   34:class AbstractDenseLattice : public AnalysisState {
        -:   35:public:
        -:   36:  /// A dense lattice can only be created for operations and blocks.
        -:   37:  using AnalysisState::AnalysisState;
        -:   38:
        -:   39:  /// Join the lattice across control-flow or callgraph edges.
        -:   40:  virtual ChangeResult join(const AbstractDenseLattice &rhs) = 0;
        -:   41:};
        -:   42:
        -:   43://===----------------------------------------------------------------------===//
        -:   44:// AbstractDenseDataFlowAnalysis
        -:   45://===----------------------------------------------------------------------===//
        -:   46:
        -:   47:/// Base class for dense data-flow analyses. Dense data-flow analysis attaches a
        -:   48:/// lattice between the execution of operations and implements a transfer
        -:   49:/// function from the lattice before each operation to the lattice after. The
        -:   50:/// lattice contains information about the state of the program at that point.
        -:   51:///
        -:   52:/// In this implementation, a lattice attached to an operation represents the
        -:   53:/// state of the program after its execution, and a lattice attached to block
        -:   54:/// represents the state of the program right before it starts executing its
        -:   55:/// body.
        -:   56:class AbstractDenseDataFlowAnalysis : public DataFlowAnalysis {
        -:   57:public:
        -:   58:  using DataFlowAnalysis::DataFlowAnalysis;
        -:   59:
        -:   60:  /// Initialize the analysis by visiting every program point whose execution
        -:   61:  /// may modify the program state; that is, every operation and block.
        -:   62:  LogicalResult initialize(Operation *top) override;
        -:   63:
        -:   64:  /// Visit a program point that modifies the state of the program. If this is a
        -:   65:  /// block, then the state is propagated from control-flow predecessors or
        -:   66:  /// callsites. If this is a call operation or region control-flow operation,
        -:   67:  /// then the state after the execution of the operation is set by control-flow
        -:   68:  /// or the callgraph. Otherwise, this function invokes the operation transfer
        -:   69:  /// function.
        -:   70:  LogicalResult visit(ProgramPoint point) override;
        -:   71:
        -:   72:protected:
        -:   73:  /// Propagate the dense lattice before the execution of an operation to the
        -:   74:  /// lattice after its execution.
        -:   75:  virtual void visitOperationImpl(Operation *op,
        -:   76:                                  const AbstractDenseLattice &before,
        -:   77:                                  AbstractDenseLattice *after) = 0;
        -:   78:
        -:   79:  /// Get the dense lattice after the execution of the given program point.
        -:   80:  virtual AbstractDenseLattice *getLattice(ProgramPoint point) = 0;
        -:   81:
        -:   82:  /// Get the dense lattice after the execution of the given program point and
        -:   83:  /// add it as a dependency to a program point.
        -:   84:  const AbstractDenseLattice *getLatticeFor(ProgramPoint dependent,
        -:   85:                                            ProgramPoint point);
        -:   86:
        -:   87:  /// Set the dense lattice at control flow entry point and propagate an update
        -:   88:  /// if it changed.
        -:   89:  virtual void setToEntryState(AbstractDenseLattice *lattice) = 0;
        -:   90:
        -:   91:  /// Join a lattice with another and propagate an update if it changed.
function _ZN4mlir8dataflow29AbstractDenseDataFlowAnalysis4joinEPNS0_20AbstractDenseLatticeERKS2_ called 153218 returned 100% blocks executed 100%
   153218:   92:  void join(AbstractDenseLattice *lhs, const AbstractDenseLattice &rhs) {
   153218:   93:    propagateIfChanged(lhs, lhs->join(rhs));
call    0 returned 100%
call    1 returned 100%
   153218:   94:  }
        -:   95:
        -:   96:private:
        -:   97:  /// Visit an operation. If this is a call operation or region control-flow
        -:   98:  /// operation, then the state after the execution of the operation is set by
        -:   99:  /// control-flow or the callgraph. Otherwise, this function invokes the
        -:  100:  /// operation transfer function.
        -:  101:  void visitOperation(Operation *op);
        -:  102:
        -:  103:  /// Visit a block. The state at the start of the block is propagated from
        -:  104:  /// control-flow predecessors or callsites
        -:  105:  void visitBlock(Block *block);
        -:  106:
        -:  107:  /// Visit a program point within a region branch operation with predecessors
        -:  108:  /// in it. This can either be an entry block of one of the regions of the
        -:  109:  /// parent operation itself.
        -:  110:  void visitRegionBranchOperation(ProgramPoint point,
        -:  111:                                  RegionBranchOpInterface branch,
        -:  112:                                  AbstractDenseLattice *after);
        -:  113:};
        -:  114:
        -:  115://===----------------------------------------------------------------------===//
        -:  116:// DenseDataFlowAnalysis
        -:  117://===----------------------------------------------------------------------===//
        -:  118:
        -:  119:/// A dense (forward) data-flow analysis for propagating lattices before and
        -:  120:/// after the execution of every operation across the IR by implementing
        -:  121:/// transfer functions for operations.
        -:  122:///
        -:  123:/// `StateT` is expected to be a subclass of `AbstractDenseLattice`.
        -:  124:template <typename LatticeT>
        -:  125:class DenseDataFlowAnalysis : public AbstractDenseDataFlowAnalysis {
        -:  126:  static_assert(
        -:  127:      std::is_base_of<AbstractDenseLattice, LatticeT>::value,
        -:  128:      "analysis state class expected to subclass AbstractDenseLattice");
        -:  129:
        -:  130:public:
        -:  131:  using AbstractDenseDataFlowAnalysis::AbstractDenseDataFlowAnalysis;
        -:  132:
        -:  133:  /// Visit an operation with the dense lattice before its execution. This
        -:  134:  /// function is expected to set the dense lattice after its execution.
        -:  135:  virtual void visitOperation(Operation *op, const LatticeT &before,
        -:  136:                              LatticeT *after) = 0;
        -:  137:
        -:  138:protected:
        -:  139:  /// Get the dense lattice after this program point.
        -:  140:  LatticeT *getLattice(ProgramPoint point) override {
        -:  141:    return getOrCreate<LatticeT>(point);
        -:  142:  }
        -:  143:
        -:  144:  /// Set the dense lattice at control flow entry point and propagate an update
        -:  145:  /// if it changed.
        -:  146:  virtual void setToEntryState(LatticeT *lattice) = 0;
        -:  147:  void setToEntryState(AbstractDenseLattice *lattice) override {
        -:  148:    setToEntryState(static_cast<LatticeT *>(lattice));
        -:  149:  }
        -:  150:
        -:  151:private:
        -:  152:  /// Type-erased wrappers that convert the abstract dense lattice to a derived
        -:  153:  /// lattice and invoke the virtual hooks operating on the derived lattice.
        -:  154:  void visitOperationImpl(Operation *op, const AbstractDenseLattice &before,
        -:  155:                          AbstractDenseLattice *after) override {
        -:  156:    visitOperation(op, static_cast<const LatticeT &>(before),
        -:  157:                   static_cast<LatticeT *>(after));
        -:  158:  }
        -:  159:};
        -:  160:
        -:  161:} // end namespace dataflow
        -:  162:} // end namespace mlir
        -:  163:
        -:  164:#endif // MLIR_ANALYSIS_DENSEDATAFLOWANALYSIS_H
