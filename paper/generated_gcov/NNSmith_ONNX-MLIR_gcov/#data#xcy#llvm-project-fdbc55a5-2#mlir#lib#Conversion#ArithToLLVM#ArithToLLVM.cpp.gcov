        -:    0:Source:/data/xcy/llvm-project-fdbc55a5-2/mlir/lib/Conversion/ArithToLLVM/ArithToLLVM.cpp
        -:    0:Graph:../tools/mlir/lib/Conversion/ArithToLLVM/CMakeFiles/obj.MLIRArithToLLVM.dir/ArithToLLVM.cpp.gcno
        -:    0:Data:../tools/mlir/lib/Conversion/ArithToLLVM/CMakeFiles/obj.MLIRArithToLLVM.dir/ArithToLLVM.cpp.gcda
        -:    0:Runs:128633
        -:    1://===- ArithToLLVM.cpp - Arithmetic to LLVM dialect conversion -------===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:
        -:    9:#include "mlir/Conversion/ArithToLLVM/ArithToLLVM.h"
        -:   10:
        -:   11:#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
        -:   12:#include "mlir/Conversion/LLVMCommon/VectorPattern.h"
        -:   13:#include "mlir/Dialect/Arith/IR/Arith.h"
        -:   14:#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
        -:   15:#include "mlir/IR/TypeUtilities.h"
        -:   16:#include "mlir/Pass/Pass.h"
        -:   17:
        -:   18:namespace mlir {
        -:   19:#define GEN_PASS_DEF_ARITHTOLLVMCONVERSIONPASS
        -:   20:#include "mlir/Conversion/Passes.h.inc"
        -:   21:} // namespace mlir
        -:   22:
        -:   23:using namespace mlir;
        -:   24:
        -:   25:namespace {
        -:   26:
        -:   27:// Map arithmetic fastmath enum values to LLVMIR enum values.
        -:   28:static LLVM::FastmathFlags
function _ZN12_GLOBAL__N_1L31convertArithFastMathFlagsToLLVMEN4mlir5arith13FastMathFlagsE called 0 returned 0% blocks executed 0%
    #####:   29:convertArithFastMathFlagsToLLVM(arith::FastMathFlags arithFMF) {
    #####:   30:  LLVM::FastmathFlags llvmFMF{};
    #####:   31:  const std::pair<arith::FastMathFlags, LLVM::FastmathFlags> flags[] = {
        -:   32:      {arith::FastMathFlags::nnan, LLVM::FastmathFlags::nnan},
        -:   33:      {arith::FastMathFlags::ninf, LLVM::FastmathFlags::ninf},
        -:   34:      {arith::FastMathFlags::nsz, LLVM::FastmathFlags::nsz},
        -:   35:      {arith::FastMathFlags::arcp, LLVM::FastmathFlags::arcp},
        -:   36:      {arith::FastMathFlags::contract, LLVM::FastmathFlags::contract},
        -:   37:      {arith::FastMathFlags::afn, LLVM::FastmathFlags::afn},
        -:   38:      {arith::FastMathFlags::reassoc, LLVM::FastmathFlags::reassoc}};
    #####:   39:  for (auto fmfMap : flags) {
branch  0 never executed
branch  1 never executed
    #####:   40:    if (bitEnumContainsAny(arithFMF, fmfMap.first))
branch  0 never executed
branch  1 never executed
    #####:   41:      llvmFMF = llvmFMF | fmfMap.second;
        -:   42:  }
    #####:   43:  return llvmFMF;
        -:   44:}
        -:   45:
        -:   46:// Create an LLVM fastmath attribute from a given arithmetic fastmath attribute.
        -:   47:static LLVM::FastmathFlagsAttr
function _ZN12_GLOBAL__N_1L24convertArithFastMathAttrEN4mlir5arith17FastMathFlagsAttrE called 0 returned 0% blocks executed 0%
    #####:   48:convertArithFastMathAttr(arith::FastMathFlagsAttr fmfAttr) {
    #####:   49:  arith::FastMathFlags arithFMF = fmfAttr.getValue();
call    0 never executed
    #####:   50:  return LLVM::FastmathFlagsAttr::get(
    #####:   51:      fmfAttr.getContext(), convertArithFastMathFlagsToLLVM(arithFMF));
call    0 never executed
call    1 never executed
        -:   52:}
        -:   53:
        -:   54:// Attribute converter that populates a NamedAttrList by removing the fastmath
        -:   55:// attribute from the source operation attributes, and replacing it with an
        -:   56:// equivalent LLVM fastmath attribute.
        -:   57:template <typename SourceOp, typename TargetOp>
    #####:   58:class AttrConvertFastMath {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:   59:public:
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
        -:   71:    }
    #####:   72:  }
------------------
_ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6AddFOpENS1_4LLVM6FAddOpEEC2ES3_:
function _ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6AddFOpENS1_4LLVM6FAddOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
call    0 never executed
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
branch  0 never executed
branch  1 never executed
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
call    0 never executed
call    1 never executed
        -:   71:    }
    #####:   72:  }
------------------
_ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6DivFOpENS1_4LLVM6FDivOpEEC2ES3_:
function _ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6DivFOpENS1_4LLVM6FDivOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
call    0 never executed
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
branch  0 never executed
branch  1 never executed
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
call    0 never executed
call    1 never executed
        -:   71:    }
    #####:   72:  }
------------------
_ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6MulFOpENS1_4LLVM6FMulOpEEC2ES3_:
function _ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6MulFOpENS1_4LLVM6FMulOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
call    0 never executed
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
branch  0 never executed
branch  1 never executed
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
call    0 never executed
call    1 never executed
        -:   71:    }
    #####:   72:  }
------------------
_ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6NegFOpENS1_4LLVM6FNegOpEEC2ES3_:
function _ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6NegFOpENS1_4LLVM6FNegOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
call    0 never executed
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
branch  0 never executed
branch  1 never executed
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
call    0 never executed
call    1 never executed
        -:   71:    }
    #####:   72:  }
------------------
_ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6SubFOpENS1_4LLVM6FSubOpEEC2ES3_:
function _ZN12_GLOBAL__N_119AttrConvertFastMathIN4mlir5arith6SubFOpENS1_4LLVM6FSubOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   60:  AttrConvertFastMath(SourceOp srcOp) {
call    0 never executed
        -:   61:    // Copy the source attributes.
    #####:   62:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   63:    // Get the name of the arith fastmath attribute.
    #####:   64:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   65:    // Remove the source fastmath attribute.
    #####:   66:    auto arithFMFAttr = convertedAttr.erase(arithFMFAttrName)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   67:                            .template dyn_cast_or_null<arith::FastMathFlagsAttr>();
    #####:   68:    if (arithFMFAttr) {
branch  0 never executed
branch  1 never executed
        -:   69:      llvm::StringRef targetAttrName = TargetOp::getFastmathAttrName();
    #####:   70:      convertedAttr.set(targetAttrName, convertArithFastMathAttr(arithFMFAttr));
call    0 never executed
call    1 never executed
        -:   71:    }
    #####:   72:  }
------------------
        -:   73:
    #####:   74:  ArrayRef<NamedAttribute> getAttrs() const { return convertedAttr.getAttrs(); }
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   75:
        -:   76:private:
        -:   77:  NamedAttrList convertedAttr;
        -:   78:};
        -:   79:
        -:   80:// Attribute converter that populates a NamedAttrList by removing the fastmath
        -:   81:// attribute from the source operation attributes. This may be useful for
        -:   82:// target operations that do not require the fastmath attribute, or for targets
        -:   83:// that do not yet support the LLVM fastmath attribute.
        -:   84:template <typename SourceOp, typename TargetOp>
    #####:   85:class AttrDropFastMath {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   86:public:
    #####:   87:  AttrDropFastMath(SourceOp srcOp) {
        -:   88:    // Copy the source attributes.
    #####:   89:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
        -:   90:    // Get the name of the arith fastmath attribute.
    #####:   91:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   92:    // Remove the source fastmath attribute.
    #####:   93:    convertedAttr.erase(arithFMFAttrName);
    #####:   94:  }
------------------
_ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6MaxFOpENS1_4LLVM8MaxNumOpEEC2ES3_:
function _ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6MaxFOpENS1_4LLVM8MaxNumOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   87:  AttrDropFastMath(SourceOp srcOp) {
call    0 never executed
        -:   88:    // Copy the source attributes.
    #####:   89:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   90:    // Get the name of the arith fastmath attribute.
    #####:   91:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   92:    // Remove the source fastmath attribute.
    #####:   93:    convertedAttr.erase(arithFMFAttrName);
call    0 never executed
    #####:   94:  }
------------------
_ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6MinFOpENS1_4LLVM8MinNumOpEEC2ES3_:
function _ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6MinFOpENS1_4LLVM8MinNumOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   87:  AttrDropFastMath(SourceOp srcOp) {
call    0 never executed
        -:   88:    // Copy the source attributes.
    #####:   89:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   90:    // Get the name of the arith fastmath attribute.
    #####:   91:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   92:    // Remove the source fastmath attribute.
    #####:   93:    convertedAttr.erase(arithFMFAttrName);
call    0 never executed
    #####:   94:  }
------------------
_ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6RemFOpENS1_4LLVM6FRemOpEEC2ES3_:
function _ZN12_GLOBAL__N_116AttrDropFastMathIN4mlir5arith6RemFOpENS1_4LLVM6FRemOpEEC2ES3_ called 0 returned 0% blocks executed 0%
    #####:   87:  AttrDropFastMath(SourceOp srcOp) {
call    0 never executed
        -:   88:    // Copy the source attributes.
    #####:   89:    convertedAttr = NamedAttrList{srcOp->getAttrs()};
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
call    5 never executed
        -:   90:    // Get the name of the arith fastmath attribute.
    #####:   91:    llvm::StringRef arithFMFAttrName = SourceOp::getFastMathAttrName();
        -:   92:    // Remove the source fastmath attribute.
    #####:   93:    convertedAttr.erase(arithFMFAttrName);
call    0 never executed
    #####:   94:  }
------------------
        -:   95:
    #####:   96:  ArrayRef<NamedAttribute> getAttrs() const { return convertedAttr.getAttrs(); }
call    0 never executed
call    1 never executed
call    2 never executed
        -:   97:
        -:   98:private:
        -:   99:  NamedAttrList convertedAttr;
        -:  100:};
        -:  101:
        -:  102://===----------------------------------------------------------------------===//
        -:  103:// Straightforward Op Lowerings
        -:  104://===----------------------------------------------------------------------===//
        -:  105:
        -:  106:using AddFOpLowering = VectorConvertToLLVMPattern<arith::AddFOp, LLVM::FAddOp,
        -:  107:                                                  AttrConvertFastMath>;
        -:  108:using AddIOpLowering = VectorConvertToLLVMPattern<arith::AddIOp, LLVM::AddOp>;
        -:  109:using AndIOpLowering = VectorConvertToLLVMPattern<arith::AndIOp, LLVM::AndOp>;
        -:  110:using BitcastOpLowering =
        -:  111:    VectorConvertToLLVMPattern<arith::BitcastOp, LLVM::BitcastOp>;
        -:  112:using DivFOpLowering = VectorConvertToLLVMPattern<arith::DivFOp, LLVM::FDivOp,
        -:  113:                                                  AttrConvertFastMath>;
        -:  114:using DivSIOpLowering =
        -:  115:    VectorConvertToLLVMPattern<arith::DivSIOp, LLVM::SDivOp>;
        -:  116:using DivUIOpLowering =
        -:  117:    VectorConvertToLLVMPattern<arith::DivUIOp, LLVM::UDivOp>;
        -:  118:using ExtFOpLowering = VectorConvertToLLVMPattern<arith::ExtFOp, LLVM::FPExtOp>;
        -:  119:using ExtSIOpLowering =
        -:  120:    VectorConvertToLLVMPattern<arith::ExtSIOp, LLVM::SExtOp>;
        -:  121:using ExtUIOpLowering =
        -:  122:    VectorConvertToLLVMPattern<arith::ExtUIOp, LLVM::ZExtOp>;
        -:  123:using FPToSIOpLowering =
        -:  124:    VectorConvertToLLVMPattern<arith::FPToSIOp, LLVM::FPToSIOp>;
        -:  125:using FPToUIOpLowering =
        -:  126:    VectorConvertToLLVMPattern<arith::FPToUIOp, LLVM::FPToUIOp>;
        -:  127:// TODO: Add LLVM intrinsic support for fastmath
        -:  128:using MaxFOpLowering =
        -:  129:    VectorConvertToLLVMPattern<arith::MaxFOp, LLVM::MaxNumOp, AttrDropFastMath>;
        -:  130:using MaxSIOpLowering =
        -:  131:    VectorConvertToLLVMPattern<arith::MaxSIOp, LLVM::SMaxOp>;
        -:  132:using MaxUIOpLowering =
        -:  133:    VectorConvertToLLVMPattern<arith::MaxUIOp, LLVM::UMaxOp>;
        -:  134:// TODO: Add LLVM intrinsic support for fastmath
        -:  135:using MinFOpLowering =
        -:  136:    VectorConvertToLLVMPattern<arith::MinFOp, LLVM::MinNumOp, AttrDropFastMath>;
        -:  137:using MinSIOpLowering =
        -:  138:    VectorConvertToLLVMPattern<arith::MinSIOp, LLVM::SMinOp>;
        -:  139:using MinUIOpLowering =
        -:  140:    VectorConvertToLLVMPattern<arith::MinUIOp, LLVM::UMinOp>;
        -:  141:using MulFOpLowering = VectorConvertToLLVMPattern<arith::MulFOp, LLVM::FMulOp,
        -:  142:                                                  AttrConvertFastMath>;
        -:  143:using MulIOpLowering = VectorConvertToLLVMPattern<arith::MulIOp, LLVM::MulOp>;
        -:  144:using NegFOpLowering = VectorConvertToLLVMPattern<arith::NegFOp, LLVM::FNegOp,
        -:  145:                                                  AttrConvertFastMath>;
        -:  146:using OrIOpLowering = VectorConvertToLLVMPattern<arith::OrIOp, LLVM::OrOp>;
        -:  147:// TODO: Add LLVM intrinsic support for fastmath
        -:  148:using RemFOpLowering =
        -:  149:    VectorConvertToLLVMPattern<arith::RemFOp, LLVM::FRemOp, AttrDropFastMath>;
        -:  150:using RemSIOpLowering =
        -:  151:    VectorConvertToLLVMPattern<arith::RemSIOp, LLVM::SRemOp>;
        -:  152:using RemUIOpLowering =
        -:  153:    VectorConvertToLLVMPattern<arith::RemUIOp, LLVM::URemOp>;
        -:  154:using SelectOpLowering =
        -:  155:    VectorConvertToLLVMPattern<arith::SelectOp, LLVM::SelectOp>;
        -:  156:using ShLIOpLowering = VectorConvertToLLVMPattern<arith::ShLIOp, LLVM::ShlOp>;
        -:  157:using ShRSIOpLowering =
        -:  158:    VectorConvertToLLVMPattern<arith::ShRSIOp, LLVM::AShrOp>;
        -:  159:using ShRUIOpLowering =
        -:  160:    VectorConvertToLLVMPattern<arith::ShRUIOp, LLVM::LShrOp>;
        -:  161:using SIToFPOpLowering =
        -:  162:    VectorConvertToLLVMPattern<arith::SIToFPOp, LLVM::SIToFPOp>;
        -:  163:using SubFOpLowering = VectorConvertToLLVMPattern<arith::SubFOp, LLVM::FSubOp,
        -:  164:                                                  AttrConvertFastMath>;
        -:  165:using SubIOpLowering = VectorConvertToLLVMPattern<arith::SubIOp, LLVM::SubOp>;
        -:  166:using TruncFOpLowering =
        -:  167:    VectorConvertToLLVMPattern<arith::TruncFOp, LLVM::FPTruncOp>;
        -:  168:using TruncIOpLowering =
        -:  169:    VectorConvertToLLVMPattern<arith::TruncIOp, LLVM::TruncOp>;
        -:  170:using UIToFPOpLowering =
        -:  171:    VectorConvertToLLVMPattern<arith::UIToFPOp, LLVM::UIToFPOp>;
        -:  172:using XOrIOpLowering = VectorConvertToLLVMPattern<arith::XOrIOp, LLVM::XOrOp>;
        -:  173:
        -:  174://===----------------------------------------------------------------------===//
        -:  175:// Op Lowering Patterns
        -:  176://===----------------------------------------------------------------------===//
        -:  177:
        -:  178:/// Directly lower to LLVM op.
        -:  179:struct ConstantOpLowering : public ConvertOpToLLVMPattern<arith::ConstantOp> {
     3153:  180:  using ConvertOpToLLVMPattern::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  181:
        -:  182:  LogicalResult
        -:  183:  matchAndRewrite(arith::ConstantOp op, OpAdaptor adaptor,
        -:  184:                  ConversionPatternRewriter &rewriter) const override;
        -:  185:};
        -:  186:
        -:  187:/// The lowering of index_cast becomes an integer conversion since index
        -:  188:/// becomes an integer.  If the bit width of the source and target integer
        -:  189:/// types is the same, just erase the cast.  If the target type is wider,
        -:  190:/// sign-extend the value, otherwise truncate it.
        -:  191:template <typename OpTy, typename ExtCastTy>
        -:  192:struct IndexCastOpLowering : public ConvertOpToLLVMPattern<OpTy> {
     6306:  193:  using ConvertOpToLLVMPattern<OpTy>::ConvertOpToLLVMPattern;
call    0 returned 100%
call    1 returned 100%
        -:  194:
        -:  195:  LogicalResult
        -:  196:  matchAndRewrite(OpTy op, typename OpTy::Adaptor adaptor,
        -:  197:                  ConversionPatternRewriter &rewriter) const override;
        -:  198:};
        -:  199:
        -:  200:using IndexCastOpSILowering =
        -:  201:    IndexCastOpLowering<arith::IndexCastOp, LLVM::SExtOp>;
        -:  202:using IndexCastOpUILowering =
        -:  203:    IndexCastOpLowering<arith::IndexCastUIOp, LLVM::ZExtOp>;
        -:  204:
        -:  205:struct AddUICarryOpLowering
        -:  206:    : public ConvertOpToLLVMPattern<arith::AddUICarryOp> {
     3153:  207:  using ConvertOpToLLVMPattern::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  208:
        -:  209:  LogicalResult
        -:  210:  matchAndRewrite(arith::AddUICarryOp op, OpAdaptor adaptor,
        -:  211:                  ConversionPatternRewriter &rewriter) const override;
        -:  212:};
        -:  213:
        -:  214:struct CmpIOpLowering : public ConvertOpToLLVMPattern<arith::CmpIOp> {
     3153:  215:  using ConvertOpToLLVMPattern::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  216:
        -:  217:  LogicalResult
        -:  218:  matchAndRewrite(arith::CmpIOp op, OpAdaptor adaptor,
        -:  219:                  ConversionPatternRewriter &rewriter) const override;
        -:  220:};
        -:  221:
        -:  222:struct CmpFOpLowering : public ConvertOpToLLVMPattern<arith::CmpFOp> {
     3153:  223:  using ConvertOpToLLVMPattern::ConvertOpToLLVMPattern;
call    0 returned 100%
        -:  224:
        -:  225:  LogicalResult
        -:  226:  matchAndRewrite(arith::CmpFOp op, OpAdaptor adaptor,
        -:  227:                  ConversionPatternRewriter &rewriter) const override;
        -:  228:};
        -:  229:
        -:  230:} // namespace
        -:  231:
        -:  232://===----------------------------------------------------------------------===//
        -:  233:// ConstantOpLowering
        -:  234://===----------------------------------------------------------------------===//
        -:  235:
        -:  236:LogicalResult
function _ZNK12_GLOBAL__N_118ConstantOpLowering15matchAndRewriteEN4mlir5arith10ConstantOpENS2_17ConstantOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  237:ConstantOpLowering::matchAndRewrite(arith::ConstantOp op, OpAdaptor adaptor,
        -:  238:                                    ConversionPatternRewriter &rewriter) const {
    #####:  239:  return LLVM::detail::oneToOneRewrite(op, LLVM::ConstantOp::getOperationName(),
        -:  240:                                       adaptor.getOperands(), op->getAttrs(),
    #####:  241:                                       *getTypeConverter(), rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  242:}
        -:  243:
        -:  244://===----------------------------------------------------------------------===//
        -:  245:// IndexCastOpLowering
        -:  246://===----------------------------------------------------------------------===//
        -:  247:
        -:  248:template <typename OpTy, typename ExtCastTy>
    #####:  249:LogicalResult IndexCastOpLowering<OpTy, ExtCastTy>::matchAndRewrite(
        -:  250:    OpTy op, typename OpTy::Adaptor adaptor,
        -:  251:    ConversionPatternRewriter &rewriter) const {
    #####:  252:  Type resultType = op.getResult().getType();
    #####:  253:  Type targetElementType =
    #####:  254:      this->typeConverter->convertType(getElementTypeOrSelf(resultType));
    #####:  255:  Type sourceElementType =
    #####:  256:      this->typeConverter->convertType(getElementTypeOrSelf(op.getIn()));
    #####:  257:  unsigned targetBits = targetElementType.getIntOrFloatBitWidth();
    #####:  258:  unsigned sourceBits = sourceElementType.getIntOrFloatBitWidth();
        -:  259:
    #####:  260:  if (targetBits == sourceBits) {
    #####:  261:    rewriter.replaceOp(op, adaptor.getIn());
    #####:  262:    return success();
        -:  263:  }
        -:  264:
        -:  265:  // Handle the scalar and 1D vector cases.
    #####:  266:  Type operandType = adaptor.getIn().getType();
    #####:  267:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
    #####:  268:    Type targetType = this->typeConverter->convertType(resultType);
    #####:  269:    if (targetBits < sourceBits)
    #####:  270:      rewriter.replaceOpWithNewOp<LLVM::TruncOp>(op, targetType,
        -:  271:                                                 adaptor.getIn());
        -:  272:    else
    #####:  273:      rewriter.replaceOpWithNewOp<ExtCastTy>(op, targetType, adaptor.getIn());
    #####:  274:    return success();
        -:  275:  }
        -:  276:
    #####:  277:  if (!resultType.isa<VectorType>())
    #####:  278:    return rewriter.notifyMatchFailure(op, "expected vector result type");
        -:  279:
    #####:  280:  return LLVM::detail::handleMultidimensionalVectors(
    #####:  281:      op.getOperation(), adaptor.getOperands(), *(this->getTypeConverter()),
    #####:  282:      [&](Type llvm1DVectorTy, ValueRange operands) -> Value {
    #####:  283:        typename OpTy::Adaptor adaptor(operands);
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  284:        if (targetBits < sourceBits) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  285:          return rewriter.create<LLVM::TruncOp>(op.getLoc(), llvm1DVectorTy,
    #####:  286:                                                adaptor.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  287:        }
        -:  288:        return rewriter.create<ExtCastTy>(op.getLoc(), llvm1DVectorTy,
    #####:  289:                                          adaptor.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  290:      },
        -:  291:      rewriter);
        -:  292:}
------------------
_ZNK12_GLOBAL__N_119IndexCastOpLoweringIN4mlir5arith11IndexCastOpENS1_4LLVM6SExtOpEE15matchAndRewriteES3_NS2_18IndexCastOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_119IndexCastOpLoweringIN4mlir5arith11IndexCastOpENS1_4LLVM6SExtOpEE15matchAndRewriteES3_NS2_18IndexCastOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  249:LogicalResult IndexCastOpLowering<OpTy, ExtCastTy>::matchAndRewrite(
call    0 never executed
        -:  250:    OpTy op, typename OpTy::Adaptor adaptor,
        -:  251:    ConversionPatternRewriter &rewriter) const {
    #####:  252:  Type resultType = op.getResult().getType();
call    0 never executed
    #####:  253:  Type targetElementType =
call    0 never executed
    #####:  254:      this->typeConverter->convertType(getElementTypeOrSelf(resultType));
call    0 never executed
    #####:  255:  Type sourceElementType =
call    0 never executed
call    1 never executed
    #####:  256:      this->typeConverter->convertType(getElementTypeOrSelf(op.getIn()));
call    0 never executed
    #####:  257:  unsigned targetBits = targetElementType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  258:  unsigned sourceBits = sourceElementType.getIntOrFloatBitWidth();
call    0 never executed
        -:  259:
    #####:  260:  if (targetBits == sourceBits) {
branch  0 never executed
branch  1 never executed
    #####:  261:    rewriter.replaceOp(op, adaptor.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  262:    return success();
        -:  263:  }
        -:  264:
        -:  265:  // Handle the scalar and 1D vector cases.
    #####:  266:  Type operandType = adaptor.getIn().getType();
call    0 never executed
call    1 never executed
    #####:  267:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
branch  0 never executed
branch  1 never executed
    #####:  268:    Type targetType = this->typeConverter->convertType(resultType);
call    0 never executed
    #####:  269:    if (targetBits < sourceBits)
branch  0 never executed
branch  1 never executed
    #####:  270:      rewriter.replaceOpWithNewOp<LLVM::TruncOp>(op, targetType,
call    0 never executed
call    1 never executed
        -:  271:                                                 adaptor.getIn());
        -:  272:    else
    #####:  273:      rewriter.replaceOpWithNewOp<ExtCastTy>(op, targetType, adaptor.getIn());
call    0 never executed
call    1 never executed
    #####:  274:    return success();
        -:  275:  }
        -:  276:
    #####:  277:  if (!resultType.isa<VectorType>())
branch  0 never executed
branch  1 never executed
    #####:  278:    return rewriter.notifyMatchFailure(op, "expected vector result type");
call    0 never executed
        -:  279:
    #####:  280:  return LLVM::detail::handleMultidimensionalVectors(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  281:      op.getOperation(), adaptor.getOperands(), *(this->getTypeConverter()),
call    0 never executed
        -:  282:      [&](Type llvm1DVectorTy, ValueRange operands) -> Value {
        -:  283:        typename OpTy::Adaptor adaptor(operands);
        -:  284:        if (targetBits < sourceBits) {
        -:  285:          return rewriter.create<LLVM::TruncOp>(op.getLoc(), llvm1DVectorTy,
        -:  286:                                                adaptor.getIn());
        -:  287:        }
        -:  288:        return rewriter.create<ExtCastTy>(op.getLoc(), llvm1DVectorTy,
        -:  289:                                          adaptor.getIn());
        -:  290:      },
        -:  291:      rewriter);
        -:  292:}
------------------
_ZNK12_GLOBAL__N_119IndexCastOpLoweringIN4mlir5arith13IndexCastUIOpENS1_4LLVM6ZExtOpEE15matchAndRewriteES3_NS2_20IndexCastUIOpAdaptorERNS1_25ConversionPatternRewriterE:
function _ZNK12_GLOBAL__N_119IndexCastOpLoweringIN4mlir5arith13IndexCastUIOpENS1_4LLVM6ZExtOpEE15matchAndRewriteES3_NS2_20IndexCastUIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  249:LogicalResult IndexCastOpLowering<OpTy, ExtCastTy>::matchAndRewrite(
call    0 never executed
        -:  250:    OpTy op, typename OpTy::Adaptor adaptor,
        -:  251:    ConversionPatternRewriter &rewriter) const {
    #####:  252:  Type resultType = op.getResult().getType();
call    0 never executed
    #####:  253:  Type targetElementType =
call    0 never executed
    #####:  254:      this->typeConverter->convertType(getElementTypeOrSelf(resultType));
call    0 never executed
    #####:  255:  Type sourceElementType =
call    0 never executed
call    1 never executed
    #####:  256:      this->typeConverter->convertType(getElementTypeOrSelf(op.getIn()));
call    0 never executed
    #####:  257:  unsigned targetBits = targetElementType.getIntOrFloatBitWidth();
call    0 never executed
    #####:  258:  unsigned sourceBits = sourceElementType.getIntOrFloatBitWidth();
call    0 never executed
        -:  259:
    #####:  260:  if (targetBits == sourceBits) {
branch  0 never executed
branch  1 never executed
    #####:  261:    rewriter.replaceOp(op, adaptor.getIn());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  262:    return success();
        -:  263:  }
        -:  264:
        -:  265:  // Handle the scalar and 1D vector cases.
    #####:  266:  Type operandType = adaptor.getIn().getType();
call    0 never executed
call    1 never executed
    #####:  267:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
branch  0 never executed
branch  1 never executed
    #####:  268:    Type targetType = this->typeConverter->convertType(resultType);
call    0 never executed
    #####:  269:    if (targetBits < sourceBits)
branch  0 never executed
branch  1 never executed
    #####:  270:      rewriter.replaceOpWithNewOp<LLVM::TruncOp>(op, targetType,
call    0 never executed
call    1 never executed
        -:  271:                                                 adaptor.getIn());
        -:  272:    else
    #####:  273:      rewriter.replaceOpWithNewOp<ExtCastTy>(op, targetType, adaptor.getIn());
call    0 never executed
call    1 never executed
    #####:  274:    return success();
        -:  275:  }
        -:  276:
    #####:  277:  if (!resultType.isa<VectorType>())
branch  0 never executed
branch  1 never executed
    #####:  278:    return rewriter.notifyMatchFailure(op, "expected vector result type");
call    0 never executed
        -:  279:
    #####:  280:  return LLVM::detail::handleMultidimensionalVectors(
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  281:      op.getOperation(), adaptor.getOperands(), *(this->getTypeConverter()),
call    0 never executed
        -:  282:      [&](Type llvm1DVectorTy, ValueRange operands) -> Value {
        -:  283:        typename OpTy::Adaptor adaptor(operands);
        -:  284:        if (targetBits < sourceBits) {
        -:  285:          return rewriter.create<LLVM::TruncOp>(op.getLoc(), llvm1DVectorTy,
        -:  286:                                                adaptor.getIn());
        -:  287:        }
        -:  288:        return rewriter.create<ExtCastTy>(op.getLoc(), llvm1DVectorTy,
        -:  289:                                          adaptor.getIn());
        -:  290:      },
        -:  291:      rewriter);
        -:  292:}
------------------
        -:  293:
        -:  294://===----------------------------------------------------------------------===//
        -:  295:// AddUICarryOpLowering
        -:  296://===----------------------------------------------------------------------===//
        -:  297:
function _ZNK12_GLOBAL__N_120AddUICarryOpLowering15matchAndRewriteEN4mlir5arith12AddUICarryOpENS2_19AddUICarryOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  298:LogicalResult AddUICarryOpLowering::matchAndRewrite(
        -:  299:    arith::AddUICarryOp op, OpAdaptor adaptor,
        -:  300:    ConversionPatternRewriter &rewriter) const {
    #####:  301:  Type operandType = adaptor.getLhs().getType();
call    0 never executed
call    1 never executed
    #####:  302:  Type sumResultType = op.getSum().getType();
call    0 never executed
call    1 never executed
    #####:  303:  Type carryResultType = op.getCarry().getType();
call    0 never executed
call    1 never executed
        -:  304:
    #####:  305:  if (!LLVM::isCompatibleType(operandType))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  306:    return failure();
        -:  307:
    #####:  308:  MLIRContext *ctx = rewriter.getContext();
call    0 never executed
    #####:  309:  Location loc = op.getLoc();
call    0 never executed
        -:  310:
        -:  311:  // Handle the scalar and 1D vector cases.
    #####:  312:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  313:    Type newCarryType = typeConverter->convertType(carryResultType);
call    0 never executed
    #####:  314:    Type structType =
    #####:  315:        LLVM::LLVMStructType::getLiteral(ctx, {sumResultType, newCarryType});
call    0 never executed
    #####:  316:    Value addOverflow = rewriter.create<LLVM::UAddWithOverflowOp>(
    #####:  317:        loc, structType, adaptor.getLhs(), adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  318:    Value sumExtracted =
    #####:  319:        rewriter.create<LLVM::ExtractValueOp>(loc, addOverflow, 0);
call    0 never executed
call    1 never executed
    #####:  320:    Value carryExtracted =
    #####:  321:        rewriter.create<LLVM::ExtractValueOp>(loc, addOverflow, 1);
call    0 never executed
call    1 never executed
    #####:  322:    rewriter.replaceOp(op, {sumExtracted, carryExtracted});
call    0 never executed
call    1 never executed
    #####:  323:    return success();
        -:  324:  }
        -:  325:
    #####:  326:  if (!sumResultType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  327:    return rewriter.notifyMatchFailure(loc, "expected vector result types");
call    0 never executed
        -:  328:
    #####:  329:  return rewriter.notifyMatchFailure(loc,
    #####:  330:                                     "ND vector types are not supported yet");
call    0 never executed
        -:  331:}
        -:  332:
        -:  333://===----------------------------------------------------------------------===//
        -:  334:// CmpIOpLowering
        -:  335://===----------------------------------------------------------------------===//
        -:  336:
        -:  337:// Convert arith.cmp predicate into the LLVM dialect CmpPredicate. The two enums
        -:  338:// share numerical values so just cast.
        -:  339:template <typename LLVMPredType, typename PredType>
    #####:  340:static LLVMPredType convertCmpPredicate(PredType pred) {
        -:  341:  return static_cast<LLVMPredType>(pred);
        -:  342:}
        -:  343:
        -:  344:LogicalResult
function _ZNK12_GLOBAL__N_114CmpIOpLowering15matchAndRewriteEN4mlir5arith6CmpIOpENS2_13CmpIOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  345:CmpIOpLowering::matchAndRewrite(arith::CmpIOp op, OpAdaptor adaptor,
        -:  346:                                ConversionPatternRewriter &rewriter) const {
    #####:  347:  Type operandType = adaptor.getLhs().getType();
call    0 never executed
call    1 never executed
    #####:  348:  Type resultType = op.getResult().getType();
call    0 never executed
call    1 never executed
        -:  349:
        -:  350:  // Handle the scalar and 1D vector cases.
    #####:  351:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  352:    rewriter.replaceOpWithNewOp<LLVM::ICmpOp>(
    #####:  353:        op, typeConverter->convertType(resultType),
    #####:  354:        convertCmpPredicate<LLVM::ICmpPredicate>(op.getPredicate()),
call    0 never executed
call    1 never executed
    #####:  355:        adaptor.getLhs(), adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  356:    return success();
        -:  357:  }
        -:  358:
    #####:  359:  if (!resultType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  360:    return rewriter.notifyMatchFailure(op, "expected vector result type");
call    0 never executed
        -:  361:
    #####:  362:  return LLVM::detail::handleMultidimensionalVectors(
    #####:  363:      op.getOperation(), adaptor.getOperands(), *getTypeConverter(),
call    0 never executed
function _ZZNK12_GLOBAL__N_114CmpIOpLowering15matchAndRewriteEN4mlir5arith6CmpIOpENS2_13CmpIOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_4TypeENS1_10ValueRangeEE_clES7_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  364:      [&](Type llvm1DVectorTy, ValueRange operands) {
    #####:  365:        OpAdaptor adaptor(operands);
call    0 never executed
call    1 never executed
    #####:  366:        return rewriter.create<LLVM::ICmpOp>(
    #####:  367:            op.getLoc(), llvm1DVectorTy,
    #####:  368:            convertCmpPredicate<LLVM::ICmpPredicate>(op.getPredicate()),
call    0 never executed
    #####:  369:            adaptor.getLhs(), adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  370:      },
    #####:  371:      rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  372:}
        -:  373:
        -:  374://===----------------------------------------------------------------------===//
        -:  375:// CmpFOpLowering
        -:  376://===----------------------------------------------------------------------===//
        -:  377:
        -:  378:LogicalResult
function _ZNK12_GLOBAL__N_114CmpFOpLowering15matchAndRewriteEN4mlir5arith6CmpFOpENS2_13CmpFOpAdaptorERNS1_25ConversionPatternRewriterE called 0 returned 0% blocks executed 0%
    #####:  379:CmpFOpLowering::matchAndRewrite(arith::CmpFOp op, OpAdaptor adaptor,
        -:  380:                                ConversionPatternRewriter &rewriter) const {
    #####:  381:  Type operandType = adaptor.getLhs().getType();
call    0 never executed
call    1 never executed
    #####:  382:  Type resultType = op.getResult().getType();
call    0 never executed
call    1 never executed
        -:  383:
        -:  384:  // Handle the scalar and 1D vector cases.
    #####:  385:  if (!operandType.isa<LLVM::LLVMArrayType>()) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  386:    rewriter.replaceOpWithNewOp<LLVM::FCmpOp>(
    #####:  387:        op, typeConverter->convertType(resultType),
    #####:  388:        convertCmpPredicate<LLVM::FCmpPredicate>(op.getPredicate()),
call    0 never executed
call    1 never executed
    #####:  389:        adaptor.getLhs(), adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  390:    return success();
        -:  391:  }
        -:  392:
    #####:  393:  if (!resultType.isa<VectorType>())
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  394:    return rewriter.notifyMatchFailure(op, "expected vector result type");
call    0 never executed
        -:  395:
    #####:  396:  return LLVM::detail::handleMultidimensionalVectors(
    #####:  397:      op.getOperation(), adaptor.getOperands(), *getTypeConverter(),
call    0 never executed
function _ZZNK12_GLOBAL__N_114CmpFOpLowering15matchAndRewriteEN4mlir5arith6CmpFOpENS2_13CmpFOpAdaptorERNS1_25ConversionPatternRewriterEENKUlNS1_4TypeENS1_10ValueRangeEE_clES7_S8_.isra.0 called 0 returned 0% blocks executed 0%
    #####:  398:      [&](Type llvm1DVectorTy, ValueRange operands) {
    #####:  399:        OpAdaptor adaptor(operands);
call    0 never executed
call    1 never executed
    #####:  400:        return rewriter.create<LLVM::FCmpOp>(
    #####:  401:            op.getLoc(), llvm1DVectorTy,
    #####:  402:            convertCmpPredicate<LLVM::FCmpPredicate>(op.getPredicate()),
call    0 never executed
    #####:  403:            adaptor.getLhs(), adaptor.getRhs());
call    0 never executed
call    1 never executed
call    2 never executed
        -:  404:      },
    #####:  405:      rewriter);
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -:  406:}
        -:  407:
        -:  408://===----------------------------------------------------------------------===//
        -:  409:// Pass Definition
        -:  410://===----------------------------------------------------------------------===//
        -:  411:
        -:  412:namespace {
  129273*:  413:struct ArithToLLVMConversionPass
call    0 never executed
call    1 returned 100%
        -:  414:    : public impl::ArithToLLVMConversionPassBase<ArithToLLVMConversionPass> {
    #####:  415:  using Base::Base;
call    0 never executed
        -:  416:
function _ZN12_GLOBAL__N_125ArithToLLVMConversionPass14runOnOperationEv called 551 returned 100% blocks executed 88%
      551:  417:  void runOnOperation() override {
      551:  418:    LLVMConversionTarget target(getContext());
call    0 returned 100%
call    1 returned 100%
     1102:  419:    RewritePatternSet patterns(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  420:
     1102:  421:    LowerToLLVMOptions options(&getContext());
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
      551:  422:    if (indexBitwidth != kDeriveIndexBitwidthFromDataLayout)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  423:      options.overrideIndexBitwidth(indexBitwidth);
        -:  424:
     1102:  425:    LLVMTypeConverter converter(&getContext(), options);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
     1102:  426:    mlir::arith::populateArithToLLVMConversionPatterns(converter, patterns);
        -:  427:
      551:  428:    if (failed(applyPartialConversion(getOperation(), target,
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 returned 100%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
      551:  429:                                      std::move(patterns))))
call    0 returned 100%
    #####:  430:      signalPassFailure();
call    0 never executed
      551:  431:  }
        -:  432:};
        -:  433:} // namespace
        -:  434:
        -:  435://===----------------------------------------------------------------------===//
        -:  436:// Pattern Population
        -:  437://===----------------------------------------------------------------------===//
        -:  438:
function _ZN4mlir5arith37populateArithToLLVMConversionPatternsERNS_17LLVMTypeConverterERNS_17RewritePatternSetE called 2602 returned 100% blocks executed 100%
     3153:  439:void mlir::arith::populateArithToLLVMConversionPatterns(
        -:  440:    LLVMTypeConverter &converter, RewritePatternSet &patterns) {
        -:  441:  // clang-format off
     3153:  442:  patterns.add<
        -:  443:    AddFOpLowering,
        -:  444:    AddIOpLowering,
        -:  445:    AndIOpLowering,
        -:  446:    AddUICarryOpLowering,
        -:  447:    BitcastOpLowering,
        -:  448:    ConstantOpLowering,
        -:  449:    CmpFOpLowering,
        -:  450:    CmpIOpLowering,
        -:  451:    DivFOpLowering,
        -:  452:    DivSIOpLowering,
        -:  453:    DivUIOpLowering,
        -:  454:    ExtFOpLowering,
        -:  455:    ExtSIOpLowering,
        -:  456:    ExtUIOpLowering,
        -:  457:    FPToSIOpLowering,
        -:  458:    FPToUIOpLowering,
        -:  459:    IndexCastOpSILowering,
        -:  460:    IndexCastOpUILowering,
        -:  461:    MaxFOpLowering,
        -:  462:    MaxSIOpLowering,
        -:  463:    MaxUIOpLowering,
        -:  464:    MinFOpLowering,
        -:  465:    MinSIOpLowering,
        -:  466:    MinUIOpLowering,
        -:  467:    MulFOpLowering,
        -:  468:    MulIOpLowering,
        -:  469:    NegFOpLowering,
        -:  470:    OrIOpLowering,
        -:  471:    RemFOpLowering,
        -:  472:    RemSIOpLowering,
        -:  473:    RemUIOpLowering,
        -:  474:    SelectOpLowering,
        -:  475:    ShLIOpLowering,
        -:  476:    ShRSIOpLowering,
        -:  477:    ShRUIOpLowering,
        -:  478:    SIToFPOpLowering,
        -:  479:    SubFOpLowering,
        -:  480:    SubIOpLowering,
        -:  481:    TruncFOpLowering,
        -:  482:    TruncIOpLowering,
        -:  483:    UIToFPOpLowering,
        -:  484:    XOrIOpLowering
     3153:  485:  >(converter);
call    0 returned 100%
call    1 returned 100%
        -:  486:  // clang-format on
     2602:  487:}
